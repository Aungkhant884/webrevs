{"files":[{"patch":"@@ -12,0 +12,21 @@\n+\n+---\n+About Project Panama\n+===================\n+This repository contains changes which aim at improving the interoperability between the Java programming language and native libraries, which is one of the main goals of Project Panama. More information can be found at: https:\/\/openjdk.java.net\/projects\/panama\/\n+\n+The Project Panama JBS dashboard can be found at: https:\/\/bugs.openjdk.java.net\/Dashboard.jspa?selectPageId=18412\n+\n+Early acccess (EA) binary snapshots can be found at: http:\/\/jdk.java.net\/panama\/\n+\n+About the panama-foreign repository\n+===================\n+This repository houses two main branches:\n+- **foreign-memaccess+abi**: Contains the developement of both the foreign memory access API ([JEP 393](https:\/\/openjdk.java.net\/jeps\/393)) and the foreign linker API ([JEP 389](https:\/\/openjdk.java.net\/jeps\/389)). The former can be used to interact with different kinds of memory resources, including so-called off-heap or native memory. The latter can be used to call native code in a .dll\/.so\/.dylib, or to create a native function pointer to a Java method which can be passed to code in a native library. More information on how to use the memory access API and foreign linker API can be found [here](doc\/panama_memaccess.md) and [here](doc\/panama_ffi.md), respectively.\n+- **foreign-jextract**: Contains the development of an API to parse native headers, which can be used to create an abstract representation (declarations) from a C header file. This branch also provides an accompanying extraction tool (jextract), which is built on top of the API, and can be used to generate Java bindings to access functions and\/or structs in a native library described by a given header file. More information on how to use the jextract tool can be found [here](doc\/panama_jextract.md).\n+\n+The foreign-jextract branch depends on the foreign-memaccess+abi branch, which in turn depends on the master branch (which is kept periodically in sync with jdk\/jdk). As such, the foreign-jextract branch is the most complete of the three and therefore the default branch of this repository.\n+\n+Building notes\n+===================\n+Jextract requires [LLVM 9.x](https:\/\/releases.llvm.org\/download.html) as a dependency. So, to build the foreign-jextract branch, the flag `--with-libclang=\/path\/to\/llvm\/root` must be supplied when generating a build configuration. Please see [doc\/building.md](doc\/building.md) for general building instructions.\n","filename":"README.md","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,477 @@\n+## State of foreign function support\n+\n+**May 2021**\n+\n+**Maurizio Cimadamore**\n+\n+In this document we explore the main concepts behind Panama's foreign function support; as we shall see, the central abstraction in the foreign function support is the so called *foreign linker*, an abstraction that allows clients to construct *native* method handles — that is, method handles whose invocation targets a native function defined in some native library. In other words, Panama foreign function support is completely expressed in terms of Java code and no intermediate native code is required.\n+\n+### Native addresses\n+\n+Before we dive into the specifics of the foreign function support, it would be useful to briefly recap some of the main concepts we have learned when exploring the [foreign memory access support](panama_memaccess.md). The Foreign Memory Access API allows client to create and manipulate *memory segments*. A memory segment is a view over a memory source (either on- or off-heap) which is spatially bounded, temporally bounded and thread-confined. The guarantees ensure that dereferencing a segment that has been created by Java code is always *safe*, and can never result in a VM crash, or, worse, in silent memory corruption.\n+\n+Now, in the case of memory segments, the above properties (spatial bounds, temporal bounds and confinement) can be known *in full* when the segment is created. But when we interact with native libraries we will often be receiving *raw* pointers; such pointers have no spatial bounds (does a `char*` in C refer to one `char`, or a `char` array of a given size?), no notion of temporal bounds, nor thread-confinement. Raw addresses in our interop support are modeled using the `MemoryAddress` abstraction.\n+\n+A memory address is just what the name implies: it encapsulates a memory address (either on- or off-heap). Since, in order to dereference memory using a memory access var handle, we need a segment, it follows that it is *not* possible to directly dereference a memory address — to do that we need a segment first. So clients can proceed in three different ways here.\n+\n+First, if the memory address is known to belong to a segment the client *already* owns, a *rebase* operation can be performed; in other words, the client can ask the address what is its offset relative to a given segment, and then proceed to dereference the original segment accordingly:\n+\n+```java\n+MemorySegment segment = MemorySegment.allocateNative(100, ResourceScope.newImplicitScope());\n+...\n+MemoryAddress addr = ... \/\/obtain address from native code\n+int x = MemoryAccess.getIntAtOffset(segment, addr.segmentOffset(segment));    \n+```\n+\n+Secondly, if the client does *not* have a segment which contains a given memory address, it can create one *unsafely*, using the `MemoryAddress::asSegment`; this can also be useful to inject extra knowledge about spatial bounds which might be available in the native library the client is interacting with:\n+\n+```java\n+MemoryAddress addr = ... \/\/obtain address from native code\n+MemorySegment segment = addr.asSegment(100);\n+int x = MemoryAccess.getInt(segment);\n+```\n+\n+Alternatively, the client can fall back to use the so called *everything* segment - that is, a primordial segment which covers the entire native heap and whose scope is always alive (the so called *global scope*). Since this segment is available as a constant, dereference can happen without the need of creating any additional segment instances:\n+\n+```java\n+MemoryAddress addr = ... \/\/obtain address from native code\n+int x = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+```\n+\n+Of course, since accessing the entire native heap is inherently *unsafe*, accessing the *everything* segment is considered a *restricted* operation which is only allowed if the module performing the operation is listed in the  `--enable-native-access` command-line flag.\n+\n+`MemoryAddress`, like `MemorySegment` , implements the `Addressable` interface, which is a functional interface whose method projects an entity down to a `MemoryAddress` instance. In the case of `MemoryAddress` such a projection is the identity function; in the case of a memory segment, the projection returns the `MemoryAddres` instance for the segment's base address. This abstraction allows to pass either memory address or memory segments where an address is expected (this is especially useful when generating native bindings).\n+\n+### Segment allocators\n+\n+Idiomatic C code implicitly relies on stack allocation to allow for concise variable declarations; consider this example:\n+\n+```c\n+int arr[] = { 0, 1, 2, 3, 4 };\n+```\n+\n+A variable initializer such as the one above can be implemented as follows, using the Foreign Memory Access API:\n+\n+```java\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    MemorySegment arr = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(5, JAVA_INT), scope);\n+    for (int i = 0 ; i <= 5 ; i++) {\n+        MemoryAccess.setIntAtIndex(arr, i);\n+    }\n+}\n+```\n+\n+There are a number of issues with the above code snippet:\n+\n+* compared to the C code, it is more verbose - the native array has to be initialized *element by element*\n+* allocation is very slow compared to C; allocating the `arr` variable now takes a full `malloc`, while in C the variable was simply stack-allocated\n+* when having multiple declarations like the one above, it might become increasingly harder to manage the lifecycle of the various segments\n+\n+To address these problems, Panama provides a `SegmentAllocator` abstraction, a functional interface which provides many useful operation to allocate commonly used values. For instance, the above code can be rewritten as follows:\n+\n+```java\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    MemorySegment arr = SegmentAllocator.ofScope(scope).allocateArray(JAVA_INT, new int[] { 0, 1, 2, 3, 4 });\n+} \/\/ 'arr' is released here\n+```\n+\n+The above code obtains a  *scoped allocator* (an allocator built on top of `MemorySegment::allocateNative`), and then uses this allocator to create a native array which is initialized to the values `{ 0, 1, 2, 3, 4 }`.  The array initialization is more efficient, compared to the previous snippet, as the Java array is copied *in bulk* into the memory region associated with the newly allocated memory segment. The scoped allocator makes sure that all segments allocated with it are no longer usable after the scope associated with the allocator has been closed. This makes it easier to manage multiple resources which share the same lifecycle.\n+\n+Custom segment allocators are also critical to achieve optimal allocation performance; for this reason, a number of predefined allocators are available via factories in the `SegmentAllocator` interface. For instance, it is possible to create an arena-based allocator, as follows:\n+\n+```java\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+    for (int i = 0 ; i < 100 ; i++) {\n+        allocator.allocateArray(JAVA_INT, new int[] { 0, 1, 2, 3, 4 });\n+    }\n+    ...\n+} \/\/ all memory allocated is released here\n+```\n+\n+The above code creates a confined scope; inside the *try-with-resources*, a new unbounded arena allocation is created, associated with the existing scope. The allocator will allocate slabs of memory, of a specific size, and respond to allocation requests by returning different slices of the pre-allocated slab. If a slab does not have sufficient space to accommodate a new allocation request, a new one will be allocated. If the scope associated with the arena allocator is closed, all memory associated with the segments created by the allocator (see the body of the `for` loop) will be deallocated at once. This idiom combines the advantages of deterministic deallocation (provided by the Memory Access API) with a more flexible and scalable allocation scheme, and can be very useful when writing large applications.\n+\n+For these reasons, all the methods in the Foreign Linker API which *produce* memory segments (see `CLinker::toCString`), allow an optional allocator to be provided by user code — this is key in ensuring that an application using the Foreign Linker API achieves optimal allocation performances, especially in non-trivial use cases.\n+\n+### Symbol lookups\n+\n+The first ingredient of any foreign function support is a mechanism to lookup symbols in native libraries. In traditional Java\/JNI, this is done via the `System::loadLibrary` and `System::load` methods, which internally map into calls to `dlopen`. Unfortunately, these methods do not provide a way for clients to obtain the address associated with a given library symbol. For this reason, the Foreign Linker API introduces a new abstraction, namely `SymbolLookup` (similar in spirit to a method handle lookup),  which provides capabilities to lookup named symbols; we can obtain a symbol lookup in 2 different ways <a href=\"#1\"><sup>1<\/sup><\/a>:\n+\n+* `SymbolLookup::loaderLookup` — creates a symbol lookup which can be used to search symbols in all the libraries loaded by the caller's classloader (e.g. using `System::loadLibrary` or `System::load`)\n+* `CLinker::getSystemLookup`  — returns a platform-specific symbol lookup which can be used e.g. to search symbols in the standard C library\n+\n+Once a lookup has been obtained, a client can use it to retrieve handles to library symbols (either global variables or functions) using the `lookup(String)` method, which returns an  `Optional<MemoryAddress>`.\n+\n+For instance, the following code can be used to lookup the `clang_getClangVersion` function provided by the `clang` library:\n+\n+```java\n+System.loadLibrary(\"clang\");\n+MemoryAddress clangVersion = SymbolLookup.loaderLookup().lookup(\"clang_getClangVersion\").get();\n+```\n+\n+### C Linker\n+\n+At the core of Panama foreign function support we find the `CLinker` abstraction. This abstraction plays a dual role: first, for downcalls, it allows to model native function calls as plain `MethodHandle` calls (see `ForeignLinker::downcallHandle`); second, for upcalls, it allows to convert an existing `MethodHandle` (which might point to some Java method) into a `MemorySegment` which could then be passed to native functions as a function pointer (see `ForeignLinker::upcallStub`):\n+\n+```java\n+interface CLinker {\n+    MethodHandle downcallHandle(Addressable func, MethodType type, FunctionDescriptor function);\n+    MemorySegment upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);    \n+    ... \/\/ some overloads omitted here\n+\n+    static CLinker getInstance() { ... }\n+}\n+```\n+\n+In the following sections we will dive deeper into how downcall handles and upcall stubs are created; here we want to focus on the similarities between these two routines. First, both take a `FunctionDescriptor` instance — essentially an aggregate of memory layouts which is used to describe the signature of a foreign function in full. Speaking of C, the `CLinker` class defines many layout constants (one for each main C primitive type) — these layouts can be combined using a `FunctionDescriptor` to describe the signature of a C function. For instance, assuming we have a C function taking a `char*` and returning a `long` we can model such a function with the following descriptor:\n+\n+```java\n+FunctionDescriptor func = FunctionDescriptor.of(CLinker.C_LONG, CLinker.C_POINTER);\n+```\n+\n+The layouts used above will be mapped to the right layout according to the platform we are executing on. This also means that these layouts will be platform dependent and that e.g. `C_LONG` will be a 32 bit value layout on Windows, while being a 64-bit value on Linux.\n+\n+Layouts defined in the `CLinker` class are not only handy, as they already model the C types we want to work on; they also contain hidden pieces of information which the foreign linker support uses in order to compute the calling sequence associated with a given function descriptor. For instance, the two C types `int` and `float` might share a similar memory layout (they both are expressed as 32 bit values), but are typically passed using different machine registers. The layout attributes attached to the C-specific layouts in the `CLinker` class ensures that arguments and return values are interpreted in the correct way.\n+\n+Another similarity between `downcallHandle` and `upcallStub` is that they both accept (either directly, or indirectly) a `MethodType` instance. The method type describes the Java signatures that clients will be using when interacting with said downcall handles, or upcall stubs. The C linker implementation adds constraints on which layouts can be used with which Java carrier — for instance by enforcing that the size of the Java carrier is equal to that of the corresponding layout, or by making sure that certain layouts are associated with specific carriers. The following table shows the Java carrier vs. layout mappings enforced by the Linux\/macOS foreign linker implementation:\n+\n+| C layout      | Java carrier     |\n+| ------------- | ---------------- |\n+| `C_BOOL`      | `byte`           |\n+| `C_CHAR`      | `byte`           |\n+| `C_SHORT`     | `short`, `char`  |\n+| `C_INT`       | `int`            |\n+| `C_LONG`      | `long`           |\n+| `C_LONGLONG`  | `long`           |\n+| `C_FLOAT`     | `float`          |\n+| `C_DOUBLE`    | `double`         |\n+| `C_POINTER`   | `MemoryAddress`  |\n+| `GroupLayout` | `MemorySegment`  |\n+| `C_VALIST`    | `CLinker.VaList` |\n+\n+Aside from the mapping between primitive layout and primitive Java carriers (which might vary across platforms), it is important to note how all pointer layouts must correspond to a `MemoryAddress` carrier, whereas structs (whose layout is defined by a `GroupLayout`) must be associated with a `MemorySegment` carrier; there is also a layout\/carrier pair for native `va_list` (which are covered later in this document).\n+\n+### Downcalls\n+\n+We will now look at how foreign functions can be called from Java using the foreign linker abstraction. Assume we wanted to call the following function from the standard C library:\n+\n+```c\n+size_t strlen(const char *s);\n+```\n+\n+In order to do that, we have to:\n+\n+* lookup the `strlen` symbol\n+* describe the signature of the C function using the layouts in the `CLinker` class\n+\n+* select a Java signature we want to *overlay* on the native function — this will be the signature that clients of the native method handles will interact with\n+* create a *downcall* native method handle with the above information, using the standard C foreign linker\n+\n+Here's an example of how we might want to do that (a full listing of all the examples in this and subsequent sections will be provided in the [appendix](#appendix-full-source-code)):\n+\n+```java\n+MethodHandle strlen = CLinker.getInstance().downcallHandle(\n+\t\tCLinker.systemLookup().lookup(\"strlen\").get(),\n+        MethodType.methodType(long.class, MemoryAddress.class),\n+        FunctionDescriptor.of(C_LONG, C_POINTER)\n+);\n+```\n+\n+Note that, since the function `strlen` is part of the standard C library, which is loaded with the VM, we can just use the system lookup to look it up. The rest is pretty straightforward — the only tricky detail is how to model `size_t`: typically this type has the size of a pointer, so we can use `C_LONG` on Linux, but we'd have to use `C_LONGLONG` on Windows. On the Java side, we model the `size_t` using a `long` and the pointer is modeled using a `MemoryAddress` parameter.\n+\n+One we have obtained the downcall native method handle, we can just use it as any other method handle:\n+\n+```java\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    long len = strlen.invokeExact(CLinker.toCString(\"Hello\", scope).address()); \/\/ 5\n+}\n+```\n+\n+Here we are using one of the helper methods in `CLinker` to convert a Java string into an off-heap memory segment which contains a `NULL` terminated C string. We then pass that segment to the method handle and retrieve our result in a Java `long`. Note how all this has been possible *without* any piece of intervening native code — all the interop code can be expressed in (low level) Java. Note also how we used an explicit resource scope to control the lifecycle of the allocated C string, which ensures timely deallocation of the memory segment holding the native string.\n+\n+The `CLinker` interfaces also supports linking of native function without an address known at link time; when that happens, an address must be provided when the method handle returned by the linker is invoked - this is very useful to support *virtual calls*. For instance, the above code can be rewritten as follows:\n+\n+```java\n+MethodHandle strlen_virtual = CLinker.getInstance().downcallHandle( \/\/ address parameter missing!\n+\t\tMethodType.methodType(long.class, MemoryAddress.class),\n+        FunctionDescriptor.of(C_LONG, C_POINTER)\n+);\n+\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    long len = strlen_virtual.invokeExact(\n+        (Addressable)CLinker.systemLookup().lookup(\"strlen\").get() \/\/ address provided here!\n+        CLinker.toCString(\"Hello\", scope).address()\n+    ); \/\/ 5\n+}\n+```\n+\n+Now that we have seen the basics of how foreign function calls are supported in Panama, let's add some additional considerations. First, it is important to note that, albeit the interop code is written in Java, the above code can *not* be considered 100% safe. There are many arbitrary decisions to be made when setting up downcall method handles such as the one above, some of which might be obvious to us (e.g. how many parameters does the function take), but which cannot ultimately be verified by the Panama runtime. After all, a symbol in a dynamic library is, mostly a numeric offset and, unless we are using a shared library with debugging information, no type information is attached to a given library symbol. This means that, in this case, the Panama runtime has to *trust* our description of the `strlen` function. For this reason, access to the foreign linker is a restricted operation, which can only be performed if the requesting module is listed in the `--enable-native-access` command-line flag <a href=\"#2\"><sup>2<\/sup><\/a>.\n+\n+Certain functions might return pointers, or structs; it is important to realize that if a function returns a pointer (or a `MemoryAddress`), no life-cycle whatsoever is attached to that pointer. It is then up to the client to e.g. free the memory associated with that pointer, or do nothing (in case the library is responsible for the life-cycle of that pointer). If a library returns a struct by value, things are different, as a *fresh*, memory segment is allocated off-heap and returned to the callee. In such cases, the foreign linker API will request an additional prefix `SegmentAllocator` (see above) parameter which will be responsible for allocating the returned segment. The allocation will likely associate the segment with a *resource scope* that is known to the callee and which can then be used to release the memory associated with that segment. An additional overload of `downcallHandle` is also provided by `CLinker` where a client can specify which allocator should be used in such cases at *link-time*.\n+\n+Performance-wise, the reader might ask how efficient calling a foreign function using a native method handle is; the answer is *very*. The JVM comes with some special support for native method handles, so that, if a give method handle is invoked many times (e.g, inside an *hot* loop), the JIT compiler might decide to just generate a snippet of assembly code required to call the native function, and execute that directly. In most cases, invoking native function this way is as efficient as doing so through JNI <a href=\"#3\"><sup>3<\/sup><\/a>.\n+\n+### Upcalls\n+\n+Sometimes, it is useful to pass Java code as a function pointer to some native function; we can achieve that by using foreign linker support for upcalls. To demonstrate this, let's consider the following function from the C standard library:\n+\n+```c\n+void qsort(void *base, size_t nmemb, size_t size,\n+           int (*compar)(const void *, const void *));\n+```\n+\n+This is a function that can be used to sort the contents of an array, using a custom comparator function — `compar` — which is passed as a function pointer. To be able to call the `qsort` function from Java we have first to create a downcall native method handle for it:\n+\n+```java\n+MethodHandle qsort = CLinker.getInstance().downcallHandle(\n+\t\tCLinker.systemLookup().lookup(\"qsort\").get(),\n+        MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+        FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER)\n+);\n+```\n+\n+As before, we use `C_LONG` and `long.class` to map the C `size_t` type, and we use `MemoryAddess.class` both for the first pointer parameter (the array pointer) and the last parameter (the function pointer).\n+\n+This time, in order to invoke the `qsort` downcall handle, we need a *function pointer* to be passed as the last parameter; this is where the upcall support in foreign linker comes in handy, as it allows us to create a function pointer out of an existing method handle. First, let's write a function that can compare two int elements (passed as pointers):\n+\n+```java\n+class Qsort {\n+\tstatic int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+\t\treturn MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue()) - \n+\t    \t   MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue());\n+\t}\n+}\n+```\n+\n+Here we can see that the function is performing some *unsafe* dereference of the pointer contents, by using the *everything* segment.\n+\n+ Now let's create a method handle pointing to the comparator function above:\n+\n+```java\n+MethodHandle comparHandle = MethodHandles.lookup()\n+                                         .findStatic(Qsort.class, \"qsortCompare\",\n+                                                     MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+```\n+\n+Now that we have a method handle for our Java comparator function, we finally have all the ingredients to create an upcall segment, and pass it to the `qsort` downcall handle:\n+\n+```java\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    MemorySegment comparFunc = CLinker.getInstance().upcallStub(\n+        comparHandle,\n+    \tFunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+        scope);\n+    MemorySegment array = SegmentAllocator.ofScope(scope).allocateArray(new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 }));\n+    qsort.invokeExact(array.address(), 10L, 4L, comparFunc);\n+    int[] sorted = array.toIntArray(); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+}\n+```\n+\n+The above code creates  a memory segment — `comparFunc` — containing a stub that can be used to invoke our Java comparator function. The memory segment is associated with the provided resource scope instance; this means that the stub will be uninstalled when the resource scope is closed. It is also possible (not shown here) to create upcall stubs associated with an *implicit scope*, in which case the stub will be uninstalled when the upcall segment becomes *unreachable*.\n+\n+The snippet then creates an off-heap array from a Java array (using a `SegmentAllocator`), which is then passed to the `qsort` handle, along with the comparator function we obtained from the foreign linker.  As a side-effect, after the call, the contents of the off-heap array will be sorted (as instructed by our comparator function, written in Java). We can than extract a new Java array from the segment, which contains the sorted elements. This is a more advanced example, but one that shows how powerful the native interop support provided by the foreign linker abstraction is, allowing full bidirectional interop support between Java and native.\n+\n+### Varargs\n+\n+Some C functions are *variadic* and can take an arbitrary number of arguments. Perhaps the most common example of this is the `printf` function, defined in the C standard library:\n+\n+```c\n+int printf(const char *format, ...);\n+```\n+\n+This function takes a format string, which features zero or more *holes*, and then can take a number of additional arguments that is identical to the number of holes in the format string.\n+\n+The foreign function support can support variadic calls, but with a caveat: the client must provide a specialized Java signature, and a specialized description of the C signature. For instance, let's say we wanted to model the following C call:\n+\n+```C\n+printf(\"%d plus %d equals %d\", 2, 2, 4);\n+```\n+\n+To do this using the foreign function support provided by Panama we would have to build a *specialized* downcall handle for that call shape <a href=\"#4\"><sup>4<\/sup><\/a>:\n+\n+```java\n+MethodHandle printf = CLinker.getInstance().downcallHandle(\n+\t\tCLinker.systemLookup().lookup(\"printf\").get(),\n+        MethodType.methodType(int.class, MemoryAddress.class, int.class, int.class, int.class),\n+        FunctionDescriptor.of(C_INT, C_POINTER, C_INT, C_INT, C_INT)\n+);\n+```\n+\n+Then we can call the specialized downcall handle as usual:\n+\n+```java\n+printf.invoke(CLinker.toCString(\"%d plus %d equals %d\").address(), 2, 2, 4); \/\/prints \"2 plus 2 equals 4\"\n+```\n+\n+While this works, it is easy to see how such an approach is not very desirable:\n+\n+* If the variadic function needs to be called with many different shapes, we have to create many different downcall handles\n+* while this approach works for downcalls (since the Java code is in charge of determining which and how many arguments should be passed) it fails to scale to upcalls; in that case, the call comes from native code, so we have no way to guarantee that the shape of the upcall stub we have created will match that required by the native function.\n+\n+To mitigate these issues, the standard C foreign linker comes equipped with support for C variable argument lists — or `va_list`.  When a variadic function is called, C code has to unpack the variadic arguments by creating a `va_list` structure, and then accessing the variadic arguments through the `va_list` one by one (using the `va_arg` macro). To facilitate interop between standard variadic functions and `va_list` many C library functions in fact define *two* flavors of the same function, one using standard variadic signature, one using an extra `va_list` parameter. For instance, in the case of `printf` we can find that a `va_list`-accepting function performing the same task is also defined:\n+\n+```c\n+int vprintf(const char *format, va_list ap);\n+```\n+\n+The behavior of this function is the same as before — the only difference is that the ellipsis notation `...` has been replaced with a single `va_list` parameter; in other words, the function is no longer variadic.\n+\n+It is indeed fairly easy to create a downcall for `vprintf`:\n+\n+```java\n+MethodHandle vprintf = CLinker.getInstance().downcallHandle(\n+\t\tCLinker.systemLookup().lookup(\"vprintf\").get(),\n+\t\tMethodType.methodType(int.class, MemoryAddress.class, VaList.class),\n+        FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+```\n+\n+Here, the notable thing is that `CLinker` comes equipped with the special `C_VA_LIST` layout (the layout of a `va_list` parameter) as well as a `VaList` carrier, which can be used to construct and represent variable argument lists from Java code.\n+\n+To call the `vprintf` handle we need to create an instance of `VaList` which contains the arguments we want to pass to the `vprintf` function — we can do so, as follows:\n+\n+```java\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    vprintf.invoke(\n+            CLinker.toCString(\"%d plus %d equals %d\", scope).address(),\n+            VaList.make(builder ->\n+                            builder.vargFromInt(C_INT, 2)\n+                                   .vargFromInt(C_INT, 2)\n+                                   .vargFromInt(C_INT, 4), scope)\n+); \/\/prints \"2 plus 2 equals 4\"\n+```\n+\n+While the callee has to do more work to call the `vprintf` handle, note that that now we're back in a place where the downcall handle  `vprintf` can be shared across multiple callees. Note that both the format string and the `VaList` are associated with the given resource scope — this means that both will remain valid throughout the native function call. As for other APIs, it is also possible (not shown here) to create a `VaList` associated with an *implicit scope* - meaning that the resources allocated by the `VaList` will remain available as long as the `VaList` remains *reachable*.\n+\n+Another advantage of using `VaList` is that this approach also scales to upcall stubs — it is therefore possible for clients to create upcalls stubs which take a `VaList` and then, from the Java upcall, read the arguments packed inside the `VaList` one by one using the methods provided by the `VaList` API (e.g. `VaList::vargAsInt(MemoryLayout)`), which mimic the behavior of the C `va_arg` macro.\n+\n+### Appendix: full source code\n+\n+The full source code containing most of the code shown throughout this document can be seen below:\n+\n+```java\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class Examples {\n+\n+    public static void main(String[] args) throws Throwable {\n+        strlen();\n+        strlen_virtual();\n+        qsort();\n+        printf();\n+        vprintf();\n+    }\n+\n+    public static void strlen() throws Throwable {\n+        MethodHandle strlen = CLinker.getInstance().downcallHandle(\n+                CLinker.systemLookup().lookup(\"strlen\").get(),\n+                MethodType.methodType(long.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_LONG, C_POINTER)\n+        );\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment hello = CLinker.toCString(\"Hello\", scope);\n+            long len = (long) strlen.invokeExact(hello.address()); \/\/ 5\n+            System.out.println(len);\n+        }\n+    }\n+\n+    public static void strlen_virtual() throws Throwable {\n+        MethodHandle strlen_virtual = CLinker.getInstance().downcallHandle(\n+                MethodType.methodType(long.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_LONG, C_POINTER)\n+        );\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment hello = CLinker.toCString(\"Hello\", scope);\n+            long len = (long) strlen_virtual.invokeExact(\n+                (Addressable)CLinker.systemLookup().lookup(\"strlen\").get(),\n+                hello.address()); \/\/ 5\n+            System.out.println(len);\n+        }\n+    }\n+\n+    static class Qsort {\n+        static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+            int v1 = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue());\n+            int v2 = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue());\n+            return v1 - v2;\n+        }\n+    }\n+\n+    public static void qsort() throws Throwable {\n+        MethodHandle qsort = CLinker.getInstance().downcallHandle(\n+                CLinker.systemLookup().lookup(\"qsort\").get(),\n+                MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_LONG, C_LONG, C_POINTER)\n+        );\n+\n+        MethodHandle comparHandle = MethodHandles.lookup()\n+                .findStatic(Qsort.class, \"qsortCompare\",\n+                        MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress comparFunc = CLinker.getInstance().upcallStub(\n+                comparHandle,\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER), scope);\n+\n+            MemorySegment array = SegmentAllocator.ofScope(scope)\n+                                                  .allocateArray(C_INT, new int[] { 0, 9, 3, 4, 6, 5, 1, 8, 2, 7 });\n+            qsort.invokeExact(array.address(), 10L, 4L, comparFunc);\n+            int[] sorted = array.toIntArray(); \/\/ [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]\n+            System.out.println(Arrays.toString(sorted));\n+        }\n+    }\n+\n+    public static void printf() throws Throwable {\n+        MethodHandle printf = CLinker.getInstance().downcallHandle(\n+                CLinker.systemLookup().lookup(\"printf\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class, int.class, int.class, int.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_INT, C_INT, C_INT)\n+        );\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = CLinker.toCString(\"%d plus %d equals %d\\n\", scope);\n+            printf.invoke(s.address(), 2, 2, 4);\n+        }\n+    }\n+\n+    public static void vprintf() throws Throwable {\n+\n+        MethodHandle vprintf = CLinker.getInstance().downcallHandle(\n+                CLinker.systemLookup().lookup(\"vprintf\").get(),\n+                MethodType.methodType(int.class, MemoryAddress.class, CLinker.VaList.class),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = CLinker.toCString(\"%d plus %d equals %d\\n\", scope);\n+            CLinker.VaList vlist = CLinker.VaList.make(builder ->\n+                     builder.vargFromInt(C_INT, 2)\n+                            .vargFromInt(C_INT, 2)\n+                            .vargFromInt(C_INT, 4), scope);\n+            vprintf.invoke(s.address(), vlist);\n+        }\n+    }\n+}\n+```\n+\n+\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In the future, we might add more ways to obtain a symbol lookup - for instance:   ```  SymbolLookup.ofLibrary(String libName, ResourceScope scope)   ``` . This would  allow developers to load a  library and associate its lifecycle with a `ResourceScope` (rather than  a classloader). That is, when the scope is closed, the library will be  unloaded. However, adding these new mode will require some additional  foundational work on the `CLinker` support - as we need to make sure  that the memory address used by a downcall method handle cannot be  unloaded while the downcall method handle is being invoked.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> In reality this is not entirely new; even in JNI, when you call a `native` method the VM trusts that the corresponding implementing function in C will feature compatible parameter types and return values; if not a crash might occur.<\/small>\n+* <a id=\"3\"\/>(<sup>3<\/sup>):<small> As an advanced option, Panama allows the user to opt-in to remove Java to native thread transitions; while, in the general case it is unsafe doing so (removing thread transitions could have a negative impact on GC for long running native functions, and could crash the VM if the downcall needs to pop back out in Java, e.g. via an upcall), greater efficiency can be achieved; performance sensitive users should consider this option at least for the functions that are called more frequently, assuming that these functions are *leaf* functions (e.g. do not go back to Java via an upcall) and are relatively short-lived.<\/small>\n+* <a id=\"4\"\/>(<sup>4<\/sup>):<small> On Windows, layouts for variadic arguments have to be adjusted using the `CLinker.Win64.asVarArg(ValueLayout)`; this is necessary because the Windows ABI passes variadic arguments using different rules than the ones used for ordinary arguments.<\/small>\n+\n","filename":"doc\/panama_ffi.md","additions":477,"deletions":0,"binary":false,"changes":477,"status":"added"},{"patch":"@@ -0,0 +1,992 @@\n+<!DOCTYPE html>\n+<html xmlns=\"http:\/\/www.w3.org\/1999\/xhtml\" lang=\"\" xml:lang=\"\">\n+<head>\n+  <meta charset=\"utf-8\" \/>\n+  <meta name=\"generator\" content=\"pandoc\" \/>\n+  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, user-scalable=yes\" \/>\n+  <title>panama_jextract<\/title>\n+  <style>\n+    code{white-space: pre-wrap;}\n+    span.smallcaps{font-variant: small-caps;}\n+    span.underline{text-decoration: underline;}\n+    div.column{display: inline-block; vertical-align: top; width: 50%;}\n+    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}\n+    ul.task-list{list-style: none;}\n+    pre > code.sourceCode { white-space: pre; position: relative; }\n+    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }\n+    pre > code.sourceCode > span:empty { height: 1.2em; }\n+    code.sourceCode > span { color: inherit; text-decoration: inherit; }\n+    div.sourceCode { margin: 1em 0; }\n+    pre.sourceCode { margin: 0; }\n+    @media screen {\n+    div.sourceCode { overflow: auto; }\n+    }\n+    @media print {\n+    pre > code.sourceCode { white-space: pre-wrap; }\n+    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }\n+    }\n+    pre.numberSource code\n+      { counter-reset: source-line 0; }\n+    pre.numberSource code > span\n+      { position: relative; left: -4em; counter-increment: source-line; }\n+    pre.numberSource code > span > a:first-child::before\n+      { content: counter(source-line);\n+        position: relative; left: -1em; text-align: right; vertical-align: baseline;\n+        border: none; display: inline-block;\n+        -webkit-touch-callout: none; -webkit-user-select: none;\n+        -khtml-user-select: none; -moz-user-select: none;\n+        -ms-user-select: none; user-select: none;\n+        padding: 0 4px; width: 4em;\n+        color: #aaaaaa;\n+      }\n+    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\n+    div.sourceCode\n+      {   }\n+    @media screen {\n+    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }\n+    }\n+    code span.al { color: #ff0000; font-weight: bold; } \/* Alert *\/\n+    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Annotation *\/\n+    code span.at { color: #7d9029; } \/* Attribute *\/\n+    code span.bn { color: #40a070; } \/* BaseN *\/\n+    code span.bu { } \/* BuiltIn *\/\n+    code span.cf { color: #007020; font-weight: bold; } \/* ControlFlow *\/\n+    code span.ch { color: #4070a0; } \/* Char *\/\n+    code span.cn { color: #880000; } \/* Constant *\/\n+    code span.co { color: #60a0b0; font-style: italic; } \/* Comment *\/\n+    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } \/* CommentVar *\/\n+    code span.do { color: #ba2121; font-style: italic; } \/* Documentation *\/\n+    code span.dt { color: #902000; } \/* DataType *\/\n+    code span.dv { color: #40a070; } \/* DecVal *\/\n+    code span.er { color: #ff0000; font-weight: bold; } \/* Error *\/\n+    code span.ex { } \/* Extension *\/\n+    code span.fl { color: #40a070; } \/* Float *\/\n+    code span.fu { color: #06287e; } \/* Function *\/\n+    code span.im { } \/* Import *\/\n+    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Information *\/\n+    code span.kw { color: #007020; font-weight: bold; } \/* Keyword *\/\n+    code span.op { color: #666666; } \/* Operator *\/\n+    code span.ot { color: #007020; } \/* Other *\/\n+    code span.pp { color: #bc7a00; } \/* Preprocessor *\/\n+    code span.sc { color: #4070a0; } \/* SpecialChar *\/\n+    code span.ss { color: #bb6688; } \/* SpecialString *\/\n+    code span.st { color: #4070a0; } \/* String *\/\n+    code span.va { color: #19177c; } \/* Variable *\/\n+    code span.vs { color: #4070a0; } \/* VerbatimString *\/\n+    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } \/* Warning *\/\n+  <\/style>\n+  <link rel=\"stylesheet\" href=\"..\/make\/data\/docs-resources\/resources\/jdk-default.css\" \/>\n+  <!--[if lt IE 9]>\n+    <script src=\"\/\/cdnjs.cloudflare.com\/ajax\/libs\/html5shiv\/3.7.3\/html5shiv-printshiv.min.js\"><\/script>\n+  <![endif]-->\n+<\/head>\n+<body>\n+<nav id=\"TOC\" role=\"doc-toc\">\n+<ul>\n+<li><a href=\"#using-the-jextract-tool\">Using the <code>jextract<\/code> tool<\/a>\n+<ul>\n+<li><a href=\"#hello-world\">Hello World<\/a>\n+<ul>\n+<li><a href=\"#hello-world-c-header-helloworld.h\">Hello World C Header (helloworld.h)<\/a><\/li>\n+<li><a href=\"#hello-world-c-source-helloworld.c\">Hello World C Source (helloworld.c)<\/a><\/li>\n+<li><a href=\"#building-hello-world\">Building Hello World<\/a><\/li>\n+<li><a href=\"#jextract-a-jar-file-for-helloworld.h\">jextract a Jar file for helloworld.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-extracted-helloworld-interface\">Java program that uses extracted helloworld interface<\/a><\/li>\n+<li><a href=\"#running-the-java-code-that-invokes-helloworld\">Running the Java code that invokes helloworld<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#embedding-python-interpreter-in-your-java-program-mac-os\">Embedding Python interpreter in your Java program (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#jextract-python.h\">jextract Python.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-extracted-python-interface\">Java program that uses extracted Python interface<\/a><\/li>\n+<li><a href=\"#running-the-java-code-that-calls-python-interpreter\">Running the Java code that calls Python interpreter<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-readline-library-from-java-code-mac-os\">Using readline library from Java code (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#jextract-readline.h\">jextract readline.h<\/a><\/li>\n+<li><a href=\"#java-code-that-uses-readline\">Java code that uses readline<\/a><\/li>\n+<li><a href=\"#running-the-java-code-that-uses-readline\">Running the java code that uses readline<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-libcurl-from-java-mac-os\">Using libcurl from Java (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#jextract-curl.h\">jextract curl.h<\/a><\/li>\n+<li><a href=\"#java-code-that-uses-libcurl\">Java code that uses libcurl<\/a><\/li>\n+<li><a href=\"#running-the-java-code-that-uses-libcurl\">Running the java code that uses libcurl<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-blas-library\">Using BLAS library<\/a>\n+<ul>\n+<li><a href=\"#installing-openblas-mac-os\">Installing OpenBLAS (Mac OS)<\/a><\/li>\n+<li><a href=\"#jextracting-cblas.h-macos\">jextracting cblas.h (MacOS)<\/a><\/li>\n+<li><a href=\"#java-sample-code-that-uses-cblas-library\">Java sample code that uses cblas library<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-above-blas-sample\">Compiling and running the above BLAS sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-lapack-library-mac-os\">Using LAPACK library (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#jextracting-lapacke.h\">jextracting lapacke.h<\/a><\/li>\n+<li><a href=\"#java-sample-code-that-uses-lapack-library\">Java sample code that uses LAPACK library<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-above-lapack-sample\">Compiling and running the above LAPACK sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-libproc-library-to-list-processes-from-java-mac-os\">Using libproc library to list processes from Java (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#jextract-libproc.h\">jextract libproc.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-libproc-to-list-processes\">Java program that uses libproc to list processes<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-libproc-sample\">Compiling and running the libproc sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-libgit2-from-java-mac-os\">Using libgit2 from Java (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#getting-and-building-libgit2\">Getting and building libgit2<\/a><\/li>\n+<li><a href=\"#jextract-git2.h\">jextract git2.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-libgit2-to-clone-github-repo\">Java program that uses libgit2 to clone github repo<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-libgit2-sample\">Compiling and running the libgit2 sample<\/a><\/li>\n+<li><a href=\"#cloning-a-github-repo-using-the-above-run.sh-command\">Cloning a github repo using the above run.sh command<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-sqlite3-library-from-java-mac-os\">Using sqlite3 library from Java (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#jextract-sqlite3.h\">jextract sqlite3.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-sqlite3\">Java program that uses sqlite3<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-sqlite3-sample\">Compiling and running the sqlite3 sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-opengl-library-from-java-mac-os\">Using OpenGL library from Java (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#jextract-glut.h\">jextract glut.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-opengl\">Java program that uses OpenGL<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-opengl-sample\">Compiling and running the OpenGL sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-tensorflow-mac-os\">Using tensorflow (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#getting-libtensorflow\">getting libtensorflow<\/a><\/li>\n+<li><a href=\"#jextract-c_api.h\">jextract c_api.h<\/a><\/li>\n+<li><a href=\"#python-program-that-creates-and-saves-model\">Python program that creates and saves model<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-tensorflow-c-api\">Java program that uses Tensorflow C API<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-java-tensorflow-sample\">Compiling and running the Java Tensorflow sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-time.h-mac-os\">Using time.h (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#jextract-time.h\">jextract time.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-posix-time-library\">Java program that uses POSIX time library<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-time-sample\">Compiling and running the time sample<\/a><\/li>\n+<\/ul><\/li>\n+<li><a href=\"#using-libclang-library-mac-os\">Using libclang library (Mac OS)<\/a>\n+<ul>\n+<li><a href=\"#jextract-index.h\">jextract Index.h<\/a><\/li>\n+<li><a href=\"#java-program-that-uses-libclang-to-print-ast-of-a-given-c-program\">Java program that uses libclang to print AST of a given C program<\/a><\/li>\n+<li><a href=\"#compiling-and-running-the-libclang-sample\">Compiling and running the libclang sample<\/a><\/li>\n+<\/ul><\/li>\n+<\/ul><\/li>\n+<\/ul>\n+<\/nav>\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<h1 id=\"using-the-jextract-tool\">Using the <code>jextract<\/code> tool<\/h1>\n+<p><code>jextract<\/code> is a simple - but convenient - tool which generates a Java API from one or more native C headers. The tool can be obtained by building the <a href=\"https:\/\/github.com\/openjdk\/panama-foreign\">foreign-jextract<\/a> branch of Panama foreign repository.<\/p>\n+<p>Interacting with the <code>jextract<\/code> tool usually involves two steps:<\/p>\n+<ol type=\"1\">\n+<li>Use the <code>jextract<\/code> tool to generate a java interface for some C header files<\/li>\n+<li>Write a Java program which invokes the wrapper API points generated by <code>jextract<\/code><\/li>\n+<\/ol>\n+<p>The <code>jextract<\/code> tool provides some basic options in order to control how the extraction process works; these are listed below:<\/p>\n+<ul>\n+<li><code>-C &lt;String&gt;<\/code> - specify arguments to be passed to the underlying Clang parser<\/li>\n+<li><code>-I &lt;String&gt;<\/code> - specify include files path<\/li>\n+<li><code>-l &lt;String&gt;<\/code> - specify a library (name or full absolute path) which should be linked when the generated API is loaded<\/li>\n+<li><code>-d &lt;String&gt;<\/code> - specify where to place generated files<\/li>\n+<li><code>-t &lt;String&gt;<\/code> specify the target package for the generated classes<\/li>\n+<li>--include-function <String> - name of function to include<\/li>\n+<li>--include-macro <String> - name of constant macro to include<\/li>\n+<li>--include-struct <String> - name of struct definition to include<\/li>\n+<li>--include-typedef <String> - name of type definition to include<\/li>\n+<li>--include-union <String> - name of union definition to include<\/li>\n+<li>--include-var <String> - name of global variable to include<\/li>\n+<li><code>--source<\/code> - generate java sources instead of classfiles<\/li>\n+<\/ul>\n+<p>The remainder of this documents shows some basic usage examples of the <code>jextract<\/code> tool.<\/p>\n+<h2 id=\"hello-world\">Hello World<\/h2>\n+<h3 id=\"hello-world-c-header-helloworld.h\">Hello World C Header (helloworld.h)<\/h3>\n+<div class=\"sourceCode\" id=\"cb1\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><span id=\"cb1-1\"><a href=\"#cb1-1\"><\/a><\/span>\n+<span id=\"cb1-2\"><a href=\"#cb1-2\"><\/a><span class=\"pp\">#ifndef helloworld_h<\/span><\/span>\n+<span id=\"cb1-3\"><a href=\"#cb1-3\"><\/a><span class=\"pp\">#define helloworld_h<\/span><\/span>\n+<span id=\"cb1-4\"><a href=\"#cb1-4\"><\/a><\/span>\n+<span id=\"cb1-5\"><a href=\"#cb1-5\"><\/a><span class=\"kw\">extern<\/span> <span class=\"dt\">void<\/span> helloworld(<span class=\"dt\">void<\/span>);<\/span>\n+<span id=\"cb1-6\"><a href=\"#cb1-6\"><\/a><\/span>\n+<span id=\"cb1-7\"><a href=\"#cb1-7\"><\/a><span class=\"pp\">#endif <\/span><span class=\"co\">\/* helloworld_h *\/<\/span><\/span>\n+<span id=\"cb1-8\"><a href=\"#cb1-8\"><\/a><\/span><\/code><\/pre><\/div>\n+<h3 id=\"hello-world-c-source-helloworld.c\">Hello World C Source (helloworld.c)<\/h3>\n+<div class=\"sourceCode\" id=\"cb2\"><pre class=\"sourceCode c\"><code class=\"sourceCode c\"><span id=\"cb2-1\"><a href=\"#cb2-1\"><\/a><\/span>\n+<span id=\"cb2-2\"><a href=\"#cb2-2\"><\/a><span class=\"pp\">#include <\/span><span class=\"im\">&lt;stdio.h&gt;<\/span><\/span>\n+<span id=\"cb2-3\"><a href=\"#cb2-3\"><\/a><\/span>\n+<span id=\"cb2-4\"><a href=\"#cb2-4\"><\/a><span class=\"pp\">#include <\/span><span class=\"im\">&quot;helloworld.h&quot;<\/span><\/span>\n+<span id=\"cb2-5\"><a href=\"#cb2-5\"><\/a><\/span>\n+<span id=\"cb2-6\"><a href=\"#cb2-6\"><\/a><span class=\"dt\">void<\/span> helloworld(<span class=\"dt\">void<\/span>) {<\/span>\n+<span id=\"cb2-7\"><a href=\"#cb2-7\"><\/a>    printf(<span class=\"st\">&quot;Hello World!<\/span><span class=\"sc\">\\n<\/span><span class=\"st\">&quot;<\/span>);<\/span>\n+<span id=\"cb2-8\"><a href=\"#cb2-8\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"building-hello-world\">Building Hello World<\/h3>\n+<div class=\"sourceCode\" id=\"cb3\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb3-1\"><a href=\"#cb3-1\"><\/a><\/span>\n+<span id=\"cb3-2\"><a href=\"#cb3-2\"><\/a><span class=\"fu\">cc<\/span> -shared -o libhelloworld.dylib helloworld.c<\/span><\/code><\/pre><\/div>\n+<h3 id=\"jextract-a-jar-file-for-helloworld.h\">jextract a Jar file for helloworld.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb4\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb4-1\"><a href=\"#cb4-1\"><\/a><\/span>\n+<span id=\"cb4-2\"><a href=\"#cb4-2\"><\/a><span class=\"ex\">jextract<\/span> -t org.hello -lhelloworld helloworld.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-extracted-helloworld-interface\">Java program that uses extracted helloworld interface<\/h3>\n+<div class=\"sourceCode\" id=\"cb5\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb5-1\"><a href=\"#cb5-1\"><\/a><\/span>\n+<span id=\"cb5-2\"><a href=\"#cb5-2\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> org.hello.helloworld_h.*;<\/span><\/span>\n+<span id=\"cb5-3\"><a href=\"#cb5-3\"><\/a><\/span>\n+<span id=\"cb5-4\"><a href=\"#cb5-4\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> HelloWorld {<\/span>\n+<span id=\"cb5-5\"><a href=\"#cb5-5\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb5-6\"><a href=\"#cb5-6\"><\/a>        <span class=\"fu\">helloworld<\/span>();<\/span>\n+<span id=\"cb5-7\"><a href=\"#cb5-7\"><\/a>    }<\/span>\n+<span id=\"cb5-8\"><a href=\"#cb5-8\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"running-the-java-code-that-invokes-helloworld\">Running the Java code that invokes helloworld<\/h3>\n+<div class=\"sourceCode\" id=\"cb6\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb6-1\"><a href=\"#cb6-1\"><\/a><\/span>\n+<span id=\"cb6-2\"><a href=\"#cb6-2\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign HelloWorld.java<\/span><\/code><\/pre><\/div>\n+<h2 id=\"embedding-python-interpreter-in-your-java-program-mac-os\">Embedding Python interpreter in your Java program (Mac OS)<\/h2>\n+<h3 id=\"jextract-python.h\">jextract Python.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb7\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb7-1\"><a href=\"#cb7-1\"><\/a><\/span>\n+<span id=\"cb7-2\"><a href=\"#cb7-2\"><\/a><span class=\"ex\">jextract<\/span> \\<\/span>\n+<span id=\"cb7-3\"><a href=\"#cb7-3\"><\/a>  -l python2.7 \\<\/span>\n+<span id=\"cb7-4\"><a href=\"#cb7-4\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/span>\n+<span id=\"cb7-5\"><a href=\"#cb7-5\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/python2.7\/ \\<\/span>\n+<span id=\"cb7-6\"><a href=\"#cb7-6\"><\/a>  -t org.python \\<\/span>\n+<span id=\"cb7-7\"><a href=\"#cb7-7\"><\/a>   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/python2.7\/Python.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-extracted-python-interface\">Java program that uses extracted Python interface<\/h3>\n+<div class=\"sourceCode\" id=\"cb8\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb8-1\"><a href=\"#cb8-1\"><\/a><\/span>\n+<span id=\"cb8-2\"><a href=\"#cb8-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.ResourceScope;<\/span><\/span>\n+<span id=\"cb8-3\"><a href=\"#cb8-3\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb8-4\"><a href=\"#cb8-4\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/span>\n+<span id=\"cb8-5\"><a href=\"#cb8-5\"><\/a><span class=\"co\">\/\/ import jextracted python &#39;header&#39; class<\/span><\/span>\n+<span id=\"cb8-6\"><a href=\"#cb8-6\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> org.python.Python_h.*;<\/span><\/span>\n+<span id=\"cb8-7\"><a href=\"#cb8-7\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> org.python.*;<\/span><\/span>\n+<span id=\"cb8-8\"><a href=\"#cb8-8\"><\/a><\/span>\n+<span id=\"cb8-9\"><a href=\"#cb8-9\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> PythonMain {<\/span>\n+<span id=\"cb8-10\"><a href=\"#cb8-10\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb8-11\"><a href=\"#cb8-11\"><\/a>        <span class=\"bu\">String<\/span> script = <span class=\"st\">&quot;print(sum([33, 55, 66])); print(&#39;Hello from Python!&#39;)<\/span><span class=\"sc\">\\n<\/span><span class=\"st\">&quot;<\/span>;<\/span>\n+<span id=\"cb8-12\"><a href=\"#cb8-12\"><\/a><\/span>\n+<span id=\"cb8-13\"><a href=\"#cb8-13\"><\/a>        <span class=\"fu\">Py_Initialize<\/span>();<\/span>\n+<span id=\"cb8-14\"><a href=\"#cb8-14\"><\/a>        <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb8-15\"><a href=\"#cb8-15\"><\/a>            var str = <span class=\"fu\">toCString<\/span>(script, scope);<\/span>\n+<span id=\"cb8-16\"><a href=\"#cb8-16\"><\/a>            <span class=\"fu\">PyRun_SimpleStringFlags<\/span>(str, NULL);<\/span>\n+<span id=\"cb8-17\"><a href=\"#cb8-17\"><\/a>            <span class=\"fu\">Py_Finalize<\/span>();<\/span>\n+<span id=\"cb8-18\"><a href=\"#cb8-18\"><\/a>        }<\/span>\n+<span id=\"cb8-19\"><a href=\"#cb8-19\"><\/a>    }<\/span>\n+<span id=\"cb8-20\"><a href=\"#cb8-20\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"running-the-java-code-that-calls-python-interpreter\">Running the Java code that calls Python interpreter<\/h3>\n+<div class=\"sourceCode\" id=\"cb9\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb9-1\"><a href=\"#cb9-1\"><\/a><\/span>\n+<span id=\"cb9-2\"><a href=\"#cb9-2\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\<\/span>\n+<span id=\"cb9-3\"><a href=\"#cb9-3\"><\/a>    -Djava.library.path=\/System\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib \\<\/span>\n+<span id=\"cb9-4\"><a href=\"#cb9-4\"><\/a>    PythonMain.java<\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-readline-library-from-java-code-mac-os\">Using readline library from Java code (Mac OS)<\/h2>\n+<h3 id=\"jextract-readline.h\">jextract readline.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb10\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb10-1\"><a href=\"#cb10-1\"><\/a><\/span>\n+<span id=\"cb10-2\"><a href=\"#cb10-2\"><\/a><span class=\"ex\">jextract<\/span> \\<\/span>\n+<span id=\"cb10-3\"><a href=\"#cb10-3\"><\/a>  -l readline -t org.unix \\<\/span>\n+<span id=\"cb10-4\"><a href=\"#cb10-4\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/span>\n+<span id=\"cb10-5\"><a href=\"#cb10-5\"><\/a>   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/readline\/readline.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-code-that-uses-readline\">Java code that uses readline<\/h3>\n+<div class=\"sourceCode\" id=\"cb11\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb11-1\"><a href=\"#cb11-1\"><\/a><\/span>\n+<span id=\"cb11-2\"><a href=\"#cb11-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.ResourceScope;<\/span><\/span>\n+<span id=\"cb11-3\"><a href=\"#cb11-3\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> org.unix.readline_h.*;<\/span><\/span>\n+<span id=\"cb11-4\"><a href=\"#cb11-4\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb11-5\"><a href=\"#cb11-5\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> org.unix.*;<\/span><\/span>\n+<span id=\"cb11-6\"><a href=\"#cb11-6\"><\/a><\/span>\n+<span id=\"cb11-7\"><a href=\"#cb11-7\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> Readline {<\/span>\n+<span id=\"cb11-8\"><a href=\"#cb11-8\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb11-9\"><a href=\"#cb11-9\"><\/a>       <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb11-10\"><a href=\"#cb11-10\"><\/a>            var url = <span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;name? &quot;<\/span>, scope);<\/span>\n+<span id=\"cb11-11\"><a href=\"#cb11-11\"><\/a><\/span>\n+<span id=\"cb11-12\"><a href=\"#cb11-12\"><\/a>            <span class=\"co\">\/\/ call &quot;readline&quot; API<\/span><\/span>\n+<span id=\"cb11-13\"><a href=\"#cb11-13\"><\/a>            var p = <span class=\"fu\">readline<\/span>(url);<\/span>\n+<span id=\"cb11-14\"><a href=\"#cb11-14\"><\/a><\/span>\n+<span id=\"cb11-15\"><a href=\"#cb11-15\"><\/a>            <span class=\"co\">\/\/ print char* as is<\/span><\/span>\n+<span id=\"cb11-16\"><a href=\"#cb11-16\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(p);<\/span>\n+<span id=\"cb11-17\"><a href=\"#cb11-17\"><\/a>            <span class=\"co\">\/\/ convert char* ptr from readline as Java String &amp; print it<\/span><\/span>\n+<span id=\"cb11-18\"><a href=\"#cb11-18\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;Hello, &quot;<\/span> + <span class=\"fu\">toJavaString<\/span>(p));<\/span>\n+<span id=\"cb11-19\"><a href=\"#cb11-19\"><\/a><\/span>\n+<span id=\"cb11-20\"><a href=\"#cb11-20\"><\/a>            <span class=\"fu\">freeMemory<\/span>(p);<\/span>\n+<span id=\"cb11-21\"><a href=\"#cb11-21\"><\/a>        }<\/span>\n+<span id=\"cb11-22\"><a href=\"#cb11-22\"><\/a>    }<\/span>\n+<span id=\"cb11-23\"><a href=\"#cb11-23\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"running-the-java-code-that-uses-readline\">Running the java code that uses readline<\/h3>\n+<pre><code>java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/local\/opt\/readline\/lib\/ Readline.java\n+<\/code><\/pre>\n+<h2 id=\"using-libcurl-from-java-mac-os\">Using libcurl from Java (Mac OS)<\/h2>\n+<h3 id=\"jextract-curl.h\">jextract curl.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb13\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb13-1\"><a href=\"#cb13-1\"><\/a><\/span>\n+<span id=\"cb13-2\"><a href=\"#cb13-2\"><\/a><span class=\"ex\">jextract<\/span> -t org.unix -lcurl \\<\/span>\n+<span id=\"cb13-3\"><a href=\"#cb13-3\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/span>\n+<span id=\"cb13-4\"><a href=\"#cb13-4\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/ \\<\/span>\n+<span id=\"cb13-5\"><a href=\"#cb13-5\"><\/a>  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/curl.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-code-that-uses-libcurl\">Java code that uses libcurl<\/h3>\n+<div class=\"sourceCode\" id=\"cb14\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb14-1\"><a href=\"#cb14-1\"><\/a><\/span>\n+<span id=\"cb14-2\"><a href=\"#cb14-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.ResourceScope;<\/span><\/span>\n+<span id=\"cb14-3\"><a href=\"#cb14-3\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/span>\n+<span id=\"cb14-4\"><a href=\"#cb14-4\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> org.jextract.curl_h.*;<\/span><\/span>\n+<span id=\"cb14-5\"><a href=\"#cb14-5\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb14-6\"><a href=\"#cb14-6\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> org.jextract.*;<\/span><\/span>\n+<span id=\"cb14-7\"><a href=\"#cb14-7\"><\/a><\/span>\n+<span id=\"cb14-8\"><a href=\"#cb14-8\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> CurlMain {<\/span>\n+<span id=\"cb14-9\"><a href=\"#cb14-9\"><\/a>   <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb14-10\"><a href=\"#cb14-10\"><\/a>       var urlStr = args[<span class=\"dv\">0<\/span>];<\/span>\n+<span id=\"cb14-11\"><a href=\"#cb14-11\"><\/a>       <span class=\"fu\">curl_global_init<\/span>(<span class=\"fu\">CURL_GLOBAL_DEFAULT<\/span>());<\/span>\n+<span id=\"cb14-12\"><a href=\"#cb14-12\"><\/a>       var curl = <span class=\"fu\">curl_easy_init<\/span>();<\/span>\n+<span id=\"cb14-13\"><a href=\"#cb14-13\"><\/a>       <span class=\"kw\">if<\/span>(!curl.<span class=\"fu\">equals<\/span>(NULL)) {<\/span>\n+<span id=\"cb14-14\"><a href=\"#cb14-14\"><\/a>           <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb14-15\"><a href=\"#cb14-15\"><\/a>               var url = <span class=\"fu\">toCString<\/span>(urlStr, scope);<\/span>\n+<span id=\"cb14-16\"><a href=\"#cb14-16\"><\/a>               <span class=\"fu\">curl_easy_setopt<\/span>(curl, <span class=\"fu\">CURLOPT_URL<\/span>(), url.<span class=\"fu\">address<\/span>());<\/span>\n+<span id=\"cb14-17\"><a href=\"#cb14-17\"><\/a>               <span class=\"dt\">int<\/span> res = <span class=\"fu\">curl_easy_perform<\/span>(curl);<\/span>\n+<span id=\"cb14-18\"><a href=\"#cb14-18\"><\/a>               <span class=\"kw\">if<\/span> (res != <span class=\"fu\">CURLE_OK<\/span>()) {<\/span>\n+<span id=\"cb14-19\"><a href=\"#cb14-19\"><\/a>                   <span class=\"bu\">String<\/span> error = <span class=\"fu\">toJavaString<\/span>(<span class=\"fu\">curl_easy_strerror<\/span>(res));<\/span>\n+<span id=\"cb14-20\"><a href=\"#cb14-20\"><\/a>                   <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;Curl error: &quot;<\/span> + error);<\/span>\n+<span id=\"cb14-21\"><a href=\"#cb14-21\"><\/a>                   <span class=\"fu\">curl_easy_cleanup<\/span>(curl);<\/span>\n+<span id=\"cb14-22\"><a href=\"#cb14-22\"><\/a>               }<\/span>\n+<span id=\"cb14-23\"><a href=\"#cb14-23\"><\/a>           }<\/span>\n+<span id=\"cb14-24\"><a href=\"#cb14-24\"><\/a>       }<\/span>\n+<span id=\"cb14-25\"><a href=\"#cb14-25\"><\/a>       <span class=\"fu\">curl_global_cleanup<\/span>();<\/span>\n+<span id=\"cb14-26\"><a href=\"#cb14-26\"><\/a>   }<\/span>\n+<span id=\"cb14-27\"><a href=\"#cb14-27\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"running-the-java-code-that-uses-libcurl\">Running the java code that uses libcurl<\/h3>\n+<div class=\"sourceCode\" id=\"cb15\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb15-1\"><a href=\"#cb15-1\"><\/a><\/span>\n+<span id=\"cb15-2\"><a href=\"#cb15-2\"><\/a><span class=\"co\"># run this shell script by passing a URL as first argument<\/span><\/span>\n+<span id=\"cb15-3\"><a href=\"#cb15-3\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\<\/span>\n+<span id=\"cb15-4\"><a href=\"#cb15-4\"><\/a>    -Djava.library.path=\/usr\/lib CurlMain.java <span class=\"va\">$*<\/span><\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-blas-library\">Using BLAS library<\/h2>\n+<p>BLAS is a popular library that allows fast matrix and vector computation: <a href=\"http:\/\/www.netlib.org\/blas\/\">http:\/\/www.netlib.org\/blas\/<\/a>.<\/p>\n+<h3 id=\"installing-openblas-mac-os\">Installing OpenBLAS (Mac OS)<\/h3>\n+<p>On Mac, blas is available as part of the OpenBLAS library: <a href=\"https:\/\/github.com\/xianyi\/OpenBLAS\/wiki\">https:\/\/github.com\/xianyi\/OpenBLAS\/wiki<\/a><\/p>\n+<p>OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.<\/p>\n+<p>You can install openblas using HomeBrew<\/p>\n+<div class=\"sourceCode\" id=\"cb16\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb16-1\"><a href=\"#cb16-1\"><\/a><\/span>\n+<span id=\"cb16-2\"><a href=\"#cb16-2\"><\/a><span class=\"ex\">brew<\/span> install openblas<\/span><\/code><\/pre><\/div>\n+<p>It installs include and lib directories under \/usr\/local\/opt\/openblas<\/p>\n+<h3 id=\"jextracting-cblas.h-macos\">jextracting cblas.h (MacOS)<\/h3>\n+<p>The following command can be used to extract cblas.h on MacOs<\/p>\n+<div class=\"sourceCode\" id=\"cb17\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb17-1\"><a href=\"#cb17-1\"><\/a><\/span>\n+<span id=\"cb17-2\"><a href=\"#cb17-2\"><\/a><span class=\"ex\">jextract<\/span> -C <span class=\"st\">&quot;-D FORCE_OPENBLAS_COMPLEX_STRUCT&quot;<\/span> \\<\/span>\n+<span id=\"cb17-3\"><a href=\"#cb17-3\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/span>\n+<span id=\"cb17-4\"><a href=\"#cb17-4\"><\/a>  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-sample-code-that-uses-cblas-library\">Java sample code that uses cblas library<\/h3>\n+<div class=\"sourceCode\" id=\"cb18\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb18-1\"><a href=\"#cb18-1\"><\/a><\/span>\n+<span id=\"cb18-2\"><a href=\"#cb18-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress;<\/span><\/span>\n+<span id=\"cb18-3\"><a href=\"#cb18-3\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAccess;<\/span><\/span>\n+<span id=\"cb18-4\"><a href=\"#cb18-4\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.ResourceScope;<\/span><\/span>\n+<span id=\"cb18-5\"><a href=\"#cb18-5\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.SegmentAllocator;<\/span><\/span>\n+<span id=\"cb18-6\"><a href=\"#cb18-6\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> blas.*;<\/span><\/span>\n+<span id=\"cb18-7\"><a href=\"#cb18-7\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> blas.cblas_h.*;<\/span><\/span>\n+<span id=\"cb18-8\"><a href=\"#cb18-8\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb18-9\"><a href=\"#cb18-9\"><\/a><\/span>\n+<span id=\"cb18-10\"><a href=\"#cb18-10\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> TestBlas {<\/span>\n+<span id=\"cb18-11\"><a href=\"#cb18-11\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb18-12\"><a href=\"#cb18-12\"><\/a>        <span class=\"dt\">int<\/span> Layout;<\/span>\n+<span id=\"cb18-13\"><a href=\"#cb18-13\"><\/a>        <span class=\"dt\">int<\/span> transa;<\/span>\n+<span id=\"cb18-14\"><a href=\"#cb18-14\"><\/a><\/span>\n+<span id=\"cb18-15\"><a href=\"#cb18-15\"><\/a>        <span class=\"dt\">double<\/span> alpha, beta;<\/span>\n+<span id=\"cb18-16\"><a href=\"#cb18-16\"><\/a>        <span class=\"dt\">int<\/span> m, n, lda, incx, incy, i;<\/span>\n+<span id=\"cb18-17\"><a href=\"#cb18-17\"><\/a><\/span>\n+<span id=\"cb18-18\"><a href=\"#cb18-18\"><\/a>        Layout = <span class=\"fu\">CblasColMajor<\/span>();<\/span>\n+<span id=\"cb18-19\"><a href=\"#cb18-19\"><\/a>        transa = <span class=\"fu\">CblasNoTrans<\/span>();<\/span>\n+<span id=\"cb18-20\"><a href=\"#cb18-20\"><\/a><\/span>\n+<span id=\"cb18-21\"><a href=\"#cb18-21\"><\/a>        m = <span class=\"dv\">4<\/span>; <span class=\"co\">\/* Size of Column ( the number of rows ) *\/<\/span><\/span>\n+<span id=\"cb18-22\"><a href=\"#cb18-22\"><\/a>        n = <span class=\"dv\">4<\/span>; <span class=\"co\">\/* Size of Row ( the number of columns ) *\/<\/span><\/span>\n+<span id=\"cb18-23\"><a href=\"#cb18-23\"><\/a>        lda = <span class=\"dv\">4<\/span>; <span class=\"co\">\/* Leading dimension of 5 * 4 matrix is 5 *\/<\/span><\/span>\n+<span id=\"cb18-24\"><a href=\"#cb18-24\"><\/a>        incx = <span class=\"dv\">1<\/span>;<\/span>\n+<span id=\"cb18-25\"><a href=\"#cb18-25\"><\/a>        incy = <span class=\"dv\">1<\/span>;<\/span>\n+<span id=\"cb18-26\"><a href=\"#cb18-26\"><\/a>        alpha = <span class=\"dv\">1<\/span>;<\/span>\n+<span id=\"cb18-27\"><a href=\"#cb18-27\"><\/a>        beta = <span class=\"dv\">0<\/span>;<\/span>\n+<span id=\"cb18-28\"><a href=\"#cb18-28\"><\/a><\/span>\n+<span id=\"cb18-29\"><a href=\"#cb18-29\"><\/a>        <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb18-30\"><a href=\"#cb18-30\"><\/a>            var allocator = SegmentAllocator.<span class=\"fu\">ofScope<\/span>(scope);<\/span>\n+<span id=\"cb18-31\"><a href=\"#cb18-31\"><\/a>            var a = allocator.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, <span class=\"kw\">new<\/span> <span class=\"dt\">double<\/span>[] {<\/span>\n+<span id=\"cb18-32\"><a href=\"#cb18-32\"><\/a>                <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">2.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">3.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">4.<\/span><span class=\"dv\">0<\/span>,<\/span>\n+<span id=\"cb18-33\"><a href=\"#cb18-33\"><\/a>                <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>,<\/span>\n+<span id=\"cb18-34\"><a href=\"#cb18-34\"><\/a>                <span class=\"fl\">3.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">4.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">5.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">6.<\/span><span class=\"dv\">0<\/span>,<\/span>\n+<span id=\"cb18-35\"><a href=\"#cb18-35\"><\/a>                <span class=\"fl\">5.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">6.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">7.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">8.<\/span><span class=\"dv\">0<\/span><\/span>\n+<span id=\"cb18-36\"><a href=\"#cb18-36\"><\/a>            });<\/span>\n+<span id=\"cb18-37\"><a href=\"#cb18-37\"><\/a>            var x = allocator.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, <span class=\"kw\">new<\/span> <span class=\"dt\">double<\/span>[] {<\/span>\n+<span id=\"cb18-38\"><a href=\"#cb18-38\"><\/a>                <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">2.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span>, <span class=\"fl\">1.<\/span><span class=\"dv\">0<\/span><\/span>\n+<span id=\"cb18-39\"><a href=\"#cb18-39\"><\/a>            });<\/span>\n+<span id=\"cb18-40\"><a href=\"#cb18-40\"><\/a>            var y = allocator.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, n);<\/span>\n+<span id=\"cb18-41\"><a href=\"#cb18-41\"><\/a><\/span>\n+<span id=\"cb18-42\"><a href=\"#cb18-42\"><\/a>            <span class=\"fu\">cblas_dgemv<\/span>(Layout, transa, m, n, alpha, a, lda, x, incx, beta, y, incy);<\/span>\n+<span id=\"cb18-43\"><a href=\"#cb18-43\"><\/a>            <span class=\"co\">\/* Print y *\/<\/span><\/span>\n+<span id=\"cb18-44\"><a href=\"#cb18-44\"><\/a>            <span class=\"kw\">for<\/span> (i = <span class=\"dv\">0<\/span>; i &lt; n; i++) {<\/span>\n+<span id=\"cb18-45\"><a href=\"#cb18-45\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">print<\/span>(<span class=\"bu\">String<\/span><span class=\"fu\">.format<\/span>(<span class=\"st\">&quot; y<\/span><span class=\"sc\">%d<\/span><span class=\"st\"> = <\/span><span class=\"sc\">%f\\n<\/span><span class=\"st\">&quot;<\/span>, i, MemoryAccess.<span class=\"fu\">getDoubleAtIndex<\/span>(y, i)));<\/span>\n+<span id=\"cb18-46\"><a href=\"#cb18-46\"><\/a>            }<\/span>\n+<span id=\"cb18-47\"><a href=\"#cb18-47\"><\/a>        }<\/span>\n+<span id=\"cb18-48\"><a href=\"#cb18-48\"><\/a>    }<\/span>\n+<span id=\"cb18-49\"><a href=\"#cb18-49\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-above-blas-sample\">Compiling and running the above BLAS sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb19\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb19-1\"><a href=\"#cb19-1\"><\/a><\/span>\n+<span id=\"cb19-2\"><a href=\"#cb19-2\"><\/a><span class=\"ex\">jextract<\/span> \\<\/span>\n+<span id=\"cb19-3\"><a href=\"#cb19-3\"><\/a>  -C <span class=\"st\">&quot;-D FORCE_OPENBLAS_COMPLEX_STRUCT&quot;<\/span> \\<\/span>\n+<span id=\"cb19-4\"><a href=\"#cb19-4\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/span>\n+<span id=\"cb19-5\"><a href=\"#cb19-5\"><\/a>  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h<\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-lapack-library-mac-os\">Using LAPACK library (Mac OS)<\/h2>\n+<p>On Mac OS, lapack is installed under \/usr\/local\/opt\/lapack directory.<\/p>\n+<h3 id=\"jextracting-lapacke.h\">jextracting lapacke.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb20\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb20-1\"><a href=\"#cb20-1\"><\/a><\/span>\n+<span id=\"cb20-2\"><a href=\"#cb20-2\"><\/a><span class=\"ex\">jextract<\/span> \\<\/span>\n+<span id=\"cb20-3\"><a href=\"#cb20-3\"><\/a>   -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/span>\n+<span id=\"cb20-4\"><a href=\"#cb20-4\"><\/a>   -l lapacke -t lapack \\<\/span>\n+<span id=\"cb20-5\"><a href=\"#cb20-5\"><\/a>   \/usr\/local\/opt\/lapack\/include\/lapacke.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-sample-code-that-uses-lapack-library\">Java sample code that uses LAPACK library<\/h3>\n+<div class=\"sourceCode\" id=\"cb21\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb21-1\"><a href=\"#cb21-1\"><\/a><\/span>\n+<span id=\"cb21-2\"><a href=\"#cb21-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAccess;<\/span><\/span>\n+<span id=\"cb21-3\"><a href=\"#cb21-3\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress;<\/span><\/span>\n+<span id=\"cb21-4\"><a href=\"#cb21-4\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemorySegment;<\/span><\/span>\n+<span id=\"cb21-5\"><a href=\"#cb21-5\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.ResourceScope;<\/span><\/span>\n+<span id=\"cb21-6\"><a href=\"#cb21-6\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.SegmentAllocator;<\/span><\/span>\n+<span id=\"cb21-7\"><a href=\"#cb21-7\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> lapack.*;<\/span><\/span>\n+<span id=\"cb21-8\"><a href=\"#cb21-8\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> lapack.lapacke_h.*;<\/span><\/span>\n+<span id=\"cb21-9\"><a href=\"#cb21-9\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb21-10\"><a href=\"#cb21-10\"><\/a><\/span>\n+<span id=\"cb21-11\"><a href=\"#cb21-11\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> TestLapack {<\/span>\n+<span id=\"cb21-12\"><a href=\"#cb21-12\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb21-13\"><a href=\"#cb21-13\"><\/a><\/span>\n+<span id=\"cb21-14\"><a href=\"#cb21-14\"><\/a>        <span class=\"co\">\/* Locals *\/<\/span><\/span>\n+<span id=\"cb21-15\"><a href=\"#cb21-15\"><\/a>        <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb21-16\"><a href=\"#cb21-16\"><\/a>            var allocator = SegmentAllocator.<span class=\"fu\">ofScope<\/span>(scope);<\/span>\n+<span id=\"cb21-17\"><a href=\"#cb21-17\"><\/a>            var A = allocator.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, <span class=\"kw\">new<\/span> <span class=\"dt\">double<\/span>[]{<\/span>\n+<span id=\"cb21-18\"><a href=\"#cb21-18\"><\/a>                    <span class=\"dv\">1<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">3<\/span>, <span class=\"dv\">4<\/span>, <span class=\"dv\">5<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">3<\/span>, <span class=\"dv\">5<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">4<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">4<\/span>, <span class=\"dv\">2<\/span>, <span class=\"dv\">5<\/span>, <span class=\"dv\">3<\/span><\/span>\n+<span id=\"cb21-19\"><a href=\"#cb21-19\"><\/a>            });<\/span>\n+<span id=\"cb21-20\"><a href=\"#cb21-20\"><\/a>            var b = allocator.<span class=\"fu\">allocateArray<\/span>(C_DOUBLE, <span class=\"kw\">new<\/span> <span class=\"dt\">double<\/span>[]{<\/span>\n+<span id=\"cb21-21\"><a href=\"#cb21-21\"><\/a>                    -<span class=\"dv\">10<\/span>, <span class=\"dv\">12<\/span>, <span class=\"dv\">14<\/span>, <span class=\"dv\">16<\/span>, <span class=\"dv\">18<\/span>, -<span class=\"dv\">3<\/span>, <span class=\"dv\">14<\/span>, <span class=\"dv\">12<\/span>, <span class=\"dv\">16<\/span>, <span class=\"dv\">16<\/span><\/span>\n+<span id=\"cb21-22\"><a href=\"#cb21-22\"><\/a>            });<\/span>\n+<span id=\"cb21-23\"><a href=\"#cb21-23\"><\/a>            <span class=\"dt\">int<\/span> info, m, n, lda, ldb, nrhs;<\/span>\n+<span id=\"cb21-24\"><a href=\"#cb21-24\"><\/a><\/span>\n+<span id=\"cb21-25\"><a href=\"#cb21-25\"><\/a>            <span class=\"co\">\/* Initialization *\/<\/span><\/span>\n+<span id=\"cb21-26\"><a href=\"#cb21-26\"><\/a>            m = <span class=\"dv\">5<\/span>;<\/span>\n+<span id=\"cb21-27\"><a href=\"#cb21-27\"><\/a>            n = <span class=\"dv\">3<\/span>;<\/span>\n+<span id=\"cb21-28\"><a href=\"#cb21-28\"><\/a>            nrhs = <span class=\"dv\">2<\/span>;<\/span>\n+<span id=\"cb21-29\"><a href=\"#cb21-29\"><\/a>            lda = <span class=\"dv\">5<\/span>;<\/span>\n+<span id=\"cb21-30\"><a href=\"#cb21-30\"><\/a>            ldb = <span class=\"dv\">5<\/span>;<\/span>\n+<span id=\"cb21-31\"><a href=\"#cb21-31\"><\/a><\/span>\n+<span id=\"cb21-32\"><a href=\"#cb21-32\"><\/a>            <span class=\"co\">\/* Print Entry Matrix *\/<\/span><\/span>\n+<span id=\"cb21-33\"><a href=\"#cb21-33\"><\/a>            <span class=\"fu\">print_matrix_colmajor<\/span>(<span class=\"st\">&quot;Entry Matrix A&quot;<\/span>, m, n, A, lda );<\/span>\n+<span id=\"cb21-34\"><a href=\"#cb21-34\"><\/a>            <span class=\"co\">\/* Print Right Rand Side *\/<\/span><\/span>\n+<span id=\"cb21-35\"><a href=\"#cb21-35\"><\/a>            <span class=\"fu\">print_matrix_colmajor<\/span>(<span class=\"st\">&quot;Right Hand Side b&quot;<\/span>, n, nrhs, b, ldb );<\/span>\n+<span id=\"cb21-36\"><a href=\"#cb21-36\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>();<\/span>\n+<span id=\"cb21-37\"><a href=\"#cb21-37\"><\/a><\/span>\n+<span id=\"cb21-38\"><a href=\"#cb21-38\"><\/a>            <span class=\"co\">\/* Executable statements *\/<\/span><\/span>\n+<span id=\"cb21-39\"><a href=\"#cb21-39\"><\/a>            <span class=\"co\">\/\/            printf( &quot;LAPACKE_dgels (col-major, high-level) Example Program Results\\n&quot; );<\/span><\/span>\n+<span id=\"cb21-40\"><a href=\"#cb21-40\"><\/a>            <span class=\"co\">\/* Solve least squares problem*\/<\/span><\/span>\n+<span id=\"cb21-41\"><a href=\"#cb21-41\"><\/a>            info = <span class=\"fu\">LAPACKE_dgels<\/span>(<span class=\"fu\">LAPACK_COL_MAJOR<\/span>(), (<span class=\"dt\">byte<\/span>)<span class=\"ch\">&#39;N&#39;<\/span>, m, n, nrhs, A, lda, b, ldb);<\/span>\n+<span id=\"cb21-42\"><a href=\"#cb21-42\"><\/a><\/span>\n+<span id=\"cb21-43\"><a href=\"#cb21-43\"><\/a>            <span class=\"co\">\/* Print Solution *\/<\/span><\/span>\n+<span id=\"cb21-44\"><a href=\"#cb21-44\"><\/a>            <span class=\"fu\">print_matrix_colmajor<\/span>(<span class=\"st\">&quot;Solution&quot;<\/span>, n, nrhs, b, ldb );<\/span>\n+<span id=\"cb21-45\"><a href=\"#cb21-45\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>();<\/span>\n+<span id=\"cb21-46\"><a href=\"#cb21-46\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">exit<\/span>(info);<\/span>\n+<span id=\"cb21-47\"><a href=\"#cb21-47\"><\/a>        }<\/span>\n+<span id=\"cb21-48\"><a href=\"#cb21-48\"><\/a>    }<\/span>\n+<span id=\"cb21-49\"><a href=\"#cb21-49\"><\/a><\/span>\n+<span id=\"cb21-50\"><a href=\"#cb21-50\"><\/a>    <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">print_matrix_colmajor<\/span>(<span class=\"bu\">String<\/span> msg, <span class=\"dt\">int<\/span> m, <span class=\"dt\">int<\/span> n, MemorySegment mat, <span class=\"dt\">int<\/span> ldm) {<\/span>\n+<span id=\"cb21-51\"><a href=\"#cb21-51\"><\/a>        <span class=\"dt\">int<\/span> i, j;<\/span>\n+<span id=\"cb21-52\"><a href=\"#cb21-52\"><\/a>        <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">\\n<\/span><span class=\"st\"> <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>, msg);<\/span>\n+<span id=\"cb21-53\"><a href=\"#cb21-53\"><\/a><\/span>\n+<span id=\"cb21-54\"><a href=\"#cb21-54\"><\/a>        <span class=\"kw\">for<\/span>( i = <span class=\"dv\">0<\/span>; i &lt; m; i++ ) {<\/span>\n+<span id=\"cb21-55\"><a href=\"#cb21-55\"><\/a>            <span class=\"kw\">for<\/span>( j = <span class=\"dv\">0<\/span>; j &lt; n; j++ ) <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot; <\/span><span class=\"sc\">%6.2f<\/span><span class=\"st\">&quot;<\/span>, MemoryAccess.<span class=\"fu\">getDoubleAtIndex<\/span>(mat, i+j*ldm));<\/span>\n+<span id=\"cb21-56\"><a href=\"#cb21-56\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>( <span class=\"st\">&quot;<\/span><span class=\"sc\">\\n<\/span><span class=\"st\">&quot;<\/span> );<\/span>\n+<span id=\"cb21-57\"><a href=\"#cb21-57\"><\/a>        }<\/span>\n+<span id=\"cb21-58\"><a href=\"#cb21-58\"><\/a>    }<\/span>\n+<span id=\"cb21-59\"><a href=\"#cb21-59\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-above-lapack-sample\">Compiling and running the above LAPACK sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb22\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb22-1\"><a href=\"#cb22-1\"><\/a><\/span>\n+<span id=\"cb22-2\"><a href=\"#cb22-2\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED \\<\/span>\n+<span id=\"cb22-3\"><a href=\"#cb22-3\"><\/a>    --add-modules jdk.incubator.foreign \\<\/span>\n+<span id=\"cb22-4\"><a href=\"#cb22-4\"><\/a>    -Djava.library.path=\/usr\/local\/opt\/lapack\/lib \\<\/span>\n+<span id=\"cb22-5\"><a href=\"#cb22-5\"><\/a>    TestLapack.java<\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-libproc-library-to-list-processes-from-java-mac-os\">Using libproc library to list processes from Java (Mac OS)<\/h2>\n+<h3 id=\"jextract-libproc.h\">jextract libproc.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb23\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb23-1\"><a href=\"#cb23-1\"><\/a><\/span>\n+<span id=\"cb23-2\"><a href=\"#cb23-2\"><\/a><span class=\"ex\">jextract<\/span> \\<\/span>\n+<span id=\"cb23-3\"><a href=\"#cb23-3\"><\/a>  -t org.unix \\<\/span>\n+<span id=\"cb23-4\"><a href=\"#cb23-4\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/span>\n+<span id=\"cb23-5\"><a href=\"#cb23-5\"><\/a>  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/libproc.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-libproc-to-list-processes\">Java program that uses libproc to list processes<\/h3>\n+<div class=\"sourceCode\" id=\"cb24\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb24-1\"><a href=\"#cb24-1\"><\/a><\/span>\n+<span id=\"cb24-2\"><a href=\"#cb24-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker;<\/span><\/span>\n+<span id=\"cb24-3\"><a href=\"#cb24-3\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemorySegment;<\/span><\/span>\n+<span id=\"cb24-4\"><a href=\"#cb24-4\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.ResourceScope;<\/span><\/span>\n+<span id=\"cb24-5\"><a href=\"#cb24-5\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.SegmentAllocator;<\/span><\/span>\n+<span id=\"cb24-6\"><a href=\"#cb24-6\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> org.unix.*;<\/span><\/span>\n+<span id=\"cb24-7\"><a href=\"#cb24-7\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/span>\n+<span id=\"cb24-8\"><a href=\"#cb24-8\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> org.unix.libproc_h.*;<\/span><\/span>\n+<span id=\"cb24-9\"><a href=\"#cb24-9\"><\/a><\/span>\n+<span id=\"cb24-10\"><a href=\"#cb24-10\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> LibprocMain {<\/span>\n+<span id=\"cb24-11\"><a href=\"#cb24-11\"><\/a>    <span class=\"kw\">private<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">final<\/span> <span class=\"dt\">int<\/span> NAME_BUF_MAX = <span class=\"dv\">256<\/span>;<\/span>\n+<span id=\"cb24-12\"><a href=\"#cb24-12\"><\/a><\/span>\n+<span id=\"cb24-13\"><a href=\"#cb24-13\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb24-14\"><a href=\"#cb24-14\"><\/a>        <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb24-15\"><a href=\"#cb24-15\"><\/a>            var allocator = SegmentAllocator.<span class=\"fu\">ofScope<\/span>(scope);<\/span>\n+<span id=\"cb24-16\"><a href=\"#cb24-16\"><\/a>            <span class=\"co\">\/\/ get the number of processes<\/span><\/span>\n+<span id=\"cb24-17\"><a href=\"#cb24-17\"><\/a>            <span class=\"dt\">int<\/span> numPids = <span class=\"fu\">proc_listallpids<\/span>(NULL, <span class=\"dv\">0<\/span>);<\/span>\n+<span id=\"cb24-18\"><a href=\"#cb24-18\"><\/a>            <span class=\"co\">\/\/ allocate an array<\/span><\/span>\n+<span id=\"cb24-19\"><a href=\"#cb24-19\"><\/a>            var pids = allocator.<span class=\"fu\">allocateArray<\/span>(CLinker.<span class=\"fu\">C_INT<\/span>, numPids);<\/span>\n+<span id=\"cb24-20\"><a href=\"#cb24-20\"><\/a>            <span class=\"co\">\/\/ list all the pids into the native array<\/span><\/span>\n+<span id=\"cb24-21\"><a href=\"#cb24-21\"><\/a>            <span class=\"fu\">proc_listallpids<\/span>(pids, numPids);<\/span>\n+<span id=\"cb24-22\"><a href=\"#cb24-22\"><\/a>            <span class=\"co\">\/\/ convert native array to java array<\/span><\/span>\n+<span id=\"cb24-23\"><a href=\"#cb24-23\"><\/a>            <span class=\"dt\">int<\/span>[] jpids = pids.<span class=\"fu\">toIntArray<\/span>();<\/span>\n+<span id=\"cb24-24\"><a href=\"#cb24-24\"><\/a>            <span class=\"co\">\/\/ buffer for process name<\/span><\/span>\n+<span id=\"cb24-25\"><a href=\"#cb24-25\"><\/a>            var nameBuf = allocator.<span class=\"fu\">allocateArray<\/span>(CLinker.<span class=\"fu\">C_CHAR<\/span>, NAME_BUF_MAX);<\/span>\n+<span id=\"cb24-26\"><a href=\"#cb24-26\"><\/a>            <span class=\"kw\">for<\/span> (<span class=\"dt\">int<\/span> i = <span class=\"dv\">0<\/span>; i &lt; jpids.<span class=\"fu\">length<\/span>; i++) {<\/span>\n+<span id=\"cb24-27\"><a href=\"#cb24-27\"><\/a>                <span class=\"dt\">int<\/span> pid = jpids[i];<\/span>\n+<span id=\"cb24-28\"><a href=\"#cb24-28\"><\/a>                <span class=\"co\">\/\/ get the process name<\/span><\/span>\n+<span id=\"cb24-29\"><a href=\"#cb24-29\"><\/a>                <span class=\"fu\">proc_name<\/span>(pid, nameBuf, NAME_BUF_MAX);<\/span>\n+<span id=\"cb24-30\"><a href=\"#cb24-30\"><\/a>                <span class=\"bu\">String<\/span> procName = CLinker.<span class=\"fu\">toJavaString<\/span>(nameBuf);<\/span>\n+<span id=\"cb24-31\"><a href=\"#cb24-31\"><\/a>                <span class=\"co\">\/\/ print pid and process name<\/span><\/span>\n+<span id=\"cb24-32\"><a href=\"#cb24-32\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">%d<\/span><span class=\"st\"> <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>, pid, procName);<\/span>\n+<span id=\"cb24-33\"><a href=\"#cb24-33\"><\/a>            }<\/span>\n+<span id=\"cb24-34\"><a href=\"#cb24-34\"><\/a>        }<\/span>\n+<span id=\"cb24-35\"><a href=\"#cb24-35\"><\/a>    }<\/span>\n+<span id=\"cb24-36\"><a href=\"#cb24-36\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-libproc-sample\">Compiling and running the libproc sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb25\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb25-1\"><a href=\"#cb25-1\"><\/a><\/span>\n+<span id=\"cb25-2\"><a href=\"#cb25-2\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED \\<\/span>\n+<span id=\"cb25-3\"><a href=\"#cb25-3\"><\/a>    --add-modules jdk.incubator.foreign \\<\/span>\n+<span id=\"cb25-4\"><a href=\"#cb25-4\"><\/a>    -Djava.library.path=\/usr\/lib LibprocMain.java<\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-libgit2-from-java-mac-os\">Using libgit2 from Java (Mac OS)<\/h2>\n+<h3 id=\"getting-and-building-libgit2\">Getting and building libgit2<\/h3>\n+<ul>\n+<li>Download libgit2 v1.0.0 source from https:\/\/github.com\/libgit2\/libgit2\/releases<\/li>\n+<li>Use cmake to build from libgit2<\/li>\n+<li>Let ${LIBGIT2_HOME} be the directory where you expanded libgit2 sources.<\/li>\n+<li>Let ${LIBGIT2_HOME}\/build be the build directory where libgit2.dylib is built.<\/li>\n+<\/ul>\n+<h3 id=\"jextract-git2.h\">jextract git2.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb26\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb26-1\"><a href=\"#cb26-1\"><\/a><\/span>\n+<span id=\"cb26-2\"><a href=\"#cb26-2\"><\/a><span class=\"ex\">jextract<\/span> \\<\/span>\n+<span id=\"cb26-3\"><a href=\"#cb26-3\"><\/a>  -t com.github -lgit2 \\<\/span>\n+<span id=\"cb26-4\"><a href=\"#cb26-4\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/span>\n+<span id=\"cb26-5\"><a href=\"#cb26-5\"><\/a>  -I <span class=\"va\">${LIBGIT2_HOME}<\/span>\/include\/ \\<\/span>\n+<span id=\"cb26-6\"><a href=\"#cb26-6\"><\/a>  -I <span class=\"va\">${LIBGIT2_HOME}<\/span>\/include\/git2 \\<\/span>\n+<span id=\"cb26-7\"><a href=\"#cb26-7\"><\/a>  <span class=\"va\">${LIBGIT2_HOME}<\/span>\/include\/git2.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-libgit2-to-clone-github-repo\">Java program that uses libgit2 to clone github repo<\/h3>\n+<div class=\"sourceCode\" id=\"cb27\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb27-1\"><a href=\"#cb27-1\"><\/a><\/span>\n+<span id=\"cb27-2\"><a href=\"#cb27-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress;<\/span><\/span>\n+<span id=\"cb27-3\"><a href=\"#cb27-3\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.ResourceScope;<\/span><\/span>\n+<span id=\"cb27-4\"><a href=\"#cb27-4\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.SegmentAllocator;<\/span><\/span>\n+<span id=\"cb27-5\"><a href=\"#cb27-5\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> com.github.git2_h.*;<\/span><\/span>\n+<span id=\"cb27-6\"><a href=\"#cb27-6\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb27-7\"><a href=\"#cb27-7\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/span>\n+<span id=\"cb27-8\"><a href=\"#cb27-8\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> com.github.*;<\/span><\/span>\n+<span id=\"cb27-9\"><a href=\"#cb27-9\"><\/a><\/span>\n+<span id=\"cb27-10\"><a href=\"#cb27-10\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> GitClone {<\/span>\n+<span id=\"cb27-11\"><a href=\"#cb27-11\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb27-12\"><a href=\"#cb27-12\"><\/a>          <span class=\"kw\">if<\/span> (args.<span class=\"fu\">length<\/span> != <span class=\"dv\">2<\/span>) {<\/span>\n+<span id=\"cb27-13\"><a href=\"#cb27-13\"><\/a>              <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;java GitClone &lt;url&gt; &lt;path&gt;&quot;<\/span>);<\/span>\n+<span id=\"cb27-14\"><a href=\"#cb27-14\"><\/a>              <span class=\"bu\">System<\/span>.<span class=\"fu\">exit<\/span>(<span class=\"dv\">1<\/span>);<\/span>\n+<span id=\"cb27-15\"><a href=\"#cb27-15\"><\/a>          }<\/span>\n+<span id=\"cb27-16\"><a href=\"#cb27-16\"><\/a>          <span class=\"fu\">git_libgit2_init<\/span>();<\/span>\n+<span id=\"cb27-17\"><a href=\"#cb27-17\"><\/a>          <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb27-18\"><a href=\"#cb27-18\"><\/a>              var allocator = SegmentAllocator.<span class=\"fu\">ofScope<\/span>(scope);<\/span>\n+<span id=\"cb27-19\"><a href=\"#cb27-19\"><\/a>              var repo = allocator.<span class=\"fu\">allocate<\/span>(C_POINTER);<\/span>\n+<span id=\"cb27-20\"><a href=\"#cb27-20\"><\/a>              var url = <span class=\"fu\">toCString<\/span>(args[<span class=\"dv\">0<\/span>], scope);<\/span>\n+<span id=\"cb27-21\"><a href=\"#cb27-21\"><\/a>              var path = <span class=\"fu\">toCString<\/span>(args[<span class=\"dv\">1<\/span>], scope);<\/span>\n+<span id=\"cb27-22\"><a href=\"#cb27-22\"><\/a>              <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"fu\">git_clone<\/span>(repo, url, path, NULL));<\/span>\n+<span id=\"cb27-23\"><a href=\"#cb27-23\"><\/a>          }<\/span>\n+<span id=\"cb27-24\"><a href=\"#cb27-24\"><\/a>          <span class=\"fu\">git_libgit2_shutdown<\/span>();<\/span>\n+<span id=\"cb27-25\"><a href=\"#cb27-25\"><\/a>    }<\/span>\n+<span id=\"cb27-26\"><a href=\"#cb27-26\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-libgit2-sample\">Compiling and running the libgit2 sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb28\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb28-1\"><a href=\"#cb28-1\"><\/a><\/span>\n+<span id=\"cb28-2\"><a href=\"#cb28-2\"><\/a><span class=\"co\"># file run.sh<\/span><\/span>\n+<span id=\"cb28-3\"><a href=\"#cb28-3\"><\/a><\/span>\n+<span id=\"cb28-4\"><a href=\"#cb28-4\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\<\/span>\n+<span id=\"cb28-5\"><a href=\"#cb28-5\"><\/a>    -Djava.library.path=<span class=\"va\">${LIBGIT2_HOME}<\/span>\/build\/ \\<\/span>\n+<span id=\"cb28-6\"><a href=\"#cb28-6\"><\/a>    GitClone.java <span class=\"va\">$*<\/span><\/span><\/code><\/pre><\/div>\n+<h3 id=\"cloning-a-github-repo-using-the-above-run.sh-command\">Cloning a github repo using the above run.sh command<\/h3>\n+<div class=\"sourceCode\" id=\"cb29\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb29-1\"><a href=\"#cb29-1\"><\/a><\/span>\n+<span id=\"cb29-2\"><a href=\"#cb29-2\"><\/a><span class=\"fu\">sh<\/span> run.sh https:\/\/github.com\/libgit2\/libgit2.git libgit2<\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-sqlite3-library-from-java-mac-os\">Using sqlite3 library from Java (Mac OS)<\/h2>\n+<h3 id=\"jextract-sqlite3.h\">jextract sqlite3.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb30\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb30-1\"><a href=\"#cb30-1\"><\/a><\/span>\n+<span id=\"cb30-2\"><a href=\"#cb30-2\"><\/a><span class=\"ex\">jextract<\/span> \\<\/span>\n+<span id=\"cb30-3\"><a href=\"#cb30-3\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/span>\n+<span id=\"cb30-4\"><a href=\"#cb30-4\"><\/a>  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/sqlite3.h \\<\/span>\n+<span id=\"cb30-5\"><a href=\"#cb30-5\"><\/a>  -t org.sqlite -lsqlite3<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-sqlite3\">Java program that uses sqlite3<\/h3>\n+<div class=\"sourceCode\" id=\"cb31\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb31-1\"><a href=\"#cb31-1\"><\/a><\/span>\n+<span id=\"cb31-2\"><a href=\"#cb31-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress;<\/span><\/span>\n+<span id=\"cb31-3\"><a href=\"#cb31-3\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAccess;<\/span><\/span>\n+<span id=\"cb31-4\"><a href=\"#cb31-4\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.ResourceScope;<\/span><\/span>\n+<span id=\"cb31-5\"><a href=\"#cb31-5\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.SegmentAllocator;<\/span><\/span>\n+<span id=\"cb31-6\"><a href=\"#cb31-6\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> org.sqlite.*;<\/span><\/span>\n+<span id=\"cb31-7\"><a href=\"#cb31-7\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/span>\n+<span id=\"cb31-8\"><a href=\"#cb31-8\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> org.sqlite.sqlite3_h.*;<\/span><\/span>\n+<span id=\"cb31-9\"><a href=\"#cb31-9\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb31-10\"><a href=\"#cb31-10\"><\/a><\/span>\n+<span id=\"cb31-11\"><a href=\"#cb31-11\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> SqliteMain {<\/span>\n+<span id=\"cb31-12\"><a href=\"#cb31-12\"><\/a>   <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) <span class=\"kw\">throws<\/span> <span class=\"bu\">Exception<\/span> {<\/span>\n+<span id=\"cb31-13\"><a href=\"#cb31-13\"><\/a>        <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb31-14\"><a href=\"#cb31-14\"><\/a>            var allocator = SegmentAllocator.<span class=\"fu\">ofScope<\/span>(scope);<\/span>\n+<span id=\"cb31-15\"><a href=\"#cb31-15\"><\/a>            <span class=\"co\">\/\/ char** errMsgPtrPtr;<\/span><\/span>\n+<span id=\"cb31-16\"><a href=\"#cb31-16\"><\/a>            var errMsgPtrPtr = allocator.<span class=\"fu\">allocate<\/span>(C_POINTER);<\/span>\n+<span id=\"cb31-17\"><a href=\"#cb31-17\"><\/a><\/span>\n+<span id=\"cb31-18\"><a href=\"#cb31-18\"><\/a>            <span class=\"co\">\/\/ sqlite3** dbPtrPtr;<\/span><\/span>\n+<span id=\"cb31-19\"><a href=\"#cb31-19\"><\/a>            var dbPtrPtr = allocator.<span class=\"fu\">allocate<\/span>(C_POINTER);<\/span>\n+<span id=\"cb31-20\"><a href=\"#cb31-20\"><\/a><\/span>\n+<span id=\"cb31-21\"><a href=\"#cb31-21\"><\/a>            <span class=\"dt\">int<\/span> rc = <span class=\"fu\">sqlite3_open<\/span>(<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;employee.db&quot;<\/span>,scope), dbPtrPtr);<\/span>\n+<span id=\"cb31-22\"><a href=\"#cb31-22\"><\/a>            <span class=\"kw\">if<\/span> (rc != <span class=\"dv\">0<\/span>) {<\/span>\n+<span id=\"cb31-23\"><a href=\"#cb31-23\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;sqlite3_open failed: &quot;<\/span> + rc);<\/span>\n+<span id=\"cb31-24\"><a href=\"#cb31-24\"><\/a>                <span class=\"kw\">return<\/span>;<\/span>\n+<span id=\"cb31-25\"><a href=\"#cb31-25\"><\/a>            } <span class=\"kw\">else<\/span> {<\/span>\n+<span id=\"cb31-26\"><a href=\"#cb31-26\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;employee db opened&quot;<\/span>);<\/span>\n+<span id=\"cb31-27\"><a href=\"#cb31-27\"><\/a>            }<\/span>\n+<span id=\"cb31-28\"><a href=\"#cb31-28\"><\/a><\/span>\n+<span id=\"cb31-29\"><a href=\"#cb31-29\"><\/a>            <span class=\"co\">\/\/ sqlite3* dbPtr;<\/span><\/span>\n+<span id=\"cb31-30\"><a href=\"#cb31-30\"><\/a>            var dbPtr = MemoryAccess.<span class=\"fu\">getAddress<\/span>(dbPtrPtr);<\/span>\n+<span id=\"cb31-31\"><a href=\"#cb31-31\"><\/a><\/span>\n+<span id=\"cb31-32\"><a href=\"#cb31-32\"><\/a>            <span class=\"co\">\/\/ create a new table<\/span><\/span>\n+<span id=\"cb31-33\"><a href=\"#cb31-33\"><\/a>            var sql = <span class=\"fu\">toCString<\/span>(<\/span>\n+<span id=\"cb31-34\"><a href=\"#cb31-34\"><\/a>                <span class=\"st\">&quot;CREATE TABLE EMPLOYEE (&quot;<\/span>  +<\/span>\n+<span id=\"cb31-35\"><a href=\"#cb31-35\"><\/a>                <span class=\"st\">&quot;  ID INT PRIMARY KEY NOT NULL,&quot;<\/span> +<\/span>\n+<span id=\"cb31-36\"><a href=\"#cb31-36\"><\/a>                <span class=\"st\">&quot;  NAME TEXT NOT NULL,&quot;<\/span>    +<\/span>\n+<span id=\"cb31-37\"><a href=\"#cb31-37\"><\/a>                <span class=\"st\">&quot;  SALARY REAL NOT NULL )&quot;<\/span>, scope);<\/span>\n+<span id=\"cb31-38\"><a href=\"#cb31-38\"><\/a><\/span>\n+<span id=\"cb31-39\"><a href=\"#cb31-39\"><\/a>            rc = <span class=\"fu\">sqlite3_exec<\/span>(dbPtr, sql, NULL, NULL, errMsgPtrPtr);<\/span>\n+<span id=\"cb31-40\"><a href=\"#cb31-40\"><\/a><\/span>\n+<span id=\"cb31-41\"><a href=\"#cb31-41\"><\/a>            <span class=\"kw\">if<\/span> (rc != <span class=\"dv\">0<\/span>) {<\/span>\n+<span id=\"cb31-42\"><a href=\"#cb31-42\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;sqlite3_exec failed: &quot;<\/span> + rc);<\/span>\n+<span id=\"cb31-43\"><a href=\"#cb31-43\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;SQL error: &quot;<\/span> + <span class=\"fu\">toJavaString<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr)));<\/span>\n+<span id=\"cb31-44\"><a href=\"#cb31-44\"><\/a>                <span class=\"fu\">sqlite3_free<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr));<\/span>\n+<span id=\"cb31-45\"><a href=\"#cb31-45\"><\/a>            } <span class=\"kw\">else<\/span> {<\/span>\n+<span id=\"cb31-46\"><a href=\"#cb31-46\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;employee table created&quot;<\/span>);<\/span>\n+<span id=\"cb31-47\"><a href=\"#cb31-47\"><\/a>            }<\/span>\n+<span id=\"cb31-48\"><a href=\"#cb31-48\"><\/a><\/span>\n+<span id=\"cb31-49\"><a href=\"#cb31-49\"><\/a>            <span class=\"co\">\/\/ insert two rows<\/span><\/span>\n+<span id=\"cb31-50\"><a href=\"#cb31-50\"><\/a>            sql = <span class=\"fu\">toCString<\/span>(<\/span>\n+<span id=\"cb31-51\"><a href=\"#cb31-51\"><\/a>                <span class=\"st\">&quot;INSERT INTO EMPLOYEE (ID,NAME,SALARY) &quot;<\/span> +<\/span>\n+<span id=\"cb31-52\"><a href=\"#cb31-52\"><\/a>                    <span class=\"st\">&quot;VALUES (134, &#39;Xyz&#39;, 200000.0); &quot;<\/span> +<\/span>\n+<span id=\"cb31-53\"><a href=\"#cb31-53\"><\/a>                <span class=\"st\">&quot;INSERT INTO EMPLOYEE (ID,NAME,SALARY) &quot;<\/span> +<\/span>\n+<span id=\"cb31-54\"><a href=\"#cb31-54\"><\/a>                    <span class=\"st\">&quot;VALUES (333, &#39;Abc&#39;, 100000.0);&quot;<\/span>, scope<\/span>\n+<span id=\"cb31-55\"><a href=\"#cb31-55\"><\/a>            );<\/span>\n+<span id=\"cb31-56\"><a href=\"#cb31-56\"><\/a>            rc = <span class=\"fu\">sqlite3_exec<\/span>(dbPtr, sql, NULL, NULL, errMsgPtrPtr);<\/span>\n+<span id=\"cb31-57\"><a href=\"#cb31-57\"><\/a><\/span>\n+<span id=\"cb31-58\"><a href=\"#cb31-58\"><\/a>            <span class=\"kw\">if<\/span> (rc != <span class=\"dv\">0<\/span>) {<\/span>\n+<span id=\"cb31-59\"><a href=\"#cb31-59\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;sqlite3_exec failed: &quot;<\/span> + rc);<\/span>\n+<span id=\"cb31-60\"><a href=\"#cb31-60\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;SQL error: &quot;<\/span> + <span class=\"fu\">toJavaString<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr)));<\/span>\n+<span id=\"cb31-61\"><a href=\"#cb31-61\"><\/a>                <span class=\"fu\">sqlite3_free<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr));<\/span>\n+<span id=\"cb31-62\"><a href=\"#cb31-62\"><\/a>            } <span class=\"kw\">else<\/span> {<\/span>\n+<span id=\"cb31-63\"><a href=\"#cb31-63\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;rows inserted&quot;<\/span>);<\/span>\n+<span id=\"cb31-64\"><a href=\"#cb31-64\"><\/a>            }<\/span>\n+<span id=\"cb31-65\"><a href=\"#cb31-65\"><\/a><\/span>\n+<span id=\"cb31-66\"><a href=\"#cb31-66\"><\/a>            <span class=\"dt\">int<\/span>[] rowNum = <span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[<span class=\"dv\">1<\/span>];<\/span>\n+<span id=\"cb31-67\"><a href=\"#cb31-67\"><\/a>            <span class=\"co\">\/\/ callback to print rows from SELECT query<\/span><\/span>\n+<span id=\"cb31-68\"><a href=\"#cb31-68\"><\/a>            var callback = sqlite3_exec$callback.<span class=\"fu\">allocate<\/span>((a, argc, argv, columnNames) -&gt; {<\/span>\n+<span id=\"cb31-69\"><a href=\"#cb31-69\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;Row num: &quot;<\/span> + rowNum[<span class=\"dv\">0<\/span>]++);<\/span>\n+<span id=\"cb31-70\"><a href=\"#cb31-70\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;numColumns = &quot;<\/span> + argc);<\/span>\n+<span id=\"cb31-71\"><a href=\"#cb31-71\"><\/a>                var argv_seg = argv.<span class=\"fu\">asSegment<\/span>(C_POINTER.<span class=\"fu\">byteSize<\/span>() * argc, scope);<\/span>\n+<span id=\"cb31-72\"><a href=\"#cb31-72\"><\/a>                var columnNames_seg = columnNames.<span class=\"fu\">asSegment<\/span>(C_POINTER.<span class=\"fu\">byteSize<\/span>() * argc, scope);<\/span>\n+<span id=\"cb31-73\"><a href=\"#cb31-73\"><\/a>                <span class=\"kw\">for<\/span> (<span class=\"dt\">int<\/span> i = <span class=\"dv\">0<\/span>; i &lt; argc; i++) {<\/span>\n+<span id=\"cb31-74\"><a href=\"#cb31-74\"><\/a>                     <span class=\"bu\">String<\/span> name = <span class=\"fu\">toJavaString<\/span>(MemoryAccess.<span class=\"fu\">getAddressAtIndex<\/span>(columnNames_seg, i));<\/span>\n+<span id=\"cb31-75\"><a href=\"#cb31-75\"><\/a>                     <span class=\"bu\">String<\/span> value = <span class=\"fu\">toJavaString<\/span>(MemoryAccess.<span class=\"fu\">getAddressAtIndex<\/span>(argv_seg, i));<\/span>\n+<span id=\"cb31-76\"><a href=\"#cb31-76\"><\/a>                     <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">%s<\/span><span class=\"st\"> = <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>, name, value);<\/span>\n+<span id=\"cb31-77\"><a href=\"#cb31-77\"><\/a>                }<\/span>\n+<span id=\"cb31-78\"><a href=\"#cb31-78\"><\/a>                <span class=\"kw\">return<\/span> <span class=\"dv\">0<\/span>;<\/span>\n+<span id=\"cb31-79\"><a href=\"#cb31-79\"><\/a>            }, scope);<\/span>\n+<span id=\"cb31-80\"><a href=\"#cb31-80\"><\/a><\/span>\n+<span id=\"cb31-81\"><a href=\"#cb31-81\"><\/a>            <span class=\"co\">\/\/ select query<\/span><\/span>\n+<span id=\"cb31-82\"><a href=\"#cb31-82\"><\/a>            sql = <span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;SELECT * FROM EMPLOYEE&quot;<\/span>, scope);<\/span>\n+<span id=\"cb31-83\"><a href=\"#cb31-83\"><\/a>            rc = <span class=\"fu\">sqlite3_exec<\/span>(dbPtr, sql, callback, NULL, errMsgPtrPtr);<\/span>\n+<span id=\"cb31-84\"><a href=\"#cb31-84\"><\/a><\/span>\n+<span id=\"cb31-85\"><a href=\"#cb31-85\"><\/a>            <span class=\"kw\">if<\/span> (rc != <span class=\"dv\">0<\/span>) {<\/span>\n+<span id=\"cb31-86\"><a href=\"#cb31-86\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;sqlite3_exec failed: &quot;<\/span> + rc);<\/span>\n+<span id=\"cb31-87\"><a href=\"#cb31-87\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;SQL error: &quot;<\/span> + <span class=\"fu\">toJavaString<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr)));<\/span>\n+<span id=\"cb31-88\"><a href=\"#cb31-88\"><\/a>                <span class=\"fu\">sqlite3_free<\/span>(MemoryAccess.<span class=\"fu\">getAddress<\/span>(errMsgPtrPtr));<\/span>\n+<span id=\"cb31-89\"><a href=\"#cb31-89\"><\/a>            } <span class=\"kw\">else<\/span> {<\/span>\n+<span id=\"cb31-90\"><a href=\"#cb31-90\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;done&quot;<\/span>);<\/span>\n+<span id=\"cb31-91\"><a href=\"#cb31-91\"><\/a>            }<\/span>\n+<span id=\"cb31-92\"><a href=\"#cb31-92\"><\/a><\/span>\n+<span id=\"cb31-93\"><a href=\"#cb31-93\"><\/a>            <span class=\"fu\">sqlite3_close<\/span>(dbPtr);<\/span>\n+<span id=\"cb31-94\"><a href=\"#cb31-94\"><\/a>        }<\/span>\n+<span id=\"cb31-95\"><a href=\"#cb31-95\"><\/a>    }<\/span>\n+<span id=\"cb31-96\"><a href=\"#cb31-96\"><\/a>}<\/span>\n+<span id=\"cb31-97\"><a href=\"#cb31-97\"><\/a><\/span><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-sqlite3-sample\">Compiling and running the sqlite3 sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb32\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb32-1\"><a href=\"#cb32-1\"><\/a><\/span>\n+<span id=\"cb32-2\"><a href=\"#cb32-2\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED \\<\/span>\n+<span id=\"cb32-3\"><a href=\"#cb32-3\"><\/a>   --add-modules jdk.incubator.foreign \\<\/span>\n+<span id=\"cb32-4\"><a href=\"#cb32-4\"><\/a>   -Djava.library.path=\/usr\/lib SqliteMain.java<\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-opengl-library-from-java-mac-os\">Using OpenGL library from Java (Mac OS)<\/h2>\n+<h3 id=\"jextract-glut.h\">jextract glut.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb33\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb33-1\"><a href=\"#cb33-1\"><\/a><\/span>\n+<span id=\"cb33-2\"><a href=\"#cb33-2\"><\/a><span class=\"ex\">jextract<\/span> -t opengl -lGL -l\/System\/Library\/Frameworks\/GLUT.framework\/Versions\/Current\/GLUT \\<\/span>\n+<span id=\"cb33-3\"><a href=\"#cb33-3\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/span>\n+<span id=\"cb33-4\"><a href=\"#cb33-4\"><\/a>  -C-F\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks \\<\/span>\n+<span id=\"cb33-5\"><a href=\"#cb33-5\"><\/a>  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\/GLUT.framework\/Headers\/glut.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-opengl\">Java program that uses OpenGL<\/h3>\n+<div class=\"sourceCode\" id=\"cb34\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb34-1\"><a href=\"#cb34-1\"><\/a><\/span>\n+<span id=\"cb34-2\"><a href=\"#cb34-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker;<\/span><\/span>\n+<span id=\"cb34-3\"><a href=\"#cb34-3\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.ResourceScope;<\/span><\/span>\n+<span id=\"cb34-4\"><a href=\"#cb34-4\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.SegmentAllocator;<\/span><\/span>\n+<span id=\"cb34-5\"><a href=\"#cb34-5\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> opengl.*;<\/span><\/span>\n+<span id=\"cb34-6\"><a href=\"#cb34-6\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb34-7\"><a href=\"#cb34-7\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> opengl.glut_h.*;<\/span><\/span>\n+<span id=\"cb34-8\"><a href=\"#cb34-8\"><\/a><\/span>\n+<span id=\"cb34-9\"><a href=\"#cb34-9\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> Teapot {<\/span>\n+<span id=\"cb34-10\"><a href=\"#cb34-10\"><\/a>    <span class=\"kw\">private<\/span> <span class=\"dt\">float<\/span> rot = <span class=\"dv\">0<\/span>;<\/span>\n+<span id=\"cb34-11\"><a href=\"#cb34-11\"><\/a><\/span>\n+<span id=\"cb34-12\"><a href=\"#cb34-12\"><\/a>    <span class=\"fu\">Teapot<\/span>(SegmentAllocator allocator) {<\/span>\n+<span id=\"cb34-13\"><a href=\"#cb34-13\"><\/a>        <span class=\"co\">\/\/ Reset Background<\/span><\/span>\n+<span id=\"cb34-14\"><a href=\"#cb34-14\"><\/a>        <span class=\"fu\">glClearColor<\/span>(<span class=\"fl\">0f<\/span>, <span class=\"fl\">0f<\/span>, <span class=\"fl\">0f<\/span>, <span class=\"fl\">0f<\/span>);<\/span>\n+<span id=\"cb34-15\"><a href=\"#cb34-15\"><\/a>        <span class=\"co\">\/\/ Setup Lighting<\/span><\/span>\n+<span id=\"cb34-16\"><a href=\"#cb34-16\"><\/a>        <span class=\"fu\">glShadeModel<\/span>(<span class=\"fu\">GL_SMOOTH<\/span>());<\/span>\n+<span id=\"cb34-17\"><a href=\"#cb34-17\"><\/a>        var pos = allocator.<span class=\"fu\">allocateArray<\/span>(C_FLOAT, <span class=\"kw\">new<\/span> <span class=\"dt\">float<\/span>[] {<span class=\"fl\">0.0f<\/span>, <span class=\"fl\">15.0f<\/span>, -<span class=\"fl\">15.0f<\/span>, <span class=\"dv\">0<\/span>});<\/span>\n+<span id=\"cb34-18\"><a href=\"#cb34-18\"><\/a>        <span class=\"fu\">glLightfv<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>(), <span class=\"fu\">GL_POSITION<\/span>(), pos);<\/span>\n+<span id=\"cb34-19\"><a href=\"#cb34-19\"><\/a>        var spec = allocator.<span class=\"fu\">allocateArray<\/span>(C_FLOAT, <span class=\"kw\">new<\/span> <span class=\"dt\">float<\/span>[] {<span class=\"dv\">1<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">1<\/span>, <span class=\"dv\">0<\/span>});<\/span>\n+<span id=\"cb34-20\"><a href=\"#cb34-20\"><\/a>        <span class=\"fu\">glLightfv<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>(), <span class=\"fu\">GL_AMBIENT<\/span>(), spec);<\/span>\n+<span id=\"cb34-21\"><a href=\"#cb34-21\"><\/a>        <span class=\"fu\">glLightfv<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>(), <span class=\"fu\">GL_DIFFUSE<\/span>(), spec);<\/span>\n+<span id=\"cb34-22\"><a href=\"#cb34-22\"><\/a>        <span class=\"fu\">glLightfv<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>(), <span class=\"fu\">GL_SPECULAR<\/span>(), spec);<\/span>\n+<span id=\"cb34-23\"><a href=\"#cb34-23\"><\/a>        var shini = allocator.<span class=\"fu\">allocate<\/span>(C_FLOAT, <span class=\"dv\">113<\/span>);<\/span>\n+<span id=\"cb34-24\"><a href=\"#cb34-24\"><\/a>        <span class=\"fu\">glMaterialfv<\/span>(<span class=\"fu\">GL_FRONT<\/span>(), <span class=\"fu\">GL_SHININESS<\/span>(), shini);<\/span>\n+<span id=\"cb34-25\"><a href=\"#cb34-25\"><\/a>        <span class=\"fu\">glEnable<\/span>(<span class=\"fu\">GL_LIGHTING<\/span>());<\/span>\n+<span id=\"cb34-26\"><a href=\"#cb34-26\"><\/a>        <span class=\"fu\">glEnable<\/span>(<span class=\"fu\">GL_LIGHT0<\/span>());<\/span>\n+<span id=\"cb34-27\"><a href=\"#cb34-27\"><\/a>        <span class=\"fu\">glEnable<\/span>(<span class=\"fu\">GL_DEPTH_TEST<\/span>());<\/span>\n+<span id=\"cb34-28\"><a href=\"#cb34-28\"><\/a>    }<\/span>\n+<span id=\"cb34-29\"><a href=\"#cb34-29\"><\/a><\/span>\n+<span id=\"cb34-30\"><a href=\"#cb34-30\"><\/a>    <span class=\"dt\">void<\/span> <span class=\"fu\">display<\/span>() {<\/span>\n+<span id=\"cb34-31\"><a href=\"#cb34-31\"><\/a>        <span class=\"fu\">glClear<\/span>(<span class=\"fu\">GL_COLOR_BUFFER_BIT<\/span>() | <span class=\"fu\">GL_DEPTH_BUFFER_BIT<\/span>());<\/span>\n+<span id=\"cb34-32\"><a href=\"#cb34-32\"><\/a>        <span class=\"fu\">glPushMatrix<\/span>();<\/span>\n+<span id=\"cb34-33\"><a href=\"#cb34-33\"><\/a>        <span class=\"fu\">glRotatef<\/span>(-<span class=\"fl\">20f<\/span>, <span class=\"fl\">1f<\/span>, <span class=\"fl\">1f<\/span>, <span class=\"fl\">0f<\/span>);<\/span>\n+<span id=\"cb34-34\"><a href=\"#cb34-34\"><\/a>        <span class=\"fu\">glRotatef<\/span>(rot, <span class=\"fl\">0f<\/span>, <span class=\"fl\">1f<\/span>, <span class=\"fl\">0f<\/span>);<\/span>\n+<span id=\"cb34-35\"><a href=\"#cb34-35\"><\/a>        <span class=\"fu\">glutSolidTeapot<\/span>(<span class=\"fl\">0.5d<\/span>);<\/span>\n+<span id=\"cb34-36\"><a href=\"#cb34-36\"><\/a>        <span class=\"fu\">glPopMatrix<\/span>();<\/span>\n+<span id=\"cb34-37\"><a href=\"#cb34-37\"><\/a>        <span class=\"fu\">glutSwapBuffers<\/span>();<\/span>\n+<span id=\"cb34-38\"><a href=\"#cb34-38\"><\/a>    }<\/span>\n+<span id=\"cb34-39\"><a href=\"#cb34-39\"><\/a><\/span>\n+<span id=\"cb34-40\"><a href=\"#cb34-40\"><\/a>    <span class=\"dt\">void<\/span> <span class=\"fu\">onIdle<\/span>() {<\/span>\n+<span id=\"cb34-41\"><a href=\"#cb34-41\"><\/a>        rot += <span class=\"fl\">0.<\/span><span class=\"dv\">1<\/span>;<\/span>\n+<span id=\"cb34-42\"><a href=\"#cb34-42\"><\/a>        <span class=\"fu\">glutPostRedisplay<\/span>();<\/span>\n+<span id=\"cb34-43\"><a href=\"#cb34-43\"><\/a>    }<\/span>\n+<span id=\"cb34-44\"><a href=\"#cb34-44\"><\/a><\/span>\n+<span id=\"cb34-45\"><a href=\"#cb34-45\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb34-46\"><a href=\"#cb34-46\"><\/a>        <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb34-47\"><a href=\"#cb34-47\"><\/a>            var allocator = SegmentAllocator.<span class=\"fu\">ofScope<\/span>(scope);<\/span>\n+<span id=\"cb34-48\"><a href=\"#cb34-48\"><\/a>            var argc = allocator.<span class=\"fu\">allocate<\/span>(C_INT, <span class=\"dv\">0<\/span>);<\/span>\n+<span id=\"cb34-49\"><a href=\"#cb34-49\"><\/a>            <span class=\"fu\">glutInit<\/span>(argc, argc);<\/span>\n+<span id=\"cb34-50\"><a href=\"#cb34-50\"><\/a>            <span class=\"fu\">glutInitDisplayMode<\/span>(<span class=\"fu\">GLUT_DOUBLE<\/span>() | <span class=\"fu\">GLUT_RGB<\/span>() | <span class=\"fu\">GLUT_DEPTH<\/span>());<\/span>\n+<span id=\"cb34-51\"><a href=\"#cb34-51\"><\/a>            <span class=\"fu\">glutInitWindowSize<\/span>(<span class=\"dv\">500<\/span>, <span class=\"dv\">500<\/span>);<\/span>\n+<span id=\"cb34-52\"><a href=\"#cb34-52\"><\/a>            <span class=\"fu\">glutCreateWindow<\/span>(CLinker.<span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;Hello Panama!&quot;<\/span>, scope));<\/span>\n+<span id=\"cb34-53\"><a href=\"#cb34-53\"><\/a>            var teapot = <span class=\"kw\">new<\/span> <span class=\"fu\">Teapot<\/span>(allocator);<\/span>\n+<span id=\"cb34-54\"><a href=\"#cb34-54\"><\/a>            var displayStub = glutDisplayFunc$func.<span class=\"fu\">allocate<\/span>(teapot::display, scope);<\/span>\n+<span id=\"cb34-55\"><a href=\"#cb34-55\"><\/a>            var idleStub = glutIdleFunc$func.<span class=\"fu\">allocate<\/span>(teapot::onIdle, scope);<\/span>\n+<span id=\"cb34-56\"><a href=\"#cb34-56\"><\/a>            <span class=\"fu\">glutDisplayFunc<\/span>(displayStub);<\/span>\n+<span id=\"cb34-57\"><a href=\"#cb34-57\"><\/a>            <span class=\"fu\">glutIdleFunc<\/span>(idleStub);<\/span>\n+<span id=\"cb34-58\"><a href=\"#cb34-58\"><\/a>            <span class=\"fu\">glutMainLoop<\/span>();<\/span>\n+<span id=\"cb34-59\"><a href=\"#cb34-59\"><\/a>        }<\/span>\n+<span id=\"cb34-60\"><a href=\"#cb34-60\"><\/a>    }<\/span>\n+<span id=\"cb34-61\"><a href=\"#cb34-61\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-opengl-sample\">Compiling and running the OpenGL sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb35\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb35-1\"><a href=\"#cb35-1\"><\/a><\/span>\n+<span id=\"cb35-2\"><a href=\"#cb35-2\"><\/a><span class=\"ex\">java<\/span> -XstartOnFirstThread --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\<\/span>\n+<span id=\"cb35-3\"><a href=\"#cb35-3\"><\/a>    -Djava.library.path=.:\/System\/Library\/Frameworks\/OpenGL.framework\/Versions\/Current\/Libraries\/ Teapot.java <span class=\"va\">$*<\/span><\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-tensorflow-mac-os\">Using tensorflow (Mac OS)<\/h2>\n+<h3 id=\"getting-libtensorflow\">getting libtensorflow<\/h3>\n+<ul>\n+<li><p>Download tensorflow library from<\/p>\n+<p>https:\/\/www.tensorflow.org\/install\/lang_c<\/p><\/li>\n+<li><p>extract the downloaded tar in a directory called LIBTENSORFLOW_HOME<\/p><\/li>\n+<\/ul>\n+<h3 id=\"jextract-c_api.h\">jextract c_api.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb36\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb36-1\"><a href=\"#cb36-1\"><\/a><\/span>\n+<span id=\"cb36-2\"><a href=\"#cb36-2\"><\/a><span class=\"ex\">jextract<\/span> --source \\<\/span>\n+<span id=\"cb36-3\"><a href=\"#cb36-3\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/span>\n+<span id=\"cb36-4\"><a href=\"#cb36-4\"><\/a>  -t org.tensorflow \\<\/span>\n+<span id=\"cb36-5\"><a href=\"#cb36-5\"><\/a>  -I <span class=\"va\">${LIBTENSORFLOW_HOME}<\/span>\/include \\<\/span>\n+<span id=\"cb36-6\"><a href=\"#cb36-6\"><\/a>  -l <span class=\"va\">${LIBTENSORFLOW_HOME}<\/span>\/lib\/libtensorflow.dylib \\<\/span>\n+<span id=\"cb36-7\"><a href=\"#cb36-7\"><\/a>  <span class=\"va\">${LIBTENSORFLOW_HOME}<\/span>\/include\/tensorflow\/c\/c_api.h<\/span>\n+<span id=\"cb36-8\"><a href=\"#cb36-8\"><\/a><\/span>\n+<span id=\"cb36-9\"><a href=\"#cb36-9\"><\/a><span class=\"ex\">javac<\/span> --add-modules jdk.incubator.foreign org\/tensorflow\/*.java<\/span><\/code><\/pre><\/div>\n+<h3 id=\"python-program-that-creates-and-saves-model\">Python program that creates and saves model<\/h3>\n+<p>The following Python program should be run to create and save model which will read and printed by a Java program.<\/p>\n+<p>Note: you need to install tensorflow package to run this python script.<\/p>\n+<div class=\"sourceCode\" id=\"cb37\"><pre class=\"sourceCode python\"><code class=\"sourceCode python\"><span id=\"cb37-1\"><a href=\"#cb37-1\"><\/a><\/span>\n+<span id=\"cb37-2\"><a href=\"#cb37-2\"><\/a><span class=\"im\">import<\/span> tensorflow <span class=\"im\">as<\/span> tf<\/span>\n+<span id=\"cb37-3\"><a href=\"#cb37-3\"><\/a><span class=\"im\">from<\/span> tensorflow.keras <span class=\"im\">import<\/span> models, layers<\/span>\n+<span id=\"cb37-4\"><a href=\"#cb37-4\"><\/a><span class=\"im\">from<\/span> tensorflow.keras.datasets <span class=\"im\">import<\/span> mnist<\/span>\n+<span id=\"cb37-5\"><a href=\"#cb37-5\"><\/a><\/span>\n+<span id=\"cb37-6\"><a href=\"#cb37-6\"><\/a>model <span class=\"op\">=<\/span> tf.keras.models.Sequential([<\/span>\n+<span id=\"cb37-7\"><a href=\"#cb37-7\"><\/a>  tf.keras.layers.Flatten(input_shape<span class=\"op\">=<\/span>(<span class=\"dv\">28<\/span>, <span class=\"dv\">28<\/span>)),<\/span>\n+<span id=\"cb37-8\"><a href=\"#cb37-8\"><\/a>  tf.keras.layers.Dense(<span class=\"dv\">128<\/span>,activation<span class=\"op\">=<\/span><span class=\"st\">&#39;relu&#39;<\/span>),<\/span>\n+<span id=\"cb37-9\"><a href=\"#cb37-9\"><\/a>  tf.keras.layers.Dense(<span class=\"dv\">10<\/span>, activation<span class=\"op\">=<\/span><span class=\"st\">&#39;softmax&#39;<\/span>)<\/span>\n+<span id=\"cb37-10\"><a href=\"#cb37-10\"><\/a>])<\/span>\n+<span id=\"cb37-11\"><a href=\"#cb37-11\"><\/a><\/span>\n+<span id=\"cb37-12\"><a href=\"#cb37-12\"><\/a>model.<span class=\"bu\">compile<\/span>(<\/span>\n+<span id=\"cb37-13\"><a href=\"#cb37-13\"><\/a>    loss<span class=\"op\">=<\/span><span class=\"st\">&#39;sparse_categorical_crossentropy&#39;<\/span>,<\/span>\n+<span id=\"cb37-14\"><a href=\"#cb37-14\"><\/a>    optimizer<span class=\"op\">=<\/span>tf.keras.optimizers.Adam(<span class=\"fl\">0.001<\/span>),<\/span>\n+<span id=\"cb37-15\"><a href=\"#cb37-15\"><\/a>    metrics<span class=\"op\">=<\/span>[<span class=\"st\">&#39;accuracy&#39;<\/span>],<\/span>\n+<span id=\"cb37-16\"><a href=\"#cb37-16\"><\/a>)<\/span>\n+<span id=\"cb37-17\"><a href=\"#cb37-17\"><\/a><\/span>\n+<span id=\"cb37-18\"><a href=\"#cb37-18\"><\/a><span class=\"bu\">print<\/span>(model.summary())<\/span>\n+<span id=\"cb37-19\"><a href=\"#cb37-19\"><\/a><\/span>\n+<span id=\"cb37-20\"><a href=\"#cb37-20\"><\/a>(train_images, train_labels), (test_images, test_labels) <span class=\"op\">=<\/span> mnist.load_data()<\/span>\n+<span id=\"cb37-21\"><a href=\"#cb37-21\"><\/a><\/span>\n+<span id=\"cb37-22\"><a href=\"#cb37-22\"><\/a>train_images <span class=\"op\">=<\/span> train_images<span class=\"op\">\/<\/span><span class=\"fl\">255.0<\/span><\/span>\n+<span id=\"cb37-23\"><a href=\"#cb37-23\"><\/a>test_images <span class=\"op\">=<\/span> test_images<span class=\"op\">\/<\/span><span class=\"fl\">255.0<\/span><\/span>\n+<span id=\"cb37-24\"><a href=\"#cb37-24\"><\/a><\/span>\n+<span id=\"cb37-25\"><a href=\"#cb37-25\"><\/a>model.fit(train_images, train_labels,<\/span>\n+<span id=\"cb37-26\"><a href=\"#cb37-26\"><\/a>    epochs<span class=\"op\">=<\/span><span class=\"dv\">4<\/span>, batch_size<span class=\"op\">=<\/span><span class=\"dv\">128<\/span>, verbose<span class=\"op\">=<\/span><span class=\"dv\">1<\/span>)<\/span>\n+<span id=\"cb37-27\"><a href=\"#cb37-27\"><\/a><\/span>\n+<span id=\"cb37-28\"><a href=\"#cb37-28\"><\/a>test_loss, test_accuracy <span class=\"op\">=<\/span> model.evaluate(test_images, test_labels)<\/span>\n+<span id=\"cb37-29\"><a href=\"#cb37-29\"><\/a><\/span>\n+<span id=\"cb37-30\"><a href=\"#cb37-30\"><\/a><span class=\"bu\">print<\/span>(test_loss, test_accuracy)<\/span>\n+<span id=\"cb37-31\"><a href=\"#cb37-31\"><\/a><\/span>\n+<span id=\"cb37-32\"><a href=\"#cb37-32\"><\/a>model.save(<span class=\"st\">&quot;saved_mnist_model&quot;<\/span>)<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-tensorflow-c-api\">Java program that uses Tensorflow C API<\/h3>\n+<div class=\"sourceCode\" id=\"cb38\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb38-1\"><a href=\"#cb38-1\"><\/a><\/span>\n+<span id=\"cb38-2\"><a href=\"#cb38-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.*;<\/span><\/span>\n+<span id=\"cb38-3\"><a href=\"#cb38-3\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb38-4\"><a href=\"#cb38-4\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAccess.*;<\/span><\/span>\n+<span id=\"cb38-5\"><a href=\"#cb38-5\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.*;<\/span><\/span>\n+<span id=\"cb38-6\"><a href=\"#cb38-6\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> org.tensorflow.c_api_h.*;<\/span><\/span>\n+<span id=\"cb38-7\"><a href=\"#cb38-7\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> org.tensorflow.*;<\/span><\/span>\n+<span id=\"cb38-8\"><a href=\"#cb38-8\"><\/a><\/span>\n+<span id=\"cb38-9\"><a href=\"#cb38-9\"><\/a><span class=\"co\">\/\/ simple program that loads saved model and prints basic info on operations in it<\/span><\/span>\n+<span id=\"cb38-10\"><a href=\"#cb38-10\"><\/a><\/span>\n+<span id=\"cb38-11\"><a href=\"#cb38-11\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> TensorflowLoadSavedModel {<\/span>\n+<span id=\"cb38-12\"><a href=\"#cb38-12\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span><span class=\"kw\">... <\/span>args) <span class=\"kw\">throws<\/span> <span class=\"bu\">Exception<\/span> {<\/span>\n+<span id=\"cb38-13\"><a href=\"#cb38-13\"><\/a>        <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;TensorFlow C library version: &quot;<\/span> + <span class=\"fu\">toJavaString<\/span>(<span class=\"fu\">TF_Version<\/span>()));<\/span>\n+<span id=\"cb38-14\"><a href=\"#cb38-14\"><\/a><\/span>\n+<span id=\"cb38-15\"><a href=\"#cb38-15\"><\/a>        <span class=\"kw\">if<\/span> (args.<span class=\"fu\">length<\/span> == <span class=\"dv\">0<\/span>) {<\/span>\n+<span id=\"cb38-16\"><a href=\"#cb38-16\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;java TensorflowLoadSavedModel &lt;saved model dir&gt;&quot;<\/span>);<\/span>\n+<span id=\"cb38-17\"><a href=\"#cb38-17\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">exit<\/span>(<span class=\"dv\">1<\/span>);<\/span>\n+<span id=\"cb38-18\"><a href=\"#cb38-18\"><\/a>        }<\/span>\n+<span id=\"cb38-19\"><a href=\"#cb38-19\"><\/a><\/span>\n+<span id=\"cb38-20\"><a href=\"#cb38-20\"><\/a>        <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb38-21\"><a href=\"#cb38-21\"><\/a>            var allocator = SegmentAllocator.<span class=\"fu\">ofScope<\/span>(scope);<\/span>\n+<span id=\"cb38-22\"><a href=\"#cb38-22\"><\/a>            var graph = <span class=\"fu\">TF_NewGraph<\/span>();<\/span>\n+<span id=\"cb38-23\"><a href=\"#cb38-23\"><\/a>            var status = <span class=\"fu\">TF_NewStatus<\/span>();<\/span>\n+<span id=\"cb38-24\"><a href=\"#cb38-24\"><\/a>            var sessionOpts = <span class=\"fu\">TF_NewSessionOptions<\/span>();<\/span>\n+<span id=\"cb38-25\"><a href=\"#cb38-25\"><\/a><\/span>\n+<span id=\"cb38-26\"><a href=\"#cb38-26\"><\/a>            var savedModelDir = <span class=\"fu\">toCString<\/span>(args[<span class=\"dv\">0<\/span>], scope);<\/span>\n+<span id=\"cb38-27\"><a href=\"#cb38-27\"><\/a>            var tags = allocator.<span class=\"fu\">allocate<\/span>(C_POINTER, <span class=\"fu\">toCString<\/span>(<span class=\"st\">&quot;serve&quot;<\/span>, scope));<\/span>\n+<span id=\"cb38-28\"><a href=\"#cb38-28\"><\/a>            var session = <span class=\"fu\">TF_LoadSessionFromSavedModel<\/span>(sessionOpts, NULL, savedModelDir, tags, <span class=\"dv\">1<\/span>, graph, NULL, status);<\/span>\n+<span id=\"cb38-29\"><a href=\"#cb38-29\"><\/a><\/span>\n+<span id=\"cb38-30\"><a href=\"#cb38-30\"><\/a>            <span class=\"kw\">if<\/span> (<span class=\"fu\">TF_GetCode<\/span>(status) != <span class=\"fu\">TF_OK<\/span>()) {<\/span>\n+<span id=\"cb38-31\"><a href=\"#cb38-31\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">err.printf<\/span>(<span class=\"st\">&quot;cannot load session from saved model: <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>,<\/span>\n+<span id=\"cb38-32\"><a href=\"#cb38-32\"><\/a>                    <span class=\"fu\">toJavaString<\/span>(<span class=\"fu\">TF_Message<\/span>(status)));<\/span>\n+<span id=\"cb38-33\"><a href=\"#cb38-33\"><\/a>            } <span class=\"kw\">else<\/span> {<\/span>\n+<span id=\"cb38-34\"><a href=\"#cb38-34\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;load session from saved model works!&quot;<\/span>);<\/span>\n+<span id=\"cb38-35\"><a href=\"#cb38-35\"><\/a>            }<\/span>\n+<span id=\"cb38-36\"><a href=\"#cb38-36\"><\/a><\/span>\n+<span id=\"cb38-37\"><a href=\"#cb38-37\"><\/a>            <span class=\"co\">\/\/ print operations<\/span><\/span>\n+<span id=\"cb38-38\"><a href=\"#cb38-38\"><\/a>            var size = allocator.<span class=\"fu\">allocate<\/span>(C_LONG_LONG);<\/span>\n+<span id=\"cb38-39\"><a href=\"#cb38-39\"><\/a>            var operation = NULL;<\/span>\n+<span id=\"cb38-40\"><a href=\"#cb38-40\"><\/a>            <span class=\"kw\">while<\/span> (!(operation = <span class=\"fu\">TF_GraphNextOperation<\/span>(graph, size)).<span class=\"fu\">equals<\/span>(NULL)) {<\/span>\n+<span id=\"cb38-41\"><a href=\"#cb38-41\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">%s<\/span><span class=\"st\"> : <\/span><span class=\"sc\">%s\\n<\/span><span class=\"st\">&quot;<\/span>,<\/span>\n+<span id=\"cb38-42\"><a href=\"#cb38-42\"><\/a>                    <span class=\"fu\">toJavaString<\/span>(<span class=\"fu\">TF_OperationName<\/span>(operation)),<\/span>\n+<span id=\"cb38-43\"><a href=\"#cb38-43\"><\/a>                    <span class=\"fu\">toJavaString<\/span>(<span class=\"fu\">TF_OperationOpType<\/span>(operation)));<\/span>\n+<span id=\"cb38-44\"><a href=\"#cb38-44\"><\/a>            }<\/span>\n+<span id=\"cb38-45\"><a href=\"#cb38-45\"><\/a><\/span>\n+<span id=\"cb38-46\"><a href=\"#cb38-46\"><\/a>            <span class=\"fu\">TF_DeleteGraph<\/span>(graph);<\/span>\n+<span id=\"cb38-47\"><a href=\"#cb38-47\"><\/a>            <span class=\"fu\">TF_DeleteSession<\/span>(session, status);<\/span>\n+<span id=\"cb38-48\"><a href=\"#cb38-48\"><\/a>            <span class=\"fu\">TF_DeleteSessionOptions<\/span>(sessionOpts);<\/span>\n+<span id=\"cb38-49\"><a href=\"#cb38-49\"><\/a>            <span class=\"fu\">TF_DeleteStatus<\/span>(status);<\/span>\n+<span id=\"cb38-50\"><a href=\"#cb38-50\"><\/a>        }<\/span>\n+<span id=\"cb38-51\"><a href=\"#cb38-51\"><\/a>    }<\/span>\n+<span id=\"cb38-52\"><a href=\"#cb38-52\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-java-tensorflow-sample\">Compiling and running the Java Tensorflow sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb39\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb39-1\"><a href=\"#cb39-1\"><\/a><\/span>\n+<span id=\"cb39-2\"><a href=\"#cb39-2\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\<\/span>\n+<span id=\"cb39-3\"><a href=\"#cb39-3\"><\/a>   TensorflowLoadSavedModel.java saved_mnist_model<\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-time.h-mac-os\">Using time.h (Mac OS)<\/h2>\n+<h3 id=\"jextract-time.h\">jextract time.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb40\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb40-1\"><a href=\"#cb40-1\"><\/a><\/span>\n+<span id=\"cb40-2\"><a href=\"#cb40-2\"><\/a><span class=\"ex\">jextract<\/span> -t org.unix \\<\/span>\n+<span id=\"cb40-3\"><a href=\"#cb40-3\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\<\/span>\n+<span id=\"cb40-4\"><a href=\"#cb40-4\"><\/a>   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/time.h<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-posix-time-library\">Java program that uses POSIX time library<\/h3>\n+<div class=\"sourceCode\" id=\"cb41\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb41-1\"><a href=\"#cb41-1\"><\/a><\/span>\n+<span id=\"cb41-2\"><a href=\"#cb41-2\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> org.unix.time_h.*;<\/span><\/span>\n+<span id=\"cb41-3\"><a href=\"#cb41-3\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb41-4\"><a href=\"#cb41-4\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.*;<\/span><\/span>\n+<span id=\"cb41-5\"><a href=\"#cb41-5\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> org.unix.*;<\/span><\/span>\n+<span id=\"cb41-6\"><a href=\"#cb41-6\"><\/a><\/span>\n+<span id=\"cb41-7\"><a href=\"#cb41-7\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> PanamaTime {<\/span>\n+<span id=\"cb41-8\"><a href=\"#cb41-8\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb41-9\"><a href=\"#cb41-9\"><\/a>        <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb41-10\"><a href=\"#cb41-10\"><\/a>            var allocator = SegmentAllocator.<span class=\"fu\">ofScope<\/span>(scope);<\/span>\n+<span id=\"cb41-11\"><a href=\"#cb41-11\"><\/a>            var now = allocator.<span class=\"fu\">allocate<\/span>(C_LONG, <span class=\"bu\">System<\/span>.<span class=\"fu\">currentTimeMillis<\/span>() \/ <span class=\"dv\">1000<\/span>);<\/span>\n+<span id=\"cb41-12\"><a href=\"#cb41-12\"><\/a>            MemorySegment time = tm.<span class=\"fu\">allocate<\/span>(scope);<\/span>\n+<span id=\"cb41-13\"><a href=\"#cb41-13\"><\/a>            <span class=\"fu\">localtime_r<\/span>(now, time);<\/span>\n+<span id=\"cb41-14\"><a href=\"#cb41-14\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">err.printf<\/span>(<span class=\"st\">&quot;Time = <\/span><span class=\"sc\">%d<\/span><span class=\"st\">:<\/span><span class=\"sc\">%d\\n<\/span><span class=\"st\">&quot;<\/span>, tm.<span class=\"fu\">tm_hour<\/span>$<span class=\"fu\">get<\/span>(time), tm.<span class=\"fu\">tm_min<\/span>$<span class=\"fu\">get<\/span>(time));<\/span>\n+<span id=\"cb41-15\"><a href=\"#cb41-15\"><\/a>        }<\/span>\n+<span id=\"cb41-16\"><a href=\"#cb41-16\"><\/a>    }<\/span>\n+<span id=\"cb41-17\"><a href=\"#cb41-17\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-time-sample\">Compiling and running the time sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb42\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb42-1\"><a href=\"#cb42-1\"><\/a><\/span>\n+<span id=\"cb42-2\"><a href=\"#cb42-2\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign PanamaTime.java<\/span><\/code><\/pre><\/div>\n+<h2 id=\"using-libclang-library-mac-os\">Using libclang library (Mac OS)<\/h2>\n+<h3 id=\"jextract-index.h\">jextract Index.h<\/h3>\n+<div class=\"sourceCode\" id=\"cb43\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb43-1\"><a href=\"#cb43-1\"><\/a><\/span>\n+<span id=\"cb43-2\"><a href=\"#cb43-2\"><\/a><span class=\"co\"># LIBCLANG_HOME is the directory where you&#39;ve installed llvm 9.x or above<\/span><\/span>\n+<span id=\"cb43-3\"><a href=\"#cb43-3\"><\/a><\/span>\n+<span id=\"cb43-4\"><a href=\"#cb43-4\"><\/a><span class=\"ex\">jextract<\/span> --source -t org.llvm.clang -lclang \\<\/span>\n+<span id=\"cb43-5\"><a href=\"#cb43-5\"><\/a>  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\<\/span>\n+<span id=\"cb43-6\"><a href=\"#cb43-6\"><\/a>  -I <span class=\"va\">${LIBCLANG_HOME}<\/span>\/include\/ \\<\/span>\n+<span id=\"cb43-7\"><a href=\"#cb43-7\"><\/a>  -I <span class=\"va\">${LIBCLANG_HOME}<\/span>\/include\/clang-c \\<\/span>\n+<span id=\"cb43-8\"><a href=\"#cb43-8\"><\/a>  <span class=\"va\">${LIBCLANG_HOME}<\/span>\/include\/clang-c\/Index.h<\/span>\n+<span id=\"cb43-9\"><a href=\"#cb43-9\"><\/a><span class=\"ex\">javac<\/span> --add-modules jdk.incubator.foreign org\/llvm\/clang\/*.java<\/span><\/code><\/pre><\/div>\n+<h3 id=\"java-program-that-uses-libclang-to-print-ast-of-a-given-c-program\">Java program that uses libclang to print AST of a given C program<\/h3>\n+<div class=\"sourceCode\" id=\"cb44\"><pre class=\"sourceCode java\"><code class=\"sourceCode java\"><span id=\"cb44-1\"><a href=\"#cb44-1\"><\/a><\/span>\n+<span id=\"cb44-2\"><a href=\"#cb44-2\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> jdk.incubator.foreign.*;<\/span><\/span>\n+<span id=\"cb44-3\"><a href=\"#cb44-3\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.CLinker.*;<\/span><\/span>\n+<span id=\"cb44-4\"><a href=\"#cb44-4\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> jdk.incubator.foreign.MemoryAddress.NULL;<\/span><\/span>\n+<span id=\"cb44-5\"><a href=\"#cb44-5\"><\/a><span class=\"kw\">import static<\/span><span class=\"im\"> org.llvm.clang.Index_h.*;<\/span><\/span>\n+<span id=\"cb44-6\"><a href=\"#cb44-6\"><\/a><span class=\"kw\">import<\/span><span class=\"im\"> org.llvm.clang.*;<\/span><\/span>\n+<span id=\"cb44-7\"><a href=\"#cb44-7\"><\/a><\/span>\n+<span id=\"cb44-8\"><a href=\"#cb44-8\"><\/a><span class=\"kw\">public<\/span> <span class=\"kw\">class<\/span> ASTPrinter {<\/span>\n+<span id=\"cb44-9\"><a href=\"#cb44-9\"><\/a>    <span class=\"kw\">private<\/span> <span class=\"dt\">static<\/span> <span class=\"bu\">String<\/span> <span class=\"fu\">asJavaString<\/span>(MemorySegment clangStr) {<\/span>\n+<span id=\"cb44-10\"><a href=\"#cb44-10\"><\/a>        <span class=\"bu\">String<\/span> str = <span class=\"fu\">toJavaString<\/span>(<span class=\"fu\">clang_getCString<\/span>(clangStr));<\/span>\n+<span id=\"cb44-11\"><a href=\"#cb44-11\"><\/a>        <span class=\"fu\">clang_disposeString<\/span>(clangStr);<\/span>\n+<span id=\"cb44-12\"><a href=\"#cb44-12\"><\/a>        <span class=\"kw\">return<\/span> str;<\/span>\n+<span id=\"cb44-13\"><a href=\"#cb44-13\"><\/a>    }<\/span>\n+<span id=\"cb44-14\"><a href=\"#cb44-14\"><\/a><\/span>\n+<span id=\"cb44-15\"><a href=\"#cb44-15\"><\/a>    <span class=\"kw\">public<\/span> <span class=\"dt\">static<\/span> <span class=\"dt\">void<\/span> <span class=\"fu\">main<\/span>(<span class=\"bu\">String<\/span>[] args) {<\/span>\n+<span id=\"cb44-16\"><a href=\"#cb44-16\"><\/a>        <span class=\"kw\">if<\/span> (args.<span class=\"fu\">length<\/span> == <span class=\"dv\">0<\/span>) {<\/span>\n+<span id=\"cb44-17\"><a href=\"#cb44-17\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">err<\/span>.<span class=\"fu\">println<\/span>(<span class=\"st\">&quot;java ASTPrinter &lt;C source or header&gt;&quot;<\/span>);<\/span>\n+<span id=\"cb44-18\"><a href=\"#cb44-18\"><\/a>            <span class=\"bu\">System<\/span>.<span class=\"fu\">exit<\/span>(<span class=\"dv\">1<\/span>);<\/span>\n+<span id=\"cb44-19\"><a href=\"#cb44-19\"><\/a>        }<\/span>\n+<span id=\"cb44-20\"><a href=\"#cb44-20\"><\/a><\/span>\n+<span id=\"cb44-21\"><a href=\"#cb44-21\"><\/a>        <span class=\"kw\">try<\/span> (var scope = ResourceScope.<span class=\"fu\">newConfinedScope<\/span>()) {<\/span>\n+<span id=\"cb44-22\"><a href=\"#cb44-22\"><\/a>            <span class=\"co\">\/\/ parse the C header\/source passed from the command line<\/span><\/span>\n+<span id=\"cb44-23\"><a href=\"#cb44-23\"><\/a>            var index = <span class=\"fu\">clang_createIndex<\/span>(<span class=\"dv\">0<\/span>, <span class=\"dv\">0<\/span>);<\/span>\n+<span id=\"cb44-24\"><a href=\"#cb44-24\"><\/a>            var tu = <span class=\"fu\">clang_parseTranslationUnit<\/span>(index, <span class=\"fu\">toCString<\/span>(args[<span class=\"dv\">0<\/span>], scope),<\/span>\n+<span id=\"cb44-25\"><a href=\"#cb44-25\"><\/a>                    NULL, <span class=\"dv\">0<\/span>, NULL, <span class=\"dv\">0<\/span>, <span class=\"fu\">CXTranslationUnit_None<\/span>());<\/span>\n+<span id=\"cb44-26\"><a href=\"#cb44-26\"><\/a>            <span class=\"co\">\/\/ array trick to update within lambda<\/span><\/span>\n+<span id=\"cb44-27\"><a href=\"#cb44-27\"><\/a>            var level = <span class=\"kw\">new<\/span> <span class=\"dt\">int<\/span>[<span class=\"dv\">1<\/span>];<\/span>\n+<span id=\"cb44-28\"><a href=\"#cb44-28\"><\/a>            var visitor = <span class=\"kw\">new<\/span> MemoryAddress[<span class=\"dv\">1<\/span>];<\/span>\n+<span id=\"cb44-29\"><a href=\"#cb44-29\"><\/a><\/span>\n+<span id=\"cb44-30\"><a href=\"#cb44-30\"><\/a>            <span class=\"co\">\/\/ clang Cursor visitor callback<\/span><\/span>\n+<span id=\"cb44-31\"><a href=\"#cb44-31\"><\/a>            visitor[<span class=\"dv\">0<\/span>] = CXCursorVisitor.<span class=\"fu\">allocate<\/span>((cursor, parent, data) -&gt; {<\/span>\n+<span id=\"cb44-32\"><a href=\"#cb44-32\"><\/a>                var kind = <span class=\"fu\">clang_getCursorKind<\/span>(cursor);<\/span>\n+<span id=\"cb44-33\"><a href=\"#cb44-33\"><\/a>                var name = <span class=\"fu\">asJavaString<\/span>(<span class=\"fu\">clang_getCursorSpelling<\/span>(scope, cursor));<\/span>\n+<span id=\"cb44-34\"><a href=\"#cb44-34\"><\/a>                var kindName = <span class=\"fu\">asJavaString<\/span>(<span class=\"fu\">clang_getCursorKindSpelling<\/span>(scope, kind));<\/span>\n+<span id=\"cb44-35\"><a href=\"#cb44-35\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot;<\/span><span class=\"sc\">%s<\/span><span class=\"st\"> <\/span><span class=\"sc\">%s<\/span><span class=\"st\"> <\/span><span class=\"sc\">%s<\/span><span class=\"st\">&quot;<\/span>, <span class=\"st\">&quot; &quot;<\/span>.<span class=\"fu\">repeat<\/span>(level[<span class=\"dv\">0<\/span>]), kindName, name);<\/span>\n+<span id=\"cb44-36\"><a href=\"#cb44-36\"><\/a>                var type = <span class=\"fu\">clang_getCursorType<\/span>(scope, cursor);<\/span>\n+<span id=\"cb44-37\"><a href=\"#cb44-37\"><\/a>                <span class=\"kw\">if<\/span> (CXType.<span class=\"fu\">kind<\/span>$<span class=\"fu\">get<\/span>(type) != <span class=\"fu\">CXType_Invalid<\/span>()) {<\/span>\n+<span id=\"cb44-38\"><a href=\"#cb44-38\"><\/a>                    var typeName = <span class=\"fu\">asJavaString<\/span>(<span class=\"fu\">clang_getTypeSpelling<\/span>(scope, type));<\/span>\n+<span id=\"cb44-39\"><a href=\"#cb44-39\"><\/a>                    <span class=\"bu\">System<\/span>.<span class=\"fu\">out.printf<\/span>(<span class=\"st\">&quot; &lt;<\/span><span class=\"sc\">%s<\/span><span class=\"st\">&gt;&quot;<\/span>, typeName);<\/span>\n+<span id=\"cb44-40\"><a href=\"#cb44-40\"><\/a>                }<\/span>\n+<span id=\"cb44-41\"><a href=\"#cb44-41\"><\/a>                <span class=\"bu\">System<\/span>.<span class=\"fu\">out<\/span>.<span class=\"fu\">println<\/span>();<\/span>\n+<span id=\"cb44-42\"><a href=\"#cb44-42\"><\/a><\/span>\n+<span id=\"cb44-43\"><a href=\"#cb44-43\"><\/a>                <span class=\"co\">\/\/ visit children<\/span><\/span>\n+<span id=\"cb44-44\"><a href=\"#cb44-44\"><\/a>                level[<span class=\"dv\">0<\/span>]++;<\/span>\n+<span id=\"cb44-45\"><a href=\"#cb44-45\"><\/a>                <span class=\"fu\">clang_visitChildren<\/span>(cursor, visitor[<span class=\"dv\">0<\/span>], NULL);<\/span>\n+<span id=\"cb44-46\"><a href=\"#cb44-46\"><\/a>                level[<span class=\"dv\">0<\/span>]--;<\/span>\n+<span id=\"cb44-47\"><a href=\"#cb44-47\"><\/a><\/span>\n+<span id=\"cb44-48\"><a href=\"#cb44-48\"><\/a>                <span class=\"kw\">return<\/span> <span class=\"fu\">CXChildVisit_Continue<\/span>();<\/span>\n+<span id=\"cb44-49\"><a href=\"#cb44-49\"><\/a>            });<\/span>\n+<span id=\"cb44-50\"><a href=\"#cb44-50\"><\/a><\/span>\n+<span id=\"cb44-51\"><a href=\"#cb44-51\"><\/a>            <span class=\"co\">\/\/ get the AST root and visit it<\/span><\/span>\n+<span id=\"cb44-52\"><a href=\"#cb44-52\"><\/a>            var root = <span class=\"fu\">clang_getTranslationUnitCursor<\/span>(scope, tu);<\/span>\n+<span id=\"cb44-53\"><a href=\"#cb44-53\"><\/a>            <span class=\"fu\">clang_visitChildren<\/span>(root, visitor[<span class=\"dv\">0<\/span>], NULL);<\/span>\n+<span id=\"cb44-54\"><a href=\"#cb44-54\"><\/a><\/span>\n+<span id=\"cb44-55\"><a href=\"#cb44-55\"><\/a>            <span class=\"fu\">clang_disposeTranslationUnit<\/span>(tu);<\/span>\n+<span id=\"cb44-56\"><a href=\"#cb44-56\"><\/a>            <span class=\"fu\">clang_disposeIndex<\/span>(index);<\/span>\n+<span id=\"cb44-57\"><a href=\"#cb44-57\"><\/a>        }<\/span>\n+<span id=\"cb44-58\"><a href=\"#cb44-58\"><\/a>    }<\/span>\n+<span id=\"cb44-59\"><a href=\"#cb44-59\"><\/a>}<\/span><\/code><\/pre><\/div>\n+<h3 id=\"compiling-and-running-the-libclang-sample\">Compiling and running the libclang sample<\/h3>\n+<div class=\"sourceCode\" id=\"cb45\"><pre class=\"sourceCode sh\"><code class=\"sourceCode bash\"><span id=\"cb45-1\"><a href=\"#cb45-1\"><\/a><\/span>\n+<span id=\"cb45-2\"><a href=\"#cb45-2\"><\/a><span class=\"ex\">java<\/span> --enable-native-access=ALL-UNNAMED \\<\/span>\n+<span id=\"cb45-3\"><a href=\"#cb45-3\"><\/a>    -Djava.library.path=<span class=\"va\">${LIBCLANG_HOME}<\/span>\/lib \\<\/span>\n+<span id=\"cb45-4\"><a href=\"#cb45-4\"><\/a>    --add-modules jdk.incubator.foreign \\<\/span>\n+<span id=\"cb45-5\"><a href=\"#cb45-5\"><\/a>    ASTPrinter.java <span class=\"va\">$*<\/span><\/span><\/code><\/pre><\/div>\n+<\/body>\n+<\/html>\n","filename":"doc\/panama_jextract.html","additions":992,"deletions":0,"binary":false,"changes":992,"status":"added"},{"patch":"@@ -0,0 +1,1066 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+\n+# Using the `jextract` tool\n+\n+`jextract` is a simple - but convenient - tool which generates a Java API from one or more native C headers. The tool can be obtained by building the [foreign-jextract](https:\/\/github.com\/openjdk\/panama-foreign) branch of Panama foreign repository.\n+\n+Interacting with the `jextract` tool usually involves two steps:\n+\n+1. Use the `jextract` tool to generate a java interface for some C header files\n+2. Write a Java program which invokes the wrapper API points generated by `jextract`\n+\n+The `jextract` tool provides some basic options in order to control how the extraction process works; these are listed below:\n+\n+* `-C <String>` - specify arguments to be passed to the underlying Clang parser\n+* `-I <String>` - specify include files path\n+* `-l <String>` - specify a library (name or full absolute path) which should be linked when the generated API is loaded\n+* `-d <String>` - specify where to place generated files\n+* `-t <String>`  specify the target package for the generated classes\n+* --include-function <String> - name of function to include\n+* --include-macro <String>    - name of constant macro to include\n+* --include-struct <String>   - name of struct definition to include\n+* --include-typedef <String>  - name of type definition to include\n+* --include-union <String>    - name of union definition to include\n+* --include-var <String>      - name of global variable to include\n+* `--source` - generate java sources instead of classfiles\n+\n+The remainder of this documents shows some basic usage examples of the `jextract` tool.\n+\n+## Hello World\n+\n+### Hello World C Header (helloworld.h)\n+\n+```C\n+\n+#ifndef helloworld_h\n+#define helloworld_h\n+\n+extern void helloworld(void);\n+\n+#endif \/* helloworld_h *\/\n+\n+\n+```\n+\n+### Hello World C Source (helloworld.c)\n+\n+```C\n+\n+#include <stdio.h>\n+\n+#include \"helloworld.h\"\n+\n+void helloworld(void) {\n+    printf(\"Hello World!\\n\");\n+}\n+\n+```\n+\n+### Building Hello World\n+\n+```sh\n+\n+cc -shared -o libhelloworld.dylib helloworld.c\n+\n+```\n+\n+\n+### jextract a Jar file for helloworld.h\n+\n+```sh\n+\n+jextract -t org.hello -lhelloworld helloworld.h\n+\n+```\n+\n+### Java program that uses extracted helloworld interface\n+\n+```java\n+\n+import static org.hello.helloworld_h.*;\n+\n+public class HelloWorld {\n+    public static void main(String[] args) {\n+        helloworld();\n+    }\n+}\n+\n+```\n+\n+### Running the Java code that invokes helloworld\n+\n+```sh\n+\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign HelloWorld.java\n+\n+```\n+\n+## Embedding Python interpreter in your Java program (Mac OS)\n+\n+### jextract Python.h\n+\n+```sh\n+\n+jextract \\\n+  -l python2.7 \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/python2.7\/ \\\n+  -t org.python \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/python2.7\/Python.h\n+\n+```\n+\n+### Java program that uses extracted Python interface\n+\n+```java\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+\/\/ import jextracted python 'header' class\n+import static org.python.Python_h.*;\n+import org.python.*;\n+\n+public class PythonMain {\n+    public static void main(String[] args) {\n+        String script = \"print(sum([33, 55, 66])); print('Hello from Python!')\\n\";\n+\n+        Py_Initialize();\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var str = toCString(script, scope);\n+            PyRun_SimpleStringFlags(str, NULL);\n+            Py_Finalize();\n+        }\n+    }\n+}\n+\n+```\n+\n+### Running the Java code that calls Python interpreter\n+\n+```sh\n+\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/System\/Library\/Frameworks\/Python.framework\/Versions\/2.7\/lib \\\n+    PythonMain.java\n+\n+```\n+\n+## Using readline library from Java code (Mac OS)\n+\n+### jextract readline.h\n+\n+```sh\n+\n+jextract \\\n+  -l readline -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/readline\/readline.h\n+\n+```\n+\n+### Java code that uses readline\n+\n+```java\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import static org.unix.readline_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import org.unix.*;\n+\n+public class Readline {\n+    public static void main(String[] args) {\n+       try (var scope = ResourceScope.newConfinedScope()) {\n+            var url = toCString(\"name? \", scope);\n+\n+            \/\/ call \"readline\" API\n+            var p = readline(url);\n+\n+            \/\/ print char* as is\n+            System.out.println(p);\n+            \/\/ convert char* ptr from readline as Java String & print it\n+            System.out.println(\"Hello, \" + toJavaString(p));\n+\n+            freeMemory(p);\n+        }\n+    }\n+}\n+\n+```\n+\n+### Running the java code that uses readline\n+\n+```\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/local\/opt\/readline\/lib\/ Readline.java\n+\n+```\n+\n+## Using libcurl from Java (Mac OS)\n+\n+### jextract curl.h\n+\n+```sh\n+\n+jextract -t org.unix -lcurl \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/ \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/curl\/curl.h\n+\n+```\n+\n+### Java code that uses libcurl\n+\n+```java\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.jextract.curl_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import org.jextract.*;\n+\n+public class CurlMain {\n+   public static void main(String[] args) {\n+       var urlStr = args[0];\n+       curl_global_init(CURL_GLOBAL_DEFAULT());\n+       var curl = curl_easy_init();\n+       if(!curl.equals(NULL)) {\n+           try (var scope = ResourceScope.newConfinedScope()) {\n+               var url = toCString(urlStr, scope);\n+               curl_easy_setopt(curl, CURLOPT_URL(), url.address());\n+               int res = curl_easy_perform(curl);\n+               if (res != CURLE_OK()) {\n+                   String error = toJavaString(curl_easy_strerror(res));\n+                   System.out.println(\"Curl error: \" + error);\n+                   curl_easy_cleanup(curl);\n+               }\n+           }\n+       }\n+       curl_global_cleanup();\n+   }\n+}\n+\n+```\n+\n+### Running the java code that uses libcurl\n+\n+```sh\n+\n+# run this shell script by passing a URL as first argument\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/lib CurlMain.java $*\n+\n+```\n+\n+## Using BLAS library\n+\n+BLAS is a popular library that allows fast matrix and vector computation: [http:\/\/www.netlib.org\/blas\/](http:\/\/www.netlib.org\/blas\/).\n+\n+### Installing OpenBLAS (Mac OS)\n+\n+On Mac, blas is available as part of the OpenBLAS library: [https:\/\/github.com\/xianyi\/OpenBLAS\/wiki](https:\/\/github.com\/xianyi\/OpenBLAS\/wiki)\n+\n+OpenBLAS is an optimized BLAS library based on GotoBLAS2 1.13 BSD version.\n+\n+You can install openblas using HomeBrew\n+\n+```sh\n+\n+brew install openblas\n+\n+```\n+\n+It installs include and lib directories under \/usr\/local\/opt\/openblas\n+\n+### jextracting cblas.h (MacOS)\n+\n+The following command can be used to extract cblas.h on MacOs\n+\n+```sh\n+\n+jextract -C \"-D FORCE_OPENBLAS_COMPLEX_STRUCT\" \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h\n+\n+```\n+\n+### Java sample code that uses cblas library\n+\n+```java\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import blas.*;\n+import static blas.cblas_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class TestBlas {\n+    public static void main(String[] args) {\n+        int Layout;\n+        int transa;\n+\n+        double alpha, beta;\n+        int m, n, lda, incx, incy, i;\n+\n+        Layout = CblasColMajor();\n+        transa = CblasNoTrans();\n+\n+        m = 4; \/* Size of Column ( the number of rows ) *\/\n+        n = 4; \/* Size of Row ( the number of columns ) *\/\n+        lda = 4; \/* Leading dimension of 5 * 4 matrix is 5 *\/\n+        incx = 1;\n+        incy = 1;\n+        alpha = 1;\n+        beta = 0;\n+\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            var a = allocator.allocateArray(C_DOUBLE, new double[] {\n+                1.0, 2.0, 3.0, 4.0,\n+                1.0, 1.0, 1.0, 1.0,\n+                3.0, 4.0, 5.0, 6.0,\n+                5.0, 6.0, 7.0, 8.0\n+            });\n+            var x = allocator.allocateArray(C_DOUBLE, new double[] {\n+                1.0, 2.0, 1.0, 1.0\n+            });\n+            var y = allocator.allocateArray(C_DOUBLE, n);\n+\n+            cblas_dgemv(Layout, transa, m, n, alpha, a, lda, x, incx, beta, y, incy);\n+            \/* Print y *\/\n+            for (i = 0; i < n; i++) {\n+                System.out.print(String.format(\" y%d = %f\\n\", i, MemoryAccess.getDoubleAtIndex(y, i)));\n+            }\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the above BLAS sample\n+\n+```sh\n+\n+jextract \\\n+  -C \"-D FORCE_OPENBLAS_COMPLEX_STRUCT\" \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  -l openblas -t blas \/usr\/local\/opt\/openblas\/include\/cblas.h\n+\n+```\n+\n+## Using LAPACK library (Mac OS)\n+\n+On Mac OS, lapack is installed under \/usr\/local\/opt\/lapack directory.\n+\n+### jextracting lapacke.h\n+\n+```sh\n+\n+jextract \\\n+   -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   -l lapacke -t lapack \\\n+   \/usr\/local\/opt\/lapack\/include\/lapacke.h\n+\n+```\n+\n+### Java sample code that uses LAPACK library\n+\n+```java\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import lapack.*;\n+import static lapack.lapacke_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class TestLapack {\n+    public static void main(String[] args) {\n+\n+        \/* Locals *\/\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            var A = allocator.allocateArray(C_DOUBLE, new double[]{\n+                    1, 2, 3, 4, 5, 1, 3, 5, 2, 4, 1, 4, 2, 5, 3\n+            });\n+            var b = allocator.allocateArray(C_DOUBLE, new double[]{\n+                    -10, 12, 14, 16, 18, -3, 14, 12, 16, 16\n+            });\n+            int info, m, n, lda, ldb, nrhs;\n+\n+            \/* Initialization *\/\n+            m = 5;\n+            n = 3;\n+            nrhs = 2;\n+            lda = 5;\n+            ldb = 5;\n+\n+            \/* Print Entry Matrix *\/\n+            print_matrix_colmajor(\"Entry Matrix A\", m, n, A, lda );\n+            \/* Print Right Rand Side *\/\n+            print_matrix_colmajor(\"Right Hand Side b\", n, nrhs, b, ldb );\n+            System.out.println();\n+\n+            \/* Executable statements *\/\n+            \/\/            printf( \"LAPACKE_dgels (col-major, high-level) Example Program Results\\n\" );\n+            \/* Solve least squares problem*\/\n+            info = LAPACKE_dgels(LAPACK_COL_MAJOR(), (byte)'N', m, n, nrhs, A, lda, b, ldb);\n+\n+            \/* Print Solution *\/\n+            print_matrix_colmajor(\"Solution\", n, nrhs, b, ldb );\n+            System.out.println();\n+            System.exit(info);\n+        }\n+    }\n+\n+    static void print_matrix_colmajor(String msg, int m, int n, MemorySegment mat, int ldm) {\n+        int i, j;\n+        System.out.printf(\"\\n %s\\n\", msg);\n+\n+        for( i = 0; i < m; i++ ) {\n+            for( j = 0; j < n; j++ ) System.out.printf(\" %6.2f\", MemoryAccess.getDoubleAtIndex(mat, i+j*ldm));\n+            System.out.printf( \"\\n\" );\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the above LAPACK sample\n+\n+```sh\n+\n+java --enable-native-access=ALL-UNNAMED \\\n+    --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/local\/opt\/lapack\/lib \\\n+    TestLapack.java\n+\n+```\n+## Using libproc library to list processes from Java (Mac OS)\n+\n+### jextract libproc.h\n+\n+```sh\n+\n+jextract \\\n+  -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/libproc.h\n+\n+```\n+\n+### Java program that uses libproc to list processes\n+\n+```java\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.unix.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.unix.libproc_h.*;\n+\n+public class LibprocMain {\n+    private static final int NAME_BUF_MAX = 256;\n+\n+    public static void main(String[] args) {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            \/\/ get the number of processes\n+            int numPids = proc_listallpids(NULL, 0);\n+            \/\/ allocate an array\n+            var pids = allocator.allocateArray(CLinker.C_INT, numPids);\n+            \/\/ list all the pids into the native array\n+            proc_listallpids(pids, numPids);\n+            \/\/ convert native array to java array\n+            int[] jpids = pids.toIntArray();\n+            \/\/ buffer for process name\n+            var nameBuf = allocator.allocateArray(CLinker.C_CHAR, NAME_BUF_MAX);\n+            for (int i = 0; i < jpids.length; i++) {\n+                int pid = jpids[i];\n+                \/\/ get the process name\n+                proc_name(pid, nameBuf, NAME_BUF_MAX);\n+                String procName = CLinker.toJavaString(nameBuf);\n+                \/\/ print pid and process name\n+                System.out.printf(\"%d %s\\n\", pid, procName);\n+            }\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the libproc sample\n+\n+```sh\n+\n+java --enable-native-access=ALL-UNNAMED \\\n+    --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=\/usr\/lib LibprocMain.java\n+\n+```\n+\n+## Using libgit2 from Java (Mac OS)\n+\n+### Getting and building libgit2\n+\n+* Download libgit2 v1.0.0 source from https:\/\/github.com\/libgit2\/libgit2\/releases\n+* Use cmake to build from libgit2\n+* Let ${LIBGIT2_HOME} be the directory where you expanded libgit2 sources.\n+* Let ${LIBGIT2_HOME}\/build be the build directory where libgit2.dylib is built.\n+\n+### jextract git2.h\n+\n+```sh\n+\n+jextract \\\n+  -t com.github -lgit2 \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBGIT2_HOME}\/include\/ \\\n+  -I ${LIBGIT2_HOME}\/include\/git2 \\\n+  ${LIBGIT2_HOME}\/include\/git2.h\n+\n+```\n+\n+### Java program that uses libgit2 to clone github repo\n+\n+```java\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import static com.github.git2_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import com.github.*;\n+\n+public class GitClone {\n+    public static void main(String[] args) {\n+          if (args.length != 2) {\n+              System.err.println(\"java GitClone <url> <path>\");\n+              System.exit(1);\n+          }\n+          git_libgit2_init();\n+          try (var scope = ResourceScope.newConfinedScope()) {\n+              var allocator = SegmentAllocator.ofScope(scope);\n+              var repo = allocator.allocate(C_POINTER);\n+              var url = toCString(args[0], scope);\n+              var path = toCString(args[1], scope);\n+              System.out.println(git_clone(repo, url, path, NULL));\n+          }\n+          git_libgit2_shutdown();\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the libgit2 sample\n+\n+```sh\n+\n+# file run.sh\n+\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=${LIBGIT2_HOME}\/build\/ \\\n+    GitClone.java $*\n+```\n+\n+### Cloning a github repo using the above run.sh command\n+\n+```sh\n+\n+sh run.sh https:\/\/github.com\/libgit2\/libgit2.git libgit2\n+\n+```\n+\n+## Using sqlite3 library from Java (Mac OS)\n+\n+\n+### jextract sqlite3.h\n+\n+```sh\n+\n+jextract \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/sqlite3.h \\\n+  -t org.sqlite -lsqlite3\n+\n+```\n+### Java program that uses sqlite3\n+\n+```java\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.sqlite.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.sqlite.sqlite3_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+public class SqliteMain {\n+   public static void main(String[] args) throws Exception {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            \/\/ char** errMsgPtrPtr;\n+            var errMsgPtrPtr = allocator.allocate(C_POINTER);\n+\n+            \/\/ sqlite3** dbPtrPtr;\n+            var dbPtrPtr = allocator.allocate(C_POINTER);\n+\n+            int rc = sqlite3_open(toCString(\"employee.db\",scope), dbPtrPtr);\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_open failed: \" + rc);\n+                return;\n+            } else {\n+                System.out.println(\"employee db opened\");\n+            }\n+\n+            \/\/ sqlite3* dbPtr;\n+            var dbPtr = MemoryAccess.getAddress(dbPtrPtr);\n+\n+            \/\/ create a new table\n+            var sql = toCString(\n+                \"CREATE TABLE EMPLOYEE (\"  +\n+                \"  ID INT PRIMARY KEY NOT NULL,\" +\n+                \"  NAME TEXT NOT NULL,\"    +\n+                \"  SALARY REAL NOT NULL )\", scope);\n+\n+            rc = sqlite3_exec(dbPtr, sql, NULL, NULL, errMsgPtrPtr);\n+\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_exec failed: \" + rc);\n+                System.err.println(\"SQL error: \" + toJavaString(MemoryAccess.getAddress(errMsgPtrPtr)));\n+                sqlite3_free(MemoryAccess.getAddress(errMsgPtrPtr));\n+            } else {\n+                System.out.println(\"employee table created\");\n+            }\n+\n+            \/\/ insert two rows\n+            sql = toCString(\n+                \"INSERT INTO EMPLOYEE (ID,NAME,SALARY) \" +\n+                    \"VALUES (134, 'Xyz', 200000.0); \" +\n+                \"INSERT INTO EMPLOYEE (ID,NAME,SALARY) \" +\n+                    \"VALUES (333, 'Abc', 100000.0);\", scope\n+            );\n+            rc = sqlite3_exec(dbPtr, sql, NULL, NULL, errMsgPtrPtr);\n+\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_exec failed: \" + rc);\n+                System.err.println(\"SQL error: \" + toJavaString(MemoryAccess.getAddress(errMsgPtrPtr)));\n+                sqlite3_free(MemoryAccess.getAddress(errMsgPtrPtr));\n+            } else {\n+                System.out.println(\"rows inserted\");\n+            }\n+\n+            int[] rowNum = new int[1];\n+            \/\/ callback to print rows from SELECT query\n+            var callback = sqlite3_exec$callback.allocate((a, argc, argv, columnNames) -> {\n+                System.out.println(\"Row num: \" + rowNum[0]++);\n+                System.out.println(\"numColumns = \" + argc);\n+                var argv_seg = argv.asSegment(C_POINTER.byteSize() * argc, scope);\n+                var columnNames_seg = columnNames.asSegment(C_POINTER.byteSize() * argc, scope);\n+                for (int i = 0; i < argc; i++) {\n+                     String name = toJavaString(MemoryAccess.getAddressAtIndex(columnNames_seg, i));\n+                     String value = toJavaString(MemoryAccess.getAddressAtIndex(argv_seg, i));\n+                     System.out.printf(\"%s = %s\\n\", name, value);\n+                }\n+                return 0;\n+            }, scope);\n+\n+            \/\/ select query\n+            sql = toCString(\"SELECT * FROM EMPLOYEE\", scope);\n+            rc = sqlite3_exec(dbPtr, sql, callback, NULL, errMsgPtrPtr);\n+\n+            if (rc != 0) {\n+                System.err.println(\"sqlite3_exec failed: \" + rc);\n+                System.err.println(\"SQL error: \" + toJavaString(MemoryAccess.getAddress(errMsgPtrPtr)));\n+                sqlite3_free(MemoryAccess.getAddress(errMsgPtrPtr));\n+            } else {\n+                System.out.println(\"done\");\n+            }\n+\n+            sqlite3_close(dbPtr);\n+        }\n+    }\n+}\n+\n+\n+```\n+\n+### Compiling and running the sqlite3 sample\n+\n+```sh\n+\n+java --enable-native-access=ALL-UNNAMED \\\n+   --add-modules jdk.incubator.foreign \\\n+   -Djava.library.path=\/usr\/lib SqliteMain.java\n+\n+```\n+\n+## Using OpenGL library from Java (Mac OS)\n+\n+### jextract glut.h\n+\n+```sh\n+\n+jextract -t opengl -lGL -l\/System\/Library\/Frameworks\/GLUT.framework\/Versions\/Current\/GLUT \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -C-F\/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks \\\n+  \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/System\/Library\/Frameworks\/GLUT.framework\/Headers\/glut.h\n+\n+```\n+### Java program that uses OpenGL\n+\n+```java\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import opengl.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import static opengl.glut_h.*;\n+\n+public class Teapot {\n+    private float rot = 0;\n+\n+    Teapot(SegmentAllocator allocator) {\n+        \/\/ Reset Background\n+        glClearColor(0f, 0f, 0f, 0f);\n+        \/\/ Setup Lighting\n+        glShadeModel(GL_SMOOTH());\n+        var pos = allocator.allocateArray(C_FLOAT, new float[] {0.0f, 15.0f, -15.0f, 0});\n+        glLightfv(GL_LIGHT0(), GL_POSITION(), pos);\n+        var spec = allocator.allocateArray(C_FLOAT, new float[] {1, 1, 1, 0});\n+        glLightfv(GL_LIGHT0(), GL_AMBIENT(), spec);\n+        glLightfv(GL_LIGHT0(), GL_DIFFUSE(), spec);\n+        glLightfv(GL_LIGHT0(), GL_SPECULAR(), spec);\n+        var shini = allocator.allocate(C_FLOAT, 113);\n+        glMaterialfv(GL_FRONT(), GL_SHININESS(), shini);\n+        glEnable(GL_LIGHTING());\n+        glEnable(GL_LIGHT0());\n+        glEnable(GL_DEPTH_TEST());\n+    }\n+\n+    void display() {\n+        glClear(GL_COLOR_BUFFER_BIT() | GL_DEPTH_BUFFER_BIT());\n+        glPushMatrix();\n+        glRotatef(-20f, 1f, 1f, 0f);\n+        glRotatef(rot, 0f, 1f, 0f);\n+        glutSolidTeapot(0.5d);\n+        glPopMatrix();\n+        glutSwapBuffers();\n+    }\n+\n+    void onIdle() {\n+        rot += 0.1;\n+        glutPostRedisplay();\n+    }\n+\n+    public static void main(String[] args) {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            var argc = allocator.allocate(C_INT, 0);\n+            glutInit(argc, argc);\n+            glutInitDisplayMode(GLUT_DOUBLE() | GLUT_RGB() | GLUT_DEPTH());\n+            glutInitWindowSize(500, 500);\n+            glutCreateWindow(CLinker.toCString(\"Hello Panama!\", scope));\n+            var teapot = new Teapot(allocator);\n+            var displayStub = glutDisplayFunc$func.allocate(teapot::display, scope);\n+            var idleStub = glutIdleFunc$func.allocate(teapot::onIdle, scope);\n+            glutDisplayFunc(displayStub);\n+            glutIdleFunc(idleStub);\n+            glutMainLoop();\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the OpenGL sample\n+\n+```sh\n+\n+java -XstartOnFirstThread --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+    -Djava.library.path=.:\/System\/Library\/Frameworks\/OpenGL.framework\/Versions\/Current\/Libraries\/ Teapot.java $*\n+\n+```\n+\n+## Using tensorflow (Mac OS)\n+\n+### getting libtensorflow\n+\n+* Download tensorflow library from\n+\n+    https:\/\/www.tensorflow.org\/install\/lang_c\n+\n+* extract the downloaded tar in a directory called LIBTENSORFLOW_HOME\n+\n+###  jextract c_api.h\n+\n+```sh\n+\n+jextract --source \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -t org.tensorflow \\\n+  -I ${LIBTENSORFLOW_HOME}\/include \\\n+  -l ${LIBTENSORFLOW_HOME}\/lib\/libtensorflow.dylib \\\n+  ${LIBTENSORFLOW_HOME}\/include\/tensorflow\/c\/c_api.h\n+\n+javac --add-modules jdk.incubator.foreign org\/tensorflow\/*.java\n+\n+```\n+\n+### Python program that creates and saves model\n+\n+The following Python program should be run to create and save model\n+which will read and printed by a Java program.\n+\n+Note: you need to install tensorflow package to run this python script.\n+\n+```python\n+\n+import tensorflow as tf\n+from tensorflow.keras import models, layers\n+from tensorflow.keras.datasets import mnist\n+\n+model = tf.keras.models.Sequential([\n+  tf.keras.layers.Flatten(input_shape=(28, 28)),\n+  tf.keras.layers.Dense(128,activation='relu'),\n+  tf.keras.layers.Dense(10, activation='softmax')\n+])\n+\n+model.compile(\n+    loss='sparse_categorical_crossentropy',\n+    optimizer=tf.keras.optimizers.Adam(0.001),\n+    metrics=['accuracy'],\n+)\n+\n+print(model.summary())\n+\n+(train_images, train_labels), (test_images, test_labels) = mnist.load_data()\n+\n+train_images = train_images\/255.0\n+test_images = test_images\/255.0\n+\n+model.fit(train_images, train_labels,\n+    epochs=4, batch_size=128, verbose=1)\n+\n+test_loss, test_accuracy = model.evaluate(test_images, test_labels)\n+\n+print(test_loss, test_accuracy)\n+\n+model.save(\"saved_mnist_model\")\n+\n+```\n+\n+### Java program that uses Tensorflow C API\n+\n+```java\n+\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.MemoryAccess.*;\n+import static jdk.incubator.foreign.MemoryAddress.*;\n+import static org.tensorflow.c_api_h.*;\n+import org.tensorflow.*;\n+\n+\/\/ simple program that loads saved model and prints basic info on operations in it\n+\n+public class TensorflowLoadSavedModel {\n+    public static void main(String... args) throws Exception {\n+        System.out.println(\"TensorFlow C library version: \" + toJavaString(TF_Version()));\n+\n+        if (args.length == 0) {\n+            System.err.println(\"java TensorflowLoadSavedModel <saved model dir>\");\n+            System.exit(1);\n+        }\n+\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            var graph = TF_NewGraph();\n+            var status = TF_NewStatus();\n+            var sessionOpts = TF_NewSessionOptions();\n+\n+            var savedModelDir = toCString(args[0], scope);\n+            var tags = allocator.allocate(C_POINTER, toCString(\"serve\", scope));\n+            var session = TF_LoadSessionFromSavedModel(sessionOpts, NULL, savedModelDir, tags, 1, graph, NULL, status);\n+\n+            if (TF_GetCode(status) != TF_OK()) {\n+                System.err.printf(\"cannot load session from saved model: %s\\n\",\n+                    toJavaString(TF_Message(status)));\n+            } else {\n+                System.err.println(\"load session from saved model works!\");\n+            }\n+\n+            \/\/ print operations\n+            var size = allocator.allocate(C_LONG_LONG);\n+            var operation = NULL;\n+            while (!(operation = TF_GraphNextOperation(graph, size)).equals(NULL)) {\n+                System.out.printf(\"%s : %s\\n\",\n+                    toJavaString(TF_OperationName(operation)),\n+                    toJavaString(TF_OperationOpType(operation)));\n+            }\n+\n+            TF_DeleteGraph(graph);\n+            TF_DeleteSession(session, status);\n+            TF_DeleteSessionOptions(sessionOpts);\n+            TF_DeleteStatus(status);\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the Java Tensorflow sample\n+\n+```sh\n+\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign \\\n+   TensorflowLoadSavedModel.java saved_mnist_model\n+\n+```\n+\n+## Using time.h (Mac OS)\n+\n+### jextract time.h\n+\n+\n+```sh\n+\n+jextract -t org.unix \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include \\\n+   \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/time.h\n+\n+```\n+\n+### Java program that uses POSIX time library\n+\n+```java\n+\n+import static org.unix.time_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import jdk.incubator.foreign.*;\n+import org.unix.*;\n+\n+public class PanamaTime {\n+    public static void main(String[] args) {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            var now = allocator.allocate(C_LONG, System.currentTimeMillis() \/ 1000);\n+            MemorySegment time = tm.allocate(scope);\n+            localtime_r(now, time);\n+            System.err.printf(\"Time = %d:%d\\n\", tm.tm_hour$get(time), tm.tm_min$get(time));\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the time sample\n+\n+\n+```sh\n+\n+java --enable-native-access=ALL-UNNAMED --add-modules jdk.incubator.foreign PanamaTime.java\n+\n+```\n+\n+## Using libclang library (Mac OS)\n+\n+### jextract Index.h\n+\n+```sh\n+\n+# LIBCLANG_HOME is the directory where you've installed llvm 9.x or above\n+\n+jextract --source -t org.llvm.clang -lclang \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/clang-c \\\n+  ${LIBCLANG_HOME}\/include\/clang-c\/Index.h\n+javac --add-modules jdk.incubator.foreign org\/llvm\/clang\/*.java\n+\n+```\n+\n+### Java program that uses libclang to print AST of a given C program\n+\n+```java\n+\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.llvm.clang.Index_h.*;\n+import org.llvm.clang.*;\n+\n+public class ASTPrinter {\n+    private static String asJavaString(MemorySegment clangStr) {\n+        String str = toJavaString(clang_getCString(clangStr));\n+        clang_disposeString(clangStr);\n+        return str;\n+    }\n+\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            System.err.println(\"java ASTPrinter <C source or header>\");\n+            System.exit(1);\n+        }\n+\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            \/\/ parse the C header\/source passed from the command line\n+            var index = clang_createIndex(0, 0);\n+            var tu = clang_parseTranslationUnit(index, toCString(args[0], scope),\n+                    NULL, 0, NULL, 0, CXTranslationUnit_None());\n+            \/\/ array trick to update within lambda\n+            var level = new int[1];\n+            var visitor = new MemoryAddress[1];\n+\n+            \/\/ clang Cursor visitor callback\n+            visitor[0] = CXCursorVisitor.allocate((cursor, parent, data) -> {\n+                var kind = clang_getCursorKind(cursor);\n+                var name = asJavaString(clang_getCursorSpelling(scope, cursor));\n+                var kindName = asJavaString(clang_getCursorKindSpelling(scope, kind));\n+                System.out.printf(\"%s %s %s\", \" \".repeat(level[0]), kindName, name);\n+                var type = clang_getCursorType(scope, cursor);\n+                if (CXType.kind$get(type) != CXType_Invalid()) {\n+                    var typeName = asJavaString(clang_getTypeSpelling(scope, type));\n+                    System.out.printf(\" <%s>\", typeName);\n+                }\n+                System.out.println();\n+\n+                \/\/ visit children\n+                level[0]++;\n+                clang_visitChildren(cursor, visitor[0], NULL);\n+                level[0]--;\n+\n+                return CXChildVisit_Continue();\n+            });\n+\n+            \/\/ get the AST root and visit it\n+            var root = clang_getTranslationUnitCursor(scope, tu);\n+            clang_visitChildren(root, visitor[0], NULL);\n+\n+            clang_disposeTranslationUnit(tu);\n+            clang_disposeIndex(index);\n+        }\n+    }\n+}\n+\n+```\n+\n+### Compiling and running the libclang sample\n+\n+```sh\n+\n+java --enable-native-access=ALL-UNNAMED \\\n+    -Djava.library.path=${LIBCLANG_HOME}\/lib \\\n+    --add-modules jdk.incubator.foreign \\\n+    ASTPrinter.java $*\n+\n+```\n","filename":"doc\/panama_jextract.md","additions":1066,"deletions":0,"binary":false,"changes":1066,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+## State of foreign memory support\n+\n+**May 2021**\n+\n+**Maurizio Cimadamore**\n+\n+A crucial part of any native interop story lies in the ability of accessing off-heap memory in an efficient fashion. Panama achieves this goal through the so called Foreign Memory Access API. This API has been made available as an incubating API in Java [14](https:\/\/openjdk.java.net\/jeps\/370) , [15](https:\/\/openjdk.java.net\/jeps\/383) and [16](https:\/\/openjdk.java.net\/jeps\/393) and is, to date, the most mature part of the Panama interop story.\n+\n+### Segments\n+\n+Memory segments are abstractions which can be used to model contiguous memory regions, located either on- or off- the Java heap. Segments can be allocated from native memory (e.g. like a `malloc`), or can be wrapped around existing memory sources (e.g. a Java array or a `ByteBuffer`). Memory segments provide *strong* spatial, temporal and thread-confinement guarantees which make memory dereference operation *safe* (more on that later), although in most simple cases some of the properties of memory segments can safely be ignored.\n+\n+For instance, the following snippet allocates 100 bytes off-heap:\n+\n+```java\n+MemorySegment segment = MemorySegment.allocateNative(100, ResourceScope.newImplicitScope());\n+```\n+\n+The above code allocates a 100-bytes long memory segment. The lifecycle of a memory segment is controlled by an abstraction called `ResourceScope`. In this example, the segment memory will not be *freed* as long as the segment instance is deemed *reachable*, as specified by the `newImplicitScope()` parameter. In other words, the above factory creates a segment whose behavior closely matches that of a `ByteBuffer` allocated with the `allocateDirect` factory. Of course, the memory access API also supports deterministic memory release; we will cover that in a later section of this document.\n+\n+Memory segments support *slicing* — that is, given a segment, it is possible to create a new segment whose spatial bounds are stricter than that of the original segment:\n+\n+```java\n+MemorySegment segment = MemorySement.allocateNative(10, ResourceScope.newImplicitScope());\n+MemorySegment slice = segment.asSlice(4, 4);\n+```\n+\n+The above code creates a slice that starts at offset 4 and has a length of 4 bytes. Generally speaking, slices have the *same* temporal bounds as the parent segment (we will refine this concept later in this document). In this example, the memory associated with the parent segment will not be released as long as there is at least one *reachable* slice derived from that segment.\n+\n+The Foreign Memory Access API provides ready-made static accessors in the `MemoryAccess` class, which allows to dereference a segment in various ways. The following example reads pair of 32-bit values (as Java ints) and uses them to construct an array of points:\n+\n+```java\n+record Point(int x, int y);\n+MemorySegment segment = MemorySement.allocateNative(10 * 4 * 2, ResourceScope.newImplicitScope());\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = MemoryAccess.getIntAtIndex(segment, i * 2);\n+    int y = MemoryAccess.getIntAtIndex(segment, (i * 2) + 1);\n+    values[i] = new Point(x, y);\n+}\n+```\n+\n+The above snippet allocates a flat array of 80 bytes using `MemorySegment::allocateNative`. Then, inside the loop, elements in the array are accessed using the `MemoryAccess.getIntAtIndex` method, which accesses `int` elements in a segment at a certain *logical* index (in other words, the segment offset being accessed is obtained by multiplying the index by 4, which is the stride of a Java `int` array). Thus, all coordinates `x` and `y` are collected into instances of a `Point` record.\n+\n+Memory segments are pretty flexible when it comes to interacting with existing memory sources and APIs. For instance it is possible to create a `ByteBuffer` *view* out of an existing memory segment, as follows:\n+\n+```java\n+IntBuffer intBuffer = segment.asByteBuffer().asIntBuffer();\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = intBuffer.get(i * 2);\n+    int y = intBuffer.get((i * 2) + 1);\n+    values[i] = new Point(x, y);\n+}\n+```\n+\n+Creating buffer views out of existing segment is a crucial tool enabling interoperability with existing API (especially those dealing with I\/O) which might be expressed in terms of the ByteBuffer API.\n+\n+### Layouts and structured access\n+\n+Expressing byte offsets (as in the example above) can lead to code that is hard to read, and very fragile — as memory layout invariants are captured, implicitly, in the constants used to scale offsets. To address this issue, we add a *memory layout* API which allows clients to define memory layouts *programmatically*. For instance, the layout of the array used in the above example can be expressed using the following code <a href=\"#1\"><sup>1<\/sup><\/a>:\n+\n+```java\n+MemoryLayout points = MemoryLayout.sequenceLayout(10,\n+    MemoryLayout.structLayout(\n+        MemoryLayouts.JAVA_INT.withName(\"x\"),\n+        MemoryLayouts.JAVA_INT.withName(\"y\")\n+    )\n+);            \n+```\n+\n+That is, our layout is a repetition of 10 *struct* elements, each struct element containing two 32-bit values each. The advantage of defining a memory layout upfront, using an API, is that we can then query the layout  — for instance we can compute the offset of the `y` coordinate in the 4th element of the points array:\n+\n+```java\n+long y3 = points.byteOffset(PathElement.sequenceElement(3), PathElement.groupElement(\"y\")); \/\/ 28\n+```\n+\n+To specify which nested layout element should be used for the offset calculation we use a so called *layout path* - that is, a selection expression that navigates the layout, from the *root* layout, down to the leaf layout we wish to select; in this case we need to select the 4th layout element in the sequence, and then select the layout named `y` inside the selected group layout.\n+\n+One of the things that can be derived from a layout is a so called *memory access var handle*. A memory access var handle is a special kind of var handle which takes a memory segment access coordinate, together with a byte offset — the offset, relative to the segment's base address at which the dereference operation should occur. With memory access var handles we can rewrite our example above as follows:\n+\n+```java\n+MemorySegment segment = MemorySegment.allocateNative(points, ResourceScope.newImplicitScope());\n+VarHandle xHandle = points.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"x\"));\n+VarHandle yHandle = points.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"y\"));\n+Point[] values = new Point[10];\n+for (int i = 0 ; i < values.length ; i++) {\n+    int x = (int)xHandle.get(segment, (long)i);\n+    int y = (int)yHandle.get(segment, (long)i);\n+}\n+```\n+\n+In the above,  `xHandle` and `yHandle` are two var handle instances whose type is `int`  and which takes two access coordinates:\n+\n+1. a `MemorySegment` instance; the segment whose memory should be dereferenced\n+2. a *logical* index, which is used to select the element of the sequence we want to access (as the layout path used to construct these var handles contains one free dimension)\n+\n+Note that memory access var handles (as any other var handle) are *strongly* typed; and to get maximum efficiency, it is generally necessary to introduce casts to make sure that the access coordinates match the expected types — in this case we have to cast `i` into a `long`; similarly, since the signature polymorphic method `VarHandle::get` notionally returns `Object` a cast is necessary to force the right return type the var handle operation <a href=\"#2\"><sup>2<\/sup><\/a>.\n+\n+In other words, manual offset computation is no longer needed — offsets and strides can in fact be derived from the layout object; note how `yHandle` is able to compute the required offset of the `y` coordinate in the flat array without the need of any error-prone arithmetic computation.\n+\n+### Deterministic deallocation\n+\n+In addition to spatial bounds, memory segments also feature temporal bounds as well as thread-confinement. In the examples shown so far, we have always used the API in its simpler form, leaving the runtime to handle details such as whether it was safe or not to reclaim memory associated with a given memory segment. But there are cases where this behavior is not desirable: consider the case where a large memory segment is mapped from a file (this is possible using `MemorySegment::map`); in this case, an application would probably prefer to deterministically release (e.g. unmap) the memory associated with this segment, to ensure that memory doesn't remain available for longer than in needs to (and therefore potentially impacting the performance of the application).\n+\n+Memory segments support deterministic deallocation, through an abstraction called `ResourceScope`. A resource scope models the lifecycle associated with one or more resources (in this document, by resources we mean mostly memory segments); a resource scope has a state: it starts off in the *alive* state, which means that all the resources it manages can be safely accessed - and, at the user request, it can be *closed*. After a resource scope is closed, access to resources managed by that scope is no longer allowed. Resource scope support the `AutoCloseable` interface, which means that user can use resource scopes with the *try-with-resources* construct, as demonstrated in the following code:\n+\n+```java\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    MemorySegment mapped = MemorySegment.map(Path.of(\"someFile\"), 0, 100000, MapMode.READ_WRITE, scope);    \n+} \/\/ segment is unmapped here\n+```\n+\n+Here, we create a new *confined* resource scope, which is then used when creating a mapped segment; this means that the lifecycle of the `mapped` segment will be tied to that of the resource scope, and that accessing the segment (e.g. dereference) *after* `scope` has been closed will not be possible.\n+\n+As this example alludes to, resource scopes can come in many flavors: they can be *confined* (where access is restricted to the thread which created the scope), *shared* <a href=\"#3\"><sup>3<\/sup><\/a> (where access can occur in any thread) and can be optionally associated with a `Cleaner` object, which would take care of performing implicit deallocation, in case the resource scope becomes *unreachable* and the `close` method has not been called by the user.\n+\n+Some resource scopes do *not* support deterministic deallocation. Such scopes are called *implicit* scopes. Calling `close` on an implicit scope will fail; instead, resources associated with implicit scopes are *always* managed by a `Cleaner`. A new implicit scope can be obtained using the `ResourceScope::newImplicitScope` factory (which has been used in many examples throughout this document).\n+\n+Resource scopes are very handy when managing the lifecycle of multiple resources:\n+\n+```java\n+try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+    MemorySegment segment1 = MemorySegment.allocateNative(100, scope);\n+    MemorySegment segment2 = MemorySegment.allocateNative(100, scope);\n+    ...\n+    MemorySegment segmentN = MemorySegment.allocateNative(100, scope);\n+} \/\/ all segments are deallocated here\n+```\n+\n+Here we create another confined scope, and then, inside the *try-with-resources* we use the scope to create many segments; all such segments share the *same* resource scope - meaning that when such scope is closed, the memory associated with all these segments will be reclaimed at once.\n+\n+Dealing with shared access *and* deterministic deallocation at the same time is tricky, and poses new problems for the user code; consider the case where a method receives a segment and has to write two values in that segment (e.g. two point coordinates):\n+\n+```java\n+void writePoint(MemorySegment segment, int x, int y) {\n+    MemoryAccess.setIntAtIndex(segment, 0, x);\n+    MemoryAccess.setIntAtIndex(segment, 1, y);\n+}\n+```\n+\n+If the segment is associated with a confined scope, no problem arises: the thread that created the segment is the same thread that performs the dereference - as such, when `writePoint` is called, the segment's scope is either alive (and will remain so for the duration of the call), or already closed (in which case some exception will be thrown, and no value will be written).\n+\n+But, if the segment is associated with a shared scope, there is a new problem we are faced with: the segment might be closed (concurrently) in between the two accesses! This means that, the method ends up writing only one value instead of two; in other words, the behavior of the method is no longer atomic. Note that this cannot happen in the case where the scope is shared but associated with an *implicit scope* - as implicit scopes do not support explicit deallocation.\n+\n+To avoid this problem, clients can acquire a so called resource scope *handle*. A resource scope handle effectively prevents a scope from being closed, until said handle is released by the application. Let's illustrate how that works in practice:\n+\n+```java\n+void writePointSafe(MemorySegment segment, int x, int y) {\n+    var handle = segment.scope().acquire();\n+    try {\n+        MemoryAccess.setIntAtIndex(segment, 0, x);\n+        MemoryAccess.setIntAtIndex(segment, 1, y);\n+    } finally {\n+        segment.scope().release(handle);   \n+    }\n+}\n+```\n+\n+A resource scope handle acts as a more restricted version <a href=\"#4\"><sup>4<\/sup><\/a> of an *atomic reference count*; each time a scope is acquired, its *acquired count* goes up; conversely the count goes down each time an handle associated with that scope is released. A scope can only be closed if its acquired count is exactly zero - meaning that no other client is attempting to access that (shared) segment. In our example above, the semantics of resource scope handles guarantees that the method will be able to either acquire the handle successfully, and write both values, or fail to acquire the handle, and write no value.\n+\n+### Parallel processing\n+\n+The contents of a memory segment can be processed in *parallel* (e.g. using a framework such as Fork\/Join) — by obtaining a `Spliterator` instance out of a memory segment. For instance to sum all the 32 bit values of a memory segment in parallel, we can use the following code:\n+\n+```java\n+SequenceLayout seq = MemoryLayout.sequenceLayout(1_000_000, MemoryLayouts.JAVA_INT);\n+SequenceLayout bulk_element = MemoryLayout.sequenceLayout(100, MemoryLayouts.JAVA_INT);\n+\n+try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+    MemorySegment segment = MemorySegment.allocateNative(seq, scope);\n+    int sum = segment.elements(bulk_element).parallel()\n+                       .mapToInt(slice -> {\n+                           int res = 0;\n+                           for (int i = 0; i < 100 ; i++) {\n+                               res += MemoryAccess.getIntAtIndex(slice, i);\n+                           }\n+                           return res;\n+                       }).sum();\n+}\n+```\n+\n+The `MemorySegment::elements` method takes an element layout and returns a new stream. The stream is built on top of a spliterator instance (see `MemorySegment::spliterator`) which splits the segment into chunks which corresponds to the elements in the provided layout. Here, we want to sum elements in an array which contains a million of elements; now, doing a parallel sum where each computation processes *exactly* one element would be inefficient, so instead we use a *bulk* element layout. The bulk element layout is a sequence layout containing a group of 100 elements — which should make it more amenable to parallel processing.\n+\n+Since the segment operated upon by the spliterator is associated with a shared scope, the segment can be accessed from multiple threads concurrently; the spliterator API ensures that the access occurs in a disjoint fashion: a slice is created from the original segment, and given to a thread to perform some computation — thus ensuring that no two threads can ever operate concurrently on the same memory region.\n+\n+### Combining memory access handles\n+\n+We have seen in the previous sections how memory access var handles dramatically simplify user code when structured access is involved. While deriving memory access var handles from layout is the most convenient option, the Foreign Memory Access API also allows to create such memory access var handles in a standalone fashion, as demonstrated in the following code:\n+\n+```java\n+VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder())    \n+```\n+\n+The above code creates a memory access var handle which reads\/writes `int` values at a certain byte offset in a segment. To create this var handle we have to specify a carrier type — the type we want to use e.g. to extract values from memory, as well as to whether any byte swapping should be applied when contents are read from or stored to memory. Additionally, the user can supply an extra alignment parameter (not shown here) — this can be useful to impose additional constraints on how memory dereferences should occur; for instance, a client might want to prevent access to misaligned 32 bit values. Of course, when deriving memory access var handles from layouts, all the above information can more simply inferred from the selected layout.\n+\n+The attentive reader might have noted how rich the var handles returned by the layout API are, compared to the simple memory access var handle we have constructed above. How do we go from a simple access var handle that takes a byte offset to a var handle that can dereference a complex layout path? The answer is, by using var handle *combinators*. Developers familiar with the method handle API know how simpler method handles can be combined into more complex ones using the various combinator methods in the `MethodHandles` API. These methods allow, for instance, to insert (or bind) arguments into a target method handle, filter return values, permute arguments and much more.\n+\n+Sadly, none of these features are available when working with var handles. The Foreign Memory Access API rectifies this, by adding a rich set of var handle combinators in the `MemoryHandles` class; with these tools, developers can express var handle transformations such as:\n+\n+* mapping a var handle carrier type into a different one, using an embedding\/projection method handle pairs\n+* filter one or more var handle access coordinates using unary filters\n+* permute var handle access coordinates\n+* bind concrete access coordinates to an existing var handle\n+\n+Without diving too deep, let's consider how we might want to take a basic memory access handle and turn it into a var handle which dereference a segment at a specific offset (again using the `points` layout defined previously):\n+\n+```java\n+VarHandle intHandle = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()); \/\/ (MS, J) -> I\n+long offsetOfY = points.byteOffset(PathElement.sequenceElement(3), PathElement.groupElement(\"y\"));\n+VarHandle valueHandle = MemoryHandles.insertCoordinates(intHandle, 1, offsetOfValue); \/\/ (MS) -> I\n+```\n+\n+We have been able to derive, from a basic memory access var handle, a new var handle that dereferences a segment at a given fixed offset. It is easy to see how other, richer, var handles obtained using the layout API can be constructed manually using the var handle combinator API.\n+\n+### Unsafe segments\n+\n+The memory access API provides basic safety guarantees for all memory segments created using the API. More specifically, dereferencing memory should either succeed, or result in a runtime exception - but, crucially, should never result in a VM crash, or, more subtly, in memory corruption occurring *outside* the region of memory associated with a memory segment. This is possible, since all segments have immutable *spatial bounds*, and, as we have seen, are associated with a resource scope which make sure that the segment cannot be dereferenced after the scope has been closed, or, in case of a confined scope, that the segment is dereferenced from the very same thread which created the scope.\n+\n+That said, it is sometimes necessary to create a segment out of an existing memory source, which might be managed by native code. This is the case, for instance, if we want to create a segment out of memory managed by a custom allocator.\n+\n+The ByteBuffer API allows such a move, through a JNI [method](https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/jni\/spec\/functions.html#NewDirectByteBuffer), namely `NewDirectByteBuffer`. This native method can be used to wrap a long address in a fresh byte buffer instance which is then returned to unsuspecting Java code.\n+\n+Memory segments provide a similar capability - that is, given an address (which might have been obtained through some native calls), it is possible to wrap a segment around it, with given spatial bounds and resource scope; a cleanup action to be executed when the segment is closed might also be specified.\n+\n+For instance, assuming we have an address pointing at some externally managed memory block, we can construct an *unsafe* segment, as follows:\n+\n+```java\n+try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+    MemoryAddress addr = MemoryAddress.ofLong(someLongAddr);\n+    var unsafeSegment = addr.asSegment(10, scope);\n+    ...\n+}\n+```\n+\n+The above code creates a shared scope and then, inside the *try-with-resources* it creates a *new* unsafe segment from a given address; the size of the segment is 10 bytes, and the unsafe segment is associated with the current shared scope. This means that the unsafe segment cannot be dereferenced after the shared scope has been closed.\n+\n+Of course, segments created this way are completely *unsafe*. There is no way for the runtime to verify that the provided address indeed points to a valid memory location, or that the size of the memory region pointed to by `addr` is indeed 10 bytes. Similarly, there are no guarantees that the underlying memory region associated with `addr` will not be deallocated *prior* to the call to `ResourceScope::close`.\n+\n+For these reasons, creating unsafe segments is a *restricted* operation in the Foreign Memory Access API. Restricted operations can only be performed from selected modules. To grant a given module `M`  the permission to execute restricted methods, the option `--enable-native-access=M` must be specified on the command line. Multiple module names can be specified in a comma-separated list, where the special name `ALL-UNNAMED` is used to enable restricted access for all code on the class path. Any attempt to call restricted operations from a module not listed in the above flag will fail with a runtime exception.\n+\n+* <a id=\"1\"\/>(<sup>1<\/sup>):<small> In general, deriving a complete layout from a C `struct` declaration is no trivial matter, and it's one of those areas where tooling can help greatly.<\/small>\n+* <a id=\"2\"\/>(<sup>2<\/sup>):<small> Clients can enforce stricter type checking when interacting with `VarHandle` instances, by obtaining an *exact* var handle, using the `VarHandle::withInvokeExactBehavior` method.<\/small>\n+* <a id=\"3\"\/>(<sup>3<\/sup>):<small> Shared segments rely on VM thread-local handshakes (JEP [312](https:\/\/openjdk.java.net\/jeps\/312)) to implement lock-free, safe, shared memory access; that is, when it comes to memory access, there should no difference in performance between a shared segment and a confined segment. On the other hand, `MemorySegment::close` might be slower on shared segments than on confined ones.<\/small>\n+* <a id=\"4\"\/>(<sup>4<\/sup>):<small> The main difference between reference counting and the mechanism proposed here is that reference counting is *symmetric* - meaning that any client is able to both increment and decrement the reference count at will. The resource scope handle mechanism is *asymmetric*, since only the client acquiring a handle has the capability to release that handle. This avoids situation where a client might be tempted to e.g. decrement the reference count multiple times in order to perform some task which would otherwise be forbidden. <\/small>\n+\n","filename":"doc\/panama_memaccess.md","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,203 @@\n+#\n+# Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+################################################################################\n+# Setup libclang from llvm project\n+################################################################################\n+AC_DEFUN_ONCE([LIB_SETUP_LIBCLANG],\n+[\n+  AC_ARG_WITH([libclang], [AS_HELP_STRING([--with-libclang=<path to llvm>],\n+      [Specify path of llvm installation containing libclang. Pre-built llvm\n+      binary can be downloaded from http:\/\/llvm.org\/releases\/download.html])])\n+  AC_ARG_WITH([libclang-lib], [AS_HELP_STRING([--with-libclang-lib=<path>],\n+      [Specify where to find libclang binary, so\/dylib\/lib ])])\n+  AC_ARG_WITH([libclang-include], [AS_HELP_STRING([--with-libclang-include=<path>],\n+      [Specify where to find libclang header files, clang-c\/Index.h ])])\n+  AC_ARG_WITH([libclang-include-aux], [AS_HELP_STRING([--with-libclang-include-aux=<path>],\n+      [Specify where to find libclang auxiliary header files, lib\/clang\/<clang-version>\/include\/stddef.h ])])\n+  AC_ARG_WITH([libclang-bin], [AS_HELP_STRING([--with-libclang-bin=<path>],\n+      [Specify where to find clang binary, libclang.dll ])])\n+  AC_ARG_WITH([libclang-version], [AS_HELP_STRING([--with-libclang-version=<version>],\n+      [Specify which libclang version to use ])])\n+\n+  if test \"x$with_libclang\" = \"xno\"; then\n+    AC_MSG_CHECKING([if libclang should be enabled])\n+    AC_MSG_RESULT([no, forced])\n+    ENABLE_LIBCLANG=\"false\"\n+  else\n+    if test \"x$with_libclang\" != \"x\"; then\n+      AC_MSG_CHECKING([if libclang should be enabled])\n+      AC_MSG_RESULT([yes, forced])\n+      ENABLE_LIBCLANG_FORCED=\"true\"\n+    else\n+      ENABLE_LIBCLANG_FORCED=\"false\"\n+    fi\n+    ENABLE_LIBCLANG=\"true\"\n+\n+    AC_MSG_CHECKING([libclang version to be used])\n+    if test \"x$with_libclang_version\" != \"x\"; then\n+      LIBCLANG_VERSION=\"$with_libclang_version\"\n+      AC_MSG_RESULT([$LIBCLANG_VERSION (manually specified)])\n+    else\n+      LIBCLANG_VERSION=\"9\"\n+      AC_MSG_RESULT([$LIBCLANG_VERSION (default)])\n+    fi\n+\n+    if test \"x$with_libclang\" != \"x\" -a \"x$with_libclang\" != \"xyes\"; then\n+      CLANG_LIB_PATH=\"$with_libclang\/lib\"\n+      CLANG_BIN_PATH=\"$with_libclang\/bin\"\n+      CLANG_INCLUDE_PATH=\"$with_libclang\/include\"\n+\n+      AC_MSG_CHECKING([libclang auxiliary include path])\n+      if test \"x$with_libclang_include_aux\" != \"x\"; then\n+        CLANG_INCLUDE_AUX_PATH=\"$with_libclang_include_aux\"\n+        AC_MSG_RESULT([$CLANG_INCLUDE_AUX_PATH])\n+        if test \"x$with_libclang_version\" != \"x\"; then\n+          AC_MSG_WARN([--with-libclang-include-aux was specified. Manually specified value of --with-libclang-version was ignored])\n+        fi        \n+      else \n+        # There may be more than one version of clang matching the specifed version.\n+        # Pick the last one if there are more than one versions.\n+        VER=`$LS $with_libclang\/lib\/clang\/ | $GREP \"^$LIBCLANG_VERSION\" | $TAIL -n1`\n+        if test \"x$VER\" = \"x\"; then\n+          AC_MSG_ERROR([Can not find libclang version matching the specified version: '$LIBCLANG_VERSION' in\n+            $($FIND $with_libclang\/lib\/clang\/ -mindepth 1 -maxdepth 1)])\n+        fi        \n+        CLANG_INCLUDE_AUX_PATH=\"$with_libclang\/lib\/clang\/$VER\/include\"\n+        AC_MSG_RESULT([$CLANG_INCLUDE_AUX_PATH])\n+      fi      \n+    fi\n+\n+    if test \"x$with_libclang_lib\" != \"x\"; then\n+      CLANG_LIB_PATH=\"$with_libclang_lib\"\n+    fi\n+    if test \"x$with_libclang_include\" != \"x\"; then\n+      CLANG_INCLUDE_PATH=\"$with_libclang_include\"\n+    fi\n+    if test \"x$with_libclang_bin\" != \"x\"; then\n+      CLANG_BIN_PATH=\"$with_libclang_bin\"\n+    fi\n+\n+    dnl Only for Windows platform now, as we don't need bin yet for other platform\n+    if test \"x$OPENJDK_TARGET_OS\" = xwindows; then\n+        UTIL_FIXUP_PATH(CLANG_BIN_PATH)\n+    else\n+        CLANG_BIN_PATH=\"\"\n+    fi\n+\n+    UTIL_FIXUP_PATH(CLANG_INCLUDE_PATH)\n+    UTIL_FIXUP_PATH(CLANG_LIB_PATH)\n+    UTIL_FIXUP_PATH(CLANG_INCLUDE_AUX_PATH)\n+\n+    if test \"x$CLANG_INCLUDE_PATH\" != \"x\"; then\n+        LIBCLANG_CPPFLAGS=\"-I$CLANG_INCLUDE_PATH\"\n+    else\n+        LIBCLANG_CPPFLAGS=\"\"\n+    fi\n+\n+    if test \"x$CLANG_LIB_PATH\" != \"x\"; then\n+      if test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\"; then\n+        LIBCLANG_LDFLAGS=\"\/LIBPATH:$CLANG_LIB_PATH\"\n+        LIBCLANG_LIBS=\"$CLANG_LIB_PATH\/libclang.lib\"\n+      else\n+        LIBCLANG_LDFLAGS=\"-L$CLANG_LIB_PATH\"\n+        LIBCLANG_LIBS=\"-lclang\"\n+      fi\n+    else\n+        LIBCLANG_LDFLAGS=\"\"\n+    fi\n+\n+    OLD_CPPFLAGS=$CPPFLAGS\n+    OLD_LDFLAGS=$LDFLAGS\n+    OLD_LIBS=$LIBS\n+\n+    CPPFLAGS=\"$LIBCLANG_CPPFLAGS\"\n+    LDFLAGS=\"$LIBCLANG_LDFLAGS\"\n+    LIBS=\"\"\n+\n+    OLD_CXX=$CXX\n+    OLD_CXXCPP=$CXXCPP\n+    CXX=\"$FIXPATH $CXX\"\n+    CXXCPP=\"$FIXPATH $CXXCPP\"\n+\n+    AC_CHECK_HEADER(\"clang-c\/Index.h\", [], [ENABLE_LIBCLANG=\"false\"])\n+    if test \"x$ENABLE_LIBCLANG\" = \"xtrue\"; then\n+      if test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\" || test \"x$COMPILE_TYPE\" = \"xcross\"; then\n+        # Just trust the lib is there\n+        LIBS=$LIBCLANG_LIBS\n+      else\n+        AC_CHECK_LIB(clang, clang_getClangVersion, [], [ENABLE_LIBCLANG=\"false\"])\n+      fi\n+    fi\n+\n+    CXX=$OLD_CXX\n+    CXXCPP=$OLD_CXXCPP\n+\n+    if test \"x$ENABLE_LIBCLANG\" = \"xfalse\"; then\n+      if test \"x$ENABLE_LIBCLANG_FORCED\" = \"xtrue\"; then\n+        AC_MSG_ERROR([Cannot locate libclang or headers at the specified locations:\n+            $CLANG_LIB_PATH\n+            $CLANG_INCLUDE_PATH])\n+      else\n+        AC_MSG_CHECKING([if libclang should be enabled])\n+        AC_MSG_RESULT([no, not found])\n+        AC_MSG_ERROR([Cannot locate libclang! You can download pre-built llvm\n+            binary from http:\/\/llvm.org\/releases\/download.html, then specify the\n+            location using --with-libclang])\n+      fi\n+    fi\n+\n+    LIBCLANG_LIBS=\"$LIBS\"\n+\n+    LIBS=\"$OLD_LIBS\"\n+    LDFLAGS=\"$OLD_LDFLAGS\"\n+    CPPFLAGS=\"$OLD_CPPFLAGS\"\n+  fi\n+\n+  if test \"x$ENABLE_LIBCLANG\" = \"xfalse\"; then\n+    CLANG_INCLUDE_PATH=\"\"\n+    CLANG_INCLUDE_AUX_PATH=\"\"\n+    CLANG_LIB_PATH=\"\"\n+    LIBCLANG_CPPFLAGS=\"\"\n+    LIBCLANG_LDFLAGS=\"\"\n+    LIBCLANG_LIBS=\"\"\n+  else\n+    if test \"x$OPENJDK_TARGET_OS\" = xwindows; then\n+      CLANG_LIBNAME=[$CLANG_BIN_PATH][\"\/libclang\"][$SHARED_LIBRARY_SUFFIX]\n+    else\n+      CLANG_LIBNAME=[$CLANG_LIB_PATH\/$LIBRARY_PREFIX][\"clang\"][$SHARED_LIBRARY_SUFFIX]\n+    fi\n+    UTIL_REMOVE_SYMBOLIC_LINKS(CLANG_LIBNAME)\n+  fi\n+\n+  AC_SUBST(ENABLE_LIBCLANG)\n+  AC_SUBST(CLANG_INCLUDE_PATH)\n+  AC_SUBST(CLANG_INCLUDE_AUX_PATH)\n+  AC_SUBST(CLANG_LIB_PATH)\n+  AC_SUBST(CLANG_LIBNAME)\n+  AC_SUBST(LIBCLANG_CPPFLAGS)\n+  AC_SUBST(LIBCLANG_LDFLAGS)\n+  AC_SUBST(LIBCLANG_LIBS)\n+])\n","filename":"make\/autoconf\/lib-clang.m4","additions":203,"deletions":0,"binary":false,"changes":203,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+m4_include([lib-clang.m4])\n@@ -107,0 +108,1 @@\n+  LIB_SETUP_LIBCLANG\n","filename":"make\/autoconf\/libraries.m4","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,0 +137,9 @@\n+ENABLE_LIBCLANG:=@ENABLE_LIBCLANG@\n+CLANG_LIB_PATH:=@CLANG_LIB_PATH@\n+CLANG_INCLUDE_PATH:=@CLANG_INCLUDE_PATH@\n+CLANG_INCLUDE_AUX_PATH:=@CLANG_INCLUDE_AUX_PATH@\n+CLANG_LIBNAME:=@CLANG_LIBNAME@\n+LIBCLANG_CPPFLAGS:=@LIBCLANG_CPPFLAGS@\n+LIBCLANG_LDFLAGS:=@LIBCLANG_LDFLAGS@\n+LIBCLANG_LIBS:=@LIBCLANG_LIBS@\n+\n@@ -608,0 +617,1 @@\n+SET_JCLANG_LIBRARY_ORIGIN=@SET_JCLANG_LIBRARY_ORIGIN@\n","filename":"make\/autoconf\/spec.gmk.in","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+\tjdk.incubator.jextract \\\n","filename":"make\/conf\/build-module-sets.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+\tjdk.incubator.jextract \\\n","filename":"make\/conf\/docs-modules.conf","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -425,1 +425,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"build_devkit\", \"graphviz\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"build_devkit\", \"graphviz\", \"pandoc\", \"libclang\"],\n@@ -446,1 +446,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"pandoc\", \"libclang\"],\n@@ -466,1 +466,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"pandoc\"],\n+            dependencies: [\"devkit\", \"gtest\", \"pandoc\", \"libclang\"],\n@@ -737,1 +737,1 @@\n-                \"boot_jdk\", \"devkit\", \"graphviz\", \"pandoc\", buildJdkDep,\n+                \"boot_jdk\", \"devkit\", \"graphviz\", \"pandoc\", buildJdkDep, \"libclang\"\n@@ -1141,0 +1141,7 @@\n+        libclang: {\n+            organization: common.organization,\n+            module: \"libclang-\" + input.build_platform,\n+            ext: \"tar.gz\",\n+            revision: \"9.0.0+\" + (input.build_platform == \"macosx_x64\" ? \"2.0\" : \"1.0\")\n+        },\n+\n","filename":"make\/conf\/jib-profiles.js","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,186 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# This script generates a libclang bundle. On linux by building it from source\n+# using a devkit, which should match the devkit used to build the JDK. On Macos\n+# prebuilt binaries are downloaded and repackaged. On Windows, the binary LLVM\n+# distribution needs to be downloaded and installed manually first.\n+#\n+# Set MAKE_ARGS to add parameters to make. Ex:\n+#\n+# $ MAKE_ARGS=-j32 bash createLibclangBundle.sh\n+#\n+# The llvm\/clang build is very resource intensive at the end so often needs\n+# to be restarted a few times before it fully succeeds.\n+#\n+# The script tries to behave well on multiple invocations, only performing steps\n+# not already done. To redo a step, manually delete the target files from that\n+# step.\n+\n+LLVM_VERSION=9.0.0\n+\n+BUNDLE_NAME=libclang-$LLVM_VERSION.tar.gz\n+\n+SCRIPT_DIR=\"$(cd \"$(dirname $0)\" > \/dev\/null && pwd)\"\n+OUTPUT_DIR=\"${SCRIPT_DIR}\/..\/..\/build\/libclang\"\n+SRC_DIR=\"$OUTPUT_DIR\/src\"\n+BUILD_DIR=\"$OUTPUT_DIR\/build\"\n+DOWNLOAD_DIR=\"$OUTPUT_DIR\/download\"\n+INSTALL_DIR=\"$OUTPUT_DIR\/install\"\n+IMAGE_DIR=\"$OUTPUT_DIR\/image\"\n+\n+OS_NAME=$(uname -s)\n+case $OS_NAME in\n+  Linux)\n+    USAGE=\"$0 <devkit dir>\"\n+\n+    if [ \"$1\" = \"\" ]; then\n+      echo $USAGE\n+      exit 1\n+    fi\n+    DEVKIT_DIR=\"$1\"\n+\n+    LIB_SUFFIX=.so\n+\n+    # Download source distros\n+    mkdir -p $DOWNLOAD_DIR\n+    cd $DOWNLOAD_DIR\n+    LLVM_FILE=llvm-$LLVM_VERSION.src.tar.xz\n+    if [ ! -f $LLVM_FILE ]; then\n+      wget http:\/\/releases.llvm.org\/$LLVM_VERSION\/$LLVM_FILE\n+    fi\n+    CLANG_FILE=cfe-$LLVM_VERSION.src.tar.xz\n+    if [ ! -f $CLANG_FILE ]; then\n+      wget http:\/\/releases.llvm.org\/$LLVM_VERSION\/$CLANG_FILE\n+    fi\n+\n+\n+    # Unpack src\n+    mkdir -p $SRC_DIR\n+    cd $SRC_DIR\n+    LLVM_DIRNAME=llvm-$LLVM_VERSION.src\n+    LLVM_DIR=$SRC_DIR\/$LLVM_DIRNAME\n+    if [ ! -d $LLVM_DIRNAME ]; then\n+      echo \"Unpacking $LLVM_FILE\"\n+      tar xf $DOWNLOAD_DIR\/$LLVM_FILE\n+    fi\n+    CLANG_DIRNAME=cfe-$LLVM_VERSION.src\n+    CLANG_DIR=$LLVM_DIRNAME\/tools\/$CLANG_DIRNAME\n+    if [ ! -d $CLANG_DIR ]; then\n+      echo \"Unpacking $CLANG_FILE\"\n+      (cd $LLVM_DIR\/tools && tar xf $DOWNLOAD_DIR\/$CLANG_FILE)\n+    fi\n+\n+    # Build\n+    mkdir -p $BUILD_DIR\n+    cd $BUILD_DIR\n+\n+    #init cmake\n+    if [ ! -e cmake ]; then\n+      cmake -G 'Unix Makefiles' \\\n+            -DCMAKE_INSTALL_PREFIX=..\/install \\\n+            -DCMAKE_BUILD_TYPE=Release \\\n+            -DCMAKE_C_COMPILER=$DEVKIT_DIR\/bin\/gcc \\\n+            -DCMAKE_CXX_COMPILER=$DEVKIT_DIR\/bin\/g++ \\\n+            -DCMAKE_C_FLAGS=\"-static-libgcc\" \\\n+            -DCMAKE_CXX_FLAGS=\"-static-libgcc -static-libstdc++\" \\\n+            -DLLVM_ENABLE_TERMINFO=no \\\n+            $LLVM_DIR\n+    fi\n+\n+    # Run with nice to keep system usable during build.\n+    nice make $MAKE_ARGS libclang\n+    nice make $MAKE_ARGS install\n+    ;;\n+  Darwin)\n+    LIB_SUFFIX=\".dylib\"\n+\n+    # Download binaries\n+    mkdir -p $DOWNLOAD_DIR\n+    cd $DOWNLOAD_DIR\n+    LLVM_FILE=clang+llvm-$LLVM_VERSION-x86_64-darwin-apple.tar.xz\n+    if [ ! -f $LLVM_FILE ]; then\n+      echo http:\/\/releases.llvm.org\/$LLVM_VERSION\/$LLVM_FILE\n+      curl -O http:\/\/releases.llvm.org\/$LLVM_VERSION\/$LLVM_FILE\n+    fi\n+\n+    # Extract binaries\n+    cd $OUTPUT_DIR\n+    LLVM_DIRNAME=clang+llvm-$LLVM_VERSION-x86_64-darwin-apple\n+    LLVM_DIR=$OUTPUT_DIR\/$LLVM_DIRNAME\n+    INSTALL_DIR=$LLVM_DIR\n+    if [ ! -d $LLVM_DIRNAME ]; then\n+      echo \"Unpacking $LLVM_FILE\"\n+      tar xf $DOWNLOAD_DIR\/$LLVM_FILE\n+    fi\n+    ;;\n+  CYGWIN*)\n+    if [ \"$1\" = \"\" ]; then\n+      echo \"Download and install http:\/\/releases.llvm.org\/$LLVM_VERSION\/LLVM-$LLVM_VERSION-win64.exe\"\n+      echo \"Then run: $0 <path to install dir>\"\n+      exit 1\n+    fi\n+    INSTALL_DIR=\"$(cygpath -m -s \"$1\")\"\n+    echo \"Copying from $INSTALL_DIR\"\n+    LIB_SUFFIX=\".lib\"\n+\n+    if [ ! -e $IMAGE_DIR\/bin\/libclang.dll ]; then\n+      echo \"Copying libclang.dll to image\"\n+      mkdir -p $IMAGE_DIR\/bin\n+      cp -a $INSTALL_DIR\/bin\/libclang.* $IMAGE_DIR\/bin\/\n+    fi\n+    ;;\n+  *)\n+    echo \" Unsupported OS: $OS_NAME\"\n+    exit 1\n+    ;;\n+esac\n+\n+mkdir -p $IMAGE_DIR\n+# Extract what we need into an image\n+if [ ! -e $IMAGE_DIR\/lib\/libclang$LIB_SUFFIX ]; then\n+  echo \"Copying libclang$LIB_SUFFIX to image\"\n+  mkdir -p $IMAGE_DIR\/lib\n+  cp -a $INSTALL_DIR\/lib\/libclang.* $IMAGE_DIR\/lib\/\n+fi\n+if [ ! -e $IMAGE_DIR\/include\/clang-c ]; then\n+  echo \"Copying include to image\"\n+  mkdir -p $IMAGE_DIR\/include\n+  cp -a $INSTALL_DIR\/include\/. $IMAGE_DIR\/include\/\n+fi\n+if [ ! -e $IMAGE_DIR\/lib\/clang\/$LLVM_VERSION\/include\/stddef.h ]; then\n+  echo \"Copying lib\/clang\/*\/include to image\"\n+  mkdir -p $IMAGE_DIR\/lib\/clang\/$LLVM_VERSION\/include\n+  cp -a $INSTALL_DIR\/lib\/clang\/$LLVM_VERSION\/include\/. \\\n+     $IMAGE_DIR\/lib\/clang\/$LLVM_VERSION\/include\/\n+fi\n+\n+# Create bundle\n+if [ ! -e $OUTPUT_DIR\/$BUNDLE_NAME ]; then\n+  echo \"Creating $OUTPUT_DIR\/$BUNDLE_NAME\"\n+  cd $IMAGE_DIR\n+  tar zcf $OUTPUT_DIR\/$BUNDLE_NAME *\n+fi\n","filename":"make\/devkit\/createLibclangBundle.sh","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+#\n+# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include CopyCommon.gmk\n+\n+################################################################################\n+\n+ifeq ($(ENABLE_LIBCLANG), true)\n+\n+  ifeq ($(OPENJDK_BUILD_OS), windows)\n+      LIB_PATH := $(CLANG_LIBNAME)\n+      LINK_MACRO := install-file\n+  else\n+      LIB_PATH := $(CLANG_LIB_PATH)\/$(LIBRARY_PREFIX)clang$(SHARED_LIBRARY_SUFFIX)\n+      LINK_MACRO := link-file-absolute\n+  endif\n+\n+  $(eval $(call SetupCopyFiles, COPY_CLANG_LIB, \\\n+      FILES := $(wildcard $(LIB_PATH)*), \\\n+      DEST := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+      MACRO := $(LINK_MACRO), \\\n+  ))\n+\n+  $(eval $(call SetupCopyFiles, COPY_CLANG_HEADERS, \\\n+      DEST := $(CONF_DST_DIR)\/jextract, \\\n+      FILES := $(wildcard $(CLANG_INCLUDE_AUX_PATH)\/*.h), \\\n+  ))\n+\n+  TARGETS := $(COPY_CLANG_LIB) $(COPY_CLANG_HEADERS)\n+\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/jdk.incubator.jextract\/Copy.gmk","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+COPY += .properties .template\n","filename":"make\/modules\/jdk.incubator.jextract\/Java.gmk","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+#\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include LauncherCommon.gmk\n+\n+$(eval $(call SetupBuildLauncher, jextract,\\\n+    CFLAGS := -DENABLE_ARG_FILES, \\\n+    JAVA_ARGS := --enable-native-access=jdk.incubator.jextract, \\\n+    MAIN_CLASS := jdk.incubator.jextract.JextractTool, \\\n+))\n","filename":"make\/modules\/jdk.incubator.jextract\/Launcher.gmk","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -763,0 +763,13 @@\n+  \n+  \/\/ This check is repetition of some checks from inline_unsafe_access(), used to determine if barriers are needed\n+  \/\/ Not full scope of checks is performed, we check only if access can be mixed\n+  const Type *const base_type = gvn().type(base);\n+\n+  \/\/ Is off heap access (true implies can_access_non_heap = true)\n+  const bool off_heap_access = TypePtr::NULL_PTR == base_type;\n+\n+  \/\/ Can base be NULL? Otherwise, always on-heap access.\n+  const bool can_access_non_heap = TypePtr::NULL_PTR->higher_equal(base_type);\n+\n+  \/\/ Not determined access base can and can not be null.\n+  const bool mixed_access = !(off_heap_access == can_access_non_heap);\n@@ -824,0 +837,4 @@\n+  if (mixed_access) {\n+    insert_mem_bar(Op_MemBarCPUOrder);\n+  }\n+\n@@ -867,0 +884,4 @@\n+  if (mixed_access) {\n+    insert_mem_bar(Op_MemBarCPUOrder);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -179,1 +179,2 @@\n-        jdk.jlink;\n+        jdk.jlink,\n+        jdk.incubator.jextract;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,9 @@\n+Files in jdk.internal.clang.libclang package are jextract generated and then modified.\n+jextract was run using \"sh extract.sh\" on Mac OS.\n+\n+Manual modifications:\n+\n+* GNU\/CP copyright header added\n+* Generated C_LONG layouts are replaced with C_LONGLONG for portability\n+* Index_h.libName was manually added to handle platform dependency of\n+libclang shared library. \n","filename":"src\/jdk.incubator.jextract\/share\/classes\/README","additions":9,"deletions":0,"binary":false,"changes":9,"status":"added"},{"patch":"@@ -0,0 +1,1556 @@\n+###\n+\n+--include-macro __API_TO_BE_DEPRECATED\n+\n+###\n+\n+--include-macro __ENABLE_LEGACY_MAC_AVAILABILITY\n+--include-macro __MAC_OS_X_VERSION_MAX_ALLOWED\n+--include-macro __MAC_OS_X_VERSION_MIN_REQUIRED\n+\n+###\n+\n+--include-macro MAC_OS_VERSION_11_0\n+--include-macro MAC_OS_X_VERSION_10_0\n+--include-macro MAC_OS_X_VERSION_10_1\n+--include-macro MAC_OS_X_VERSION_10_10\n+--include-macro MAC_OS_X_VERSION_10_10_2\n+--include-macro MAC_OS_X_VERSION_10_10_3\n+--include-macro MAC_OS_X_VERSION_10_11\n+--include-macro MAC_OS_X_VERSION_10_11_2\n+--include-macro MAC_OS_X_VERSION_10_11_3\n+--include-macro MAC_OS_X_VERSION_10_11_4\n+--include-macro MAC_OS_X_VERSION_10_12\n+--include-macro MAC_OS_X_VERSION_10_12_1\n+--include-macro MAC_OS_X_VERSION_10_12_2\n+--include-macro MAC_OS_X_VERSION_10_12_4\n+--include-macro MAC_OS_X_VERSION_10_13\n+--include-macro MAC_OS_X_VERSION_10_13_1\n+--include-macro MAC_OS_X_VERSION_10_13_2\n+--include-macro MAC_OS_X_VERSION_10_13_4\n+--include-macro MAC_OS_X_VERSION_10_14\n+--include-macro MAC_OS_X_VERSION_10_14_1\n+--include-macro MAC_OS_X_VERSION_10_14_4\n+--include-macro MAC_OS_X_VERSION_10_14_6\n+--include-macro MAC_OS_X_VERSION_10_15\n+--include-macro MAC_OS_X_VERSION_10_15_1\n+--include-macro MAC_OS_X_VERSION_10_16\n+--include-macro MAC_OS_X_VERSION_10_2\n+--include-macro MAC_OS_X_VERSION_10_3\n+--include-macro MAC_OS_X_VERSION_10_4\n+--include-macro MAC_OS_X_VERSION_10_5\n+--include-macro MAC_OS_X_VERSION_10_6\n+--include-macro MAC_OS_X_VERSION_10_7\n+--include-macro MAC_OS_X_VERSION_10_8\n+--include-macro MAC_OS_X_VERSION_10_9\n+--include-macro __DRIVERKIT_19_0\n+--include-macro __DRIVERKIT_20_0\n+--include-macro __IPHONE_10_0\n+--include-macro __IPHONE_10_1\n+--include-macro __IPHONE_10_2\n+--include-macro __IPHONE_10_3\n+--include-macro __IPHONE_11_0\n+--include-macro __IPHONE_11_1\n+--include-macro __IPHONE_11_2\n+--include-macro __IPHONE_11_3\n+--include-macro __IPHONE_11_4\n+--include-macro __IPHONE_12_0\n+--include-macro __IPHONE_12_1\n+--include-macro __IPHONE_12_2\n+--include-macro __IPHONE_12_3\n+--include-macro __IPHONE_12_4\n+--include-macro __IPHONE_13_0\n+--include-macro __IPHONE_13_1\n+--include-macro __IPHONE_13_2\n+--include-macro __IPHONE_13_3\n+--include-macro __IPHONE_13_4\n+--include-macro __IPHONE_13_5\n+--include-macro __IPHONE_13_6\n+--include-macro __IPHONE_13_7\n+--include-macro __IPHONE_14_0\n+--include-macro __IPHONE_14_1\n+--include-macro __IPHONE_14_2\n+--include-macro __IPHONE_14_3\n+--include-macro __IPHONE_2_0\n+--include-macro __IPHONE_2_1\n+--include-macro __IPHONE_2_2\n+--include-macro __IPHONE_3_0\n+--include-macro __IPHONE_3_1\n+--include-macro __IPHONE_3_2\n+--include-macro __IPHONE_4_0\n+--include-macro __IPHONE_4_1\n+--include-macro __IPHONE_4_2\n+--include-macro __IPHONE_4_3\n+--include-macro __IPHONE_5_0\n+--include-macro __IPHONE_5_1\n+--include-macro __IPHONE_6_0\n+--include-macro __IPHONE_6_1\n+--include-macro __IPHONE_7_0\n+--include-macro __IPHONE_7_1\n+--include-macro __IPHONE_8_0\n+--include-macro __IPHONE_8_1\n+--include-macro __IPHONE_8_2\n+--include-macro __IPHONE_8_3\n+--include-macro __IPHONE_8_4\n+--include-macro __IPHONE_9_0\n+--include-macro __IPHONE_9_1\n+--include-macro __IPHONE_9_2\n+--include-macro __IPHONE_9_3\n+--include-macro __MAC_10_0\n+--include-macro __MAC_10_1\n+--include-macro __MAC_10_10\n+--include-macro __MAC_10_10_2\n+--include-macro __MAC_10_10_3\n+--include-macro __MAC_10_11\n+--include-macro __MAC_10_11_2\n+--include-macro __MAC_10_11_3\n+--include-macro __MAC_10_11_4\n+--include-macro __MAC_10_12\n+--include-macro __MAC_10_12_1\n+--include-macro __MAC_10_12_2\n+--include-macro __MAC_10_12_4\n+--include-macro __MAC_10_13\n+--include-macro __MAC_10_13_1\n+--include-macro __MAC_10_13_2\n+--include-macro __MAC_10_13_4\n+--include-macro __MAC_10_14\n+--include-macro __MAC_10_14_1\n+--include-macro __MAC_10_14_4\n+--include-macro __MAC_10_14_6\n+--include-macro __MAC_10_15\n+--include-macro __MAC_10_15_1\n+--include-macro __MAC_10_15_4\n+--include-macro __MAC_10_16\n+--include-macro __MAC_10_2\n+--include-macro __MAC_10_3\n+--include-macro __MAC_10_4\n+--include-macro __MAC_10_5\n+--include-macro __MAC_10_6\n+--include-macro __MAC_10_7\n+--include-macro __MAC_10_8\n+--include-macro __MAC_10_9\n+--include-macro __MAC_11_0\n+--include-macro __MAC_11_1\n+--include-macro __TVOS_10_0\n+--include-macro __TVOS_10_0_1\n+--include-macro __TVOS_10_1\n+--include-macro __TVOS_10_2\n+--include-macro __TVOS_11_0\n+--include-macro __TVOS_11_1\n+--include-macro __TVOS_11_2\n+--include-macro __TVOS_11_3\n+--include-macro __TVOS_11_4\n+--include-macro __TVOS_12_0\n+--include-macro __TVOS_12_1\n+--include-macro __TVOS_12_2\n+--include-macro __TVOS_12_3\n+--include-macro __TVOS_12_4\n+--include-macro __TVOS_13_0\n+--include-macro __TVOS_13_2\n+--include-macro __TVOS_13_3\n+--include-macro __TVOS_13_4\n+--include-macro __TVOS_14_0\n+--include-macro __TVOS_14_1\n+--include-macro __TVOS_14_2\n+--include-macro __TVOS_14_3\n+--include-macro __TVOS_9_0\n+--include-macro __TVOS_9_1\n+--include-macro __TVOS_9_2\n+--include-macro __WATCHOS_1_0\n+--include-macro __WATCHOS_2_0\n+--include-macro __WATCHOS_2_1\n+--include-macro __WATCHOS_2_2\n+--include-macro __WATCHOS_3_0\n+--include-macro __WATCHOS_3_1\n+--include-macro __WATCHOS_3_1_1\n+--include-macro __WATCHOS_3_2\n+--include-macro __WATCHOS_4_0\n+--include-macro __WATCHOS_4_1\n+--include-macro __WATCHOS_4_2\n+--include-macro __WATCHOS_4_3\n+--include-macro __WATCHOS_5_0\n+--include-macro __WATCHOS_5_1\n+--include-macro __WATCHOS_5_2\n+--include-macro __WATCHOS_5_3\n+--include-macro __WATCHOS_6_0\n+--include-macro __WATCHOS_6_1\n+--include-macro __WATCHOS_6_2\n+--include-macro __WATCHOS_7_0\n+--include-macro __WATCHOS_7_1\n+--include-macro __WATCHOS_7_2\n+\n+###\n+\n+--include-typedef __darwin_nl_item\n+--include-typedef __darwin_wctrans_t\n+--include-typedef __darwin_wctype_t\n+--include-macro _FORTIFY_SOURCE\n+--include-macro __DARWIN_WCHAR_MAX\n+--include-macro __DARWIN_WCHAR_MIN\n+--include-macro __DARWIN_WEOF\n+\n+###\n+\n+--include-typedef __darwin_clock_t\n+--include-typedef __darwin_ct_rune_t\n+--include-typedef __darwin_intptr_t\n+--include-typedef __darwin_mbstate_t\n+--include-typedef __darwin_natural_t\n+--include-typedef __darwin_ptrdiff_t\n+--include-typedef __darwin_rune_t\n+--include-typedef __darwin_size_t\n+--include-typedef __darwin_socklen_t\n+--include-typedef __darwin_ssize_t\n+--include-typedef __darwin_time_t\n+--include-typedef __darwin_va_list\n+--include-typedef __darwin_wchar_t\n+--include-typedef __darwin_wint_t\n+--include-typedef __int16_t\n+--include-typedef __int32_t\n+--include-typedef __int64_t\n+--include-typedef __int8_t\n+--include-typedef __mbstate_t\n+--include-typedef __uint16_t\n+--include-typedef __uint32_t\n+--include-typedef __uint64_t\n+--include-typedef __uint8_t\n+\n+###\n+\n+--include-typedef register_t\n+--include-typedef syscall_arg_t\n+--include-typedef user_addr_t\n+--include-typedef user_long_t\n+--include-typedef user_off_t\n+--include-typedef user_size_t\n+--include-typedef user_ssize_t\n+--include-typedef user_time_t\n+--include-typedef user_ulong_t\n+--include-macro USER_ADDR_NULL\n+\n+###\n+\n+--include-typedef __darwin_pthread_attr_t\n+--include-typedef __darwin_pthread_cond_t\n+--include-typedef __darwin_pthread_condattr_t\n+--include-typedef __darwin_pthread_key_t\n+--include-typedef __darwin_pthread_mutex_t\n+--include-typedef __darwin_pthread_mutexattr_t\n+--include-typedef __darwin_pthread_once_t\n+--include-typedef __darwin_pthread_rwlock_t\n+--include-typedef __darwin_pthread_rwlockattr_t\n+--include-typedef __darwin_pthread_t\n+--include-macro __PTHREAD_ATTR_SIZE__\n+--include-macro __PTHREAD_CONDATTR_SIZE__\n+--include-macro __PTHREAD_COND_SIZE__\n+--include-macro __PTHREAD_MUTEXATTR_SIZE__\n+--include-macro __PTHREAD_MUTEX_SIZE__\n+--include-macro __PTHREAD_ONCE_SIZE__\n+--include-macro __PTHREAD_RWLOCKATTR_SIZE__\n+--include-macro __PTHREAD_RWLOCK_SIZE__\n+--include-macro __PTHREAD_SIZE__\n+--include-struct __darwin_pthread_handler_rec\n+--include-struct _opaque_pthread_attr_t\n+--include-struct _opaque_pthread_cond_t\n+--include-struct _opaque_pthread_condattr_t\n+--include-struct _opaque_pthread_mutex_t\n+--include-struct _opaque_pthread_mutexattr_t\n+--include-struct _opaque_pthread_once_t\n+--include-struct _opaque_pthread_rwlock_t\n+--include-struct _opaque_pthread_rwlockattr_t\n+--include-struct _opaque_pthread_t\n+\n+###\n+\n+--include-typedef __darwin_blkcnt_t\n+--include-typedef __darwin_blksize_t\n+--include-typedef __darwin_dev_t\n+--include-typedef __darwin_fsblkcnt_t\n+--include-typedef __darwin_fsfilcnt_t\n+--include-typedef __darwin_gid_t\n+--include-typedef __darwin_id_t\n+--include-typedef __darwin_ino64_t\n+--include-typedef __darwin_ino_t\n+--include-typedef __darwin_mach_port_name_t\n+--include-typedef __darwin_mach_port_t\n+--include-typedef __darwin_mode_t\n+--include-typedef __darwin_off_t\n+--include-typedef __darwin_pid_t\n+--include-typedef __darwin_sigset_t\n+--include-typedef __darwin_suseconds_t\n+--include-typedef __darwin_uid_t\n+--include-typedef __darwin_useconds_t\n+--include-typedef __darwin_uuid_string_t\n+--include-typedef __darwin_uuid_t\n+--include-macro __DARWIN_NULL\n+\n+###\n+\n+--include-typedef clock_t\n+\n+###\n+\n+--include-typedef int16_t\n+\n+###\n+\n+--include-typedef int32_t\n+\n+###\n+\n+--include-typedef int64_t\n+\n+###\n+\n+--include-typedef int8_t\n+\n+###\n+\n+--include-typedef intptr_t\n+\n+###\n+\n+--include-macro NULL\n+\n+###\n+\n+--include-typedef size_t\n+\n+###\n+\n+--include-typedef time_t\n+\n+###\n+\n+--include-struct timespec\n+\n+###\n+\n+--include-typedef u_int16_t\n+\n+###\n+\n+--include-typedef u_int32_t\n+\n+###\n+\n+--include-typedef u_int64_t\n+\n+###\n+\n+--include-typedef u_int8_t\n+\n+###\n+\n+--include-typedef uintptr_t\n+\n+###\n+\n+--include-macro _DARWIN_FEATURE_64_BIT_INODE\n+--include-macro _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE\n+--include-macro _DARWIN_FEATURE_UNIX_CONFORMANCE\n+--include-macro __DARWIN_64_BIT_INO_T\n+--include-macro __DARWIN_C_ANSI\n+--include-macro __DARWIN_C_FULL\n+--include-macro __DARWIN_C_LEVEL\n+--include-macro __DARWIN_NON_CANCELABLE\n+--include-macro __DARWIN_NO_LONG_LONG\n+--include-macro __DARWIN_ONLY_64_BIT_INO_T\n+--include-macro __DARWIN_ONLY_UNIX_CONFORMANCE\n+--include-macro __DARWIN_ONLY_VERS_1050\n+--include-macro __DARWIN_SUF_1050\n+--include-macro __DARWIN_SUF_64_BIT_INO_T\n+--include-macro __DARWIN_SUF_EXTSN\n+--include-macro __DARWIN_UNIX03\n+--include-macro __DARWIN_VERS_1050\n+--include-macro __STDC_WANT_LIB_EXT1__\n+\n+###\n+\n+--include-typedef clockid_t\n+--include-function asctime\n+--include-function asctime_r\n+--include-function clock\n+--include-function clock_getres\n+--include-function clock_gettime\n+--include-function clock_gettime_nsec_np\n+--include-function clock_settime\n+--include-function ctime\n+--include-function ctime_r\n+--include-function difftime\n+--include-function getdate\n+--include-function gmtime\n+--include-function gmtime_r\n+--include-function localtime\n+--include-function localtime_r\n+--include-function mktime\n+--include-function nanosleep\n+--include-function posix2time\n+--include-function strftime\n+--include-function strptime\n+--include-function time\n+--include-function time2posix\n+--include-function timegm\n+--include-function timelocal\n+--include-function timespec_get\n+--include-function tzset\n+--include-function tzsetwall\n+--include-macro CLOCKS_PER_SEC\n+--include-macro CLOCK_MONOTONIC\n+--include-macro CLOCK_MONOTONIC_RAW\n+--include-macro CLOCK_MONOTONIC_RAW_APPROX\n+--include-macro CLOCK_PROCESS_CPUTIME_ID\n+--include-macro CLOCK_REALTIME\n+--include-macro CLOCK_THREAD_CPUTIME_ID\n+--include-macro CLOCK_UPTIME_RAW\n+--include-macro CLOCK_UPTIME_RAW_APPROX\n+--include-macro TIME_UTC\n+--include-macro _CLOCK_MONOTONIC\n+--include-macro _CLOCK_MONOTONIC_RAW\n+--include-macro _CLOCK_MONOTONIC_RAW_APPROX\n+--include-macro _CLOCK_PROCESS_CPUTIME_ID\n+--include-macro _CLOCK_REALTIME\n+--include-macro _CLOCK_THREAD_CPUTIME_ID\n+--include-macro _CLOCK_UPTIME_RAW\n+--include-macro _CLOCK_UPTIME_RAW_APPROX\n+--include-struct tm\n+--include-var daylight\n+--include-var getdate_err\n+--include-var timezone\n+--include-var tzname\n+\n+###\n+\n+--include-function clang_ModuleMapDescriptor_create\n+--include-function clang_ModuleMapDescriptor_dispose\n+--include-function clang_ModuleMapDescriptor_setFrameworkModuleName\n+--include-function clang_ModuleMapDescriptor_setUmbrellaHeader\n+--include-function clang_ModuleMapDescriptor_writeToBuffer\n+--include-function clang_VirtualFileOverlay_addFileMapping\n+--include-function clang_VirtualFileOverlay_create\n+--include-function clang_VirtualFileOverlay_dispose\n+--include-function clang_VirtualFileOverlay_setCaseSensitivity\n+--include-function clang_VirtualFileOverlay_writeToBuffer\n+--include-function clang_free\n+--include-function clang_getBuildSessionTimestamp\n+--include-typedef CXModuleMapDescriptor\n+--include-typedef CXVirtualFileOverlay\n+\n+###\n+\n+--include-macro CXError_ASTReadError\n+--include-macro CXError_Crashed\n+--include-macro CXError_Failure\n+--include-macro CXError_InvalidArguments\n+--include-macro CXError_Success\n+\n+###\n+\n+--include-function clang_disposeString\n+--include-function clang_disposeStringSet\n+--include-function clang_getCString\n+--include-typedef CXString\n+--include-typedef CXStringSet\n+\n+###\n+\n+--include-function clang_CXCursorSet_contains\n+--include-function clang_CXCursorSet_insert\n+--include-function clang_CXIndex_getGlobalOptions\n+--include-function clang_CXIndex_setGlobalOptions\n+--include-function clang_CXIndex_setInvocationEmissionPathOption\n+--include-function clang_CXXConstructor_isConvertingConstructor\n+--include-function clang_CXXConstructor_isCopyConstructor\n+--include-function clang_CXXConstructor_isDefaultConstructor\n+--include-function clang_CXXConstructor_isMoveConstructor\n+--include-function clang_CXXField_isMutable\n+--include-function clang_CXXMethod_isConst\n+--include-function clang_CXXMethod_isDefaulted\n+--include-function clang_CXXMethod_isPureVirtual\n+--include-function clang_CXXMethod_isStatic\n+--include-function clang_CXXMethod_isVirtual\n+--include-function clang_CXXRecord_isAbstract\n+--include-function clang_Cursor_Evaluate\n+--include-function clang_Cursor_getArgument\n+--include-function clang_Cursor_getBriefCommentText\n+--include-function clang_Cursor_getCXXManglings\n+--include-function clang_Cursor_getCommentRange\n+--include-function clang_Cursor_getMangling\n+--include-function clang_Cursor_getModule\n+--include-function clang_Cursor_getNumArguments\n+--include-function clang_Cursor_getNumTemplateArguments\n+--include-function clang_Cursor_getObjCDeclQualifiers\n+--include-function clang_Cursor_getObjCManglings\n+--include-function clang_Cursor_getObjCPropertyAttributes\n+--include-function clang_Cursor_getObjCPropertyGetterName\n+--include-function clang_Cursor_getObjCPropertySetterName\n+--include-function clang_Cursor_getObjCSelectorIndex\n+--include-function clang_Cursor_getOffsetOfField\n+--include-function clang_Cursor_getRawCommentText\n+--include-function clang_Cursor_getReceiverType\n+--include-function clang_Cursor_getSpellingNameRange\n+--include-function clang_Cursor_getStorageClass\n+--include-function clang_Cursor_getTemplateArgumentKind\n+--include-function clang_Cursor_getTemplateArgumentType\n+--include-function clang_Cursor_getTemplateArgumentUnsignedValue\n+--include-function clang_Cursor_getTemplateArgumentValue\n+--include-function clang_Cursor_getTranslationUnit\n+--include-function clang_Cursor_hasAttrs\n+--include-function clang_Cursor_isAnonymous\n+--include-function clang_Cursor_isAnonymousRecordDecl\n+--include-function clang_Cursor_isBitField\n+--include-function clang_Cursor_isDynamicCall\n+--include-function clang_Cursor_isExternalSymbol\n+--include-function clang_Cursor_isFunctionInlined\n+--include-function clang_Cursor_isInlineNamespace\n+--include-function clang_Cursor_isMacroBuiltin\n+--include-function clang_Cursor_isMacroFunctionLike\n+--include-function clang_Cursor_isNull\n+--include-function clang_Cursor_isObjCOptional\n+--include-function clang_Cursor_isVariadic\n+--include-function clang_EnumDecl_isScoped\n+--include-function clang_EvalResult_dispose\n+--include-function clang_EvalResult_getAsDouble\n+--include-function clang_EvalResult_getAsInt\n+--include-function clang_EvalResult_getAsLongLong\n+--include-function clang_EvalResult_getAsStr\n+--include-function clang_EvalResult_getAsUnsigned\n+--include-function clang_EvalResult_getKind\n+--include-function clang_EvalResult_isUnsignedInt\n+--include-function clang_File_isEqual\n+--include-function clang_File_tryGetRealPathName\n+--include-function clang_IndexAction_create\n+--include-function clang_IndexAction_dispose\n+--include-function clang_Location_isFromMainFile\n+--include-function clang_Location_isInSystemHeader\n+--include-function clang_Module_getASTFile\n+--include-function clang_Module_getFullName\n+--include-function clang_Module_getName\n+--include-function clang_Module_getNumTopLevelHeaders\n+--include-function clang_Module_getParent\n+--include-function clang_Module_getTopLevelHeader\n+--include-function clang_Module_isSystem\n+--include-function clang_PrintingPolicy_dispose\n+--include-function clang_PrintingPolicy_getProperty\n+--include-function clang_PrintingPolicy_setProperty\n+--include-function clang_Range_isNull\n+--include-function clang_TargetInfo_dispose\n+--include-function clang_TargetInfo_getPointerWidth\n+--include-function clang_TargetInfo_getTriple\n+--include-function clang_Type_getAlignOf\n+--include-function clang_Type_getCXXRefQualifier\n+--include-function clang_Type_getClassType\n+--include-function clang_Type_getModifiedType\n+--include-function clang_Type_getNamedType\n+--include-function clang_Type_getNullability\n+--include-function clang_Type_getNumObjCProtocolRefs\n+--include-function clang_Type_getNumObjCTypeArgs\n+--include-function clang_Type_getNumTemplateArguments\n+--include-function clang_Type_getObjCEncoding\n+--include-function clang_Type_getObjCObjectBaseType\n+--include-function clang_Type_getObjCProtocolDecl\n+--include-function clang_Type_getObjCTypeArg\n+--include-function clang_Type_getOffsetOf\n+--include-function clang_Type_getSizeOf\n+--include-function clang_Type_getTemplateArgumentAsType\n+--include-function clang_Type_isTransparentTagTypedef\n+--include-function clang_Type_visitFields\n+--include-function clang_annotateTokens\n+--include-function clang_codeCompleteAt\n+--include-function clang_codeCompleteGetContainerKind\n+--include-function clang_codeCompleteGetContainerUSR\n+--include-function clang_codeCompleteGetContexts\n+--include-function clang_codeCompleteGetDiagnostic\n+--include-function clang_codeCompleteGetNumDiagnostics\n+--include-function clang_codeCompleteGetObjCSelector\n+--include-function clang_constructUSR_ObjCCategory\n+--include-function clang_constructUSR_ObjCClass\n+--include-function clang_constructUSR_ObjCIvar\n+--include-function clang_constructUSR_ObjCMethod\n+--include-function clang_constructUSR_ObjCProperty\n+--include-function clang_constructUSR_ObjCProtocol\n+--include-function clang_createCXCursorSet\n+--include-function clang_createIndex\n+--include-function clang_createTranslationUnit\n+--include-function clang_createTranslationUnit2\n+--include-function clang_createTranslationUnitFromSourceFile\n+--include-function clang_defaultCodeCompleteOptions\n+--include-function clang_defaultDiagnosticDisplayOptions\n+--include-function clang_defaultEditingTranslationUnitOptions\n+--include-function clang_defaultReparseOptions\n+--include-function clang_defaultSaveOptions\n+--include-function clang_disposeCXCursorSet\n+--include-function clang_disposeCXPlatformAvailability\n+--include-function clang_disposeCXTUResourceUsage\n+--include-function clang_disposeCodeCompleteResults\n+--include-function clang_disposeDiagnostic\n+--include-function clang_disposeDiagnosticSet\n+--include-function clang_disposeIndex\n+--include-function clang_disposeOverriddenCursors\n+--include-function clang_disposeSourceRangeList\n+--include-function clang_disposeTokens\n+--include-function clang_disposeTranslationUnit\n+--include-function clang_enableStackTraces\n+--include-function clang_equalCursors\n+--include-function clang_equalLocations\n+--include-function clang_equalRanges\n+--include-function clang_equalTypes\n+--include-function clang_executeOnThread\n+--include-function clang_findIncludesInFile\n+--include-function clang_findIncludesInFileWithBlock\n+--include-function clang_findReferencesInFile\n+--include-function clang_findReferencesInFileWithBlock\n+--include-function clang_formatDiagnostic\n+--include-function clang_getAddressSpace\n+--include-function clang_getAllSkippedRanges\n+--include-function clang_getArgType\n+--include-function clang_getArrayElementType\n+--include-function clang_getArraySize\n+--include-function clang_getCXTUResourceUsage\n+--include-function clang_getCXXAccessSpecifier\n+--include-function clang_getCanonicalCursor\n+--include-function clang_getCanonicalType\n+--include-function clang_getChildDiagnostics\n+--include-function clang_getClangVersion\n+--include-function clang_getCompletionAnnotation\n+--include-function clang_getCompletionAvailability\n+--include-function clang_getCompletionBriefComment\n+--include-function clang_getCompletionChunkCompletionString\n+--include-function clang_getCompletionChunkKind\n+--include-function clang_getCompletionChunkText\n+--include-function clang_getCompletionFixIt\n+--include-function clang_getCompletionNumAnnotations\n+--include-function clang_getCompletionNumFixIts\n+--include-function clang_getCompletionParent\n+--include-function clang_getCompletionPriority\n+--include-function clang_getCursor\n+--include-function clang_getCursorAvailability\n+--include-function clang_getCursorCompletionString\n+--include-function clang_getCursorDefinition\n+--include-function clang_getCursorDisplayName\n+--include-function clang_getCursorExceptionSpecificationType\n+--include-function clang_getCursorExtent\n+--include-function clang_getCursorKind\n+--include-function clang_getCursorKindSpelling\n+--include-function clang_getCursorLanguage\n+--include-function clang_getCursorLexicalParent\n+--include-function clang_getCursorLinkage\n+--include-function clang_getCursorLocation\n+--include-function clang_getCursorPlatformAvailability\n+--include-function clang_getCursorPrettyPrinted\n+--include-function clang_getCursorPrintingPolicy\n+--include-function clang_getCursorReferenceNameRange\n+--include-function clang_getCursorReferenced\n+--include-function clang_getCursorResultType\n+--include-function clang_getCursorSemanticParent\n+--include-function clang_getCursorSpelling\n+--include-function clang_getCursorTLSKind\n+--include-function clang_getCursorType\n+--include-function clang_getCursorUSR\n+--include-function clang_getCursorVisibility\n+--include-function clang_getDeclObjCTypeEncoding\n+--include-function clang_getDefinitionSpellingAndExtent\n+--include-function clang_getDiagnostic\n+--include-function clang_getDiagnosticCategory\n+--include-function clang_getDiagnosticCategoryName\n+--include-function clang_getDiagnosticCategoryText\n+--include-function clang_getDiagnosticFixIt\n+--include-function clang_getDiagnosticInSet\n+--include-function clang_getDiagnosticLocation\n+--include-function clang_getDiagnosticNumFixIts\n+--include-function clang_getDiagnosticNumRanges\n+--include-function clang_getDiagnosticOption\n+--include-function clang_getDiagnosticRange\n+--include-function clang_getDiagnosticSetFromTU\n+--include-function clang_getDiagnosticSeverity\n+--include-function clang_getDiagnosticSpelling\n+--include-function clang_getElementType\n+--include-function clang_getEnumConstantDeclUnsignedValue\n+--include-function clang_getEnumConstantDeclValue\n+--include-function clang_getEnumDeclIntegerType\n+--include-function clang_getExceptionSpecificationType\n+--include-function clang_getExpansionLocation\n+--include-function clang_getFieldDeclBitWidth\n+--include-function clang_getFile\n+--include-function clang_getFileContents\n+--include-function clang_getFileLocation\n+--include-function clang_getFileName\n+--include-function clang_getFileTime\n+--include-function clang_getFileUniqueID\n+--include-function clang_getFunctionTypeCallingConv\n+--include-function clang_getIBOutletCollectionType\n+--include-function clang_getIncludedFile\n+--include-function clang_getInclusions\n+--include-function clang_getInstantiationLocation\n+--include-function clang_getLocation\n+--include-function clang_getLocationForOffset\n+--include-function clang_getModuleForFile\n+--include-function clang_getNullCursor\n+--include-function clang_getNullLocation\n+--include-function clang_getNullRange\n+--include-function clang_getNumArgTypes\n+--include-function clang_getNumCompletionChunks\n+--include-function clang_getNumDiagnostics\n+--include-function clang_getNumDiagnosticsInSet\n+--include-function clang_getNumElements\n+--include-function clang_getNumOverloadedDecls\n+--include-function clang_getOverloadedDecl\n+--include-function clang_getOverriddenCursors\n+--include-function clang_getPointeeType\n+--include-function clang_getPresumedLocation\n+--include-function clang_getRange\n+--include-function clang_getRangeEnd\n+--include-function clang_getRangeStart\n+--include-function clang_getRemappings\n+--include-function clang_getRemappingsFromFileList\n+--include-function clang_getResultType\n+--include-function clang_getSkippedRanges\n+--include-function clang_getSpecializedCursorTemplate\n+--include-function clang_getSpellingLocation\n+--include-function clang_getTUResourceUsageName\n+--include-function clang_getTemplateCursorKind\n+--include-function clang_getToken\n+--include-function clang_getTokenExtent\n+--include-function clang_getTokenKind\n+--include-function clang_getTokenLocation\n+--include-function clang_getTokenSpelling\n+--include-function clang_getTranslationUnitCursor\n+--include-function clang_getTranslationUnitSpelling\n+--include-function clang_getTranslationUnitTargetInfo\n+--include-function clang_getTypeDeclaration\n+--include-function clang_getTypeKindSpelling\n+--include-function clang_getTypeSpelling\n+--include-function clang_getTypedefDeclUnderlyingType\n+--include-function clang_getTypedefName\n+--include-function clang_hashCursor\n+--include-function clang_indexLoc_getCXSourceLocation\n+--include-function clang_indexLoc_getFileLocation\n+--include-function clang_indexSourceFile\n+--include-function clang_indexSourceFileFullArgv\n+--include-function clang_indexTranslationUnit\n+--include-function clang_index_getCXXClassDeclInfo\n+--include-function clang_index_getClientContainer\n+--include-function clang_index_getClientEntity\n+--include-function clang_index_getIBOutletCollectionAttrInfo\n+--include-function clang_index_getObjCCategoryDeclInfo\n+--include-function clang_index_getObjCContainerDeclInfo\n+--include-function clang_index_getObjCInterfaceDeclInfo\n+--include-function clang_index_getObjCPropertyDeclInfo\n+--include-function clang_index_getObjCProtocolRefListInfo\n+--include-function clang_index_isEntityObjCContainerKind\n+--include-function clang_index_setClientContainer\n+--include-function clang_index_setClientEntity\n+--include-function clang_isAttribute\n+--include-function clang_isConstQualifiedType\n+--include-function clang_isCursorDefinition\n+--include-function clang_isDeclaration\n+--include-function clang_isExpression\n+--include-function clang_isFileMultipleIncludeGuarded\n+--include-function clang_isFunctionTypeVariadic\n+--include-function clang_isInvalid\n+--include-function clang_isInvalidDeclaration\n+--include-function clang_isPODType\n+--include-function clang_isPreprocessing\n+--include-function clang_isReference\n+--include-function clang_isRestrictQualifiedType\n+--include-function clang_isStatement\n+--include-function clang_isTranslationUnit\n+--include-function clang_isUnexposed\n+--include-function clang_isVirtualBase\n+--include-function clang_isVolatileQualifiedType\n+--include-function clang_loadDiagnostics\n+--include-function clang_parseTranslationUnit\n+--include-function clang_parseTranslationUnit2\n+--include-function clang_parseTranslationUnit2FullArgv\n+--include-function clang_remap_dispose\n+--include-function clang_remap_getFilenames\n+--include-function clang_remap_getNumFiles\n+--include-function clang_reparseTranslationUnit\n+--include-function clang_saveTranslationUnit\n+--include-function clang_sortCodeCompletionResults\n+--include-function clang_suspendTranslationUnit\n+--include-function clang_toggleCrashRecovery\n+--include-function clang_tokenize\n+--include-function clang_visitChildren\n+--include-function clang_visitChildrenWithBlock\n+--include-typedef CXClientData\n+--include-typedef CXCodeCompleteResults\n+--include-typedef CXCompletionResult\n+--include-typedef CXCompletionString\n+--include-typedef CXCursor\n+--include-typedef CXCursorAndRangeVisitorBlock\n+--include-typedef CXCursorSet\n+--include-typedef CXCursorVisitor\n+--include-typedef CXCursorVisitorBlock\n+--include-typedef CXDiagnostic\n+--include-typedef CXDiagnosticSet\n+--include-typedef CXEvalResult\n+--include-typedef CXEvalResultKind\n+--include-typedef CXFieldVisitor\n+--include-typedef CXFile\n+--include-typedef CXFileUniqueID\n+--include-typedef CXGlobalOptFlags\n+--include-typedef CXIdxAttrInfo\n+--include-typedef CXIdxAttrKind\n+--include-typedef CXIdxBaseClassInfo\n+--include-typedef CXIdxCXXClassDeclInfo\n+--include-typedef CXIdxClientASTFile\n+--include-typedef CXIdxClientContainer\n+--include-typedef CXIdxClientEntity\n+--include-typedef CXIdxClientFile\n+--include-typedef CXIdxContainerInfo\n+--include-typedef CXIdxDeclInfo\n+--include-typedef CXIdxDeclInfoFlags\n+--include-typedef CXIdxEntityCXXTemplateKind\n+--include-typedef CXIdxEntityInfo\n+--include-typedef CXIdxEntityKind\n+--include-typedef CXIdxEntityLanguage\n+--include-typedef CXIdxEntityRefInfo\n+--include-typedef CXIdxEntityRefKind\n+--include-typedef CXIdxIBOutletCollectionAttrInfo\n+--include-typedef CXIdxImportedASTFileInfo\n+--include-typedef CXIdxIncludedFileInfo\n+--include-typedef CXIdxLoc\n+--include-typedef CXIdxObjCCategoryDeclInfo\n+--include-typedef CXIdxObjCContainerDeclInfo\n+--include-typedef CXIdxObjCContainerKind\n+--include-typedef CXIdxObjCInterfaceDeclInfo\n+--include-typedef CXIdxObjCPropertyDeclInfo\n+--include-typedef CXIdxObjCProtocolRefInfo\n+--include-typedef CXIdxObjCProtocolRefListInfo\n+--include-typedef CXInclusionVisitor\n+--include-typedef CXIndex\n+--include-typedef CXIndexAction\n+--include-typedef CXIndexOptFlags\n+--include-typedef CXModule\n+--include-typedef CXObjCDeclQualifierKind\n+--include-typedef CXObjCPropertyAttrKind\n+--include-typedef CXPrintingPolicy\n+--include-typedef CXRemapping\n+--include-typedef CXResult\n+--include-typedef CXSourceLocation\n+--include-typedef CXSourceRange\n+--include-typedef CXSourceRangeList\n+--include-typedef CXSymbolRole\n+--include-typedef CXTargetInfo\n+--include-typedef CXToken\n+--include-typedef CXTranslationUnit\n+--include-typedef CXType\n+--include-typedef IndexerCallbacks\n+--include-macro CINDEX_VERSION\n+--include-macro CINDEX_VERSION_MAJOR\n+--include-macro CINDEX_VERSION_MINOR\n+--include-macro CINDEX_VERSION_STRING\n+--include-macro CXAvailability_Available\n+--include-macro CXAvailability_Deprecated\n+--include-macro CXAvailability_NotAccessible\n+--include-macro CXAvailability_NotAvailable\n+--include-macro CXCallingConv_AAPCS\n+--include-macro CXCallingConv_AAPCS_VFP\n+--include-macro CXCallingConv_AArch64VectorCall\n+--include-macro CXCallingConv_C\n+--include-macro CXCallingConv_Default\n+--include-macro CXCallingConv_IntelOclBicc\n+--include-macro CXCallingConv_Invalid\n+--include-macro CXCallingConv_PreserveAll\n+--include-macro CXCallingConv_PreserveMost\n+--include-macro CXCallingConv_Swift\n+--include-macro CXCallingConv_Unexposed\n+--include-macro CXCallingConv_Win64\n+--include-macro CXCallingConv_X86FastCall\n+--include-macro CXCallingConv_X86Pascal\n+--include-macro CXCallingConv_X86RegCall\n+--include-macro CXCallingConv_X86StdCall\n+--include-macro CXCallingConv_X86ThisCall\n+--include-macro CXCallingConv_X86VectorCall\n+--include-macro CXCallingConv_X86_64SysV\n+--include-macro CXCallingConv_X86_64Win64\n+--include-macro CXChildVisit_Break\n+--include-macro CXChildVisit_Continue\n+--include-macro CXChildVisit_Recurse\n+--include-macro CXCodeComplete_IncludeBriefComments\n+--include-macro CXCodeComplete_IncludeCodePatterns\n+--include-macro CXCodeComplete_IncludeCompletionsWithFixIts\n+--include-macro CXCodeComplete_IncludeMacros\n+--include-macro CXCodeComplete_SkipPreamble\n+--include-macro CXCompletionChunk_Colon\n+--include-macro CXCompletionChunk_Comma\n+--include-macro CXCompletionChunk_CurrentParameter\n+--include-macro CXCompletionChunk_Equal\n+--include-macro CXCompletionChunk_HorizontalSpace\n+--include-macro CXCompletionChunk_Informative\n+--include-macro CXCompletionChunk_LeftAngle\n+--include-macro CXCompletionChunk_LeftBrace\n+--include-macro CXCompletionChunk_LeftBracket\n+--include-macro CXCompletionChunk_LeftParen\n+--include-macro CXCompletionChunk_Optional\n+--include-macro CXCompletionChunk_Placeholder\n+--include-macro CXCompletionChunk_ResultType\n+--include-macro CXCompletionChunk_RightAngle\n+--include-macro CXCompletionChunk_RightBrace\n+--include-macro CXCompletionChunk_RightBracket\n+--include-macro CXCompletionChunk_RightParen\n+--include-macro CXCompletionChunk_SemiColon\n+--include-macro CXCompletionChunk_Text\n+--include-macro CXCompletionChunk_TypedText\n+--include-macro CXCompletionChunk_VerticalSpace\n+--include-macro CXCompletionContext_AnyType\n+--include-macro CXCompletionContext_AnyValue\n+--include-macro CXCompletionContext_ArrowMemberAccess\n+--include-macro CXCompletionContext_CXXClassTypeValue\n+--include-macro CXCompletionContext_ClassTag\n+--include-macro CXCompletionContext_DotMemberAccess\n+--include-macro CXCompletionContext_EnumTag\n+--include-macro CXCompletionContext_IncludedFile\n+--include-macro CXCompletionContext_MacroName\n+--include-macro CXCompletionContext_Namespace\n+--include-macro CXCompletionContext_NaturalLanguage\n+--include-macro CXCompletionContext_NestedNameSpecifier\n+--include-macro CXCompletionContext_ObjCCategory\n+--include-macro CXCompletionContext_ObjCClassMessage\n+--include-macro CXCompletionContext_ObjCInstanceMessage\n+--include-macro CXCompletionContext_ObjCInterface\n+--include-macro CXCompletionContext_ObjCObjectValue\n+--include-macro CXCompletionContext_ObjCPropertyAccess\n+--include-macro CXCompletionContext_ObjCProtocol\n+--include-macro CXCompletionContext_ObjCSelectorName\n+--include-macro CXCompletionContext_ObjCSelectorValue\n+--include-macro CXCompletionContext_StructTag\n+--include-macro CXCompletionContext_Unexposed\n+--include-macro CXCompletionContext_UnionTag\n+--include-macro CXCompletionContext_Unknown\n+--include-macro CXCursor_AddrLabelExpr\n+--include-macro CXCursor_AlignedAttr\n+--include-macro CXCursor_AnnotateAttr\n+--include-macro CXCursor_ArraySubscriptExpr\n+--include-macro CXCursor_AsmLabelAttr\n+--include-macro CXCursor_AsmStmt\n+--include-macro CXCursor_BinaryOperator\n+--include-macro CXCursor_BlockExpr\n+--include-macro CXCursor_BreakStmt\n+--include-macro CXCursor_BuiltinBitCastExpr\n+--include-macro CXCursor_CStyleCastExpr\n+--include-macro CXCursor_CUDAConstantAttr\n+--include-macro CXCursor_CUDADeviceAttr\n+--include-macro CXCursor_CUDAGlobalAttr\n+--include-macro CXCursor_CUDAHostAttr\n+--include-macro CXCursor_CUDASharedAttr\n+--include-macro CXCursor_CXXAccessSpecifier\n+--include-macro CXCursor_CXXBaseSpecifier\n+--include-macro CXCursor_CXXBoolLiteralExpr\n+--include-macro CXCursor_CXXCatchStmt\n+--include-macro CXCursor_CXXConstCastExpr\n+--include-macro CXCursor_CXXDeleteExpr\n+--include-macro CXCursor_CXXDynamicCastExpr\n+--include-macro CXCursor_CXXFinalAttr\n+--include-macro CXCursor_CXXForRangeStmt\n+--include-macro CXCursor_CXXFunctionalCastExpr\n+--include-macro CXCursor_CXXMethod\n+--include-macro CXCursor_CXXNewExpr\n+--include-macro CXCursor_CXXNullPtrLiteralExpr\n+--include-macro CXCursor_CXXOverrideAttr\n+--include-macro CXCursor_CXXReinterpretCastExpr\n+--include-macro CXCursor_CXXStaticCastExpr\n+--include-macro CXCursor_CXXThisExpr\n+--include-macro CXCursor_CXXThrowExpr\n+--include-macro CXCursor_CXXTryStmt\n+--include-macro CXCursor_CXXTypeidExpr\n+--include-macro CXCursor_CallExpr\n+--include-macro CXCursor_CaseStmt\n+--include-macro CXCursor_CharacterLiteral\n+--include-macro CXCursor_ClassDecl\n+--include-macro CXCursor_ClassTemplate\n+--include-macro CXCursor_ClassTemplatePartialSpecialization\n+--include-macro CXCursor_CompoundAssignOperator\n+--include-macro CXCursor_CompoundLiteralExpr\n+--include-macro CXCursor_CompoundStmt\n+--include-macro CXCursor_ConditionalOperator\n+--include-macro CXCursor_ConstAttr\n+--include-macro CXCursor_Constructor\n+--include-macro CXCursor_ContinueStmt\n+--include-macro CXCursor_ConvergentAttr\n+--include-macro CXCursor_ConversionFunction\n+--include-macro CXCursor_DLLExport\n+--include-macro CXCursor_DLLImport\n+--include-macro CXCursor_DeclRefExpr\n+--include-macro CXCursor_DeclStmt\n+--include-macro CXCursor_DefaultStmt\n+--include-macro CXCursor_Destructor\n+--include-macro CXCursor_DoStmt\n+--include-macro CXCursor_EnumConstantDecl\n+--include-macro CXCursor_EnumDecl\n+--include-macro CXCursor_ExceptionSpecificationKind_BasicNoexcept\n+--include-macro CXCursor_ExceptionSpecificationKind_ComputedNoexcept\n+--include-macro CXCursor_ExceptionSpecificationKind_Dynamic\n+--include-macro CXCursor_ExceptionSpecificationKind_DynamicNone\n+--include-macro CXCursor_ExceptionSpecificationKind_MSAny\n+--include-macro CXCursor_ExceptionSpecificationKind_NoThrow\n+--include-macro CXCursor_ExceptionSpecificationKind_None\n+--include-macro CXCursor_ExceptionSpecificationKind_Unevaluated\n+--include-macro CXCursor_ExceptionSpecificationKind_Uninstantiated\n+--include-macro CXCursor_ExceptionSpecificationKind_Unparsed\n+--include-macro CXCursor_FieldDecl\n+--include-macro CXCursor_FirstAttr\n+--include-macro CXCursor_FirstDecl\n+--include-macro CXCursor_FirstExpr\n+--include-macro CXCursor_FirstExtraDecl\n+--include-macro CXCursor_FirstInvalid\n+--include-macro CXCursor_FirstPreprocessing\n+--include-macro CXCursor_FirstRef\n+--include-macro CXCursor_FirstStmt\n+--include-macro CXCursor_FixedPointLiteral\n+--include-macro CXCursor_FlagEnum\n+--include-macro CXCursor_FloatingLiteral\n+--include-macro CXCursor_ForStmt\n+--include-macro CXCursor_FriendDecl\n+--include-macro CXCursor_FunctionDecl\n+--include-macro CXCursor_FunctionTemplate\n+--include-macro CXCursor_GCCAsmStmt\n+--include-macro CXCursor_GNUNullExpr\n+--include-macro CXCursor_GenericSelectionExpr\n+--include-macro CXCursor_GotoStmt\n+--include-macro CXCursor_IBActionAttr\n+--include-macro CXCursor_IBOutletAttr\n+--include-macro CXCursor_IBOutletCollectionAttr\n+--include-macro CXCursor_IfStmt\n+--include-macro CXCursor_ImaginaryLiteral\n+--include-macro CXCursor_InclusionDirective\n+--include-macro CXCursor_IndirectGotoStmt\n+--include-macro CXCursor_InitListExpr\n+--include-macro CXCursor_IntegerLiteral\n+--include-macro CXCursor_InvalidCode\n+--include-macro CXCursor_InvalidFile\n+--include-macro CXCursor_LabelRef\n+--include-macro CXCursor_LabelStmt\n+--include-macro CXCursor_LambdaExpr\n+--include-macro CXCursor_LastAttr\n+--include-macro CXCursor_LastDecl\n+--include-macro CXCursor_LastExpr\n+--include-macro CXCursor_LastExtraDecl\n+--include-macro CXCursor_LastInvalid\n+--include-macro CXCursor_LastPreprocessing\n+--include-macro CXCursor_LastRef\n+--include-macro CXCursor_LastStmt\n+--include-macro CXCursor_LinkageSpec\n+--include-macro CXCursor_MSAsmStmt\n+--include-macro CXCursor_MacroDefinition\n+--include-macro CXCursor_MacroExpansion\n+--include-macro CXCursor_MacroInstantiation\n+--include-macro CXCursor_MemberRef\n+--include-macro CXCursor_MemberRefExpr\n+--include-macro CXCursor_ModuleImportDecl\n+--include-macro CXCursor_NSConsumed\n+--include-macro CXCursor_NSConsumesSelf\n+--include-macro CXCursor_NSReturnsAutoreleased\n+--include-macro CXCursor_NSReturnsNotRetained\n+--include-macro CXCursor_NSReturnsRetained\n+--include-macro CXCursor_Namespace\n+--include-macro CXCursor_NamespaceAlias\n+--include-macro CXCursor_NamespaceRef\n+--include-macro CXCursor_NoDeclFound\n+--include-macro CXCursor_NoDuplicateAttr\n+--include-macro CXCursor_NonTypeTemplateParameter\n+--include-macro CXCursor_NotImplemented\n+--include-macro CXCursor_NullStmt\n+--include-macro CXCursor_OMPArraySectionExpr\n+--include-macro CXCursor_OMPAtomicDirective\n+--include-macro CXCursor_OMPBarrierDirective\n+--include-macro CXCursor_OMPCancelDirective\n+--include-macro CXCursor_OMPCancellationPointDirective\n+--include-macro CXCursor_OMPCriticalDirective\n+--include-macro CXCursor_OMPDistributeDirective\n+--include-macro CXCursor_OMPDistributeParallelForDirective\n+--include-macro CXCursor_OMPDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPDistributeSimdDirective\n+--include-macro CXCursor_OMPFlushDirective\n+--include-macro CXCursor_OMPForDirective\n+--include-macro CXCursor_OMPForSimdDirective\n+--include-macro CXCursor_OMPMasterDirective\n+--include-macro CXCursor_OMPMasterTaskLoopDirective\n+--include-macro CXCursor_OMPMasterTaskLoopSimdDirective\n+--include-macro CXCursor_OMPOrderedDirective\n+--include-macro CXCursor_OMPParallelDirective\n+--include-macro CXCursor_OMPParallelForDirective\n+--include-macro CXCursor_OMPParallelForSimdDirective\n+--include-macro CXCursor_OMPParallelMasterDirective\n+--include-macro CXCursor_OMPParallelMasterTaskLoopDirective\n+--include-macro CXCursor_OMPParallelMasterTaskLoopSimdDirective\n+--include-macro CXCursor_OMPParallelSectionsDirective\n+--include-macro CXCursor_OMPSectionDirective\n+--include-macro CXCursor_OMPSectionsDirective\n+--include-macro CXCursor_OMPSimdDirective\n+--include-macro CXCursor_OMPSingleDirective\n+--include-macro CXCursor_OMPTargetDataDirective\n+--include-macro CXCursor_OMPTargetDirective\n+--include-macro CXCursor_OMPTargetEnterDataDirective\n+--include-macro CXCursor_OMPTargetExitDataDirective\n+--include-macro CXCursor_OMPTargetParallelDirective\n+--include-macro CXCursor_OMPTargetParallelForDirective\n+--include-macro CXCursor_OMPTargetParallelForSimdDirective\n+--include-macro CXCursor_OMPTargetSimdDirective\n+--include-macro CXCursor_OMPTargetTeamsDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeParallelForDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeSimdDirective\n+--include-macro CXCursor_OMPTargetUpdateDirective\n+--include-macro CXCursor_OMPTaskDirective\n+--include-macro CXCursor_OMPTaskLoopDirective\n+--include-macro CXCursor_OMPTaskLoopSimdDirective\n+--include-macro CXCursor_OMPTaskgroupDirective\n+--include-macro CXCursor_OMPTaskwaitDirective\n+--include-macro CXCursor_OMPTaskyieldDirective\n+--include-macro CXCursor_OMPTeamsDirective\n+--include-macro CXCursor_OMPTeamsDistributeDirective\n+--include-macro CXCursor_OMPTeamsDistributeParallelForDirective\n+--include-macro CXCursor_OMPTeamsDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPTeamsDistributeSimdDirective\n+--include-macro CXCursor_ObjCAtCatchStmt\n+--include-macro CXCursor_ObjCAtFinallyStmt\n+--include-macro CXCursor_ObjCAtSynchronizedStmt\n+--include-macro CXCursor_ObjCAtThrowStmt\n+--include-macro CXCursor_ObjCAtTryStmt\n+--include-macro CXCursor_ObjCAutoreleasePoolStmt\n+--include-macro CXCursor_ObjCAvailabilityCheckExpr\n+--include-macro CXCursor_ObjCBoolLiteralExpr\n+--include-macro CXCursor_ObjCBoxable\n+--include-macro CXCursor_ObjCBridgedCastExpr\n+--include-macro CXCursor_ObjCCategoryDecl\n+--include-macro CXCursor_ObjCCategoryImplDecl\n+--include-macro CXCursor_ObjCClassMethodDecl\n+--include-macro CXCursor_ObjCClassRef\n+--include-macro CXCursor_ObjCDesignatedInitializer\n+--include-macro CXCursor_ObjCDynamicDecl\n+--include-macro CXCursor_ObjCEncodeExpr\n+--include-macro CXCursor_ObjCException\n+--include-macro CXCursor_ObjCExplicitProtocolImpl\n+--include-macro CXCursor_ObjCForCollectionStmt\n+--include-macro CXCursor_ObjCImplementationDecl\n+--include-macro CXCursor_ObjCIndependentClass\n+--include-macro CXCursor_ObjCInstanceMethodDecl\n+--include-macro CXCursor_ObjCInterfaceDecl\n+--include-macro CXCursor_ObjCIvarDecl\n+--include-macro CXCursor_ObjCMessageExpr\n+--include-macro CXCursor_ObjCNSObject\n+--include-macro CXCursor_ObjCPreciseLifetime\n+--include-macro CXCursor_ObjCPropertyDecl\n+--include-macro CXCursor_ObjCProtocolDecl\n+--include-macro CXCursor_ObjCProtocolExpr\n+--include-macro CXCursor_ObjCProtocolRef\n+--include-macro CXCursor_ObjCRequiresSuper\n+--include-macro CXCursor_ObjCReturnsInnerPointer\n+--include-macro CXCursor_ObjCRootClass\n+--include-macro CXCursor_ObjCRuntimeVisible\n+--include-macro CXCursor_ObjCSelectorExpr\n+--include-macro CXCursor_ObjCSelfExpr\n+--include-macro CXCursor_ObjCStringLiteral\n+--include-macro CXCursor_ObjCSubclassingRestricted\n+--include-macro CXCursor_ObjCSuperClassRef\n+--include-macro CXCursor_ObjCSynthesizeDecl\n+--include-macro CXCursor_OverloadCandidate\n+--include-macro CXCursor_OverloadedDeclRef\n+--include-macro CXCursor_PackExpansionExpr\n+--include-macro CXCursor_PackedAttr\n+--include-macro CXCursor_ParenExpr\n+--include-macro CXCursor_ParmDecl\n+--include-macro CXCursor_PreprocessingDirective\n+--include-macro CXCursor_PureAttr\n+--include-macro CXCursor_ReturnStmt\n+--include-macro CXCursor_SEHExceptStmt\n+--include-macro CXCursor_SEHFinallyStmt\n+--include-macro CXCursor_SEHLeaveStmt\n+--include-macro CXCursor_SEHTryStmt\n+--include-macro CXCursor_SizeOfPackExpr\n+--include-macro CXCursor_StaticAssert\n+--include-macro CXCursor_StmtExpr\n+--include-macro CXCursor_StringLiteral\n+--include-macro CXCursor_StructDecl\n+--include-macro CXCursor_SwitchStmt\n+--include-macro CXCursor_TemplateRef\n+--include-macro CXCursor_TemplateTemplateParameter\n+--include-macro CXCursor_TemplateTypeParameter\n+--include-macro CXCursor_TranslationUnit\n+--include-macro CXCursor_TypeAliasDecl\n+--include-macro CXCursor_TypeAliasTemplateDecl\n+--include-macro CXCursor_TypeRef\n+--include-macro CXCursor_TypedefDecl\n+--include-macro CXCursor_UnaryExpr\n+--include-macro CXCursor_UnaryOperator\n+--include-macro CXCursor_UnexposedAttr\n+--include-macro CXCursor_UnexposedDecl\n+--include-macro CXCursor_UnexposedExpr\n+--include-macro CXCursor_UnexposedStmt\n+--include-macro CXCursor_UnionDecl\n+--include-macro CXCursor_UsingDeclaration\n+--include-macro CXCursor_UsingDirective\n+--include-macro CXCursor_VarDecl\n+--include-macro CXCursor_VariableRef\n+--include-macro CXCursor_VisibilityAttr\n+--include-macro CXCursor_WarnUnusedAttr\n+--include-macro CXCursor_WarnUnusedResultAttr\n+--include-macro CXCursor_WhileStmt\n+--include-macro CXDiagnostic_DisplayCategoryId\n+--include-macro CXDiagnostic_DisplayCategoryName\n+--include-macro CXDiagnostic_DisplayColumn\n+--include-macro CXDiagnostic_DisplayOption\n+--include-macro CXDiagnostic_DisplaySourceLocation\n+--include-macro CXDiagnostic_DisplaySourceRanges\n+--include-macro CXDiagnostic_Error\n+--include-macro CXDiagnostic_Fatal\n+--include-macro CXDiagnostic_Ignored\n+--include-macro CXDiagnostic_Note\n+--include-macro CXDiagnostic_Warning\n+--include-macro CXEval_CFStr\n+--include-macro CXEval_Float\n+--include-macro CXEval_Int\n+--include-macro CXEval_ObjCStrLiteral\n+--include-macro CXEval_Other\n+--include-macro CXEval_StrLiteral\n+--include-macro CXEval_UnExposed\n+--include-macro CXGlobalOpt_None\n+--include-macro CXGlobalOpt_ThreadBackgroundPriorityForAll\n+--include-macro CXGlobalOpt_ThreadBackgroundPriorityForEditing\n+--include-macro CXGlobalOpt_ThreadBackgroundPriorityForIndexing\n+--include-macro CXIdxAttr_IBAction\n+--include-macro CXIdxAttr_IBOutlet\n+--include-macro CXIdxAttr_IBOutletCollection\n+--include-macro CXIdxAttr_Unexposed\n+--include-macro CXIdxDeclFlag_Skipped\n+--include-macro CXIdxEntityLang_C\n+--include-macro CXIdxEntityLang_CXX\n+--include-macro CXIdxEntityLang_None\n+--include-macro CXIdxEntityLang_ObjC\n+--include-macro CXIdxEntityLang_Swift\n+--include-macro CXIdxEntityRef_Direct\n+--include-macro CXIdxEntityRef_Implicit\n+--include-macro CXIdxEntity_CXXClass\n+--include-macro CXIdxEntity_CXXConstructor\n+--include-macro CXIdxEntity_CXXConversionFunction\n+--include-macro CXIdxEntity_CXXDestructor\n+--include-macro CXIdxEntity_CXXInstanceMethod\n+--include-macro CXIdxEntity_CXXInterface\n+--include-macro CXIdxEntity_CXXNamespace\n+--include-macro CXIdxEntity_CXXNamespaceAlias\n+--include-macro CXIdxEntity_CXXStaticMethod\n+--include-macro CXIdxEntity_CXXStaticVariable\n+--include-macro CXIdxEntity_CXXTypeAlias\n+--include-macro CXIdxEntity_Enum\n+--include-macro CXIdxEntity_EnumConstant\n+--include-macro CXIdxEntity_Field\n+--include-macro CXIdxEntity_Function\n+--include-macro CXIdxEntity_NonTemplate\n+--include-macro CXIdxEntity_ObjCCategory\n+--include-macro CXIdxEntity_ObjCClass\n+--include-macro CXIdxEntity_ObjCClassMethod\n+--include-macro CXIdxEntity_ObjCInstanceMethod\n+--include-macro CXIdxEntity_ObjCIvar\n+--include-macro CXIdxEntity_ObjCProperty\n+--include-macro CXIdxEntity_ObjCProtocol\n+--include-macro CXIdxEntity_Struct\n+--include-macro CXIdxEntity_Template\n+--include-macro CXIdxEntity_TemplatePartialSpecialization\n+--include-macro CXIdxEntity_TemplateSpecialization\n+--include-macro CXIdxEntity_Typedef\n+--include-macro CXIdxEntity_Unexposed\n+--include-macro CXIdxEntity_Union\n+--include-macro CXIdxEntity_Variable\n+--include-macro CXIdxObjCContainer_ForwardRef\n+--include-macro CXIdxObjCContainer_Implementation\n+--include-macro CXIdxObjCContainer_Interface\n+--include-macro CXIndexOpt_IndexFunctionLocalSymbols\n+--include-macro CXIndexOpt_IndexImplicitTemplateInstantiations\n+--include-macro CXIndexOpt_None\n+--include-macro CXIndexOpt_SkipParsedBodiesInSession\n+--include-macro CXIndexOpt_SuppressRedundantRefs\n+--include-macro CXIndexOpt_SuppressWarnings\n+--include-macro CXLanguage_C\n+--include-macro CXLanguage_CPlusPlus\n+--include-macro CXLanguage_Invalid\n+--include-macro CXLanguage_ObjC\n+--include-macro CXLinkage_External\n+--include-macro CXLinkage_Internal\n+--include-macro CXLinkage_Invalid\n+--include-macro CXLinkage_NoLinkage\n+--include-macro CXLinkage_UniqueExternal\n+--include-macro CXLoadDiag_CannotLoad\n+--include-macro CXLoadDiag_InvalidFile\n+--include-macro CXLoadDiag_None\n+--include-macro CXLoadDiag_Unknown\n+--include-macro CXNameRange_WantQualifier\n+--include-macro CXNameRange_WantSinglePiece\n+--include-macro CXNameRange_WantTemplateArgs\n+--include-macro CXObjCDeclQualifier_Bycopy\n+--include-macro CXObjCDeclQualifier_Byref\n+--include-macro CXObjCDeclQualifier_In\n+--include-macro CXObjCDeclQualifier_Inout\n+--include-macro CXObjCDeclQualifier_None\n+--include-macro CXObjCDeclQualifier_Oneway\n+--include-macro CXObjCDeclQualifier_Out\n+--include-macro CXObjCPropertyAttr_assign\n+--include-macro CXObjCPropertyAttr_atomic\n+--include-macro CXObjCPropertyAttr_class\n+--include-macro CXObjCPropertyAttr_copy\n+--include-macro CXObjCPropertyAttr_getter\n+--include-macro CXObjCPropertyAttr_noattr\n+--include-macro CXObjCPropertyAttr_nonatomic\n+--include-macro CXObjCPropertyAttr_readonly\n+--include-macro CXObjCPropertyAttr_readwrite\n+--include-macro CXObjCPropertyAttr_retain\n+--include-macro CXObjCPropertyAttr_setter\n+--include-macro CXObjCPropertyAttr_strong\n+--include-macro CXObjCPropertyAttr_unsafe_unretained\n+--include-macro CXObjCPropertyAttr_weak\n+--include-macro CXPrintingPolicy_Alignof\n+--include-macro CXPrintingPolicy_AnonymousTagLocations\n+--include-macro CXPrintingPolicy_Bool\n+--include-macro CXPrintingPolicy_ConstantArraySizeAsWritten\n+--include-macro CXPrintingPolicy_ConstantsAsWritten\n+--include-macro CXPrintingPolicy_FullyQualifiedName\n+--include-macro CXPrintingPolicy_Half\n+--include-macro CXPrintingPolicy_IncludeNewlines\n+--include-macro CXPrintingPolicy_IncludeTagDefinition\n+--include-macro CXPrintingPolicy_Indentation\n+--include-macro CXPrintingPolicy_LastProperty\n+--include-macro CXPrintingPolicy_MSVCFormatting\n+--include-macro CXPrintingPolicy_MSWChar\n+--include-macro CXPrintingPolicy_PolishForDeclaration\n+--include-macro CXPrintingPolicy_Restrict\n+--include-macro CXPrintingPolicy_SuppressImplicitBase\n+--include-macro CXPrintingPolicy_SuppressInitializers\n+--include-macro CXPrintingPolicy_SuppressLifetimeQualifiers\n+--include-macro CXPrintingPolicy_SuppressScope\n+--include-macro CXPrintingPolicy_SuppressSpecifiers\n+--include-macro CXPrintingPolicy_SuppressStrongLifetime\n+--include-macro CXPrintingPolicy_SuppressTagKeyword\n+--include-macro CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors\n+--include-macro CXPrintingPolicy_SuppressUnwrittenScope\n+--include-macro CXPrintingPolicy_TerseOutput\n+--include-macro CXPrintingPolicy_UnderscoreAlignof\n+--include-macro CXPrintingPolicy_UseVoidForZeroParams\n+--include-macro CXRefQualifier_LValue\n+--include-macro CXRefQualifier_None\n+--include-macro CXRefQualifier_RValue\n+--include-macro CXReparse_None\n+--include-macro CXResult_Invalid\n+--include-macro CXResult_Success\n+--include-macro CXResult_VisitBreak\n+--include-macro CXSaveError_InvalidTU\n+--include-macro CXSaveError_None\n+--include-macro CXSaveError_TranslationErrors\n+--include-macro CXSaveError_Unknown\n+--include-macro CXSaveTranslationUnit_None\n+--include-macro CXSymbolRole_AddressOf\n+--include-macro CXSymbolRole_Call\n+--include-macro CXSymbolRole_Declaration\n+--include-macro CXSymbolRole_Definition\n+--include-macro CXSymbolRole_Dynamic\n+--include-macro CXSymbolRole_Implicit\n+--include-macro CXSymbolRole_None\n+--include-macro CXSymbolRole_Read\n+--include-macro CXSymbolRole_Reference\n+--include-macro CXSymbolRole_Write\n+--include-macro CXTLS_Dynamic\n+--include-macro CXTLS_None\n+--include-macro CXTLS_Static\n+--include-macro CXTUResourceUsage_AST\n+--include-macro CXTUResourceUsage_AST_SideTables\n+--include-macro CXTUResourceUsage_ExternalASTSource_Membuffer_MMap\n+--include-macro CXTUResourceUsage_ExternalASTSource_Membuffer_Malloc\n+--include-macro CXTUResourceUsage_First\n+--include-macro CXTUResourceUsage_GlobalCompletionResults\n+--include-macro CXTUResourceUsage_Identifiers\n+--include-macro CXTUResourceUsage_Last\n+--include-macro CXTUResourceUsage_MEMORY_IN_BYTES_BEGIN\n+--include-macro CXTUResourceUsage_MEMORY_IN_BYTES_END\n+--include-macro CXTUResourceUsage_PreprocessingRecord\n+--include-macro CXTUResourceUsage_Preprocessor\n+--include-macro CXTUResourceUsage_Preprocessor_HeaderSearch\n+--include-macro CXTUResourceUsage_Selectors\n+--include-macro CXTUResourceUsage_SourceManagerContentCache\n+--include-macro CXTUResourceUsage_SourceManager_DataStructures\n+--include-macro CXTUResourceUsage_SourceManager_Membuffer_MMap\n+--include-macro CXTUResourceUsage_SourceManager_Membuffer_Malloc\n+--include-macro CXTemplateArgumentKind_Declaration\n+--include-macro CXTemplateArgumentKind_Expression\n+--include-macro CXTemplateArgumentKind_Integral\n+--include-macro CXTemplateArgumentKind_Invalid\n+--include-macro CXTemplateArgumentKind_Null\n+--include-macro CXTemplateArgumentKind_NullPtr\n+--include-macro CXTemplateArgumentKind_Pack\n+--include-macro CXTemplateArgumentKind_Template\n+--include-macro CXTemplateArgumentKind_TemplateExpansion\n+--include-macro CXTemplateArgumentKind_Type\n+--include-macro CXToken_Comment\n+--include-macro CXToken_Identifier\n+--include-macro CXToken_Keyword\n+--include-macro CXToken_Literal\n+--include-macro CXToken_Punctuation\n+--include-macro CXTranslationUnit_CXXChainedPCH\n+--include-macro CXTranslationUnit_CacheCompletionResults\n+--include-macro CXTranslationUnit_CreatePreambleOnFirstParse\n+--include-macro CXTranslationUnit_DetailedPreprocessingRecord\n+--include-macro CXTranslationUnit_ForSerialization\n+--include-macro CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles\n+--include-macro CXTranslationUnit_IncludeAttributedTypes\n+--include-macro CXTranslationUnit_IncludeBriefCommentsInCodeCompletion\n+--include-macro CXTranslationUnit_Incomplete\n+--include-macro CXTranslationUnit_KeepGoing\n+--include-macro CXTranslationUnit_LimitSkipFunctionBodiesToPreamble\n+--include-macro CXTranslationUnit_None\n+--include-macro CXTranslationUnit_PrecompiledPreamble\n+--include-macro CXTranslationUnit_RetainExcludedConditionalBlocks\n+--include-macro CXTranslationUnit_SingleFileParse\n+--include-macro CXTranslationUnit_SkipFunctionBodies\n+--include-macro CXTranslationUnit_VisitImplicitAttributes\n+--include-macro CXTypeLayoutError_Dependent\n+--include-macro CXTypeLayoutError_Incomplete\n+--include-macro CXTypeLayoutError_Invalid\n+--include-macro CXTypeLayoutError_InvalidFieldName\n+--include-macro CXTypeLayoutError_NotConstantSize\n+--include-macro CXTypeLayoutError_Undeduced\n+--include-macro CXTypeNullability_Invalid\n+--include-macro CXTypeNullability_NonNull\n+--include-macro CXTypeNullability_Nullable\n+--include-macro CXTypeNullability_Unspecified\n+--include-macro CXType_Accum\n+--include-macro CXType_Attributed\n+--include-macro CXType_Auto\n+--include-macro CXType_BlockPointer\n+--include-macro CXType_Bool\n+--include-macro CXType_Char16\n+--include-macro CXType_Char32\n+--include-macro CXType_Char_S\n+--include-macro CXType_Char_U\n+--include-macro CXType_Complex\n+--include-macro CXType_ConstantArray\n+--include-macro CXType_Dependent\n+--include-macro CXType_DependentSizedArray\n+--include-macro CXType_Double\n+--include-macro CXType_Elaborated\n+--include-macro CXType_Enum\n+--include-macro CXType_ExtVector\n+--include-macro CXType_FirstBuiltin\n+--include-macro CXType_Float\n+--include-macro CXType_Float128\n+--include-macro CXType_Float16\n+--include-macro CXType_FunctionNoProto\n+--include-macro CXType_FunctionProto\n+--include-macro CXType_Half\n+--include-macro CXType_IncompleteArray\n+--include-macro CXType_Int\n+--include-macro CXType_Int128\n+--include-macro CXType_Invalid\n+--include-macro CXType_LValueReference\n+--include-macro CXType_LastBuiltin\n+--include-macro CXType_Long\n+--include-macro CXType_LongAccum\n+--include-macro CXType_LongDouble\n+--include-macro CXType_LongLong\n+--include-macro CXType_MemberPointer\n+--include-macro CXType_NullPtr\n+--include-macro CXType_OCLEvent\n+--include-macro CXType_OCLImage1dArrayRO\n+--include-macro CXType_OCLImage1dArrayRW\n+--include-macro CXType_OCLImage1dArrayWO\n+--include-macro CXType_OCLImage1dBufferRO\n+--include-macro CXType_OCLImage1dBufferRW\n+--include-macro CXType_OCLImage1dBufferWO\n+--include-macro CXType_OCLImage1dRO\n+--include-macro CXType_OCLImage1dRW\n+--include-macro CXType_OCLImage1dWO\n+--include-macro CXType_OCLImage2dArrayDepthRO\n+--include-macro CXType_OCLImage2dArrayDepthRW\n+--include-macro CXType_OCLImage2dArrayDepthWO\n+--include-macro CXType_OCLImage2dArrayMSAADepthRO\n+--include-macro CXType_OCLImage2dArrayMSAADepthRW\n+--include-macro CXType_OCLImage2dArrayMSAADepthWO\n+--include-macro CXType_OCLImage2dArrayMSAARO\n+--include-macro CXType_OCLImage2dArrayMSAARW\n+--include-macro CXType_OCLImage2dArrayMSAAWO\n+--include-macro CXType_OCLImage2dArrayRO\n+--include-macro CXType_OCLImage2dArrayRW\n+--include-macro CXType_OCLImage2dArrayWO\n+--include-macro CXType_OCLImage2dDepthRO\n+--include-macro CXType_OCLImage2dDepthRW\n+--include-macro CXType_OCLImage2dDepthWO\n+--include-macro CXType_OCLImage2dMSAADepthRO\n+--include-macro CXType_OCLImage2dMSAADepthRW\n+--include-macro CXType_OCLImage2dMSAADepthWO\n+--include-macro CXType_OCLImage2dMSAARO\n+--include-macro CXType_OCLImage2dMSAARW\n+--include-macro CXType_OCLImage2dMSAAWO\n+--include-macro CXType_OCLImage2dRO\n+--include-macro CXType_OCLImage2dRW\n+--include-macro CXType_OCLImage2dWO\n+--include-macro CXType_OCLImage3dRO\n+--include-macro CXType_OCLImage3dRW\n+--include-macro CXType_OCLImage3dWO\n+--include-macro CXType_OCLIntelSubgroupAVCImeDualRefStreamin\n+--include-macro CXType_OCLIntelSubgroupAVCImePayload\n+--include-macro CXType_OCLIntelSubgroupAVCImeResult\n+--include-macro CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout\n+--include-macro CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout\n+--include-macro CXType_OCLIntelSubgroupAVCImeSingleRefStreamin\n+--include-macro CXType_OCLIntelSubgroupAVCMcePayload\n+--include-macro CXType_OCLIntelSubgroupAVCMceResult\n+--include-macro CXType_OCLIntelSubgroupAVCRefPayload\n+--include-macro CXType_OCLIntelSubgroupAVCRefResult\n+--include-macro CXType_OCLIntelSubgroupAVCSicPayload\n+--include-macro CXType_OCLIntelSubgroupAVCSicResult\n+--include-macro CXType_OCLQueue\n+--include-macro CXType_OCLReserveID\n+--include-macro CXType_OCLSampler\n+--include-macro CXType_ObjCClass\n+--include-macro CXType_ObjCId\n+--include-macro CXType_ObjCInterface\n+--include-macro CXType_ObjCObject\n+--include-macro CXType_ObjCObjectPointer\n+--include-macro CXType_ObjCSel\n+--include-macro CXType_ObjCTypeParam\n+--include-macro CXType_Overload\n+--include-macro CXType_Pipe\n+--include-macro CXType_Pointer\n+--include-macro CXType_RValueReference\n+--include-macro CXType_Record\n+--include-macro CXType_SChar\n+--include-macro CXType_Short\n+--include-macro CXType_ShortAccum\n+--include-macro CXType_Typedef\n+--include-macro CXType_UAccum\n+--include-macro CXType_UChar\n+--include-macro CXType_UInt\n+--include-macro CXType_UInt128\n+--include-macro CXType_ULong\n+--include-macro CXType_ULongAccum\n+--include-macro CXType_ULongLong\n+--include-macro CXType_UShort\n+--include-macro CXType_UShortAccum\n+--include-macro CXType_Unexposed\n+--include-macro CXType_VariableArray\n+--include-macro CXType_Vector\n+--include-macro CXType_Void\n+--include-macro CXType_WChar\n+--include-macro CXVisibility_Default\n+--include-macro CXVisibility_Hidden\n+--include-macro CXVisibility_Invalid\n+--include-macro CXVisibility_Protected\n+--include-macro CXVisit_Break\n+--include-macro CXVisit_Continue\n+--include-macro CX_CXXInvalidAccessSpecifier\n+--include-macro CX_CXXPrivate\n+--include-macro CX_CXXProtected\n+--include-macro CX_CXXPublic\n+--include-macro CX_SC_Auto\n+--include-macro CX_SC_Extern\n+--include-macro CX_SC_Invalid\n+--include-macro CX_SC_None\n+--include-macro CX_SC_OpenCLWorkGroupLocal\n+--include-macro CX_SC_PrivateExtern\n+--include-macro CX_SC_Register\n+--include-macro CX_SC_Static\n+--include-struct CXCursorAndRangeVisitor\n+--include-struct CXPlatformAvailability\n+--include-struct CXTUResourceUsage\n+--include-struct CXTUResourceUsageEntry\n+--include-struct CXUnsavedFile\n+--include-struct CXVersion\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/clang.full.symbols","additions":1556,"deletions":0,"binary":false,"changes":1556,"status":"added"},{"patch":"@@ -0,0 +1,624 @@\n+###\n+\n+--include-macro CXError_ASTReadError\n+--include-macro CXError_Crashed\n+--include-macro CXError_Failure\n+--include-macro CXError_InvalidArguments\n+--include-macro CXError_Success\n+\n+###\n+\n+--include-function clang_disposeString\n+--include-function clang_getCString\n+\n+###\n+\n+--include-typedef CXCursorVisitor\n+--include-typedef CXIndex\n+--include-typedef CXToken\n+--include-typedef CXTranslationUnit\n+--include-typedef CXType\n+--include-struct CXUnsavedFile\n+--include-macro CXCallingConv_AAPCS\n+--include-macro CXCallingConv_AAPCS_VFP\n+--include-macro CXCallingConv_AArch64VectorCall\n+--include-macro CXCallingConv_C\n+--include-macro CXCallingConv_Default\n+--include-macro CXCallingConv_IntelOclBicc\n+--include-macro CXCallingConv_Invalid\n+--include-macro CXCallingConv_PreserveAll\n+--include-macro CXCallingConv_PreserveMost\n+--include-macro CXCallingConv_Swift\n+--include-macro CXCallingConv_Unexposed\n+--include-macro CXCallingConv_Win64\n+--include-macro CXCallingConv_X86FastCall\n+--include-macro CXCallingConv_X86Pascal\n+--include-macro CXCallingConv_X86RegCall\n+--include-macro CXCallingConv_X86StdCall\n+--include-macro CXCallingConv_X86ThisCall\n+--include-macro CXCallingConv_X86VectorCall\n+--include-macro CXCallingConv_X86_64SysV\n+--include-macro CXCallingConv_X86_64Win64\n+--include-macro CXChildVisit_Break\n+--include-macro CXChildVisit_Continue\n+--include-macro CXChildVisit_Recurse\n+--include-macro CXCursor_AddrLabelExpr\n+--include-macro CXCursor_AlignedAttr\n+--include-macro CXCursor_AnnotateAttr\n+--include-macro CXCursor_ArraySubscriptExpr\n+--include-macro CXCursor_AsmLabelAttr\n+--include-macro CXCursor_AsmStmt\n+--include-macro CXCursor_BinaryOperator\n+--include-macro CXCursor_BlockExpr\n+--include-macro CXCursor_BreakStmt\n+--include-macro CXCursor_BuiltinBitCastExpr\n+--include-macro CXCursor_CStyleCastExpr\n+--include-macro CXCursor_CUDAConstantAttr\n+--include-macro CXCursor_CUDADeviceAttr\n+--include-macro CXCursor_CUDAGlobalAttr\n+--include-macro CXCursor_CUDAHostAttr\n+--include-macro CXCursor_CUDASharedAttr\n+--include-macro CXCursor_CXXAccessSpecifier\n+--include-macro CXCursor_CXXBaseSpecifier\n+--include-macro CXCursor_CXXBoolLiteralExpr\n+--include-macro CXCursor_CXXCatchStmt\n+--include-macro CXCursor_CXXConstCastExpr\n+--include-macro CXCursor_CXXDeleteExpr\n+--include-macro CXCursor_CXXDynamicCastExpr\n+--include-macro CXCursor_CXXFinalAttr\n+--include-macro CXCursor_CXXForRangeStmt\n+--include-macro CXCursor_CXXFunctionalCastExpr\n+--include-macro CXCursor_CXXMethod\n+--include-macro CXCursor_CXXNewExpr\n+--include-macro CXCursor_CXXNullPtrLiteralExpr\n+--include-macro CXCursor_CXXOverrideAttr\n+--include-macro CXCursor_CXXReinterpretCastExpr\n+--include-macro CXCursor_CXXStaticCastExpr\n+--include-macro CXCursor_CXXThisExpr\n+--include-macro CXCursor_CXXThrowExpr\n+--include-macro CXCursor_CXXTryStmt\n+--include-macro CXCursor_CXXTypeidExpr\n+--include-macro CXCursor_CallExpr\n+--include-macro CXCursor_CaseStmt\n+--include-macro CXCursor_CharacterLiteral\n+--include-macro CXCursor_ClassDecl\n+--include-macro CXCursor_ClassTemplate\n+--include-macro CXCursor_ClassTemplatePartialSpecialization\n+--include-macro CXCursor_CompoundAssignOperator\n+--include-macro CXCursor_CompoundLiteralExpr\n+--include-macro CXCursor_CompoundStmt\n+--include-macro CXCursor_ConditionalOperator\n+--include-macro CXCursor_ConstAttr\n+--include-macro CXCursor_Constructor\n+--include-macro CXCursor_ContinueStmt\n+--include-macro CXCursor_ConvergentAttr\n+--include-macro CXCursor_ConversionFunction\n+--include-macro CXCursor_DLLExport\n+--include-macro CXCursor_DLLImport\n+--include-macro CXCursor_DeclRefExpr\n+--include-macro CXCursor_DeclStmt\n+--include-macro CXCursor_DefaultStmt\n+--include-macro CXCursor_Destructor\n+--include-macro CXCursor_DoStmt\n+--include-macro CXCursor_EnumConstantDecl\n+--include-macro CXCursor_EnumDecl\n+--include-macro CXCursor_ExceptionSpecificationKind_BasicNoexcept\n+--include-macro CXCursor_ExceptionSpecificationKind_ComputedNoexcept\n+--include-macro CXCursor_ExceptionSpecificationKind_Dynamic\n+--include-macro CXCursor_ExceptionSpecificationKind_DynamicNone\n+--include-macro CXCursor_ExceptionSpecificationKind_MSAny\n+--include-macro CXCursor_ExceptionSpecificationKind_NoThrow\n+--include-macro CXCursor_ExceptionSpecificationKind_None\n+--include-macro CXCursor_ExceptionSpecificationKind_Unevaluated\n+--include-macro CXCursor_ExceptionSpecificationKind_Uninstantiated\n+--include-macro CXCursor_ExceptionSpecificationKind_Unparsed\n+--include-macro CXCursor_FieldDecl\n+--include-macro CXCursor_FirstAttr\n+--include-macro CXCursor_FirstDecl\n+--include-macro CXCursor_FirstExpr\n+--include-macro CXCursor_FirstExtraDecl\n+--include-macro CXCursor_FirstInvalid\n+--include-macro CXCursor_FirstPreprocessing\n+--include-macro CXCursor_FirstRef\n+--include-macro CXCursor_FirstStmt\n+--include-macro CXCursor_FixedPointLiteral\n+--include-macro CXCursor_FlagEnum\n+--include-macro CXCursor_FloatingLiteral\n+--include-macro CXCursor_ForStmt\n+--include-macro CXCursor_FriendDecl\n+--include-macro CXCursor_FunctionDecl\n+--include-macro CXCursor_FunctionTemplate\n+--include-macro CXCursor_GCCAsmStmt\n+--include-macro CXCursor_GNUNullExpr\n+--include-macro CXCursor_GenericSelectionExpr\n+--include-macro CXCursor_GotoStmt\n+--include-macro CXCursor_IBActionAttr\n+--include-macro CXCursor_IBOutletAttr\n+--include-macro CXCursor_IBOutletCollectionAttr\n+--include-macro CXCursor_IfStmt\n+--include-macro CXCursor_ImaginaryLiteral\n+--include-macro CXCursor_InclusionDirective\n+--include-macro CXCursor_IndirectGotoStmt\n+--include-macro CXCursor_InitListExpr\n+--include-macro CXCursor_IntegerLiteral\n+--include-macro CXCursor_InvalidCode\n+--include-macro CXCursor_InvalidFile\n+--include-macro CXCursor_LabelRef\n+--include-macro CXCursor_LabelStmt\n+--include-macro CXCursor_LambdaExpr\n+--include-macro CXCursor_LastAttr\n+--include-macro CXCursor_LastDecl\n+--include-macro CXCursor_LastExpr\n+--include-macro CXCursor_LastExtraDecl\n+--include-macro CXCursor_LastInvalid\n+--include-macro CXCursor_LastPreprocessing\n+--include-macro CXCursor_LastRef\n+--include-macro CXCursor_LastStmt\n+--include-macro CXCursor_LinkageSpec\n+--include-macro CXCursor_MSAsmStmt\n+--include-macro CXCursor_MacroDefinition\n+--include-macro CXCursor_MacroExpansion\n+--include-macro CXCursor_MacroInstantiation\n+--include-macro CXCursor_MemberRef\n+--include-macro CXCursor_MemberRefExpr\n+--include-macro CXCursor_ModuleImportDecl\n+--include-macro CXCursor_NSConsumed\n+--include-macro CXCursor_NSConsumesSelf\n+--include-macro CXCursor_NSReturnsAutoreleased\n+--include-macro CXCursor_NSReturnsNotRetained\n+--include-macro CXCursor_NSReturnsRetained\n+--include-macro CXCursor_Namespace\n+--include-macro CXCursor_NamespaceAlias\n+--include-macro CXCursor_NamespaceRef\n+--include-macro CXCursor_NoDeclFound\n+--include-macro CXCursor_NoDuplicateAttr\n+--include-macro CXCursor_NonTypeTemplateParameter\n+--include-macro CXCursor_NotImplemented\n+--include-macro CXCursor_NullStmt\n+--include-macro CXCursor_OMPArraySectionExpr\n+--include-macro CXCursor_OMPAtomicDirective\n+--include-macro CXCursor_OMPBarrierDirective\n+--include-macro CXCursor_OMPCancelDirective\n+--include-macro CXCursor_OMPCancellationPointDirective\n+--include-macro CXCursor_OMPCriticalDirective\n+--include-macro CXCursor_OMPDistributeDirective\n+--include-macro CXCursor_OMPDistributeParallelForDirective\n+--include-macro CXCursor_OMPDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPDistributeSimdDirective\n+--include-macro CXCursor_OMPFlushDirective\n+--include-macro CXCursor_OMPForDirective\n+--include-macro CXCursor_OMPForSimdDirective\n+--include-macro CXCursor_OMPMasterDirective\n+--include-macro CXCursor_OMPMasterTaskLoopDirective\n+--include-macro CXCursor_OMPMasterTaskLoopSimdDirective\n+--include-macro CXCursor_OMPOrderedDirective\n+--include-macro CXCursor_OMPParallelDirective\n+--include-macro CXCursor_OMPParallelForDirective\n+--include-macro CXCursor_OMPParallelForSimdDirective\n+--include-macro CXCursor_OMPParallelMasterTaskLoopDirective\n+--include-macro CXCursor_OMPParallelMasterTaskLoopSimdDirective\n+--include-macro CXCursor_OMPParallelSectionsDirective\n+--include-macro CXCursor_OMPSectionDirective\n+--include-macro CXCursor_OMPSectionsDirective\n+--include-macro CXCursor_OMPSimdDirective\n+--include-macro CXCursor_OMPSingleDirective\n+--include-macro CXCursor_OMPTargetDataDirective\n+--include-macro CXCursor_OMPTargetDirective\n+--include-macro CXCursor_OMPTargetEnterDataDirective\n+--include-macro CXCursor_OMPTargetExitDataDirective\n+--include-macro CXCursor_OMPTargetParallelDirective\n+--include-macro CXCursor_OMPTargetParallelForDirective\n+--include-macro CXCursor_OMPTargetParallelForSimdDirective\n+--include-macro CXCursor_OMPTargetSimdDirective\n+--include-macro CXCursor_OMPTargetTeamsDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeParallelForDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPTargetTeamsDistributeSimdDirective\n+--include-macro CXCursor_OMPTargetUpdateDirective\n+--include-macro CXCursor_OMPTaskDirective\n+--include-macro CXCursor_OMPTaskLoopDirective\n+--include-macro CXCursor_OMPTaskLoopSimdDirective\n+--include-macro CXCursor_OMPTaskgroupDirective\n+--include-macro CXCursor_OMPTaskwaitDirective\n+--include-macro CXCursor_OMPTaskyieldDirective\n+--include-macro CXCursor_OMPTeamsDirective\n+--include-macro CXCursor_OMPTeamsDistributeDirective\n+--include-macro CXCursor_OMPTeamsDistributeParallelForDirective\n+--include-macro CXCursor_OMPTeamsDistributeParallelForSimdDirective\n+--include-macro CXCursor_OMPTeamsDistributeSimdDirective\n+--include-macro CXCursor_ObjCAtCatchStmt\n+--include-macro CXCursor_ObjCAtFinallyStmt\n+--include-macro CXCursor_ObjCAtSynchronizedStmt\n+--include-macro CXCursor_ObjCAtThrowStmt\n+--include-macro CXCursor_ObjCAtTryStmt\n+--include-macro CXCursor_ObjCAutoreleasePoolStmt\n+--include-macro CXCursor_ObjCAvailabilityCheckExpr\n+--include-macro CXCursor_ObjCBoolLiteralExpr\n+--include-macro CXCursor_ObjCBoxable\n+--include-macro CXCursor_ObjCBridgedCastExpr\n+--include-macro CXCursor_ObjCCategoryDecl\n+--include-macro CXCursor_ObjCCategoryImplDecl\n+--include-macro CXCursor_ObjCClassMethodDecl\n+--include-macro CXCursor_ObjCClassRef\n+--include-macro CXCursor_ObjCDesignatedInitializer\n+--include-macro CXCursor_ObjCDynamicDecl\n+--include-macro CXCursor_ObjCEncodeExpr\n+--include-macro CXCursor_ObjCException\n+--include-macro CXCursor_ObjCExplicitProtocolImpl\n+--include-macro CXCursor_ObjCForCollectionStmt\n+--include-macro CXCursor_ObjCImplementationDecl\n+--include-macro CXCursor_ObjCIndependentClass\n+--include-macro CXCursor_ObjCInstanceMethodDecl\n+--include-macro CXCursor_ObjCInterfaceDecl\n+--include-macro CXCursor_ObjCIvarDecl\n+--include-macro CXCursor_ObjCMessageExpr\n+--include-macro CXCursor_ObjCNSObject\n+--include-macro CXCursor_ObjCPreciseLifetime\n+--include-macro CXCursor_ObjCPropertyDecl\n+--include-macro CXCursor_ObjCProtocolDecl\n+--include-macro CXCursor_ObjCProtocolExpr\n+--include-macro CXCursor_ObjCProtocolRef\n+--include-macro CXCursor_ObjCRequiresSuper\n+--include-macro CXCursor_ObjCReturnsInnerPointer\n+--include-macro CXCursor_ObjCRootClass\n+--include-macro CXCursor_ObjCRuntimeVisible\n+--include-macro CXCursor_ObjCSelectorExpr\n+--include-macro CXCursor_ObjCSelfExpr\n+--include-macro CXCursor_ObjCStringLiteral\n+--include-macro CXCursor_ObjCSubclassingRestricted\n+--include-macro CXCursor_ObjCSuperClassRef\n+--include-macro CXCursor_ObjCSynthesizeDecl\n+--include-macro CXCursor_OverloadCandidate\n+--include-macro CXCursor_OverloadedDeclRef\n+--include-macro CXCursor_PackExpansionExpr\n+--include-macro CXCursor_PackedAttr\n+--include-macro CXCursor_ParenExpr\n+--include-macro CXCursor_ParmDecl\n+--include-macro CXCursor_PreprocessingDirective\n+--include-macro CXCursor_PureAttr\n+--include-macro CXCursor_ReturnStmt\n+--include-macro CXCursor_SEHExceptStmt\n+--include-macro CXCursor_SEHFinallyStmt\n+--include-macro CXCursor_SEHLeaveStmt\n+--include-macro CXCursor_SEHTryStmt\n+--include-macro CXCursor_SizeOfPackExpr\n+--include-macro CXCursor_StaticAssert\n+--include-macro CXCursor_StmtExpr\n+--include-macro CXCursor_StringLiteral\n+--include-macro CXCursor_StructDecl\n+--include-macro CXCursor_SwitchStmt\n+--include-macro CXCursor_TemplateRef\n+--include-macro CXCursor_TemplateTemplateParameter\n+--include-macro CXCursor_TemplateTypeParameter\n+--include-macro CXCursor_TranslationUnit\n+--include-macro CXCursor_TypeAliasDecl\n+--include-macro CXCursor_TypeAliasTemplateDecl\n+--include-macro CXCursor_TypeRef\n+--include-macro CXCursor_TypedefDecl\n+--include-macro CXCursor_UnaryExpr\n+--include-macro CXCursor_UnaryOperator\n+--include-macro CXCursor_UnexposedAttr\n+--include-macro CXCursor_UnexposedDecl\n+--include-macro CXCursor_UnexposedExpr\n+--include-macro CXCursor_UnexposedStmt\n+--include-macro CXCursor_UnionDecl\n+--include-macro CXCursor_UsingDeclaration\n+--include-macro CXCursor_UsingDirective\n+--include-macro CXCursor_VarDecl\n+--include-macro CXCursor_VariableRef\n+--include-macro CXCursor_VisibilityAttr\n+--include-macro CXCursor_WarnUnusedAttr\n+--include-macro CXCursor_WarnUnusedResultAttr\n+--include-macro CXCursor_WhileStmt\n+--include-macro CXDiagnostic_DisplayCategoryId\n+--include-macro CXDiagnostic_DisplayCategoryName\n+--include-macro CXDiagnostic_DisplayColumn\n+--include-macro CXDiagnostic_DisplayOption\n+--include-macro CXDiagnostic_DisplaySourceLocation\n+--include-macro CXDiagnostic_DisplaySourceRanges\n+--include-macro CXDiagnostic_Error\n+--include-macro CXDiagnostic_Fatal\n+--include-macro CXDiagnostic_Ignored\n+--include-macro CXDiagnostic_Note\n+--include-macro CXDiagnostic_Warning\n+--include-macro CXLanguage_C\n+--include-macro CXLanguage_CPlusPlus\n+--include-macro CXLanguage_Invalid\n+--include-macro CXLanguage_ObjC\n+--include-macro CXPrintingPolicy_Alignof\n+--include-macro CXPrintingPolicy_AnonymousTagLocations\n+--include-macro CXPrintingPolicy_Bool\n+--include-macro CXPrintingPolicy_ConstantArraySizeAsWritten\n+--include-macro CXPrintingPolicy_ConstantsAsWritten\n+--include-macro CXPrintingPolicy_FullyQualifiedName\n+--include-macro CXPrintingPolicy_Half\n+--include-macro CXPrintingPolicy_IncludeNewlines\n+--include-macro CXPrintingPolicy_IncludeTagDefinition\n+--include-macro CXPrintingPolicy_Indentation\n+--include-macro CXPrintingPolicy_LastProperty\n+--include-macro CXPrintingPolicy_MSVCFormatting\n+--include-macro CXPrintingPolicy_MSWChar\n+--include-macro CXPrintingPolicy_PolishForDeclaration\n+--include-macro CXPrintingPolicy_Restrict\n+--include-macro CXPrintingPolicy_SuppressImplicitBase\n+--include-macro CXPrintingPolicy_SuppressInitializers\n+--include-macro CXPrintingPolicy_SuppressLifetimeQualifiers\n+--include-macro CXPrintingPolicy_SuppressScope\n+--include-macro CXPrintingPolicy_SuppressSpecifiers\n+--include-macro CXPrintingPolicy_SuppressStrongLifetime\n+--include-macro CXPrintingPolicy_SuppressTagKeyword\n+--include-macro CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors\n+--include-macro CXPrintingPolicy_SuppressUnwrittenScope\n+--include-macro CXPrintingPolicy_TerseOutput\n+--include-macro CXPrintingPolicy_UnderscoreAlignof\n+--include-macro CXPrintingPolicy_UseVoidForZeroParams\n+--include-macro CXReparse_None\n+--include-macro CXResult_Invalid\n+--include-macro CXResult_Success\n+--include-macro CXResult_VisitBreak\n+--include-macro CXSaveError_InvalidTU\n+--include-macro CXSaveError_None\n+--include-macro CXSaveError_TranslationErrors\n+--include-macro CXSaveError_Unknown\n+--include-macro CXSaveTranslationUnit_None\n+--include-macro CXToken_Comment\n+--include-macro CXToken_Identifier\n+--include-macro CXToken_Keyword\n+--include-macro CXToken_Literal\n+--include-macro CXToken_Punctuation\n+--include-macro CXTranslationUnit_CXXChainedPCH\n+--include-macro CXTranslationUnit_CacheCompletionResults\n+--include-macro CXTranslationUnit_CreatePreambleOnFirstParse\n+--include-macro CXTranslationUnit_DetailedPreprocessingRecord\n+--include-macro CXTranslationUnit_ForSerialization\n+--include-macro CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles\n+--include-macro CXTranslationUnit_IncludeAttributedTypes\n+--include-macro CXTranslationUnit_IncludeBriefCommentsInCodeCompletion\n+--include-macro CXTranslationUnit_Incomplete\n+--include-macro CXTranslationUnit_KeepGoing\n+--include-macro CXTranslationUnit_LimitSkipFunctionBodiesToPreamble\n+--include-macro CXTranslationUnit_None\n+--include-macro CXTranslationUnit_PrecompiledPreamble\n+--include-macro CXTranslationUnit_RetainExcludedConditionalBlocks\n+--include-macro CXTranslationUnit_SingleFileParse\n+--include-macro CXTranslationUnit_SkipFunctionBodies\n+--include-macro CXTranslationUnit_VisitImplicitAttributes\n+--include-macro CXTypeLayoutError_Dependent\n+--include-macro CXTypeLayoutError_Incomplete\n+--include-macro CXTypeLayoutError_Invalid\n+--include-macro CXTypeLayoutError_InvalidFieldName\n+--include-macro CXTypeLayoutError_NotConstantSize\n+--include-macro CXTypeLayoutError_Undeduced\n+--include-macro CXTypeNullability_Invalid\n+--include-macro CXTypeNullability_NonNull\n+--include-macro CXTypeNullability_Nullable\n+--include-macro CXTypeNullability_Unspecified\n+--include-macro CXType_Accum\n+--include-macro CXType_Attributed\n+--include-macro CXType_Auto\n+--include-macro CXType_BlockPointer\n+--include-macro CXType_Bool\n+--include-macro CXType_Char16\n+--include-macro CXType_Char32\n+--include-macro CXType_Char_S\n+--include-macro CXType_Char_U\n+--include-macro CXType_Complex\n+--include-macro CXType_ConstantArray\n+--include-macro CXType_Dependent\n+--include-macro CXType_DependentSizedArray\n+--include-macro CXType_Double\n+--include-macro CXType_Elaborated\n+--include-macro CXType_Enum\n+--include-macro CXType_ExtVector\n+--include-macro CXType_FirstBuiltin\n+--include-macro CXType_Float\n+--include-macro CXType_Float128\n+--include-macro CXType_Float16\n+--include-macro CXType_FunctionNoProto\n+--include-macro CXType_FunctionProto\n+--include-macro CXType_Half\n+--include-macro CXType_IncompleteArray\n+--include-macro CXType_Int\n+--include-macro CXType_Int128\n+--include-macro CXType_Invalid\n+--include-macro CXType_LValueReference\n+--include-macro CXType_LastBuiltin\n+--include-macro CXType_Long\n+--include-macro CXType_LongAccum\n+--include-macro CXType_LongDouble\n+--include-macro CXType_LongLong\n+--include-macro CXType_MemberPointer\n+--include-macro CXType_NullPtr\n+--include-macro CXType_OCLEvent\n+--include-macro CXType_OCLImage1dArrayRO\n+--include-macro CXType_OCLImage1dArrayRW\n+--include-macro CXType_OCLImage1dArrayWO\n+--include-macro CXType_OCLImage1dBufferRO\n+--include-macro CXType_OCLImage1dBufferRW\n+--include-macro CXType_OCLImage1dBufferWO\n+--include-macro CXType_OCLImage1dRO\n+--include-macro CXType_OCLImage1dRW\n+--include-macro CXType_OCLImage1dWO\n+--include-macro CXType_OCLImage2dArrayDepthRO\n+--include-macro CXType_OCLImage2dArrayDepthRW\n+--include-macro CXType_OCLImage2dArrayDepthWO\n+--include-macro CXType_OCLImage2dArrayMSAADepthRO\n+--include-macro CXType_OCLImage2dArrayMSAADepthRW\n+--include-macro CXType_OCLImage2dArrayMSAADepthWO\n+--include-macro CXType_OCLImage2dArrayMSAARO\n+--include-macro CXType_OCLImage2dArrayMSAARW\n+--include-macro CXType_OCLImage2dArrayMSAAWO\n+--include-macro CXType_OCLImage2dArrayRO\n+--include-macro CXType_OCLImage2dArrayRW\n+--include-macro CXType_OCLImage2dArrayWO\n+--include-macro CXType_OCLImage2dDepthRO\n+--include-macro CXType_OCLImage2dDepthRW\n+--include-macro CXType_OCLImage2dDepthWO\n+--include-macro CXType_OCLImage2dMSAADepthRO\n+--include-macro CXType_OCLImage2dMSAADepthRW\n+--include-macro CXType_OCLImage2dMSAADepthWO\n+--include-macro CXType_OCLImage2dMSAARO\n+--include-macro CXType_OCLImage2dMSAARW\n+--include-macro CXType_OCLImage2dMSAAWO\n+--include-macro CXType_OCLImage2dRO\n+--include-macro CXType_OCLImage2dRW\n+--include-macro CXType_OCLImage2dWO\n+--include-macro CXType_OCLImage3dRO\n+--include-macro CXType_OCLImage3dRW\n+--include-macro CXType_OCLImage3dWO\n+--include-macro CXType_OCLIntelSubgroupAVCImeDualRefStreamin\n+--include-macro CXType_OCLIntelSubgroupAVCImePayload\n+--include-macro CXType_OCLIntelSubgroupAVCImeResult\n+--include-macro CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout\n+--include-macro CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout\n+--include-macro CXType_OCLIntelSubgroupAVCImeSingleRefStreamin\n+--include-macro CXType_OCLIntelSubgroupAVCMcePayload\n+--include-macro CXType_OCLIntelSubgroupAVCMceResult\n+--include-macro CXType_OCLIntelSubgroupAVCRefPayload\n+--include-macro CXType_OCLIntelSubgroupAVCRefResult\n+--include-macro CXType_OCLIntelSubgroupAVCSicPayload\n+--include-macro CXType_OCLIntelSubgroupAVCSicResult\n+--include-macro CXType_OCLQueue\n+--include-macro CXType_OCLReserveID\n+--include-macro CXType_OCLSampler\n+--include-macro CXType_ObjCClass\n+--include-macro CXType_ObjCId\n+--include-macro CXType_ObjCInterface\n+--include-macro CXType_ObjCObject\n+--include-macro CXType_ObjCObjectPointer\n+--include-macro CXType_ObjCSel\n+--include-macro CXType_ObjCTypeParam\n+--include-macro CXType_Overload\n+--include-macro CXType_Pipe\n+--include-macro CXType_Pointer\n+--include-macro CXType_RValueReference\n+--include-macro CXType_Record\n+--include-macro CXType_SChar\n+--include-macro CXType_Short\n+--include-macro CXType_ShortAccum\n+--include-macro CXType_Typedef\n+--include-macro CXType_UAccum\n+--include-macro CXType_UChar\n+--include-macro CXType_UInt\n+--include-macro CXType_UInt128\n+--include-macro CXType_ULong\n+--include-macro CXType_ULongAccum\n+--include-macro CXType_ULongLong\n+--include-macro CXType_UShort\n+--include-macro CXType_UShortAccum\n+--include-macro CXType_Unexposed\n+--include-macro CXType_VariableArray\n+--include-macro CXType_Vector\n+--include-macro CXType_Void\n+--include-macro CXType_WChar\n+--include-function clang_Cursor_Evaluate\n+--include-function clang_Cursor_getArgument\n+--include-function clang_Cursor_getMangling\n+--include-function clang_Cursor_getNumArguments\n+--include-function clang_Cursor_getTranslationUnit\n+--include-function clang_Cursor_isAnonymous\n+--include-function clang_Cursor_isAnonymousRecordDecl\n+--include-function clang_Cursor_isBitField\n+--include-function clang_Cursor_isMacroFunctionLike\n+--include-function clang_Cursor_isNull\n+--include-function clang_Cursor_isVariadic\n+--include-function clang_EvalResult_dispose\n+--include-function clang_EvalResult_getAsDouble\n+--include-function clang_EvalResult_getAsInt\n+--include-function clang_EvalResult_getAsLongLong\n+--include-function clang_EvalResult_getAsStr\n+--include-function clang_EvalResult_getAsUnsigned\n+--include-function clang_EvalResult_getKind\n+--include-function clang_EvalResult_isUnsignedInt\n+--include-function clang_Location_isFromMainFile\n+--include-function clang_Location_isInSystemHeader\n+--include-function clang_PrintingPolicy_dispose\n+--include-function clang_PrintingPolicy_getProperty\n+--include-function clang_PrintingPolicy_setProperty\n+--include-function clang_Range_isNull\n+--include-function clang_Type_getOffsetOf\n+--include-function clang_Type_getSizeOf\n+--include-function clang_createIndex\n+--include-function clang_defaultDiagnosticDisplayOptions\n+--include-function clang_defaultReparseOptions\n+--include-function clang_disposeDiagnostic\n+--include-function clang_disposeIndex\n+--include-function clang_disposeTokens\n+--include-function clang_disposeTranslationUnit\n+--include-function clang_equalCursors\n+--include-function clang_equalLocations\n+--include-function clang_equalTypes\n+--include-function clang_formatDiagnostic\n+--include-function clang_getArgType\n+--include-function clang_getArrayElementType\n+--include-function clang_getArraySize\n+--include-function clang_getCanonicalType\n+--include-function clang_getChildDiagnostics\n+--include-function clang_getClangVersion\n+--include-function clang_getCursorDefinition\n+--include-function clang_getCursorDisplayName\n+--include-function clang_getCursorExtent\n+--include-function clang_getCursorKind\n+--include-function clang_getCursorKindSpelling\n+--include-function clang_getCursorLanguage\n+--include-function clang_getCursorLocation\n+--include-function clang_getCursorPrettyPrinted\n+--include-function clang_getCursorPrintingPolicy\n+--include-function clang_getCursorReferenced\n+--include-function clang_getCursorResultType\n+--include-function clang_getCursorSpelling\n+--include-function clang_getCursorType\n+--include-function clang_getCursorUSR\n+--include-function clang_getDiagnostic\n+--include-function clang_getDiagnosticLocation\n+--include-function clang_getDiagnosticSeverity\n+--include-function clang_getDiagnosticSpelling\n+--include-function clang_getElementType\n+--include-function clang_getEnumConstantDeclUnsignedValue\n+--include-function clang_getEnumConstantDeclValue\n+--include-function clang_getEnumDeclIntegerType\n+--include-function clang_getExpansionLocation\n+--include-function clang_getFieldDeclBitWidth\n+--include-function clang_getFileLocation\n+--include-function clang_getFileName\n+--include-function clang_getFunctionTypeCallingConv\n+--include-function clang_getLocation\n+--include-function clang_getLocationForOffset\n+--include-function clang_getNullCursor\n+--include-function clang_getNullLocation\n+--include-function clang_getNumArgTypes\n+--include-function clang_getNumDiagnostics\n+--include-function clang_getNumElements\n+--include-function clang_getPointeeType\n+--include-function clang_getRangeStart\n+--include-function clang_getRangeEnd\n+--include-function clang_getResultType\n+--include-function clang_getSpellingLocation\n+--include-function clang_getTokenExtent\n+--include-function clang_getTokenKind\n+--include-function clang_getTokenLocation\n+--include-function clang_getTokenSpelling\n+--include-function clang_getTranslationUnitCursor\n+--include-function clang_getTypeDeclaration\n+--include-function clang_getTypeKindSpelling\n+--include-function clang_getTypePrettyPrinted\n+--include-function clang_getTypePrintingPolicy\n+--include-function clang_getTypeSpelling\n+--include-function clang_getTypedefDeclUnderlyingType\n+--include-function clang_getTypedefName\n+--include-function clang_isAttribute\n+--include-function clang_isConstQualifiedType\n+--include-function clang_isCursorDefinition\n+--include-function clang_isDeclaration\n+--include-function clang_isFunctionTypeVariadic\n+--include-function clang_isInvalid\n+--include-function clang_isPreprocessing\n+--include-function clang_isVolatileQualifiedType\n+--include-function clang_parseTranslationUnit\n+--include-function clang_parseTranslationUnit2\n+--include-function clang_reparseTranslationUnit\n+--include-function clang_saveTranslationUnit\n+--include-function clang_toggleCrashRecovery\n+--include-function clang_tokenize\n+--include-function clang_visitChildren\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/clang.symbols","additions":624,"deletions":0,"binary":false,"changes":624,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/cp_header.txt","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,14 @@\n+#!\/bin\/bash\n+\n+jextract --source -t jdk.internal.clang.libclang -lclang \\\n+  -I \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/ \\\n+  -I ${LIBCLANG_HOME}\/include\/clang-c \\\n+  @clang.symbols \\\n+  ${LIBCLANG_HOME}\/include\/clang-c\/Index.h\n+\n+\n+for x in jdk\/internal\/clang\/libclang\/*.java; do\n+head -$COPYRIGHTLEN $x | diff cp_header.txt - || ( ( cat cp_header.txt; echo; cat $x) > \/tmp\/file;\n+mv \/tmp\/file $x )\n+done\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/extract.sh","additions":14,"deletions":0,"binary":false,"changes":14,"status":"added"},{"patch":"@@ -0,0 +1,540 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.incubator.jextract;\n+\n+import java.lang.constant.Constable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.internal.jextract.impl.DeclarationImpl;\n+\n+\/**\n+ * Instances of this class are used to model declaration elements in the foreign language.\n+ * All declarations have a position (see {@link Position}) and a name. Instances of this class\n+ * support the <em>visitor<\/em> pattern (see {@link Declaration#accept(Visitor, Object)} and\n+ * {@link Visitor}).\n+ *\/\n+public interface Declaration {\n+\n+    \/**\n+     * The position associated with this declaration.\n+     * @return The position associated with this declaration.\n+     *\/\n+    Position pos();\n+\n+    \/**\n+     * The name associated with this declaration.\n+     * @return The name associated with this declaration.\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Get a declaration with specified attribute.\n+     * Set the values to the specified attribute while other attributes remains unchanged. If the specified attribute\n+     * already exist, the new values are replacing the old ones. By not specifying any value, the attribute will become\n+     * empty as {@link #getAttribute(String) getAttribute(name).isEmpty()} will return true.\n+     * @param name The attribute name\n+     * @param values More attribute values\n+     * @return the Declaration with attributes\n+     *\/\n+    Declaration withAttribute(String name, Constable... values);\n+\n+    \/**\n+     * Get a declaration without current attributes\n+     * @return the Declatation without any attributes\n+     *\/\n+    Declaration stripAttributes();\n+\n+    \/**\n+     * The values of the specified attribute.\n+     * @param name The attribute to retrieve\n+     * @return The list of values associate with this attribute\n+     *\/\n+    Optional<List<Constable>> getAttribute(String name);\n+\n+    \/**\n+     * The attributes associated with this declaration\n+     * @return The attributes associated with this declaration\n+     *\/\n+    Set<String> attributeNames();\n+\n+    \/**\n+     * Entry point for visiting declaration instances.\n+     * @param visitor the declaration visitor.\n+     * @param data optional data to be passed to the visitor.\n+     * @param <R> the visitor's return type.\n+     * @param <D> the visitor's argument type.\n+     * @return the result of visiting this declaration through the specified declaration visitor.\n+     *\/\n+    <R,D> R accept(Visitor<R, D> visitor, D data);\n+\n+    \/**\n+     * Compares the specified object with this Declaration for equality.  Returns\n+     * {@code true} if and only if the specified object is also a Declaration and both\n+     * the declarations are <i>equal<\/i>.\n+     *\n+     * @param o the object to be compared for equality with this Declaration\n+     * @return {@code true} if the specified object is equal to this Declaration\n+     *\/\n+    boolean equals(Object o);\n+\n+    \/**\n+     * Returns the hash code value for this Declaration.\n+     *\n+     * @return the hash code value for this Declaration.\n+     *\/\n+    int hashCode();\n+\n+    \/**\n+     * A function declaration.\n+     *\/\n+    interface Function extends Declaration {\n+        \/**\n+         * The parameters associated with this function declaration.\n+         * @return The parameters associated with this function declaration.\n+         *\/\n+        List<Variable> parameters();\n+\n+        \/**\n+         * The foreign type associated with this function declaration.\n+         * @return The foreign type associated with this function declaration.\n+         *\/\n+        Type.Function type();\n+    }\n+\n+    \/**\n+     * A scoped declaration is a container for one or more nested declarations. This declaration can be used to model\n+     * several constructs in the foreign languages, such as (but not limited to) structs, unions and structs (see also\n+     * {@link Scoped.Kind}).\n+     *\/\n+    interface Scoped extends Declaration {\n+\n+        \/**\n+         * The scoped declaration kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Namespace declaration.\n+             *\/\n+            NAMESPACE,\n+            \/**\n+             * Class declaration.\n+             *\/\n+            CLASS,\n+            \/**\n+             * Enum declaration.\n+             *\/\n+            ENUM,\n+            \/**\n+             * Struct declaration.\n+             *\/\n+            STRUCT,\n+            \/**\n+             * Union declaration.\n+             *\/\n+            UNION,\n+            \/**\n+             * Bitfields declaration.\n+             *\/\n+            BITFIELDS,\n+            \/**\n+             * Toplevel declaration.\n+             *\/\n+            TOPLEVEL;\n+        }\n+\n+        \/**\n+         * The member declarations associated with this scoped declaration.\n+         * @return The member declarations associated with this scoped declaration.\n+         *\/\n+        List<Declaration> members();\n+\n+        \/**\n+         * The (optional) layout associated with this scoped declaration.\n+         * @return The (optional) layout associated with this scoped declaration.\n+         *\n+         * @implSpec a layout is present if the scoped declaration kind is one of {@link Kind#STRUCT}, {@link Kind#UNION},\n+         * {@link Kind#ENUM}, {@link Kind#BITFIELDS}, {@link Kind#CLASS} <em>and<\/em> if this declaration models an entity in the foreign\n+         * language that is associated with a <em>definition<\/em>.\n+         *\/\n+        Optional<MemoryLayout> layout();\n+\n+        \/**\n+         * The scoped declaration kind.\n+         * @return The scoped declaration kind.\n+         *\/\n+        Kind kind();\n+    }\n+\n+    \/**\n+     * A typedef declaration\n+     *\/\n+    interface Typedef extends Declaration {\n+        \/**\n+         * The canonical type associated with this typedef declaration.\n+         * @return The canonical type associated with this typedef declaration.\n+         *\/\n+        Type type();\n+    }\n+\n+    \/**\n+     * A variable declaration.\n+     *\/\n+    interface Variable extends Declaration {\n+        \/**\n+         * The variable declaration kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Global variable declaration.\n+             *\/\n+            GLOBAL,\n+            \/**\n+             * Field declaration.\n+             *\/\n+            FIELD,\n+            \/**\n+             * Bitfield declaration.\n+             *\/\n+            BITFIELD,\n+            \/**\n+             * Function parameter declaration.\n+             *\/\n+            PARAMETER;\n+        }\n+\n+        \/**\n+         * The type associated with this variable declaration.\n+         * @return The type associated with this variable declaration.\n+         *\/\n+        Type type();\n+\n+        \/**\n+         * The optional layout associated with this variable declaration.\n+         * @return The optional layout associated with this variable declaration.\n+         *\/\n+        Optional<MemoryLayout> layout();\n+\n+        \/**\n+         * The kind associated with this variable declaration.\n+         * @return The kind associated with this variable declaration.\n+         *\/\n+        Kind kind();\n+    }\n+\n+    \/**\n+     * A constant value declaration.\n+     *\/\n+    interface Constant extends Declaration {\n+        \/**\n+         * The value associated with this constant declaration.\n+         * @return The value associated with this constant declaration.\n+         *\/\n+        Object value();\n+\n+        \/**\n+         * The type associated with this constant declaration.\n+         * @return The type associated with this constant declaration.\n+         *\/\n+        Type type();\n+    }\n+\n+    \/**\n+     * Declaration visitor interface.\n+     * @param <R> the visitor's return type.\n+     * @param <P> the visitor's parameter type.\n+     *\/\n+    interface Visitor<R,P> {\n+        \/**\n+         * Visit a scoped declaration.\n+         * @param d the scoped declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given scoped declaration through this visitor object.\n+         *\/\n+        default R visitScoped(Scoped d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a function declaration.\n+         * @param d the function declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given function declaration through this visitor object.\n+         *\/\n+        default R visitFunction(Function d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a variable declaration.\n+         * @param d the variable declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given variable declaration through this visitor object.\n+         *\/\n+        default R visitVariable(Variable d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a constant declaration.\n+         * @param d the constant declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given constant declaration through this visitor object.\n+         *\/\n+        default R visitConstant(Constant d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a typedef declaration.\n+         * @param d the typedef declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given typedef declaration through this visitor object.\n+         *\/\n+        default R visitTypedef(Typedef d, P p) { return visitDeclaration(d, p); }\n+\n+        \/**\n+         * Visit a declaration.\n+         * @param d the declaration.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given declaration through this visitor object.\n+         *\/\n+        default R visitDeclaration(Declaration d, P p) { throw new UnsupportedOperationException(); }\n+    }\n+\n+    \/**\n+     * Creates a new constant declaration with given name and type.\n+     * @param pos the constant declaration position.\n+     * @param name the constant declaration name.\n+     * @param value the constant declaration value.\n+     * @param type the constant declaration type.\n+     * @return a new constant declaration with given name and type.\n+     *\/\n+    static Declaration.Constant constant(Position pos, String name, Object value, Type type) {\n+        return new DeclarationImpl.ConstantImpl(type, value, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new global variable declaration with given name and type.\n+     * @param pos the global variable declaration position.\n+     * @param name the global variable declaration name.\n+     * @param type the global variable declaration type.\n+     * @return a new global variable declaration with given name and type.\n+     *\/\n+    static Declaration.Variable globalVariable(Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.GLOBAL, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new field declaration with given name and type.\n+     * @param pos the field declaration position.\n+     * @param name the field declaration name.\n+     * @param type the field declaration type.\n+     * @return a new field declaration with given name and type.\n+     *\/\n+    static Declaration.Variable field(Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.FIELD, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new bitfield declaration with given name, type and layout.\n+     * @param pos the bitfield declaration position.\n+     * @param name the bitfield declaration name.\n+     * @param type the bitfield declaration type.\n+     * @param layout the bitfield declaration layout.\n+     * @return a new bitfield declaration with given name, type and layout.\n+     *\/\n+    static Declaration.Variable bitfield(Position pos, String name, Type type, MemoryLayout layout) {\n+        return new DeclarationImpl.VariableImpl(type, layout, Declaration.Variable.Kind.BITFIELD, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new parameter declaration with given name and type.\n+     * @param pos the parameter declaration position.\n+     * @param name the parameter declaration name.\n+     * @param type the parameter declaration type.\n+     * @return a new parameter declaration with given name and type.\n+     *\/\n+    static Declaration.Variable parameter(Position pos, String name, Type type) {\n+        return new DeclarationImpl.VariableImpl(type, Declaration.Variable.Kind.PARAMETER, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new toplevel declaration with given member declarations.\n+     * @param pos the toplevel declaration position.\n+     * @param decls the toplevel declaration member declarations.\n+     * @return a new toplevel declaration with given member declarations.\n+     *\/\n+    static Declaration.Scoped toplevel(Position pos, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.TOPLEVEL, declList, \"<toplevel>\", pos);\n+    }\n+\n+    \/**\n+     * Creates a new namespace declaration with given name and member declarations.\n+     * @param pos the namespace declaration position.\n+     * @param name the namespace declaration name.\n+     * @param decls the namespace declaration member declarations.\n+     * @return a new namespace declaration with given name and member declarations.\n+     *\/\n+    static Declaration.Scoped namespace(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.NAMESPACE, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new bitfields group declaration with given name and layout.\n+     * @param pos the bitfields group declaration position.\n+     * @param name the bitfields group declaration name.\n+     * @param layout the bitfields group declaration layout.\n+     * @param bitfields the bitfields group member declarations.\n+     * @return a new bitfields group declaration with given name and layout.\n+     *\/\n+    static Declaration.Scoped bitfields(Position pos, String name, MemoryLayout layout, Declaration.Variable... bitfields) {\n+        List<Declaration> declList = Stream.of(bitfields).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.BITFIELDS, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new struct declaration with given name and member declarations.\n+     * @param pos the struct declaration position.\n+     * @param name the struct declaration name.\n+     * @param decls the struct declaration member declarations.\n+     * @return a new struct declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped struct(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new struct declaration with given name, layout and member declarations.\n+     * @param pos the struct declaration position.\n+     * @param name the struct declaration name.\n+     * @param layout the struct declaration layout.\n+     * @param decls the struct declaration member declarations.\n+     * @return a new struct declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped struct(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.STRUCT, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new union declaration with given name and member declarations.\n+     * @param pos the union declaration position.\n+     * @param name the union declaration name.\n+     * @param decls the union declaration member declarations.\n+     * @return a new union declaration with given name and member declarations.\n+     *\/\n+    static Declaration.Scoped union(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Scoped.Kind.UNION, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new union declaration with given name, layout and member declarations.\n+     * @param pos the union declaration position.\n+     * @param name the union declaration name.\n+     * @param layout the union declaration layout.\n+     * @param decls the union declaration member declarations.\n+     * @return a new union declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped union(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.UNION, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new class declaration with given name and member declarations.\n+     * @param pos the class declaration position.\n+     * @param name the class declaration name.\n+     * @param decls the class declaration member declarations.\n+     * @return a new class declaration with given name and member declarations.\n+     *\/\n+    static Declaration.Scoped class_(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new class declaration with given name, layout and member declarations.\n+     * @param pos the class declaration position.\n+     * @param name the class declaration name.\n+     * @param layout the class declaration layout.\n+     * @param decls the class declaration member declarations.\n+     * @return a new class declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped class_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.CLASS, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new enum declaration with given name and member declarations.\n+     * @param pos the enum declaration position.\n+     * @param name the enum declaration name.\n+     * @param decls the enum declaration member declarations.\n+     * @return a new enum declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped enum_(Position pos, String name, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new enum declaration with given name, layout and member declarations.\n+     * @param pos the enum declaration position.\n+     * @param name the enum declaration name.\n+     * @param layout the enum declaration layout.\n+     * @param decls the enum declaration member declarations.\n+     * @return a new enum declaration with given name, layout and member declarations.\n+     *\/\n+    static Declaration.Scoped enum_(Position pos, String name, MemoryLayout layout, Declaration... decls) {\n+        List<Declaration> declList = Stream.of(decls).collect(Collectors.toList());\n+        return new DeclarationImpl.ScopedImpl(Declaration.Scoped.Kind.ENUM, layout, declList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new function declaration with given name, type and parameter declarations.\n+     * @param pos the function declaration position.\n+     * @param name the function declaration name.\n+     * @param type the function declaration type.\n+     * @param params the function declaration parameter declarations.\n+     * @return a new function declaration with given name, type and parameter declarations.\n+     *\/\n+    static Declaration.Function function(Position pos, String name, Type.Function type, Declaration.Variable... params) {\n+        List<Variable> paramList = Stream.of(params).collect(Collectors.toList());\n+        return new DeclarationImpl.FunctionImpl(type, paramList, name, pos);\n+    }\n+\n+    \/**\n+     * Creates a new typedef declaration with given name and declared type.\n+     * @param pos the typedef declaration position.\n+     * @param name the typedef declaration name.\n+     * @param type the typedef type\n+     * @return a new type declaration with given name and declared type.\n+     *\/\n+    static Declaration.Typedef typedef(Position pos, String name, Type type) {\n+        return new DeclarationImpl.TypedefImpl(type, name, pos, null);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Declaration.java","additions":540,"deletions":0,"binary":false,"changes":540,"status":"added"},{"patch":"@@ -0,0 +1,343 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.jextract;\n+\n+import jdk.internal.jextract.impl.ClangException;\n+import jdk.internal.jextract.impl.IncludeHelper;\n+import jdk.internal.jextract.impl.OutputFactory;\n+import jdk.internal.jextract.impl.Parser;\n+import jdk.internal.jextract.impl.Options;\n+import jdk.internal.jextract.impl.Writer;\n+import jdk.internal.joptsimple.OptionException;\n+import jdk.internal.joptsimple.OptionParser;\n+import jdk.internal.joptsimple.OptionSet;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.text.MessageFormat;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.ResourceBundle;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Simple extraction tool which generates a minimal Java API. Such an API consists mainly of static methods,\n+ * where for each native function a static method is added which calls the underlying native method handles.\n+ * Similarly, for struct fields and global variables, static accessors (getter and setter) are generated\n+ * on top of the underlying memory access var handles. For each struct, a static layout field is generated.\n+ *\/\n+public final class JextractTool {\n+    private static final String MESSAGES_RESOURCE = \"jdk.internal.jextract.impl.resources.Messages\";\n+\n+    private static final ResourceBundle MESSAGES_BUNDLE;\n+    static {\n+        MESSAGES_BUNDLE = ResourceBundle.getBundle(MESSAGES_RESOURCE, Locale.getDefault());\n+    }\n+\n+    public static final boolean DEBUG = Boolean.getBoolean(\"jextract.debug\");\n+\n+    \/\/ error codes\n+    private static final int SUCCESS       = 0;\n+    private static final int OPTION_ERROR  = 1;\n+    private static final int INPUT_ERROR   = 2;\n+    private static final int CLANG_ERROR   = 3;\n+    private static final int RUNTIME_ERROR = 4;\n+    private static final int OUTPUT_ERROR  = 5;\n+\n+    private final PrintWriter out;\n+    private final PrintWriter err;\n+\n+    private static String format(String msgId, Object... args) {\n+        return new MessageFormat(MESSAGES_BUNDLE.getString(msgId)).format(args);\n+    }\n+\n+    private JextractTool(PrintWriter out, PrintWriter err) {\n+        this.out = out;\n+        this.err = err;\n+    }\n+\n+    private static Path generateTmpSource(List<Path> headers) {\n+        assert headers.size() > 1;\n+        try {\n+            Path tmpFile = Files.createTempFile(\"jextract\", \".h\");\n+            tmpFile.toFile().deleteOnExit();\n+            Files.write(tmpFile, headers.stream().\n+                    map(src -> \"#include \\\"\" + src + \"\\\"\").\n+                    collect(Collectors.toList()));\n+            return tmpFile;\n+        } catch (IOException ioExp) {\n+            throw new UncheckedIOException(ioExp);\n+        }\n+    }\n+\n+    \/**\n+     * Parse input files into a toplevel declaration with given options.\n+     * @param parserOptions options to be passed to the parser.\n+     * @return a toplevel declaration.\n+     *\/\n+    public static Declaration.Scoped parse(List<Path> headers, String... parserOptions) {\n+        Path source = headers.size() > 1? generateTmpSource(headers) : headers.iterator().next();\n+        return new Parser().parse(source, Stream.of(parserOptions).collect(Collectors.toList()));\n+    }\n+\n+    public static List<JavaFileObject> generate(Declaration.Scoped decl, String headerName,\n+                                                String targetPkg, List<String> libNames) {\n+        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, new IncludeHelper(), libNames));\n+    }\n+\n+    private static List<JavaFileObject> generateInternal(Declaration.Scoped decl, String headerName,\n+                                                String targetPkg, IncludeHelper includeHelper, List<String> libNames) {\n+        return List.of(OutputFactory.generateWrapped(decl, headerName, targetPkg, includeHelper, libNames));\n+    }\n+\n+    \/**\n+     * Write resulting {@link JavaFileObject} instances into specified destination path.\n+     * @param dest the destination path.\n+     * @param compileSources whether to compile .java sources or not\n+     * @param files the {@link JavaFileObject} instances to be written.\n+     *\/\n+    public static void write(Path dest, boolean compileSources, List<JavaFileObject> files) throws UncheckedIOException {\n+        try {\n+            new Writer(dest, files).writeAll(compileSources);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private int printHelp(OptionParser parser, int exitCode) {\n+        try {\n+            parser.printHelpOn(err);\n+        } catch (IOException ignored) {}\n+        return exitCode;\n+    }\n+\n+\n+    private void printOptionError(Throwable throwable) {\n+        printOptionError(throwable.getMessage());\n+        if (DEBUG) {\n+            throwable.printStackTrace(err);\n+        }\n+    }\n+\n+    private void printOptionError(String message) {\n+        err.println(\"OPTION ERROR: \" + message);\n+        err.println(\"Usage: jextract <options> [--] <header file>\");\n+        err.println(\"Use --help for a list of possible options\");\n+    }\n+\n+    \/**\n+     * Main entry point to run the JextractTool\n+     *\n+     * @param args command line options passed\n+     *\/\n+    public static void main(String[] args) {\n+        if (args.length == 0) {\n+            System.err.println(\"Expected a header file\");\n+            return;\n+        }\n+\n+        JextractTool m = new JextractTool(new PrintWriter(System.out, true), new PrintWriter(System.err, true));\n+        System.exit(m.run(args));\n+    }\n+\n+    private int run(String[] args) {\n+        OptionParser parser = new OptionParser(false);\n+        parser.accepts(\"C\", format(\"help.C\")).withRequiredArg();\n+        parser.accepts(\"I\", format(\"help.I\")).withRequiredArg();\n+        parser.accepts(\"d\", format(\"help.d\")).withRequiredArg();\n+        parser.accepts(\"dump-includes\", format(\"help.dump-includes\")).withRequiredArg();\n+        for (IncludeHelper.IncludeKind includeKind : IncludeHelper.IncludeKind.values()) {\n+            parser.accepts(includeKind.optionName(), format(\"help.\" + includeKind.optionName())).withRequiredArg();\n+        }\n+        parser.accepts(\"l\", format(\"help.l\")).withRequiredArg();\n+        parser.accepts(\"source\", format(\"help.source\"));\n+        parser.acceptsAll(List.of(\"t\", \"target-package\"), format(\"help.t\")).withRequiredArg();\n+        parser.acceptsAll(List.of(\"?\", \"h\", \"help\"), format(\"help.h\")).forHelp();\n+        parser.accepts(\"header-class-name\", format(\"help.header-class-name\")).withRequiredArg();\n+        parser.nonOptions(format(\"help.non.option\"));\n+\n+        OptionSet optionSet;\n+        try {\n+            optionSet = parser.parse(args);\n+        } catch (OptionException oe) {\n+            printOptionError(oe);\n+            return OPTION_ERROR;\n+        }\n+\n+        if (optionSet.has(\"h\")) {\n+            return printHelp(parser, SUCCESS);\n+        }\n+\n+        if (optionSet.nonOptionArguments().size() != 1) {\n+            printOptionError(\"Expected 1 header file, not \" + optionSet.nonOptionArguments().size());\n+            return OPTION_ERROR;\n+        }\n+\n+        Options.Builder builder = Options.builder();\n+        if (optionSet.has(\"I\")) {\n+            optionSet.valuesOf(\"I\").forEach(p -> builder.addClangArg(\"-I\" + p));\n+        }\n+\n+        Path builtinInc = Paths.get(System.getProperty(\"java.home\"), \"conf\", \"jextract\");\n+        builder.addClangArg(\"-I\" + builtinInc);\n+\n+        if (optionSet.has(\"C\")) {\n+            optionSet.valuesOf(\"C\").forEach(p -> builder.addClangArg((String) p));\n+        }\n+\n+        if (optionSet.has(\"filter\")) {\n+            optionSet.valuesOf(\"filter\").forEach(p -> builder.addFilter((String) p));\n+        }\n+\n+        for (IncludeHelper.IncludeKind includeKind : IncludeHelper.IncludeKind.values()) {\n+            if (optionSet.has(includeKind.optionName())) {\n+                optionSet.valuesOf(includeKind.optionName()).forEach(p -> builder.addIncludeSymbol(includeKind, (String)p));\n+            }\n+        }\n+\n+        if (optionSet.has(\"dump-includes\")) {\n+            builder.setDumpIncludeFile(optionSet.valueOf(\"dump-includes\").toString());\n+        }\n+\n+        if (optionSet.has(\"d\")) {\n+            builder.setOutputDir(optionSet.valueOf(\"d\").toString());\n+        }\n+\n+        if (optionSet.has(\"source\")) {\n+            builder.setGenerateSource();\n+        }\n+        boolean librariesSpecified = optionSet.has(\"l\");\n+        if (librariesSpecified) {\n+            for (Object arg : optionSet.valuesOf(\"l\")) {\n+                String lib = (String)arg;\n+                if (lib.indexOf(File.separatorChar) == -1) {\n+                    builder.addLibraryName(lib);\n+                } else {\n+                    Path libPath = Paths.get(lib);\n+                    if (libPath.isAbsolute() && Files.isRegularFile(libPath)) {\n+                        builder.addLibraryName(lib);\n+                    } else {\n+                        err.println(format(\"l.option.value.invalid\", lib));\n+                        return OPTION_ERROR;\n+                    }\n+                }\n+            }\n+        }\n+\n+        String targetPackage = optionSet.has(\"t\") ? (String) optionSet.valueOf(\"t\") : \"\";\n+        builder.setTargetPackage(targetPackage);\n+\n+        Options options = builder.build();\n+\n+        Path header = Paths.get(optionSet.nonOptionArguments().get(0).toString());\n+        if (!Files.isReadable(header)) {\n+            err.println(format(\"cannot.read.header.file\", header));\n+            return INPUT_ERROR;\n+        }\n+        if (!(Files.isRegularFile(header))) {\n+            err.println(format(\"not.a.file\", header));\n+            return INPUT_ERROR;\n+        }\n+\n+        List<JavaFileObject> files = null;\n+        try {\n+            Declaration.Scoped toplevel = parse(List.of(header), options.clangArgs.toArray(new String[0]));\n+\n+            if (JextractTool.DEBUG) {\n+                System.out.println(toplevel);\n+            }\n+\n+            String headerName = optionSet.has(\"header-class-name\") ?\n+                (String) optionSet.valueOf(\"header-class-name\") :\n+                header.getFileName().toString();\n+\n+            files = generateInternal(\n+                toplevel, headerName,\n+                options.targetPackage, options.includeHelper, options.libraryNames);\n+        } catch (ClangException ce) {\n+            err.println(ce.getMessage());\n+            if (JextractTool.DEBUG) {\n+                ce.printStackTrace(err);\n+            }\n+            return CLANG_ERROR;\n+        } catch (RuntimeException re) {\n+            err.println(re.getMessage());\n+            if (JextractTool.DEBUG) {\n+                re.printStackTrace(err);\n+            }\n+            return RUNTIME_ERROR;\n+        }\n+\n+        try {\n+            if (options.includeHelper.dumpIncludesFile != null) {\n+                options.includeHelper.dumpIncludes();\n+            } else {\n+                Path output = Path.of(options.outputDir);\n+                write(output, !options.source, files);\n+            }\n+        } catch (UncheckedIOException uioe) {\n+            err.println(uioe.getMessage());\n+            if (JextractTool.DEBUG) {\n+                uioe.printStackTrace(err);\n+            }\n+            return OUTPUT_ERROR;\n+        } catch (RuntimeException re) {\n+            err.println(re.getMessage());\n+            if (JextractTool.DEBUG) {\n+                re.printStackTrace(err);\n+            }\n+            return RUNTIME_ERROR;\n+        }\n+\n+        return SUCCESS;\n+    }\n+\n+    \/**\n+     * ToolProvider implementation for jextract tool.\n+     *\/\n+    public static class JextractToolProvider implements ToolProvider {\n+        public JextractToolProvider() {}\n+\n+        @Override\n+        public String name() {\n+            return \"jextract\";\n+        }\n+\n+        @Override\n+        public int run(PrintWriter out, PrintWriter err, String... args) {\n+            JextractTool instance = new JextractTool(out, err);\n+            return instance.run(args);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/JextractTool.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.incubator.jextract;\n+\n+import java.nio.file.Path;\n+\n+\/**\n+ * Instances of this class model are used to model source code positions.\n+ *\/\n+public interface Position {\n+\n+    \/**\n+     * The input file to which this position refers to.\n+     * @return The input file to which this position refers to.\n+     *\/\n+    Path path();\n+\n+    \/**\n+     * The line number associated with this position.\n+     * @return The line number associated with this position.\n+     *\/\n+    int line();\n+\n+    \/**\n+     * The column number associated with this position.\n+     * @return The column number associated with this position.\n+     *\/\n+    int col();\n+\n+    \/**\n+     * An empty position instance; this can be used to model <em>synthetic<\/em> program elements which are not\n+     * defined in any input file.\n+     *\/\n+    Position NO_POSITION = new Position() {\n+        @Override\n+        public Path path() {\n+            return null;\n+        }\n+\n+        @Override\n+        public int line() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int col() {\n+            return 0;\n+        }\n+    };\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Position.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,514 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.incubator.jextract;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.internal.jextract.impl.LayoutUtils;\n+import jdk.internal.jextract.impl.TypeImpl;\n+import jdk.internal.jextract.impl.UnsupportedLayouts;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Instances of this class are used to model types in the foreign language.\n+ * Instances of this class support the <em>visitor<\/em> pattern (see {@link Type#accept(Type.Visitor, Object)} and\n+ * {@link Type.Visitor}).\n+ *\/\n+public interface Type {\n+\n+    \/**\n+     * Is this type the erroneous type?\n+     * @return true, if this type is the erroneous type.\n+     *\/\n+    boolean isErroneous();\n+\n+    \/**\n+     * Entry point for visiting type instances.\n+     * @param visitor the type visitor.\n+     * @param data optional data to be passed to the visitor.\n+     * @param <R> the visitor's return type.\n+     * @param <D> the visitor's argument type.\n+     * @return the result of visiting this type through the specified type visitor.\n+     *\/\n+    <R,D> R accept(Visitor<R, D> visitor, D data);\n+\n+    \/**\n+     * Compares the specified object with this Type for equality.  Returns\n+     * {@code true} if and only if the specified object is also a Type and both\n+     * the Types are <i>equal<\/i>.\n+     *\n+     * @param o the object to be compared for equality with this Type\n+     * @return {@code true} if the specified object is equal to this Type\n+     *\/\n+    boolean equals(Object o);\n+\n+    \/**\n+     * Returns the hash code value for this Type.\n+     *\n+     * @return the hash code value for this Type.\n+     *\/\n+    int hashCode();\n+\n+    \/**\n+     * A primitive type.\n+     *\/\n+    interface Primitive extends Type {\n+\n+        \/**\n+         * The primitive type kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * {@code void} type.\n+             *\/\n+            Void(\"void\", null),\n+            \/**\n+             * {@code Bool} type.\n+             *\/\n+            Bool(\"_Bool\", CLinker.C_CHAR),\n+            \/**\n+             * {@code char} type.\n+             *\/\n+            Char(\"char\", CLinker.C_CHAR),\n+            \/**\n+             * {@code char16} type.\n+             *\/\n+            Char16(\"char16\", UnsupportedLayouts.CHAR16),\n+            \/**\n+             * {@code short} type.\n+             *\/\n+            Short(\"short\", CLinker.C_SHORT),\n+            \/**\n+             * {@code int} type.\n+             *\/\n+            Int(\"int\", CLinker.C_INT),\n+            \/**\n+             * {@code long} type.\n+             *\/\n+            Long(\"long\", CLinker.C_LONG),\n+            \/**\n+             * {@code long long} type.\n+             *\/\n+            LongLong(\"long long\", CLinker.C_LONG_LONG),\n+            \/**\n+             * {@code int128} type.\n+             *\/\n+            Int128(\"__int128\", UnsupportedLayouts.__INT128),\n+            \/**\n+             * {@code float} type.\n+             *\/\n+            Float(\"float\", CLinker.C_FLOAT),\n+            \/**\n+             * {@code double} type.\n+             *\/\n+            Double(\"double\",CLinker.C_DOUBLE),\n+            \/**\n+              * {@code long double} type.\n+              *\/\n+            LongDouble(\"long double\", UnsupportedLayouts.LONG_DOUBLE),\n+            \/**\n+             * {@code float128} type.\n+             *\/\n+            Float128(\"float128\", UnsupportedLayouts._FLOAT128),\n+            \/**\n+             * {@code float16} type.\n+             *\/\n+            HalfFloat(\"__fp16\", UnsupportedLayouts.__FP16),\n+            \/**\n+             * {@code wchar} type.\n+             *\/\n+            WChar(\"wchar_t\", UnsupportedLayouts.WCHAR_T);\n+\n+            private final String typeName;\n+            private final MemoryLayout layout;\n+\n+            Kind(String typeName, MemoryLayout layout) {\n+                this.typeName = typeName;\n+                this.layout = layout;\n+            }\n+\n+            public String typeName() {\n+                return typeName;\n+            }\n+\n+            \/**\n+             * The primitive type (optional) layout.\n+             * @return The primitive type (optional) layout.\n+             *\/\n+            public Optional<MemoryLayout> layout() {\n+                return Optional.ofNullable(layout);\n+            }\n+        }\n+\n+        \/**\n+         * The primitive type kind.\n+         * @return The primitive type kind.\n+         *\/\n+        Kind kind();\n+    }\n+\n+    \/**\n+     * Instances of this class are used to model types which are associated to a declaration in the foreign language\n+     * (see {@link Declaration}).\n+     *\/\n+    interface Declared extends Type {\n+        \/**\n+         * The declaration to this type refers to.\n+         * @return The declaration to this type refers to.\n+         *\/\n+        Declaration.Scoped tree();\n+    }\n+\n+    \/**\n+     * A function type.\n+     *\/\n+    interface Function extends Type {\n+        \/**\n+         * Is this function type a variable-arity?\n+         * @return true, if this function type is a variable-arity.\n+         *\/\n+        boolean varargs();\n+\n+        \/**\n+         * The function formal parameter types.\n+         * @return The function formal parameter types.\n+         *\/\n+        List<Type> argumentTypes();\n+\n+        \/**\n+         * The function return type.\n+         * @return The function return type.\n+         *\/\n+        Type returnType();\n+    }\n+\n+    \/**\n+     * An array type. Array types feature an element type and an optional size. As such they can also be used to\n+     * model array types.\n+     *\/\n+    interface Array extends Type {\n+\n+        \/**\n+         * The array type kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Vector kind.\n+             *\/\n+            VECTOR,\n+            \/**\n+             * Array kind.\n+             *\/\n+            ARRAY,\n+            \/**\n+             * Incomplete array kind.\n+             *\/\n+            INCOMPLETE_ARRAY;\n+        }\n+\n+        \/**\n+         * The array type kind.\n+         * @return The array type kind.\n+         *\/\n+        Kind kind();\n+\n+        \/**\n+         * The (optional) array element count.\n+         * @return The (optional) array element count.\n+         *\n+         * @implSpec an element count is present if the array type kind is one of {@link Kind#VECTOR}, {@link Kind#ARRAY}.\n+         *\/\n+        OptionalLong elementCount();\n+\n+        \/**\n+         * The array type element type.\n+         * @return The array type element type.\n+         *\/\n+        Type elementType();\n+    }\n+\n+    \/**\n+     * A delegated type is used to model a type which contains an indirection to some other underlying type. For instance,\n+     * a delegated type can be used to model foreign pointers, where the indirection is used to model the pointee type.\n+     *\/\n+    interface Delegated extends Type {\n+\n+        \/**\n+         * The delegated type kind.\n+         *\/\n+        enum Kind {\n+            \/**\n+             * Type-defined type.\n+             *\/\n+            TYPEDEF,\n+            \/**\n+             * Pointer type.\n+             *\/\n+            POINTER,\n+            \/**\n+             * Signed type.\n+             *\/\n+            SIGNED,\n+            \/**\n+             * Unsigned type.\n+             *\/\n+            UNSIGNED,\n+            \/**\n+             * Atomic type.\n+             *\/\n+            ATOMIC,\n+            \/**\n+             * Volatile type.\n+             *\/\n+            VOLATILE,\n+            \/**\n+             * Complex type.\n+             *\/\n+            COMPLEX;\n+        }\n+\n+        \/**\n+         * The delegated type kind.\n+         * @return The delegated type kind.\n+         *\/\n+        Kind kind();\n+\n+        \/**\n+         * The delegated type (optional) name.\n+         * @return The delegated type (optional) name.\n+         *\n+         * @implSpec an element count is present if the array type kind is one of {@link Kind#TYPEDEF}.\n+         *\/\n+        Optional<String> name();\n+\n+        \/**\n+         * The delegated type underlying type.\n+         * @return The delegated type underlying type.\n+         *\/\n+        Type type();\n+    }\n+\n+    \/**\n+     * Type visitor interface.\n+     * @param <R> the visitor's return type.\n+     * @param <P> the visitor's parameter type.\n+     *\/\n+    interface Visitor<R,P> {\n+        \/**\n+         * Visit a primitive type.\n+         * @param t the primitive type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given primitive type through this visitor object.\n+         *\/\n+        default R visitPrimitive(Primitive t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a function type.\n+         * @param t the function type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given function type through this visitor object.\n+         *\/\n+        default R visitFunction(Function t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a declared type.\n+         * @param t the declared type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given declared type through this visitor object.\n+         *\/\n+        default R visitDeclared(Declared t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a delegated type.\n+         * @param t the delegated type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given delegated type through this visitor object.\n+         *\/\n+        default R visitDelegated(Delegated t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit an array type.\n+         * @param t the array type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given array type through this visitor object.\n+         *\/\n+        default R visitArray(Array t, P p) { return visitType(t, p); }\n+\n+        \/**\n+         * Visit a type.\n+         * @param t the type.\n+         * @param p the visitor parameter.\n+         * @return the result of visiting the given type through this visitor object.\n+         *\/\n+        default R visitType(Type t, P p) { throw new UnsupportedOperationException(); }\n+    }\n+\n+    \/**\n+     * Compute the layout for a given type.\n+     * @param t the type.\n+     * @return the layout for given type.\n+     *\/\n+    static Optional<MemoryLayout> layoutFor(Type t) {\n+        return LayoutUtils.getLayout(t);\n+    }\n+\n+    \/**\n+     * Compute the function descriptor for a given function type.\n+     * @param function the function type.\n+     * @return the function descriptor for given function type.\n+     *\/\n+    static Optional<FunctionDescriptor> descriptorFor(Function function) {\n+        return LayoutUtils.getDescriptor(function);\n+    }\n+\n+    \/**\n+     * Create the {@code void} type.\n+     * @return the {@code void} type.\n+     *\/\n+    static Type.Primitive void_() {\n+        return new TypeImpl.PrimitiveImpl(Type.Primitive.Kind.Void);\n+    }\n+\n+    \/**\n+     * Creates a new primitive type given kind.\n+     * @param kind the primitive type kind.\n+     * @return a new primitive type with given kind.\n+     *\/\n+    static Type.Primitive primitive(Type.Primitive.Kind kind) {\n+        return new TypeImpl.PrimitiveImpl(kind);\n+    }\n+\n+    \/**\n+     * Creates a new qualified type given kind and underlying type.\n+     * @param kind the qualified type kind.\n+     * @param type the qualified type underlying type.\n+     * @return a new qualified type with given name and underlying type.\n+     *\/\n+    static Type.Delegated qualified(Type.Delegated.Kind kind, Type type) {\n+        return new TypeImpl.QualifiedImpl(kind, type);\n+    }\n+\n+    \/**\n+     * Creates a new typedef type given name and underlying type.\n+     * @param name the typedef type name.\n+     * @param aliased the typeef type underlying type.\n+     * @return a new typedef type with given name and underlying type.\n+     *\/\n+    static Type.Delegated typedef(String name, Type aliased) {\n+        return new TypeImpl.QualifiedImpl(Delegated.Kind.TYPEDEF, name, aliased);\n+    }\n+\n+    \/**\n+     * Creates a new pointer type with no associated pointee information.\n+     * @return a new pointer type with no associated pointee information.\n+     *\/\n+    static Type.Delegated pointer() {\n+        return new TypeImpl.PointerImpl(() -> new TypeImpl.PrimitiveImpl(Type.Primitive.Kind.Void));\n+    }\n+\n+    \/**\n+     * Creates a new pointer type with given pointee type.\n+     * @param pointee the pointee type.\n+     * @return a new pointer type with given pointee type.\n+     *\/\n+    static Type.Delegated pointer(Type pointee) {\n+        return new TypeImpl.PointerImpl(() -> pointee);\n+    }\n+\n+    \/**\n+     * Creates a new pointer type with given pointee type.\n+     * @param pointee factory to (lazily) build the pointee type.\n+     * @return a new pointer type with given pointee type (lazily built from factory).\n+     *\/\n+    static Type.Delegated pointer(Supplier<Type> pointee) {\n+        return new TypeImpl.PointerImpl(pointee);\n+    }\n+\n+    \/**\n+     * Creates a new function type with given parameter types and return type.\n+     * @param varargs is this function type variable-arity?\n+     * @param returnType the function type return type.\n+     * @param arguments the function type formal parameter types.\n+     * @return a new function type with given parameter types and return type.\n+     *\/\n+    static Type.Function function(boolean varargs, Type returnType, Type... arguments) {\n+        return new TypeImpl.FunctionImpl(varargs, Stream.of(arguments).collect(Collectors.toList()), returnType);\n+    }\n+\n+    \/**\n+     * Creates a new declared type with given foreign declaration.\n+     * @param tree the foreign declaration the type refers to.\n+     * @return  a new declared type with given foreign declaration.\n+     *\/\n+    static Type.Declared declared(Declaration.Scoped tree) {\n+        return new TypeImpl.DeclaredImpl(tree);\n+    }\n+\n+    \/**\n+     * Creates a new vector type with given element count and element type.\n+     * @param elementCount the vector type element count.\n+     * @param elementType the vector type element type.\n+     * @return a new vector type with given element count and element type.\n+     *\/\n+    static Type.Array vector(long elementCount, Type elementType) {\n+        return new TypeImpl.ArrayImpl(Array.Kind.VECTOR, elementCount, elementType);\n+    }\n+\n+    \/**\n+     * Creates a new array type with given element count and element type.\n+     * @param elementCount the array type element count.\n+     * @param elementType the array type element type.\n+     * @return a new array type with given element count and element type.\n+     *\/\n+    static Type.Array array(long elementCount, Type elementType) {\n+        return new TypeImpl.ArrayImpl(Array.Kind.ARRAY, elementCount, elementType);\n+    }\n+\n+    \/**\n+     * Creates a new array type with given element type.\n+     * @param elementType the array type element type.\n+     * @return a new array type with given element type.\n+     *\/\n+    static Type.Array array(Type elementType) {\n+        return new TypeImpl.ArrayImpl(Array.Kind.INCOMPLETE_ARRAY, elementType);\n+    }\n+\n+    \/**\n+     * Creates an erroneous type.\n+     * @return an erroneous type.\n+     *\/\n+    static Type error() {\n+        return TypeImpl.ERROR;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Type.java","additions":514,"deletions":0,"binary":false,"changes":514,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import static jdk.internal.clang.libclang.Index_h.*;\n+\n+public enum CallingConvention {\n+\n+    Default(CXCallingConv_Default()),\n+    C(CXCallingConv_C()),\n+    X86StdCall(CXCallingConv_X86StdCall()),\n+    X86FastCall(CXCallingConv_X86FastCall()),\n+    X86ThisCall(CXCallingConv_X86ThisCall()),\n+    X86Pascal(CXCallingConv_X86Pascal()),\n+    AAPCS(CXCallingConv_AAPCS()),\n+    AAPCS_VFP(CXCallingConv_AAPCS_VFP()),\n+    PnaclCall(CXCallingConv_X86RegCall()),\n+    IntelOclBicc(CXCallingConv_IntelOclBicc()),\n+    X86_64Win64(CXCallingConv_X86_64Win64()),\n+    X86_64SysV(CXCallingConv_X86_64SysV()),\n+    Invalid(CXCallingConv_Invalid()),\n+    Unexposed(CXCallingConv_Unexposed());\n+\n+    private final int value;\n+\n+    CallingConvention(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, CallingConvention> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (CallingConvention e: CallingConvention.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static CallingConvention valueOf(int value) {\n+        CallingConvention x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException();\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/CallingConvention.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.clang.libclang.CXCursorVisitor;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+import java.util.ArrayList;\n+import java.util.stream.Stream;\n+\n+public final class Cursor {\n+\n+    private final MemorySegment cursor;\n+    private final int kind;\n+\n+    Cursor(MemorySegment cursor) {\n+        this.cursor = cursor;\n+        kind = Index_h.clang_getCursorKind(cursor);\n+    }\n+\n+    public boolean isDeclaration() {\n+        return Index_h.clang_isDeclaration(kind) != 0;\n+    }\n+\n+    public boolean isPreprocessing() {\n+        return Index_h.clang_isPreprocessing(kind) != 0;\n+    }\n+\n+    public boolean isInvalid() {\n+        return Index_h.clang_isInvalid(kind) != 0;\n+    }\n+\n+    public boolean isDefinition() {\n+        return Index_h.clang_isCursorDefinition(cursor) != 0;\n+    }\n+\n+    public boolean isAttribute() { return Index_h.clang_isAttribute(kind) != 0; }\n+\n+    public boolean isAnonymousStruct() {\n+        return Index_h.clang_Cursor_isAnonymousRecordDecl(cursor) != 0;\n+    }\n+\n+    public boolean isMacroFunctionLike() {\n+        return Index_h.clang_Cursor_isMacroFunctionLike(cursor) != 0;\n+    }\n+\n+    public String spelling() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return LibClang.CXStrToString(\n+                Index_h.clang_getCursorSpelling(scope, cursor));\n+        }\n+    }\n+\n+    public String USR() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return LibClang.CXStrToString(\n+                Index_h.clang_getCursorUSR(scope, cursor));\n+        }\n+    }\n+\n+    public String prettyPrinted(PrintingPolicy policy) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return LibClang.CXStrToString(\n+                Index_h.clang_getCursorPrettyPrinted(scope, cursor, policy.ptr()));\n+        }\n+    }\n+\n+    public String prettyPrinted() {\n+        try (PrintingPolicy policy = getPrintingPolicy()) {\n+            return prettyPrinted(policy);\n+        }\n+    }\n+\n+    public String displayName() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return LibClang.CXStrToString(\n+                Index_h.clang_getCursorDisplayName(scope, cursor));\n+        }\n+    }\n+\n+    public boolean equalCursor(Cursor other) {\n+        return Index_h.clang_equalCursors(cursor, other.cursor) != 0;\n+    }\n+\n+    public Type type() {\n+        return new Type(Index_h.clang_getCursorType(ResourceScope.newImplicitScope(), cursor));\n+    }\n+\n+    public Type getEnumDeclIntegerType() {\n+        return new Type(Index_h.clang_getEnumDeclIntegerType(ResourceScope.newImplicitScope(), cursor));\n+    }\n+\n+    public Cursor getDefinition() {\n+        return new Cursor(Index_h.clang_getCursorDefinition(ResourceScope.newImplicitScope(), cursor));\n+    }\n+\n+    public SourceLocation getSourceLocation() {\n+        MemorySegment loc = Index_h.clang_getCursorLocation(ResourceScope.newImplicitScope(), cursor);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            if (Index_h.clang_equalLocations(loc, Index_h.clang_getNullLocation(scope)) != 0) {\n+                return null;\n+            }\n+        }\n+        return new SourceLocation(loc);\n+    }\n+\n+    public SourceRange getExtent() {\n+        MemorySegment range = Index_h.clang_getCursorExtent(ResourceScope.newImplicitScope(), cursor);\n+        if (Index_h.clang_Range_isNull(range) != 0) {\n+            return null;\n+        }\n+        return new SourceRange(range);\n+    }\n+\n+    public int numberOfArgs() {\n+        return Index_h.clang_Cursor_getNumArguments(cursor);\n+    }\n+\n+    public Cursor getArgument(int idx) {\n+        return new Cursor(Index_h.clang_Cursor_getArgument(ResourceScope.newImplicitScope(), cursor, idx));\n+    }\n+\n+    \/\/ C long long, 64-bit\n+    public long getEnumConstantValue() {\n+        return Index_h.clang_getEnumConstantDeclValue(cursor);\n+    }\n+\n+    \/\/ C unsigned long long, 64-bit\n+    public long getEnumConstantUnsignedValue() {\n+        return Index_h.clang_getEnumConstantDeclUnsignedValue(cursor);\n+    }\n+\n+    public boolean isBitField() {\n+        return Index_h.clang_Cursor_isBitField(cursor) != 0;\n+    }\n+\n+    public int getBitFieldWidth() {\n+        return Index_h.clang_getFieldDeclBitWidth(cursor);\n+    }\n+\n+    public CursorKind kind() {\n+        return CursorKind.valueOf(kind);\n+    }\n+\n+    public CursorLanguage language() {\n+        return CursorLanguage.valueOf(Index_h.clang_getCursorLanguage(cursor));\n+    }\n+\n+    public int kind0() {\n+        return kind;\n+    }\n+\n+    \/**\n+     * For a cursor that is a reference, retrieve a cursor representing the entity that it references.\n+     *\/\n+    public Cursor getCursorReferenced() {\n+        return new Cursor(Index_h.clang_getCursorReferenced(ResourceScope.newImplicitScope(), cursor));\n+    }\n+\n+    private static class CursorChildren {\n+        private static final ArrayList<Cursor> children = new ArrayList<>();\n+        private static final MemoryAddress callback = CXCursorVisitor.allocate((c, p, d) -> {\n+            MemorySegment copy = MemorySegment.allocateNative(c.byteSize(), ResourceScope.newImplicitScope());\n+            copy.copyFrom(c);\n+            Cursor cursor = new Cursor(copy);\n+            children.add(cursor);\n+            return Index_h.CXChildVisit_Continue();\n+        });\n+\n+        synchronized static Stream<Cursor> get(Cursor c) {\n+            try {\n+                Index_h.clang_visitChildren(c.cursor, callback, MemoryAddress.NULL);\n+                return new ArrayList<>(children).stream();\n+            } finally {\n+                children.clear();\n+            }\n+        }\n+    }\n+\n+    public Stream<Cursor> children() {\n+        return CursorChildren.get(this);\n+    }\n+\n+    public Stream<Cursor> allChildren() {\n+        return children().flatMap(c -> Stream.concat(Stream.of(c), c.children()));\n+    }\n+\n+    public String getMangling() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return LibClang.CXStrToString(\n+                Index_h.clang_Cursor_getMangling(scope, cursor));\n+        }\n+    }\n+\n+    public TranslationUnit getTranslationUnit() {\n+        return new TranslationUnit(Index_h.clang_Cursor_getTranslationUnit(cursor));\n+    }\n+\n+    private MemoryAddress eval0() {\n+        return Index_h.clang_Cursor_Evaluate(cursor);\n+    }\n+\n+    public EvalResult eval() {\n+        MemoryAddress ptr = eval0();\n+        return ptr == MemoryAddress.NULL ? EvalResult.erroneous : new EvalResult(ptr);\n+    }\n+\n+    public PrintingPolicy getPrintingPolicy() {\n+        return new PrintingPolicy(Index_h.clang_getCursorPrintingPolicy(cursor));\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!(other instanceof Cursor)) {\n+            return false;\n+        }\n+        return (Index_h.clang_equalCursors(cursor, ((Cursor)other).cursor) != 0);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return spelling().hashCode();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Cursor.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import static jdk.internal.clang.libclang.Index_h.*;\n+\n+public enum CursorKind {\n+\n+    UnexposedDecl(CXCursor_UnexposedDecl()),\n+    StructDecl(CXCursor_StructDecl()),\n+    UnionDecl(CXCursor_UnionDecl()),\n+    ClassDecl(CXCursor_ClassDecl()),\n+    EnumDecl(CXCursor_EnumDecl()),\n+    FieldDecl(CXCursor_FieldDecl()),\n+    EnumConstantDecl(CXCursor_EnumConstantDecl()),\n+    FunctionDecl(CXCursor_FunctionDecl()),\n+    VarDecl(CXCursor_VarDecl()),\n+    ParmDecl(CXCursor_ParmDecl()),\n+    TypedefDecl(CXCursor_TypedefDecl()),\n+    Namespace(CXCursor_Namespace()),\n+    IntegerLiteral(CXCursor_IntegerLiteral()),\n+    FloatingLiteral(CXCursor_FloatingLiteral()),\n+    ImaginaryLiteral(CXCursor_ImaginaryLiteral()),\n+    StringLiteral(CXCursor_StringLiteral()),\n+    CharacterLiteral(CXCursor_CharacterLiteral()),\n+    UnexposedAttr(CXCursor_UnexposedAttr()),\n+    IBActionAttr(CXCursor_IBActionAttr()),\n+    IBOutletAttr(CXCursor_IBOutletAttr()),\n+    IBOutletCollectionAttr(CXCursor_IBOutletCollectionAttr()),\n+    CXXFinalAttr(CXCursor_CXXFinalAttr()),\n+    CXXOverrideAttr(CXCursor_CXXOverrideAttr()),\n+    AnnotateAttr(CXCursor_AnnotateAttr()),\n+    AsmLabelAttr(CXCursor_AsmLabelAttr()),\n+    PackedAttr(CXCursor_PackedAttr()),\n+    PureAttr(CXCursor_PureAttr()),\n+    ConstAttr(CXCursor_ConstAttr()),\n+    NoDuplicateAttr(CXCursor_NoDuplicateAttr()),\n+    CUDAConstantAttr(CXCursor_CUDAConstantAttr()),\n+    CUDADeviceAttr(CXCursor_CUDADeviceAttr()),\n+    CUDAGlobalAttr(CXCursor_CUDAGlobalAttr()),\n+    CUDAHostAttr(CXCursor_CUDAHostAttr()),\n+    CUDASharedAttr(CXCursor_CUDASharedAttr()),\n+    VisibilityAttr(CXCursor_VisibilityAttr()),\n+    DLLExport(CXCursor_DLLExport()),\n+    DLLImport(CXCursor_DLLImport()),\n+    NSReturnsRetained(CXCursor_NSReturnsRetained()),\n+    NSReturnsNotRetained(CXCursor_NSReturnsNotRetained()),\n+    NSReturnsAutoreleased(CXCursor_NSReturnsAutoreleased()),\n+    NSConsumesSelf(CXCursor_NSConsumesSelf()),\n+    NSConsumed(CXCursor_NSConsumed()),\n+    ObjCException(CXCursor_ObjCException()),\n+    ObjCNSObject(CXCursor_ObjCNSObject()),\n+    ObjCIndependentClass(CXCursor_ObjCIndependentClass()),\n+    ObjCPreciseLifetime(CXCursor_ObjCPreciseLifetime()),\n+    ObjCReturnsInnerPointer(CXCursor_ObjCReturnsInnerPointer()),\n+    ObjCRequiresSuper(CXCursor_ObjCRequiresSuper()),\n+    ObjCRootClass(CXCursor_ObjCRootClass()),\n+    ObjCSubclassingRestricted(CXCursor_ObjCSubclassingRestricted()),\n+    ObjCExplicitProtocolImpl(CXCursor_ObjCExplicitProtocolImpl()),\n+    ObjCDesignatedInitializer(CXCursor_ObjCDesignatedInitializer()),\n+    ObjCRuntimeVisible(CXCursor_ObjCRuntimeVisible()),\n+    ObjCBoxable(CXCursor_ObjCBoxable()),\n+    FlagEnum(CXCursor_FlagEnum()),\n+    ConvergentAttr(CXCursor_ConvergentAttr()),\n+    WarnUnusedAttr(CXCursor_WarnUnusedAttr()),\n+    WarnUnusedResultAttr(CXCursor_WarnUnusedResultAttr()),\n+    AlignedAttr(CXCursor_AlignedAttr()),\n+    MacroDefinition(CXCursor_MacroDefinition()),\n+    MacroExpansion(CXCursor_MacroExpansion()),\n+    MacroInstantiation(CXCursor_MacroInstantiation()),\n+    InclusionDirective(CXCursor_InclusionDirective());\n+\n+    private final int value;\n+\n+    CursorKind(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, CursorKind> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (CursorKind e: CursorKind.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static CursorKind valueOf(int value) {\n+        CursorKind x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"Invalid Cursor kind value: \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/CursorKind.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.clang.libclang.Index_h.*;\n+\n+public enum CursorLanguage {\n+    Invalid(CXLanguage_Invalid(), \"Invalid\"),\n+    C(CXLanguage_C(), \"C\"),\n+    ObjC(CXLanguage_ObjC(), \"Objective C\"),\n+    CPlusPlus(CXLanguage_CPlusPlus(), \"C++\");\n+\n+    private final int code;\n+    private final String name;\n+\n+    CursorLanguage(int code, String name) {\n+        this.code = code;\n+        this.name = name;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    private static final Map<Integer, CursorLanguage> lookup = Arrays.stream(values())\n+            .collect(toMap(CursorLanguage::code, Function.identity()));\n+\n+    public static CursorLanguage valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No CursorLanguage with code: \" + k); });\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/CursorLanguage.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+public class Diagnostic {\n+    final MemoryAddress ptr;\n+\n+    \/\/ Various Diagnostic severity levels - from Clang enum CXDiagnosticSeverity\n+\n+    \/**\n+     * A diagnostic that has been suppressed, e.g., by a command-line\n+     * option.\n+     *\/\n+    public static final int CXDiagnostic_Ignored = Index_h.CXDiagnostic_Ignored();\n+\n+    \/**\n+     * This diagnostic is a note that should be attached to the\n+     * previous (non-note) diagnostic.\n+     *\/\n+    public static final int CXDiagnostic_Note    = Index_h.CXDiagnostic_Note();\n+\n+    \/**\n+     * This diagnostic indicates suspicious code that may not be\n+     * wrong.\n+     *\/\n+    public static final int CXDiagnostic_Warning = Index_h.CXDiagnostic_Warning();\n+\n+    \/**\n+     * This diagnostic indicates that the code is ill-formed.\n+     *\/\n+    public static final int CXDiagnostic_Error   = Index_h.CXDiagnostic_Error();\n+\n+    \/**\n+     * This diagnostic indicates that the code is ill-formed such\n+     * that future parser recovery is unlikely to produce useful\n+     * results.\n+     *\/\n+    public static final int CXDiagnostic_Fatal   = Index_h.CXDiagnostic_Fatal();\n+\n+    Diagnostic(MemoryAddress ptr) {\n+        this.ptr = ptr;\n+    }\n+\n+    public int severity() {\n+        return Index_h.clang_getDiagnosticSeverity(ptr);\n+    }\n+\n+    public SourceLocation location() {\n+        return new SourceLocation(Index_h.clang_getDiagnosticLocation(ResourceScope.newImplicitScope(), ptr));\n+    }\n+\n+    public String spelling() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+           return LibClang.CXStrToString(\n+                Index_h.clang_getDiagnosticSpelling(scope, ptr));\n+        }\n+    }\n+\n+    public void dispose() {\n+        Index_h.clang_disposeDiagnostic(ptr);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return LibClang.CXStrToString(\n+                Index_h.clang_formatDiagnostic(scope, ptr,\n+                    Index_h.clang_defaultDiagnosticDisplayOptions()));\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Diagnostic.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.clang.libclang.Index_h.*;\n+\n+public enum ErrorCode {\n+    Success(CXError_Success()),\n+    Failure(CXError_Failure()),\n+    Crashed(CXError_Crashed()),\n+    InvalidArguments(CXError_InvalidArguments()),\n+    ASTReadError(CXError_ASTReadError());\n+\n+    private final int code;\n+\n+    ErrorCode(int code) {\n+        this.code = code;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    private static final Map<Integer, ErrorCode> lookup = Arrays.stream(values())\n+            .collect(toMap(ErrorCode::code, Function.identity()));\n+\n+    public static ErrorCode valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No ErrorCode with code: \" + k); });\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/ErrorCode.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+public class EvalResult implements AutoCloseable {\n+    private MemoryAddress ptr;\n+\n+    public EvalResult(MemoryAddress ptr) {\n+        this.ptr = ptr;\n+    }\n+\n+    public enum Kind {\n+        Integral,\n+        FloatingPoint,\n+        StrLiteral,\n+        Erroneous,\n+        Unknown\n+    }\n+\n+    private int getKind0() {\n+        return Index_h.clang_EvalResult_getKind(ptr);\n+    }\n+\n+    public Kind getKind() {\n+        int code = getKind0();\n+        switch (code) {\n+            case 1: return Kind.Integral;\n+            case 2: return Kind.FloatingPoint;\n+            case 3: case 4: case 5:\n+                return Kind.StrLiteral;\n+            default:\n+                return Kind.Unknown;\n+        }\n+    }\n+\n+    private long getAsInt0() {\n+        return Index_h.clang_EvalResult_getAsLongLong(ptr);\n+    }\n+\n+    public long getAsInt() {\n+        Kind kind = getKind();\n+        switch (kind) {\n+            case Integral:\n+                return getAsInt0();\n+            default:\n+                throw new IllegalStateException(\"Unexpected kind: \" + kind);\n+        }\n+    }\n+\n+    private double getAsFloat0() {\n+        return Index_h.clang_EvalResult_getAsDouble(ptr);\n+    }\n+\n+    public double getAsFloat() {\n+        Kind kind = getKind();\n+        switch (kind) {\n+            case FloatingPoint:\n+                return getAsFloat0();\n+            default:\n+                throw new IllegalStateException(\"Unexpected kind: \" + kind);\n+        }\n+    }\n+\n+    private String getAsString0() {\n+        MemoryAddress value = Index_h.clang_EvalResult_getAsStr(ptr);\n+        return CLinker.toJavaString(value);\n+    }\n+\n+    public String getAsString() {\n+        Kind kind = getKind();\n+        switch (kind) {\n+            case StrLiteral:\n+                return getAsString0();\n+            default:\n+                throw new IllegalStateException(\"Unexpected kind: \" + kind);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (ptr != MemoryAddress.NULL) {\n+            Index_h.clang_EvalResult_dispose(ptr);\n+            ptr = MemoryAddress.NULL;\n+        }\n+    }\n+\n+    final static EvalResult erroneous = new EvalResult(MemoryAddress.NULL) {\n+        @Override\n+        public Kind getKind() {\n+            return Kind.Erroneous;\n+        }\n+\n+        @Override\n+        public void close() {\n+            \/\/do nothing\n+        }\n+    };\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/EvalResult.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+\n+public class Index implements AutoCloseable {\n+    \/\/ Pointer to CXIndex\n+    private MemoryAddress ptr;\n+    \/\/ Set of TranslationUnit\n+    public final List<TranslationUnit> translationUnits;\n+\n+    Index(MemoryAddress ptr) {\n+        this.ptr = ptr;\n+        translationUnits = new ArrayList<>();\n+    }\n+\n+    public static class UnsavedFile {\n+        final String file;\n+        final String contents;\n+\n+        private UnsavedFile(Path path, String contents) {\n+            this.file = path.toAbsolutePath().toString();\n+            this.contents = contents;\n+        }\n+\n+        public static UnsavedFile of(Path path, String contents) {\n+            return new UnsavedFile(path, contents);\n+        }\n+    }\n+\n+    public static class ParsingFailedException extends RuntimeException {\n+        private static final long serialVersionUID = -1L;\n+        private final Path srcFile;\n+        private final ErrorCode code;\n+\n+        public ParsingFailedException(Path srcFile, ErrorCode code) {\n+            super(\"Failed to parse \" + srcFile.toAbsolutePath().toString() + \": \" + code);\n+            this.srcFile = srcFile;\n+            this.code = code;\n+        }\n+    }\n+\n+    private static final VarHandle VH_MemoryAddress =\n+            MemoryHandles.asAddressVarHandle(CLinker.C_POINTER.varHandle(long.class));\n+\n+    public TranslationUnit parseTU(String file, Consumer<Diagnostic> dh, int options, String... args)\n+            throws ParsingFailedException {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n+            MemorySegment src = CLinker.toCString(file, scope);\n+            MemorySegment cargs = args.length == 0 ? null : allocator.allocateArray(CLinker.C_POINTER, args.length);\n+            for (int i = 0 ; i < args.length ; i++) {\n+                MemoryAccess.setAddressAtIndex(cargs, i, CLinker.toCString(args[i], scope));\n+            }\n+            MemorySegment outAddress = allocator.allocate(CLinker.C_POINTER);\n+            ErrorCode code = ErrorCode.valueOf(Index_h.clang_parseTranslationUnit2(\n+                    ptr,\n+                    src,\n+                    cargs == null ? MemoryAddress.NULL : cargs,\n+                    args.length, MemoryAddress.NULL,\n+                    0,\n+                    options,\n+                    outAddress));\n+\n+            MemoryAddress tu = (MemoryAddress) VH_MemoryAddress.get(outAddress);\n+            TranslationUnit rv = new TranslationUnit(tu);\n+            \/\/ even if we failed to parse, we might still have diagnostics\n+            rv.processDiagnostics(dh);\n+\n+            if (code != ErrorCode.Success) {\n+                throw new ParsingFailedException(Path.of(file).toAbsolutePath(), code);\n+            }\n+\n+            translationUnits.add(rv);\n+            return rv;\n+        }\n+    }\n+\n+    private int defaultOptions(boolean detailedPreprocessorRecord) {\n+        int rv = Index_h.CXTranslationUnit_ForSerialization();\n+        rv |= Index_h.CXTranslationUnit_SkipFunctionBodies();\n+        if (detailedPreprocessorRecord) {\n+            rv |= Index_h.CXTranslationUnit_DetailedPreprocessingRecord();\n+        }\n+        return rv;\n+    }\n+\n+    public TranslationUnit parse(String file, Consumer<Diagnostic> dh, boolean detailedPreprocessorRecord, String... args)\n+    throws ParsingFailedException {\n+        return parseTU(file, dh, defaultOptions(detailedPreprocessorRecord), args);\n+    }\n+\n+    public TranslationUnit parse(String file, boolean detailedPreprocessorRecord, String... args)\n+    throws ParsingFailedException {\n+        return parse(file, dh -> {}, detailedPreprocessorRecord, args);\n+    }\n+\n+    @Override\n+    public void close() {\n+        dispose();\n+    }\n+\n+    public void dispose() {\n+        for (TranslationUnit tu: translationUnits) {\n+            tu.dispose();\n+        }\n+        if (ptr != MemoryAddress.NULL) {\n+            Index_h.clang_disposeIndex(ptr);\n+        }\n+        ptr = MemoryAddress.NULL;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Index.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+public class LibClang {\n+    private static final boolean DEBUG = Boolean.getBoolean(\"libclang.debug\");\n+    private static final boolean CRASH_RECOVERY = Boolean.getBoolean(\"libclang.crash_recovery\");\n+    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\").startsWith(\"Windows\");\n+\n+    private final static MemorySegment disableCrashRecovery =\n+            CLinker.toCString(\"LIBCLANG_DISABLE_CRASH_RECOVERY=\" + CRASH_RECOVERY, ResourceScope.newImplicitScope());\n+\n+    static {\n+        if (!CRASH_RECOVERY) {\n+            \/\/this is an hack - needed because clang_toggleCrashRecovery only takes effect _after_ the\n+            \/\/first call to createIndex.\n+            try {\n+                CLinker linker = CLinker.getInstance();\n+                String putenv = IS_WINDOWS ? \"_putenv\" : \"putenv\";\n+                MethodHandle PUT_ENV = linker.downcallHandle(CLinker.systemLookup().lookup(putenv).get(),\n+                                MethodType.methodType(int.class, MemoryAddress.class),\n+                                FunctionDescriptor.of(CLinker.C_INT, CLinker.C_POINTER));\n+                int res = (int) PUT_ENV.invokeExact(disableCrashRecovery.address());\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n+            }\n+        }\n+    }\n+\n+    public static Index createIndex(boolean local) {\n+        Index index = new Index(Index_h.clang_createIndex(local ? 1 : 0, 0));\n+        if (DEBUG) {\n+            System.err.println(\"LibClang crash recovery \" + (CRASH_RECOVERY ? \"enabled\" : \"disabled\"));\n+        }\n+        return index;\n+    }\n+\n+    public static String CXStrToString(MemorySegment cxstr) {\n+        MemoryAddress buf = Index_h.clang_getCString(cxstr);\n+        String str = CLinker.toJavaString(buf);\n+        Index_h.clang_disposeString(cxstr);\n+        return str;\n+    }\n+\n+    public static String version() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return CXStrToString(Index_h.clang_getClangVersion(scope));\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/LibClang.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+public final class PrintingPolicy implements AutoCloseable {\n+    private MemoryAddress policy;\n+\n+    PrintingPolicy(MemoryAddress policy) {\n+        this.policy = policy;\n+    }\n+\n+    MemoryAddress ptr() {\n+        return policy;\n+    }\n+\n+    @Override\n+    public void close() {\n+        dispose();\n+    }\n+\n+    public void dispose() {\n+        if (policy != MemoryAddress.NULL) {\n+            Index_h.clang_PrintingPolicy_dispose(policy);\n+            policy = MemoryAddress.NULL;\n+        }\n+    }\n+\n+    public boolean getProperty(PrintingPolicyProperty prop) {\n+        return Index_h.clang_PrintingPolicy_getProperty(policy, prop.value()) != 0;\n+    }\n+\n+    public void setProperty(PrintingPolicyProperty prop, boolean value) {\n+        Index_h.clang_PrintingPolicy_setProperty(policy, prop.value(), value? 1 : 0);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/PrintingPolicy.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import static jdk.internal.clang.libclang.Index_h.*;\n+\n+public enum PrintingPolicyProperty {\n+    Indentation(CXPrintingPolicy_Indentation()),\n+    SuppressSpecifiers(CXPrintingPolicy_SuppressSpecifiers()),\n+    SuppressTagKeyword(CXPrintingPolicy_SuppressTagKeyword()),\n+    IncludeTagDefinition(CXPrintingPolicy_IncludeTagDefinition()),\n+    SuppressScope(CXPrintingPolicy_SuppressScope()),\n+    SuppressUnwrittenScope(CXPrintingPolicy_SuppressUnwrittenScope()),\n+    SuppressInitializers(CXPrintingPolicy_SuppressInitializers()),\n+    ConstantArraySizeAsWritten(CXPrintingPolicy_ConstantArraySizeAsWritten()),\n+    AnonymousTagLocations(CXPrintingPolicy_AnonymousTagLocations()),\n+    SuppressStrongLifetime(CXPrintingPolicy_SuppressStrongLifetime()),\n+    SuppressLifetimeQualifiers(CXPrintingPolicy_SuppressLifetimeQualifiers()),\n+    SuppressTemplateArgsInCXXConstructors(CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors()),\n+    Bool(CXPrintingPolicy_Bool()),\n+    Restrict(CXPrintingPolicy_Restrict()),\n+    Alignof(CXPrintingPolicy_Alignof()),\n+    UnderscoreAlignof(CXPrintingPolicy_UnderscoreAlignof()),\n+    UseVoidForZeroParams(CXPrintingPolicy_UseVoidForZeroParams()),\n+    TerseOutput(CXPrintingPolicy_TerseOutput()),\n+    PolishForDeclaration(CXPrintingPolicy_PolishForDeclaration()),\n+    Half(CXPrintingPolicy_Half()),\n+    MSWChar(CXPrintingPolicy_MSWChar()),\n+    IncludeNewlines(CXPrintingPolicy_IncludeNewlines()),\n+    MSVCFormatting(CXPrintingPolicy_MSVCFormatting()),\n+    ConstantsAsWritten(CXPrintingPolicy_ConstantsAsWritten()),\n+    SuppressImplicitBase(CXPrintingPolicy_SuppressImplicitBase()),\n+    FullyQualifiedName(CXPrintingPolicy_FullyQualifiedName()),\n+    LastProperty(CXPrintingPolicy_LastProperty());\n+\n+    private final int value;\n+\n+    PrintingPolicyProperty(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, PrintingPolicyProperty> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (PrintingPolicyProperty e: PrintingPolicyProperty.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static PrintingPolicyProperty valueOf(int value) {\n+        PrintingPolicyProperty x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"Invalid PrintingPolicyProperty value: \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/PrintingPolicyProperty.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.function.Function;\n+\n+import static java.util.stream.Collectors.toMap;\n+import static jdk.internal.clang.libclang.Index_h.*;\n+\n+public enum SaveError {\n+    None(CXSaveError_None()),\n+    Unknown(CXSaveError_Unknown()),\n+    TranslationErrors(CXSaveError_TranslationErrors()),\n+    InvalidTU(CXSaveError_InvalidTU());\n+\n+    private final int code;\n+\n+    SaveError(int code) {\n+        this.code = code;\n+    }\n+\n+    public int code() {\n+        return code;\n+    }\n+\n+    private static final Map<Integer, SaveError> lookup = Arrays.stream(values())\n+            .collect(toMap(SaveError::code, Function.identity()));\n+\n+    public static SaveError valueOf(int code) {\n+        return lookup.computeIfAbsent(code, k -> { throw new NoSuchElementException(\"No SaveError with code: \" + k); });\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SaveError.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Objects;\n+\n+public class SourceLocation {\n+\n+    private final MemorySegment loc;\n+\n+    SourceLocation(MemorySegment loc) {\n+        this.loc = loc;\n+    }\n+\n+    @FunctionalInterface\n+    private interface LocationFactory {\n+        void get(MemorySegment loc, Addressable file,\n+                 Addressable line, Addressable column, Addressable offset);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Location getLocation(LocationFactory fn) {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+             MemorySegment file = MemorySegment.allocateNative(CLinker.C_POINTER, scope);\n+             MemorySegment line = MemorySegment.allocateNative(CLinker.C_INT, scope);\n+             MemorySegment col = MemorySegment.allocateNative(CLinker.C_INT, scope);\n+             MemorySegment offset = MemorySegment.allocateNative(CLinker.C_INT, scope);\n+\n+            fn.get(loc, file, line, col, offset);\n+            MemoryAddress fname = MemoryAccess.getAddress(file);\n+            String str = fname == MemoryAddress.NULL ?  null : getFileName(fname);\n+\n+            return new Location(str, MemoryAccess.getInt(line),\n+                MemoryAccess.getInt(col), MemoryAccess.getInt(offset));\n+        }\n+    }\n+\n+    private static String getFileName(MemoryAddress fname) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return LibClang.CXStrToString(Index_h.clang_getFileName(scope, fname));\n+        }\n+    }\n+\n+    public Location getFileLocation() { return getLocation(Index_h::clang_getFileLocation); }\n+    public Location getExpansionLocation() { return getLocation(Index_h::clang_getExpansionLocation); }\n+    public Location getSpellingLocation() { return getLocation(Index_h::clang_getSpellingLocation); }\n+    public boolean isInSystemHeader() {\n+        return Index_h.clang_Location_isInSystemHeader(loc) != 0;\n+    }\n+\n+    public boolean isFromMainFile() {\n+        return Index_h.clang_Location_isFromMainFile(loc) != 0;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!(other instanceof SourceLocation)) {\n+            return false;\n+        }\n+        SourceLocation sloc = (SourceLocation)other;\n+        return Objects.equals(getFileLocation(), sloc.getFileLocation());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return getFileLocation().hashCode();\n+    }\n+\n+    public final static class Location {\n+        private final Path path;\n+        private final int line;\n+        private final int column;\n+        private final int offset;\n+\n+        private Location(String filename, int line, int column, int offset) {\n+            if (filename == null || filename.isEmpty()) {\n+                this.path = null;\n+            } else {\n+                this.path = Paths.get(filename);\n+            }\n+\n+            this.line = line;\n+            this.column = column;\n+            this.offset = offset;\n+        }\n+\n+        public Path path() {\n+            return path;\n+        }\n+\n+        public int line() {\n+            return line;\n+        }\n+\n+        public int column() {\n+            return column;\n+        }\n+\n+        public int offset() {\n+            return offset;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            if (this == other) {\n+                return true;\n+            }\n+            if (!(other instanceof Location)) {\n+                return false;\n+            }\n+            Location loc = (Location)other;\n+            return Objects.equals(path, loc.path) &&\n+                line == loc.line && column == loc.column &&\n+                offset == loc.offset;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hashCode(path) ^ line ^ column ^ offset;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Objects.toString(path) + \":\" + line + \":\" + column + \":\" + offset;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SourceLocation.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+public class SourceRange {\n+    final MemorySegment range;\n+\n+    SourceRange(MemorySegment range) {\n+        this.range = range;\n+    }\n+\n+    public SourceLocation getBegin() {\n+        MemorySegment loc = Index_h.clang_getRangeStart(ResourceScope.newImplicitScope(), range);\n+        return new SourceLocation(loc);\n+    }\n+\n+    public SourceLocation getEnd() {\n+        MemorySegment loc = Index_h.clang_getRangeEnd(ResourceScope.newImplicitScope(), range);\n+        return new SourceLocation(loc);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/SourceRange.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.internal.clang.libclang.CXToken;\n+import jdk.internal.clang.libclang.Index_h;\n+import jdk.internal.clang.libclang.CXUnsavedFile;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+public class TranslationUnit implements AutoCloseable {\n+\n+    private MemoryAddress tu;\n+\n+    TranslationUnit(MemoryAddress tu) {\n+        this.tu = tu;\n+    }\n+\n+    public Cursor getCursor() {\n+        return new Cursor(Index_h.clang_getTranslationUnitCursor(ResourceScope.newImplicitScope(), tu));\n+    }\n+\n+    public Diagnostic[] getDiagnostics() {\n+        int cntDiags = Index_h.clang_getNumDiagnostics(tu);\n+        Diagnostic[] rv = new Diagnostic[cntDiags];\n+        for (int i = 0; i < cntDiags; i++) {\n+            MemoryAddress diag = Index_h.clang_getDiagnostic(tu, i);\n+            rv[i] = new Diagnostic(diag);\n+        }\n+\n+        return rv;\n+    }\n+\n+    public final void save(Path path) throws TranslationUnitSaveException {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment pathStr = CLinker.toCString(path.toAbsolutePath().toString(), scope);\n+            SaveError res = SaveError.valueOf(Index_h.clang_saveTranslationUnit(tu, pathStr, 0));\n+            if (res != SaveError.None) {\n+                throw new TranslationUnitSaveException(path, res);\n+            }\n+        }\n+    }\n+\n+    void processDiagnostics(Consumer<Diagnostic> dh) {\n+        Objects.requireNonNull(dh);\n+        for (Diagnostic diag : getDiagnostics()) {\n+            dh.accept(diag);\n+        }\n+    }\n+\n+    static long FILENAME_OFFSET = CXUnsavedFile.$LAYOUT().byteOffset(MemoryLayout.PathElement.groupElement(\"Filename\"));\n+    static long CONTENTS_OFFSET = CXUnsavedFile.$LAYOUT().byteOffset(MemoryLayout.PathElement.groupElement(\"Contents\"));\n+    static long LENGTH_OFFSET = CXUnsavedFile.$LAYOUT().byteOffset(MemoryLayout.PathElement.groupElement(\"Length\"));\n+\n+    public void reparse(Index.UnsavedFile... inMemoryFiles) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n+            MemorySegment files = inMemoryFiles.length == 0 ?\n+                    null :\n+                    allocator.allocateArray(CXUnsavedFile.$LAYOUT(), inMemoryFiles.length);\n+            for (int i = 0; i < inMemoryFiles.length; i++) {\n+                MemorySegment start = files.asSlice(i * CXUnsavedFile.$LAYOUT().byteSize());\n+                MemoryAccess.setAddress(start.asSlice(FILENAME_OFFSET), CLinker.toCString(inMemoryFiles[i].file, scope));\n+                MemoryAccess.setAddress(start.asSlice(CONTENTS_OFFSET), CLinker.toCString(inMemoryFiles[i].contents, scope));\n+                MemoryAccess.setLong(start.asSlice(LENGTH_OFFSET), inMemoryFiles[i].contents.length());\n+            }\n+            ErrorCode code = ErrorCode.valueOf(Index_h.clang_reparseTranslationUnit(\n+                        tu,\n+                        inMemoryFiles.length,\n+                        files == null ? MemoryAddress.NULL : files,\n+                        Index_h.clang_defaultReparseOptions(tu)));\n+\n+            if (code != ErrorCode.Success) {\n+                throw new IllegalStateException(\"Re-parsing failed: \" + code);\n+            }\n+        }\n+    }\n+\n+    public void reparse(Consumer<Diagnostic> dh, Index.UnsavedFile... inMemoryFiles) {\n+        reparse(inMemoryFiles);\n+        processDiagnostics(dh);\n+    }\n+\n+    public String[] tokens(SourceRange range) {\n+        Tokens tokens = tokenize(range);\n+        String rv[] = new String[tokens.size()];\n+        for (int i = 0; i < rv.length; i++) {\n+            rv[i] = tokens.getToken(i).spelling();\n+        }\n+        return rv;\n+    }\n+\n+    public Tokens tokenize(SourceRange range) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment p = MemorySegment.allocateNative(CLinker.C_POINTER, scope);\n+            MemorySegment pCnt = MemorySegment.allocateNative(CLinker.C_INT, scope);\n+            Index_h.clang_tokenize(tu, range.range, p, pCnt);\n+            Tokens rv = new Tokens(MemoryAccess.getAddress(p), MemoryAccess.getInt(pCnt));\n+            return rv;\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        dispose();\n+    }\n+\n+    public void dispose() {\n+        if (tu != MemoryAddress.NULL) {\n+            Index_h.clang_disposeTranslationUnit(tu);\n+            tu = MemoryAddress.NULL;\n+        }\n+    }\n+\n+    public class Tokens {\n+        private final MemoryAddress ar;\n+        private final int size;\n+\n+        Tokens(MemoryAddress ar, int size) {\n+            this.ar = ar;\n+            this.size = size;\n+        }\n+\n+        public void dispose() {\n+            Index_h.clang_disposeTokens(tu, ar, size);\n+        }\n+\n+        public int size() {\n+            return size;\n+        }\n+\n+        public MemorySegment getTokenSegment(int idx) {\n+            MemoryAddress p = ar.addOffset(idx * CXToken.$LAYOUT().byteSize());\n+            return p.asSegment(CXToken.$LAYOUT().byteSize(), ResourceScope.newImplicitScope());\n+        }\n+\n+        public Token getToken(int index) {\n+            return new Token(getTokenSegment(index));\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 0; i < size; i++) {\n+                try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                    MemorySegment s = Index_h.clang_getTokenSpelling(scope, tu, getTokenSegment(i));\n+                    sb.append(\"Token[\");\n+                    sb.append(i);\n+                    sb.append(\"]=\");\n+                    sb.append(LibClang.CXStrToString(s));\n+                    sb.append(\"\\n\");\n+                }\n+            }\n+            return sb.toString();\n+        }\n+    }\n+\n+    public class Token {\n+        final MemorySegment token;\n+\n+        Token(MemorySegment token) {\n+            this.token = token;\n+        }\n+\n+        public int kind() {\n+            return Index_h.clang_getTokenKind(token);\n+        }\n+\n+        public String spelling() {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment s = Index_h.clang_getTokenSpelling(\n+                    scope, tu, token);\n+                return LibClang.CXStrToString(s);\n+            }\n+        }\n+\n+        public SourceLocation getLocation() {\n+            return new SourceLocation(Index_h.clang_getTokenLocation(\n+                ResourceScope.newImplicitScope(), tu, token));\n+        }\n+\n+        public SourceRange getExtent() {\n+            return new SourceRange(Index_h.clang_getTokenExtent(ResourceScope.newImplicitScope(),\n+                    tu, token));\n+        }\n+    }\n+\n+    public static class TranslationUnitSaveException extends IOException {\n+\n+        static final long serialVersionUID = 1L;\n+\n+        private final SaveError error;\n+\n+        TranslationUnitSaveException(Path path, SaveError error) {\n+            super(\"Cannot save translation unit to: \" + path.toAbsolutePath() + \". Error: \" + error);\n+            this.error = error;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TranslationUnit.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.internal.clang.libclang.CXType;\n+import jdk.internal.clang.libclang.Index_h;\n+\n+public final class Type {\n+    private final MemorySegment type;\n+    Type(MemorySegment type) {\n+        this.type = type;\n+    }\n+\n+    public boolean isInvalid() {\n+        return kind() == TypeKind.Invalid;\n+    }\n+\n+    \/\/ Function Types\n+    public boolean isVariadic() {\n+        return Index_h.clang_isFunctionTypeVariadic(type) != 0;\n+    }\n+    public Type resultType() {\n+        return new Type(Index_h.clang_getResultType(ResourceScope.newImplicitScope(), type));\n+    }\n+    public int numberOfArgs() {\n+        return Index_h.clang_getNumArgTypes(type);\n+    }\n+    public Type argType(int idx) {\n+        return new Type(Index_h.clang_getArgType(ResourceScope.newImplicitScope(), type, idx));\n+    }\n+    private int getCallingConvention0() {\n+        return Index_h.clang_getFunctionTypeCallingConv(type);\n+    }\n+\n+    public CallingConvention getCallingConvention() {\n+        int v = getCallingConvention0();\n+        return CallingConvention.valueOf(v);\n+    }\n+\n+    public boolean isPointer() {\n+        var kind = kind();\n+        return kind == TypeKind.Pointer ||\n+            kind == TypeKind.BlockPointer || kind == TypeKind.MemberPointer;\n+    }\n+\n+    public boolean isReference() {\n+        var kind = kind();\n+        return kind == TypeKind.LValueReference || kind == TypeKind.RValueReference;\n+    }\n+\n+    public boolean isArray() {\n+        var kind = kind();\n+        return kind == TypeKind.ConstantArray ||\n+           kind == TypeKind.IncompleteArray ||\n+           kind == TypeKind.VariableArray ||\n+           kind == TypeKind.DependentSizedArray;\n+    }\n+\n+    \/\/ Pointer type\n+    public Type getPointeeType() {\n+        return new Type(Index_h.clang_getPointeeType(ResourceScope.newImplicitScope(), type));\n+    }\n+\n+    \/\/ array\/vector type\n+    public Type getElementType() {\n+        return new Type(Index_h.clang_getElementType(ResourceScope.newImplicitScope(), type));\n+    }\n+\n+    public long getNumberOfElements() {\n+        return Index_h.clang_getNumElements(type);\n+    }\n+\n+    \/\/ Struct\/RecordType\n+    private long getOffsetOf0(String fieldName) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment cfname = CLinker.toCString(fieldName, scope);\n+            return Index_h.clang_Type_getOffsetOf(type, cfname);\n+        }\n+    }\n+\n+    public long getOffsetOf(String fieldName) {\n+        long res = getOffsetOf0(fieldName);\n+        if(TypeLayoutError.isError(res)) {\n+            throw new TypeLayoutError(res, String.format(\"type: %s, fieldName: %s\", this, fieldName));\n+        }\n+        return res;\n+    }\n+\n+    \/\/ Typedef\n+    \/**\n+     * Return the canonical type for a Type.\n+     *\n+     * Clang's type system explicitly models typedefs and all the ways\n+     * a specific type can be represented.  The canonical type is the underlying\n+     * type with all the \"sugar\" removed.  For example, if 'T' is a typedef\n+     * for 'int', the canonical type for 'T' would be 'int'.\n+     *\/\n+    public Type canonicalType() {\n+        return new Type(Index_h.clang_getCanonicalType(ResourceScope.newImplicitScope(), type));\n+    }\n+\n+    \/**\n+     * Determine whether a Type has the \"const\" qualifier set,\n+     * without looking through typedefs that may have added \"const\" at a\n+     * different level.\n+     *\/\n+    public boolean isConstQualifierdType() {\n+        return Index_h.clang_isConstQualifiedType(type) != 0;\n+    }\n+\n+    \/**\n+     * Determine whether a Type has the \"volatile\" qualifier set,\n+     * without looking through typedefs that may have added \"volatile\" at\n+     * a different level.\n+     *\/\n+    public boolean isVolatileQualified() {\n+        return Index_h.clang_isVolatileQualifiedType(type) != 0;\n+    }\n+\n+    public String spelling() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            return LibClang.CXStrToString(Index_h.clang_getTypeSpelling(scope, type));\n+        }\n+    }\n+\n+    public int kind0() {\n+        return CXType.kind$get(type);\n+    }\n+\n+    private long size0() {\n+        return Index_h.clang_Type_getSizeOf(type);\n+    }\n+\n+    public long size() {\n+        long res = size0();\n+        if(TypeLayoutError.isError(res)) {\n+            throw new TypeLayoutError(res, String.format(\"type: %s\", this));\n+        }\n+        return res;\n+    }\n+\n+    public TypeKind kind() {\n+        int v = kind0();\n+        TypeKind rv = TypeKind.valueOf(v);\n+        \/\/ TODO: Atomic type doesn't work\n+        return rv;\n+    }\n+\n+    public Cursor getDeclarationCursor() {\n+        return new Cursor(Index_h.clang_getTypeDeclaration(ResourceScope.newImplicitScope(), type));\n+    }\n+\n+    public boolean equalType(Type other) {\n+        return Index_h.clang_equalTypes(type, other.type) != 0;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        if (this == other) {\n+            return true;\n+        }\n+        if (!(other instanceof Type)) {\n+            return false;\n+        }\n+        return equalType((Type) other);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return spelling().hashCode();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/Type.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import static jdk.internal.clang.libclang.Index_h.*;\n+\n+public enum TypeKind {\n+\n+    Invalid(CXType_Invalid()),\n+    Unexposed(CXType_Unexposed()),\n+    Void(CXType_Void()),\n+    Bool(CXType_Bool()),\n+    Char_U(CXType_Char_U()),\n+    UChar(CXType_UChar()),\n+    Char16(CXType_Char16()),\n+    Char32(CXType_Char32()),\n+    UShort(CXType_UShort()),\n+    UInt(CXType_UInt()),\n+    ULong(CXType_ULong()),\n+    ULongLong(CXType_ULongLong()),\n+    UInt128(CXType_UInt128()),\n+    Char_S(CXType_Char_S()),\n+    SChar(CXType_SChar()),\n+    WChar(CXType_WChar()),\n+    Short(CXType_Short()),\n+    Int(CXType_Int()),\n+    Long(CXType_Long()),\n+    LongLong(CXType_LongLong()),\n+    Int128(CXType_Int128()),\n+    Float(CXType_Float()),\n+    Double(CXType_Double()),\n+    LongDouble(CXType_LongDouble()),\n+    NullPtr(CXType_NullPtr()),\n+    Overload(CXType_Overload()),\n+    Dependent(CXType_Dependent()),\n+    ObjCId(CXType_ObjCId()),\n+    ObjCClass(CXType_ObjCClass()),\n+    ObjCSel(CXType_ObjCSel()),\n+    Float128(CXType_Float128()),\n+    Half(CXType_Half()),\n+    Float16(CXType_Float16()),\n+    ShortAccum(CXType_ShortAccum()),\n+    Accum(CXType_Accum()),\n+    LongAccum(CXType_LongAccum()),\n+    UShortAccum(CXType_UShortAccum()),\n+    UAccum(CXType_UAccum()),\n+    ULongAccum(CXType_ULongAccum()),\n+    Complex(CXType_Complex()),\n+    Pointer(CXType_Pointer()),\n+    BlockPointer(CXType_BlockPointer()),\n+    LValueReference(CXType_LValueReference()),\n+    RValueReference(CXType_RValueReference()),\n+    Record(CXType_Record()),\n+    Enum(CXType_Enum()),\n+    Typedef(CXType_Typedef()),\n+    ObjCInterface(CXType_ObjCInterface()),\n+    ObjCObjectPointer(CXType_ObjCObjectPointer()),\n+    FunctionNoProto(CXType_FunctionNoProto()),\n+    FunctionProto(CXType_FunctionProto()),\n+    ConstantArray(CXType_ConstantArray()),\n+    Vector(CXType_Vector()),\n+    IncompleteArray(CXType_IncompleteArray()),\n+    VariableArray(CXType_VariableArray()),\n+    DependentSizedArray(CXType_DependentSizedArray()),\n+    MemberPointer(CXType_MemberPointer()),\n+    Auto(CXType_Auto()),\n+    Elaborated(CXType_Elaborated()),\n+    Pipe(CXType_Pipe()),\n+    OCLImage1dRO(CXType_OCLImage1dRO()),\n+    OCLImage1dArrayRO(CXType_OCLImage1dArrayRO()),\n+    OCLImage1dBufferRO(CXType_OCLImage1dBufferRO()),\n+    OCLImage2dRO(CXType_OCLImage2dRO()),\n+    OCLImage2dArrayRO(CXType_OCLImage2dArrayRO()),\n+    OCLImage2dDepthRO(CXType_OCLImage2dDepthRO()),\n+    OCLImage2dArrayDepthRO(CXType_OCLImage2dArrayDepthRO()),\n+    OCLImage2dMSAARO(CXType_OCLImage2dMSAARO()),\n+    OCLImage2dArrayMSAARO(CXType_OCLImage2dArrayMSAARO()),\n+    OCLImage2dMSAADepthRO(CXType_OCLImage2dMSAADepthRO()),\n+    OCLImage2dArrayMSAADepthRO(CXType_OCLImage2dArrayMSAADepthRO()),\n+    OCLImage3dRO(CXType_OCLImage3dRO()),\n+    OCLImage1dWO(CXType_OCLImage1dWO()),\n+    OCLImage1dArrayWO(CXType_OCLImage1dArrayWO()),\n+    OCLImage1dBufferWO(CXType_OCLImage1dBufferWO()),\n+    OCLImage2dWO(CXType_OCLImage2dWO()),\n+    OCLImage2dArrayWO(CXType_OCLImage2dArrayWO()),\n+    OCLImage2dDepthWO(CXType_OCLImage2dDepthWO()),\n+    OCLImage2dArrayDepthWO(CXType_OCLImage2dArrayDepthWO()),\n+    OCLImage2dMSAAWO(CXType_OCLImage2dMSAAWO()),\n+    OCLImage2dArrayMSAAWO(CXType_OCLImage2dArrayMSAAWO()),\n+    OCLImage2dMSAADepthWO(CXType_OCLImage2dMSAADepthWO()),\n+    OCLImage2dArrayMSAADepthWO(CXType_OCLImage2dArrayMSAADepthWO()),\n+    OCLImage3dWO(CXType_OCLImage3dWO()),\n+    OCLImage1dRW(CXType_OCLImage1dRW()),\n+    OCLImage1dArrayRW(CXType_OCLImage1dArrayRW()),\n+    OCLImage1dBufferRW(CXType_OCLImage1dBufferRW()),\n+    OCLImage2dRW(CXType_OCLImage2dRW()),\n+    OCLImage2dArrayRW(CXType_OCLImage2dArrayRW()),\n+    OCLImage2dDepthRW(CXType_OCLImage2dDepthRW()),\n+    OCLImage2dArrayDepthRW(CXType_OCLImage2dArrayDepthRW()),\n+    OCLImage2dMSAARW(CXType_OCLImage2dMSAARW()),\n+    OCLImage2dArrayMSAARW(CXType_OCLImage2dArrayMSAARW()),\n+    OCLImage2dMSAADepthRW(CXType_OCLImage2dMSAADepthRW()),\n+    OCLImage2dArrayMSAADepthRW(CXType_OCLImage2dArrayMSAADepthRW()),\n+    OCLImage3dRW(CXType_OCLImage3dRW()),\n+    OCLSampler(CXType_OCLSampler()),\n+    OCLEvent(CXType_OCLEvent()),\n+    OCLQueue(CXType_OCLQueue()),\n+    OCLReserveID(CXType_OCLReserveID()),\n+    ObjCObject(CXType_ObjCObject()),\n+    ObjCTypeParam(CXType_ObjCTypeParam()),\n+    Attributed(CXType_Attributed()),\n+    OCLIntelSubgroupAVCMcePayload(CXType_OCLIntelSubgroupAVCMcePayload()),\n+    OCLIntelSubgroupAVCImePayload(CXType_OCLIntelSubgroupAVCImePayload()),\n+    OCLIntelSubgroupAVCRefPayload(CXType_OCLIntelSubgroupAVCRefPayload()),\n+    OCLIntelSubgroupAVCSicPayload(CXType_OCLIntelSubgroupAVCSicPayload()),\n+    OCLIntelSubgroupAVCMceResult(CXType_OCLIntelSubgroupAVCMceResult()),\n+    OCLIntelSubgroupAVCImeResult(CXType_OCLIntelSubgroupAVCImeResult()),\n+    OCLIntelSubgroupAVCRefResult(CXType_OCLIntelSubgroupAVCRefResult()),\n+    OCLIntelSubgroupAVCSicResult(CXType_OCLIntelSubgroupAVCSicResult()),\n+    OCLIntelSubgroupAVCImeResultSingleRefStreamout(CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout()),\n+    OCLIntelSubgroupAVCImeResultDualRefStreamout(CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout()),\n+    OCLIntelSubgroupAVCImeSingleRefStreamin(CXType_OCLIntelSubgroupAVCImeSingleRefStreamin()),\n+    OCLIntelSubgroupAVCImeDualRefStreamin(CXType_OCLIntelSubgroupAVCImeDualRefStreamin()),\n+    ExtVector(CXType_ExtVector()),\n+    Atomic(177);  \/\/ This is missing in auto-generated code\n+\n+    private final int value;\n+\n+    TypeKind(int value) {\n+        this.value = value;\n+    }\n+\n+    public int value() {\n+        return value;\n+    }\n+\n+    private final static Map<Integer, TypeKind> lookup;\n+\n+    static {\n+        lookup = new HashMap<>();\n+        for (TypeKind e: TypeKind.values()) {\n+            lookup.put(e.value(), e);\n+        }\n+    }\n+\n+    public final static TypeKind valueOf(int value) {\n+        TypeKind x = lookup.get(value);\n+        if (null == x) {\n+            throw new NoSuchElementException(\"kind = \" + value);\n+        }\n+        return x;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TypeKind.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.clang;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+\n+public class TypeLayoutError extends IllegalStateException {\n+\n+    private static final long serialVersionUID = 0L;\n+\n+    private final Kind kind;\n+\n+    public TypeLayoutError(long value, String message) {\n+        super(Kind.valueOf(value) + \". \" + message);\n+        this.kind = Kind.valueOf(value);\n+    }\n+\n+    public Kind kind() {\n+        return kind;\n+    }\n+\n+    public static boolean isError(long value) {\n+        return Kind.isError(value);\n+    }\n+\n+    public enum Kind {\n+        Invalid(-1),\n+        Incomplete(-2),\n+        Dependent(-3),\n+        NotConstantSize(-4),\n+        InvalidFieldName(-5);\n+\n+        private final long value;\n+\n+        Kind(long value) {\n+            this.value = value;\n+        }\n+\n+        private final static Map<Long, Kind> lookup;\n+\n+        static {\n+            lookup = new HashMap<>();\n+            for (Kind e: Kind.values()) {\n+                lookup.put(e.value, e);\n+            }\n+        }\n+\n+        public final static Kind valueOf(long value) {\n+            Kind x = lookup.get(value);\n+            if (null == x) {\n+                throw new NoSuchElementException(\"TypeLayoutError = \" + value);\n+            }\n+            return x;\n+        }\n+\n+        public static boolean isError(long value) {\n+            return lookup.containsKey(value);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/TypeLayoutError.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+public interface CXCursorVisitor {\n+\n+    int apply(jdk.incubator.foreign.MemorySegment x0, jdk.incubator.foreign.MemorySegment x1, jdk.incubator.foreign.MemoryAddress x2);\n+    static MemoryAddress allocate(CXCursorVisitor fi) {\n+        return RuntimeHelper.upcallStub(CXCursorVisitor.class, fi, constants$13.CXCursorVisitor$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)I\");\n+    }\n+    static MemoryAddress allocate(CXCursorVisitor fi, ResourceScope scope) {\n+        return RuntimeHelper.upcallStub(CXCursorVisitor.class, fi, constants$13.CXCursorVisitor$FUNC, \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)I\", scope);\n+    }\n+    static CXCursorVisitor ofAddress(MemoryAddress addr) {\n+        return (jdk.incubator.foreign.MemorySegment x0, jdk.incubator.foreign.MemorySegment x1, jdk.incubator.foreign.MemoryAddress x2) -> {\n+            try {\n+                return (int)constants$13.CXCursorVisitor$MH.invokeExact((Addressable)addr, x0, x1, x2);\n+            } catch (Throwable ex$) {\n+                throw new AssertionError(\"should not reach here\", ex$);\n+            }\n+        };\n+    }\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/CXCursorVisitor.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+public class CXToken {\n+\n+    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(4, C_INT).withName(\"int_data\"),\n+        C_POINTER.withName(\"ptr_data\")\n+    );\n+    public static MemoryLayout $LAYOUT() {\n+        return CXToken.$struct$LAYOUT;\n+    }\n+    public static MemorySegment int_data$slice(MemorySegment seg) {\n+        return seg.asSlice(0, 16);\n+    }\n+    static final VarHandle ptr_data$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"ptr_data\")));\n+    public static VarHandle ptr_data$VH() {\n+        return CXToken.ptr_data$VH;\n+    }\n+    public static MemoryAddress ptr_data$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXToken.ptr_data$VH.get(seg);\n+    }\n+    public static void ptr_data$set( MemorySegment seg, MemoryAddress x) {\n+        CXToken.ptr_data$VH.set(seg, x);\n+    }\n+    public static MemoryAddress ptr_data$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXToken.ptr_data$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void ptr_data$set(MemorySegment seg, long index, MemoryAddress x) {\n+        CXToken.ptr_data$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }\n+    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n+        return allocateArray(len, SegmentAllocator.ofScope(scope));\n+    }\n+    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/CXToken.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+public class CXType {\n+\n+    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    );\n+    public static MemoryLayout $LAYOUT() {\n+        return CXType.$struct$LAYOUT;\n+    }\n+    static final VarHandle kind$VH = $struct$LAYOUT.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"kind\"));\n+    public static VarHandle kind$VH() {\n+        return CXType.kind$VH;\n+    }\n+    public static int kind$get(MemorySegment seg) {\n+        return (int)CXType.kind$VH.get(seg);\n+    }\n+    public static void kind$set( MemorySegment seg, int x) {\n+        CXType.kind$VH.set(seg, x);\n+    }\n+    public static int kind$get(MemorySegment seg, long index) {\n+        return (int)CXType.kind$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void kind$set(MemorySegment seg, long index, int x) {\n+        CXType.kind$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    public static MemorySegment data$slice(MemorySegment seg) {\n+        return seg.asSlice(8, 16);\n+    }\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }\n+    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n+        return allocateArray(len, SegmentAllocator.ofScope(scope));\n+    }\n+    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/CXType.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+public class CXUnsavedFile {\n+\n+    static final MemoryLayout $struct$LAYOUT = MemoryLayout.structLayout(\n+        C_POINTER.withName(\"Filename\"),\n+        C_POINTER.withName(\"Contents\"),\n+        C_LONG_LONG.withName(\"Length\")\n+    ).withName(\"CXUnsavedFile\");\n+    public static MemoryLayout $LAYOUT() {\n+        return CXUnsavedFile.$struct$LAYOUT;\n+    }\n+    static final VarHandle Filename$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Filename\")));\n+    public static VarHandle Filename$VH() {\n+        return CXUnsavedFile.Filename$VH;\n+    }\n+    public static MemoryAddress Filename$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Filename$VH.get(seg);\n+    }\n+    public static void Filename$set( MemorySegment seg, MemoryAddress x) {\n+        CXUnsavedFile.Filename$VH.set(seg, x);\n+    }\n+    public static MemoryAddress Filename$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Filename$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void Filename$set(MemorySegment seg, long index, MemoryAddress x) {\n+        CXUnsavedFile.Filename$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    static final VarHandle Contents$VH = MemoryHandles.asAddressVarHandle($struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Contents\")));\n+    public static VarHandle Contents$VH() {\n+        return CXUnsavedFile.Contents$VH;\n+    }\n+    public static MemoryAddress Contents$get(MemorySegment seg) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Contents$VH.get(seg);\n+    }\n+    public static void Contents$set( MemorySegment seg, MemoryAddress x) {\n+        CXUnsavedFile.Contents$VH.set(seg, x);\n+    }\n+    public static MemoryAddress Contents$get(MemorySegment seg, long index) {\n+        return (jdk.incubator.foreign.MemoryAddress)CXUnsavedFile.Contents$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void Contents$set(MemorySegment seg, long index, MemoryAddress x) {\n+        CXUnsavedFile.Contents$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    static final VarHandle Length$VH = $struct$LAYOUT.varHandle(long.class, MemoryLayout.PathElement.groupElement(\"Length\"));\n+    public static VarHandle Length$VH() {\n+        return CXUnsavedFile.Length$VH;\n+    }\n+    public static long Length$get(MemorySegment seg) {\n+        return (long)CXUnsavedFile.Length$VH.get(seg);\n+    }\n+    public static void Length$set( MemorySegment seg, long x) {\n+        CXUnsavedFile.Length$VH.set(seg, x);\n+    }\n+    public static long Length$get(MemorySegment seg, long index) {\n+        return (long)CXUnsavedFile.Length$VH.get(seg.asSlice(index*sizeof()));\n+    }\n+    public static void Length$set(MemorySegment seg, long index, long x) {\n+        CXUnsavedFile.Length$VH.set(seg.asSlice(index*sizeof()), x);\n+    }\n+    public static long sizeof() { return $LAYOUT().byteSize(); }\n+    public static MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\n+    public static MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }\n+    public static MemorySegment allocateArray(int len, SegmentAllocator allocator) {\n+        return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\n+    }\n+    public static MemorySegment allocateArray(int len, ResourceScope scope) {\n+        return allocateArray(len, SegmentAllocator.ofScope(scope));\n+    }\n+    public static MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/CXUnsavedFile.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,2876 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+public class Index_h  {\n+\n+    \/\/ Manual change to handle platform specific library name difference\n+    private static String libName() {\n+        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+            return \"libclang\";\n+        }\n+        return \"clang\";\n+    }\n+\n+    static {\n+        System.loadLibrary(libName());\n+    }\n+\n+    static final SymbolLookup LIBRARIES = RuntimeHelper.lookup();    \/* package-private *\/ Index_h() {}\n+    public static int CXError_Success() {\n+        return (int)0L;\n+    }\n+    public static int CXError_Failure() {\n+        return (int)1L;\n+    }\n+    public static int CXError_Crashed() {\n+        return (int)2L;\n+    }\n+    public static int CXError_InvalidArguments() {\n+        return (int)3L;\n+    }\n+    public static int CXError_ASTReadError() {\n+        return (int)4L;\n+    }\n+    public static MethodHandle clang_getCString$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_getCString$MH,\"clang_getCString\");\n+    }\n+    public static MemoryAddress clang_getCString ( MemorySegment string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_getCString$MH, \"clang_getCString\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(string);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeString$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_disposeString$MH,\"clang_disposeString\");\n+    }\n+    public static void clang_disposeString ( MemorySegment string) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_disposeString$MH, \"clang_disposeString\");\n+        try {\n+            mh$.invokeExact(string);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_None() {\n+        return (int)0L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_DynamicNone() {\n+        return (int)1L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Dynamic() {\n+        return (int)2L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_MSAny() {\n+        return (int)3L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_BasicNoexcept() {\n+        return (int)4L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_ComputedNoexcept() {\n+        return (int)5L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Unevaluated() {\n+        return (int)6L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Uninstantiated() {\n+        return (int)7L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_Unparsed() {\n+        return (int)8L;\n+    }\n+    public static int CXCursor_ExceptionSpecificationKind_NoThrow() {\n+        return (int)9L;\n+    }\n+    public static MethodHandle clang_createIndex$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_createIndex$MH,\"clang_createIndex\");\n+    }\n+    public static MemoryAddress clang_createIndex ( int excludeDeclarationsFromPCH,  int displayDiagnostics) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_createIndex$MH, \"clang_createIndex\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(excludeDeclarationsFromPCH, displayDiagnostics);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeIndex$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_disposeIndex$MH,\"clang_disposeIndex\");\n+    }\n+    public static void clang_disposeIndex ( Addressable index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_disposeIndex$MH, \"clang_disposeIndex\");\n+        try {\n+            mh$.invokeExact(index.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFileName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_getFileName$MH,\"clang_getFileName\");\n+    }\n+    public static MemorySegment clang_getFileName ( SegmentAllocator allocator,  Addressable SFile) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_getFileName$MH, \"clang_getFileName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, SFile.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getFileName ( ResourceScope scope,  Addressable SFile) {\n+        return clang_getFileName(SegmentAllocator.ofScope(scope), SFile.address());\n+    }\n+    public static MethodHandle clang_getNullLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$0.clang_getNullLocation$MH,\"clang_getNullLocation\");\n+    }\n+    public static MemorySegment clang_getNullLocation ( SegmentAllocator allocator) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$0.clang_getNullLocation$MH, \"clang_getNullLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getNullLocation ( ResourceScope scope) {\n+        return clang_getNullLocation(SegmentAllocator.ofScope(scope));\n+    }\n+    public static MethodHandle clang_equalLocations$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_equalLocations$MH,\"clang_equalLocations\");\n+    }\n+    public static int clang_equalLocations ( MemorySegment loc1,  MemorySegment loc2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_equalLocations$MH, \"clang_equalLocations\");\n+        try {\n+            return (int)mh$.invokeExact(loc1, loc2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_getLocation$MH,\"clang_getLocation\");\n+    }\n+    public static MemorySegment clang_getLocation ( SegmentAllocator allocator,  Addressable tu,  Addressable file,  int line,  int column) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_getLocation$MH, \"clang_getLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, tu.address(), file.address(), line, column);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getLocation ( ResourceScope scope,  Addressable tu,  Addressable file,  int line,  int column) {\n+        return clang_getLocation(SegmentAllocator.ofScope(scope), tu.address(), file.address(), line, column);\n+    }\n+    public static MethodHandle clang_getLocationForOffset$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_getLocationForOffset$MH,\"clang_getLocationForOffset\");\n+    }\n+    public static MemorySegment clang_getLocationForOffset ( SegmentAllocator allocator,  Addressable tu,  Addressable file,  int offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_getLocationForOffset$MH, \"clang_getLocationForOffset\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, tu.address(), file.address(), offset);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getLocationForOffset ( ResourceScope scope,  Addressable tu,  Addressable file,  int offset) {\n+        return clang_getLocationForOffset(SegmentAllocator.ofScope(scope), tu.address(), file.address(), offset);\n+    }\n+    public static MethodHandle clang_Location_isInSystemHeader$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_Location_isInSystemHeader$MH,\"clang_Location_isInSystemHeader\");\n+    }\n+    public static int clang_Location_isInSystemHeader ( MemorySegment location) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_Location_isInSystemHeader$MH, \"clang_Location_isInSystemHeader\");\n+        try {\n+            return (int)mh$.invokeExact(location);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Location_isFromMainFile$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_Location_isFromMainFile$MH,\"clang_Location_isFromMainFile\");\n+    }\n+    public static int clang_Location_isFromMainFile ( MemorySegment location) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_Location_isFromMainFile$MH, \"clang_Location_isFromMainFile\");\n+        try {\n+            return (int)mh$.invokeExact(location);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Range_isNull$MH() {\n+        return RuntimeHelper.requireNonNull(constants$1.clang_Range_isNull$MH,\"clang_Range_isNull\");\n+    }\n+    public static int clang_Range_isNull ( MemorySegment range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$1.clang_Range_isNull$MH, \"clang_Range_isNull\");\n+        try {\n+            return (int)mh$.invokeExact(range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getExpansionLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getExpansionLocation$MH,\"clang_getExpansionLocation\");\n+    }\n+    public static void clang_getExpansionLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getExpansionLocation$MH, \"clang_getExpansionLocation\");\n+        try {\n+            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getSpellingLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getSpellingLocation$MH,\"clang_getSpellingLocation\");\n+    }\n+    public static void clang_getSpellingLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getSpellingLocation$MH, \"clang_getSpellingLocation\");\n+        try {\n+            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFileLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getFileLocation$MH,\"clang_getFileLocation\");\n+    }\n+    public static void clang_getFileLocation ( MemorySegment location,  Addressable file,  Addressable line,  Addressable column,  Addressable offset) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getFileLocation$MH, \"clang_getFileLocation\");\n+        try {\n+            mh$.invokeExact(location, file.address(), line.address(), column.address(), offset.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getRangeStart$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getRangeStart$MH,\"clang_getRangeStart\");\n+    }\n+    public static MemorySegment clang_getRangeStart ( SegmentAllocator allocator,  MemorySegment range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getRangeStart$MH, \"clang_getRangeStart\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getRangeStart ( ResourceScope scope,  MemorySegment range) {\n+        return clang_getRangeStart(SegmentAllocator.ofScope(scope), range);\n+    }\n+    public static MethodHandle clang_getRangeEnd$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getRangeEnd$MH,\"clang_getRangeEnd\");\n+    }\n+    public static MemorySegment clang_getRangeEnd ( SegmentAllocator allocator,  MemorySegment range) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getRangeEnd$MH, \"clang_getRangeEnd\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, range);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getRangeEnd ( ResourceScope scope,  MemorySegment range) {\n+        return clang_getRangeEnd(SegmentAllocator.ofScope(scope), range);\n+    }\n+    public static int CXDiagnostic_Ignored() {\n+        return (int)0L;\n+    }\n+    public static int CXDiagnostic_Note() {\n+        return (int)1L;\n+    }\n+    public static int CXDiagnostic_Warning() {\n+        return (int)2L;\n+    }\n+    public static int CXDiagnostic_Error() {\n+        return (int)3L;\n+    }\n+    public static int CXDiagnostic_Fatal() {\n+        return (int)4L;\n+    }\n+    public static MethodHandle clang_getChildDiagnostics$MH() {\n+        return RuntimeHelper.requireNonNull(constants$2.clang_getChildDiagnostics$MH,\"clang_getChildDiagnostics\");\n+    }\n+    public static MemoryAddress clang_getChildDiagnostics ( Addressable D) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$2.clang_getChildDiagnostics$MH, \"clang_getChildDiagnostics\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(D.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getNumDiagnostics$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getNumDiagnostics$MH,\"clang_getNumDiagnostics\");\n+    }\n+    public static int clang_getNumDiagnostics ( Addressable Unit) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getNumDiagnostics$MH, \"clang_getNumDiagnostics\");\n+        try {\n+            return (int)mh$.invokeExact(Unit.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getDiagnostic$MH,\"clang_getDiagnostic\");\n+    }\n+    public static MemoryAddress clang_getDiagnostic ( Addressable Unit,  int Index) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getDiagnostic$MH, \"clang_getDiagnostic\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(Unit.address(), Index);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_disposeDiagnostic$MH,\"clang_disposeDiagnostic\");\n+    }\n+    public static void clang_disposeDiagnostic ( Addressable Diagnostic) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_disposeDiagnostic$MH, \"clang_disposeDiagnostic\");\n+        try {\n+            mh$.invokeExact(Diagnostic.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXDiagnostic_DisplaySourceLocation() {\n+        return (int)1L;\n+    }\n+    public static int CXDiagnostic_DisplayColumn() {\n+        return (int)2L;\n+    }\n+    public static int CXDiagnostic_DisplaySourceRanges() {\n+        return (int)4L;\n+    }\n+    public static int CXDiagnostic_DisplayOption() {\n+        return (int)8L;\n+    }\n+    public static int CXDiagnostic_DisplayCategoryId() {\n+        return (int)16L;\n+    }\n+    public static int CXDiagnostic_DisplayCategoryName() {\n+        return (int)32L;\n+    }\n+    public static MethodHandle clang_formatDiagnostic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_formatDiagnostic$MH,\"clang_formatDiagnostic\");\n+    }\n+    public static MemorySegment clang_formatDiagnostic ( SegmentAllocator allocator,  Addressable Diagnostic,  int Options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_formatDiagnostic$MH, \"clang_formatDiagnostic\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Diagnostic.address(), Options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_formatDiagnostic ( ResourceScope scope,  Addressable Diagnostic,  int Options) {\n+        return clang_formatDiagnostic(SegmentAllocator.ofScope(scope), Diagnostic.address(), Options);\n+    }\n+    public static MethodHandle clang_defaultDiagnosticDisplayOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_defaultDiagnosticDisplayOptions$MH,\"clang_defaultDiagnosticDisplayOptions\");\n+    }\n+    public static int clang_defaultDiagnosticDisplayOptions () {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_defaultDiagnosticDisplayOptions$MH, \"clang_defaultDiagnosticDisplayOptions\");\n+        try {\n+            return (int)mh$.invokeExact();\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticSeverity$MH() {\n+        return RuntimeHelper.requireNonNull(constants$3.clang_getDiagnosticSeverity$MH,\"clang_getDiagnosticSeverity\");\n+    }\n+    public static int clang_getDiagnosticSeverity ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$3.clang_getDiagnosticSeverity$MH, \"clang_getDiagnosticSeverity\");\n+        try {\n+            return (int)mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getDiagnosticLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticLocation$MH,\"clang_getDiagnosticLocation\");\n+    }\n+    public static MemorySegment clang_getDiagnosticLocation ( SegmentAllocator allocator,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticLocation$MH, \"clang_getDiagnosticLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getDiagnosticLocation ( ResourceScope scope,  Addressable x1) {\n+        return clang_getDiagnosticLocation(SegmentAllocator.ofScope(scope), x1.address());\n+    }\n+    public static MethodHandle clang_getDiagnosticSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticSpelling$MH,\"clang_getDiagnosticSpelling\");\n+    }\n+    public static MemorySegment clang_getDiagnosticSpelling ( SegmentAllocator allocator,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_getDiagnosticSpelling$MH, \"clang_getDiagnosticSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getDiagnosticSpelling ( ResourceScope scope,  Addressable x1) {\n+        return clang_getDiagnosticSpelling(SegmentAllocator.ofScope(scope), x1.address());\n+    }\n+    public static int CXTranslationUnit_None() {\n+        return (int)0L;\n+    }\n+    public static int CXTranslationUnit_DetailedPreprocessingRecord() {\n+        return (int)1L;\n+    }\n+    public static int CXTranslationUnit_Incomplete() {\n+        return (int)2L;\n+    }\n+    public static int CXTranslationUnit_PrecompiledPreamble() {\n+        return (int)4L;\n+    }\n+    public static int CXTranslationUnit_CacheCompletionResults() {\n+        return (int)8L;\n+    }\n+    public static int CXTranslationUnit_ForSerialization() {\n+        return (int)16L;\n+    }\n+    public static int CXTranslationUnit_CXXChainedPCH() {\n+        return (int)32L;\n+    }\n+    public static int CXTranslationUnit_SkipFunctionBodies() {\n+        return (int)64L;\n+    }\n+    public static int CXTranslationUnit_IncludeBriefCommentsInCodeCompletion() {\n+        return (int)128L;\n+    }\n+    public static int CXTranslationUnit_CreatePreambleOnFirstParse() {\n+        return (int)256L;\n+    }\n+    public static int CXTranslationUnit_KeepGoing() {\n+        return (int)512L;\n+    }\n+    public static int CXTranslationUnit_SingleFileParse() {\n+        return (int)1024L;\n+    }\n+    public static int CXTranslationUnit_LimitSkipFunctionBodiesToPreamble() {\n+        return (int)2048L;\n+    }\n+    public static int CXTranslationUnit_IncludeAttributedTypes() {\n+        return (int)4096L;\n+    }\n+    public static int CXTranslationUnit_VisitImplicitAttributes() {\n+        return (int)8192L;\n+    }\n+    public static int CXTranslationUnit_IgnoreNonErrorsFromIncludedFiles() {\n+        return (int)16384L;\n+    }\n+    public static int CXTranslationUnit_RetainExcludedConditionalBlocks() {\n+        return (int)32768L;\n+    }\n+    public static MethodHandle clang_parseTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit$MH,\"clang_parseTranslationUnit\");\n+    }\n+    public static MemoryAddress clang_parseTranslationUnit ( Addressable CIdx,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit$MH, \"clang_parseTranslationUnit\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(CIdx.address(), source_filename.address(), command_line_args.address(), num_command_line_args, unsaved_files.address(), num_unsaved_files, options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_parseTranslationUnit2$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit2$MH,\"clang_parseTranslationUnit2\");\n+    }\n+    public static int clang_parseTranslationUnit2 ( Addressable CIdx,  Addressable source_filename,  Addressable command_line_args,  int num_command_line_args,  Addressable unsaved_files,  int num_unsaved_files,  int options,  Addressable out_TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_parseTranslationUnit2$MH, \"clang_parseTranslationUnit2\");\n+        try {\n+            return (int)mh$.invokeExact(CIdx.address(), source_filename.address(), command_line_args.address(), num_command_line_args, unsaved_files.address(), num_unsaved_files, options, out_TU.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXSaveTranslationUnit_None() {\n+        return (int)0L;\n+    }\n+    public static int CXSaveError_None() {\n+        return (int)0L;\n+    }\n+    public static int CXSaveError_Unknown() {\n+        return (int)1L;\n+    }\n+    public static int CXSaveError_TranslationErrors() {\n+        return (int)2L;\n+    }\n+    public static int CXSaveError_InvalidTU() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_saveTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_saveTranslationUnit$MH,\"clang_saveTranslationUnit\");\n+    }\n+    public static int clang_saveTranslationUnit ( Addressable TU,  Addressable FileName,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_saveTranslationUnit$MH, \"clang_saveTranslationUnit\");\n+        try {\n+            return (int)mh$.invokeExact(TU.address(), FileName.address(), options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$4.clang_disposeTranslationUnit$MH,\"clang_disposeTranslationUnit\");\n+    }\n+    public static void clang_disposeTranslationUnit ( Addressable x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$4.clang_disposeTranslationUnit$MH, \"clang_disposeTranslationUnit\");\n+        try {\n+            mh$.invokeExact(x0.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXReparse_None() {\n+        return (int)0L;\n+    }\n+    public static MethodHandle clang_defaultReparseOptions$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_defaultReparseOptions$MH,\"clang_defaultReparseOptions\");\n+    }\n+    public static int clang_defaultReparseOptions ( Addressable TU) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_defaultReparseOptions$MH, \"clang_defaultReparseOptions\");\n+        try {\n+            return (int)mh$.invokeExact(TU.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_reparseTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_reparseTranslationUnit$MH,\"clang_reparseTranslationUnit\");\n+    }\n+    public static int clang_reparseTranslationUnit ( Addressable TU,  int num_unsaved_files,  Addressable unsaved_files,  int options) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_reparseTranslationUnit$MH, \"clang_reparseTranslationUnit\");\n+        try {\n+            return (int)mh$.invokeExact(TU.address(), num_unsaved_files, unsaved_files.address(), options);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXCursor_UnexposedDecl() {\n+        return (int)1L;\n+    }\n+    public static int CXCursor_StructDecl() {\n+        return (int)2L;\n+    }\n+    public static int CXCursor_UnionDecl() {\n+        return (int)3L;\n+    }\n+    public static int CXCursor_ClassDecl() {\n+        return (int)4L;\n+    }\n+    public static int CXCursor_EnumDecl() {\n+        return (int)5L;\n+    }\n+    public static int CXCursor_FieldDecl() {\n+        return (int)6L;\n+    }\n+    public static int CXCursor_EnumConstantDecl() {\n+        return (int)7L;\n+    }\n+    public static int CXCursor_FunctionDecl() {\n+        return (int)8L;\n+    }\n+    public static int CXCursor_VarDecl() {\n+        return (int)9L;\n+    }\n+    public static int CXCursor_ParmDecl() {\n+        return (int)10L;\n+    }\n+    public static int CXCursor_ObjCInterfaceDecl() {\n+        return (int)11L;\n+    }\n+    public static int CXCursor_ObjCCategoryDecl() {\n+        return (int)12L;\n+    }\n+    public static int CXCursor_ObjCProtocolDecl() {\n+        return (int)13L;\n+    }\n+    public static int CXCursor_ObjCPropertyDecl() {\n+        return (int)14L;\n+    }\n+    public static int CXCursor_ObjCIvarDecl() {\n+        return (int)15L;\n+    }\n+    public static int CXCursor_ObjCInstanceMethodDecl() {\n+        return (int)16L;\n+    }\n+    public static int CXCursor_ObjCClassMethodDecl() {\n+        return (int)17L;\n+    }\n+    public static int CXCursor_ObjCImplementationDecl() {\n+        return (int)18L;\n+    }\n+    public static int CXCursor_ObjCCategoryImplDecl() {\n+        return (int)19L;\n+    }\n+    public static int CXCursor_TypedefDecl() {\n+        return (int)20L;\n+    }\n+    public static int CXCursor_CXXMethod() {\n+        return (int)21L;\n+    }\n+    public static int CXCursor_Namespace() {\n+        return (int)22L;\n+    }\n+    public static int CXCursor_LinkageSpec() {\n+        return (int)23L;\n+    }\n+    public static int CXCursor_Constructor() {\n+        return (int)24L;\n+    }\n+    public static int CXCursor_Destructor() {\n+        return (int)25L;\n+    }\n+    public static int CXCursor_ConversionFunction() {\n+        return (int)26L;\n+    }\n+    public static int CXCursor_TemplateTypeParameter() {\n+        return (int)27L;\n+    }\n+    public static int CXCursor_NonTypeTemplateParameter() {\n+        return (int)28L;\n+    }\n+    public static int CXCursor_TemplateTemplateParameter() {\n+        return (int)29L;\n+    }\n+    public static int CXCursor_FunctionTemplate() {\n+        return (int)30L;\n+    }\n+    public static int CXCursor_ClassTemplate() {\n+        return (int)31L;\n+    }\n+    public static int CXCursor_ClassTemplatePartialSpecialization() {\n+        return (int)32L;\n+    }\n+    public static int CXCursor_NamespaceAlias() {\n+        return (int)33L;\n+    }\n+    public static int CXCursor_UsingDirective() {\n+        return (int)34L;\n+    }\n+    public static int CXCursor_UsingDeclaration() {\n+        return (int)35L;\n+    }\n+    public static int CXCursor_TypeAliasDecl() {\n+        return (int)36L;\n+    }\n+    public static int CXCursor_ObjCSynthesizeDecl() {\n+        return (int)37L;\n+    }\n+    public static int CXCursor_ObjCDynamicDecl() {\n+        return (int)38L;\n+    }\n+    public static int CXCursor_CXXAccessSpecifier() {\n+        return (int)39L;\n+    }\n+    public static int CXCursor_FirstDecl() {\n+        return (int)1L;\n+    }\n+    public static int CXCursor_LastDecl() {\n+        return (int)39L;\n+    }\n+    public static int CXCursor_FirstRef() {\n+        return (int)40L;\n+    }\n+    public static int CXCursor_ObjCSuperClassRef() {\n+        return (int)40L;\n+    }\n+    public static int CXCursor_ObjCProtocolRef() {\n+        return (int)41L;\n+    }\n+    public static int CXCursor_ObjCClassRef() {\n+        return (int)42L;\n+    }\n+    public static int CXCursor_TypeRef() {\n+        return (int)43L;\n+    }\n+    public static int CXCursor_CXXBaseSpecifier() {\n+        return (int)44L;\n+    }\n+    public static int CXCursor_TemplateRef() {\n+        return (int)45L;\n+    }\n+    public static int CXCursor_NamespaceRef() {\n+        return (int)46L;\n+    }\n+    public static int CXCursor_MemberRef() {\n+        return (int)47L;\n+    }\n+    public static int CXCursor_LabelRef() {\n+        return (int)48L;\n+    }\n+    public static int CXCursor_OverloadedDeclRef() {\n+        return (int)49L;\n+    }\n+    public static int CXCursor_VariableRef() {\n+        return (int)50L;\n+    }\n+    public static int CXCursor_LastRef() {\n+        return (int)50L;\n+    }\n+    public static int CXCursor_FirstInvalid() {\n+        return (int)70L;\n+    }\n+    public static int CXCursor_InvalidFile() {\n+        return (int)70L;\n+    }\n+    public static int CXCursor_NoDeclFound() {\n+        return (int)71L;\n+    }\n+    public static int CXCursor_NotImplemented() {\n+        return (int)72L;\n+    }\n+    public static int CXCursor_InvalidCode() {\n+        return (int)73L;\n+    }\n+    public static int CXCursor_LastInvalid() {\n+        return (int)73L;\n+    }\n+    public static int CXCursor_FirstExpr() {\n+        return (int)100L;\n+    }\n+    public static int CXCursor_UnexposedExpr() {\n+        return (int)100L;\n+    }\n+    public static int CXCursor_DeclRefExpr() {\n+        return (int)101L;\n+    }\n+    public static int CXCursor_MemberRefExpr() {\n+        return (int)102L;\n+    }\n+    public static int CXCursor_CallExpr() {\n+        return (int)103L;\n+    }\n+    public static int CXCursor_ObjCMessageExpr() {\n+        return (int)104L;\n+    }\n+    public static int CXCursor_BlockExpr() {\n+        return (int)105L;\n+    }\n+    public static int CXCursor_IntegerLiteral() {\n+        return (int)106L;\n+    }\n+    public static int CXCursor_FloatingLiteral() {\n+        return (int)107L;\n+    }\n+    public static int CXCursor_ImaginaryLiteral() {\n+        return (int)108L;\n+    }\n+    public static int CXCursor_StringLiteral() {\n+        return (int)109L;\n+    }\n+    public static int CXCursor_CharacterLiteral() {\n+        return (int)110L;\n+    }\n+    public static int CXCursor_ParenExpr() {\n+        return (int)111L;\n+    }\n+    public static int CXCursor_UnaryOperator() {\n+        return (int)112L;\n+    }\n+    public static int CXCursor_ArraySubscriptExpr() {\n+        return (int)113L;\n+    }\n+    public static int CXCursor_BinaryOperator() {\n+        return (int)114L;\n+    }\n+    public static int CXCursor_CompoundAssignOperator() {\n+        return (int)115L;\n+    }\n+    public static int CXCursor_ConditionalOperator() {\n+        return (int)116L;\n+    }\n+    public static int CXCursor_CStyleCastExpr() {\n+        return (int)117L;\n+    }\n+    public static int CXCursor_CompoundLiteralExpr() {\n+        return (int)118L;\n+    }\n+    public static int CXCursor_InitListExpr() {\n+        return (int)119L;\n+    }\n+    public static int CXCursor_AddrLabelExpr() {\n+        return (int)120L;\n+    }\n+    public static int CXCursor_StmtExpr() {\n+        return (int)121L;\n+    }\n+    public static int CXCursor_GenericSelectionExpr() {\n+        return (int)122L;\n+    }\n+    public static int CXCursor_GNUNullExpr() {\n+        return (int)123L;\n+    }\n+    public static int CXCursor_CXXStaticCastExpr() {\n+        return (int)124L;\n+    }\n+    public static int CXCursor_CXXDynamicCastExpr() {\n+        return (int)125L;\n+    }\n+    public static int CXCursor_CXXReinterpretCastExpr() {\n+        return (int)126L;\n+    }\n+    public static int CXCursor_CXXConstCastExpr() {\n+        return (int)127L;\n+    }\n+    public static int CXCursor_CXXFunctionalCastExpr() {\n+        return (int)128L;\n+    }\n+    public static int CXCursor_CXXTypeidExpr() {\n+        return (int)129L;\n+    }\n+    public static int CXCursor_CXXBoolLiteralExpr() {\n+        return (int)130L;\n+    }\n+    public static int CXCursor_CXXNullPtrLiteralExpr() {\n+        return (int)131L;\n+    }\n+    public static int CXCursor_CXXThisExpr() {\n+        return (int)132L;\n+    }\n+    public static int CXCursor_CXXThrowExpr() {\n+        return (int)133L;\n+    }\n+    public static int CXCursor_CXXNewExpr() {\n+        return (int)134L;\n+    }\n+    public static int CXCursor_CXXDeleteExpr() {\n+        return (int)135L;\n+    }\n+    public static int CXCursor_UnaryExpr() {\n+        return (int)136L;\n+    }\n+    public static int CXCursor_ObjCStringLiteral() {\n+        return (int)137L;\n+    }\n+    public static int CXCursor_ObjCEncodeExpr() {\n+        return (int)138L;\n+    }\n+    public static int CXCursor_ObjCSelectorExpr() {\n+        return (int)139L;\n+    }\n+    public static int CXCursor_ObjCProtocolExpr() {\n+        return (int)140L;\n+    }\n+    public static int CXCursor_ObjCBridgedCastExpr() {\n+        return (int)141L;\n+    }\n+    public static int CXCursor_PackExpansionExpr() {\n+        return (int)142L;\n+    }\n+    public static int CXCursor_SizeOfPackExpr() {\n+        return (int)143L;\n+    }\n+    public static int CXCursor_LambdaExpr() {\n+        return (int)144L;\n+    }\n+    public static int CXCursor_ObjCBoolLiteralExpr() {\n+        return (int)145L;\n+    }\n+    public static int CXCursor_ObjCSelfExpr() {\n+        return (int)146L;\n+    }\n+    public static int CXCursor_OMPArraySectionExpr() {\n+        return (int)147L;\n+    }\n+    public static int CXCursor_ObjCAvailabilityCheckExpr() {\n+        return (int)148L;\n+    }\n+    public static int CXCursor_FixedPointLiteral() {\n+        return (int)149L;\n+    }\n+    public static int CXCursor_LastExpr() {\n+        return (int)149L;\n+    }\n+    public static int CXCursor_FirstStmt() {\n+        return (int)200L;\n+    }\n+    public static int CXCursor_UnexposedStmt() {\n+        return (int)200L;\n+    }\n+    public static int CXCursor_LabelStmt() {\n+        return (int)201L;\n+    }\n+    public static int CXCursor_CompoundStmt() {\n+        return (int)202L;\n+    }\n+    public static int CXCursor_CaseStmt() {\n+        return (int)203L;\n+    }\n+    public static int CXCursor_DefaultStmt() {\n+        return (int)204L;\n+    }\n+    public static int CXCursor_IfStmt() {\n+        return (int)205L;\n+    }\n+    public static int CXCursor_SwitchStmt() {\n+        return (int)206L;\n+    }\n+    public static int CXCursor_WhileStmt() {\n+        return (int)207L;\n+    }\n+    public static int CXCursor_DoStmt() {\n+        return (int)208L;\n+    }\n+    public static int CXCursor_ForStmt() {\n+        return (int)209L;\n+    }\n+    public static int CXCursor_GotoStmt() {\n+        return (int)210L;\n+    }\n+    public static int CXCursor_IndirectGotoStmt() {\n+        return (int)211L;\n+    }\n+    public static int CXCursor_ContinueStmt() {\n+        return (int)212L;\n+    }\n+    public static int CXCursor_BreakStmt() {\n+        return (int)213L;\n+    }\n+    public static int CXCursor_ReturnStmt() {\n+        return (int)214L;\n+    }\n+    public static int CXCursor_GCCAsmStmt() {\n+        return (int)215L;\n+    }\n+    public static int CXCursor_AsmStmt() {\n+        return (int)215L;\n+    }\n+    public static int CXCursor_ObjCAtTryStmt() {\n+        return (int)216L;\n+    }\n+    public static int CXCursor_ObjCAtCatchStmt() {\n+        return (int)217L;\n+    }\n+    public static int CXCursor_ObjCAtFinallyStmt() {\n+        return (int)218L;\n+    }\n+    public static int CXCursor_ObjCAtThrowStmt() {\n+        return (int)219L;\n+    }\n+    public static int CXCursor_ObjCAtSynchronizedStmt() {\n+        return (int)220L;\n+    }\n+    public static int CXCursor_ObjCAutoreleasePoolStmt() {\n+        return (int)221L;\n+    }\n+    public static int CXCursor_ObjCForCollectionStmt() {\n+        return (int)222L;\n+    }\n+    public static int CXCursor_CXXCatchStmt() {\n+        return (int)223L;\n+    }\n+    public static int CXCursor_CXXTryStmt() {\n+        return (int)224L;\n+    }\n+    public static int CXCursor_CXXForRangeStmt() {\n+        return (int)225L;\n+    }\n+    public static int CXCursor_SEHTryStmt() {\n+        return (int)226L;\n+    }\n+    public static int CXCursor_SEHExceptStmt() {\n+        return (int)227L;\n+    }\n+    public static int CXCursor_SEHFinallyStmt() {\n+        return (int)228L;\n+    }\n+    public static int CXCursor_MSAsmStmt() {\n+        return (int)229L;\n+    }\n+    public static int CXCursor_NullStmt() {\n+        return (int)230L;\n+    }\n+    public static int CXCursor_DeclStmt() {\n+        return (int)231L;\n+    }\n+    public static int CXCursor_OMPParallelDirective() {\n+        return (int)232L;\n+    }\n+    public static int CXCursor_OMPSimdDirective() {\n+        return (int)233L;\n+    }\n+    public static int CXCursor_OMPForDirective() {\n+        return (int)234L;\n+    }\n+    public static int CXCursor_OMPSectionsDirective() {\n+        return (int)235L;\n+    }\n+    public static int CXCursor_OMPSectionDirective() {\n+        return (int)236L;\n+    }\n+    public static int CXCursor_OMPSingleDirective() {\n+        return (int)237L;\n+    }\n+    public static int CXCursor_OMPParallelForDirective() {\n+        return (int)238L;\n+    }\n+    public static int CXCursor_OMPParallelSectionsDirective() {\n+        return (int)239L;\n+    }\n+    public static int CXCursor_OMPTaskDirective() {\n+        return (int)240L;\n+    }\n+    public static int CXCursor_OMPMasterDirective() {\n+        return (int)241L;\n+    }\n+    public static int CXCursor_OMPCriticalDirective() {\n+        return (int)242L;\n+    }\n+    public static int CXCursor_OMPTaskyieldDirective() {\n+        return (int)243L;\n+    }\n+    public static int CXCursor_OMPBarrierDirective() {\n+        return (int)244L;\n+    }\n+    public static int CXCursor_OMPTaskwaitDirective() {\n+        return (int)245L;\n+    }\n+    public static int CXCursor_OMPFlushDirective() {\n+        return (int)246L;\n+    }\n+    public static int CXCursor_SEHLeaveStmt() {\n+        return (int)247L;\n+    }\n+    public static int CXCursor_OMPOrderedDirective() {\n+        return (int)248L;\n+    }\n+    public static int CXCursor_OMPAtomicDirective() {\n+        return (int)249L;\n+    }\n+    public static int CXCursor_OMPForSimdDirective() {\n+        return (int)250L;\n+    }\n+    public static int CXCursor_OMPParallelForSimdDirective() {\n+        return (int)251L;\n+    }\n+    public static int CXCursor_OMPTargetDirective() {\n+        return (int)252L;\n+    }\n+    public static int CXCursor_OMPTeamsDirective() {\n+        return (int)253L;\n+    }\n+    public static int CXCursor_OMPTaskgroupDirective() {\n+        return (int)254L;\n+    }\n+    public static int CXCursor_OMPCancellationPointDirective() {\n+        return (int)255L;\n+    }\n+    public static int CXCursor_OMPCancelDirective() {\n+        return (int)256L;\n+    }\n+    public static int CXCursor_OMPTargetDataDirective() {\n+        return (int)257L;\n+    }\n+    public static int CXCursor_OMPTaskLoopDirective() {\n+        return (int)258L;\n+    }\n+    public static int CXCursor_OMPTaskLoopSimdDirective() {\n+        return (int)259L;\n+    }\n+    public static int CXCursor_OMPDistributeDirective() {\n+        return (int)260L;\n+    }\n+    public static int CXCursor_OMPTargetEnterDataDirective() {\n+        return (int)261L;\n+    }\n+    public static int CXCursor_OMPTargetExitDataDirective() {\n+        return (int)262L;\n+    }\n+    public static int CXCursor_OMPTargetParallelDirective() {\n+        return (int)263L;\n+    }\n+    public static int CXCursor_OMPTargetParallelForDirective() {\n+        return (int)264L;\n+    }\n+    public static int CXCursor_OMPTargetUpdateDirective() {\n+        return (int)265L;\n+    }\n+    public static int CXCursor_OMPDistributeParallelForDirective() {\n+        return (int)266L;\n+    }\n+    public static int CXCursor_OMPDistributeParallelForSimdDirective() {\n+        return (int)267L;\n+    }\n+    public static int CXCursor_OMPDistributeSimdDirective() {\n+        return (int)268L;\n+    }\n+    public static int CXCursor_OMPTargetParallelForSimdDirective() {\n+        return (int)269L;\n+    }\n+    public static int CXCursor_OMPTargetSimdDirective() {\n+        return (int)270L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeDirective() {\n+        return (int)271L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeSimdDirective() {\n+        return (int)272L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeParallelForSimdDirective() {\n+        return (int)273L;\n+    }\n+    public static int CXCursor_OMPTeamsDistributeParallelForDirective() {\n+        return (int)274L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDirective() {\n+        return (int)275L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeDirective() {\n+        return (int)276L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeParallelForDirective() {\n+        return (int)277L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeParallelForSimdDirective() {\n+        return (int)278L;\n+    }\n+    public static int CXCursor_OMPTargetTeamsDistributeSimdDirective() {\n+        return (int)279L;\n+    }\n+    public static int CXCursor_BuiltinBitCastExpr() {\n+        return (int)280L;\n+    }\n+    public static int CXCursor_OMPMasterTaskLoopDirective() {\n+        return (int)281L;\n+    }\n+    public static int CXCursor_OMPParallelMasterTaskLoopDirective() {\n+        return (int)282L;\n+    }\n+    public static int CXCursor_OMPMasterTaskLoopSimdDirective() {\n+        return (int)283L;\n+    }\n+    public static int CXCursor_OMPParallelMasterTaskLoopSimdDirective() {\n+        return (int)284L;\n+    }\n+    public static int CXCursor_LastStmt() {\n+        return (int)285L;\n+    }\n+    public static int CXCursor_TranslationUnit() {\n+        return (int)300L;\n+    }\n+    public static int CXCursor_FirstAttr() {\n+        return (int)400L;\n+    }\n+    public static int CXCursor_UnexposedAttr() {\n+        return (int)400L;\n+    }\n+    public static int CXCursor_IBActionAttr() {\n+        return (int)401L;\n+    }\n+    public static int CXCursor_IBOutletAttr() {\n+        return (int)402L;\n+    }\n+    public static int CXCursor_IBOutletCollectionAttr() {\n+        return (int)403L;\n+    }\n+    public static int CXCursor_CXXFinalAttr() {\n+        return (int)404L;\n+    }\n+    public static int CXCursor_CXXOverrideAttr() {\n+        return (int)405L;\n+    }\n+    public static int CXCursor_AnnotateAttr() {\n+        return (int)406L;\n+    }\n+    public static int CXCursor_AsmLabelAttr() {\n+        return (int)407L;\n+    }\n+    public static int CXCursor_PackedAttr() {\n+        return (int)408L;\n+    }\n+    public static int CXCursor_PureAttr() {\n+        return (int)409L;\n+    }\n+    public static int CXCursor_ConstAttr() {\n+        return (int)410L;\n+    }\n+    public static int CXCursor_NoDuplicateAttr() {\n+        return (int)411L;\n+    }\n+    public static int CXCursor_CUDAConstantAttr() {\n+        return (int)412L;\n+    }\n+    public static int CXCursor_CUDADeviceAttr() {\n+        return (int)413L;\n+    }\n+    public static int CXCursor_CUDAGlobalAttr() {\n+        return (int)414L;\n+    }\n+    public static int CXCursor_CUDAHostAttr() {\n+        return (int)415L;\n+    }\n+    public static int CXCursor_CUDASharedAttr() {\n+        return (int)416L;\n+    }\n+    public static int CXCursor_VisibilityAttr() {\n+        return (int)417L;\n+    }\n+    public static int CXCursor_DLLExport() {\n+        return (int)418L;\n+    }\n+    public static int CXCursor_DLLImport() {\n+        return (int)419L;\n+    }\n+    public static int CXCursor_NSReturnsRetained() {\n+        return (int)420L;\n+    }\n+    public static int CXCursor_NSReturnsNotRetained() {\n+        return (int)421L;\n+    }\n+    public static int CXCursor_NSReturnsAutoreleased() {\n+        return (int)422L;\n+    }\n+    public static int CXCursor_NSConsumesSelf() {\n+        return (int)423L;\n+    }\n+    public static int CXCursor_NSConsumed() {\n+        return (int)424L;\n+    }\n+    public static int CXCursor_ObjCException() {\n+        return (int)425L;\n+    }\n+    public static int CXCursor_ObjCNSObject() {\n+        return (int)426L;\n+    }\n+    public static int CXCursor_ObjCIndependentClass() {\n+        return (int)427L;\n+    }\n+    public static int CXCursor_ObjCPreciseLifetime() {\n+        return (int)428L;\n+    }\n+    public static int CXCursor_ObjCReturnsInnerPointer() {\n+        return (int)429L;\n+    }\n+    public static int CXCursor_ObjCRequiresSuper() {\n+        return (int)430L;\n+    }\n+    public static int CXCursor_ObjCRootClass() {\n+        return (int)431L;\n+    }\n+    public static int CXCursor_ObjCSubclassingRestricted() {\n+        return (int)432L;\n+    }\n+    public static int CXCursor_ObjCExplicitProtocolImpl() {\n+        return (int)433L;\n+    }\n+    public static int CXCursor_ObjCDesignatedInitializer() {\n+        return (int)434L;\n+    }\n+    public static int CXCursor_ObjCRuntimeVisible() {\n+        return (int)435L;\n+    }\n+    public static int CXCursor_ObjCBoxable() {\n+        return (int)436L;\n+    }\n+    public static int CXCursor_FlagEnum() {\n+        return (int)437L;\n+    }\n+    public static int CXCursor_ConvergentAttr() {\n+        return (int)438L;\n+    }\n+    public static int CXCursor_WarnUnusedAttr() {\n+        return (int)439L;\n+    }\n+    public static int CXCursor_WarnUnusedResultAttr() {\n+        return (int)440L;\n+    }\n+    public static int CXCursor_AlignedAttr() {\n+        return (int)441L;\n+    }\n+    public static int CXCursor_LastAttr() {\n+        return (int)441L;\n+    }\n+    public static int CXCursor_PreprocessingDirective() {\n+        return (int)500L;\n+    }\n+    public static int CXCursor_MacroDefinition() {\n+        return (int)501L;\n+    }\n+    public static int CXCursor_MacroExpansion() {\n+        return (int)502L;\n+    }\n+    public static int CXCursor_MacroInstantiation() {\n+        return (int)502L;\n+    }\n+    public static int CXCursor_InclusionDirective() {\n+        return (int)503L;\n+    }\n+    public static int CXCursor_FirstPreprocessing() {\n+        return (int)500L;\n+    }\n+    public static int CXCursor_LastPreprocessing() {\n+        return (int)503L;\n+    }\n+    public static int CXCursor_ModuleImportDecl() {\n+        return (int)600L;\n+    }\n+    public static int CXCursor_TypeAliasTemplateDecl() {\n+        return (int)601L;\n+    }\n+    public static int CXCursor_StaticAssert() {\n+        return (int)602L;\n+    }\n+    public static int CXCursor_FriendDecl() {\n+        return (int)603L;\n+    }\n+    public static int CXCursor_FirstExtraDecl() {\n+        return (int)600L;\n+    }\n+    public static int CXCursor_LastExtraDecl() {\n+        return (int)603L;\n+    }\n+    public static int CXCursor_OverloadCandidate() {\n+        return (int)700L;\n+    }\n+    public static MethodHandle clang_getNullCursor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_getNullCursor$MH,\"clang_getNullCursor\");\n+    }\n+    public static MemorySegment clang_getNullCursor ( SegmentAllocator allocator) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_getNullCursor$MH, \"clang_getNullCursor\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getNullCursor ( ResourceScope scope) {\n+        return clang_getNullCursor(SegmentAllocator.ofScope(scope));\n+    }\n+    public static MethodHandle clang_getTranslationUnitCursor$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_getTranslationUnitCursor$MH,\"clang_getTranslationUnitCursor\");\n+    }\n+    public static MemorySegment clang_getTranslationUnitCursor ( SegmentAllocator allocator,  Addressable x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_getTranslationUnitCursor$MH, \"clang_getTranslationUnitCursor\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTranslationUnitCursor ( ResourceScope scope,  Addressable x1) {\n+        return clang_getTranslationUnitCursor(SegmentAllocator.ofScope(scope), x1.address());\n+    }\n+    public static MethodHandle clang_equalCursors$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_equalCursors$MH,\"clang_equalCursors\");\n+    }\n+    public static int clang_equalCursors ( MemorySegment x0,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_equalCursors$MH, \"clang_equalCursors\");\n+        try {\n+            return (int)mh$.invokeExact(x0, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isNull$MH() {\n+        return RuntimeHelper.requireNonNull(constants$5.clang_Cursor_isNull$MH,\"clang_Cursor_isNull\");\n+    }\n+    public static int clang_Cursor_isNull ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$5.clang_Cursor_isNull$MH, \"clang_Cursor_isNull\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_getCursorKind$MH,\"clang_getCursorKind\");\n+    }\n+    public static int clang_getCursorKind ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_getCursorKind$MH, \"clang_getCursorKind\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isDeclaration$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_isDeclaration$MH,\"clang_isDeclaration\");\n+    }\n+    public static int clang_isDeclaration ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_isDeclaration$MH, \"clang_isDeclaration\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isAttribute$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_isAttribute$MH,\"clang_isAttribute\");\n+    }\n+    public static int clang_isAttribute ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_isAttribute$MH, \"clang_isAttribute\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isInvalid$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_isInvalid$MH,\"clang_isInvalid\");\n+    }\n+    public static int clang_isInvalid ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_isInvalid$MH, \"clang_isInvalid\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isPreprocessing$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_isPreprocessing$MH,\"clang_isPreprocessing\");\n+    }\n+    public static int clang_isPreprocessing ( int x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_isPreprocessing$MH, \"clang_isPreprocessing\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXLanguage_Invalid() {\n+        return (int)0L;\n+    }\n+    public static int CXLanguage_C() {\n+        return (int)1L;\n+    }\n+    public static int CXLanguage_ObjC() {\n+        return (int)2L;\n+    }\n+    public static int CXLanguage_CPlusPlus() {\n+        return (int)3L;\n+    }\n+    public static MethodHandle clang_getCursorLanguage$MH() {\n+        return RuntimeHelper.requireNonNull(constants$6.clang_getCursorLanguage$MH,\"clang_getCursorLanguage\");\n+    }\n+    public static int clang_getCursorLanguage ( MemorySegment cursor) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$6.clang_getCursorLanguage$MH, \"clang_getCursorLanguage\");\n+        try {\n+            return (int)mh$.invokeExact(cursor);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getTranslationUnit$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_Cursor_getTranslationUnit$MH,\"clang_Cursor_getTranslationUnit\");\n+    }\n+    public static MemoryAddress clang_Cursor_getTranslationUnit ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_Cursor_getTranslationUnit$MH, \"clang_Cursor_getTranslationUnit\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorLocation$MH,\"clang_getCursorLocation\");\n+    }\n+    public static MemorySegment clang_getCursorLocation ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getCursorLocation$MH, \"clang_getCursorLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorLocation ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorLocation(SegmentAllocator.ofScope(scope), x1);\n+    }\n+    public static MethodHandle clang_getCursorExtent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorExtent$MH,\"clang_getCursorExtent\");\n+    }\n+    public static MemorySegment clang_getCursorExtent ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getCursorExtent$MH, \"clang_getCursorExtent\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorExtent ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorExtent(SegmentAllocator.ofScope(scope), x1);\n+    }\n+    public static int CXType_Invalid() {\n+        return (int)0L;\n+    }\n+    public static int CXType_Unexposed() {\n+        return (int)1L;\n+    }\n+    public static int CXType_Void() {\n+        return (int)2L;\n+    }\n+    public static int CXType_Bool() {\n+        return (int)3L;\n+    }\n+    public static int CXType_Char_U() {\n+        return (int)4L;\n+    }\n+    public static int CXType_UChar() {\n+        return (int)5L;\n+    }\n+    public static int CXType_Char16() {\n+        return (int)6L;\n+    }\n+    public static int CXType_Char32() {\n+        return (int)7L;\n+    }\n+    public static int CXType_UShort() {\n+        return (int)8L;\n+    }\n+    public static int CXType_UInt() {\n+        return (int)9L;\n+    }\n+    public static int CXType_ULong() {\n+        return (int)10L;\n+    }\n+    public static int CXType_ULongLong() {\n+        return (int)11L;\n+    }\n+    public static int CXType_UInt128() {\n+        return (int)12L;\n+    }\n+    public static int CXType_Char_S() {\n+        return (int)13L;\n+    }\n+    public static int CXType_SChar() {\n+        return (int)14L;\n+    }\n+    public static int CXType_WChar() {\n+        return (int)15L;\n+    }\n+    public static int CXType_Short() {\n+        return (int)16L;\n+    }\n+    public static int CXType_Int() {\n+        return (int)17L;\n+    }\n+    public static int CXType_Long() {\n+        return (int)18L;\n+    }\n+    public static int CXType_LongLong() {\n+        return (int)19L;\n+    }\n+    public static int CXType_Int128() {\n+        return (int)20L;\n+    }\n+    public static int CXType_Float() {\n+        return (int)21L;\n+    }\n+    public static int CXType_Double() {\n+        return (int)22L;\n+    }\n+    public static int CXType_LongDouble() {\n+        return (int)23L;\n+    }\n+    public static int CXType_NullPtr() {\n+        return (int)24L;\n+    }\n+    public static int CXType_Overload() {\n+        return (int)25L;\n+    }\n+    public static int CXType_Dependent() {\n+        return (int)26L;\n+    }\n+    public static int CXType_ObjCId() {\n+        return (int)27L;\n+    }\n+    public static int CXType_ObjCClass() {\n+        return (int)28L;\n+    }\n+    public static int CXType_ObjCSel() {\n+        return (int)29L;\n+    }\n+    public static int CXType_Float128() {\n+        return (int)30L;\n+    }\n+    public static int CXType_Half() {\n+        return (int)31L;\n+    }\n+    public static int CXType_Float16() {\n+        return (int)32L;\n+    }\n+    public static int CXType_ShortAccum() {\n+        return (int)33L;\n+    }\n+    public static int CXType_Accum() {\n+        return (int)34L;\n+    }\n+    public static int CXType_LongAccum() {\n+        return (int)35L;\n+    }\n+    public static int CXType_UShortAccum() {\n+        return (int)36L;\n+    }\n+    public static int CXType_UAccum() {\n+        return (int)37L;\n+    }\n+    public static int CXType_ULongAccum() {\n+        return (int)38L;\n+    }\n+    public static int CXType_FirstBuiltin() {\n+        return (int)2L;\n+    }\n+    public static int CXType_LastBuiltin() {\n+        return (int)38L;\n+    }\n+    public static int CXType_Complex() {\n+        return (int)100L;\n+    }\n+    public static int CXType_Pointer() {\n+        return (int)101L;\n+    }\n+    public static int CXType_BlockPointer() {\n+        return (int)102L;\n+    }\n+    public static int CXType_LValueReference() {\n+        return (int)103L;\n+    }\n+    public static int CXType_RValueReference() {\n+        return (int)104L;\n+    }\n+    public static int CXType_Record() {\n+        return (int)105L;\n+    }\n+    public static int CXType_Enum() {\n+        return (int)106L;\n+    }\n+    public static int CXType_Typedef() {\n+        return (int)107L;\n+    }\n+    public static int CXType_ObjCInterface() {\n+        return (int)108L;\n+    }\n+    public static int CXType_ObjCObjectPointer() {\n+        return (int)109L;\n+    }\n+    public static int CXType_FunctionNoProto() {\n+        return (int)110L;\n+    }\n+    public static int CXType_FunctionProto() {\n+        return (int)111L;\n+    }\n+    public static int CXType_ConstantArray() {\n+        return (int)112L;\n+    }\n+    public static int CXType_Vector() {\n+        return (int)113L;\n+    }\n+    public static int CXType_IncompleteArray() {\n+        return (int)114L;\n+    }\n+    public static int CXType_VariableArray() {\n+        return (int)115L;\n+    }\n+    public static int CXType_DependentSizedArray() {\n+        return (int)116L;\n+    }\n+    public static int CXType_MemberPointer() {\n+        return (int)117L;\n+    }\n+    public static int CXType_Auto() {\n+        return (int)118L;\n+    }\n+    public static int CXType_Elaborated() {\n+        return (int)119L;\n+    }\n+    public static int CXType_Pipe() {\n+        return (int)120L;\n+    }\n+    public static int CXType_OCLImage1dRO() {\n+        return (int)121L;\n+    }\n+    public static int CXType_OCLImage1dArrayRO() {\n+        return (int)122L;\n+    }\n+    public static int CXType_OCLImage1dBufferRO() {\n+        return (int)123L;\n+    }\n+    public static int CXType_OCLImage2dRO() {\n+        return (int)124L;\n+    }\n+    public static int CXType_OCLImage2dArrayRO() {\n+        return (int)125L;\n+    }\n+    public static int CXType_OCLImage2dDepthRO() {\n+        return (int)126L;\n+    }\n+    public static int CXType_OCLImage2dArrayDepthRO() {\n+        return (int)127L;\n+    }\n+    public static int CXType_OCLImage2dMSAARO() {\n+        return (int)128L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAARO() {\n+        return (int)129L;\n+    }\n+    public static int CXType_OCLImage2dMSAADepthRO() {\n+        return (int)130L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAADepthRO() {\n+        return (int)131L;\n+    }\n+    public static int CXType_OCLImage3dRO() {\n+        return (int)132L;\n+    }\n+    public static int CXType_OCLImage1dWO() {\n+        return (int)133L;\n+    }\n+    public static int CXType_OCLImage1dArrayWO() {\n+        return (int)134L;\n+    }\n+    public static int CXType_OCLImage1dBufferWO() {\n+        return (int)135L;\n+    }\n+    public static int CXType_OCLImage2dWO() {\n+        return (int)136L;\n+    }\n+    public static int CXType_OCLImage2dArrayWO() {\n+        return (int)137L;\n+    }\n+    public static int CXType_OCLImage2dDepthWO() {\n+        return (int)138L;\n+    }\n+    public static int CXType_OCLImage2dArrayDepthWO() {\n+        return (int)139L;\n+    }\n+    public static int CXType_OCLImage2dMSAAWO() {\n+        return (int)140L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAAWO() {\n+        return (int)141L;\n+    }\n+    public static int CXType_OCLImage2dMSAADepthWO() {\n+        return (int)142L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAADepthWO() {\n+        return (int)143L;\n+    }\n+    public static int CXType_OCLImage3dWO() {\n+        return (int)144L;\n+    }\n+    public static int CXType_OCLImage1dRW() {\n+        return (int)145L;\n+    }\n+    public static int CXType_OCLImage1dArrayRW() {\n+        return (int)146L;\n+    }\n+    public static int CXType_OCLImage1dBufferRW() {\n+        return (int)147L;\n+    }\n+    public static int CXType_OCLImage2dRW() {\n+        return (int)148L;\n+    }\n+    public static int CXType_OCLImage2dArrayRW() {\n+        return (int)149L;\n+    }\n+    public static int CXType_OCLImage2dDepthRW() {\n+        return (int)150L;\n+    }\n+    public static int CXType_OCLImage2dArrayDepthRW() {\n+        return (int)151L;\n+    }\n+    public static int CXType_OCLImage2dMSAARW() {\n+        return (int)152L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAARW() {\n+        return (int)153L;\n+    }\n+    public static int CXType_OCLImage2dMSAADepthRW() {\n+        return (int)154L;\n+    }\n+    public static int CXType_OCLImage2dArrayMSAADepthRW() {\n+        return (int)155L;\n+    }\n+    public static int CXType_OCLImage3dRW() {\n+        return (int)156L;\n+    }\n+    public static int CXType_OCLSampler() {\n+        return (int)157L;\n+    }\n+    public static int CXType_OCLEvent() {\n+        return (int)158L;\n+    }\n+    public static int CXType_OCLQueue() {\n+        return (int)159L;\n+    }\n+    public static int CXType_OCLReserveID() {\n+        return (int)160L;\n+    }\n+    public static int CXType_ObjCObject() {\n+        return (int)161L;\n+    }\n+    public static int CXType_ObjCTypeParam() {\n+        return (int)162L;\n+    }\n+    public static int CXType_Attributed() {\n+        return (int)163L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCMcePayload() {\n+        return (int)164L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImePayload() {\n+        return (int)165L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCRefPayload() {\n+        return (int)166L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCSicPayload() {\n+        return (int)167L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCMceResult() {\n+        return (int)168L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeResult() {\n+        return (int)169L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCRefResult() {\n+        return (int)170L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCSicResult() {\n+        return (int)171L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeResultSingleRefStreamout() {\n+        return (int)172L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeResultDualRefStreamout() {\n+        return (int)173L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeSingleRefStreamin() {\n+        return (int)174L;\n+    }\n+    public static int CXType_OCLIntelSubgroupAVCImeDualRefStreamin() {\n+        return (int)175L;\n+    }\n+    public static int CXType_ExtVector() {\n+        return (int)176L;\n+    }\n+    public static int CXCallingConv_Default() {\n+        return (int)0L;\n+    }\n+    public static int CXCallingConv_C() {\n+        return (int)1L;\n+    }\n+    public static int CXCallingConv_X86StdCall() {\n+        return (int)2L;\n+    }\n+    public static int CXCallingConv_X86FastCall() {\n+        return (int)3L;\n+    }\n+    public static int CXCallingConv_X86ThisCall() {\n+        return (int)4L;\n+    }\n+    public static int CXCallingConv_X86Pascal() {\n+        return (int)5L;\n+    }\n+    public static int CXCallingConv_AAPCS() {\n+        return (int)6L;\n+    }\n+    public static int CXCallingConv_AAPCS_VFP() {\n+        return (int)7L;\n+    }\n+    public static int CXCallingConv_X86RegCall() {\n+        return (int)8L;\n+    }\n+    public static int CXCallingConv_IntelOclBicc() {\n+        return (int)9L;\n+    }\n+    public static int CXCallingConv_Win64() {\n+        return (int)10L;\n+    }\n+    public static int CXCallingConv_X86_64Win64() {\n+        return (int)10L;\n+    }\n+    public static int CXCallingConv_X86_64SysV() {\n+        return (int)11L;\n+    }\n+    public static int CXCallingConv_X86VectorCall() {\n+        return (int)12L;\n+    }\n+    public static int CXCallingConv_Swift() {\n+        return (int)13L;\n+    }\n+    public static int CXCallingConv_PreserveMost() {\n+        return (int)14L;\n+    }\n+    public static int CXCallingConv_PreserveAll() {\n+        return (int)15L;\n+    }\n+    public static int CXCallingConv_AArch64VectorCall() {\n+        return (int)16L;\n+    }\n+    public static int CXCallingConv_Invalid() {\n+        return (int)100L;\n+    }\n+    public static int CXCallingConv_Unexposed() {\n+        return (int)200L;\n+    }\n+    public static MethodHandle clang_getCursorType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getCursorType$MH,\"clang_getCursorType\");\n+    }\n+    public static MemorySegment clang_getCursorType ( SegmentAllocator allocator,  MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getCursorType$MH, \"clang_getCursorType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorType ( ResourceScope scope,  MemorySegment C) {\n+        return clang_getCursorType(SegmentAllocator.ofScope(scope), C);\n+    }\n+    public static MethodHandle clang_getTypeSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getTypeSpelling$MH,\"clang_getTypeSpelling\");\n+    }\n+    public static MemorySegment clang_getTypeSpelling ( SegmentAllocator allocator,  MemorySegment CT) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getTypeSpelling$MH, \"clang_getTypeSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, CT);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypeSpelling ( ResourceScope scope,  MemorySegment CT) {\n+        return clang_getTypeSpelling(SegmentAllocator.ofScope(scope), CT);\n+    }\n+    public static MethodHandle clang_getTypedefDeclUnderlyingType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$7.clang_getTypedefDeclUnderlyingType$MH,\"clang_getTypedefDeclUnderlyingType\");\n+    }\n+    public static MemorySegment clang_getTypedefDeclUnderlyingType ( SegmentAllocator allocator,  MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$7.clang_getTypedefDeclUnderlyingType$MH, \"clang_getTypedefDeclUnderlyingType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypedefDeclUnderlyingType ( ResourceScope scope,  MemorySegment C) {\n+        return clang_getTypedefDeclUnderlyingType(SegmentAllocator.ofScope(scope), C);\n+    }\n+    public static MethodHandle clang_getEnumDeclIntegerType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumDeclIntegerType$MH,\"clang_getEnumDeclIntegerType\");\n+    }\n+    public static MemorySegment clang_getEnumDeclIntegerType ( SegmentAllocator allocator,  MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getEnumDeclIntegerType$MH, \"clang_getEnumDeclIntegerType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getEnumDeclIntegerType ( ResourceScope scope,  MemorySegment C) {\n+        return clang_getEnumDeclIntegerType(SegmentAllocator.ofScope(scope), C);\n+    }\n+    public static MethodHandle clang_getEnumConstantDeclValue$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclValue$MH,\"clang_getEnumConstantDeclValue\");\n+    }\n+    public static long clang_getEnumConstantDeclValue ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclValue$MH, \"clang_getEnumConstantDeclValue\");\n+        try {\n+            return (long)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getEnumConstantDeclUnsignedValue$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclUnsignedValue$MH,\"clang_getEnumConstantDeclUnsignedValue\");\n+    }\n+    public static long clang_getEnumConstantDeclUnsignedValue ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getEnumConstantDeclUnsignedValue$MH, \"clang_getEnumConstantDeclUnsignedValue\");\n+        try {\n+            return (long)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getFieldDeclBitWidth$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_getFieldDeclBitWidth$MH,\"clang_getFieldDeclBitWidth\");\n+    }\n+    public static int clang_getFieldDeclBitWidth ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_getFieldDeclBitWidth$MH, \"clang_getFieldDeclBitWidth\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getNumArguments$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getNumArguments$MH,\"clang_Cursor_getNumArguments\");\n+    }\n+    public static int clang_Cursor_getNumArguments ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getNumArguments$MH, \"clang_Cursor_getNumArguments\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getArgument$MH() {\n+        return RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getArgument$MH,\"clang_Cursor_getArgument\");\n+    }\n+    public static MemorySegment clang_Cursor_getArgument ( SegmentAllocator allocator,  MemorySegment C,  int i) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$8.clang_Cursor_getArgument$MH, \"clang_Cursor_getArgument\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C, i);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_Cursor_getArgument ( ResourceScope scope,  MemorySegment C,  int i) {\n+        return clang_Cursor_getArgument(SegmentAllocator.ofScope(scope), C, i);\n+    }\n+    public static MethodHandle clang_equalTypes$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_equalTypes$MH,\"clang_equalTypes\");\n+    }\n+    public static int clang_equalTypes ( MemorySegment A,  MemorySegment B) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_equalTypes$MH, \"clang_equalTypes\");\n+        try {\n+            return (int)mh$.invokeExact(A, B);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCanonicalType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_getCanonicalType$MH,\"clang_getCanonicalType\");\n+    }\n+    public static MemorySegment clang_getCanonicalType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_getCanonicalType$MH, \"clang_getCanonicalType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCanonicalType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getCanonicalType(SegmentAllocator.ofScope(scope), T);\n+    }\n+    public static MethodHandle clang_isConstQualifiedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_isConstQualifiedType$MH,\"clang_isConstQualifiedType\");\n+    }\n+    public static int clang_isConstQualifiedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_isConstQualifiedType$MH, \"clang_isConstQualifiedType\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isMacroFunctionLike$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_Cursor_isMacroFunctionLike$MH,\"clang_Cursor_isMacroFunctionLike\");\n+    }\n+    public static int clang_Cursor_isMacroFunctionLike ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_Cursor_isMacroFunctionLike$MH, \"clang_Cursor_isMacroFunctionLike\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_isVolatileQualifiedType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_isVolatileQualifiedType$MH,\"clang_isVolatileQualifiedType\");\n+    }\n+    public static int clang_isVolatileQualifiedType ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_isVolatileQualifiedType$MH, \"clang_isVolatileQualifiedType\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTypedefName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$9.clang_getTypedefName$MH,\"clang_getTypedefName\");\n+    }\n+    public static MemorySegment clang_getTypedefName ( SegmentAllocator allocator,  MemorySegment CT) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$9.clang_getTypedefName$MH, \"clang_getTypedefName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, CT);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypedefName ( ResourceScope scope,  MemorySegment CT) {\n+        return clang_getTypedefName(SegmentAllocator.ofScope(scope), CT);\n+    }\n+    public static MethodHandle clang_getPointeeType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getPointeeType$MH,\"clang_getPointeeType\");\n+    }\n+    public static MemorySegment clang_getPointeeType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getPointeeType$MH, \"clang_getPointeeType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getPointeeType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getPointeeType(SegmentAllocator.ofScope(scope), T);\n+    }\n+    public static MethodHandle clang_getTypeDeclaration$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getTypeDeclaration$MH,\"clang_getTypeDeclaration\");\n+    }\n+    public static MemorySegment clang_getTypeDeclaration ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getTypeDeclaration$MH, \"clang_getTypeDeclaration\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypeDeclaration ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getTypeDeclaration(SegmentAllocator.ofScope(scope), T);\n+    }\n+    public static MethodHandle clang_getTypeKindSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getTypeKindSpelling$MH,\"clang_getTypeKindSpelling\");\n+    }\n+    public static MemorySegment clang_getTypeKindSpelling ( SegmentAllocator allocator,  int K) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getTypeKindSpelling$MH, \"clang_getTypeKindSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, K);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTypeKindSpelling ( ResourceScope scope,  int K) {\n+        return clang_getTypeKindSpelling(SegmentAllocator.ofScope(scope), K);\n+    }\n+    public static MethodHandle clang_getFunctionTypeCallingConv$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getFunctionTypeCallingConv$MH,\"clang_getFunctionTypeCallingConv\");\n+    }\n+    public static int clang_getFunctionTypeCallingConv ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getFunctionTypeCallingConv$MH, \"clang_getFunctionTypeCallingConv\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getResultType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getResultType$MH,\"clang_getResultType\");\n+    }\n+    public static MemorySegment clang_getResultType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getResultType$MH, \"clang_getResultType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getResultType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getResultType(SegmentAllocator.ofScope(scope), T);\n+    }\n+    public static MethodHandle clang_getNumArgTypes$MH() {\n+        return RuntimeHelper.requireNonNull(constants$10.clang_getNumArgTypes$MH,\"clang_getNumArgTypes\");\n+    }\n+    public static int clang_getNumArgTypes ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$10.clang_getNumArgTypes$MH, \"clang_getNumArgTypes\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getArgType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getArgType$MH,\"clang_getArgType\");\n+    }\n+    public static MemorySegment clang_getArgType ( SegmentAllocator allocator,  MemorySegment T,  int i) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getArgType$MH, \"clang_getArgType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T, i);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getArgType ( ResourceScope scope,  MemorySegment T,  int i) {\n+        return clang_getArgType(SegmentAllocator.ofScope(scope), T, i);\n+    }\n+    public static MethodHandle clang_isFunctionTypeVariadic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_isFunctionTypeVariadic$MH,\"clang_isFunctionTypeVariadic\");\n+    }\n+    public static int clang_isFunctionTypeVariadic ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_isFunctionTypeVariadic$MH, \"clang_isFunctionTypeVariadic\");\n+        try {\n+            return (int)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorResultType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getCursorResultType$MH,\"clang_getCursorResultType\");\n+    }\n+    public static MemorySegment clang_getCursorResultType ( SegmentAllocator allocator,  MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getCursorResultType$MH, \"clang_getCursorResultType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorResultType ( ResourceScope scope,  MemorySegment C) {\n+        return clang_getCursorResultType(SegmentAllocator.ofScope(scope), C);\n+    }\n+    public static MethodHandle clang_getElementType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getElementType$MH,\"clang_getElementType\");\n+    }\n+    public static MemorySegment clang_getElementType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getElementType$MH, \"clang_getElementType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getElementType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getElementType(SegmentAllocator.ofScope(scope), T);\n+    }\n+    public static MethodHandle clang_getNumElements$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getNumElements$MH,\"clang_getNumElements\");\n+    }\n+    public static long clang_getNumElements ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getNumElements$MH, \"clang_getNumElements\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getArrayElementType$MH() {\n+        return RuntimeHelper.requireNonNull(constants$11.clang_getArrayElementType$MH,\"clang_getArrayElementType\");\n+    }\n+    public static MemorySegment clang_getArrayElementType ( SegmentAllocator allocator,  MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$11.clang_getArrayElementType$MH, \"clang_getArrayElementType\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getArrayElementType ( ResourceScope scope,  MemorySegment T) {\n+        return clang_getArrayElementType(SegmentAllocator.ofScope(scope), T);\n+    }\n+    public static MethodHandle clang_getArraySize$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_getArraySize$MH,\"clang_getArraySize\");\n+    }\n+    public static long clang_getArraySize ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_getArraySize$MH, \"clang_getArraySize\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXTypeNullability_NonNull() {\n+        return (int)0L;\n+    }\n+    public static int CXTypeNullability_Nullable() {\n+        return (int)1L;\n+    }\n+    public static int CXTypeNullability_Unspecified() {\n+        return (int)2L;\n+    }\n+    public static int CXTypeNullability_Invalid() {\n+        return (int)3L;\n+    }\n+    public static int CXTypeLayoutError_Invalid() {\n+        return (int)-1L;\n+    }\n+    public static int CXTypeLayoutError_Incomplete() {\n+        return (int)-2L;\n+    }\n+    public static int CXTypeLayoutError_Dependent() {\n+        return (int)-3L;\n+    }\n+    public static int CXTypeLayoutError_NotConstantSize() {\n+        return (int)-4L;\n+    }\n+    public static int CXTypeLayoutError_InvalidFieldName() {\n+        return (int)-5L;\n+    }\n+    public static int CXTypeLayoutError_Undeduced() {\n+        return (int)-6L;\n+    }\n+    public static MethodHandle clang_Type_getSizeOf$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getSizeOf$MH,\"clang_Type_getSizeOf\");\n+    }\n+    public static long clang_Type_getSizeOf ( MemorySegment T) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Type_getSizeOf$MH, \"clang_Type_getSizeOf\");\n+        try {\n+            return (long)mh$.invokeExact(T);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Type_getOffsetOf$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Type_getOffsetOf$MH,\"clang_Type_getOffsetOf\");\n+    }\n+    public static long clang_Type_getOffsetOf ( MemorySegment T,  Addressable S) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Type_getOffsetOf$MH, \"clang_Type_getOffsetOf\");\n+        try {\n+            return (long)mh$.invokeExact(T, S.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isAnonymous$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymous$MH,\"clang_Cursor_isAnonymous\");\n+    }\n+    public static int clang_Cursor_isAnonymous ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymous$MH, \"clang_Cursor_isAnonymous\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isAnonymousRecordDecl$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymousRecordDecl$MH,\"clang_Cursor_isAnonymousRecordDecl\");\n+    }\n+    public static int clang_Cursor_isAnonymousRecordDecl ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isAnonymousRecordDecl$MH, \"clang_Cursor_isAnonymousRecordDecl\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isBitField$MH() {\n+        return RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isBitField$MH,\"clang_Cursor_isBitField\");\n+    }\n+    public static int clang_Cursor_isBitField ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$12.clang_Cursor_isBitField$MH, \"clang_Cursor_isBitField\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXChildVisit_Break() {\n+        return (int)0L;\n+    }\n+    public static int CXChildVisit_Continue() {\n+        return (int)1L;\n+    }\n+    public static int CXChildVisit_Recurse() {\n+        return (int)2L;\n+    }\n+    public static MethodHandle clang_visitChildren$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_visitChildren$MH,\"clang_visitChildren\");\n+    }\n+    public static int clang_visitChildren ( MemorySegment parent,  Addressable visitor,  Addressable client_data) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_visitChildren$MH, \"clang_visitChildren\");\n+        try {\n+            return (int)mh$.invokeExact(parent, visitor.address(), client_data.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorUSR$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_getCursorUSR$MH,\"clang_getCursorUSR\");\n+    }\n+    public static MemorySegment clang_getCursorUSR ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_getCursorUSR$MH, \"clang_getCursorUSR\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorUSR ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorUSR(SegmentAllocator.ofScope(scope), x1);\n+    }\n+    public static MethodHandle clang_getCursorSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_getCursorSpelling$MH,\"clang_getCursorSpelling\");\n+    }\n+    public static MemorySegment clang_getCursorSpelling ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_getCursorSpelling$MH, \"clang_getCursorSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorSpelling ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorSpelling(SegmentAllocator.ofScope(scope), x1);\n+    }\n+    public static int CXPrintingPolicy_Indentation() {\n+        return (int)0L;\n+    }\n+    public static int CXPrintingPolicy_SuppressSpecifiers() {\n+        return (int)1L;\n+    }\n+    public static int CXPrintingPolicy_SuppressTagKeyword() {\n+        return (int)2L;\n+    }\n+    public static int CXPrintingPolicy_IncludeTagDefinition() {\n+        return (int)3L;\n+    }\n+    public static int CXPrintingPolicy_SuppressScope() {\n+        return (int)4L;\n+    }\n+    public static int CXPrintingPolicy_SuppressUnwrittenScope() {\n+        return (int)5L;\n+    }\n+    public static int CXPrintingPolicy_SuppressInitializers() {\n+        return (int)6L;\n+    }\n+    public static int CXPrintingPolicy_ConstantArraySizeAsWritten() {\n+        return (int)7L;\n+    }\n+    public static int CXPrintingPolicy_AnonymousTagLocations() {\n+        return (int)8L;\n+    }\n+    public static int CXPrintingPolicy_SuppressStrongLifetime() {\n+        return (int)9L;\n+    }\n+    public static int CXPrintingPolicy_SuppressLifetimeQualifiers() {\n+        return (int)10L;\n+    }\n+    public static int CXPrintingPolicy_SuppressTemplateArgsInCXXConstructors() {\n+        return (int)11L;\n+    }\n+    public static int CXPrintingPolicy_Bool() {\n+        return (int)12L;\n+    }\n+    public static int CXPrintingPolicy_Restrict() {\n+        return (int)13L;\n+    }\n+    public static int CXPrintingPolicy_Alignof() {\n+        return (int)14L;\n+    }\n+    public static int CXPrintingPolicy_UnderscoreAlignof() {\n+        return (int)15L;\n+    }\n+    public static int CXPrintingPolicy_UseVoidForZeroParams() {\n+        return (int)16L;\n+    }\n+    public static int CXPrintingPolicy_TerseOutput() {\n+        return (int)17L;\n+    }\n+    public static int CXPrintingPolicy_PolishForDeclaration() {\n+        return (int)18L;\n+    }\n+    public static int CXPrintingPolicy_Half() {\n+        return (int)19L;\n+    }\n+    public static int CXPrintingPolicy_MSWChar() {\n+        return (int)20L;\n+    }\n+    public static int CXPrintingPolicy_IncludeNewlines() {\n+        return (int)21L;\n+    }\n+    public static int CXPrintingPolicy_MSVCFormatting() {\n+        return (int)22L;\n+    }\n+    public static int CXPrintingPolicy_ConstantsAsWritten() {\n+        return (int)23L;\n+    }\n+    public static int CXPrintingPolicy_SuppressImplicitBase() {\n+        return (int)24L;\n+    }\n+    public static int CXPrintingPolicy_FullyQualifiedName() {\n+        return (int)25L;\n+    }\n+    public static int CXPrintingPolicy_LastProperty() {\n+        return (int)25L;\n+    }\n+    public static MethodHandle clang_PrintingPolicy_getProperty$MH() {\n+        return RuntimeHelper.requireNonNull(constants$13.clang_PrintingPolicy_getProperty$MH,\"clang_PrintingPolicy_getProperty\");\n+    }\n+    public static int clang_PrintingPolicy_getProperty ( Addressable Policy,  int Property) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$13.clang_PrintingPolicy_getProperty$MH, \"clang_PrintingPolicy_getProperty\");\n+        try {\n+            return (int)mh$.invokeExact(Policy.address(), Property);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_PrintingPolicy_setProperty$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_setProperty$MH,\"clang_PrintingPolicy_setProperty\");\n+    }\n+    public static void clang_PrintingPolicy_setProperty ( Addressable Policy,  int Property,  int Value) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_setProperty$MH, \"clang_PrintingPolicy_setProperty\");\n+        try {\n+            mh$.invokeExact(Policy.address(), Property, Value);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorPrintingPolicy$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrintingPolicy$MH,\"clang_getCursorPrintingPolicy\");\n+    }\n+    public static MemoryAddress clang_getCursorPrintingPolicy ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrintingPolicy$MH, \"clang_getCursorPrintingPolicy\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_PrintingPolicy_dispose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_dispose$MH,\"clang_PrintingPolicy_dispose\");\n+    }\n+    public static void clang_PrintingPolicy_dispose ( Addressable Policy) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_PrintingPolicy_dispose$MH, \"clang_PrintingPolicy_dispose\");\n+        try {\n+            mh$.invokeExact(Policy.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorPrettyPrinted$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrettyPrinted$MH,\"clang_getCursorPrettyPrinted\");\n+    }\n+    public static MemorySegment clang_getCursorPrettyPrinted ( SegmentAllocator allocator,  MemorySegment Cursor,  Addressable Policy) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_getCursorPrettyPrinted$MH, \"clang_getCursorPrettyPrinted\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Cursor, Policy.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorPrettyPrinted ( ResourceScope scope,  MemorySegment Cursor,  Addressable Policy) {\n+        return clang_getCursorPrettyPrinted(SegmentAllocator.ofScope(scope), Cursor, Policy.address());\n+    }\n+    public static MethodHandle clang_getCursorDisplayName$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorDisplayName$MH,\"clang_getCursorDisplayName\");\n+    }\n+    public static MemorySegment clang_getCursorDisplayName ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_getCursorDisplayName$MH, \"clang_getCursorDisplayName\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorDisplayName ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorDisplayName(SegmentAllocator.ofScope(scope), x1);\n+    }\n+    public static MethodHandle clang_getCursorReferenced$MH() {\n+        return RuntimeHelper.requireNonNull(constants$14.clang_getCursorReferenced$MH,\"clang_getCursorReferenced\");\n+    }\n+    public static MemorySegment clang_getCursorReferenced ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$14.clang_getCursorReferenced$MH, \"clang_getCursorReferenced\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorReferenced ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorReferenced(SegmentAllocator.ofScope(scope), x1);\n+    }\n+    public static MethodHandle clang_getCursorDefinition$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_getCursorDefinition$MH,\"clang_getCursorDefinition\");\n+    }\n+    public static MemorySegment clang_getCursorDefinition ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_getCursorDefinition$MH, \"clang_getCursorDefinition\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorDefinition ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_getCursorDefinition(SegmentAllocator.ofScope(scope), x1);\n+    }\n+    public static MethodHandle clang_isCursorDefinition$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_isCursorDefinition$MH,\"clang_isCursorDefinition\");\n+    }\n+    public static int clang_isCursorDefinition ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_isCursorDefinition$MH, \"clang_isCursorDefinition\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_isVariadic$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_Cursor_isVariadic$MH,\"clang_Cursor_isVariadic\");\n+    }\n+    public static int clang_Cursor_isVariadic ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_Cursor_isVariadic$MH, \"clang_Cursor_isVariadic\");\n+        try {\n+            return (int)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_getMangling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_Cursor_getMangling$MH,\"clang_Cursor_getMangling\");\n+    }\n+    public static MemorySegment clang_Cursor_getMangling ( SegmentAllocator allocator,  MemorySegment x1) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_Cursor_getMangling$MH, \"clang_Cursor_getMangling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_Cursor_getMangling ( ResourceScope scope,  MemorySegment x1) {\n+        return clang_Cursor_getMangling(SegmentAllocator.ofScope(scope), x1);\n+    }\n+    public static int CXToken_Punctuation() {\n+        return (int)0L;\n+    }\n+    public static int CXToken_Keyword() {\n+        return (int)1L;\n+    }\n+    public static int CXToken_Identifier() {\n+        return (int)2L;\n+    }\n+    public static int CXToken_Literal() {\n+        return (int)3L;\n+    }\n+    public static int CXToken_Comment() {\n+        return (int)4L;\n+    }\n+    public static MethodHandle clang_getTokenKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_getTokenKind$MH,\"clang_getTokenKind\");\n+    }\n+    public static int clang_getTokenKind ( MemorySegment x0) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_getTokenKind$MH, \"clang_getTokenKind\");\n+        try {\n+            return (int)mh$.invokeExact(x0);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getTokenSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$15.clang_getTokenSpelling$MH,\"clang_getTokenSpelling\");\n+    }\n+    public static MemorySegment clang_getTokenSpelling ( SegmentAllocator allocator,  Addressable x1,  MemorySegment x2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$15.clang_getTokenSpelling$MH, \"clang_getTokenSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address(), x2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTokenSpelling ( ResourceScope scope,  Addressable x1,  MemorySegment x2) {\n+        return clang_getTokenSpelling(SegmentAllocator.ofScope(scope), x1.address(), x2);\n+    }\n+    public static MethodHandle clang_getTokenLocation$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenLocation$MH,\"clang_getTokenLocation\");\n+    }\n+    public static MemorySegment clang_getTokenLocation ( SegmentAllocator allocator,  Addressable x1,  MemorySegment x2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getTokenLocation$MH, \"clang_getTokenLocation\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address(), x2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTokenLocation ( ResourceScope scope,  Addressable x1,  MemorySegment x2) {\n+        return clang_getTokenLocation(SegmentAllocator.ofScope(scope), x1.address(), x2);\n+    }\n+    public static MethodHandle clang_getTokenExtent$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getTokenExtent$MH,\"clang_getTokenExtent\");\n+    }\n+    public static MemorySegment clang_getTokenExtent ( SegmentAllocator allocator,  Addressable x1,  MemorySegment x2) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getTokenExtent$MH, \"clang_getTokenExtent\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, x1.address(), x2);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getTokenExtent ( ResourceScope scope,  Addressable x1,  MemorySegment x2) {\n+        return clang_getTokenExtent(SegmentAllocator.ofScope(scope), x1.address(), x2);\n+    }\n+    public static MethodHandle clang_tokenize$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_tokenize$MH,\"clang_tokenize\");\n+    }\n+    public static void clang_tokenize ( Addressable TU,  MemorySegment Range,  Addressable Tokens,  Addressable NumTokens) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_tokenize$MH, \"clang_tokenize\");\n+        try {\n+            mh$.invokeExact(TU.address(), Range, Tokens.address(), NumTokens.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_disposeTokens$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_disposeTokens$MH,\"clang_disposeTokens\");\n+    }\n+    public static void clang_disposeTokens ( Addressable TU,  Addressable Tokens,  int NumTokens) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_disposeTokens$MH, \"clang_disposeTokens\");\n+        try {\n+            mh$.invokeExact(TU.address(), Tokens.address(), NumTokens);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_getCursorKindSpelling$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getCursorKindSpelling$MH,\"clang_getCursorKindSpelling\");\n+    }\n+    public static MemorySegment clang_getCursorKindSpelling ( SegmentAllocator allocator,  int Kind) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getCursorKindSpelling$MH, \"clang_getCursorKindSpelling\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator, Kind);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getCursorKindSpelling ( ResourceScope scope,  int Kind) {\n+        return clang_getCursorKindSpelling(SegmentAllocator.ofScope(scope), Kind);\n+    }\n+    public static MethodHandle clang_getClangVersion$MH() {\n+        return RuntimeHelper.requireNonNull(constants$16.clang_getClangVersion$MH,\"clang_getClangVersion\");\n+    }\n+    public static MemorySegment clang_getClangVersion ( SegmentAllocator allocator) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$16.clang_getClangVersion$MH, \"clang_getClangVersion\");\n+        try {\n+            return (jdk.incubator.foreign.MemorySegment)mh$.invokeExact(allocator);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MemorySegment clang_getClangVersion ( ResourceScope scope) {\n+        return clang_getClangVersion(SegmentAllocator.ofScope(scope));\n+    }\n+    public static MethodHandle clang_toggleCrashRecovery$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_toggleCrashRecovery$MH,\"clang_toggleCrashRecovery\");\n+    }\n+    public static void clang_toggleCrashRecovery ( int isEnabled) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_toggleCrashRecovery$MH, \"clang_toggleCrashRecovery\");\n+        try {\n+            mh$.invokeExact(isEnabled);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_Cursor_Evaluate$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_Cursor_Evaluate$MH,\"clang_Cursor_Evaluate\");\n+    }\n+    public static MemoryAddress clang_Cursor_Evaluate ( MemorySegment C) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_Cursor_Evaluate$MH, \"clang_Cursor_Evaluate\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(C);\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getKind$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getKind$MH,\"clang_EvalResult_getKind\");\n+    }\n+    public static int clang_EvalResult_getKind ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getKind$MH, \"clang_EvalResult_getKind\");\n+        try {\n+            return (int)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsInt$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsInt$MH,\"clang_EvalResult_getAsInt\");\n+    }\n+    public static int clang_EvalResult_getAsInt ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsInt$MH, \"clang_EvalResult_getAsInt\");\n+        try {\n+            return (int)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsLongLong$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsLongLong$MH,\"clang_EvalResult_getAsLongLong\");\n+    }\n+    public static long clang_EvalResult_getAsLongLong ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_getAsLongLong$MH, \"clang_EvalResult_getAsLongLong\");\n+        try {\n+            return (long)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_isUnsignedInt$MH() {\n+        return RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_isUnsignedInt$MH,\"clang_EvalResult_isUnsignedInt\");\n+    }\n+    public static int clang_EvalResult_isUnsignedInt ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$17.clang_EvalResult_isUnsignedInt$MH, \"clang_EvalResult_isUnsignedInt\");\n+        try {\n+            return (int)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsUnsigned$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsUnsigned$MH,\"clang_EvalResult_getAsUnsigned\");\n+    }\n+    public static long clang_EvalResult_getAsUnsigned ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsUnsigned$MH, \"clang_EvalResult_getAsUnsigned\");\n+        try {\n+            return (long)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsDouble$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsDouble$MH,\"clang_EvalResult_getAsDouble\");\n+    }\n+    public static double clang_EvalResult_getAsDouble ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsDouble$MH, \"clang_EvalResult_getAsDouble\");\n+        try {\n+            return (double)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_getAsStr$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsStr$MH,\"clang_EvalResult_getAsStr\");\n+    }\n+    public static MemoryAddress clang_EvalResult_getAsStr ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_getAsStr$MH, \"clang_EvalResult_getAsStr\");\n+        try {\n+            return (jdk.incubator.foreign.MemoryAddress)mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static MethodHandle clang_EvalResult_dispose$MH() {\n+        return RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_dispose$MH,\"clang_EvalResult_dispose\");\n+    }\n+    public static void clang_EvalResult_dispose ( Addressable E) {\n+        var mh$ = RuntimeHelper.requireNonNull(constants$18.clang_EvalResult_dispose$MH, \"clang_EvalResult_dispose\");\n+        try {\n+            mh$.invokeExact(E.address());\n+        } catch (Throwable ex$) {\n+            throw new AssertionError(\"should not reach here\", ex$);\n+        }\n+    }\n+    public static int CXResult_Success() {\n+        return (int)0L;\n+    }\n+    public static int CXResult_Invalid() {\n+        return (int)1L;\n+    }\n+    public static int CXResult_VisitBreak() {\n+        return (int)2L;\n+    }\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/Index_h.java","additions":2876,"deletions":0,"binary":false,"changes":2876,"status":"added"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+package jdk.internal.clang.libclang;\n+\/\/ Generated by jextract\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+final class RuntimeHelper {\n+    private RuntimeHelper() {}\n+    private final static CLinker LINKER = CLinker.getInstance();\n+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n+\n+    static SymbolLookup lookup() {\n+        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+        SymbolLookup systemLookup = CLinker.systemLookup();\n+        return name -> loaderLookup.lookup(name).or(() -> systemLookup.lookup(name));\n+    }\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    private final static SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n+\n+    static final MemorySegment lookupGlobalVariable(SymbolLookup LOOKUP, String name, MemoryLayout layout) {\n+        return LOOKUP.lookup(name).map(s -> s.address().asSegment(layout.byteSize(), ResourceScope.newImplicitScope())).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(SymbolLookup LOOKUP, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {\n+        return LOOKUP.lookup(name).map(\n+                addr -> {\n+                    MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+                    return variadic ?\n+                        VarargsInvoker.make(addr, mt, fdesc) :\n+                        LINKER.downcallHandle(addr, mt, fdesc);\n+                }).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(String desc, FunctionDescriptor fdesc, boolean variadic) {\n+        if (variadic) {\n+            throw new AssertionError(\"Cannot get here!\");\n+        }\n+        MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+        return LINKER.downcallHandle(mt, fdesc);\n+    }\n+\n+    static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {\n+        return upcallStub(fi, z, fdesc, mtypeDesc, ResourceScope.newImplicitScope());\n+    }\n+\n+    static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n+        try {\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            handle = handle.bindTo(z);\n+            return LINKER.upcallStub(handle, fdesc, scope);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, ResourceScope scope) {\n+         return addr.asSegment(numElements * layout.byteSize(), scope);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static class VarargsInvoker {\n+        private static final MethodHandle INVOKE_MH;\n+        private final Addressable symbol;\n+        private final MethodType varargs;\n+        private final FunctionDescriptor function;\n+\n+        private VarargsInvoker(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+            this.symbol = symbol;\n+            this.varargs = type;\n+            this.function = function;\n+        }\n+\n+        static {\n+            try {\n+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);\n+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount());\n+            if (type.returnType().equals(MemorySegment.class)) {\n+                type = type.insertParameterTypes(0, SegmentAllocator.class);\n+            } else {\n+                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n+            }\n+            return handle.asType(type);\n+        }\n+\n+        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n+            \/\/ one trailing Object[]\n+            int nNamedArgs = function.argumentLayouts().size();\n+            assert(args.length == nNamedArgs + 1);\n+            \/\/ The last argument is the array of vararg collector\n+            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n+\n+            int argsCount = nNamedArgs + unnamedArgs.length;\n+            Class<?>[] argTypes = new Class<?>[argsCount];\n+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n+\n+            int pos = 0;\n+            for (pos = 0; pos < nNamedArgs; pos++) {\n+                argTypes[pos] = varargs.parameterType(pos);\n+                argLayouts[pos] = function.argumentLayouts().get(pos);\n+            }\n+\n+            assert pos == nNamedArgs;\n+            for (Object o: unnamedArgs) {\n+                argTypes[pos] = normalize(o.getClass());\n+                argLayouts[pos] = variadicLayout(argTypes[pos]);\n+                pos++;\n+            }\n+            assert pos == argsCount;\n+\n+            MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);\n+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n+                    FunctionDescriptor.ofVoid(argLayouts) :\n+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, allocator, mt, f);\n+            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n+\n+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n+        }\n+\n+        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n+            if (clazz == Boolean.class) {\n+                return boolean.class;\n+            } else if (clazz == Void.class) {\n+                return void.class;\n+            } else if (clazz == Byte.class) {\n+                return byte.class;\n+            } else if (clazz == Character.class) {\n+                return char.class;\n+            } else if (clazz == Short.class) {\n+                return short.class;\n+            } else if (clazz == Integer.class) {\n+                return int.class;\n+            } else if (clazz == Long.class) {\n+                return long.class;\n+            } else if (clazz == Float.class) {\n+                return float.class;\n+            } else if (clazz == Double.class) {\n+                return double.class;\n+            } else {\n+                return clazz;\n+            }\n+        }\n+\n+        private Class<?> promote(Class<?> c) {\n+            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n+                return long.class;\n+            } else if (c == float.class) {\n+                return double.class;\n+            } else {\n+                return c;\n+            }\n+        }\n+\n+        private Class<?> normalize(Class<?> c) {\n+            c = unboxIfNeeded(c);\n+            if (c.isPrimitive()) {\n+                return promote(c);\n+            }\n+            if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return MemoryAddress.class;\n+            }\n+            if (MemorySegment.class.isAssignableFrom(c)) {\n+                return MemorySegment.class;\n+            }\n+            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+        }\n+\n+        private MemoryLayout variadicLayout(Class<?> c) {\n+            if (c == long.class) {\n+                return C_LONG_LONG;\n+            } else if (c == double.class) {\n+                return C_DOUBLE;\n+            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return C_POINTER;\n+            } else {\n+                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/RuntimeHelper.java","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$0 {\n+\n+    static final FunctionDescriptor clang_getCString$FUNC = FunctionDescriptor.of(C_POINTER,\n+        MemoryLayout.structLayout(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_getCString$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCString\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+        constants$0.clang_getCString$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeString$FUNC = FunctionDescriptor.ofVoid(\n+        MemoryLayout.structLayout(\n+            C_POINTER.withName(\"data\"),\n+            C_INT.withName(\"private_flags\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_disposeString$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_disposeString\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)V\",\n+        constants$0.clang_disposeString$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_createIndex$FUNC = FunctionDescriptor.of(C_POINTER,\n+        C_INT,\n+        C_INT\n+    );\n+    static final MethodHandle clang_createIndex$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_createIndex\",\n+        \"(II)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+        constants$0.clang_createIndex$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeIndex$FUNC = FunctionDescriptor.ofVoid(\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_disposeIndex$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_disposeIndex\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+        constants$0.clang_disposeIndex$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getFileName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getFileName$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getFileName\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$0.clang_getFileName$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getNullLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ));\n+    static final MethodHandle clang_getNullLocation$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getNullLocation\",\n+        \"()Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$0.clang_getNullLocation$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$0.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$1 {\n+\n+    static final FunctionDescriptor clang_equalLocations$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        ),\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_equalLocations$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_equalLocations\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$1.clang_equalLocations$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_POINTER,\n+        C_POINTER,\n+        C_INT,\n+        C_INT\n+    );\n+    static final MethodHandle clang_getLocation$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getLocation\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;II)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$1.clang_getLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getLocationForOffset$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_POINTER,\n+        C_POINTER,\n+        C_INT\n+    );\n+    static final MethodHandle clang_getLocationForOffset$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getLocationForOffset\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$1.clang_getLocationForOffset$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Location_isInSystemHeader$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_Location_isInSystemHeader$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Location_isInSystemHeader\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$1.clang_Location_isInSystemHeader$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Location_isFromMainFile$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        )\n+    );\n+    static final MethodHandle clang_Location_isFromMainFile$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Location_isFromMainFile\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$1.clang_Location_isFromMainFile$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Range_isNull$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        )\n+    );\n+    static final MethodHandle clang_Range_isNull$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Range_isNull\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$1.clang_Range_isNull$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$1.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$10 {\n+\n+    static final FunctionDescriptor clang_getPointeeType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getPointeeType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getPointeeType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$10.clang_getPointeeType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypeDeclaration$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        C_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTypeDeclaration$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTypeDeclaration\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$10.clang_getTypeDeclaration$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypeKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_INT\n+    );\n+    static final MethodHandle clang_getTypeKindSpelling$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTypeKindSpelling\",\n+        \"(I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$10.clang_getTypeKindSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getFunctionTypeCallingConv$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getFunctionTypeCallingConv$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getFunctionTypeCallingConv\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$10.clang_getFunctionTypeCallingConv$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getResultType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getResultType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getResultType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$10.clang_getResultType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getNumArgTypes$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getNumArgTypes$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getNumArgTypes\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$10.clang_getNumArgTypes$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$10.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$11 {\n+\n+    static final FunctionDescriptor clang_getArgType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        ),\n+        C_INT\n+    );\n+    static final MethodHandle clang_getArgType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getArgType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$11.clang_getArgType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isFunctionTypeVariadic$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_isFunctionTypeVariadic$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_isFunctionTypeVariadic\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$11.clang_isFunctionTypeVariadic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorResultType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorResultType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorResultType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$11.clang_getCursorResultType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getElementType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getElementType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getElementType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$11.clang_getElementType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getNumElements$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getNumElements$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getNumElements\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+        constants$11.clang_getNumElements$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getArrayElementType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getArrayElementType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getArrayElementType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$11.clang_getArrayElementType$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$11.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$12 {\n+\n+    static final FunctionDescriptor clang_getArraySize$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getArraySize$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getArraySize\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+        constants$12.clang_getArraySize$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Type_getSizeOf$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Type_getSizeOf$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Type_getSizeOf\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+        constants$12.clang_Type_getSizeOf$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Type_getOffsetOf$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        ),\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_Type_getOffsetOf$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Type_getOffsetOf\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)J\",\n+        constants$12.clang_Type_getOffsetOf$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isAnonymous$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isAnonymous$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_isAnonymous\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$12.clang_Cursor_isAnonymous$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isAnonymousRecordDecl$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isAnonymousRecordDecl$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_isAnonymousRecordDecl\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$12.clang_Cursor_isAnonymousRecordDecl$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isBitField$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isBitField$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_isBitField\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$12.clang_Cursor_isBitField$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$12.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$13 {\n+\n+    static final FunctionDescriptor CXCursorVisitor$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        ),\n+        C_POINTER\n+    );\n+    static final MethodHandle CXCursorVisitor$MH = RuntimeHelper.downcallHandle(\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+        constants$13.CXCursorVisitor$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_visitChildren$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        ),\n+        C_POINTER,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_visitChildren$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_visitChildren\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+        constants$13.clang_visitChildren$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorUSR$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorUSR$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorUSR\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$13.clang_getCursorUSR$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorSpelling$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorSpelling\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$13.clang_getCursorSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_PrintingPolicy_getProperty$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER,\n+        C_INT\n+    );\n+    static final MethodHandle clang_PrintingPolicy_getProperty$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_PrintingPolicy_getProperty\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+        constants$13.clang_PrintingPolicy_getProperty$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$13.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$14 {\n+\n+    static final FunctionDescriptor clang_PrintingPolicy_setProperty$FUNC = FunctionDescriptor.ofVoid(\n+        C_POINTER,\n+        C_INT,\n+        C_INT\n+    );\n+    static final MethodHandle clang_PrintingPolicy_setProperty$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_PrintingPolicy_setProperty\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;II)V\",\n+        constants$14.clang_PrintingPolicy_setProperty$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorPrintingPolicy$FUNC = FunctionDescriptor.of(C_POINTER,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorPrintingPolicy$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorPrintingPolicy\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+        constants$14.clang_getCursorPrintingPolicy$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_PrintingPolicy_dispose$FUNC = FunctionDescriptor.ofVoid(\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_PrintingPolicy_dispose$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_PrintingPolicy_dispose\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+        constants$14.clang_PrintingPolicy_dispose$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorPrettyPrinted$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        ),\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getCursorPrettyPrinted$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorPrettyPrinted\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$14.clang_getCursorPrettyPrinted$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorDisplayName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorDisplayName$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorDisplayName\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$14.clang_getCursorDisplayName$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorReferenced$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        C_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorReferenced$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorReferenced\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$14.clang_getCursorReferenced$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$14.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$15 {\n+\n+    static final FunctionDescriptor clang_getCursorDefinition$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        C_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorDefinition$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorDefinition\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$15.clang_getCursorDefinition$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isCursorDefinition$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_isCursorDefinition$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_isCursorDefinition\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$15.clang_isCursorDefinition$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isVariadic$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isVariadic$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_isVariadic\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$15.clang_Cursor_isVariadic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_getMangling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_getMangling$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_getMangling\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$15.clang_Cursor_getMangling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTokenKind$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(4, C_INT).withName(\"int_data\"),\n+            C_POINTER.withName(\"ptr_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTokenKind$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTokenKind\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$15.clang_getTokenKind$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTokenSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_POINTER,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(4, C_INT).withName(\"int_data\"),\n+            C_POINTER.withName(\"ptr_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTokenSpelling$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTokenSpelling\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$15.clang_getTokenSpelling$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$15.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$16 {\n+\n+    static final FunctionDescriptor clang_getTokenLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_POINTER,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(4, C_INT).withName(\"int_data\"),\n+            C_POINTER.withName(\"ptr_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTokenLocation$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTokenLocation\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$16.clang_getTokenLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTokenExtent$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"begin_int_data\"),\n+        C_INT.withName(\"end_int_data\")\n+    ),\n+        C_POINTER,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(4, C_INT).withName(\"int_data\"),\n+            C_POINTER.withName(\"ptr_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTokenExtent$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTokenExtent\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$16.clang_getTokenExtent$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_tokenize$FUNC = FunctionDescriptor.ofVoid(\n+        C_POINTER,\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        ),\n+        C_POINTER,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_tokenize$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_tokenize\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+        constants$16.clang_tokenize$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeTokens$FUNC = FunctionDescriptor.ofVoid(\n+        C_POINTER,\n+        C_POINTER,\n+        C_INT\n+    );\n+    static final MethodHandle clang_disposeTokens$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_disposeTokens\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;I)V\",\n+        constants$16.clang_disposeTokens$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorKindSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_INT\n+    );\n+    static final MethodHandle clang_getCursorKindSpelling$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorKindSpelling\",\n+        \"(I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$16.clang_getCursorKindSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getClangVersion$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ));\n+    static final MethodHandle clang_getClangVersion$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getClangVersion\",\n+        \"()Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$16.clang_getClangVersion$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$16.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$17 {\n+\n+    static final FunctionDescriptor clang_toggleCrashRecovery$FUNC = FunctionDescriptor.ofVoid(\n+        C_INT\n+    );\n+    static final MethodHandle clang_toggleCrashRecovery$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_toggleCrashRecovery\",\n+        \"(I)V\",\n+        constants$17.clang_toggleCrashRecovery$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_Evaluate$FUNC = FunctionDescriptor.of(C_POINTER,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_Evaluate$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_Evaluate\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+        constants$17.clang_Cursor_Evaluate$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getKind$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_EvalResult_getKind$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_EvalResult_getKind\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+        constants$17.clang_EvalResult_getKind$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getAsInt$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_EvalResult_getAsInt$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_EvalResult_getAsInt\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+        constants$17.clang_EvalResult_getAsInt$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getAsLongLong$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_EvalResult_getAsLongLong$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_EvalResult_getAsLongLong\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)J\",\n+        constants$17.clang_EvalResult_getAsLongLong$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_isUnsignedInt$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_EvalResult_isUnsignedInt$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_EvalResult_isUnsignedInt\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+        constants$17.clang_EvalResult_isUnsignedInt$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$17.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$18 {\n+\n+    static final FunctionDescriptor clang_EvalResult_getAsUnsigned$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_EvalResult_getAsUnsigned$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_EvalResult_getAsUnsigned\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)J\",\n+        constants$18.clang_EvalResult_getAsUnsigned$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getAsDouble$FUNC = FunctionDescriptor.of(C_DOUBLE,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_EvalResult_getAsDouble$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_EvalResult_getAsDouble\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)D\",\n+        constants$18.clang_EvalResult_getAsDouble$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_getAsStr$FUNC = FunctionDescriptor.of(C_POINTER,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_EvalResult_getAsStr$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_EvalResult_getAsStr\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+        constants$18.clang_EvalResult_getAsStr$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_EvalResult_dispose$FUNC = FunctionDescriptor.ofVoid(\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_EvalResult_dispose$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_EvalResult_dispose\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+        constants$18.clang_EvalResult_dispose$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$18.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$2 {\n+\n+    static final FunctionDescriptor clang_getExpansionLocation$FUNC = FunctionDescriptor.ofVoid(\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        ),\n+        C_POINTER,\n+        C_POINTER,\n+        C_POINTER,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getExpansionLocation$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getExpansionLocation\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+        constants$2.clang_getExpansionLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getSpellingLocation$FUNC = FunctionDescriptor.ofVoid(\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        ),\n+        C_POINTER,\n+        C_POINTER,\n+        C_POINTER,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getSpellingLocation$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getSpellingLocation\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+        constants$2.clang_getSpellingLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getFileLocation$FUNC = FunctionDescriptor.ofVoid(\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"int_data\"),\n+            MemoryLayout.paddingLayout(32)\n+        ),\n+        C_POINTER,\n+        C_POINTER,\n+        C_POINTER,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getFileLocation$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getFileLocation\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+        constants$2.clang_getFileLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getRangeStart$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getRangeStart$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getRangeStart\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$2.clang_getRangeStart$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getRangeEnd$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+            C_INT.withName(\"begin_int_data\"),\n+            C_INT.withName(\"end_int_data\")\n+        )\n+    );\n+    static final MethodHandle clang_getRangeEnd$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getRangeEnd\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$2.clang_getRangeEnd$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getChildDiagnostics$FUNC = FunctionDescriptor.of(C_POINTER,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getChildDiagnostics$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getChildDiagnostics\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+        constants$2.clang_getChildDiagnostics$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$2.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$3 {\n+\n+    static final FunctionDescriptor clang_getNumDiagnostics$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getNumDiagnostics$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getNumDiagnostics\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+        constants$3.clang_getNumDiagnostics$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getDiagnostic$FUNC = FunctionDescriptor.of(C_POINTER,\n+        C_POINTER,\n+        C_INT\n+    );\n+    static final MethodHandle clang_getDiagnostic$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getDiagnostic\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+        constants$3.clang_getDiagnostic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeDiagnostic$FUNC = FunctionDescriptor.ofVoid(\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_disposeDiagnostic$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_disposeDiagnostic\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+        constants$3.clang_disposeDiagnostic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_formatDiagnostic$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_POINTER,\n+        C_INT\n+    );\n+    static final MethodHandle clang_formatDiagnostic$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_formatDiagnostic\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$3.clang_formatDiagnostic$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_defaultDiagnosticDisplayOptions$FUNC = FunctionDescriptor.of(C_INT);\n+    static final MethodHandle clang_defaultDiagnosticDisplayOptions$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_defaultDiagnosticDisplayOptions\",\n+        \"()I\",\n+        constants$3.clang_defaultDiagnosticDisplayOptions$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getDiagnosticSeverity$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getDiagnosticSeverity$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getDiagnosticSeverity\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+        constants$3.clang_getDiagnosticSeverity$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$3.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$4 {\n+\n+    static final FunctionDescriptor clang_getDiagnosticLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getDiagnosticLocation$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getDiagnosticLocation\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$4.clang_getDiagnosticLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getDiagnosticSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getDiagnosticSpelling$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getDiagnosticSpelling\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$4.clang_getDiagnosticSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_parseTranslationUnit$FUNC = FunctionDescriptor.of(C_POINTER,\n+        C_POINTER,\n+        C_POINTER,\n+        C_POINTER,\n+        C_INT,\n+        C_POINTER,\n+        C_INT,\n+        C_INT\n+    );\n+    static final MethodHandle clang_parseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_parseTranslationUnit\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;II)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+        constants$4.clang_parseTranslationUnit$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_parseTranslationUnit2$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER,\n+        C_POINTER,\n+        C_POINTER,\n+        C_INT,\n+        C_POINTER,\n+        C_INT,\n+        C_INT,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_parseTranslationUnit2$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_parseTranslationUnit2\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;IILjdk\/incubator\/foreign\/MemoryAddress;)I\",\n+        constants$4.clang_parseTranslationUnit2$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_saveTranslationUnit$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER,\n+        C_POINTER,\n+        C_INT\n+    );\n+    static final MethodHandle clang_saveTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_saveTranslationUnit\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+        constants$4.clang_saveTranslationUnit$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_disposeTranslationUnit$FUNC = FunctionDescriptor.ofVoid(\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_disposeTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_disposeTranslationUnit\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)V\",\n+        constants$4.clang_disposeTranslationUnit$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$4.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$5 {\n+\n+    static final FunctionDescriptor clang_defaultReparseOptions$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_defaultReparseOptions$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_defaultReparseOptions\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)I\",\n+        constants$5.clang_defaultReparseOptions$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_reparseTranslationUnit$FUNC = FunctionDescriptor.of(C_INT,\n+        C_POINTER,\n+        C_INT,\n+        C_POINTER,\n+        C_INT\n+    );\n+    static final MethodHandle clang_reparseTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_reparseTranslationUnit\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;ILjdk\/incubator\/foreign\/MemoryAddress;I)I\",\n+        constants$5.clang_reparseTranslationUnit$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getNullCursor$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        C_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+    ));\n+    static final MethodHandle clang_getNullCursor$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getNullCursor\",\n+        \"()Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$5.clang_getNullCursor$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTranslationUnitCursor$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        C_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+    ),\n+        C_POINTER\n+    );\n+    static final MethodHandle clang_getTranslationUnitCursor$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTranslationUnitCursor\",\n+        \"(Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$5.clang_getTranslationUnitCursor$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_equalCursors$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_equalCursors$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_equalCursors\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$5.clang_equalCursors$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isNull$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isNull$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_isNull\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$5.clang_Cursor_isNull$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$5.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$6 {\n+\n+    static final FunctionDescriptor clang_getCursorKind$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorKind$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorKind\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$6.clang_getCursorKind$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isDeclaration$FUNC = FunctionDescriptor.of(C_INT,\n+        C_INT\n+    );\n+    static final MethodHandle clang_isDeclaration$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_isDeclaration\",\n+        \"(I)I\",\n+        constants$6.clang_isDeclaration$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isAttribute$FUNC = FunctionDescriptor.of(C_INT,\n+        C_INT\n+    );\n+    static final MethodHandle clang_isAttribute$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_isAttribute\",\n+        \"(I)I\",\n+        constants$6.clang_isAttribute$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isInvalid$FUNC = FunctionDescriptor.of(C_INT,\n+        C_INT\n+    );\n+    static final MethodHandle clang_isInvalid$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_isInvalid\",\n+        \"(I)I\",\n+        constants$6.clang_isInvalid$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isPreprocessing$FUNC = FunctionDescriptor.of(C_INT,\n+        C_INT\n+    );\n+    static final MethodHandle clang_isPreprocessing$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_isPreprocessing\",\n+        \"(I)I\",\n+        constants$6.clang_isPreprocessing$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorLanguage$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorLanguage$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorLanguage\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$6.clang_getCursorLanguage$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$6.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$7 {\n+\n+    static final FunctionDescriptor clang_Cursor_getTranslationUnit$FUNC = FunctionDescriptor.of(C_POINTER,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_getTranslationUnit$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_getTranslationUnit\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemoryAddress;\",\n+        constants$7.clang_Cursor_getTranslationUnit$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorLocation$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"int_data\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorLocation$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorLocation\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$7.clang_getCursorLocation$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorExtent$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"ptr_data\"),\n+        C_INT.withName(\"begin_int_data\"),\n+        C_INT.withName(\"end_int_data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorExtent$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorExtent\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$7.clang_getCursorExtent$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCursorType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCursorType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCursorType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$7.clang_getCursorType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypeSpelling$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTypeSpelling$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTypeSpelling\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$7.clang_getTypeSpelling$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypedefDeclUnderlyingType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTypedefDeclUnderlyingType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTypedefDeclUnderlyingType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$7.clang_getTypedefDeclUnderlyingType$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$7.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$8 {\n+\n+    static final FunctionDescriptor clang_getEnumDeclIntegerType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getEnumDeclIntegerType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getEnumDeclIntegerType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$8.clang_getEnumDeclIntegerType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getEnumConstantDeclValue$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getEnumConstantDeclValue$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getEnumConstantDeclValue\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+        constants$8.clang_getEnumConstantDeclValue$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getEnumConstantDeclUnsignedValue$FUNC = FunctionDescriptor.of(C_LONG_LONG,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getEnumConstantDeclUnsignedValue$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getEnumConstantDeclUnsignedValue\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)J\",\n+        constants$8.clang_getEnumConstantDeclUnsignedValue$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getFieldDeclBitWidth$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getFieldDeclBitWidth$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getFieldDeclBitWidth\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$8.clang_getFieldDeclBitWidth$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_getNumArguments$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_getNumArguments$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_getNumArguments\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$8.clang_Cursor_getNumArguments$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_getArgument$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        C_INT.withName(\"xdata\"),\n+        MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        ),\n+        C_INT\n+    );\n+    static final MethodHandle clang_Cursor_getArgument$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_getArgument\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;I)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$8.clang_Cursor_getArgument$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$8.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/\/ Generated by jextract\n+\n+package jdk.internal.clang.libclang;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import jdk.incubator.foreign.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+class constants$9 {\n+\n+    static final FunctionDescriptor clang_equalTypes$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_equalTypes$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_equalTypes\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$9.clang_equalTypes$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getCanonicalType$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_INT.withName(\"kind\"),\n+        MemoryLayout.paddingLayout(32),\n+        MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getCanonicalType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getCanonicalType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$9.clang_getCanonicalType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isConstQualifiedType$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_isConstQualifiedType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_isConstQualifiedType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$9.clang_isConstQualifiedType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_Cursor_isMacroFunctionLike$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            C_INT.withName(\"xdata\"),\n+            MemoryLayout.sequenceLayout(3, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_Cursor_isMacroFunctionLike$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_Cursor_isMacroFunctionLike\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$9.clang_Cursor_isMacroFunctionLike$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_isVolatileQualifiedType$FUNC = FunctionDescriptor.of(C_INT,\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_isVolatileQualifiedType$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_isVolatileQualifiedType\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)I\",\n+        constants$9.clang_isVolatileQualifiedType$FUNC, false\n+    );\n+    static final FunctionDescriptor clang_getTypedefName$FUNC = FunctionDescriptor.of(MemoryLayout.structLayout(\n+        C_POINTER.withName(\"data\"),\n+        C_INT.withName(\"private_flags\"),\n+        MemoryLayout.paddingLayout(32)\n+    ),\n+        MemoryLayout.structLayout(\n+            C_INT.withName(\"kind\"),\n+            MemoryLayout.paddingLayout(32),\n+            MemoryLayout.sequenceLayout(2, C_POINTER).withName(\"data\")\n+        )\n+    );\n+    static final MethodHandle clang_getTypedefName$MH = RuntimeHelper.downcallHandle(\n+        Index_h.LIBRARIES, \"clang_getTypedefName\",\n+        \"(Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment;\",\n+        constants$9.clang_getTypedefName$FUNC, false\n+    );\n+}\n+\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/clang\/libclang\/constants$9.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+public class ClangException extends RuntimeException {\n+    private static final long serialVersionUID = 0L;\n+\n+    public ClangException(String message) {\n+        super(message);\n+    }\n+\n+    public ClangException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+\n+    public ClangException(Throwable cause) {\n+        super(cause);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClangException.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.constant.ClassDesc;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * Superclass for .java source generator classes.\n+ *\/\n+abstract class ClassSourceBuilder extends JavaSourceBuilder {\n+\n+    enum Kind {\n+        CLASS(\"class\"),\n+        INTERFACE(\"interface\");\n+\n+        final String kindName;\n+\n+        Kind(String kindName) {\n+            this.kindName = kindName;\n+        }\n+    }\n+\n+    final Kind kind;\n+    final ClassDesc desc;\n+    protected final JavaSourceBuilder enclosing;\n+\n+    \/\/ code buffer\n+    private StringBuilder sb = new StringBuilder();\n+    \/\/ current line alignment (number of 4-spaces)\n+    private int align;\n+\n+    ClassSourceBuilder(JavaSourceBuilder enclosing, Kind kind, String name) {\n+        this.enclosing = enclosing;\n+        this.align = (enclosing instanceof ClassSourceBuilder) ?\n+            ((ClassSourceBuilder) enclosing).align : 0;\n+        this.kind = kind;\n+        this.desc = ClassDesc.of(enclosing.packageName(), enclosing.uniqueNestedClassName(name));\n+    }\n+\n+    boolean isNested() {\n+        return enclosing instanceof ClassSourceBuilder;\n+    }\n+\n+    String className() {\n+        return desc.displayName();\n+    }\n+\n+    String fullName() {\n+        return isNested() ?\n+                ((ClassSourceBuilder)enclosing).className() + \".\" + className() :\n+                className();\n+    }\n+\n+    @Override\n+    public final String packageName() {\n+        return desc.packageName();\n+    }\n+\n+    String superClass() {\n+        return null;\n+    }\n+\n+    String mods() {\n+        return (!isNested() || kind == Kind.INTERFACE) ?\n+                    \"public \" : \"public static \";\n+    }\n+\n+    void classBegin() {\n+        if (isNested()) {\n+            incrAlign();\n+        }\n+        emitPackagePrefix();\n+        emitImportSection();\n+\n+        indent();\n+        append(mods());\n+        append(kind.kindName + \" \" + className());\n+        if (superClass() != null) {\n+            append(\" extends \");\n+            append(superClass());\n+        }\n+        append(\" {\\n\\n\");\n+    }\n+\n+    JavaSourceBuilder classEnd() {\n+        indent();\n+        append(\"}\\n\\n\");\n+        if (isNested()) {\n+            decrAlign();\n+            ((ClassSourceBuilder)enclosing).append(build());\n+            sb = null;\n+        }\n+        return enclosing;\n+    }\n+\n+    @Override\n+    public List<JavaFileObject> toFiles() {\n+        if (isNested()) {\n+            throw new UnsupportedOperationException(\"Nested builder!\");\n+        }\n+        String res = build();\n+        sb = null;\n+        return List.of(Utils.fileFromString(packageName(), className(), res));\n+    }\n+\n+    \/\/ Internal generation helpers (used by other builders)\n+\n+    void append(String s) {\n+        sb.append(s);\n+    }\n+\n+    void append(char c) {\n+        sb.append(c);\n+    }\n+\n+    void append(boolean b) {\n+        sb.append(b);\n+    }\n+\n+    void append(long l) {\n+        sb.append(l);\n+    }\n+\n+    void indent() {\n+        for (int i = 0; i < align; i++) {\n+            append(\"    \");\n+        }\n+    }\n+\n+    void incrAlign() {\n+        align++;\n+    }\n+\n+    void decrAlign() {\n+        align--;\n+    }\n+\n+    String build() {\n+        String s = sb.toString();\n+        return s;\n+    }\n+\n+    \/\/ is the name enclosed enclosed by a class of the same name?\n+    boolean isEnclosedBySameName(String name) {\n+        return className().equals(name) ||\n+                (isNested() && enclosing.isEnclosedBySameName(name));\n+    }\n+\n+    protected void emitPackagePrefix() {\n+        if (!isNested()) {\n+            assert packageName().indexOf('\/') == -1 : \"package name invalid: \" + packageName();\n+            append(\"\/\/ Generated by jextract\\n\\n\");\n+            if (!packageName().isEmpty()) {\n+                append(\"package \");\n+                append(packageName());\n+                append(\";\\n\\n\");\n+            }\n+        }\n+    }\n+\n+    protected void emitImportSection() {\n+        if (!isNested()) {\n+            append(\"import java.lang.invoke.MethodHandle;\\n\");\n+            append(\"import java.lang.invoke.VarHandle;\\n\");\n+            append(\"import java.nio.ByteOrder;\\n\");\n+            append(\"import jdk.incubator.foreign.*;\\n\");\n+            append(\"import static jdk.incubator.foreign.CLinker.*;\\n\");\n+        }\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access, boolean nullCheck, String symbolName) {\n+        incrAlign();\n+        indent();\n+        append(mods + \" \" + type.getSimpleName() + \" \" +name + \"() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \");\n+        if (nullCheck) {\n+            append(\"RuntimeHelper.requireNonNull(\");\n+        }\n+        append(access);\n+        if (nullCheck) {\n+            append(\",\\\"\");\n+            append(symbolName);\n+            append(\"\\\")\");\n+        }\n+        append(\";\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    protected void emitGetter(String mods, Class<?> type, String name, String access) {\n+        emitGetter(mods, type, name, access, false, null);\n+    }\n+\n+    ToplevelBuilder toplevel() {\n+        JavaSourceBuilder encl = enclosing;\n+        while (encl instanceof ClassSourceBuilder) {\n+            encl = ((ClassSourceBuilder) encl).enclosing;\n+        }\n+        return (ToplevelBuilder)encl;\n+    }\n+\n+    @Override\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        enclosing.emitWithConstantClass(constantConsumer);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ClassSourceBuilder.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+public class CompilationFailedException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+\n+    public CompilationFailedException(String msg) {\n+        super(msg);\n+    }\n+\n+    public CompilationFailedException(String msg, Throwable cause) {\n+        super(msg, cause);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/CompilationFailedException.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.SequenceLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.VarHandle;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+public class ConstantBuilder extends ClassSourceBuilder {\n+\n+    \/\/ set of names generates already\n+    private final Map<String, Constant> namesGenerated = new HashMap<>();\n+\n+    public ConstantBuilder(JavaSourceBuilder enclosing, String className) {\n+        super(enclosing, Kind.CLASS, className);\n+    }\n+\n+    String memberMods() {\n+        return kind == ClassSourceBuilder.Kind.CLASS ?\n+                \"static final \" : \"\";\n+    }\n+\n+    \/\/ public API\n+\n+    public Constant addLayout(String javaName, MemoryLayout layout) {\n+        return emitIfAbsent(javaName, Constant.Kind.LAYOUT,\n+                () -> emitLayoutField(javaName, layout));\n+    }\n+\n+    public Constant addFieldVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+                                      String rootJavaName, List<String> prefixElementNames) {\n+        return addVarHandle(javaName, nativeName, varInfo, rootJavaName, prefixElementNames);\n+    }\n+\n+    public Constant addGlobalVarHandle(String javaName, String nativeName, VarInfo varInfo) {\n+        return addVarHandle(javaName, nativeName, varInfo, null, List.of());\n+    }\n+\n+    private Constant addVarHandle(String javaName, String nativeName, VarInfo varInfo,\n+                                String rootLayoutName, List<String> prefixElementNames) {\n+        return emitIfAbsent(javaName, Constant.Kind.VAR_HANDLE,\n+                () -> emitVarHandleField(javaName, nativeName, varInfo, rootLayoutName, prefixElementNames));\n+    }\n+\n+    public Constant addMethodHandle(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+        return emitIfAbsent(javaName, Constant.Kind.METHOD_HANDLE,\n+                () -> emitMethodHandleField(javaName, nativeName, functionInfo, virtual));\n+    }\n+\n+    public Constant addSegment(String javaName, String nativeName, MemoryLayout layout) {\n+        return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n+                () -> emitSegmentField(javaName, nativeName, layout));\n+    }\n+\n+    public Constant addFunctionDesc(String javaName, FunctionDescriptor desc) {\n+        return emitIfAbsent(javaName, Constant.Kind.FUNCTION_DESCRIPTOR,\n+                () -> emitFunctionDescField(javaName, desc));\n+    }\n+\n+    public Constant addConstantDesc(String javaName, Class<?> type, Object value) {\n+        if (type == MemorySegment.class) {\n+            return emitIfAbsent(javaName, Constant.Kind.SEGMENT,\n+                    () -> emitConstantSegment(javaName, value));\n+        } else if (type == MemoryAddress.class) {\n+            return emitIfAbsent(javaName, Constant.Kind.ADDRESS,\n+                    () -> emitConstantAddress(javaName, value));\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    static class Constant {\n+\n+        enum Kind {\n+            LAYOUT(MemoryLayout.class, \"$LAYOUT\"),\n+            METHOD_HANDLE(MethodHandle.class, \"$MH\"),\n+            VAR_HANDLE(VarHandle.class, \"$VH\"),\n+            FUNCTION_DESCRIPTOR(FunctionDescriptor.class, \"$FUNC\"),\n+            ADDRESS(MemoryAddress.class, \"$ADDR\"),\n+            SEGMENT(MemorySegment.class, \"$SEGMENT\");\n+\n+            final Class<?> type;\n+            final String nameSuffix;\n+\n+            Kind(Class<?> type, String nameSuffix) {\n+                this.type = type;\n+                this.nameSuffix = nameSuffix;\n+            }\n+\n+            String fieldName(String javaName) {\n+                return javaName + nameSuffix;\n+            }\n+        }\n+\n+        private final String className;\n+        private final String javaName;\n+        private final Kind kind;\n+\n+        Constant(String className, String javaName, Kind kind) {\n+            this.className = className;\n+            this.javaName = javaName;\n+            this.kind = kind;\n+        }\n+\n+        List<String> getterNameParts() {\n+            return List.of(className, javaName, kind.nameSuffix);\n+        }\n+\n+        String accessExpression() {\n+            return className + \".\" + kind.fieldName(javaName);\n+        }\n+\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc) {\n+            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression());\n+            return this;\n+        }\n+\n+        Constant emitGetter(ClassSourceBuilder builder, String mods, Function<List<String>, String> getterNameFunc, String symbolName) {\n+            builder.emitGetter(mods, kind.type, getterNameFunc.apply(getterNameParts()), accessExpression(), true, symbolName);\n+            return this;\n+        }\n+\n+        static final Function<List<String>, String> QUALIFIED_NAME =\n+                l -> l.stream().skip(1).collect(Collectors.joining());\n+\n+        static final Function<List<String>, String> JAVA_NAME =\n+                l -> l.get(1);\n+\n+        static final Function<List<String>, String> SUFFIX_ONLY =\n+                l -> l.get(2);\n+    }\n+\n+    \/\/ private generators\n+\n+    public Constant emitIfAbsent(String name, Constant.Kind kind, Supplier<Constant> constantFactory) {\n+        String lookupName = kind.fieldName(name);\n+        Constant constant = namesGenerated.get(lookupName);\n+        if (constant == null) {\n+            constant = constantFactory.get();\n+            if (constant.kind != kind) {\n+                throw new AssertionError(\"Factory return wrong kind of constant; expected: \"\n+                        + kind + \"; found: \" + constant.kind);\n+            }\n+            namesGenerated.put(lookupName, constant);\n+        }\n+        return constant;\n+    }\n+\n+    private Constant emitMethodHandleField(String javaName, String nativeName, FunctionInfo functionInfo, boolean virtual) {\n+        Constant functionDesc = addFunctionDesc(javaName, functionInfo.descriptor());\n+        incrAlign();\n+        String fieldName = Constant.Kind.METHOD_HANDLE.fieldName(javaName);\n+        indent();\n+        append(memberMods() + \"MethodHandle \");\n+        append(fieldName + \" = RuntimeHelper.downcallHandle(\\n\");\n+        incrAlign();\n+        indent();\n+        if (!virtual) {\n+            append(toplevel().headerClassName() + \".LIBRARIES, \\\"\" + nativeName + \"\\\"\");\n+            append(\",\\n\");\n+            indent();\n+        }\n+        append(\"\\\"\" + functionInfo.methodType().toMethodDescriptorString() + \"\\\",\\n\");\n+        indent();\n+        append(functionDesc.accessExpression());\n+        append(\", \");\n+        \/\/ isVariadic\n+        append(functionInfo.isVarargs());\n+        append(\"\\n\");\n+        decrAlign();\n+        indent();\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.METHOD_HANDLE);\n+    }\n+\n+    private Constant emitVarHandleField(String javaName, String nativeName, VarInfo varInfo,\n+                                      String rootLayoutName, List<String> prefixElementNames) {\n+        String layoutAccess = rootLayoutName != null ?\n+                Constant.Kind.LAYOUT.fieldName(rootLayoutName) :\n+                addLayout(javaName, varInfo.layout()).accessExpression();\n+        incrAlign();\n+        String typeName = varInfo.carrier().getName();\n+        boolean isAddr = typeName.contains(\"MemoryAddress\");\n+        if (isAddr) {\n+            typeName = \"long\";\n+        }\n+        indent();\n+        String fieldName = Constant.Kind.VAR_HANDLE.fieldName(javaName);\n+        append(memberMods() + \"VarHandle \" + fieldName + \" = \");\n+        if (isAddr) {\n+            append(\"MemoryHandles.asAddressVarHandle(\");\n+        }\n+        append(layoutAccess);\n+        append(\".varHandle(\" + typeName + \".class\");\n+        if (rootLayoutName != null) {\n+            for (String prefixElementName : prefixElementNames) {\n+                append(\", MemoryLayout.PathElement.groupElement(\\\"\" + prefixElementName + \"\\\")\");\n+            }\n+            append(\", MemoryLayout.PathElement.groupElement(\\\"\" + nativeName + \"\\\")\");\n+        }\n+        append(\")\");\n+        if (isAddr) {\n+            append(\")\");\n+        }\n+        append(\";\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.VAR_HANDLE);\n+    }\n+\n+    private Constant emitLayoutField(String javaName, MemoryLayout layout) {\n+        String fieldName = Constant.Kind.LAYOUT.fieldName(javaName);\n+        incrAlign();\n+        indent();\n+        append(memberMods() + \"MemoryLayout \" + fieldName + \" = \");\n+        emitLayoutString(layout, false);\n+        append(\";\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.LAYOUT);\n+    }\n+\n+    private void emitLayoutString(MemoryLayout l, boolean inBitfield) {\n+        if (l instanceof ValueLayout val) {\n+            append(typeToLayoutName(val, inBitfield));\n+        } else if (l instanceof SequenceLayout seq) {\n+            append(\"MemoryLayout.sequenceLayout(\");\n+            if (seq.elementCount().isPresent()) {\n+                append(seq.elementCount().getAsLong() + \", \");\n+            }\n+            emitLayoutString(seq.elementLayout(), false);\n+            append(\")\");\n+        } else if (l instanceof GroupLayout group) {\n+            if (group.isStruct()) {\n+                append(\"MemoryLayout.structLayout(\\n\");\n+            } else {\n+                append(\"MemoryLayout.unionLayout(\\n\");\n+            }\n+            incrAlign();\n+            String delim = \"\";\n+            boolean isBitfield = LayoutUtils.isBitfields(group);\n+            for (MemoryLayout e : group.memberLayouts()) {\n+                append(delim);\n+                indent();\n+                emitLayoutString(e, isBitfield);\n+                delim = \",\\n\";\n+            }\n+            append(\"\\n\");\n+            decrAlign();\n+            indent();\n+            append(\")\");\n+        } else {\n+            \/\/ padding\n+            append(\"MemoryLayout.paddingLayout(\" + l.bitSize() + \")\");\n+        }\n+        if (l.name().isPresent()) {\n+            append(\".withName(\\\"\" +  l.name().get() + \"\\\")\");\n+        }\n+    }\n+\n+    private Constant emitFunctionDescField(String javaName, FunctionDescriptor desc) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.FUNCTION_DESCRIPTOR.fieldName(javaName);\n+        final boolean noArgs = desc.argumentLayouts().isEmpty();\n+        append(memberMods());\n+        append(\"FunctionDescriptor \");\n+        append(fieldName);\n+        append(\" = \");\n+        if (desc.returnLayout().isPresent()) {\n+            append(\"FunctionDescriptor.of(\");\n+            emitLayoutString(desc.returnLayout().get(), false);\n+            if (!noArgs) {\n+                append(\",\");\n+            }\n+        } else {\n+            append(\"FunctionDescriptor.ofVoid(\");\n+        }\n+        if (!noArgs) {\n+            append(\"\\n\");\n+            incrAlign();\n+            String delim = \"\";\n+            for (MemoryLayout e : desc.argumentLayouts()) {\n+                append(delim);\n+                indent();\n+                emitLayoutString(e, false);\n+                delim = \",\\n\";\n+            }\n+            append(\"\\n\");\n+            decrAlign();\n+            indent();\n+        }\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.FUNCTION_DESCRIPTOR);\n+    }\n+\n+    private Constant emitConstantSegment(String javaName, Object value) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemorySegment \");\n+        append(fieldName);\n+        append(\" = CLinker.toCString(\\\"\");\n+        append(Utils.quote(Objects.toString(value)));\n+        append(\"\\\", ResourceScope.newImplicitScope());\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n+    }\n+\n+    private Constant emitConstantAddress(String javaName, Object value) {\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.ADDRESS.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemoryAddress \");\n+        append(fieldName);\n+        append(\" = MemoryAddress.ofLong(\");\n+        append(((Number)value).longValue());\n+        append(\"L);\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.ADDRESS);\n+    }\n+\n+    private static String typeToLayoutName(ValueLayout vl, boolean inBitfields) {\n+        if (UnsupportedLayouts.isUnsupported(vl)) {\n+            return \"MemoryLayout.paddingLayout(\" + vl.bitSize() + \")\";\n+        } else if (inBitfields) {\n+            return \"MemoryLayout.valueLayout(\" + vl.bitSize() + \", ByteOrder.nativeOrder())\";\n+        } else {\n+            CLinker.TypeKind kind = (CLinker.TypeKind) vl.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n+                    () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n+            return switch (kind) {\n+                case CHAR -> \"C_CHAR\";\n+                case SHORT -> \"C_SHORT\";\n+                case INT -> \"C_INT\";\n+                case LONG -> \"C_LONG\";\n+                case LONG_LONG -> \"C_LONG_LONG\";\n+                case FLOAT -> \"C_FLOAT\";\n+                case DOUBLE -> \"C_DOUBLE\";\n+                case POINTER -> \"C_POINTER\";\n+            };\n+        }\n+    }\n+\n+    private Constant emitSegmentField(String javaName, String nativeName, MemoryLayout layout) {\n+        Constant layoutConstant = addLayout(javaName, layout);\n+        incrAlign();\n+        indent();\n+        String fieldName = Constant.Kind.SEGMENT.fieldName(javaName);\n+        append(memberMods());\n+        append(\"MemorySegment \");\n+        append(fieldName);\n+        append(\" = \");\n+        append(\"RuntimeHelper.lookupGlobalVariable(\");\n+        append(toplevel().headerClassName() + \".LIBRARIES, \\\"\");\n+        append(nativeName);\n+        append(\"\\\", \");\n+        append(layoutConstant.accessExpression());\n+        append(\");\\n\");\n+        decrAlign();\n+        return new Constant(className(), javaName, Constant.Kind.SEGMENT);\n+    }\n+\n+    @Override\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        constantConsumer.accept(this);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ConstantBuilder.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -0,0 +1,393 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import java.lang.constant.Constable;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+\n+public abstract class DeclarationImpl implements Declaration {\n+\n+    private final String name;\n+    private final Position pos;\n+    private final Optional<Map<String, List<Constable>>> attributes;\n+\n+    public DeclarationImpl(String name, Position pos, Map<String, List<Constable>> attrs) {\n+        this.name = name;\n+        this.pos = pos;\n+        this.attributes = Optional.ofNullable(attrs);\n+    }\n+\n+    public String toString() {\n+        return new PrettyPrinter().print(this);\n+    }\n+\n+    public String name() {\n+        return name;\n+    }\n+\n+    @Override\n+    public Position pos() {\n+        return pos;\n+    }\n+\n+    @Override\n+    public Optional<List<Constable>> getAttribute(String name) {\n+        return attributes.map(attrs -> attrs.get(name));\n+    }\n+\n+    @Override\n+    public Set<String> attributeNames() { return Collections.unmodifiableSet(\n+            attributes.map(Map::keySet).orElse(Collections.emptySet()));\n+    }\n+\n+    @Override\n+    public Declaration withAttribute(String name, Constable... values) {\n+        if (values == null || values.length == 0) {\n+            return withAttributes(null);\n+        }\n+        var attrs = attributes.map(HashMap::new).orElseGet(HashMap::new);\n+        attrs.put(name, List.of(values));\n+        return withAttributes(attrs);\n+    }\n+\n+    abstract protected Declaration withAttributes(Map<String, List<Constable>> attrs);\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (!(o instanceof Declaration)) return false;\n+        Declaration decl = (Declaration) o;\n+        return name().equals(decl.name());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name);\n+    }\n+\n+    public static final class TypedefImpl extends DeclarationImpl implements Declaration.Typedef {\n+        final Type type;\n+\n+        public TypedefImpl(Type type, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitTypedef(this, data);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Typedef withAttributes(Map<String, List<Constable>> attrs) {\n+            return new TypedefImpl(type, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Typedef stripAttributes() {\n+            return new TypedefImpl(type, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Typedef)) return false;\n+\n+            Declaration.Typedef other = (Declaration.Typedef) o;\n+            return name().equals(other.name()) &&\n+                    type.equals(other.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static final class VariableImpl extends DeclarationImpl implements Declaration.Variable {\n+\n+        final Variable.Kind kind;\n+        final Type type;\n+        final Optional<MemoryLayout> layout;\n+\n+        private VariableImpl(Type type, Optional<MemoryLayout> layout, Variable.Kind kind, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.type = Objects.requireNonNull(type);\n+            this.layout = Objects.requireNonNull(layout);\n+        }\n+\n+        public VariableImpl(Type type, Variable.Kind kind, String name, Position pos) {\n+            this(type, LayoutUtils.getLayout(type), kind, name, pos, null);\n+        }\n+\n+        public VariableImpl(Type type, MemoryLayout layout, Variable.Kind kind, String name, Position pos) {\n+            this(type, Optional.of(layout), kind, name, pos, null);\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitVariable(this, data);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Optional<MemoryLayout> layout() {\n+            return layout;\n+        }\n+\n+        @Override\n+        public Variable withAttributes(Map<String, List<Constable>> attrs) {\n+            return new VariableImpl(type, layout, kind, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Variable stripAttributes() {\n+            return new VariableImpl(type, layout, kind, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Variable)) return false;\n+\n+            Declaration.Variable variable = (Declaration.Variable) o;\n+            if (!super.equals(o)) return false;\n+            return kind == variable.kind() &&\n+                    type.equals(variable.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), kind, type);\n+        }\n+    }\n+\n+    public static final class FunctionImpl extends DeclarationImpl implements Declaration.Function {\n+\n+        final List<Variable> params;\n+        final Type.Function type;\n+\n+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos) {\n+            this(type, params, name, pos, null);\n+        }\n+\n+        public FunctionImpl(Type.Function type, List<Variable> params, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.params = Objects.requireNonNull(params);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitFunction(this, data);\n+        }\n+\n+        @Override\n+        public List<Variable> parameters() {\n+            return params;\n+        }\n+\n+        @Override\n+        public Type.Function type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Function withAttributes(Map<String, List<Constable>> attrs) {\n+            return new FunctionImpl(type, params, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Function stripAttributes() {\n+            return new FunctionImpl(type, params, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Function)) return false;\n+            if (!super.equals(o)) return false;\n+\n+            Declaration.Function function = (Declaration.Function) o;\n+            return type.equals(function.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static class ScopedImpl extends DeclarationImpl implements Declaration.Scoped {\n+\n+        private final Scoped.Kind kind;\n+        private final List<Declaration> declarations;\n+        private final Optional<MemoryLayout> optLayout;\n+\n+        public ScopedImpl(Kind kind, MemoryLayout layout, List<Declaration> declarations, String name, Position pos) {\n+            this(kind, Optional.of(layout), declarations, name, pos, null);\n+        }\n+\n+        public ScopedImpl(Kind kind, List<Declaration> declarations, String name, Position pos) {\n+            this(kind, Optional.empty(), declarations, name, pos, null);\n+        }\n+\n+        ScopedImpl(Kind kind, Optional<MemoryLayout> optLayout, List<Declaration> declarations,\n+                String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.kind = Objects.requireNonNull(kind);\n+            this.declarations = Objects.requireNonNull(declarations);\n+            this.optLayout = Objects.requireNonNull(optLayout);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitScoped(this, data);\n+        }\n+\n+        @Override\n+        public List<Declaration> members() {\n+            return declarations;\n+        }\n+\n+        @Override\n+        public Optional<MemoryLayout> layout() {\n+            return optLayout;\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public Scoped withAttributes(Map<String, List<Constable>> attrs) {\n+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Scoped stripAttributes() {\n+            return new ScopedImpl(kind, optLayout, declarations, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Scoped)) return false;\n+            if (!super.equals(o)) return false;\n+            Declaration.Scoped scoped = (Declaration.Scoped) o;\n+            return kind == scoped.kind() &&\n+                    declarations.equals(scoped.members());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), kind, declarations);\n+        }\n+    }\n+\n+    public static final class ConstantImpl extends DeclarationImpl implements Declaration.Constant {\n+\n+        final Object value;\n+        final Type type;\n+\n+        public ConstantImpl(Type type, Object value, String name, Position pos) {\n+            this(type, value, name, pos, null);\n+        }\n+\n+        public ConstantImpl(Type type, Object value, String name, Position pos, Map<String, List<Constable>> attrs) {\n+            super(name, pos, attrs);\n+            this.value = Objects.requireNonNull(value);\n+            this.type = Objects.requireNonNull(type);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitConstant(this, data);\n+        }\n+\n+        @Override\n+        public Object value() {\n+            return value;\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public Constant withAttributes(Map<String, List<Constable>> attrs) {\n+            return new ConstantImpl(type, value, name(), pos(), attrs);\n+        }\n+\n+        @Override\n+        public Constant stripAttributes() {\n+            return new ConstantImpl(type, value, name(), pos(), null);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Declaration.Constant)) return false;\n+            if (!super.equals(o)) return false;\n+            Declaration.Constant constant = (Declaration.Constant) o;\n+            return value.equals(constant.value()) &&\n+                    type.equals(constant.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(super.hashCode(), value, type);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/DeclarationImpl.java","additions":393,"deletions":0,"binary":false,"changes":393,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.*;\n+\n+import jdk.internal.jextract.impl.ConstantBuilder.Constant;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class FunctionalInterfaceBuilder extends ClassSourceBuilder {\n+\n+    private static final String MEMBER_MODS = \"static\";\n+\n+    private final MethodType fiType;\n+    private final FunctionDescriptor fiDesc;\n+\n+    FunctionalInterfaceBuilder(JavaSourceBuilder enclosing, String className,\n+                               MethodType fiType, FunctionDescriptor fiDesc) {\n+        super(enclosing, Kind.INTERFACE, className);\n+        this.fiType = fiType;\n+        this.fiDesc = fiDesc;\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        emitFunctionalInterfaceMethod();\n+        emitFunctionalFactories();\n+        emitFunctionalFactoryForPointer();\n+        return super.classEnd();\n+    }\n+\n+    \/\/ private generation\n+\n+    private void emitFunctionalInterfaceMethod() {\n+        incrAlign();\n+        indent();\n+        append(fiType.returnType().getName() + \" apply(\");\n+        String delim = \"\";\n+        for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+            append(delim + fiType.parameterType(i).getName() + \" x\" + i);\n+            delim = \", \";\n+        }\n+        append(\");\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFunctionalFactories() {\n+        emitWithConstantClass(constantBuilder -> {\n+            Constant functionDesc = constantBuilder.addFunctionDesc(className(), fiDesc);\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS + \" MemoryAddress allocate(\" + className() + \" fi) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return RuntimeHelper.upcallStub(\" + className() + \".class, fi, \" + functionDesc.accessExpression() + \", \" +\n+                    \"\\\"\" + fiType.toMethodDescriptorString() + \"\\\");\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            indent();\n+            append(MEMBER_MODS + \" MemoryAddress allocate(\" + className() + \" fi, ResourceScope scope) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return RuntimeHelper.upcallStub(\" + className() + \".class, fi, \" + functionDesc.accessExpression() + \", \" +\n+                    \"\\\"\" + fiType.toMethodDescriptorString() + \"\\\", scope);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        });\n+    }\n+\n+    private void emitFunctionalFactoryForPointer() {\n+        emitWithConstantClass(constantBuilder -> {\n+            Constant mhConstant = constantBuilder.addMethodHandle(className(), className(), FunctionInfo.ofFunctionPointer(fiType, fiDesc), true);\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS + \" \" + className() + \" ofAddress(MemoryAddress addr) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"return (\");\n+            String delim = \"\";\n+            for (int i = 0 ; i < fiType.parameterCount(); i++) {\n+                append(delim + fiType.parameterType(i).getName() + \" x\" + i);\n+                delim = \", \";\n+            }\n+            append(\") -> {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"try {\\n\");\n+            incrAlign();\n+            indent();\n+            if (!fiType.returnType().equals(void.class)) {\n+                append(\"return (\" + fiType.returnType().getName() + \")\");\n+            }\n+            append(mhConstant.accessExpression() + \".invokeExact((Addressable)addr\");\n+            if (fiType.parameterCount() > 0) {\n+                String params = IntStream.range(0, fiType.parameterCount())\n+                        .mapToObj(i -> \"x\" + i)\n+                        .collect(Collectors.joining(\", \"));\n+                append(\", \" + params);\n+            }\n+            append(\");\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"} catch (Throwable ex$) {\\n\");\n+            incrAlign();\n+            indent();\n+            append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"};\\n\");\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\");\n+            decrAlign();\n+        });\n+    }\n+\n+    @Override\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        enclosing.emitWithConstantClass(constantConsumer);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceBuilder.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+class FunctionalInterfaceScanner implements Declaration.Visitor<Void, Set<FunctionDescriptor>> {\n+\n+    private final Set<FunctionDescriptor> descriptors;\n+\n+    FunctionalInterfaceScanner(Set<FunctionDescriptor> descriptors) {\n+        this.descriptors = descriptors;\n+    }\n+\n+    Declaration.Scoped scan(Declaration.Scoped decl) {\n+        decl.accept(this, descriptors);\n+        return decl;\n+    }\n+\n+    void scanType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n+        t.accept(new TypeScanner(), functionDescriptors);\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Set<FunctionDescriptor> functionDescriptors) {\n+        d.members().forEach(m -> m.accept(this, functionDescriptors));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function d, Set<FunctionDescriptor> functionDescriptors) {\n+        scanType(d.type().returnType(), functionDescriptors);\n+        d.parameters().forEach(p -> p.accept(this, functionDescriptors));\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable d, Set<FunctionDescriptor> functionDescriptors) {\n+        scanType(d.type(), functionDescriptors);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant d, Set<FunctionDescriptor> functionDescriptors) {\n+        scanType(d.type(), functionDescriptors);\n+        return null;\n+    }\n+\n+    static class TypeScanner implements Type.Visitor<Void, Set<FunctionDescriptor>> {\n+\n+        @Override\n+        public Void visitPrimitive(Type.Primitive t, Set<FunctionDescriptor> functionDescriptors) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitDelegated(Type.Delegated t, Set<FunctionDescriptor> functionDescriptors) {\n+            return t.type().accept(this, functionDescriptors);\n+        }\n+\n+        @Override\n+        public Void visitFunction(Type.Function t, Set<FunctionDescriptor> functionDescriptors) {\n+            t.returnType().accept(this, functionDescriptors);\n+            t.argumentTypes().forEach(a -> a.accept(this, functionDescriptors));\n+            Optional<FunctionDescriptor> descriptor = Type.descriptorFor(t);\n+            if (descriptor.isPresent()) {\n+                functionDescriptors.add(descriptor.get());\n+            }\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitDeclared(Type.Declared t, Set<FunctionDescriptor> functionDescriptors) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitArray(Type.Array t, Set<FunctionDescriptor> functionDescriptors) {\n+            return t.elementType().accept(this, functionDescriptors);\n+        }\n+\n+        @Override\n+        public Void visitType(Type t, Set<FunctionDescriptor> functionDescriptors) {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/FunctionalInterfaceScanner.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,317 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import jdk.incubator.jextract.Type;\n+\n+import jdk.internal.jextract.impl.ConstantBuilder.Constant;\n+\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+\/**\n+ * A helper class to generate header interface class in source form.\n+ * After aggregating various constituents of a .java source, build\n+ * method is called to get overall generated source string.\n+ *\/\n+abstract class HeaderFileBuilder extends ClassSourceBuilder {\n+\n+    private static final String MEMBER_MODS = \"public static\";\n+\n+    private final String superclass;\n+\n+    HeaderFileBuilder(ToplevelBuilder enclosing, String name, String superclass) {\n+        super(enclosing, Kind.CLASS, name);\n+        this.superclass = superclass;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return superclass;\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n+            emitWithConstantClass(constantBuilder -> {\n+                constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+            });\n+        } else {\n+            emitWithConstantClass(constantBuilder -> {\n+                constantBuilder.addLayout(javaName, varInfo.layout())\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+                Constant vhConstant = constantBuilder.addGlobalVarHandle(javaName, nativeName, varInfo)\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+                Constant segmentConstant = constantBuilder.addSegment(javaName, nativeName, varInfo.layout())\n+                        .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+                emitGlobalGetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                emitGlobalSetter(segmentConstant, vhConstant, javaName, nativeName, varInfo.carrier());\n+                if (varInfo.fiName().isPresent()) {\n+                    emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+                }\n+            });\n+        }\n+    }\n+\n+    @Override\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+        emitWithConstantClass(constantBuilder -> {\n+            Constant mhConstant = constantBuilder.addMethodHandle(javaName, nativeName, functionInfo, false)\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME, nativeName);\n+            emitFunctionWrapper(mhConstant, javaName, nativeName, functionInfo);\n+            if (functionInfo.methodType().returnType().equals(MemorySegment.class)) {\n+                \/\/ emit scoped overload\n+                emitFunctionWrapperScopedOverload(javaName, functionInfo);\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        if (type.equals(MemorySegment.class) || type.equals(MemoryAddress.class)) {\n+            emitWithConstantClass(constantBuilder -> {\n+                constantBuilder.addConstantDesc(javaName, type, value)\n+                        .emitGetter(this, MEMBER_MODS, Constant.JAVA_NAME);\n+            });\n+        } else {\n+            emitGetter(MEMBER_MODS, type, javaName, getConstantString(type, value));\n+        }\n+    }\n+\n+    \/\/ private generation\n+\n+    private void emitFunctionWrapper(Constant mhConstant, String javaName, String nativeName, FunctionInfo functionInfo) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        MethodType declType = functionInfo.methodType();\n+        List<String> paramNames = functionInfo.parameterNames().get();\n+        if (functionInfo.methodType().returnType().equals(MemorySegment.class)) {\n+            \/\/ needs allocator parameter\n+            declType = declType.insertParameterTypes(0, SegmentAllocator.class);\n+            paramNames = new ArrayList<>(paramNames);\n+            paramNames.add(0, \"allocator\");\n+        }\n+        List<String> pExprs = emitFunctionWrapperDecl(javaName, declType, functionInfo.isVarargs(), paramNames);\n+        append(\" {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"var mh$ = RuntimeHelper.requireNonNull(\");\n+        append(mhConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\");\\n\");\n+        indent();\n+        append(\"try {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+            append(\"return (\" + functionInfo.methodType().returnType().getName() + \")\");\n+        }\n+        append(\"mh$.invokeExact(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"} catch (Throwable ex$) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"throw new AssertionError(\\\"should not reach here\\\", ex$);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private List<String> emitFunctionWrapperDecl(String javaName, MethodType methodType, boolean isVarargs, List<String> paramNames) {\n+        append(methodType.returnType().getSimpleName() + \" \" + javaName + \" (\");\n+        String delim = \"\";\n+        List<String> pExprs = new ArrayList<>();\n+        final int numParams = paramNames.size();\n+        for (int i = 0 ; i < numParams; i++) {\n+            String pName = paramNames.get(i);\n+            if (pName.isEmpty()) {\n+                pName = \"x\" + i;\n+            }\n+            if (methodType.parameterType(i).equals(MemoryAddress.class)) {\n+                pExprs.add(pName + \".address()\");\n+            } else {\n+                pExprs.add(pName);\n+            }\n+            Class<?> pType = methodType.parameterType(i);\n+            if (pType.equals(MemoryAddress.class)) {\n+                pType = Addressable.class;\n+            }\n+            append(delim + \" \" + pType.getSimpleName() + \" \" + pName);\n+            delim = \", \";\n+        }\n+        if (isVarargs) {\n+            String lastArg = \"x\" + numParams;\n+            append(delim + \"Object... \" + lastArg);\n+            pExprs.add(lastArg);\n+        }\n+        append(\")\");\n+        return pExprs;\n+    }\n+\n+    private void emitFunctionWrapperScopedOverload(String javaName, FunctionInfo functionInfo) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        List<String> paramNames = new ArrayList<>(functionInfo.parameterNames().get());\n+        paramNames.add(0, \"scope\");\n+        List<String> pExprs = emitFunctionWrapperDecl(javaName,\n+                functionInfo.methodType().insertParameterTypes(0, ResourceScope.class),\n+                functionInfo.isVarargs(),\n+                paramNames);\n+        String param = pExprs.remove(0);\n+        pExprs.add(0, \"SegmentAllocator.ofScope(\" + param + \")\");\n+        append(\" {\\n\");\n+        incrAlign();\n+        indent();\n+        if (!functionInfo.methodType().returnType().equals(void.class)) {\n+            append(\"return \");\n+        }\n+        append(javaName + \"(\" + String.join(\", \", pExprs) + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(fiName + \" \" + javaName + \" () {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + fiName + \".ofAddress(\" + javaName + \"$get());\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    void emitPrimitiveTypedef(Type.Primitive primType, String name) {\n+        Type.Primitive.Kind kind = primType.kind();\n+        if (primitiveKindSupported(kind) && !kind.layout().isEmpty()) {\n+            incrAlign();\n+            indent();\n+            append(MEMBER_MODS);\n+            append(\" ValueLayout \");\n+            append(uniqueNestedClassName(name));\n+            append(\" = \");\n+            append(TypeTranslator.typeToLayoutName(kind));\n+            append(\";\\n\");\n+            decrAlign();\n+        }\n+    }\n+\n+    private boolean primitiveKindSupported(Type.Primitive.Kind kind) {\n+        return switch(kind) {\n+            case Short, Int, Long, LongLong, Float, Double, Char -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private String getConstantString(Class<?> type, Object value) {\n+        StringBuilder buf = new StringBuilder();\n+        if (type == float.class) {\n+            float f = ((Number)value).floatValue();\n+            if (Float.isFinite(f)) {\n+                buf.append(value);\n+                buf.append(\"f\");\n+            } else {\n+                buf.append(\"Float.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else if (type == long.class) {\n+            buf.append(value);\n+            buf.append(\"L\");\n+        } else if (type == double.class) {\n+            double d = ((Number)value).doubleValue();\n+            if (Double.isFinite(d)) {\n+                buf.append(value);\n+                buf.append(\"d\");\n+            } else {\n+                buf.append(\"Double.valueOf(\\\"\");\n+                buf.append(value.toString());\n+                buf.append(\"\\\")\");\n+            }\n+        } else {\n+            buf.append(\"(\" + type.getName() + \")\");\n+            buf.append(value + \"L\");\n+        }\n+        return buf.toString();\n+    }\n+\n+    private void emitGlobalGetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get() {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \") \");\n+        append(vhConstant.accessExpression());\n+        append(\".get(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitGlobalSetter(Constant segmentConstant, Constant vhConstant, String javaName, String nativeName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + \" \" + type.getSimpleName() + \" x) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression());\n+        append(\".set(RuntimeHelper.requireNonNull(\");\n+        append(segmentConstant.accessExpression());\n+        append(\", \\\"\");\n+        append(nativeName);\n+        append(\"\\\"), x);\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/HeaderFileBuilder.java","additions":317,"deletions":0,"binary":false,"changes":317,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaCompiler;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+import java.io.*;\n+import java.io.Writer;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+final class InMemoryJavaCompiler {\n+    private InMemoryJavaCompiler() {}\n+\n+    static List<JavaFileObject> compile(List<JavaFileObject> files,\n+                                        String... options) {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        FileManager fileManager = new FileManager(compiler.getStandardFileManager(null, null, null));\n+\n+        Writer writer = new StringWriter();\n+        Boolean exitCode = compiler.getTask(writer, fileManager, null, Arrays.asList(options), null, files).call();\n+        if (!exitCode) {\n+            throw new CompilationFailedException(\"In memory compilation failed: \" + writer.toString());\n+        }\n+        return fileManager.getCompiledFiles();\n+    }\n+\n+    static JavaFileObject jfoFromByteArray(URI uri, byte[] bytes) {\n+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.CLASS) {\n+            @Override\n+            public InputStream openInputStream() {\n+                return new ByteArrayInputStream(bytes);\n+            }\n+        };\n+    }\n+\n+    static JavaFileObject jfoFromString(URI uri, String contents) {\n+        return new SimpleJavaFileObject(uri, JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return contents;\n+            }\n+        };\n+    }\n+\n+    \/\/ Wraper for class byte array\n+    private static class ClassFile extends SimpleJavaFileObject {\n+        private final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        protected ClassFile(String name) {\n+            super(URI.create(name.replace('.', '\/') + Kind.CLASS.extension), Kind.CLASS);\n+        }\n+\n+        @Override\n+        public ByteArrayOutputStream openOutputStream() {\n+            return this.baos;\n+        }\n+\n+        @Override\n+        public InputStream openInputStream() {\n+            return new ByteArrayInputStream(baos.toByteArray());\n+        }\n+    }\n+\n+    \/\/ File manager which spawns ClassFile instances on demand\n+    private static class FileManager extends ForwardingJavaFileManager<JavaFileManager> {\n+        private final List<JavaFileObject> compiled = new ArrayList<>();\n+\n+        protected FileManager(JavaFileManager fileManager) {\n+            super(fileManager);\n+        }\n+\n+        @Override\n+        public JavaFileObject getJavaFileForOutput(Location location, String name, JavaFileObject.Kind kind, FileObject source) throws IOException {\n+            JavaFileObject out = new ClassFile(name);\n+            compiled.add(out);\n+            return out;\n+        }\n+\n+        public List<JavaFileObject> getCompiledFiles() {\n+            return compiled;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/InMemoryJavaCompiler.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Comparator;\n+import java.util.EnumMap;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+\n+public class IncludeHelper {\n+\n+    public enum IncludeKind {\n+        MACRO,\n+        VAR,\n+        FUNCTION,\n+        TYPEDEF,\n+        STRUCT,\n+        UNION;\n+\n+        public String optionName() {\n+            return \"include-\" + name().toLowerCase();\n+        }\n+\n+        static IncludeKind fromDeclaration(Declaration d) {\n+            if (d instanceof Declaration.Constant) {\n+                return MACRO;\n+            } else if (d instanceof Declaration.Variable) {\n+                return VAR;\n+            } else if (d instanceof Declaration.Function) {\n+                return FUNCTION;\n+            } else if (d instanceof Declaration.Typedef) {\n+                return TYPEDEF;\n+            } else if (d instanceof Declaration.Scoped scoped) {\n+                return fromScoped(scoped);\n+            } else {\n+                throw new IllegalStateException(\"Cannot get here!\");\n+            }\n+        }\n+\n+        static IncludeKind fromScoped(Declaration.Scoped scoped) {\n+            return switch (scoped.kind()) {\n+                case STRUCT -> IncludeKind.STRUCT;\n+                case UNION ->  IncludeKind.UNION;\n+                default -> throw new IllegalStateException(\"Cannot get here!\");\n+            };\n+        }\n+    }\n+\n+    private final EnumMap<IncludeKind, Set<String>> includesSymbolNamesByKind = new EnumMap<>(IncludeKind.class);\n+    private final Set<Declaration> usedDeclarations = new HashSet<>();\n+    public String dumpIncludesFile;\n+\n+    public void addSymbol(IncludeKind kind, String symbolName) {\n+        Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n+        names.add(symbolName);\n+    }\n+\n+    public boolean isIncluded(Declaration.Variable variable) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.VAR, variable);\n+    }\n+\n+    public boolean isIncluded(Declaration.Function function) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.FUNCTION, function);\n+    }\n+\n+    public boolean isIncluded(Declaration.Constant constant) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.MACRO, constant);\n+    }\n+\n+    public boolean isIncluded(Declaration.Typedef typedef) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.TYPEDEF, typedef);\n+    }\n+\n+    public boolean isIncluded(Declaration.Scoped scoped) {\n+        return checkIncludedAndAddIfNeeded(IncludeKind.fromScoped(scoped), scoped);\n+    }\n+\n+    private boolean checkIncludedAndAddIfNeeded(IncludeKind kind, Declaration declaration) {\n+        boolean included = isIncludedInternal(kind, declaration);\n+        if (included && dumpIncludesFile != null) {\n+            usedDeclarations.add(declaration);\n+        }\n+        return included;\n+    }\n+\n+    private boolean isIncludedInternal(IncludeKind kind, Declaration declaration) {\n+        if (!isEnabled()) {\n+            return true;\n+        } else {\n+            Set<String> names = includesSymbolNamesByKind.computeIfAbsent(kind, (_unused) -> new HashSet<>());\n+            return names.contains(declaration.name());\n+        }\n+    }\n+\n+    public boolean isEnabled() {\n+        return includesSymbolNamesByKind.size() > 0;\n+    }\n+\n+    public void dumpIncludes() {\n+        try (var writer = Files.newBufferedWriter(Path.of(dumpIncludesFile), StandardOpenOption.CREATE)) {\n+            Map<Path, Set<Declaration>> declsByPath = usedDeclarations.stream()\n+                    .collect(Collectors.groupingBy(d -> d.pos().path(),\n+                            () -> new TreeMap<>(Path::compareTo),\n+                            Collectors.toCollection(() -> new TreeSet<>(Comparator.comparing(Declaration::name)))));\n+            String lineSep = \"\";\n+            for (Map.Entry<Path, Set<Declaration>> pathEntries : declsByPath.entrySet()) {\n+                writer.append(lineSep);\n+                writer.append(\"#### Extracted from: \" + pathEntries.getKey().toString() + \"\\n\\n\");\n+                Map<IncludeKind, List<Declaration>> declsByKind = pathEntries.getValue().stream()\n+                        .collect(Collectors.groupingBy(IncludeKind::fromDeclaration));\n+                int maxLengthOptionCol = pathEntries.getValue().stream().mapToInt(d -> d.name().length()).max().getAsInt();\n+                maxLengthOptionCol += 2; \/\/ --\n+                maxLengthOptionCol += IncludeKind.FUNCTION.optionName().length(); \/\/ max option name\n+                maxLengthOptionCol += 1; \/\/ space\n+                for (Map.Entry<IncludeKind, List<Declaration>> kindEntries : declsByKind.entrySet()) {\n+                    for (Declaration d : kindEntries.getValue()) {\n+                        writer.append(String.format(\"%-\" + maxLengthOptionCol + \"s %s\",\n+                                \"--\" + kindEntries.getKey().optionName() + \" \" + d.name(),\n+                                       \"# header: \" + pathEntries.getKey() + \"\\n\"));\n+                    }\n+                }\n+                lineSep = \"\\n\";\n+            }\n+        } catch (IOException exception) {\n+            throw new UncheckedIOException(exception);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/IncludeHelper.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+import javax.tools.JavaFileObject;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+public abstract class JavaSourceBuilder {\n+\n+    \/\/ public API (used by OutputFactory)\n+\n+    public static record FunctionInfo(\n+            MethodType methodType,\n+            FunctionDescriptor descriptor,\n+            boolean isVarargs,\n+            Optional<List<String>> parameterNames) {\n+\n+        static FunctionInfo ofFunction(MethodType methodType, FunctionDescriptor functionDescriptor, boolean isVarargs, List<String> parameterNames) {\n+            return new FunctionInfo(methodType, functionDescriptor, isVarargs, Optional.of(parameterNames));\n+        }\n+\n+        static FunctionInfo ofFunctionPointer(MethodType methodType, FunctionDescriptor functionDescriptor) {\n+            return new FunctionInfo(methodType, functionDescriptor, false, Optional.empty());\n+        }\n+    }\n+\n+    public static record VarInfo(\n+            Class<?> carrier,\n+            MemoryLayout layout,\n+            Optional<String> fiName) {\n+\n+        static VarInfo ofVar(Class<?> carrier, MemoryLayout layout) {\n+            return new VarInfo(carrier, layout, Optional.empty());\n+        }\n+\n+        static VarInfo ofFunctionalPointerVar(Class<?> carrier, MemoryLayout layout, String fiName) {\n+            return new VarInfo(carrier, layout, Optional.ofNullable(fiName));\n+        }\n+    }\n+\n+    public void addVar(String javaName, String nativeName, ClassSourceBuilder.VarInfo varInfo) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addFunction(String javaName, String nativeName, ClassSourceBuilder.FunctionInfo functionInfo) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addTypedef(String name, String superClass, Type type) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public String addFunctionalInterface(String name, ClassSourceBuilder.FunctionInfo fInfo) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    abstract public List<JavaFileObject> toFiles();\n+\n+    public abstract String packageName();\n+\n+    Set<String> nestedClassNames = new HashSet<>();\n+    int nestedClassNameCount = 0;\n+\n+    \/*\n+     * We may have case-insensitive name collision! A C program may have\n+     * defined structs\/unions\/typedefs with the names FooS, fooS, FoOs, fOOs.\n+     * Because we map structs\/unions\/typedefs to nested classes of header classes,\n+     * such a case-insensitive name collision is problematic. This is because in\n+     * a case-insensitive file system javac will overwrite classes for\n+     * Header$CFooS, Header$CfooS, Header$CFoOs and so on! We solve this by\n+     * generating unique case-insensitive names for nested classes.\n+     *\/\n+    final String uniqueNestedClassName(String name) {\n+        name = Utils.javaSafeIdentifier(name);\n+        var notSeen = nestedClassNames.add(name.toLowerCase());\n+        var notEnclosed = !isEnclosedBySameName(name.toLowerCase());\n+        return notSeen && notEnclosed? name : (name + \"$\" + nestedClassNameCount++);\n+    }\n+\n+    abstract boolean isEnclosedBySameName(String name);\n+\n+    abstract protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer);\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/JavaSourceBuilder.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Type.Primitive;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.Type;\n+\n+import java.util.Optional;\n+import java.util.function.Supplier;\n+\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+\/**\n+ * General Layout utility functions\n+ *\/\n+public final class LayoutUtils {\n+\n+    public static final String JEXTRACT_ANONYMOUS = \"jextract\/anonymous\";\n+    public static final String JEXTRACT_BITFIELDS = \"jextract\/bitfields\";\n+\n+    private LayoutUtils() {}\n+\n+    public static String getName(Type type) {\n+        Cursor c = type.getDeclarationCursor();\n+        if (c.isInvalid()) {\n+            return type.spelling();\n+        }\n+        return getName(c);\n+    }\n+\n+    public static String getName(Cursor cursor) {\n+        return cursor.spelling();\n+    }\n+\n+    public static MemoryLayout getLayout(Type t) {\n+        Supplier<UnsupportedOperationException> unsupported = () ->\n+                new UnsupportedOperationException(\"unsupported: \" + t.kind());\n+        switch(t.kind()) {\n+            case UChar, Char_U:\n+            case SChar, Char_S:\n+                return Primitive.Kind.Char.layout().orElseThrow(unsupported);\n+            case Short:\n+            case UShort:\n+                return Primitive.Kind.Short.layout().orElseThrow(unsupported);\n+            case Int:\n+            case UInt:\n+                return Primitive.Kind.Int.layout().orElseThrow(unsupported);\n+            case ULong:\n+            case Long:\n+                return Primitive.Kind.Long.layout().orElseThrow(unsupported);\n+            case ULongLong:\n+            case LongLong:\n+                return Primitive.Kind.LongLong.layout().orElseThrow(unsupported);\n+            case UInt128:\n+            case Int128:\n+                return Primitive.Kind.Int128.layout().orElseThrow(unsupported);\n+            case Enum:\n+                return valueLayoutForSize(t.size() * 8).layout().orElseThrow(unsupported);\n+            case Bool:\n+                return Primitive.Kind.Bool.layout().orElseThrow(unsupported);\n+            case Float:\n+                return Primitive.Kind.Float.layout().orElseThrow(unsupported);\n+            case Double:\n+                return Primitive.Kind.Double.layout().orElseThrow(unsupported);\n+            case LongDouble:\n+                return Primitive.Kind.LongDouble.layout().orElseThrow(unsupported);\n+            case Complex:\n+                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n+            case Record:\n+                return getRecordLayout(t);\n+            case Vector:\n+                return MemoryLayout.sequenceLayout(t.getNumberOfElements(), getLayout(t.getElementType()));\n+            case ConstantArray:\n+                return MemoryLayout.sequenceLayout(t.getNumberOfElements(), getLayout(t.getElementType()));\n+            case IncompleteArray:\n+                return MemoryLayout.sequenceLayout(getLayout(t.getElementType()));\n+            case Unexposed:\n+                Type canonical = t.canonicalType();\n+                if (canonical.equalType(t)) {\n+                    throw new TypeMaker.TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n+                }\n+                return getLayout(canonical);\n+            case Typedef:\n+            case Elaborated:\n+                return getLayout(t.canonicalType());\n+            case Pointer:\n+            case BlockPointer:\n+                return C_POINTER;\n+            default:\n+                throw new UnsupportedOperationException(\"unsupported: \" + t.kind());\n+        }\n+    }\n+\n+    public static Optional<MemoryLayout> getLayout(jdk.incubator.jextract.Type t) {\n+        try {\n+            return Optional.of(getLayoutInternal(t));\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static MemoryLayout getLayoutInternal(jdk.incubator.jextract.Type t) {\n+        return t.accept(layoutMaker, null);\n+    }\n+\n+    private static jdk.incubator.jextract.Type.Visitor<MemoryLayout, Void> layoutMaker = new jdk.incubator.jextract.Type.Visitor<>() {\n+        @Override\n+        public MemoryLayout visitPrimitive(jdk.incubator.jextract.Type.Primitive t, Void _ignored) {\n+            return t.kind().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDelegated(jdk.incubator.jextract.Type.Delegated t, Void _ignored) {\n+            if (t.kind() == jdk.incubator.jextract.Type.Delegated.Kind.POINTER) {\n+                return C_POINTER;\n+            } else {\n+                return t.type().accept(this, null);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitFunction(jdk.incubator.jextract.Type.Function t, Void _ignored) {\n+            \/*\n+             * \/\/ pointer to function declared as function like this\n+             *\n+             * typedef void CB(int);\n+             * void func(CB cb);\n+             *\/\n+            return C_POINTER;\n+        }\n+\n+        @Override\n+        public MemoryLayout visitDeclared(jdk.incubator.jextract.Type.Declared t, Void _ignored) {\n+            return t.tree().layout().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        @Override\n+        public MemoryLayout visitArray(jdk.incubator.jextract.Type.Array t, Void _ignored) {\n+            MemoryLayout elem = t.elementType().accept(this, null);\n+            if (t.elementCount().isPresent()) {\n+                return MemoryLayout.sequenceLayout(t.elementCount().getAsLong(), elem);\n+            } else {\n+                return MemoryLayout.sequenceLayout(elem);\n+            }\n+        }\n+\n+        @Override\n+        public MemoryLayout visitType(jdk.incubator.jextract.Type t, Void _ignored) {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n+\n+    static MemoryLayout getRecordLayout(Type type) {\n+        return RecordLayoutComputer.compute(0, type, type);\n+    }\n+\n+    private static boolean isVoidType(jdk.incubator.jextract.Type type) {\n+        if (type instanceof jdk.incubator.jextract.Type.Primitive) {\n+            jdk.incubator.jextract.Type.Primitive pt = (jdk.incubator.jextract.Type.Primitive)type;\n+            return pt.kind() == jdk.incubator.jextract.Type.Primitive.Kind.Void;\n+        } else if (type instanceof jdk.incubator.jextract.Type.Delegated) {\n+            jdk.incubator.jextract.Type.Delegated dt = (jdk.incubator.jextract.Type.Delegated)type;\n+            return dt.kind() == jdk.incubator.jextract.Type.Delegated.Kind.TYPEDEF? isVoidType(dt.type()) : false;\n+        }\n+        return false;\n+    }\n+\n+    public static Optional<FunctionDescriptor> getDescriptor(jdk.incubator.jextract.Type.Function t) {\n+        try {\n+            MemoryLayout[] args = t.argumentTypes().stream()\n+                    .map(LayoutUtils::getLayoutInternal)\n+                    .toArray(MemoryLayout[]::new);\n+            jdk.incubator.jextract.Type retType = t.returnType();\n+            if (isVoidType(retType)) {\n+                return Optional.of(FunctionDescriptor.ofVoid(args));\n+            } else {\n+                return Optional.of(FunctionDescriptor.of(getLayoutInternal(retType), args));\n+            }\n+        } catch (Throwable ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static Primitive.Kind valueLayoutForSize(long size) {\n+        return switch ((int) size) {\n+            case 8 -> Primitive.Kind.Char;\n+            case 16 -> Primitive.Kind.Short;\n+            case 32 -> Primitive.Kind.Int;\n+            case 64 -> Primitive.Kind.LongLong;\n+            default -> throw new IllegalStateException(\"Cannot infer container layout\");\n+        };\n+    }\n+\n+    static boolean isBitfields(GroupLayout layout) {\n+        return layout.attribute(JEXTRACT_BITFIELDS).isPresent();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <Z extends MemoryLayout> Z setBitfields(Z layout) {\n+        return (Z) layout.withAttribute(JEXTRACT_BITFIELDS, true);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/LayoutUtils.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"},{"patch":"@@ -0,0 +1,379 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.jextract.JextractTool;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.Diagnostic;\n+import jdk.internal.clang.EvalResult;\n+import jdk.internal.clang.Index;\n+import jdk.internal.clang.LibClang;\n+import jdk.internal.clang.TranslationUnit;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+class MacroParserImpl {\n+\n+    private final ClangReparser reparser;\n+    private final TreeMaker treeMaker;\n+    final MacroTable macroTable;\n+\n+    private MacroParserImpl(ClangReparser reparser, TreeMaker treeMaker) {\n+        this.reparser = reparser;\n+        this.treeMaker = treeMaker;\n+        this.macroTable = new MacroTable();\n+    }\n+\n+    static MacroParserImpl make(TreeMaker treeMaker, TranslationUnit tu, Collection<String> args) {\n+        ClangReparser reparser;\n+        try {\n+            reparser = new ClangReparser(tu, args);\n+        } catch (IOException | Index.ParsingFailedException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+\n+        return new MacroParserImpl(reparser, treeMaker);\n+    }\n+\n+    \/**\n+     * This method attempts to evaluate the macro. Evaluation occurs in two steps: first, an attempt is made\n+     * to see if the macro corresponds to a simple numeric constant. If so, the constant is parsed in Java directly.\n+     * If that is not possible (e.g. because the macro refers to other macro, or has a more complex grammar), fall\n+     * back to use clang evaluation support.\n+     *\/\n+    Optional<Declaration.Constant> parseConstant(Position pos, String name, String[] tokens) {\n+        if (!(pos instanceof TreeMaker.CursorPosition)) {\n+            return Optional.empty();\n+        } else {\n+            Cursor cursor = ((TreeMaker.CursorPosition)pos).cursor();\n+            if (cursor.isMacroFunctionLike()) {\n+                return Optional.empty();\n+            } else if (tokens.length == 2) {\n+                \/\/check for fast path\n+                Integer num = toNumber(tokens[1]);\n+                if (num != null) {\n+                    return Optional.of(treeMaker.createMacro(cursor, name, Type.primitive(Type.Primitive.Kind.Int), (long)num));\n+                }\n+            }\n+            macroTable.enterMacro(name, tokens, cursor);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private Integer toNumber(String str) {\n+        try {\n+            \/\/ Integer.decode supports '#' hex literals which is not valid in C.\n+            return str.length() > 0 && str.charAt(0) != '#'? Integer.decode(str) : null;\n+        } catch (NumberFormatException nfe) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * This class allows client to reparse a snippet of code against a given set of include files.\n+     * For performance reasons, the set of includes (which comes from the jextract parser) is compiled\n+     * into a precompiled header, so as to speed to incremental recompilation of the generated snippets.\n+     *\/\n+    static class ClangReparser {\n+        final Path macro;\n+        final Index macroIndex = LibClang.createIndex(true);\n+        final TranslationUnit macroUnit;\n+\n+        public ClangReparser(TranslationUnit tu, Collection<String> args) throws IOException, Index.ParsingFailedException {\n+            Path precompiled = Files.createTempFile(\"jextract$\", \".pch\");\n+            precompiled.toFile().deleteOnExit();\n+            tu.save(precompiled);\n+            this.macro = Files.createTempFile(\"jextract$\", \".h\");\n+            this.macro.toFile().deleteOnExit();\n+            String[] patchedArgs = Stream.concat(\n+                Stream.of(\n+                    \/\/ Avoid system search path, use bundled instead\n+                    \"-nostdinc\",\n+                    \"-ferror-limit=0\",\n+                    \/\/ precompiled header\n+                    \"-include-pch\", precompiled.toAbsolutePath().toString()),\n+                args.stream()).toArray(String[]::new);\n+            this.macroUnit = macroIndex.parse(macro.toAbsolutePath().toString(),\n+                    this::processDiagnostics,\n+                    false, \/\/add serialization support (needed for macros)\n+                    patchedArgs);\n+        }\n+\n+        void processDiagnostics(Diagnostic diag) {\n+            if (JextractTool.DEBUG) {\n+                System.err.println(\"Error while processing macro: \" + diag.spelling());\n+            }\n+        }\n+\n+        public Stream<Cursor> reparse(String snippet) {\n+            macroUnit.reparse(this::processDiagnostics,\n+                    Index.UnsavedFile.of(macro, snippet));\n+            return macroUnit.getCursor().children();\n+        }\n+    }\n+\n+    \/**\n+     * This abstraction is used to collect all macros which could not be interpreted during {@link #parseConstant(Position, String, String[])}.\n+     * All unparsed macros in the table can have three different states: UNPARSED (which means the macro has not been parsed yet),\n+     * SUCCESS (which means the macro has been parsed and has a type and a value) and FAILURE, which means the macro has been\n+     * parsed with some errors, but for which we were at least able to infer a type.\n+     *\n+     * The reparsing process goes as follows:\n+     * 1. all unparsed macros are added to the table in the UNPARSED state.\n+     * 2. a snippet for all macros in the UNPARSED state is compiled and the table state is updated\n+     * 3. a recovery snippet for all macros in the FAILURE state is compiled and the table state is updated again\n+     * 4. we repeat from (2) until no further progress is made.\n+     * 5. we return a list of macro which are in the SUCCESS state.\n+     *\n+     * State transitions in the table are as follows:\n+     * - an UNPARSED macro can go to either SUCCESS, to FAILURE or be removed (if not even a type can be inferred)\n+     * - a FAILURE macro can go to either SUCCESS (if recovery step succeds) or be removed\n+     * - a SUCCESS macro cannot go in any other state\n+     *\/\n+    class MacroTable {\n+\n+        final Map<String, Entry> macrosByMangledName = new LinkedHashMap<>();\n+\n+        abstract class Entry {\n+            final String name;\n+            final String[] tokens;\n+            final Cursor cursor;\n+\n+            Entry(String name, String[] tokens, Cursor cursor) {\n+                this.name = name;\n+                this.tokens = tokens;\n+                this.cursor = cursor;\n+            }\n+\n+            String mangledName() {\n+                return \"jextract$macro$\" + name;\n+            }\n+\n+            Entry success(Type type, Object value) {\n+                throw new IllegalStateException();\n+            }\n+\n+            Entry failure(Type type) {\n+                throw new IllegalStateException();\n+            }\n+\n+            boolean isSuccess() {\n+                return false;\n+            }\n+            boolean isRecoverableFailure() {\n+                return false;\n+            }\n+            boolean isUnparsed() {\n+                return false;\n+            }\n+\n+            void update() {\n+                macrosByMangledName.put(mangledName(), this);\n+            }\n+        }\n+\n+        class Unparsed extends Entry {\n+            Unparsed(String name, String[] tokens, Cursor cursor) {\n+                super(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            Entry success(Type type, Object value) {\n+                return new Success(name, tokens, cursor, type, value);\n+            }\n+\n+            @Override\n+            Entry failure(Type type) {\n+                return type != null ?\n+                        new RecoverableFailure(name, tokens, cursor, type) :\n+                        new UnparseableMacro(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            boolean isUnparsed() {\n+                return true;\n+            }\n+\n+            @Override\n+            void update() {\n+                throw new IllegalStateException();\n+            }\n+        }\n+\n+        class RecoverableFailure extends Entry {\n+\n+            final Type type;\n+\n+            public RecoverableFailure(String name, String[] tokens, Cursor cursor, Type type) {\n+                super(name, tokens, cursor);\n+                this.type = type;\n+            }\n+\n+            @Override\n+            Entry success(Type type, Object value) {\n+                return new Success(name, tokens, cursor, this.type, value);\n+            }\n+\n+            @Override\n+            Entry failure(Type type) {\n+                return new UnparseableMacro(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            boolean isRecoverableFailure() {\n+                return true;\n+            }\n+        }\n+\n+        class Success extends Entry {\n+            final Type type;\n+            final Object value;\n+\n+            public Success(String name, String[] tokens, Cursor cursor, Type type, Object value) {\n+                super(name, tokens, cursor);\n+                this.type = type;\n+                this.value = value;\n+            }\n+\n+            @Override\n+            boolean isSuccess() {\n+                return true;\n+            }\n+\n+            public Object value() {\n+                return value;\n+            }\n+        }\n+\n+        class UnparseableMacro extends Entry {\n+\n+            UnparseableMacro(String name, String[] tokens, Cursor cursor) {\n+                super(name, tokens, cursor);\n+            }\n+\n+            @Override\n+            void update() {\n+                macrosByMangledName.remove(mangledName());\n+            }\n+        };\n+\n+        void enterMacro(String name, String[] tokens, Cursor cursor) {\n+            Unparsed unparsed = new Unparsed(name, tokens, cursor);\n+            macrosByMangledName.put(unparsed.mangledName(), unparsed);\n+        }\n+\n+        public List<Declaration.Constant> reparseConstants() {\n+            int last = -1;\n+            while (macrosByMangledName.size() > 0 && last != macrosByMangledName.size()) {\n+                last = macrosByMangledName.size();\n+                \/\/ step 1 - try parsing macros as var declarations\n+                reparseMacros(false);\n+                \/\/ step 2 - retry failed parsed macros as pointers\n+                reparseMacros(true);\n+            }\n+            treeMaker.typeMaker.resolveTypeReferences();\n+            return macrosByMangledName.values().stream()\n+                    .filter(Entry::isSuccess)\n+                    .map(e -> treeMaker.createMacro(e.cursor, e.name, ((Success)e).type, ((Success)e).value))\n+                    .collect(Collectors.toList());\n+        }\n+\n+        void updateTable(TypeMaker typeMaker, Cursor decl) {\n+            String mangledName = decl.spelling();\n+            Entry entry = macrosByMangledName.get(mangledName);\n+            try (EvalResult result = decl.eval()) {\n+                Entry newEntry = switch (result.getKind()) {\n+                    case Integral -> {\n+                        long value = result.getAsInt();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    case FloatingPoint -> {\n+                        double value = result.getAsFloat();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    case StrLiteral -> {\n+                        String value = result.getAsString();\n+                        yield entry.success(typeMaker.makeType(decl.type()), value);\n+                    }\n+                    default -> {\n+                        Type type = decl.type().equals(decl.type().canonicalType()) ?\n+                                null : typeMaker.makeType(decl.type());\n+                        yield entry.failure(type);\n+                    }\n+                };\n+                newEntry.update();\n+            }\n+        }\n+\n+        void reparseMacros(boolean recovery) {\n+            String snippet = macroDecl(recovery);\n+            TreeMaker treeMaker = new TreeMaker();\n+            try {\n+                reparser.reparse(snippet)\n+                        .filter(c -> c.kind() == CursorKind.VarDecl &&\n+                                c.spelling().contains(\"jextract$\"))\n+                        .forEach(c -> updateTable(treeMaker.typeMaker, c));\n+            } finally {\n+                treeMaker.typeMaker.resolveTypeReferences();\n+            }\n+        }\n+\n+        String macroDecl(boolean recovery) {\n+            StringBuilder buf = new StringBuilder();\n+            if (recovery) {\n+                buf.append(\"#include <stdint.h>\\n\");\n+            }\n+            macrosByMangledName.values().stream()\n+                    .filter(e -> !e.isSuccess()) \/\/ skip macros that already have passed\n+                    .filter(recovery ? Entry::isRecoverableFailure : Entry::isUnparsed)\n+                    .forEach(e -> {\n+                        buf.append(\"__auto_type \")\n+                                .append(e.mangledName())\n+                                .append(\" = \");\n+                        if (recovery) {\n+                            buf.append(\"(uintptr_t)\");\n+                        }\n+                        buf.append(e.name)\n+                                .append(\";\\n\");\n+                    });\n+            return buf.toString();\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/MacroParserImpl.java","additions":379,"deletions":0,"binary":false,"changes":379,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public final class Options {\n+\n+    \/\/ The args for parsing C\n+    public final List<String> clangArgs;\n+    \/\/ The list of library names\n+    public final List<String> libraryNames;\n+    public final List<String> filters;\n+    \/\/ target package\n+    public final String targetPackage;\n+    \/\/ output directory\n+    public final String outputDir;\n+    public final boolean source;\n+    public final IncludeHelper includeHelper;\n+\n+    private Options(List<String> clangArgs, List<String> libraryNames,\n+            List<String> filters, String targetPackage,\n+            String outputDir, boolean source, IncludeHelper includeHelper) {\n+        this.clangArgs = clangArgs;\n+        this.libraryNames = libraryNames;\n+        this.filters = filters;\n+        this.targetPackage = targetPackage;\n+        this.outputDir = outputDir;\n+        this.source = source;\n+        this.includeHelper = includeHelper;\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    public static Options createDefault() {\n+        return builder().build();\n+    }\n+\n+    public static class Builder {\n+        private final List<String> clangArgs;\n+        private final List<String> libraryNames;\n+        private final List<String> filters;\n+        private String targetPackage;\n+        private String outputDir;\n+        private boolean source;\n+        private IncludeHelper includeHelper = new IncludeHelper();\n+\n+        public Builder() {\n+            this.clangArgs = new ArrayList<>();\n+            this.libraryNames = new ArrayList<>();\n+            this.filters = new ArrayList<>();\n+            this.targetPackage = \"\";\n+            this.outputDir = \".\";\n+            this.source = false;\n+        }\n+\n+        public Options build() {\n+            return new Options(\n+                    Collections.unmodifiableList(clangArgs),\n+                    Collections.unmodifiableList(libraryNames),\n+                    Collections.unmodifiableList(filters),\n+                    targetPackage, outputDir, source, includeHelper\n+            );\n+        }\n+\n+        public void addClangArg(String arg) {\n+            clangArgs.add(arg);\n+        }\n+\n+        public void addLibraryName(String name) {\n+            libraryNames.add(name);\n+        }\n+\n+        public void setOutputDir(String outputDir) {\n+            this.outputDir = outputDir;\n+        }\n+\n+        public void setTargetPackage(String pkg) {\n+            this.targetPackage = pkg;\n+        }\n+\n+        public void addFilter(String filter) {\n+            filters.add(filter);\n+        }\n+\n+        public void setGenerateSource() {\n+            source = true;\n+        }\n+\n+        public void setDumpIncludeFile(String dumpIncludesFile) {\n+            includeHelper.dumpIncludesFile = dumpIncludesFile;\n+        }\n+\n+        public void addIncludeSymbol(IncludeHelper.IncludeKind kind, String symbolName) {\n+            includeHelper.addSymbol(kind, symbolName);\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Options.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,533 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.*;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.JextractTool;\n+import jdk.incubator.jextract.Type;\n+\n+import jdk.internal.jextract.impl.JavaSourceBuilder.VarInfo;\n+import jdk.internal.jextract.impl.JavaSourceBuilder.FunctionInfo;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.constant.ClassDesc;\n+import java.lang.invoke.MethodType;\n+import java.net.URI;\n+import java.net.URL;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiFunction;\n+import java.util.stream.Collectors;\n+\n+\/*\n+ * Scan a header file and generate Java source items for entities defined in that header\n+ * file. Tree visitor visit methods return true\/false depending on whether a\n+ * particular Tree is processed or skipped.\n+ *\/\n+public class OutputFactory implements Declaration.Visitor<Void, Declaration> {\n+    \/\/ internal symbol used by clang for \"va_list\"\n+    private static final String VA_LIST_TAG = \"__va_list_tag\";\n+    private final Set<String> constants = new HashSet<>();\n+    \/\/ To detect duplicate Variable and Function declarations.\n+    private final Set<String> variables = new HashSet<>();\n+    private final Set<Declaration.Function> functions = new HashSet<>();\n+\n+    protected final ToplevelBuilder toplevelBuilder;\n+    protected JavaSourceBuilder currentBuilder;\n+    protected final TypeTranslator typeTranslator = new TypeTranslator();\n+    private final String pkgName;\n+    private final Map<Declaration, String> structClassNames = new HashMap<>();\n+    private final Set<Declaration.Typedef> unresolvedStructTypedefs = new HashSet<>();\n+    private final Map<Type, String> functionTypeDefNames = new HashMap<>();\n+    private final IncludeHelper includeHelper;\n+\n+    private void addStructDefinition(Declaration decl, String name) {\n+        structClassNames.put(decl, name);\n+    }\n+\n+    private boolean structDefinitionSeen(Declaration decl) {\n+        return structClassNames.containsKey(decl);\n+    }\n+\n+    private String structDefinitionName(Declaration decl) {\n+        return structClassNames.get(decl);\n+    }\n+\n+    private void addFunctionTypedef(Type.Delegated typedef, String name) {\n+        functionTypeDefNames.put(typedef, name);\n+    }\n+\n+    private boolean functionTypedefSeen(Type.Delegated typedef) {\n+        return functionTypeDefNames.containsKey(typedef);\n+    }\n+\n+    private String functionTypedefName(Type.Delegated decl) {\n+        return functionTypeDefNames.get(decl);\n+    }\n+\n+    \/\/ have we seen this Variable earlier?\n+    protected boolean variableSeen(Declaration.Variable tree) {\n+        return !variables.add(tree.name());\n+    }\n+\n+    \/\/ have we seen this Function earlier?\n+    protected boolean functionSeen(Declaration.Function tree) {\n+        return !functions.add(tree);\n+    }\n+\n+    public static JavaFileObject[] generateWrapped(Declaration.Scoped decl, String headerName,\n+                String pkgName, IncludeHelper includeHelper, List<String> libraryNames) {\n+        String clsName = Utils.javaSafeIdentifier(headerName.replace(\".h\", \"_h\"), true);\n+        ToplevelBuilder toplevelBuilder = new ToplevelBuilder(pkgName, clsName, libraryNames.toArray(new String[0]));\n+        return new OutputFactory(pkgName, toplevelBuilder, includeHelper).generate(decl);\n+    }\n+\n+    private OutputFactory(String pkgName, ToplevelBuilder toplevelBuilder, IncludeHelper includeHelper) {\n+        this.pkgName = pkgName;\n+        this.toplevelBuilder = toplevelBuilder;\n+        this.currentBuilder = toplevelBuilder;\n+        this.includeHelper = includeHelper;\n+    }\n+\n+    JavaFileObject[] generate(Declaration.Scoped decl) {\n+        \/\/generate all decls\n+        decl.members().forEach(this::generateDecl);\n+        \/\/ check if unresolved typedefs can be resolved now!\n+        for (Declaration.Typedef td : unresolvedStructTypedefs) {\n+            Declaration.Scoped structDef = ((Type.Declared) td.type()).tree();\n+            toplevelBuilder.addTypedef(td.name(),\n+                    structDefinitionSeen(structDef) ? structDefinitionName(structDef) : null, td.type());\n+        }\n+        try {\n+            List<JavaFileObject> files = new ArrayList<>(toplevelBuilder.toFiles());\n+            files.add(jfoFromString(pkgName,\"RuntimeHelper\", getRuntimeHelperSource()));\n+            return files.toArray(new JavaFileObject[0]);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        } catch (URISyntaxException ex2) {\n+            throw new RuntimeException(ex2);\n+        }\n+    }\n+\n+    private String getRuntimeHelperSource() throws URISyntaxException, IOException {\n+        URL runtimeHelper = OutputFactory.class.getResource(\"resources\/RuntimeHelper.java.template\");\n+        return (pkgName.isEmpty()? \"\" : \"package \" + pkgName + \";\\n\") +\n+                        String.join(\"\\n\", Files.readAllLines(Paths.get(runtimeHelper.toURI())));\n+    }\n+\n+    private void generateDecl(Declaration tree) {\n+        try {\n+            tree.accept(this, null);\n+        } catch (Exception ex) {\n+            ex.printStackTrace();\n+        }\n+    }\n+\n+    private JavaFileObject jfoFromString(String pkgName, String clsName, String contents) {\n+        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n+        return InMemoryJavaCompiler.jfoFromString(URI.create(pkgPrefix + clsName + \".java\"), contents);\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant constant, Declaration parent) {\n+        if (!constants.add(constant.name()) || !includeHelper.isIncluded(constant)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        Class<?> clazz = getJavaType(constant.type());\n+        if (clazz == null) {\n+            warn(\"skipping \" + constant.name() + \" because of unsupported type usage\");\n+            return null;\n+        }\n+        toplevelBuilder.addConstant(Utils.javaSafeIdentifier(constant.name()),\n+                constant.value() instanceof String ? MemorySegment.class :\n+                typeTranslator.getJavaType(constant.type()), constant.value());\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Declaration parent) {\n+        if (d.layout().isEmpty()) {\n+            \/\/skip decl-only\n+            return null;\n+        }\n+        boolean isStructKind = switch (d.kind()) {\n+            case STRUCT, UNION -> true;\n+            default -> false;\n+        };\n+        StructBuilder structBuilder = null;\n+        if (isStructKind) {\n+            String className = d.name();\n+            if (!className.isEmpty() && !includeHelper.isIncluded(d)) {\n+                return null;\n+            }\n+            GroupLayout layout = (GroupLayout) layoutFor(d);\n+            currentBuilder = structBuilder = currentBuilder.addStruct(className, parent, layout, Type.declared(d));\n+            structBuilder.classBegin();\n+            if (!className.isEmpty()) {\n+                addStructDefinition(d, structBuilder.fullName());\n+            }\n+        }\n+        try {\n+            d.members().forEach(fieldTree -> fieldTree.accept(this, d));\n+        } finally {\n+            if (isStructKind) {\n+                currentBuilder = structBuilder.classEnd();\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static MemoryLayout isUnsupported(MemoryLayout layout) {\n+        if (layout instanceof ValueLayout) {\n+            if (UnsupportedLayouts.isUnsupported(layout)) {\n+                return layout;\n+            }\n+        } else if (layout instanceof GroupLayout) {\n+            GroupLayout gl = (GroupLayout)layout;\n+            for (MemoryLayout ml : gl.memberLayouts()) {\n+                MemoryLayout ul = isUnsupported(ml);\n+                if (ul != null) {\n+                    return ul;\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private static MemoryLayout isUnsupported(FunctionDescriptor desc) {\n+        MemoryLayout resultLayout = desc.returnLayout().orElse(null);\n+        if (resultLayout != null) {\n+            MemoryLayout ul = isUnsupported(resultLayout);\n+            if (ul != null) {\n+                return ul;\n+            }\n+        }\n+\n+        for (MemoryLayout argLayout : desc.argumentLayouts()) {\n+            MemoryLayout ul = isUnsupported(argLayout);\n+            if (ul != null) {\n+                return ul;\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private String generateFunctionalInterface(Type.Function func, String name) {\n+        return functionInfo(func, name, false, FunctionInfo::ofFunctionPointer)\n+                .map(fInfo -> currentBuilder.addFunctionalInterface(Utils.javaSafeIdentifier(name), fInfo))\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function funcTree, Declaration parent) {\n+        if (functionSeen(funcTree) ||\n+                !includeHelper.isIncluded(funcTree)) {\n+            return null;\n+        }\n+\n+        String mhName = Utils.javaSafeIdentifier(funcTree.name());\n+        \/\/generate static wrapper for function\n+        List<String> paramNames = funcTree.parameters()\n+                                          .stream()\n+                                          .map(Declaration.Variable::name)\n+                                          .map(p -> !p.isEmpty() ? Utils.javaSafeIdentifier(p) : p)\n+                                          .collect(Collectors.toList());\n+\n+        Optional<FunctionInfo> functionInfo = functionInfo(funcTree.type(), funcTree.name(), true,\n+                (mtype, desc) -> FunctionInfo.ofFunction(mtype, desc, funcTree.type().varargs(), paramNames));\n+\n+        if (functionInfo.isPresent()) {\n+            int i = 0;\n+            for (Declaration.Variable param : funcTree.parameters()) {\n+                Type.Function f = getAsFunctionPointer(param.type());\n+                if (f != null) {\n+                    String name = funcTree.name() + \"$\" + (param.name().isEmpty() ? \"x\" + i : param.name());\n+                    if (generateFunctionalInterface(f, name) == null) {\n+                        return null;\n+                    }\n+                    i++;\n+                }\n+            }\n+\n+            toplevelBuilder.addFunction(mhName, funcTree.name(), functionInfo.get());\n+        }\n+\n+        return null;\n+    }\n+\n+    Optional<String> getAsFunctionPointerTypedef(Type type) {\n+        if (type instanceof Type.Delegated delegated &&\n+                delegated.kind() == Type.Delegated.Kind.TYPEDEF &&\n+                functionTypedefSeen(delegated)) {\n+            return Optional.of(functionTypedefName(delegated));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    Type.Function getAsFunctionPointer(Type type) {\n+        if (type instanceof Type.Delegated) {\n+            Type.Delegated delegated = (Type.Delegated) type;\n+            return (delegated.kind() == Type.Delegated.Kind.POINTER) ?\n+                    getAsFunctionPointer(delegated.type()) : null;\n+        } else if (type instanceof Type.Function) {\n+            \/*\n+             * \/\/ pointer to function declared as function like this\n+             *\n+             * typedef void CB(int);\n+             * void func(CB cb);\n+             *\/\n+            return (Type.Function) type;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef tree, Declaration parent) {\n+        if (!includeHelper.isIncluded(tree)) {\n+            return null;\n+        }\n+        Type type = tree.type();\n+        if (type instanceof Type.Declared) {\n+            Declaration.Scoped s = ((Type.Declared) type).tree();\n+            if (!s.name().equals(tree.name())) {\n+                switch (s.kind()) {\n+                    case STRUCT, UNION -> {\n+                        if (s.name().isEmpty()) {\n+                            visitScoped(s, tree);\n+                        } else {\n+                            \/*\n+                             * If typedef is seen after the struct\/union definition, we can generate subclass\n+                             * right away. If not, we've to save it and revisit after all the declarations are\n+                             * seen. This is to support forward declaration of typedefs.\n+                             *\n+                             * typedef struct Foo Bar;\n+                             *\n+                             * struct Foo {\n+                             *     int x, y;\n+                             * };\n+                             *\/\n+                            if (structDefinitionSeen(s)) {\n+                                toplevelBuilder.addTypedef(tree.name(), structDefinitionName(s), tree.type());\n+                            } else {\n+                                \/*\n+                                 * Definition of typedef'ed struct\/union not seen yet. May be the definition comes later.\n+                                 * Save it to visit at the end of all declarations.\n+                                 *\/\n+                                unresolvedStructTypedefs.add(tree);\n+                            }\n+                        }\n+                    }\n+                    default -> visitScoped(s, tree);\n+                }\n+            }\n+        } else if (type instanceof Type.Primitive) {\n+             toplevelBuilder.addTypedef(tree.name(), null, type);\n+        } else {\n+            Type.Function func = getAsFunctionPointer(type);\n+            if (func != null) {\n+                String funcIntfName = generateFunctionalInterface(func, tree.name());\n+                if (funcIntfName != null) {\n+                    addFunctionTypedef(Type.typedef(tree.name(), tree.type()), funcIntfName);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable tree, Declaration parent) {\n+        if (parent == null && (variableSeen(tree) || !includeHelper.isIncluded(tree))) {\n+            return null;\n+        }\n+\n+        String fieldName = tree.name();\n+        String symbol = tree.name();\n+        assert !symbol.isEmpty();\n+        assert !fieldName.isEmpty();\n+        fieldName = Utils.javaSafeIdentifier(fieldName);\n+\n+        Type type = tree.type();\n+\n+        if (type instanceof Type.Declared && ((Type.Declared) type).tree().name().isEmpty()) {\n+            \/\/ anon type - let's generate something\n+            ((Type.Declared) type).tree().accept(this, tree);\n+        }\n+        MemoryLayout layout = tree.layout().orElse(Type.layoutFor(type).orElse(null));\n+        if (layout == null) {\n+            \/\/no layout - abort\n+            return null;\n+        }\n+\n+        MemoryLayout ul = isUnsupported(layout);\n+        if (ul != null) {\n+            String name = parent != null? parent.name() + \".\" : \"\";\n+            name += fieldName;\n+            warn(\"skipping \" + name + \" because of unsupported type usage: \" +\n+                    UnsupportedLayouts.getUnsupportedTypeName(ul));\n+            return null;\n+        }\n+\n+        Class<?> clazz = getJavaType(type);\n+        if (clazz == null) {\n+            String name = parent != null? parent.name() + \".\" : \"\";\n+            name += fieldName;\n+            warn(\"skipping \" + name + \" because of unsupported type usage\");\n+            return null;\n+        }\n+\n+\n+        VarInfo varInfo = VarInfo.ofVar(clazz, layout);\n+        Type.Function func = getAsFunctionPointer(type);\n+        String fiName;\n+        if (func != null) {\n+            fiName = generateFunctionalInterface(func, fieldName);\n+            if (fiName != null) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, fiName);\n+            }\n+        } else {\n+            Optional<String> funcTypedef = getAsFunctionPointerTypedef(type);\n+            if (funcTypedef.isPresent()) {\n+                varInfo = VarInfo.ofFunctionalPointerVar(clazz, layout, Utils.javaSafeIdentifier(funcTypedef.get()));\n+            }\n+        }\n+\n+        if (tree.kind() == Declaration.Variable.Kind.BITFIELD ||\n+                (layout instanceof ValueLayout && layout.byteSize() > 8)) {\n+            \/\/skip\n+            return null;\n+        }\n+\n+        boolean sizeAvailable;\n+        try {\n+            layout.byteSize();\n+            sizeAvailable = true;\n+        } catch (Exception ignored) {\n+            sizeAvailable = false;\n+        }\n+        if (sizeAvailable) {\n+            currentBuilder.addVar(fieldName, tree.name(), varInfo);\n+        } else {\n+            warn(\"Layout size not available for \" + fieldName);\n+        }\n+\n+        return null;\n+    }\n+\n+    private Optional<FunctionInfo> functionInfo(Type.Function funcPtr, String nativeName, boolean allowVarargs,\n+                                                BiFunction<MethodType, FunctionDescriptor, FunctionInfo> functionInfoFactory) {\n+        FunctionDescriptor descriptor = Type.descriptorFor(funcPtr).orElse(null);\n+        if (descriptor == null) {\n+            \/\/abort\n+            return Optional.empty();\n+        }\n+\n+        \/\/generate functional interface\n+        if (!allowVarargs && funcPtr.varargs() && !funcPtr.argumentTypes().isEmpty()) {\n+            warn(\"varargs in callbacks is not supported: \" + funcPtr);\n+            return Optional.empty();\n+        }\n+\n+        MemoryLayout unsupportedLayout = isUnsupported(descriptor);\n+        if (unsupportedLayout != null) {\n+            warn(\"skipping \" + nativeName + \" because of unsupported type usage: \" +\n+                    UnsupportedLayouts.getUnsupportedTypeName(unsupportedLayout));\n+            return Optional.empty();\n+        }\n+\n+        MethodType mtype = getMethodType(funcPtr, allowVarargs);\n+        return mtype != null ?\n+                Optional.of(functionInfoFactory.apply(mtype, descriptor)) :\n+                Optional.empty();\n+    }\n+\n+    protected static MemoryLayout layoutFor(Declaration decl) {\n+        if (decl instanceof Declaration.Typedef) {\n+            Declaration.Typedef alias = (Declaration.Typedef) decl;\n+            return Type.layoutFor(alias.type()).orElseThrow();\n+        } else if (decl instanceof Declaration.Scoped) {\n+            return ((Declaration.Scoped) decl).layout().orElseThrow();\n+        } else {\n+            throw new IllegalArgumentException(\"Unexpected parent declaration\");\n+        }\n+        \/\/ case like `typedef struct { ... } Foo`\n+    }\n+\n+    static void warn(String msg) {\n+        System.err.println(\"WARNING: \" + msg);\n+    }\n+\n+    private Class<?> getJavaType(Type type) {\n+        try {\n+            return typeTranslator.getJavaType(type);\n+        } catch (UnsupportedOperationException uoe) {\n+            warn(uoe.toString());\n+            if (JextractTool.DEBUG) {\n+                uoe.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private MethodType getMethodType(Type.Function type) {\n+        try {\n+            return typeTranslator.getMethodType(type);\n+        } catch (UnsupportedOperationException uoe) {\n+            warn(uoe.toString());\n+            if (JextractTool.DEBUG) {\n+                uoe.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+\n+    private MethodType getMethodType(Type.Function type, boolean varargsCheck) {\n+        try {\n+            return typeTranslator.getMethodType(type, varargsCheck);\n+        } catch (UnsupportedOperationException uoe) {\n+            warn(uoe.toString());\n+            if (JextractTool.DEBUG) {\n+                uoe.printStackTrace();\n+            }\n+            return null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/OutputFactory.java","additions":533,"deletions":0,"binary":false,"changes":533,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.Diagnostic;\n+import jdk.internal.clang.Index;\n+import jdk.internal.clang.LibClang;\n+import jdk.internal.clang.SourceLocation;\n+import jdk.internal.clang.SourceRange;\n+import jdk.internal.clang.TranslationUnit;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class Parser {\n+    private final TreeMaker treeMaker;\n+\n+    public Parser() {\n+        this.treeMaker = new TreeMaker();\n+    }\n+\n+    public Declaration.Scoped parse(Path path, Collection<String> args) {\n+        final Index index = LibClang.createIndex(false);\n+\n+        TranslationUnit tu = index.parse(path.toString(),\n+            d -> {\n+                if (d.severity() > Diagnostic.CXDiagnostic_Warning) {\n+                    throw new ClangException(d.toString());\n+                }\n+            },\n+            true, args.toArray(new String[0]));\n+\n+        MacroParserImpl macroParser = MacroParserImpl.make(treeMaker, tu, args);\n+\n+        List<Declaration> decls = new ArrayList<>();\n+        Cursor tuCursor = tu.getCursor();\n+        tuCursor.children().\n+            forEach(c -> {\n+                SourceLocation loc = c.getSourceLocation();\n+                if (loc == null) {\n+                    return;\n+                }\n+\n+                SourceLocation.Location src = loc.getFileLocation();\n+                if (src == null) {\n+                    return;\n+                }\n+\n+\n+                if (c.isDeclaration()) {\n+                    if (c.kind() == CursorKind.UnexposedDecl ||\n+                        c.kind() == CursorKind.Namespace) {\n+                        c.children().map(treeMaker::createTree)\n+                                .filter(t -> t != null)\n+                                .forEach(decls::add);\n+                    } else {\n+                        Declaration decl = treeMaker.createTree(c);\n+                        if (decl != null) {\n+                            decls.add(decl);\n+                        }\n+                    }\n+                } else if (isMacro(c) && src.path() != null) {\n+                    SourceRange range = c.getExtent();\n+                    String[] tokens = c.getTranslationUnit().tokens(range);\n+                    Optional<Declaration.Constant> constant = macroParser.parseConstant(treeMaker.toPos(c), c.spelling(), tokens);\n+                    if (constant.isPresent()) {\n+                        decls.add(constant.get());\n+                    }\n+                }\n+            });\n+\n+        decls.addAll(macroParser.macroTable.reparseConstants());\n+        Declaration.Scoped rv = treeMaker.createHeader(tuCursor, decls);\n+        treeMaker.freeze();\n+        index.close();\n+        return rv;\n+    }\n+\n+    private boolean isMacro(Cursor c) {\n+        return c.isPreprocessing() && c.kind() == CursorKind.MacroDefinition;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Parser.java","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import java.lang.constant.Constable;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+\n+public class PrettyPrinter implements Declaration.Visitor<Void, Void> {\n+\n+    private static String SPACES = \" \".repeat(92);\n+    int align = 0;\n+\n+    void incr() {\n+        align += 4;\n+    }\n+\n+    void decr() {\n+        align -= 4;\n+    }\n+\n+    void indent() {\n+        builder.append(SPACES.substring(0, align));\n+    }\n+\n+    StringBuilder builder = new StringBuilder();\n+\n+    private void getAttributes(Declaration decl) {\n+        Set<String> attrs = decl.attributeNames();\n+        if (attrs.isEmpty()) {\n+            return;\n+        }\n+        incr();\n+        indent();\n+        for (String k: attrs) {\n+            builder.append(\"Attr: \");\n+            builder.append(k);\n+            builder.append(\" -> [\");\n+            builder.append(decl.getAttribute(k).get().stream()\n+                .map(Constable::toString)\n+                .collect(Collectors.joining(\", \")));\n+            builder.append(\"]\\n\");\n+        }\n+        decr();\n+    }\n+\n+    public String print(Declaration decl) {\n+        decl.accept(this, null);\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped d, Void aVoid) {\n+        indent();\n+        builder.append(\"Scoped: \" + d.kind() + \" \" + d.name() + d.layout().map(l -> \" layout = \" + l).orElse(\"\"));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        incr();\n+        d.members().forEach(m -> m.accept(this, null));\n+        decr();\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitFunction(Declaration.Function d, Void aVoid) {\n+        indent();\n+        builder.append(\"Function: \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        incr();\n+        d.parameters().forEach(m -> m.accept(this, null));\n+        decr();\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitVariable(Declaration.Variable d, Void aVoid) {\n+        indent();\n+        builder.append(\"Variable: \" + d.kind() + \" \" + d.name() + \" type = \" + d.type().accept(typeVisitor, null) + \", layout = \" + d.layout());\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitConstant(Declaration.Constant d, Void aVoid) {\n+        indent();\n+        builder.append(\"Constant: \" + d.name() + \" \" + d.value() + \" type = \" + d.type().accept(typeVisitor, null));\n+        builder.append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitTypedef(Declaration.Typedef d, Void aVoid) {\n+        indent();\n+        builder.append(\"Typedef: \").append(d.name()).append(\" = \")\n+               .append(d.type().accept(typeVisitor, null)).append(\"\\n\");\n+        getAttributes(d);\n+        return null;\n+    }\n+\n+    private static Type.Visitor<String, Void> typeVisitor = new Type.Visitor<>() {\n+        @Override\n+        public String visitPrimitive(Type.Primitive t, Void aVoid) {\n+            return t.kind().toString() + t.kind().layout().map(l -> \"(layout = \" + l + \")\").orElse(\"\");\n+        }\n+\n+        @Override\n+        public String visitDelegated(Type.Delegated t, Void aVoid) {\n+            switch (t.kind()) {\n+                case TYPEDEF:\n+                    return \"typedef \" + t.name() + \" = \" + t.type().accept(this, null);\n+                case POINTER:\n+                    return \"(\" + t.type().accept(this, null) + \")*\";\n+                default:\n+                    return t.kind() + \" = \" + t.type().accept(this, null);\n+            }\n+        }\n+\n+        @Override\n+        public String visitFunction(Type.Function t, Void aVoid) {\n+            String res = t.returnType().accept(this, null);\n+            String args = t.argumentTypes().stream()\n+                    .map(a -> a.accept(this, null))\n+                    .collect(Collectors.joining(\",\", \"(\", \")\"));\n+            return res + args;\n+        }\n+\n+        @Override\n+        public String visitDeclared(Type.Declared t, Void aVoid) {\n+            return \"Declared(\" + t.tree().layout().map(MemoryLayout::toString).orElse(\"\") + \")\";\n+        }\n+\n+        @Override\n+        public String visitArray(Type.Array t, Void aVoid) {\n+            String brackets = String.format(\"%s[%s]\", t.kind() == Type.Array.Kind.VECTOR ? \"v\" : \"\",\n+                    t.elementCount().isPresent() ? t.elementCount().getAsLong() : \"\");\n+            return t.elementType().accept(this, null) + brackets;\n+        }\n+\n+        @Override\n+        public String visitType(Type t, Void aVoid) {\n+            return \"Unknown type: \" + t.getClass().getName();\n+        }\n+    };\n+\n+    public static String type(Type type) {\n+        return type.accept(typeVisitor, null);\n+    }\n+\n+    public static String position(Position pos) {\n+        return String.format(\"%s:%d:%d\",\n+                pos.path() == null ? \"N\/A\" : pos.path().toString(),\n+                pos.line(), pos.col());\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/PrettyPrinter.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.Type;\n+import jdk.internal.clang.TypeKind;\n+\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n+\n+\/**\n+ * Base class for C struct, union MemoryLayout computer helper classes.\n+ *\/\n+abstract class RecordLayoutComputer {\n+    \/\/ enclosing struct type (or this struct type for top level structs)\n+    final Type parent;\n+    \/\/ this struct type\n+    final Type type;\n+    \/\/ cursor of this struct\n+    final Cursor cursor;\n+    final List<MemoryLayout> fieldLayouts;\n+\n+    private int anonCount = 0;\n+\n+    RecordLayoutComputer(Type parent, Type type) {\n+        this.parent = parent;\n+        this.type = type;\n+        this.cursor = type.getDeclarationCursor().getDefinition();\n+        this.fieldLayouts = new ArrayList<>();\n+    }\n+\n+    static MemoryLayout compute(long offsetInParent, Type parent, Type type) {\n+        Cursor cursor = type.getDeclarationCursor().getDefinition();\n+        if (cursor.isInvalid()) {\n+            return MemoryLayout.paddingLayout(64);\n+        }\n+\n+        final boolean isUnion = cursor.kind() == CursorKind.UnionDecl;\n+        return isUnion? new UnionLayoutComputer(offsetInParent, parent, type).compute() :\n+                new StructLayoutComputer(offsetInParent, parent, type).compute();\n+    }\n+\n+    final MemoryLayout compute() {\n+        Stream<Cursor> fieldCursors = Utils.flattenableChildren(cursor);\n+        for (Cursor fc : fieldCursors.collect(Collectors.toList())) {\n+            \/*\n+             * Ignore bitfields of zero width.\n+             *\n+             * struct Foo {\n+             *     int i:0;\n+             * }\n+             *\n+             * And bitfields without a name.\n+             * (padding is computed automatically)\n+             *\/\n+            if (fc.isBitField() && (fc.getBitFieldWidth() == 0 || fc.spelling().isEmpty())) {\n+                startBitfield();\n+                continue;\n+            }\n+\n+            processField(fc);\n+        }\n+\n+        return finishLayout();\n+    }\n+\n+    abstract void startBitfield();\n+    abstract void processField(Cursor c);\n+    abstract MemoryLayout finishLayout();\n+\n+    void addFieldLayout(MemoryLayout MemoryLayout) {\n+        fieldLayouts.add(MemoryLayout);\n+    }\n+\n+    void addFieldLayout(long offset, Type parent, Cursor c) {\n+        MemoryLayout memoryLayout = c.isAnonymousStruct()\n+            ? compute(offset, parent, c.type())\n+                .withName(nextAnonymousName())\n+                .withAttribute(JEXTRACT_ANONYMOUS, true)\n+            : fieldLayout(c);\n+        addFieldLayout(memoryLayout);\n+    }\n+\n+    private String nextAnonymousName() {\n+        return \"$anon$\" + anonCount++;\n+    }\n+\n+    MemoryLayout fieldLayout(Cursor c) {\n+        MemoryLayout l = LayoutUtils.getLayout(c.type());\n+        String name = LayoutUtils.getName(c);\n+        if (c.isBitField()) {\n+            MemoryLayout sublayout = MemoryLayout.valueLayout(c.getBitFieldWidth(), ByteOrder.nativeOrder());\n+            return sublayout.withName(name);\n+        } else {\n+            return l.withName(name);\n+        }\n+    }\n+\n+    long fieldSize(Cursor c) {\n+        if (c.type().kind() == TypeKind.IncompleteArray) {\n+            return 0;\n+        }\n+        return c.isBitField() ? c.getBitFieldWidth() : c.type().size() * 8;\n+    }\n+\n+    MemoryLayout bitfield(List<MemoryLayout> sublayouts) {\n+        return LayoutUtils.setBitfields(MemoryLayout.structLayout(sublayouts.toArray(new MemoryLayout[0])));\n+    }\n+\n+    long offsetOf(Type parent, Cursor c) {\n+        if (c.kind() == CursorKind.FieldDecl) {\n+            return parent.getOffsetOf(c.spelling());\n+        } else {\n+            return Utils.flattenableChildren(c)\n+                    .mapToLong(child -> offsetOf(parent, child))\n+                    .findFirst()\n+                    .orElseThrow(() -> new IllegalStateException(\n+                            \"Can not find offset of: \" + c + \", in: \" + parent));\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/RecordLayoutComputer.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,363 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.List;\n+\n+import static jdk.internal.jextract.impl.LayoutUtils.JEXTRACT_ANONYMOUS;\n+\n+\/**\n+ * This class generates static utilities class for C structs, unions.\n+ *\/\n+class StructBuilder extends ConstantBuilder {\n+\n+    private static final String MEMBER_MODS = \"public static\";\n+\n+    private final GroupLayout structLayout;\n+    private final Type structType;\n+    private final Deque<String> prefixElementNames;\n+\n+    StructBuilder(JavaSourceBuilder enclosing, String name, GroupLayout structLayout, Type structType) {\n+        super(enclosing, name);\n+        this.structLayout = structLayout;\n+        this.structType = structType;\n+        prefixElementNames = new ArrayDeque<>();\n+    }\n+\n+    private String safeParameterName(String paramName) {\n+        return isEnclosedBySameName(paramName)? paramName + \"$\" : paramName;\n+    }\n+\n+    void pushPrefixElement(String prefixElementName) {\n+        prefixElementNames.push(prefixElementName);\n+    }\n+\n+    void popPrefixElement() {\n+        prefixElementNames.pop();\n+    }\n+\n+    private List<String> prefixNamesList() {\n+        List<String> prefixes = new ArrayList<>(prefixElementNames);\n+        Collections.reverse(prefixes);\n+        return Collections.unmodifiableList(prefixes);\n+    }\n+\n+    @Override\n+    void classBegin() {\n+        if (!inAnonymousNested()) {\n+            super.classBegin();\n+            addLayout(layoutField(), ((Type.Declared) structType).tree().layout().get())\n+                    .emitGetter(this, MEMBER_MODS, Constant.SUFFIX_ONLY);\n+        }\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        if (!inAnonymousNested()) {\n+            emitSizeof();\n+            emitAllocatorAllocate();\n+            emitScopeAllocate();\n+            emitAllocatorAllocateArray();\n+            emitScopeAllocateArray();\n+            emitOfAddressScoped();\n+            return super.classEnd();\n+        } else {\n+            \/\/ we're in an anonymous struct which got merged into this one, return this very builder and keep it open\n+            popPrefixElement();\n+            return this;\n+        }\n+    }\n+\n+    boolean inAnonymousNested() {\n+        return !prefixElementNames.isEmpty();\n+    }\n+\n+    @Override\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        if (name.isEmpty() && (parent instanceof Declaration.Scoped)) {\n+            \/\/nested anon struct - merge into this builder!\n+            GroupLayout parentLayout = (GroupLayout)((Declaration.Scoped)parent).layout().get();\n+            String anonName = findAnonymousStructName(parentLayout, layout);\n+            pushPrefixElement(anonName);\n+            return this;\n+        } else {\n+            return new StructBuilder(this, name.isEmpty() ? parent.name() : name, layout, type);\n+        }\n+    }\n+\n+    @Override\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this, name, functionInfo.methodType(), functionInfo.descriptor());\n+        builder.classBegin();\n+        builder.classEnd();\n+        return builder.className();\n+    }\n+\n+    private String findAnonymousStructName(GroupLayout parentLayout, GroupLayout layout) {\n+        \/\/ nested anonymous struct or union\n+        for (MemoryLayout ml : parentLayout.memberLayouts()) {\n+            \/\/ look for anonymous structs\n+            if (ml.attribute(JEXTRACT_ANONYMOUS).isPresent()) {\n+                \/\/ it's enough to just compare the member layouts, since the member names\n+                \/\/ have to be unique within the parent layout (in C)\n+                if (((GroupLayout) ml).memberLayouts().equals(layout.memberLayouts())) {\n+                    return ml.name().orElseThrow();\n+                }\n+            }\n+        }\n+        throw new IllegalStateException(\"Could not find layout in parent\");\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        try {\n+            structLayout.byteOffset(elementPaths(nativeName));\n+        } catch (UnsupportedOperationException uoe) {\n+            \/\/ bad layout - do nothing\n+            OutputFactory.warn(\"skipping '\" + className() + \".\" + nativeName + \"' : \" + uoe.toString());\n+            return;\n+        }\n+        if (varInfo.carrier().equals(MemorySegment.class)) {\n+            emitSegmentGetter(javaName, nativeName, varInfo.layout());\n+        } else {\n+            Constant vhConstant = addFieldVarHandle(javaName, nativeName, varInfo, layoutField(), prefixNamesList())\n+                    .emitGetter(this, MEMBER_MODS, Constant.QUALIFIED_NAME);\n+            emitFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldGetter(vhConstant, javaName, varInfo.carrier());\n+            emitIndexedFieldSetter(vhConstant, javaName, varInfo.carrier());\n+            if (varInfo.fiName().isPresent()) {\n+                emitFunctionalInterfaceGetter(varInfo.fiName().get(), javaName);\n+            }\n+        }\n+    }\n+\n+    private void emitFunctionalInterfaceGetter(String fiName, String javaName) {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS + \" \");\n+        append(fiName + \" \" + javaName + \" (MemorySegment segment) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + fiName + \".ofAddress(\" + javaName + \"$get(segment));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String seg = safeParameterName(\"seg\");\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(MemorySegment \" + seg + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \")\"\n+                + vhConstant.accessExpression() + \".get(\" + seg + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String seg = safeParameterName(\"seg\");\n+        String x = safeParameterName(\"x\");\n+        String param = MemorySegment.class.getSimpleName() + \" \" + seg;\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set( \" + param + \", \" + type.getSimpleName() + \" \" + x + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression() + \".set(\" + seg + \", \" + x + \");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private MemoryLayout.PathElement[] elementPaths(String nativeFieldName) {\n+        List<String> prefixElements = prefixNamesList();\n+        MemoryLayout.PathElement[] elems = new MemoryLayout.PathElement[prefixElements.size() + 1];\n+        int i = 0;\n+        for (; i < prefixElements.size(); i++) {\n+            elems[i] = MemoryLayout.PathElement.groupElement(prefixElements.get(i));\n+        }\n+        elems[i] = MemoryLayout.PathElement.groupElement(nativeFieldName);\n+        return elems;\n+    }\n+\n+    private void emitSegmentGetter(String javaName, String nativeName, MemoryLayout layout) {\n+        incrAlign();\n+        indent();\n+        String seg = safeParameterName(\"seg\");\n+        append(MEMBER_MODS + \" MemorySegment \" + javaName + \"$slice(MemorySegment \" + seg + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return \" + seg + \".asSlice(\");\n+        append(structLayout.byteOffset(elementPaths(nativeName)));\n+        append(\", \");\n+        append(layout.byteSize());\n+        append(\");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitSizeof() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" long sizeof() { return $LAYOUT().byteSize(); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitScopeAllocate() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocate(ResourceScope scope) { return allocate(SegmentAllocator.ofScope(scope)); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAllocatorAllocate() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocate(SegmentAllocator allocator) { return allocator.allocate($LAYOUT()); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitScopeAllocateArray() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocateArray(int len, ResourceScope scope) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return allocateArray(len, SegmentAllocator.ofScope(scope));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitAllocatorAllocateArray() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment allocateArray(int len, SegmentAllocator allocator) {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return allocator.allocate(MemoryLayout.sequenceLayout(len, $LAYOUT()));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitOfAddressScoped() {\n+        incrAlign();\n+        indent();\n+        append(MEMBER_MODS);\n+        append(\" MemorySegment ofAddress(MemoryAddress addr, ResourceScope scope) { return RuntimeHelper.asArray(addr, $LAYOUT(), 1, scope); }\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitIndexedFieldGetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String index = safeParameterName(\"index\");\n+        String seg = safeParameterName(\"seg\");\n+        String params = MemorySegment.class.getSimpleName() + \" \" + seg + \", long \" + index;\n+        append(MEMBER_MODS + \" \" + type.getSimpleName() + \" \" + javaName + \"$get(\" + params + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(\"return (\" + type.getName() + \")\");\n+        append(vhConstant.accessExpression());\n+        append(\".get(\");\n+        append(seg);\n+        append(\".asSlice(\");\n+        append(index);\n+        append(\"*sizeof()));\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private void emitIndexedFieldSetter(Constant vhConstant, String javaName, Class<?> type) {\n+        incrAlign();\n+        indent();\n+        String index = safeParameterName(\"index\");\n+        String seg = safeParameterName(\"seg\");\n+        String x = safeParameterName(\"x\");\n+        String params = MemorySegment.class.getSimpleName() + \" \" + seg +\n+            \", long \" + index + \", \" + type.getSimpleName() + \" \" + x;\n+        append(MEMBER_MODS + \" void \" + javaName + \"$set(\" + params + \") {\\n\");\n+        incrAlign();\n+        indent();\n+        append(vhConstant.accessExpression());\n+        append(\".set(\");\n+        append(seg);\n+        append(\".asSlice(\");\n+        append(index);\n+        append(\"*sizeof()), \");\n+        append(x);\n+        append(\");\\n\");\n+        decrAlign();\n+        indent();\n+        append(\"}\\n\");\n+        decrAlign();\n+    }\n+\n+    private String qualifiedName(ClassSourceBuilder builder) {\n+        if (builder.isNested()) {\n+            String prefix = qualifiedName((ClassSourceBuilder)builder.enclosing);\n+            return prefix.isEmpty() ?\n+                    builder.className() :\n+                    prefix + \"$\" + builder.className();\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    private String layoutField() {\n+        String suffix = structLayout.isUnion() ? \"union\" : \"struct\";\n+        return qualifiedName(this) + \"$\" + suffix;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructBuilder.java","additions":363,"deletions":0,"binary":false,"changes":363,"status":"added"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.Type;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * MemoryLayout computer for C structs.\n+ *\/\n+final class StructLayoutComputer extends RecordLayoutComputer {\n+    private long offset;\n+    private long actualSize = 0L;\n+    \/\/ List to collect bitfield fields to process later, may be null\n+    private List<MemoryLayout> bitfieldLayouts;\n+\n+    StructLayoutComputer(long offsetInParent, Type parent, Type type) {\n+        super(parent, type);\n+        this.offset = offsetInParent;\n+    }\n+\n+    @Override\n+    void addFieldLayout(MemoryLayout MemoryLayout) {\n+        if (bitfieldLayouts != null) {\n+            bitfieldLayouts.add(MemoryLayout);\n+        } else {\n+            fieldLayouts.add(MemoryLayout);\n+        }\n+    }\n+\n+    @Override\n+    void startBitfield() {\n+        \/*\n+         * In a struct, a bitfield field is seen after a non-bitfield.\n+         * Initialize bitfieldLayouts list to collect this and subsequent\n+         * bitfield layouts.\n+         *\/\n+        if (bitfieldLayouts == null) {\n+            bitfieldLayouts = new ArrayList<>();\n+        }\n+    }\n+\n+    @Override\n+    void processField(Cursor c) {\n+        boolean isBitfield = c.isBitField();\n+        long expectedOffset = offsetOf(parent, c);\n+        if (expectedOffset > offset) {\n+            addFieldLayout(MemoryLayout.paddingLayout(expectedOffset - offset));\n+            actualSize += (expectedOffset - offset);\n+            offset = expectedOffset;\n+        }\n+\n+        if (isBitfield) {\n+            startBitfield();\n+        } else { \/\/ !isBitfield\n+            \/*\n+             * We may be crossing from bit fields to non-bitfield field.\n+             *\n+             * struct Foo {\n+             *     int i:12;\n+             *     int j:20;\n+             *     int k; \/\/ <-- processing this\n+             *     int m;\n+             * }\n+             *\/\n+            handleBitfields();\n+        }\n+\n+        addFieldLayout(offset, parent, c);\n+        long size = fieldSize(c);\n+        offset += size;\n+        actualSize += size;\n+    }\n+\n+    @Override\n+    MemoryLayout finishLayout() {\n+        \/\/ pad at the end, if any\n+        long expectedSize = type.size() * 8;\n+        if (actualSize < expectedSize) {\n+            addFieldLayout(MemoryLayout.paddingLayout(expectedSize - actualSize));\n+        }\n+\n+        \/*\n+         * Handle bitfields at the end, if any.\n+         *\n+         * struct Foo {\n+         *     int i,j, k;\n+         *     int f:10;\n+         *     int pad:12;\n+         * }\n+         *\/\n+        handleBitfields();\n+\n+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n+        GroupLayout g = MemoryLayout.structLayout(fields);\n+        String name = LayoutUtils.getName(cursor);\n+        return name.isEmpty() ?\n+                g : g.withName(name);\n+    }\n+\n+    \/\/ process bitfields if any and clear bitfield layouts\n+    private void handleBitfields() {\n+        if (bitfieldLayouts != null) {\n+            fieldLayouts.add(bitfield(bitfieldLayouts));\n+            bitfieldLayouts = null;\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/StructLayoutComputer.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.File;\n+import java.lang.constant.ClassDesc;\n+import java.util.*;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+\/**\n+ * A helper class to generate header interface class in source form.\n+ * After aggregating various constituents of a .java source, build\n+ * method is called to get overall generated source string.\n+ *\/\n+class ToplevelBuilder extends JavaSourceBuilder {\n+\n+    private int declCount;\n+    private final List<JavaSourceBuilder> builders = new ArrayList<>();\n+    private SplitHeader lastHeader;\n+    private int headersCount;\n+    private final ClassDesc headerDesc;\n+    private final String[] libraryNames;\n+\n+    static final int DECLS_PER_HEADER_CLASS = Integer.getInteger(\"jextract.decls.per.header\", 1000);\n+\n+    ToplevelBuilder(String packageName, String headerClassName, String[] libraryNames) {\n+        this.libraryNames = libraryNames;\n+        this.headerDesc = ClassDesc.of(packageName, headerClassName);\n+        SplitHeader first = lastHeader = new FirstHeader(headerClassName);\n+        first.classBegin();\n+        builders.add(first);\n+    }\n+\n+    public List<JavaFileObject> toFiles() {\n+        if (constantBuilder != null) {\n+            constantBuilder.classEnd();\n+        }\n+        lastHeader.classEnd();\n+        builders.addAll(constantBuilders);\n+        List<JavaFileObject> files = new ArrayList<>();\n+        files.addAll(builders.stream()\n+                .flatMap(b -> b.toFiles().stream())\n+                .collect(Collectors.toList()));\n+        return files;\n+    }\n+\n+    public String headerClassName() {\n+        return headerDesc.displayName();\n+    }\n+\n+    @Override\n+    boolean isEnclosedBySameName(String name) {\n+        return false;\n+    }\n+\n+    @Override\n+    public String packageName() {\n+        return headerDesc.packageName();\n+    }\n+\n+    @Override\n+    public void addVar(String javaName, String nativeName, VarInfo varInfo) {\n+        nextHeader().addVar(javaName, nativeName, varInfo);\n+    }\n+\n+    @Override\n+    public void addFunction(String javaName, String nativeName, FunctionInfo functionInfo) {\n+        nextHeader().addFunction(javaName, nativeName, functionInfo);\n+    }\n+\n+    @Override\n+    public void addConstant(String javaName, Class<?> type, Object value) {\n+        nextHeader().addConstant(javaName, type, value);\n+    }\n+\n+    @Override\n+    public void addTypedef(String name, String superClass, Type type) {\n+        if (type instanceof Type.Primitive) {\n+            \/\/ primitive\n+            nextHeader().emitPrimitiveTypedef((Type.Primitive)type, name);\n+        } else {\n+            TypedefBuilder builder = new TypedefBuilder(this, name, superClass);\n+            builders.add(builder);\n+            builder.classBegin();\n+            builder.classEnd();\n+        }\n+    }\n+\n+    @Override\n+    public StructBuilder addStruct(String name, Declaration parent, GroupLayout layout, Type type) {\n+        String structName = name.isEmpty() ? parent.name() : name;\n+        StructBuilder structBuilder = new StructBuilder(this, structName, layout, type);\n+        builders.add(structBuilder);\n+        return structBuilder;\n+    }\n+\n+    @Override\n+    public String addFunctionalInterface(String name, FunctionInfo functionInfo) {\n+        FunctionalInterfaceBuilder builder = new FunctionalInterfaceBuilder(this,\n+                name, functionInfo.methodType(), functionInfo.descriptor());\n+        builders.add(builder);\n+        builder.classBegin();\n+        builder.classEnd();\n+        return builder.className();\n+    }\n+\n+    private SplitHeader nextHeader() {\n+        if (declCount == DECLS_PER_HEADER_CLASS) {\n+            boolean hasSuper = !(lastHeader instanceof FirstHeader);\n+            SplitHeader headerFileBuilder = new SplitHeader(headerDesc.displayName() + \"_\" + ++headersCount,\n+                    hasSuper ? lastHeader.className() : null);\n+            lastHeader.classEnd();\n+            headerFileBuilder.classBegin();\n+            builders.add(headerFileBuilder);\n+            lastHeader = headerFileBuilder;\n+            declCount = 1;\n+            return headerFileBuilder;\n+        } else {\n+            declCount++;\n+            return lastHeader;\n+        }\n+    }\n+\n+    class SplitHeader extends HeaderFileBuilder {\n+        SplitHeader(String name, String superclass) {\n+            super(ToplevelBuilder.this, name, superclass);\n+        }\n+\n+        @Override\n+        String mods() {\n+            return \" \";\n+        }\n+    }\n+\n+    class FirstHeader extends SplitHeader {\n+\n+        FirstHeader(String name) {\n+            super(name, \"#{SUPER}\");\n+        }\n+\n+        @Override\n+        String mods() {\n+            return \"public \";\n+        }\n+\n+        @Override\n+        void classBegin() {\n+            super.classBegin();\n+            emitLibraries(libraryNames);\n+            emitConstructor();\n+        }\n+\n+        void emitConstructor() {\n+            incrAlign();\n+            indent();\n+            append(\"\/* package-private *\/ \");\n+            append(className());\n+            append(\"() {}\");\n+            append('\\n');\n+            decrAlign();\n+        }\n+\n+        @Override\n+        String build() {\n+            HeaderFileBuilder last = lastHeader;\n+            return super.build().replace(\"extends #{SUPER}\",\n+                    last != this ? \"extends \" + last.className() : \"\");\n+        }\n+\n+        private void emitLibraries(String[] libraryNames) {\n+            incrAlign();\n+            indent();\n+            append(\"static {\\n\");\n+            incrAlign();\n+            for (String lib : libraryNames) {\n+                String quotedLibName = quoteLibraryName(lib);\n+                indent();\n+                if (quotedLibName.indexOf(File.separatorChar) != -1) {\n+                    append(\"System.load(\\\"\" + quotedLibName + \"\\\");\");\n+                } else {\n+                    append(\"System.loadLibrary(\\\"\" + quotedLibName + \"\\\");\");\n+                }\n+                append(\"\\n\");\n+            }\n+            decrAlign();\n+            indent();\n+            append(\"}\\n\\n\");\n+            indent();\n+            append(\"static final \");\n+            append(\"SymbolLookup LIBRARIES = RuntimeHelper.lookup();\");\n+            decrAlign();\n+        }\n+\n+        private String quoteLibraryName(String lib) {\n+            return lib.replace(\"\\\\\", \"\\\\\\\\\"); \/\/ double up slashes\n+        }\n+    }\n+\n+    \/\/ constant support\n+\n+    int constant_counter = 0;\n+    int constant_class_index = 0;\n+    List<ConstantBuilder> constantBuilders = new ArrayList<>();\n+\n+    static final int CONSTANTS_PER_CLASS = Integer.getInteger(\"jextract.constants.per.class\", 5);\n+    ConstantBuilder constantBuilder;\n+\n+    protected void emitWithConstantClass(Consumer<ConstantBuilder> constantConsumer) {\n+        if (constant_counter > CONSTANTS_PER_CLASS || constantBuilder == null) {\n+            if (constantBuilder != null) {\n+                constantBuilder.classEnd();\n+            }\n+            constant_counter = 0;\n+            constantBuilder = new ConstantBuilder(this, \"constants$\" + constant_class_index++) {\n+                @Override\n+                String mods() {\n+                    return \"\"; \/\/ constants package-private!\n+                }\n+            };\n+            constantBuilders.add(constantBuilder);\n+            constantBuilder.classBegin();\n+        }\n+        constantConsumer.accept(constantBuilder);\n+        constant_counter++;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/ToplevelBuilder.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import java.lang.constant.Constable;\n+import java.nio.ByteOrder;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Position;\n+import jdk.incubator.jextract.Type;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.CursorLanguage;\n+import jdk.internal.clang.SourceLocation;\n+\n+class TreeMaker {\n+    public TreeMaker() {}\n+\n+    TypeMaker typeMaker = new TypeMaker(this);\n+\n+    public void freeze() {\n+        typeMaker.resolveTypeReferences();\n+    }\n+\n+    interface ScopedFactoryLayout {\n+        Declaration.Scoped make(Position pos, String name, MemoryLayout layout, Declaration... decls);\n+    }\n+\n+    interface ScopedFactoryNoLayout {\n+        Declaration.Scoped make(Position pos, String name, Declaration... decls);\n+    }\n+\n+    interface VarFactoryNoLayout {\n+        Declaration.Variable make(Position pos, String name, Type type);\n+    }\n+\n+    Map<String, List<Constable>> collectAttributes(Cursor c) {\n+        return c.children().filter(Cursor::isAttribute)\n+                .collect(Collectors.groupingBy(\n+                        attr -> attr.kind().name(),\n+                        Collectors.mapping(Cursor::spelling, Collectors.toList())\n+                ));\n+    }\n+\n+    public Declaration createTree(Cursor c) {\n+        Objects.requireNonNull(c);\n+        CursorLanguage lang = c.language();\n+        if (lang != CursorLanguage.C && lang != CursorLanguage.Invalid) {\n+            throw new RuntimeException(\"Unsupported language: \" + c.language());\n+        }\n+        var rv = (DeclarationImpl) createTreeInternal(c);\n+        return (rv == null) ? null : rv.withAttributes(collectAttributes(c));\n+    }\n+\n+    private Declaration createTreeInternal(Cursor c) {\n+        switch (c.kind()) {\n+            case EnumDecl:\n+                return createScoped(c, Declaration.Scoped.Kind.ENUM, Declaration::enum_, Declaration::enum_);\n+            case EnumConstantDecl:\n+                return createEnumConstant(c);\n+            case FieldDecl:\n+                return createVar(c.isBitField() ?\n+                        Declaration.Variable.Kind.BITFIELD : Declaration.Variable.Kind.FIELD, c, Declaration::field);\n+            case ParmDecl:\n+                return createVar(Declaration.Variable.Kind.PARAMETER, c, Declaration::parameter);\n+            case FunctionDecl:\n+                return createFunction(c);\n+            case StructDecl:\n+                return createScoped(c, Declaration.Scoped.Kind.STRUCT, Declaration::struct, Declaration::struct);\n+            case UnionDecl:\n+                return createScoped(c, Declaration.Scoped.Kind.UNION, Declaration::union, Declaration::union);\n+            case TypedefDecl: {\n+                return createTypedef(c);\n+            }\n+            case VarDecl:\n+                return createVar(Declaration.Variable.Kind.GLOBAL, c, Declaration::globalVariable);\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    Position toPos(Cursor cursor) {\n+        SourceLocation loc = cursor.getSourceLocation();\n+        if (loc == null) {\n+            return Position.NO_POSITION;\n+        }\n+        SourceLocation.Location sloc = loc.getFileLocation();\n+        if (sloc == null) {\n+            return Position.NO_POSITION;\n+        }\n+        return new CursorPosition(cursor);\n+    }\n+\n+    static class CursorPosition implements Position {\n+        private final Cursor cursor;\n+        private final Path path;\n+        private final int line;\n+        private final int column;\n+\n+        CursorPosition(Cursor cursor) {\n+            this.cursor = cursor;\n+            SourceLocation.Location loc = cursor.getSourceLocation().getFileLocation();\n+            this.path = loc.path();\n+            this.line = loc.line();\n+            this.column = loc.column();\n+        }\n+\n+        @Override\n+        public Path path() {\n+            return path;\n+        }\n+\n+        @Override\n+        public int line() {\n+            return line;\n+        }\n+\n+        @Override\n+        public int col() {\n+            return column;\n+        }\n+\n+        public Cursor cursor() {\n+            return cursor;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return PrettyPrinter.position(this);\n+        }\n+    }\n+\n+    public Declaration.Function createFunction(Cursor c) {\n+        checkCursor(c, CursorKind.FunctionDecl);\n+        List<Declaration.Variable> params = new ArrayList<>();\n+        for (int i = 0 ; i < c.numberOfArgs() ; i++) {\n+            params.add((Declaration.Variable)createTree(c.getArgument(i)));\n+        }\n+        Type type = toType(c);\n+        Type funcType = type instanceof Type.Delegated? ((Type.Delegated)type).type() : type;\n+        return Declaration.function(toPos(c), c.spelling(), (Type.Function)funcType,\n+                params.toArray(new Declaration.Variable[0]));\n+    }\n+\n+    public Declaration.Constant createMacro(Cursor c, String name, Type type, Object value) {\n+        checkCursorAny(c, CursorKind.MacroDefinition);\n+        return Declaration.constant(toPos(c), name, value, type);\n+    }\n+\n+    public Declaration.Constant createEnumConstant(Cursor c) {\n+        return Declaration.constant(toPos(c), c.spelling(), c.getEnumConstantValue(), typeMaker.makeType(c.type()));\n+    }\n+\n+    public Declaration.Scoped createHeader(Cursor c, List<Declaration> decls) {\n+        return Declaration.toplevel(toPos(c), filterNestedDeclarations(decls).toArray(new Declaration[0]));\n+    }\n+\n+    public Declaration.Scoped createScoped(Cursor c, Declaration.Scoped.Kind scopeKind, ScopedFactoryLayout factoryLayout, ScopedFactoryNoLayout factoryNoLayout) {\n+        List<Declaration> decls = filterNestedDeclarations(c.children()\n+                .filter(fc -> {\n+                    if (fc.isBitField()) {\n+                        \/\/ only non-empty and named bit fields are generated\n+                        return fc.getBitFieldWidth() != 0 && !fc.spelling().isEmpty();\n+                    }\n+                    return true;\n+                })\n+                .map(this::createTree).collect(Collectors.toList()));\n+        if (c.isDefinition()) {\n+            \/\/just a declaration AND definition, we have a layout\n+            MemoryLayout layout = null;\n+            try {\n+                layout = LayoutUtils.getLayout(c.type());\n+            } catch (TypeMaker.TypeException ex) {\n+                System.err.println(ex);\n+                System.err.println(\"WARNING: generating empty struct: \" + c.spelling());\n+                return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n+            }\n+            List<Declaration> adaptedDecls = layout instanceof GroupLayout ?\n+                    collectBitfields(layout, decls) :\n+                    decls;\n+            return factoryLayout.make(toPos(c), c.spelling(), layout, adaptedDecls.toArray(new Declaration[0]));\n+        } else {\n+            \/\/just a declaration\n+            if (scopeKind == Declaration.Scoped.Kind.STRUCT ||\n+                    scopeKind == Declaration.Scoped.Kind.UNION ||\n+                    scopeKind == Declaration.Scoped.Kind.ENUM ||\n+                    scopeKind == Declaration.Scoped.Kind.CLASS) {\n+                \/\/if there's a real definition somewhere else, skip this redundant declaration\n+                if (!c.getDefinition().isInvalid()) {\n+                    return null;\n+                }\n+            }\n+            return factoryNoLayout.make(toPos(c), c.spelling(), decls.toArray(new Declaration[0]));\n+        }\n+    }\n+\n+    private static boolean isEnum(Declaration d) {\n+        return d instanceof Declaration.Scoped && ((Declaration.Scoped)d).kind() == Declaration.Scoped.Kind.ENUM;\n+    }\n+\n+    private static boolean isAnonymousStruct(Declaration declaration) {\n+        return ((CursorPosition)declaration.pos()).cursor.isAnonymousStruct();\n+    }\n+\n+    private List<Declaration> filterNestedDeclarations(List<Declaration> declarations) {\n+        return declarations.stream()\n+                .filter(Objects::nonNull)\n+                .filter(d -> isEnum(d) || !d.name().isEmpty() || isAnonymousStruct(d))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Declaration.Typedef createTypedef(Cursor c) {\n+        Type cursorType = toType(c);\n+        Type canonicalType = cursorType instanceof Type.Function\n+            ? cursorType\n+            : ((Type.Delegated) cursorType).type(); \/\/ normal typedef\n+        if (canonicalType instanceof Type.Declared) {\n+            Declaration.Scoped s = ((Type.Declared) canonicalType).tree();\n+            if (s.name().equals(c.spelling())) {\n+                \/\/ typedef record with the same name, no need to present twice\n+                return null;\n+            }\n+        }\n+        return Declaration.typedef(toPos(c), c.spelling(), canonicalType);\n+    }\n+\n+    private Declaration.Variable createVar(Declaration.Variable.Kind kind, Cursor c, VarFactoryNoLayout varFactory) {\n+        checkCursorAny(c, CursorKind.VarDecl, CursorKind.FieldDecl, CursorKind.ParmDecl);\n+        if (c.isBitField()) {\n+            return Declaration.bitfield(toPos(c), c.spelling(), toType(c),\n+                    MemoryLayout.valueLayout(c.getBitFieldWidth(), ByteOrder.nativeOrder()));\n+        } else {\n+            Type type = null;\n+            try {\n+                type = toType(c);\n+            } catch (TypeMaker.TypeException ex) {\n+                System.err.println(ex);\n+                System.err.println(\"WARNING: ignoring variable: \" + c.spelling());\n+                return null;\n+            }\n+            return varFactory.make(toPos(c), c.spelling(), type);\n+        }\n+    }\n+\n+    private static void collectNestedBitFields(Set<Declaration> out, Declaration.Scoped anonymousStruct) {\n+        for  (Declaration field : anonymousStruct.members()) {\n+            if (isAnonymousStruct(field)) {\n+                collectNestedBitFields(out, (Declaration.Scoped) field);\n+            } else if (field instanceof Declaration.Scoped\n+                       && ((Declaration.Scoped) field).kind() == Declaration.Scoped.Kind.BITFIELDS) {\n+                out.addAll(((Declaration.Scoped) field).members());\n+            }\n+        }\n+    }\n+\n+    private static Set<Declaration> nestedBitFields(List<Declaration> members) {\n+        Set<Declaration> res = new HashSet<>();\n+        for (Declaration member : members) {\n+            if (isAnonymousStruct(member)) {\n+                collectNestedBitFields(res, (Declaration.Scoped) member);\n+            }\n+        }\n+        return res;\n+    }\n+\n+    private List<Declaration> collectBitfields(MemoryLayout layout, List<Declaration> declarations) {\n+        Set<String> nestedBitfieldNames = nestedBitFields(declarations).stream()\n+                                                                       .map(Declaration::name)\n+                                                                       .collect(Collectors.toSet());\n+        List<Declaration> newDecls = new ArrayList<>();\n+        for (MemoryLayout e : ((GroupLayout)layout).memberLayouts()) {\n+            if (e instanceof GroupLayout contents && LayoutUtils.isBitfields(contents)) {\n+                List<Declaration.Variable> bfDecls = new ArrayList<>();\n+                outer: for (MemoryLayout bitfield : contents.memberLayouts()) {\n+                    if (bitfield.name().isPresent() && !nestedBitfieldNames.contains(bitfield.name().get())) {\n+                        Iterator<Declaration> declIt = declarations.iterator();\n+                        while (declIt.hasNext()) {\n+                            Declaration d = declIt.next();\n+                            if (d.name().equals(bitfield.name().get())) {\n+                                bfDecls.add((Declaration.Variable)d);\n+                                declIt.remove();\n+                                continue outer;\n+                            }\n+                        }\n+                        throw new IllegalStateException(\"No matching declaration found for bitfield: \" + bitfield);\n+                    }\n+                }\n+                if (!bfDecls.isEmpty()) {\n+                    newDecls.add(Declaration.bitfields(bfDecls.get(0).pos(), \"\", contents, bfDecls.toArray(new Declaration.Variable[0])));\n+                }\n+            }\n+        }\n+        newDecls.addAll(declarations);\n+        return newDecls;\n+    }\n+\n+    private Type toType(Cursor c) {\n+        return typeMaker.makeType(c.type());\n+    }\n+\n+    private void checkCursor(Cursor c, CursorKind k) {\n+        if (c.kind() != k) {\n+            throw new IllegalArgumentException(\"Invalid cursor kind\");\n+        }\n+    }\n+\n+    private void checkCursorAny(Cursor c, CursorKind... kinds) {\n+        CursorKind expected = Objects.requireNonNull(c.kind());\n+        for (CursorKind k : kinds) {\n+            if (k == expected) {\n+                return;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid cursor kind\");\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TreeMaker.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -0,0 +1,343 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.OptionalLong;\n+import java.util.function.Supplier;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+public abstract class TypeImpl implements Type {\n+\n+    @Override\n+    public boolean isErroneous() {\n+        return false;\n+    }\n+\n+    static boolean equals(Type t1, Type.Delegated t2) {\n+        assert t1 != null;\n+        assert t2 != null;\n+\n+        return (t2.kind() == Delegated.Kind.TYPEDEF) && t1.equals(t2.type());\n+    }\n+\n+    public static final TypeImpl ERROR = new TypeImpl() {\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitType(this, data);\n+        }\n+\n+        @Override\n+        public boolean isErroneous() {\n+            return true;\n+        }\n+    };\n+\n+    public static final class PrimitiveImpl extends TypeImpl implements Type.Primitive {\n+\n+        private final Primitive.Kind kind;\n+\n+        public PrimitiveImpl(Kind kind) {\n+            this.kind = Objects.requireNonNull(kind);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitPrimitive(this, data);\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Primitive)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated)o);\n+            }\n+            Type.Primitive primitive = (Type.Primitive) o;\n+            return kind == primitive.kind();\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind);\n+        }\n+    }\n+\n+    static abstract class DelegatedBase extends TypeImpl implements Type.Delegated {\n+        Delegated.Kind kind;\n+        Optional<String> name;\n+\n+        DelegatedBase(Kind kind, Optional<String> name) {\n+            this.kind = Objects.requireNonNull(kind);\n+            this.name = Objects.requireNonNull(name);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitDelegated(this, data);\n+        }\n+\n+        @Override\n+        public final Delegated.Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public final Optional<String> name() {\n+            return name;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Delegated)) {\n+                return (o instanceof Type) && equals((Type)o, this);\n+            }\n+            Type.Delegated that = (Type.Delegated) o;\n+            return kind == that.kind() &&\n+                    name.equals(that.name());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, name);\n+        }\n+    }\n+\n+    public static final class QualifiedImpl extends DelegatedBase {\n+        private final Type type;\n+\n+        public QualifiedImpl(Kind kind, Type type) {\n+            this(kind, Optional.empty(), type);\n+        }\n+\n+        public QualifiedImpl(Kind kind, String name, Type type) {\n+            this(kind, Optional.of(name), type);\n+        }\n+\n+        private QualifiedImpl(Kind kind, Optional<String> name, Type type) {\n+            super(kind, name);\n+            this.type = type;\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return type;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Delegated)) return false;\n+            if (!super.equals(o)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Delegated qualified = (Type.Delegated) o;\n+            return Objects.equals(type, qualified.type());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return (kind() == Kind.TYPEDEF)? type().hashCode() : Objects.hash(super.hashCode(), type);\n+        }\n+    }\n+\n+    public static final class PointerImpl extends DelegatedBase {\n+        private final Supplier<Type> pointeeFactory;\n+\n+        public PointerImpl(Supplier<Type> pointeeFactory) {\n+            super(Kind.POINTER, Optional.empty());\n+            this.pointeeFactory = Objects.requireNonNull(pointeeFactory);\n+        }\n+\n+        public PointerImpl(Type pointee) {\n+            this(() -> pointee);\n+        }\n+\n+        @Override\n+        public Type type() {\n+            return pointeeFactory.get();\n+        }\n+    }\n+\n+    public static final class DeclaredImpl extends TypeImpl implements Type.Declared {\n+\n+        private final Declaration.Scoped declaration;\n+\n+        public DeclaredImpl(Declaration.Scoped declaration) {\n+            super();\n+            this.declaration = Objects.requireNonNull(declaration);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitDeclared(this, data);\n+        }\n+\n+        @Override\n+        public Declaration.Scoped tree() {\n+            return declaration;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Declared)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Declared declared = (Type.Declared) o;\n+            return declaration.equals(declared.tree());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(declaration);\n+        }\n+    }\n+\n+    public static final class FunctionImpl extends TypeImpl implements Type.Function {\n+\n+        private final boolean varargs;\n+        private final List<Type> argtypes;\n+        private final Type restype;\n+\n+        public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype) {\n+            super();\n+            this.varargs = varargs;\n+            this.argtypes = Objects.requireNonNull(argtypes);\n+            this.restype = Objects.requireNonNull(restype);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitFunction(this, data);\n+        }\n+\n+        @Override\n+        public boolean varargs() {\n+            return varargs;\n+        }\n+\n+        @Override\n+        public List<Type> argumentTypes() {\n+            return argtypes;\n+        }\n+\n+        @Override\n+        public Type returnType() {\n+            return restype;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Function)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Function function = (Type.Function) o;\n+            return varargs == function.varargs() &&\n+                    argtypes.equals(function.argumentTypes()) &&\n+                    restype.equals(function.returnType());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(varargs, argtypes, restype);\n+        }\n+    }\n+\n+    public static final class ArrayImpl extends TypeImpl implements Type.Array {\n+\n+        private final Kind kind;\n+        private final OptionalLong elemCount;\n+        private final Type elemType;\n+\n+        public ArrayImpl(Kind kind, long count, Type elemType) {\n+            this(kind, elemType, OptionalLong.of(count));\n+        }\n+\n+        public ArrayImpl(Kind kind, Type elemType) {\n+            this(kind, elemType, OptionalLong.empty());\n+        }\n+\n+        private ArrayImpl(Kind kind, Type elemType, OptionalLong elemCount) {\n+            super();\n+            this.kind = Objects.requireNonNull(kind);\n+            this.elemCount = Objects.requireNonNull(elemCount);\n+            this.elemType = Objects.requireNonNull(elemType);\n+        }\n+\n+        @Override\n+        public <R, D> R accept(Visitor<R, D> visitor, D data) {\n+            return visitor.visitArray(this, data);\n+        }\n+\n+        @Override\n+        public OptionalLong elementCount() {\n+            return elemCount;\n+        }\n+\n+        @Override\n+        public Type elementType() {\n+            return elemType;\n+        }\n+\n+        @Override\n+        public Kind kind() {\n+            return kind;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Type.Array)) {\n+                return (o instanceof Delegated) && equals(this, (Delegated) o);\n+            }\n+            Type.Array array = (Type.Array) o;\n+            return kind == array.kind() &&\n+                    elemType.equals(array.elementType());\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(kind, elemType);\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return PrettyPrinter.type(this);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeImpl.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"added"},{"patch":"@@ -0,0 +1,257 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+\n+import java.util.ArrayList;\n+import java.util.ConcurrentModificationException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Supplier;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.jextract.Type.Delegated;\n+import jdk.incubator.jextract.Type.Primitive;\n+\n+class TypeMaker {\n+\n+    TreeMaker treeMaker;\n+    private final Map<jdk.internal.clang.Type, Type> typeCache = new HashMap<>();\n+    private List<ClangTypeReference> unresolved = new ArrayList<>();\n+\n+    private class ClangTypeReference implements Supplier<Type> {\n+        jdk.internal.clang.Type origin;\n+        Type derived;\n+\n+        private ClangTypeReference(jdk.internal.clang.Type origin) {\n+            this.origin = origin;\n+            derived = typeCache.get(origin);\n+        }\n+\n+        public boolean isUnresolved() {\n+            return null == derived;\n+        }\n+\n+        public void resolve() {\n+            derived = makeType(origin);\n+            Objects.requireNonNull(derived, \"Clang type cannot be resolved: \" + origin.spelling());\n+        }\n+\n+        public Type get() {\n+            Objects.requireNonNull(derived, \"Type is not yet resolved.\");\n+            return derived;\n+        }\n+    }\n+\n+    private ClangTypeReference reference(jdk.internal.clang.Type type) {\n+        ClangTypeReference ref = new ClangTypeReference(type);\n+        if (ref.isUnresolved()) {\n+            unresolved.add(ref);\n+        }\n+        return ref;\n+    }\n+\n+    public TypeMaker(TreeMaker treeMaker) {\n+        this.treeMaker = treeMaker;\n+    }\n+\n+    \/**\n+     * Resolve all type references. This method should be called before discard clang cursors\/types\n+     *\/\n+    void resolveTypeReferences() {\n+        List<ClangTypeReference> resolving = unresolved;\n+        unresolved = new ArrayList<>();\n+        while (! resolving.isEmpty()) {\n+            resolving.forEach(ClangTypeReference::resolve);\n+            resolving = unresolved;\n+            unresolved = new ArrayList<>();\n+        }\n+    }\n+\n+    Type makeType(jdk.internal.clang.Type t) {\n+        Type rv = typeCache.get(t);\n+        if (rv != null) {\n+            return rv;\n+        }\n+        rv = makeTypeInternal(t);\n+        if (null != rv && typeCache.put(t, rv) != null) {\n+            throw new ConcurrentModificationException();\n+        }\n+        return rv;\n+    }\n+\n+    static class TypeException extends RuntimeException {\n+        static final long serialVersionUID = 1L;\n+\n+        TypeException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    Type makeTypeInternal(jdk.internal.clang.Type t) {\n+        switch(t.kind()) {\n+            case Auto:\n+                return makeType(t.canonicalType());\n+            case Void:\n+                return Type.void_();\n+            case Char_S:\n+            case Char_U:\n+                return Type.primitive(Primitive.Kind.Char);\n+            case Short:\n+                return Type.primitive(Primitive.Kind.Short);\n+            case Int:\n+                return Type.primitive(Primitive.Kind.Int);\n+            case Long:\n+                return Type.primitive(Primitive.Kind.Long);\n+            case LongLong:\n+                return Type.primitive(Primitive.Kind.LongLong);\n+            case SChar: {\n+                Type chType = Type.primitive(Primitive.Kind.Char);\n+                return Type.qualified(Delegated.Kind.SIGNED, chType);\n+            }\n+            case UShort: {\n+                Type chType = Type.primitive(Primitive.Kind.Short);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case UInt: {\n+                Type chType = Type.primitive(Primitive.Kind.Int);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case ULong: {\n+                Type chType = Type.primitive(Primitive.Kind.Long);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case ULongLong: {\n+                Type chType = Type.primitive(Primitive.Kind.LongLong);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+            case UChar: {\n+                Type chType = Type.primitive(Primitive.Kind.Char);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, chType);\n+            }\n+\n+            case Bool:\n+                return Type.primitive(Primitive.Kind.Bool);\n+            case Double:\n+                return Type.primitive(Primitive.Kind.Double);\n+            case Float:\n+                return Type.primitive(Primitive.Kind.Float);\n+            case Unexposed:\n+            case Elaborated:\n+                jdk.internal.clang.Type canonical = t.canonicalType();\n+                if (canonical.equalType(t)) {\n+                    throw new TypeException(\"Unknown type with same canonical type: \" + t.spelling());\n+                }\n+                return makeType(canonical);\n+            case ConstantArray: {\n+                Type elem = makeType(t.getElementType());\n+                return Type.array(t.getNumberOfElements(), elem);\n+            }\n+            case IncompleteArray: {\n+                Type elem = makeType(t.getElementType());\n+                return Type.array(elem);\n+            }\n+            case FunctionProto:\n+            case FunctionNoProto: {\n+                List<Type> args = new ArrayList<>();\n+                for (int i = 0; i < t.numberOfArgs(); i++) {\n+                    \/\/ argument could be function pointer declared locally\n+                    args.add(lowerFunctionType(t.argType(i)));\n+                }\n+                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args.toArray(new Type[0]));\n+            }\n+            case Enum:\n+            case Record: {\n+                if (treeMaker == null) {\n+                    \/\/ Macro evaluation, type is meaningless as this can only be pointer and we only care value\n+                    return Type.void_();\n+                }\n+                return Type.declared((Declaration.Scoped) treeMaker.createTree(t.getDeclarationCursor()));\n+            }\n+            case BlockPointer:\n+            case Pointer: {\n+                \/\/ TODO: We can always erase type for macro evaluation, should we?\n+                return new TypeImpl.PointerImpl(reference(t.getPointeeType()));\n+            }\n+            case Typedef: {\n+                Type __type = makeType(t.canonicalType());\n+                return Type.typedef(t.spelling(), __type);\n+            }\n+            case Complex: {\n+                Type __type = makeType(t.getElementType());\n+                return Type.qualified(Delegated.Kind.COMPLEX, __type);\n+            }\n+            case Vector: {\n+                Type __type = makeType(t.getElementType());\n+                return Type.vector(t.getNumberOfElements(), __type);\n+            }\n+            case WChar: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.WChar);\n+            case Char16: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.Char16);\n+            case Half: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.HalfFloat);\n+            case Int128: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.Int128);\n+            case LongDouble: \/\/unsupported\n+                return Type.primitive(Primitive.Kind.LongDouble);\n+            case UInt128: { \/\/unsupported\n+                Type iType = Type.primitive(Primitive.Kind.Int128);\n+                return Type.qualified(Delegated.Kind.UNSIGNED, iType);\n+            }\n+            default:\n+                return TypeImpl.ERROR;\n+        }\n+    }\n+\n+    private Type lowerFunctionType(jdk.internal.clang.Type t) {\n+        Type t2 = makeType(t);\n+        return t2.accept(lowerFunctionType, null);\n+    }\n+\n+    private Type.Visitor<Type, Void> lowerFunctionType = new Type.Visitor<>() {\n+        @Override\n+        public Type visitArray(Type.Array t, Void aVoid) {\n+            return Type.pointer(t.elementType());\n+        }\n+\n+        @Override\n+        public Type visitDelegated(Type.Delegated t, Void aVoid) {\n+            if (t.kind() == Delegated.Kind.TYPEDEF && t.type() instanceof Type.Array) {\n+                return visitArray((Type.Array)t.type(), aVoid);\n+            }\n+            return visitType(t, aVoid);\n+        }\n+\n+        @Override\n+        public Type visitType(Type t, Void aVoid) {\n+            return t;\n+        }\n+    };\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeMaker.java","additions":257,"deletions":0,"binary":false,"changes":257,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Type.Primitive;\n+import jdk.incubator.jextract.Type;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodType;\n+\n+public class TypeTranslator implements Type.Visitor<Class<?>, Void> {\n+    @Override\n+    public Class<?> visitPrimitive(Type.Primitive t, Void aVoid) {\n+        if (t.kind().layout().isEmpty()) {\n+            return void.class;\n+        } else {\n+            return layoutToClass(isFloatingPoint(t), t.kind().layout().orElseThrow(UnsupportedOperationException::new));\n+        }\n+    }\n+\n+    private boolean isFloatingPoint(Type.Primitive t) {\n+        switch (t.kind()) {\n+            case Float:\n+            case Float128:\n+            case HalfFloat:\n+            case Double:\n+            case LongDouble:\n+                return true;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+    static String typeToLayoutName(Primitive.Kind type) {\n+        return switch (type) {\n+            case Bool -> \"C_BOOL\";\n+            case Char -> \"C_CHAR\";\n+            case Short -> \"C_SHORT\";\n+            case Int -> \"C_INT\";\n+            case Long -> \"C_LONG\";\n+            case LongLong -> \"C_LONG_LONG\";\n+            case Float -> \"C_FLOAT\";\n+            case Double -> \"C_DOUBLE\";\n+            default -> throw new RuntimeException(\"should not reach here: \" + type);\n+        };\n+    }\n+\n+    static Class<?> layoutToClass(boolean fp, MemoryLayout layout) {\n+        switch ((int)layout.bitSize()) {\n+            case 8: return byte.class;\n+            case 16: return short.class;\n+            case 32: return !fp ? int.class : float.class;\n+            case 64:\n+            case 128: return !fp ? long.class : double.class;\n+            default:\n+                throw new UnsupportedOperationException(\"size: \" + (int)layout.bitSize());\n+        }\n+    }\n+\n+    @Override\n+    public Class<?> visitDelegated(Type.Delegated t, Void aVoid) {\n+        return t.kind() == Type.Delegated.Kind.POINTER ?\n+                MemoryAddress.class :\n+                t.type().accept(this, null);\n+    }\n+\n+    @Override\n+    public Class<?> visitFunction(Type.Function t, Void aVoid) {\n+        return MemoryAddress.class; \/\/ function pointer\n+    }\n+\n+    @Override\n+    public Class<?> visitDeclared(Type.Declared t, Void aVoid) {\n+        switch (t.tree().kind()) {\n+            case UNION:\n+            case STRUCT:\n+                return MemorySegment.class;\n+            case ENUM:\n+                return layoutToClass(false, t.tree().layout().orElseThrow(UnsupportedOperationException::new));\n+            default:\n+                throw new UnsupportedOperationException(\"declaration kind: \" + t.tree().kind());\n+        }\n+    }\n+\n+    @Override\n+    public Class<?> visitArray(Type.Array t, Void aVoid) {\n+        if (t.kind() == Type.Array.Kind.VECTOR) {\n+            throw new UnsupportedOperationException(\"vector\");\n+        } else {\n+            return MemorySegment.class;\n+        }\n+    }\n+\n+    @Override\n+    public Class<?> visitType(Type t, Void aVoid) {\n+        throw new UnsupportedOperationException(t.getClass().toString());\n+    }\n+\n+    Class<?> getJavaType(Type t) {\n+        return t.accept(this, null);\n+    }\n+\n+    MethodType getMethodType(Type.Function type) {\n+        return getMethodType(type, true);\n+    }\n+\n+    MethodType getMethodType(Type.Function type, boolean varargsCheck) {\n+        MethodType mtype = MethodType.methodType(getJavaType(type.returnType()));\n+        for (Type arg : type.argumentTypes()) {\n+            mtype = mtype.appendParameterTypes(getJavaType(arg));\n+        }\n+        if (varargsCheck && type.varargs()) {\n+            mtype = mtype.appendParameterTypes(Object[].class);\n+        }\n+        return mtype;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeTranslator.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+public class TypedefBuilder extends ClassSourceBuilder {\n+\n+    private final String superClass;\n+\n+    public TypedefBuilder(JavaSourceBuilder enclosing, String name, String superClass) {\n+        super(enclosing, Kind.CLASS, name);\n+        this.superClass = superClass;\n+    }\n+\n+    @Override\n+    String superClass() {\n+        return superClass;\n+    }\n+\n+    @Override\n+    JavaSourceBuilder classEnd() {\n+        return super.classEnd();\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefBuilder.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.internal.clang.Cursor;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\/**\n+ * This visitor handles certain typedef declarations.\n+ *\n+ * 1. Remove redundant typedefs.\n+ * 2. Rename typedef'ed anonymous type definitions like\n+ *        typedef struct { int x; int y; } Point;\n+ *\/\n+final class TypedefHandler implements Declaration.Visitor<Void, Void> {\n+\n+    TreeMaker maker;\n+\n+    public TypedefHandler(TreeMaker maker) {\n+        this.maker = maker;\n+    }\n+\n+    \/\/ Potential Tree instances that will go into transformed HeaderTree\n+    \/\/ are collected in this list.\n+    private List<Declaration> decls = new ArrayList<>();\n+\n+    \/\/ Tree instances that are to be replaced from \"decls\" list are\n+    \/\/ saved in the following Map. One or more Trees can replace a Tree.\n+    private final Map<Cursor, List<Declaration>> replacements = new HashMap<>();\n+\n+    public Declaration.Scoped transform(Declaration.Scoped ht) {\n+        \/\/ Process all header declarations are collect potential\n+        \/\/ declarations that will go into transformed HeaderTree\n+        \/\/ into the this.decls field.\n+        ht.accept(this, null);\n+\n+\/\/        \/\/ Replace trees from this.decls with Trees found in this.replacements.\n+\/\/        \/\/ We need this two step process so that named StructTree instances\n+\/\/        \/\/ will replace with original unnamed StructTree instances.\n+\/\/        List<Declaration> newDecls = decls.stream().flatMap(tx -> {\n+\/\/            if (replacements.containsKey(tx.cursor())) {\n+\/\/                return replacements.get(tx.cursor()).stream();\n+\/\/            } else {\n+\/\/                return Stream.of(tx);\n+\/\/            }\n+\/\/        }).collect(Collectors.toList());\n+\/\/\n+\/\/        return treeMaker.createHeader(ht.cursor(), ht.path(), newDecls);\n+        return ht;\n+    }\n+\n+    @Override\n+    public Void visitDeclaration(Declaration d, Void aVoid) {\n+        decls.add(d);\n+        return null;\n+    }\n+\n+    @Override\n+    public Void visitScoped(Declaration.Scoped ht, Void v) {\n+        ht.members().forEach(decl -> decl.accept(this, null));\n+        return null;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypedefHandler.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.Type;\n+import jdk.internal.clang.TypeKind;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * MemoryLayout computer for C unions.\n+ *\/\n+final class UnionLayoutComputer extends RecordLayoutComputer {\n+    private final long offset;\n+    private long actualSize = 0L;\n+\n+    UnionLayoutComputer(long offsetInParent, Type parent, Type type) {\n+        super(parent, type);\n+        this.offset = offsetInParent;\n+    }\n+\n+    @Override\n+    void processField(Cursor c) {\n+        long expectedOffset = offsetOf(parent, c);\n+        if (expectedOffset > offset) {\n+            throw new IllegalStateException(\"No padding in union elements!\");\n+        }\n+\n+        addFieldLayout(offset, parent, c);\n+        actualSize = Math.max(actualSize, fieldSize(c));\n+    }\n+\n+    @Override\n+    void startBitfield() {\n+        \/\/ do nothing\n+    }\n+\n+    @Override\n+    MemoryLayout fieldLayout(Cursor c) {\n+        if (c.isBitField()) {\n+            return bitfield(List.of(super.fieldLayout(c)));\n+        } else {\n+            return super.fieldLayout(c);\n+        }\n+    }\n+\n+    @Override\n+    long fieldSize(Cursor c) {\n+        if (c.type().kind() == TypeKind.IncompleteArray) {\n+            return 0;\n+        } else if (c.isBitField()) {\n+            return c.getBitFieldWidth();\n+        } else {\n+            return c.type().size() * 8;\n+        }\n+    }\n+\n+    @Override\n+    MemoryLayout finishLayout() {\n+        \/\/ size mismatch indicates use of bitfields in union\n+        long expectedSize = type.size() * 8;\n+        if (actualSize < expectedSize) {\n+            \/\/ emit an extra padding of expected size to make sure union layout size is computed correctly\n+            addFieldLayout(MemoryLayout.paddingLayout(expectedSize));\n+        } else if (actualSize > expectedSize) {\n+            throw new AssertionError(\"Invalid union size - expected: \" + expectedSize + \"; found: \" + actualSize);\n+        }\n+\n+        MemoryLayout[] fields = fieldLayouts.toArray(new MemoryLayout[0]);\n+        GroupLayout g = MemoryLayout.unionLayout(fields);\n+        String name = LayoutUtils.getName(cursor);\n+        return name.isEmpty() ?\n+                g : g.withName(name);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/UnionLayoutComputer.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.jextract.impl;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.ValueLayout;\n+import java.nio.ByteOrder;\n+\n+\/*\n+ * Layouts for the primitive types not supported by ABI implementations.\n+ *\/\n+public final class UnsupportedLayouts {\n+    private UnsupportedLayouts() {}\n+\n+    private static final String ATTR_LAYOUT_KIND = \"jextract.abi.unsupported.layout.kind\";\n+\n+    public static final ValueLayout __INT128 = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"__int128\");\n+\n+    public static final ValueLayout LONG_DOUBLE = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"long double\");\n+\n+    public static final ValueLayout _FLOAT128 = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"_float128\");\n+\n+    public static final ValueLayout __FP16 = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"__fp16\");\n+\n+    public static final ValueLayout CHAR16 = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"char16\");\n+\n+    public static final ValueLayout WCHAR_T = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder()).\n+            withAttribute(ATTR_LAYOUT_KIND, \"wchar_t\");\n+\n+    static boolean isUnsupported(MemoryLayout vl) {\n+        return vl.attribute(ATTR_LAYOUT_KIND).isPresent();\n+    }\n+\n+    static String getUnsupportedTypeName(MemoryLayout vl) {\n+        return (String)\n+                vl.attribute(ATTR_LAYOUT_KIND).orElseThrow(IllegalArgumentException::new);\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/UnsupportedLayouts.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import jdk.internal.clang.Cursor;\n+import jdk.internal.clang.CursorKind;\n+import jdk.internal.clang.SourceLocation;\n+import jdk.internal.clang.Type;\n+\n+import javax.lang.model.SourceVersion;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * General utility functions\n+ *\/\n+class Utils {\n+    public static String qualifiedClassName(String packageName, String simpleName) {\n+        return (packageName.isEmpty() ? \"\" : packageName + \".\") + simpleName;\n+    }\n+\n+    private static URI fileName(String pkgName, String clsName, String extension) {\n+        String pkgPrefix = pkgName.isEmpty() ? \"\" : pkgName.replaceAll(\"\\\\.\", \"\/\") + \"\/\";\n+        return URI.create(pkgPrefix + clsName + extension);\n+    }\n+\n+    static JavaFileObject fileFromString(String pkgName, String clsName, String contents) {\n+        return new SimpleJavaFileObject(fileName(pkgName, clsName, \".java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                return contents;\n+            }\n+        };\n+    }\n+\n+    static String javaSafeIdentifier(String name) {\n+        return javaSafeIdentifier(name, false);\n+    }\n+\n+    static String javaSafeIdentifier(String name, boolean checkAllChars) {\n+        if (checkAllChars) {\n+            StringBuilder buf = new StringBuilder();\n+            char[] chars = name.toCharArray();\n+            if (Character.isJavaIdentifierStart(chars[0])) {\n+                buf.append(chars[0]);\n+            } else {\n+                buf.append('_');\n+            }\n+            if (chars.length > 1) {\n+                for (int i = 1; i < chars.length; i++) {\n+                    char ch = chars[i];\n+                    if (Character.isJavaIdentifierPart(ch)) {\n+                        buf.append(ch);\n+                    } else {\n+                        buf.append('_');\n+                    }\n+                }\n+            }\n+            return buf.toString();\n+        } else {\n+            \/\/ We never get the problem of Java non-identifiers (like 123, ab-xy) as\n+            \/\/ C identifiers. But we may have a java keyword used as a C identifier.\n+            assert SourceVersion.isIdentifier(name);\n+\n+            return SourceVersion.isKeyword(name) || isRestrictedTypeName(name) || isJavaTypeName(name)? (name + \"_\") : name;\n+        }\n+    }\n+\n+    private static boolean isRestrictedTypeName(String name) {\n+        return switch (name) {\n+            case \"var\", \"yield\", \"record\",\n+                \"sealed\", \"permits\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    private static boolean isJavaTypeName(String name) {\n+        \/\/ Java types that are used unqualified in the generated code\n+        return switch (name) {\n+            case \"String\", \"MethodHandle\",\n+                \"VarHandle\", \"ByteOrder\",\n+                \"FunctionDescriptor\", \"LibraryLookup\",\n+                \"MemoryAddress\", \"MemoryLayout\",\n+                \"MemorySegment\", \"ValueLayout\",\n+                \"RuntimeHelper\" -> true;\n+            default -> false;\n+        };\n+    }\n+\n+    static void validSimpleIdentifier(String name) {\n+        int length = name.length();\n+        if (length == 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        int ch = name.codePointAt(0);\n+        if (length == 1 && ch == '_') {\n+            throw new IllegalArgumentException(\"'_' is no longer valid identifier.\");\n+        }\n+\n+        if (!Character.isJavaIdentifierStart(ch)) {\n+            throw new IllegalArgumentException(\"Invalid start character for an identifier: \" + ch);\n+        }\n+\n+        for (int i = 1; i < length; i++) {\n+            ch = name.codePointAt(i);\n+            if (!Character.isJavaIdentifierPart(ch)) {\n+                throw new IllegalArgumentException(\"Invalid character for an identifier: \" + ch);\n+            }\n+        }\n+    }\n+\n+    static void validPackageName(String name) {\n+        if (name.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+        int idx = name.lastIndexOf('.');\n+        if (idx == -1) {\n+           validSimpleIdentifier(name);\n+        } else {\n+            validSimpleIdentifier(name.substring(idx + 1));\n+            validPackageName(name.substring(0, idx));\n+        }\n+    }\n+\n+    static String toJavaIdentifier(String str) {\n+        final int size = str.length();\n+        StringBuilder sb = new StringBuilder(size);\n+        if (! Character.isJavaIdentifierStart(str.charAt(0))) {\n+            sb.append('_');\n+        }\n+        for (int i = 0; i < size; i++) {\n+            char ch = str.charAt(i);\n+            if (Character.isJavaIdentifierPart(ch)) {\n+                sb.append(ch);\n+            } else {\n+                sb.append('_');\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String toSafeName(String name) {\n+        StringBuilder sb = new StringBuilder(name.length());\n+        name = toJavaIdentifier(name);\n+        sb.append(name);\n+        if (SourceVersion.isKeyword(name)) {\n+            sb.append(\"$\");\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String toClassName(String cname) {\n+        return toSafeName(cname);\n+    }\n+\n+    static String toMacroName(String mname) {\n+        return toSafeName(mname);\n+    }\n+\n+    static String toInternalName(String pkg, String name, String... nested) {\n+        if ((pkg == null || pkg.isEmpty()) && nested == null) {\n+            return name;\n+        }\n+\n+        StringBuilder sb = new StringBuilder();\n+        if (pkg != null && ! pkg.isEmpty()) {\n+            sb.append(pkg.replace('.', '\/'));\n+            if (sb.charAt(sb.length() - 1) != '\/') {\n+                sb.append('\/');\n+            }\n+        }\n+        sb.append(name);\n+        for (String n: nested) {\n+            sb.append('$');\n+            sb.append(n);\n+        }\n+        return sb.toString();\n+    }\n+\n+    static String getName(Type type) {\n+        return LayoutUtils.getName(type);\n+    }\n+\n+    static Stream<Cursor> flattenableChildren(Cursor c) {\n+        return c.children()\n+                .filter(cx -> cx.isAnonymousStruct() || cx.kind() == CursorKind.FieldDecl);\n+    }\n+\n+    \/\/ return builtin Record types accessible from the given Type\n+    static Stream<Cursor> getBuiltinRecordTypes(Type type) {\n+        List<Cursor> recordTypes = new ArrayList<>();\n+        fillBuiltinRecordTypes(type, recordTypes);\n+        return recordTypes.stream().distinct();\n+    }\n+\n+    private static void fillBuiltinRecordTypes(Type type, List<Cursor> recordTypes) {\n+        Type canonicalType = type.canonicalType();\n+        switch (canonicalType.kind()) {\n+            case ConstantArray:\n+            case IncompleteArray:\n+                fillBuiltinRecordTypes(canonicalType.getElementType(), recordTypes);\n+                break;\n+\n+            case FunctionProto:\n+            case FunctionNoProto: {\n+                final int numArgs = canonicalType.numberOfArgs();\n+                for (int i = 0; i < numArgs; i++) {\n+                    fillBuiltinRecordTypes(canonicalType.argType(i), recordTypes);\n+                }\n+                fillBuiltinRecordTypes(canonicalType.resultType(), recordTypes);\n+            }\n+            break;\n+\n+            case Record: {\n+                Cursor c = canonicalType.getDeclarationCursor();\n+                if (c.isDefinition()) {\n+                    SourceLocation sloc = c.getSourceLocation();\n+                    if (sloc != null && sloc.getFileLocation().path() == null) {\n+                        recordTypes.add(c);\n+                    }\n+                }\n+            }\n+            break;\n+\n+            case BlockPointer:\n+            case Pointer:\n+                fillBuiltinRecordTypes(canonicalType.getPointeeType(), recordTypes);\n+                break;\n+\n+            case Unexposed:\n+                if (! canonicalType.equalType(type)) {\n+                    fillBuiltinRecordTypes(canonicalType, recordTypes);\n+                }\n+                break;\n+\n+            case Elaborated:\n+            case Typedef:\n+                fillBuiltinRecordTypes(canonicalType, recordTypes);\n+                break;\n+\n+            default: \/\/ nothing to do\n+        }\n+    }\n+\n+    \/\/ return the absolute path of the library of given name by searching\n+    \/\/ in the given array of paths.\n+    static Optional<Path> findLibraryPath(Path[] paths, String libName) {\n+        return Arrays.stream(paths).\n+                map(p -> p.resolve(System.mapLibraryName(libName))).\n+                filter(Files::isRegularFile).map(Path::toAbsolutePath).findFirst();\n+    }\n+\n+    \/*\n+     * FIXME: when we add jdk.compiler dependency from jdk.jextract module, revisit\n+     * the following. The following methods 'quote', 'quote' and 'isPrintableAscii'\n+     * are from javac source. See also com.sun.tools.javac.util.Convert.java.\n+     *\/\n+\n+    \/**\n+     * Escapes each character in a string that has an escape sequence or\n+     * is non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(String s) {\n+        StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < s.length(); i++) {\n+            buf.append(quote(s.charAt(i)));\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Escapes a character if it has an escape sequence or is\n+     * non-printable ASCII.  Leaves non-ASCII characters alone.\n+     *\/\n+    static String quote(char ch) {\n+        switch (ch) {\n+        case '\\b':  return \"\\\\b\";\n+        case '\\f':  return \"\\\\f\";\n+        case '\\n':  return \"\\\\n\";\n+        case '\\r':  return \"\\\\r\";\n+        case '\\t':  return \"\\\\t\";\n+        case '\\'':  return \"\\\\'\";\n+        case '\\\"':  return \"\\\\\\\"\";\n+        case '\\\\':  return \"\\\\\\\\\";\n+        default:\n+            return (isPrintableAscii(ch))\n+                ? String.valueOf(ch)\n+                : String.format(\"\\\\u%04x\", (int) ch);\n+        }\n+    }\n+\n+    \/**\n+     * Is a character printable ASCII?\n+     *\/\n+    private static boolean isPrintableAscii(char ch) {\n+        return ch >= ' ' && ch <= '~';\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Utils.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package jdk.internal.jextract.impl;\n+\n+import javax.tools.JavaFileObject;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public final class Writer {\n+    private final List<? extends JavaFileObject> files;\n+    private final Path dest;\n+\n+    public Writer(Path dest, List<? extends JavaFileObject> files) {\n+        this.files = files;\n+        this.dest = dest;\n+    }\n+\n+    private List<JavaFileObject> ensureSourcesCompiled() {\n+        List<JavaFileObject> sources = sources();\n+        if (sources.isEmpty()) {\n+            return List.of();\n+        } else {\n+            return InMemoryJavaCompiler.compile(sources,\n+                \"--add-modules\", \"jdk.incubator.foreign\",\n+                \"--release\", \"17\",\n+                \"-d\", dest.toAbsolutePath().toString(),\n+                \"-cp\", dest.toAbsolutePath().toString());\n+        }\n+    }\n+\n+    public void writeAll(boolean compileSources) throws IOException {\n+        writeClassFiles(resources());\n+        writeClassFiles(classes());\n+        if (compileSources) {\n+            writeClassFiles(ensureSourcesCompiled());\n+        } else {\n+            writeSourceFiles();\n+        }\n+    }\n+\n+    void writeClassFiles(List<JavaFileObject> files) throws IOException {\n+        Path destDir = createOutputDir();\n+        for (var entry : files) {\n+            String path = entry.getName();\n+            Path fullPath = destDir.resolve(path).normalize();\n+            Files.createDirectories(fullPath.getParent());\n+            try (InputStream is = entry.openInputStream()) {\n+                Files.write(fullPath, is.readAllBytes());\n+            }\n+        }\n+    }\n+\n+    void writeSourceFiles() throws IOException {\n+        Path destDir = createOutputDir();\n+        for (var entry : sources()) {\n+            String srcPath = entry.getName();\n+            Path fullPath = destDir.resolve(srcPath).normalize();\n+            Path dir = fullPath.getParent();\n+            \/\/ In case the folder exist and is a link to a folder, this should be OK\n+            \/\/ Case in point, \/tmp on MacOS link to \/private\/tmp\n+            if (Files.exists(dir)) {\n+                if (!Files.isDirectory(dir)) {\n+                    throw new FileAlreadyExistsException(dir.toAbsolutePath().toString());\n+                }\n+            } else {\n+                Files.createDirectories(fullPath.getParent());\n+            }\n+            Files.write(fullPath, List.of(entry.getCharContent(false)));\n+        }\n+    }\n+\n+    private List<JavaFileObject> sources() {\n+        return files.stream()\n+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.SOURCE)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<JavaFileObject> classes() {\n+        return files.stream()\n+                .filter(jfo -> jfo.getKind() == JavaFileObject.Kind.CLASS)\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<JavaFileObject> resources() {\n+        return files.stream()\n+                .filter(jfo -> (jfo.getKind() == JavaFileObject.Kind.HTML || jfo.getKind() == JavaFileObject.Kind.OTHER))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private Path createOutputDir() throws IOException {\n+        Path absDest = dest.toAbsolutePath();\n+        if (!Files.exists(absDest)) {\n+            Files.createDirectories(absDest);\n+        }\n+        if (!Files.isDirectory(absDest)) {\n+            throw new IOException(\"Not a directory: \" + dest);\n+        }\n+        return absDest;\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/Writer.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+#\n+#  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+#  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+# \n+#  This code is free software; you can redistribute it and\/or modify it\n+#  under the terms of the GNU General Public License version 2 only, as\n+#  published by the Free Software Foundation.\n+# \n+#  This code is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+#  version 2 for more details (a copy is included in the LICENSE file that\n+#  accompanied this code).\n+# \n+#  You should have received a copy of the GNU General Public License version\n+#  2 along with this work; if not, write to the Free Software Foundation,\n+#  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+# \n+#  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+#  or visit www.oracle.com if you need additional information or have any\n+#  questions.\n+#\n+\n+# error message\n+cannot.read.header.file=cannot read header file: {0}\n+not.a.file=not a file: {0}\n+l.option.value.invalid=option value for -l option should be a name or an absolute path\n+\n+# help messages for options\n+help.C=pass through argument for clang\n+help.I=specify include files path\n+help.d=specify where to place generated files\n+help.include-macro=name of constant macro to include\n+help.include-var=name of global variable to include\n+help.include-function=name of function to include\n+help.include-typedef=name of type definition to include\n+help.include-struct=name of struct definition to include\n+help.include-union=name of union definition to include\n+help.dump-includes=dump included symbols into specified file\n+help.h=print help\n+help.header-class-name=name of the header class\n+help.l=specify a library\n+help.source=generate java sources\n+help.t=target package for specified header files\n+help.non.option=header file\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/Messages.properties","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/\/ Generated by jextract\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+final class RuntimeHelper {\n+    private RuntimeHelper() {}\n+    private final static CLinker LINKER = CLinker.getInstance();\n+    private final static ClassLoader LOADER = RuntimeHelper.class.getClassLoader();\n+    private final static MethodHandles.Lookup MH_LOOKUP = MethodHandles.lookup();\n+\n+    static SymbolLookup lookup() {\n+        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+        SymbolLookup systemLookup = CLinker.systemLookup();\n+        return name -> loaderLookup.lookup(name).or(() -> systemLookup.lookup(name));\n+    }\n+\n+    static <T> T requireNonNull(T obj, String symbolName) {\n+        if (obj == null) {\n+            throw new UnsatisfiedLinkError(\"unresolved symbol: \" + symbolName);\n+        }\n+        return obj;\n+    }\n+\n+    private final static SegmentAllocator THROWING_ALLOCATOR = (x, y) -> { throw new AssertionError(\"should not reach here\"); };\n+\n+    static final MemorySegment lookupGlobalVariable(SymbolLookup LOOKUP, String name, MemoryLayout layout) {\n+        return LOOKUP.lookup(name).map(s -> s.address().asSegment(layout.byteSize(), ResourceScope.newImplicitScope())).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(SymbolLookup LOOKUP, String name, String desc, FunctionDescriptor fdesc, boolean variadic) {\n+        return LOOKUP.lookup(name).map(\n+                addr -> {\n+                    MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+                    return variadic ?\n+                        VarargsInvoker.make(addr, mt, fdesc) :\n+                        LINKER.downcallHandle(addr, mt, fdesc);\n+                }).orElse(null);\n+    }\n+\n+    static final MethodHandle downcallHandle(String desc, FunctionDescriptor fdesc, boolean variadic) {\n+        if (variadic) {\n+            throw new AssertionError(\"Cannot get here!\");\n+        }\n+        MethodType mt = MethodType.fromMethodDescriptorString(desc, LOADER);\n+        return LINKER.downcallHandle(mt, fdesc);\n+    }\n+\n+    static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc) {\n+        return upcallStub(fi, z, fdesc, mtypeDesc, ResourceScope.newImplicitScope());\n+    }\n+\n+    static final <Z> MemoryAddress upcallStub(Class<Z> fi, Z z, FunctionDescriptor fdesc, String mtypeDesc, ResourceScope scope) {\n+        try {\n+            MethodHandle handle = MH_LOOKUP.findVirtual(fi, \"apply\",\n+                    MethodType.fromMethodDescriptorString(mtypeDesc, LOADER));\n+            handle = handle.bindTo(z);\n+            return LINKER.upcallStub(handle, fdesc, scope);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static MemorySegment asArray(MemoryAddress addr, MemoryLayout layout, int numElements, ResourceScope scope) {\n+         return addr.asSegment(numElements * layout.byteSize(), scope);\n+    }\n+\n+    \/\/ Internals only below this point\n+\n+    private static class VarargsInvoker {\n+        private static final MethodHandle INVOKE_MH;\n+        private final Addressable symbol;\n+        private final MethodType varargs;\n+        private final FunctionDescriptor function;\n+\n+        private VarargsInvoker(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+            this.symbol = symbol;\n+            this.varargs = type;\n+            this.function = function;\n+        }\n+\n+        static {\n+            try {\n+                INVOKE_MH = MethodHandles.lookup().findVirtual(VarargsInvoker.class, \"invoke\", MethodType.methodType(Object.class, SegmentAllocator.class, Object[].class));\n+            } catch (ReflectiveOperationException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static MethodHandle make(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+            VarargsInvoker invoker = new VarargsInvoker(symbol, type, function);\n+            MethodHandle handle = INVOKE_MH.bindTo(invoker).asCollector(Object[].class, type.parameterCount());\n+            if (type.returnType().equals(MemorySegment.class)) {\n+                type = type.insertParameterTypes(0, SegmentAllocator.class);\n+            } else {\n+                handle = MethodHandles.insertArguments(handle, 0, THROWING_ALLOCATOR);\n+            }\n+            return handle.asType(type);\n+        }\n+\n+        private Object invoke(SegmentAllocator allocator, Object[] args) throws Throwable {\n+            \/\/ one trailing Object[]\n+            int nNamedArgs = function.argumentLayouts().size();\n+            assert(args.length == nNamedArgs + 1);\n+            \/\/ The last argument is the array of vararg collector\n+            Object[] unnamedArgs = (Object[]) args[args.length - 1];\n+\n+            int argsCount = nNamedArgs + unnamedArgs.length;\n+            Class<?>[] argTypes = new Class<?>[argsCount];\n+            MemoryLayout[] argLayouts = new MemoryLayout[nNamedArgs + unnamedArgs.length];\n+\n+            int pos = 0;\n+            for (pos = 0; pos < nNamedArgs; pos++) {\n+                argTypes[pos] = varargs.parameterType(pos);\n+                argLayouts[pos] = function.argumentLayouts().get(pos);\n+            }\n+\n+            assert pos == nNamedArgs;\n+            for (Object o: unnamedArgs) {\n+                argTypes[pos] = normalize(o.getClass());\n+                argLayouts[pos] = variadicLayout(argTypes[pos]);\n+                pos++;\n+            }\n+            assert pos == argsCount;\n+\n+            MethodType mt = MethodType.methodType(varargs.returnType(), argTypes);\n+            FunctionDescriptor f = (function.returnLayout().isEmpty()) ?\n+                    FunctionDescriptor.ofVoid(argLayouts) :\n+                    FunctionDescriptor.of(function.returnLayout().get(), argLayouts);\n+            MethodHandle mh = LINKER.downcallHandle(symbol, allocator, mt, f);\n+            \/\/ flatten argument list so that it can be passed to an asSpreader MH\n+            Object[] allArgs = new Object[nNamedArgs + unnamedArgs.length];\n+            System.arraycopy(args, 0, allArgs, 0, nNamedArgs);\n+            System.arraycopy(unnamedArgs, 0, allArgs, nNamedArgs, unnamedArgs.length);\n+\n+            return mh.asSpreader(Object[].class, argsCount).invoke(allArgs);\n+        }\n+\n+        private static Class<?> unboxIfNeeded(Class<?> clazz) {\n+            if (clazz == Boolean.class) {\n+                return boolean.class;\n+            } else if (clazz == Void.class) {\n+                return void.class;\n+            } else if (clazz == Byte.class) {\n+                return byte.class;\n+            } else if (clazz == Character.class) {\n+                return char.class;\n+            } else if (clazz == Short.class) {\n+                return short.class;\n+            } else if (clazz == Integer.class) {\n+                return int.class;\n+            } else if (clazz == Long.class) {\n+                return long.class;\n+            } else if (clazz == Float.class) {\n+                return float.class;\n+            } else if (clazz == Double.class) {\n+                return double.class;\n+            } else {\n+                return clazz;\n+            }\n+        }\n+\n+        private Class<?> promote(Class<?> c) {\n+            if (c == byte.class || c == char.class || c == short.class || c == int.class) {\n+                return long.class;\n+            } else if (c == float.class) {\n+                return double.class;\n+            } else {\n+                return c;\n+            }\n+        }\n+\n+        private Class<?> normalize(Class<?> c) {\n+            c = unboxIfNeeded(c);\n+            if (c.isPrimitive()) {\n+                return promote(c);\n+            }\n+            if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return MemoryAddress.class;\n+            }\n+            if (MemorySegment.class.isAssignableFrom(c)) {\n+                return MemorySegment.class;\n+            }\n+            throw new IllegalArgumentException(\"Invalid type for ABI: \" + c.getTypeName());\n+        }\n+\n+        private MemoryLayout variadicLayout(Class<?> c) {\n+            if (c == long.class) {\n+                return C_LONG_LONG;\n+            } else if (c == double.class) {\n+                return C_DOUBLE;\n+            } else if (MemoryAddress.class.isAssignableFrom(c)) {\n+                return C_POINTER;\n+            } else {\n+                throw new IllegalArgumentException(\"Unhandled variadic argument class: \" + c);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/resources\/RuntimeHelper.java.template","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+import jdk.incubator.jextract.JextractTool;\n+\n+module jdk.incubator.jextract {\n+    requires transitive java.compiler;\n+    requires transitive jdk.incubator.foreign;\n+    requires jdk.internal.opt;\n+    exports jdk.incubator.jextract;\n+\n+    provides java.util.spi.ToolProvider with\n+        JextractTool.JextractToolProvider;\n+}\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/module-info.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -3548,0 +3548,1 @@\n+        Objects.requireNonNull(a);\n@@ -3566,8 +3567,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.get(o + i * 1));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.get(o + i * 1));\n+                  });\n+        }\n@@ -3600,0 +3605,1 @@\n+        Objects.requireNonNull(a);\n@@ -3615,9 +3621,13 @@\n-        ByteSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          ByteSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.put(o + i * 1, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3159,0 +3159,1 @@\n+        Objects.requireNonNull(a);\n@@ -3177,8 +3178,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getDouble(o + i * 8));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getDouble(o + i * 8));\n+                  });\n+        }\n@@ -3211,0 +3216,1 @@\n+        Objects.requireNonNull(a);\n@@ -3226,9 +3232,13 @@\n-        DoubleSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          DoubleSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putDouble(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3146,0 +3146,1 @@\n+        Objects.requireNonNull(a);\n@@ -3164,8 +3165,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getFloat(o + i * 4));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getFloat(o + i * 4));\n+                  });\n+        }\n@@ -3198,0 +3203,1 @@\n+        Objects.requireNonNull(a);\n@@ -3213,9 +3219,13 @@\n-        FloatSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          FloatSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putFloat(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3255,0 +3255,1 @@\n+        Objects.requireNonNull(a);\n@@ -3273,8 +3274,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getInt(o + i * 4));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getInt(o + i * 4));\n+                  });\n+        }\n@@ -3307,0 +3312,1 @@\n+        Objects.requireNonNull(a);\n@@ -3322,9 +3328,13 @@\n-        IntSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          IntSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putInt(o + i * 4, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3158,0 +3158,1 @@\n+        Objects.requireNonNull(a);\n@@ -3176,8 +3177,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getLong(o + i * 8));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getLong(o + i * 8));\n+                  });\n+        }\n@@ -3210,0 +3215,1 @@\n+        Objects.requireNonNull(a);\n@@ -3225,9 +3231,13 @@\n-        LongSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          LongSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putLong(o + i * 8, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -3535,0 +3535,1 @@\n+        Objects.requireNonNull(a);\n@@ -3553,8 +3554,12 @@\n-        return ScopedMemoryAccess.loadFromByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                bb, offset, vsp,\n-                (buf, off, s) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    return s.ldOp(wb, off,\n-                            (wb_, o, i) -> wb_.getShort(o + i * 2));\n-                });\n+        if (!bb.isDirect()) {\n+          return fromByteArray0(bb.array(), offset);\n+        } else {\n+          return ScopedMemoryAccess.loadFromByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  bb, offset, vsp,\n+                  (buf, off, s) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      return s.ldOp(wb, off,\n+                              (wb_, o, i) -> wb_.getShort(o + i * 2));\n+                  });\n+        }\n@@ -3587,0 +3592,1 @@\n+        Objects.requireNonNull(a);\n@@ -3602,9 +3608,13 @@\n-        ShortSpecies vsp = vspecies();\n-        ScopedMemoryAccess.storeIntoByteBuffer(\n-                vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n-                this, bb, offset,\n-                (buf, off, v) -> {\n-                    ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n-                    v.stOp(wb, off,\n-                            (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n-                });\n+        if (!bb.isDirect()) {\n+          intoByteArray0(bb.array(), offset);\n+        } else {\n+          ShortSpecies vsp = vspecies();\n+          ScopedMemoryAccess.storeIntoByteBuffer(\n+                  vsp.vectorType(), vsp.elementType(), vsp.laneCount(),\n+                  this, bb, offset,\n+                  (buf, off, v) -> {\n+                      ByteBuffer wb = wrapper(buf, NATIVE_ENDIAN);\n+                      v.stOp(wb, off,\n+                              (wb_, o, i, e) -> wb_.putShort(o + i * 2, e));\n+                  });\n+        }\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -32,1 +32,7 @@\n-    exports jdk.internal.joptsimple to jdk.jlink, jdk.jshell;\n+    exports jdk.internal.joptsimple to\n+        jdk.incubator.jextract,\n+        jdk.jlink,\n+        jdk.jshell;\n+\n+    exports jdk.internal.joptsimple.util to\n+        jdk.incubator.jextract;\n","filename":"src\/jdk.internal.opt\/share\/classes\/module-info.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    :jdk_jextract \\\n@@ -342,0 +343,4 @@\n+jdk_jextract = \\\n+    java\/jextract \\\n+    tools\/jextract\n+\n","filename":"test\/jdk\/TEST.groups","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.JextractTool;\n+import jdk.incubator.jextract.Type;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class JextractApiTestBase {\n+    static final boolean isMacOSX =\n+            System.getProperty(\"os.name\", \"unknown\").contains(\"OS X\");\n+    static final boolean isWindows =\n+            System.getProperty(\"os.name\", \"unknown\").startsWith(\"Windows\");\n+\n+    public static  Declaration.Scoped parse(String headerFilename, String... parseOptions) {\n+        Path header = Paths.get(System.getProperty(\"test.src\", \".\"), headerFilename);\n+        return JextractTool.parse(List.of(header), parseOptions);\n+    }\n+\n+    public static void checkNames(List<Declaration> members, String... fields) {\n+        assertEquals(members.size(), fields.length);\n+        for (int i = 0; i < fields.length; i++) {\n+            assertEquals(members.get(i).name(), fields[i]);\n+        }\n+    }\n+\n+    public static Declaration.Scoped checkScoped(Declaration.Scoped toplevel, String name, Declaration.Scoped.Kind kind,  String... fields) {\n+        Declaration.Scoped scoped = findDecl(toplevel, name, Declaration.Scoped.class);\n+        assertTrue(scoped.kind() == kind);\n+        checkNames(scoped.members(), fields);\n+        return scoped;\n+    }\n+\n+    private static List<Declaration> getNamedFields(Declaration.Scoped scoped) {\n+        List<Declaration> fields = new ArrayList<>();\n+        scoped.members().forEach(d -> {\n+            if (d instanceof Declaration.Variable) {\n+                Declaration.Variable v = (Declaration.Variable) d;\n+                if (v.kind() == Declaration.Variable.Kind.FIELD) {\n+                    assert (!v.name().isEmpty());\n+                    fields.add(v);\n+                }\n+            } else if (d instanceof Declaration.Scoped) {\n+                Declaration.Scoped record = (Declaration.Scoped) d;\n+                if (record.name().isEmpty()) {\n+                    fields.addAll(getNamedFields(record));\n+                } else {\n+                    fields.add(record);\n+                }\n+            }\n+        });\n+        return fields;\n+    }\n+\n+    public static Declaration.Scoped checkRecord(Declaration.Scoped scoped, String name, Declaration.Scoped.Kind kind,  String... fields) {\n+        assertTrue(scoped.kind() == kind);\n+        checkNames(getNamedFields(scoped), fields);\n+        return scoped;\n+    }\n+\n+    public static Declaration.Scoped checkStruct(Declaration.Scoped toplevel, String name, String... fields) {\n+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.STRUCT, fields);\n+    }\n+\n+    public static Declaration.Scoped checkBitfields(Declaration.Scoped toplevel, String name, String... fields) {\n+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.BITFIELDS, fields);\n+    }\n+\n+    public static Declaration.Scoped checkUnion(Declaration.Scoped toplevel, String name, String... fields) {\n+        return checkScoped(toplevel, name, Declaration.Scoped.Kind.UNION, fields);\n+    }\n+\n+    public static Declaration.Variable checkVariable(Declaration.Scoped scope, String name, Type type) {\n+        Declaration.Variable var = findDecl(scope, name, Declaration.Variable.class);\n+        assertTypeEquals(type, var.type());\n+        return var;\n+    }\n+\n+    public static Declaration.Variable checkGlobal(Declaration.Scoped toplevel, String name, Type type) {\n+        Declaration.Variable global = checkVariable(toplevel, name, type);\n+        assertEquals(global.kind(), Declaration.Variable.Kind.GLOBAL);\n+        return global;\n+    }\n+\n+    public static Declaration.Variable checkField(Declaration.Scoped record, String name, Type type) {\n+        Declaration.Variable global = checkVariable(record, name, type);\n+        assertEquals(global.kind(), Declaration.Variable.Kind.FIELD);\n+        return global;\n+    }\n+\n+    public static Declaration.Variable checkBitField(Declaration.Scoped record, String name, Type type, int size) {\n+        Declaration.Variable global = checkVariable(record, name, type);\n+        assertEquals(global.kind(), Declaration.Variable.Kind.BITFIELD);\n+        assertEquals(global.layout().get().bitSize(), size);\n+        return global;\n+    }\n+\n+    public static void checkFunction(Declaration.Function function, Type ret, Type... params) {\n+        assertTypeEquals(ret, function.type().returnType());\n+        assertEquals(function.parameters().size(), params.length);\n+        for (int i = 0 ; i < params.length ; i++) {\n+            assertTypeEquals(params[i], function.type().argumentTypes().get(i));\n+            Type paramType = function.parameters().get(i).type();\n+            if (paramType instanceof Type.Array) {\n+                assertTypeEquals(params[i], Type.pointer(((Type.Array) paramType).elementType()));\n+            } else {\n+                assertTypeEquals(params[i], function.parameters().get(i).type());\n+            }\n+        }\n+    }\n+\n+    public static Declaration.Function checkFunction(Declaration.Scoped toplevel,String name , Type ret, Type... params) {\n+        Declaration.Function function = findDecl(toplevel, name, Declaration.Function.class);\n+        checkFunction(function, ret,params);\n+        return function;\n+    }\n+\n+    public static Declaration.Constant checkConstant(Declaration.Scoped toplevel, String name, Type type, Object value) {\n+        Declaration.Constant constant = findDecl(toplevel, name, Declaration.Constant.class);\n+        assertTypeEquals(type, constant.type());\n+        assertEquals(value, constant.value());\n+        return constant;\n+    }\n+\n+    public static Predicate<Declaration> byName(final String name) {\n+        return d -> d.name().equals(name);\n+    }\n+\n+    public static Predicate<Declaration> byNameAndType(final String name, Class<? extends Declaration> declType) {\n+        return d -> declType.isAssignableFrom(d.getClass()) && d.name().equals(name);\n+    }\n+\n+    public static Optional<Declaration> findDecl(Declaration.Scoped toplevel, Predicate<Declaration> filter) {\n+        return toplevel.members().stream().filter(filter).findAny();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static <D extends Declaration> D findDecl(Declaration.Scoped toplevel, String name, Class<D> declType) {\n+        Optional<Declaration> d = findDecl(toplevel, byNameAndType(name, declType));\n+        if (d.isEmpty()) {\n+            fail(\"No declaration with name \" + name + \" found in \" + toplevel);\n+            return null;\n+        }\n+        return (D) d.get();\n+    }\n+\n+    public static void assertTypeEquals(Type expected, Type found) {\n+        assertEquals(expected.getClass(), found.getClass());\n+        if (expected instanceof Type.Primitive) {\n+            assertEquals(expected, found);\n+        } else if (expected instanceof Type.Delegated) {\n+            assertEquals(((Type.Delegated)expected).kind(), ((Type.Delegated)found).kind());\n+            assertTypeEquals(((Type.Delegated)expected).type(), ((Type.Delegated)found).type());\n+        } else if (expected instanceof Type.Array) {\n+            assertEquals(((Type.Array)expected).kind(), ((Type.Array)found).kind());\n+            assertEquals(((Type.Array)expected).elementCount(), ((Type.Array)found).elementCount());\n+            assertTypeEquals(((Type.Array)expected).elementType(), ((Type.Array)found).elementType());\n+        } else if (expected instanceof Type.Declared) {\n+            assertEquals(((Type.Declared)expected).tree(), ((Type.Declared)found).tree());\n+        } else if (expected instanceof Type.Function) {\n+            assertTypeEquals(((Type.Function)expected).returnType(), ((Type.Function)found).returnType());\n+            assertEquals(((Type.Function)expected).argumentTypes().size(), ((Type.Function)found).argumentTypes().size());\n+            assertEquals(((Type.Function)expected).varargs(), ((Type.Function)found).varargs());\n+            for (int i = 0 ; i < ((Type.Function)expected).argumentTypes().size() ; i++) {\n+                assertTypeEquals(((Type.Function)expected).argumentTypes().get(i), ((Type.Function)found).argumentTypes().get(i));\n+            }\n+        }\n+    }\n+\n+    public static Type unwrapDelegatedType(Type type, Type.Delegated.Kind kind) {\n+        assertTrue(type instanceof Type.Delegated,\n+                \"Expecting Type.Delegated, got \" + type.getClass());\n+        Type.Delegated delegated = (Type.Delegated) type;\n+        assertEquals(delegated.kind(), kind);\n+        return delegated.type();\n+    }\n+\n+    public static Type unwrapPointerType(Type type) {\n+        return unwrapDelegatedType(type, Type.Delegated.Kind.POINTER);\n+    }\n+\n+    public static Type unwrapTypedefType(Type type) {\n+        return unwrapDelegatedType(type, Type.Delegated.Kind.TYPEDEF);\n+    }\n+\n+    public static Type unwrapArrayType(Type type, long size) {\n+        assertTrue(type instanceof Type.Array,\n+                \"Expecting Type.Array, got \" + type.getClass());\n+        Type.Array arType = (Type.Array) type;\n+        assertEquals(arType.elementCount().getAsLong(), size);\n+        return arType.elementType();\n+    }\n+\n+    public static Type unwrapArrayType(Type type) {\n+        assertTrue(type instanceof Type.Array,\n+                \"Expecting Type.Array, got \" + type.getClass());\n+        Type.Array arType = (Type.Array) type;\n+        assertTrue(arType.elementCount().isEmpty());\n+        return arType.elementType();\n+    }\n+\n+    static class TypeUnwrapper {\n+        private Type type;\n+\n+        private TypeUnwrapper(Type type) {\n+            this.type = type;\n+        }\n+\n+        public static TypeUnwrapper of(Type type) {\n+            return new TypeUnwrapper(type);\n+        }\n+\n+        public TypeUnwrapper unwrapPointer() {\n+            type = unwrapPointerType(type);\n+            return this;\n+        }\n+\n+        public TypeUnwrapper unwrapTypedef() {\n+            type = unwrapTypedefType(type);\n+            return this;\n+        }\n+\n+        public TypeUnwrapper unwrapArray(long size) {\n+            type = unwrapArrayType(type, size);\n+            return this;\n+        }\n+\n+        public TypeUnwrapper unwrapArray() {\n+            type = unwrapArrayType(type);\n+            return this;\n+        }\n+\n+        public Type get() {\n+            return type;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/JextractApiTestBase.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract SmokeTest\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+public class SmokeTest extends JextractApiTestBase {\n+\n+    @Test\n+    public void testParser() {\n+        Declaration.Scoped d = parse(\"smoke.h\");\n+        Declaration.Scoped pointDecl = checkStruct(d, \"Point\", \"x\", \"y\");\n+        Type intType = ((Declaration.Variable)pointDecl.members().get(0)).type();\n+        checkGlobal(d, \"p\", Type.declared(pointDecl));\n+        checkFunction(d, \"distance\", intType, Type.declared(pointDecl), Type.declared(pointDecl));\n+        Declaration.Variable ch_ptr_ptr = findDecl(d, \"ch_ptr_ptr\", Declaration.Variable.class);\n+        checkFunction(d, \"pointers\", ch_ptr_ptr.type(), ch_ptr_ptr.type(), ch_ptr_ptr.type());\n+        checkConstant(d, \"ZERO\", intType, 0L);\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/SmokeTest.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+#\n+# Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+modules = jdk.incubator.jextract\n","filename":"test\/jdk\/java\/jextract\/TEST.properties","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Forward reference of struct to cause ConcurrentModificationException\n+struct foo;\n+\n+\/\/ Declaration above is required, without it, the argument s cause\n+\/\/ a C warning as struct foo only visible to the function.\n+int withRecordTypeArg(int n, struct foo s);\n+struct foo returnRecordType(void);\n+\n+\/\/ Improper header may write such with definition in other file\n+struct bar returnBar(void);\n+void withBar(struct bar s);\n+\n+struct bar *nextBar(struct bar *current);\n+\n+struct foo {\n+    int n;\n+    struct foo *ptr;\n+};\n","filename":"test\/jdk\/java\/jextract\/Test8238712.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8238712\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+public class Test8238712 extends JextractApiTestBase {\n+    @Test\n+    public void test8238712() {\n+        Declaration.Scoped d = parse(\"Test8238712.h\");\n+        Declaration.Scoped structFoo = checkStruct(d, \"foo\", \"n\", \"ptr\");\n+        Type intType = ((Declaration.Variable) structFoo.members().get(0)).type();\n+        Type fooType = Type.declared(structFoo);\n+        checkFunction(d, \"withRecordTypeArg\", intType, intType, fooType);\n+        checkFunction(d, \"returnRecordType\", fooType);\n+        \/\/ Opaque struct, have no field\n+        Declaration.Scoped structBar = checkStruct(d, \"bar\");\n+        assertTrue(structBar.layout().isEmpty());\n+        Type barType = Type.declared(structBar);\n+        \/\/ Function with opaque struct won't work but should have cursor for tool to handle\n+        checkFunction(d, \"returnBar\", barType);\n+        checkFunction(d, \"withBar\", Type.void_(), barType);\n+        \/\/ Function use pointer to opaque struct should be OK\n+        Type barPointer = Type.pointer(barType);\n+        checkFunction(d, \"nextBar\", barPointer, barPointer);\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/Test8238712.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    unsigned int a:1;\n+    unsigned int b:1;\n+    unsigned int c:30;\n+};\n+\n+struct Bar {\n+    unsigned int x:1;\n+    unsigned int y:31;\n+    struct Foo z[1];\n+};\n+\n+struct Baz {\n+    unsigned long long x:1;\n+    unsigned long long y:63;\n+    struct Bar z[1];\n+};\n","filename":"test\/jdk\/java\/jextract\/Test8239490.h","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8239490\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+public class Test8239490 extends JextractApiTestBase {\n+    @Test\n+    public void test8239490() {\n+        Declaration.Scoped d = parse(\"Test8239490.h\");\n+        \/\/ check Foo\n+        String[] fooBitfieldNames = { \"a\", \"b\", \"c\" };\n+        int[] fooBitfieldSizes = { 1, 1, 30 };\n+        Declaration.Scoped structFoo = checkStruct(d, \"Foo\", \"\");\n+        Declaration.Scoped bitfieldsFoo = checkBitfields(structFoo, \"\", \"a\", \"b\", \"c\");\n+        Type intType = ((Declaration.Variable)bitfieldsFoo.members().get(0)).type();\n+        for (int i = 0 ; i < fooBitfieldNames.length ; i++) {\n+            checkBitField(bitfieldsFoo, fooBitfieldNames[i], intType, fooBitfieldSizes[i]);\n+        }\n+        \/\/ check Bar\n+        String[] barBitfieldNames = { \"x\", \"y\" };\n+        int[] barBitfieldSizes = { 1, 31 };\n+        Declaration.Scoped structBar = checkStruct(d, \"Bar\", \"\", \"z\");\n+        Declaration.Scoped bitfieldsBar = checkBitfields(structBar, \"\", \"x\", \"y\");\n+        for (int i = 0 ; i < barBitfieldNames.length ; i++) {\n+            checkBitField(bitfieldsBar, barBitfieldNames[i], intType, barBitfieldSizes[i]);\n+        }\n+        checkField(structBar, \"z\", Type.array(1, Type.declared(structFoo)));\n+\n+        \/\/ check Baz\n+        String[] bazBitfieldNames = { \"x\", \"y\" };\n+        int[] bazBitfieldSizes = { 1, 63 };\n+        Declaration.Scoped structBaz = checkStruct(d, \"Baz\", \"\", \"z\");\n+        Declaration.Scoped bitfieldsBaz = checkBitfields(structBaz, \"\", \"x\", \"y\");\n+        Type longType = ((Declaration.Variable)bitfieldsBaz.members().get(0)).type();\n+        for (int i = 0 ; i < bazBitfieldNames.length ; i++) {\n+            checkBitField(bitfieldsBaz, bazBitfieldNames[i], longType, bazBitfieldSizes[i]);\n+        }\n+        checkField(structBaz, \"z\", Type.array(1, Type.declared(structBar)));\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/Test8239490.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef void CB(int);\n+void func_cb(CB cb);\n","filename":"test\/jdk\/java\/jextract\/Test8240372.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8240372\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+public class Test8240372 extends JextractApiTestBase {\n+    @Test\n+    public void test8239490() {\n+        Declaration.Scoped d = parse(\"Test8240372.h\");\n+\n+        Type funcType = Type.function(false, Type.void_(), Type.primitive(Type.Primitive.Kind.Int));\n+        Type typedefType = Type.typedef(\"CB\", funcType);\n+        checkFunction(d, \"func_cb\", Type.void_(), typedefType);\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/Test8240372.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+union Foo {\n+    int i;\n+    long long l;\n+};\n","filename":"test\/jdk\/java\/jextract\/Test8240853.h","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8240853\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import org.testng.annotations.Test;\n+\n+public class Test8240853 extends JextractApiTestBase {\n+    @Test\n+    public void test8240853() {\n+        Declaration.Scoped d = parse(\"Test8240853.h\");\n+        \/\/ check Foo\n+        checkUnion(d, \"Foo\", \"i\", \"l\");\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/Test8240853.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8239808\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract TestAttributes\n+ *\/\n+\n+import java.lang.constant.Constable;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestAttributes extends JextractApiTestBase {\n+    private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int);\n+    private final static String ASMLABEL = \"AsmLabelAttr\";\n+\n+    private void validateAsmLabel(Declaration d, boolean isAdd) {\n+        var attrs = d.getAttribute(ASMLABEL).get();\n+        String value = isMacOSX ? \"_\" : \"\";\n+        value += d.name();\n+        value += isAdd ? \"A\" : \"B\";\n+        assertEquals(attrs.get(0), value);\n+    }\n+\n+    private void validateHeader(Declaration.Scoped top, boolean isAdd) {\n+        if (isWindows) {\n+            \/\/ TODO: add Windows validation\n+            \/\/ Simply dump declaration for now\n+            System.out.println(top);\n+            return;\n+        }\n+        var list = top.members().stream()\n+                .filter(byNameAndType(\"foo\", Declaration.Variable.class))\n+                .map(Declaration.Variable.class::cast)\n+                .collect(Collectors.toList());\n+        assertEquals(list.size(), 3);\n+        int hasAttrs = 0;\n+        for (Declaration.Variable foo: list) {\n+            assertEquals(Declaration.Variable.Kind.GLOBAL, foo.kind());\n+            assertTypeEquals(C_INT, foo.type());\n+            if (foo.getAttribute(ASMLABEL).isPresent()) {\n+                hasAttrs++;\n+                validateAsmLabel(foo, isAdd);\n+            }\n+        }\n+        assertEquals(hasAttrs, 2);\n+        var listFunc = top.members().stream()\n+                .filter(byNameAndType(\"func\", Declaration.Function.class))\n+                .map(Declaration.Function.class::cast)\n+                .collect(Collectors.toList());\n+        assertEquals(listFunc.size(), 3);\n+        hasAttrs = 0;\n+        for (Declaration.Function func: listFunc) {\n+            checkFunction(func, C_INT, C_INT, C_INT);\n+            if (func.getAttribute(ASMLABEL).isPresent()) {\n+                hasAttrs++;\n+                validateAsmLabel(func, isAdd);\n+            }\n+        }\n+        assertEquals(hasAttrs, 2);\n+    }\n+\n+    @Test\n+    public void testA() {\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\", \"-DADD\");\n+        validateHeader(d, true);\n+    }\n+\n+    @Test\n+    public void testB() {\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\");\n+        validateHeader(d, false);\n+    }\n+\n+    private static  Constable getSingleValue(Declaration d, String name) {\n+        List<Constable> values = d.getAttribute(name).get();\n+        assertEquals(1, values.size());\n+        return values.get(0);\n+    }\n+\n+    @Test\n+    public void testAddAttribute() {\n+        final String ts = \"timestamp\";\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\");\n+        String timestamp = LocalDateTime.now().format(DateTimeFormatter.ISO_DATE_TIME);\n+        Declaration withAttrs = d.withAttribute(\"header\", d.name())\n+                .withAttribute(ts, timestamp);\n+\n+        assertEquals(getSingleValue(withAttrs, \"header\"), d.name());\n+        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n+\n+        String timestamp2 = LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);\n+        Declaration withNewAttrs = withAttrs.withAttribute(ts, timestamp2);\n+        assertEquals(getSingleValue(withNewAttrs, ts), timestamp2);\n+\n+        \/\/ Make sure original Declaration is not altered\n+        assertEquals(getSingleValue(withAttrs, ts), timestamp);\n+\n+        \/\/ Add more value to same attribute\n+        withNewAttrs = withAttrs.withAttribute(ts, Stream.concat(\n+                withAttrs.getAttribute(ts).map(List::stream).orElse(Stream.empty()),\n+                Stream.of(timestamp2)\n+            ).toArray(Constable[]::new));\n+        assertEquals(withNewAttrs.getAttribute(ts).get(), List.of(timestamp, timestamp2));\n+        assertEquals(getSingleValue(withNewAttrs,\"header\"), d.name());\n+\n+        \/\/ Remove attribute\n+        withAttrs = withNewAttrs.withAttribute(ts);\n+        assertTrue(withAttrs.getAttribute(ts).isEmpty());\n+\n+        \/\/ Strip attribute\n+        withNewAttrs = withNewAttrs.stripAttributes();\n+        assertTrue(withNewAttrs.attributeNames().isEmpty());\n+    }\n+\n+    @Test\n+    public void replaceFunctionSymbol() {\n+        Declaration.Scoped d = parse(\"libAsmSymbol.h\", \"-DADD\");\n+        validateHeader(d, true);\n+\n+        var members = d.members().stream()\n+            .map(m -> m.getAttribute(ASMLABEL)\n+                    .map(attr -> m.withAttribute(ASMLABEL, attr.get(0).toString().replace('A', 'B')))\n+                    .orElse(m))\n+            .toArray(Declaration[]::new);\n+        Declaration.Scoped patched = Declaration.toplevel(d.pos(), members);\n+        validateHeader(patched, false);\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/TestAttributes.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8239128\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract TestMacros\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+public class TestMacros extends JextractApiTestBase {\n+    Declaration.Scoped badMacro;\n+    Declaration.Scoped foo;\n+    Declaration.Scoped bar;\n+    private final static Type C_INT = Type.primitive(Type.Primitive.Kind.Int);\n+\n+    @BeforeClass\n+    public void parse() {\n+        \/\/ We need stdint.h for pointer macro, otherwise evaluation failed and Constant declaration is not created\n+        Path builtinInc = Paths.get(System.getProperty(\"java.home\"), \"conf\", \"jextract\");\n+        badMacro = parse(\"badMacros.h\", \"-I\", builtinInc.toString());\n+\n+        foo = checkStruct(badMacro, \"foo\", \"ptrFoo\", \"ptrBar\");\n+        bar = checkStruct(badMacro, \"bar\", \"ptrFoo\", \"arFooPtr\");\n+    }\n+\n+    @Test\n+    public void testBadMacros() {\n+        checkConstant(badMacro, \"INVALID_INT_CONSUMER\",\n+            Type.pointer(Type.function(false, Type.void_(), C_INT)),\n+            0L);\n+        \/\/ Record type in macro definition are erased to void\n+        checkConstant(badMacro, \"NO_FOO\", Type.pointer(Type.declared(foo)), 0L);\n+        checkConstant(badMacro, \"INVALID_INT_ARRAY_PTR\", Type.pointer(Type.pointer(C_INT)), 0L);\n+    }\n+\n+    @Test\n+    public void verifyFunctions() {\n+        checkFunction(badMacro, \"func\", Type.void_(),\n+            Type.pointer(Type.declared(bar)), Type.pointer(Type.declared(foo)));\n+        checkFunction(badMacro, \"withArray\", Type.void_(),\n+            Type.pointer(Type.typedef(\"foo_t\", Type.pointer(Type.declared(foo)))));\n+    }\n+\n+    @Test\n+    public void verifyGlobals() {\n+        checkGlobal(badMacro, \"op\", Type.pointer(\n+                Type.function(false, Type.void_(), C_INT, Type.pointer(C_INT))));\n+    }\n+\n+    @Test\n+    public void verifyFields() {\n+        Type foo_t = Type.typedef(\"foo_t\", Type.pointer(Type.declared(foo)));\n+        checkField(foo, \"ptrFoo\", foo_t);\n+        checkField(foo, \"ptrBar\", Type.pointer(Type.declared(bar)));\n+        checkField(bar, \"ptrFoo\", foo_t);\n+        checkField(bar, \"arFooPtr\", Type.pointer(foo_t));\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/TestMacros.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @build JextractApiTestBase\n+ * @run testng\/othervm -ea --enable-native-access=jdk.incubator.jextract TestTypedef\n+ *\/\n+\n+import java.util.Set;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import jdk.incubator.jextract.Declaration;\n+import jdk.incubator.jextract.Type;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class TestTypedef extends JextractApiTestBase {\n+    Declaration.Scoped root;\n+\n+    @BeforeClass\n+    public void parse() {\n+        root = parse(\"testTypedef.h\");\n+        System.out.println(root);\n+    }\n+\n+    private Declaration[] findAllWithName(Declaration.Scoped scope, String name) {\n+        return scope.members().stream().filter(byName(name)).toArray(Declaration[]::new);\n+    }\n+\n+    public static Type getTypedefType(Declaration.Scoped scope, String name) {\n+        Declaration.Typedef d = findDecl(scope, name, Declaration.Typedef.class);\n+        Type type = d.type();\n+        \/\/ Typedef declaration should return canonical type\n+        if (type instanceof Type.Delegated) {\n+            assertNotEquals(((Type.Delegated) type).kind(), Type.Delegated.Kind.TYPEDEF);\n+        }\n+        return d.type();\n+    }\n+\n+    private Declaration.Scoped assertDeclaredTypedef(Declaration.Typedef decl) {\n+        Type type = decl.type();\n+        assertTrue(type instanceof Type.Declared, \"Expecting Type.Declared, got \" + type.getClass());\n+        return ((Type.Declared) type).tree();\n+    }\n+\n+    private Declaration.Scoped assertAnonymousRecord(Declaration.Scoped scope, String name) {\n+        Declaration[] ar = findAllWithName(scope, name);\n+        assertEquals(ar.length, 1);\n+        assertTrue(ar[0] instanceof Declaration.Typedef, \"Expectint Declaration.Typedef, but got \" + ar[0].getClass());\n+        Declaration.Scoped record = assertDeclaredTypedef((Declaration.Typedef) ar[0]);\n+        return record;\n+    }\n+\n+    private Declaration.Scoped assertNamedRecord(Declaration.Scoped scope, String name) {\n+        Declaration[] ar = findAllWithName(scope, name);\n+        assertEquals(ar.length, 1);\n+        assertTrue(ar[0] instanceof Declaration.Scoped, \"Expectint Declaration.Scoped, but got \" + ar[0].getClass());\n+        return (Declaration.Scoped) ar[0];\n+    }\n+\n+    @Test\n+    public void NoDuplicateSameNameTypedef() {\n+        \/\/ When typedef a named record with the same name, present the scoped\n+        \/\/ declaration and ignore the typedef\n+        Declaration.Scoped s = assertNamedRecord(root, \"Point3D\");\n+        assertEquals(s.kind(), Declaration.Scoped.Kind.STRUCT);\n+        checkNames(s.members(), \"i\", \"j\", \"k\");\n+\n+        s = assertNamedRecord(root, \"SIZE\");\n+        assertEquals(s.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(s.members(), \"XS\", \"S\", \"M\", \"L\", \"XL\");\n+    }\n+\n+    @Test\n+    public void TypedefReferences() {\n+        \/\/ When reference to a typedef, the Type should be Type.Delegated\n+        \/\/ With the type to be the referenced type\n+        Declaration.Scoped pt3d = checkStruct(root, \"Point3D\", \"i\", \"j\", \"k\");\n+        Declaration.Function drawParamid = findDecl(root, \"drawParamid\", Declaration.Function.class);\n+        Type.Function fnType = drawParamid.type();\n+        \/\/ Array in function argument is lowered to pointer\n+        Type type = TypeUnwrapper.of(fnType.argumentTypes().get(0))\n+                        .unwrapPointer().unwrapTypedef().get();\n+        assertEquals(type, Type.declared(pt3d));\n+\n+        Declaration.Function do_ops = findDecl(root, \"do_ops\", Declaration.Function.class);\n+        fnType = do_ops.type();\n+        type = unwrapTypedefType(fnType.returnType());\n+        assertEquals(type, getTypedefType(root, \"op_sequence\"));\n+        type = fnType.argumentTypes().get(0);\n+        type = unwrapTypedefType(type);\n+        assertEquals(type, getTypedefType(root, \"int_op\"));\n+        type = fnType.argumentTypes().get(1);\n+        type = unwrapTypedefType(type);\n+        assertEquals(type, getTypedefType(root, \"count_t\"));\n+    }\n+\n+    @Test\n+    public void TypedefsToSameType()  {\n+        \/\/ For typedef declaration, the type will be the canonical type\n+        \/\/ Which means, the type will not be another typedef\n+        \/\/ However, it can be other delegated type or an array\n+        Declaration.Scoped pt = checkStruct(root, \"Point\", \"i\", \"j\");\n+        Type.Declared type = Type.declared(pt);\n+        assertEquals(getTypedefType(root, \"POINT\"), type);\n+        assertEquals(getTypedefType(root, \"point_t\"), type);\n+\n+        Type canonical = TypeUnwrapper.of(getTypedefType(root, \"rectangle\"))\n+                .unwrapArray(4)\n+                \/\/ FIXME? If we would like to generate array using typedef type\n+                \/\/ then we need to use typedef as array element type and\n+                \/\/ requires following line to pass the test.\n+                \/\/ .unwrapTypedef()\n+                .get();\n+        assertEquals(canonical, type);\n+\n+        Declaration.Variable canvas = findDecl(root, \"canvas\", Declaration.Variable.class);\n+        assertEquals(canvas.kind(), Declaration.Variable.Kind.GLOBAL);\n+        Type ref = TypeUnwrapper.of(canvas.type())\n+            .unwrapTypedef()\n+            .unwrapArray(4)\n+            .get();\n+        assertEquals(ref, type);\n+\n+        getTypedefType(root, \"count_t\");\n+    }\n+\n+    @Test\n+    public void TypedefsArrays()  {\n+        Type intType = getTypedefType(root, \"cordinate_t\");\n+\n+        \/\/ As noted earlier, we currently have canonical array element type from typedef\n+        Type type = getTypedefType(root, \"location2D\");\n+        Type elementType = unwrapArrayType(type, 2);\n+        assertEquals(elementType, intType);\n+\n+        Type count_t = getTypedefType(root, \"count_t\");\n+        type = getTypedefType(root, \"dimensions\");\n+        elementType = unwrapArrayType(type);\n+        assertEquals(elementType, count_t);\n+        type = getTypedefType(root, \"count_ptr\");\n+        assertEquals(type, Type.pointer(count_t));\n+    }\n+\n+    @Test\n+    public void AnonymousRecordTypedef() {\n+        \/\/ For anonymous typedef, present the typedef declaration and\n+        \/\/ the Scope declaration can be obtained via Variable.type()\n+        Declaration.Scoped record = assertAnonymousRecord(root, \"op_sequence\");\n+        assertEquals(record.kind(), Declaration.Scoped.Kind.STRUCT);\n+        checkNames(record.members(), \"times\", \"op\");\n+\n+        record = assertAnonymousRecord(root, \"IntOrFloat\");\n+        assertEquals(record.kind(), Declaration.Scoped.Kind.UNION);\n+        checkNames(record.members(), \"i\", \"f\");\n+\n+        record = assertAnonymousRecord(root, \"codetype_t\");\n+        assertEquals(record.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(record.members(), \"Java\", \"C\", \"CPP\", \"Python\", \"Ruby\");\n+    }\n+\n+    @Test\n+    public void CheckAnonyousDeclarations() {\n+        \/\/ Should we expunge anonymous declaration?\n+        \/\/ They only needed if referenced as a field or gloabal variable\n+        \/\/ Exception enum, as they can be used as pleased, so we need to\n+        \/\/ elevate them into constants.\n+        \/\/ Anyhow, current implementation pass through enum, not elevate them.\n+        \/\/ So we just check that\n+        Declaration[] ar = findAllWithName(root, \"\");\n+        assertEquals(ar.length, 2);\n+        Declaration.Scoped e = (Declaration.Scoped) ar[0];\n+        assertEquals(e.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(e.members(), \"RED\", \"GREEN\", \"BLUE\");\n+        e = (Declaration.Scoped) ar[1];\n+        assertEquals(e.kind(), Declaration.Scoped.Kind.ENUM);\n+        checkNames(e.members(), \"Java\", \"C\", \"CPP\", \"Python\", \"Ruby\");\n+    }\n+\n+    @Test\n+    public void CheckFunctionPointers() {\n+        Type intType = getTypedefType(root, \"cordinate_t\");\n+        Type intOpType = getTypedefType(root, \"int_op\");\n+        assertEquals(intOpType, Type.pointer(Type.function(false, intType, intType)));\n+        Type intOp2Type = getTypedefType(root, \"int_op2\");\n+        assertEquals(intOp2Type, Type.pointer(Type.function(false, intType, intType, intType)));\n+\n+        checkGlobal(root, \"another_int_op\", intOpType);\n+\n+        Declaration.Function getFn = findDecl(root, \"getFn\", Declaration.Function.class);\n+        assertEquals(getFn.parameters().size(), 0);\n+        Type.Delegated retType = (Type.Delegated) getFn.type().returnType();\n+        assertTrue(retType.kind() == Type.Delegated.Kind.POINTER);\n+        Type.Function fnType = (Type.Function) retType.type();\n+        assertEquals(fnType.returnType(), Type.void_());\n+        assertEquals(fnType.argumentTypes().get(1),\n+                Type.typedef(\"count_t\", getTypedefType(root, \"count_t\")));\n+    }\n+}\n","filename":"test\/jdk\/java\/jextract\/TestTypedef.java","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Macro of constant function pointer\n+#define INVALID_INT_CONSUMER         (void (*)(int))0\n+\n+struct foo;\n+typedef struct foo *foo_t;\n+struct bar;\n+\n+\/\/ Macro of constant struct pointer\n+#define NO_FOO ((foo_t)0)\n+\n+\/\/ Cases where resolving introduce new type references\n+\/\/ Pointer to pointer in macro\n+#define INVALID_INT_ARRAY_PTR (int**) 0\n+\/\/ Function pointer with pointer type argument\n+void (*op)(int cnt, int* operands);\n+void func(struct bar *pBar, struct foo *pFoo);\n+\n+\/\/ Cyclic struct pointer within struct definitions\n+struct foo {\n+    foo_t ptrFoo;\n+    struct bar *ptrBar;\n+};\n+\n+struct bar {\n+    foo_t ptrFoo;\n+    foo_t *arFooPtr;\n+};\n+\n+\/\/ Function with array to pointer\n+void withArray(foo_t ar[2]);\n","filename":"test\/jdk\/java\/jextract\/badMacros.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+  #ifdef IMPL\n+    #define EXPORT __declspec(dllexport)\n+  #else\n+    #define EXPORT __declspec(dllimport)\n+  #endif \/\/ IMPL\n+#else\n+#define EXPORT\n+#endif \/\/_WIN64\n+\n+#ifdef _WIN32\n+\/\/ Windows doesn't really support asm symbol, this is similar approach for C code to\n+\/\/ achieve similar, but this won't work with Panama until we support such Macro\n+#ifdef ADD\n+#define foo fooA\n+#define func funcA\n+#else\n+#define foo fooB\n+#define func funcB\n+#endif \/\/ADD\n+#define ALIAS(sym)\n+\n+#elif __APPLE__\n+#define ALIAS(sym) __asm(\"_\" #sym)\n+#else\n+#define ALIAS(sym) __asm__(#sym)\n+#endif \/\/ _WIN32\n+\n+\/\/ We do 3 declarations to make sure we will pick up alias no matter the sequence of encounter\n+\/\/ Without alias\n+EXPORT extern int foo;\n+EXPORT int func (int x, int y);\n+\n+\/\/ With alias\n+#ifdef ADD\n+\n+EXPORT extern int foo ALIAS(fooA);\n+EXPORT int func (int x, int y) ALIAS(funcA);\n+\n+#else\n+\n+EXPORT extern int foo ALIAS(fooB);\n+EXPORT int func (int x, int y) ALIAS(funcB);\n+\n+#endif \/\/ ADD\n+\n+\/\/ Without alias again\n+EXPORT extern int foo;\n+EXPORT int func (int x, int y);\n+\n","filename":"test\/jdk\/java\/jextract\/libAsmSymbol.h","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library .. \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractApiTestBase\n+ * @bug 8249536\n+ * @summary jextract throw IllegalStateException for bitfields in nested anonymous structs\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract TestNestedBitfields\n+ *\/\n+public class TestNestedBitfields extends JextractApiTestBase {\n+\n+    @Test\n+    public void testNestedBitfields() {\n+        Declaration.Scoped d = parse(\"nestedbitfields.h\");\n+        Declaration.Scoped foo = checkStruct(d, \"Foo\", \"\");\n+        Declaration.Scoped foo$anon = checkStruct(foo, \"\", \"\");\n+        checkBitfields(foo$anon, \"\", \"a\", \"b\");\n+\n+        Declaration.Scoped bar = checkStruct(d, \"Bar\", \"\");\n+        Declaration.Scoped bar$anon = checkStruct(bar, \"\", \"\");\n+        Declaration.Scoped bar$anon$anon = checkStruct(bar$anon, \"\", \"\");\n+        checkBitfields(bar$anon$anon, \"\", \"a\", \"b\");\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/jextract\/nestedBitfields\/TestNestedBitfields.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    struct {\n+        int a : 7;\n+        int b : 25;\n+    };\n+};\n+\n+struct Bar {\n+    struct {\n+        struct {\n+            int a : 7;\n+            int b : 25;\n+        };\n+    };\n+};\n+\n","filename":"test\/jdk\/java\/jextract\/nestedBitfields\/nestedbitfields.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/simple struct\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+\/\/global\n+struct Point p;\n+\n+\/\/function\n+int distance(struct Point p1, struct Point p2);\n+\n+\/\/function with arrays\n+char ** ch_ptr_ptr;\n+char** pointers(char* arr1[], char* arr2[]);\n+\n+\/\/and a constant\n+#define ZERO 0\n","filename":"test\/jdk\/java\/jextract\/smoke.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+typedef unsigned long count_t;\n+typedef int (*int_op)(int);\n+typedef int (*int_op2)(int, int);\n+\n+typedef struct {\n+    count_t times;\n+    int_op op;\n+} op_sequence;\n+\n+int_op add;\n+\n+\/\/ Global variable with unnamed function type\n+int (*another_int_op)(int);\n+\n+\/\/ Function prototype\n+op_sequence do_ops(int_op op, count_t times);\n+\n+\/\/ anonymous typedef\n+typedef union {\n+    int i;\n+    float f;\n+} IntOrFloat;\n+\n+\/\/ Completely anonymous enum\n+enum {\n+    RED = 0xff0000,\n+    GREEN = 0x00ff00,\n+    BLUE = 0x0000ff\n+};\n+\n+typedef enum SIZE {\n+    XS,\n+    S,\n+    M,\n+    L,\n+    XL\n+} SIZE;\n+\n+\/\/ Typedef anonymous enum\n+typedef enum {\n+   Java,\n+   C,\n+   CPP,\n+   Python,\n+   Ruby\n+} codetype_t;\n+\n+\/\/ declaration only\n+struct Point;\n+\/\/ definition\n+struct Point {\n+   int i;\n+   int j;\n+};\n+\/\/ different name struct typedef\n+typedef struct Point POINT;\n+\/\/ layered typedef\n+typedef POINT point_t;\n+typedef point_t rectangle[4];\n+\n+rectangle canvas;\n+\n+typedef int cordinate_t;\n+typedef cordinate_t location2D[2];\n+typedef count_t dimensions[];\n+typedef count_t *count_ptr;\n+\n+\/\/ same name struct typedef\n+typedef struct Point3D {\n+    int i;\n+    int j;\n+    int k;\n+} Point3D;\n+\/\/ User of same name typedef\n+void drawParamid(Point3D vertices[4]);\n+\n+\/\/ anonymous types not references\n+struct {\n+    int foo;\n+    int bar;\n+};\n+\n+static union {\n+    int i;\n+    long l;\n+};\n+\n+\/\/ No way to declare anonymous function type\n+\/\/ But here is a function getFn to return a function type\n+void (*getFn(void))(int, count_t, int_op);\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/jextract\/testTypedef.h","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build BadBitfieldTest\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract BadBitfieldTest\n+ *\/\n+\n+\/*\n+ * MSVC: (\/d1reportSingleClassLayoutFoo)\n+ * class Foo    size(24):\n+ *      +---\n+ *  0.    | a (bitstart=0,nbits=45)\n+ *  8.    | b (bitstart=0,nbits=24)\n+ *  8.    | c (bitstart=24,nbits=1)\n+ * 16.    | d (bitstart=0,nbits=58)\n+ *      +---\n+ *\n+ * SysV: (PAHole)\n+ * struct Foo {\n+ *     long long int a:45;                0:19   8\n+ *     long long int b:24;                0:251  8\n+ *     XXX 251 bits hole, try to pack\n+ *     long long int c:1;                 8:58   8\n+ *     long long int d:58;                8: 0   8\n+ *\n+ *     size: 16, cachelines: 1, members: 4\n+ *     bit holes: 1, sum bit holes: 251 bits\n+ *     bit_padding: 5 bits\n+ *     last cacheline: 16 bytes\n+ * };\n+ *\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+public class BadBitfieldTest extends JextractToolRunner {\n+    @Test\n+    public void testBadBitfield() {\n+        run(\"-d\", getOutputFilePath(\"badBitfieldsGen\").toString(),\n+                getInputFilePath(\"badBitfields.h\").toString()).checkSuccess();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/BadBitfieldTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertSame;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build ConstantsTest\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED ConstantsTest\n+ *\/\n+public class ConstantsTest extends JextractToolRunner {\n+    private Class<?> constants;\n+    private Path dirPath;\n+    private Loader loader;\n+\n+    @BeforeTest\n+    public void setup() {\n+        dirPath = getOutputFilePath(\"ConstantsTest_output\");\n+        run( \"-d\", dirPath.toString(), getInputFilePath(\"constants.h\").toString()).checkSuccess();\n+        loader = classLoader(dirPath);\n+        constants = loader.loadClass(\"constants_h\");\n+    }\n+\n+    @AfterTest\n+    public void cleanup() {\n+        constants = null;\n+        loader.close();\n+        deleteDir(dirPath);\n+    }\n+\n+    @Test(dataProvider = \"definedConstants\")\n+    public void checkConstantsTypesAndValues(String name, Class<?> type, Consumer<Object> checker) throws ReflectiveOperationException {\n+        var f = findMethod(constants, name);\n+        assertNotNull(f);\n+        assertSame(f.getReturnType(), type);\n+        f.setAccessible(true);\n+        Object actual = f.invoke(null);\n+        checker.accept(actual);\n+    }\n+\n+    @Test(dataProvider = \"missingConstants\")\n+    public void checkMissingConstants(String name) {\n+        assertTrue(findMethod(constants, name) == null);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] definedConstants() {\n+        return new Object[][] {\n+                { \"SUP\", int.class, equalsTo(5) },\n+                { \"ZERO\", int.class, equalsTo(0) },\n+                { \"ONE\", int.class, equalsTo(1) },\n+                { \"TWO\", int.class, equalsTo(2) },\n+                { \"THREE\", int.class, equalsTo(3) },\n+                { \"FOUR\", long.class, equalsTo(4L) },\n+                { \"FIVE\", long.class, equalsTo(5L) },\n+                { \"SIX\", int.class, equalsTo(6) },\n+                { \"FLOAT_VALUE\", float.class, equalsTo(1.32f) },\n+                { \"DOUBLE_VALUE\", double.class, (Consumer<Double>) (actual -> assertEquals(actual, 1.32, 0.1)) },\n+                { \"CHAR_VALUE\", int.class, equalsTo(104) }, \/\/integer char constants have type int\n+                { \"MULTICHAR_VALUE\", int.class, equalsTo(26728) },  \/\/integer char constants have type int\n+                { \"BOOL_VALUE\", byte.class, equalsTo((byte)1) },\n+                { \"SUB\", int.class, equalsTo( 7 ) },\n+                \/\/ pointer type values\n+                { \"STR\", MemorySegment.class, equalsToJavaStr(\"Hello\") },\n+                { \"QUOTE\", MemorySegment.class, equalsToJavaStr(\"QUOTE\") },\n+                { \"ZERO_PTR\", MemoryAddress.class, equalsPtrContents(0) },\n+                { \"F_PTR\", MemoryAddress.class, equalsPtrContents(0xFFFFFFFFFFFFFFFFL) },\n+        };\n+    }\n+\n+    static Consumer<Object> equalsTo(Object expected) {\n+        return actual -> assertEquals(actual, expected);\n+    }\n+\n+    static Consumer<MemorySegment> equalsToJavaStr(String expected) {\n+        return actual -> assertEquals(CLinker.toJavaString(actual), expected);\n+    }\n+\n+    static Consumer<MemoryAddress> equalsPtrContents(long expected) {\n+        return actual -> assertEquals(actual.toRawLongValue(), expected);\n+    }\n+\n+    @DataProvider\n+    public static Object[][] missingConstants() {\n+        return new Object[][] {\n+                { \"ID\" },\n+                { \"SUM\" },\n+                { \"BLOCK_BEGIN\" },\n+                { \"BLOCK_END\" },\n+                { \"INTEGER_MAX_VALUE\" },\n+                { \"CYCLIC_1\" },\n+                { \"CYCLIC_2\" },\n+                \/\/ array\n+                { \"ARRAY\" }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/ConstantsTest.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+void func(int);\n","filename":"test\/jdk\/tools\/jextract\/JDK-8248474.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.MemoryAddress;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240181\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract -Duser.language=en --add-modules jdk.incubator.jextract JextractToolProviderTest\n+ *\/\n+public class JextractToolProviderTest extends JextractToolRunner {\n+    @Test\n+    public void testHelp() {\n+        run().checkFailure(OPTION_ERROR); \/\/ no options\n+        run(\"--help\").checkSuccess();\n+        run(\"-h\").checkSuccess();\n+        run(\"-?\").checkSuccess();\n+    }\n+\n+    \/\/ error for non-existent header file\n+    @Test\n+    public void testNonExistentHeader() {\n+        run(getInputFilePath(\"non_existent.h\").toString())\n+            .checkFailure(INPUT_ERROR)\n+            .checkContainsOutput(\"cannot read header file\");\n+    }\n+\n+    \/\/ error for header including non_existent.h file\n+    @Test\n+    public void testNonExistentIncluder() {\n+        run(getInputFilePath(\"non_existent_includer.h\").toString())\n+            .checkFailure(CLANG_ERROR)\n+            .checkContainsOutput(\"file not found\");\n+    }\n+\n+    @Test\n+    public void testDirectoryAsHeader() {\n+        run(getInputFilePath(\"directory.h\").toString())\n+            .checkFailure(INPUT_ERROR)\n+            .checkContainsOutput(\"not a file\");\n+    }\n+\n+    \/\/ error for header with parser errors\n+    @Test\n+    public void testHeaderWithDeclarationErrors() {\n+        run(getInputFilePath(\"illegal_decls.h\").toString())\n+            .checkFailure(CLANG_ERROR)\n+            .checkContainsOutput(\"cannot combine with previous 'short' declaration specifier\");\n+    }\n+\n+    \/\/ @bug 8267504: jextract should report unsupported language and exit rather\n+    \/\/ than generating partial nonworking code\n+    @Test\n+    public void testUnsupportedLanguage() {\n+        run(\"-C-xc++\", getInputFilePath(\"unsupported_lang.h\").toString())\n+            .checkFailure(RUNTIME_ERROR)\n+            .checkContainsOutput(\"Unsupported language: C++\");\n+    }\n+\n+    @Test\n+    public void testOutputClass() {\n+        Path helloOutput = getOutputFilePath(\"hellogen\");\n+        Path helloH = getInputFilePath(\"hello.h\");\n+        run(\"-d\", helloOutput.toString(), helloH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(helloOutput)) {\n+            Class<?> cls = loader.loadClass(\"hello_h\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+        } finally {\n+            deleteDir(helloOutput);\n+        }\n+    }\n+\n+    private void testTargetPackage(String targetPkgOption) {\n+        Path helloOutput = getOutputFilePath(\"hellogen\");\n+        Path helloH = getInputFilePath(\"hello.h\");\n+        run(targetPkgOption, \"com.acme\", \"-d\",\n+            helloOutput.toString(), helloH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(helloOutput)) {\n+            Class<?> cls = loader.loadClass(\"com.acme.hello_h\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+        } finally {\n+            deleteDir(helloOutput);\n+        }\n+    }\n+\n+    @Test\n+    public void testTargetPackageOption() {\n+        testTargetPackage(\"-t\");\n+    }\n+\n+    @Test\n+    public void testTargetPackageLongOption() {\n+        testTargetPackage(\"--target-package\");\n+    }\n+\n+    @Test\n+    public void testHeaderClassName() {\n+        Path helloOutput = getOutputFilePath(\"hellogen\");\n+        Path helloH = getInputFilePath(\"hello.h\");\n+        run(\"--header-class-name\", \"MyHello\", \"-t\", \"com.acme\", \"-d\",\n+            helloOutput.toString(), helloH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(helloOutput)) {\n+            Class<?> cls = loader.loadClass(\"com.acme.MyHello\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+            \/\/ check a method for \"int printf(MemoryAddress, Object[])\"\n+            assertNotNull(findMethod(cls, \"printf\", Addressable.class, Object[].class));\n+        } finally {\n+            deleteDir(helloOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/JextractToolProviderTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.spi.ToolProvider;\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayout.PathElement;\n+import jdk.incubator.jextract.Type;\n+import jdk.test.lib.util.FileUtils;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+public class JextractToolRunner {\n+\n+    \/\/ (private) exit codes from jextract tool. Copied from JextractTool.\n+    static final int SUCCESS       = 0;\n+    static final int OPTION_ERROR  = 1;\n+    static final int INPUT_ERROR   = 2;\n+    static final int CLANG_ERROR   = 3;\n+    static final int RUNTIME_ERROR = 4;\n+    static final int OUTPUT_ERROR  = 5;\n+\n+    private static String safeFileName(String filename) {\n+        int ext = filename.lastIndexOf('.');\n+        return ext != -1 ? filename.substring(0, ext) : filename;\n+    }\n+\n+    private static final ToolProvider JEXTRACT_TOOL = ToolProvider.findFirst(\"jextract\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jextract tool not found\")\n+            );\n+\n+    private final Path inputDir;\n+    private final Path outputDir;\n+\n+    protected JextractToolRunner() {\n+        this(null, null);\n+    }\n+\n+    protected JextractToolRunner(Path input, Path output) {\n+        inputDir = (input != null) ? input :\n+                Paths.get(System.getProperty(\"test.src\", \".\"));\n+        outputDir = (output != null) ? output :\n+                Paths.get(System.getProperty(\"test.classes\", \".\"));\n+    }\n+\n+    protected Path getInputFilePath(String fileName) {\n+        return inputDir.resolve(fileName).toAbsolutePath();\n+    }\n+\n+    protected Path getOutputFilePath(String fileName) {\n+        return outputDir.resolve(fileName).toAbsolutePath();\n+    }\n+\n+    protected static class JextractResult {\n+        private int exitCode;\n+        private String output;\n+\n+        JextractResult(int exitCode, String output) {\n+            this.exitCode = exitCode;\n+            this.output = output;\n+        }\n+\n+        protected JextractResult checkSuccess() {\n+            assertEquals(exitCode, SUCCESS, \"Sucess expected, failed: \" + exitCode);\n+            return this;\n+        }\n+\n+        protected JextractResult checkFailure() {\n+            assertNotEquals(exitCode, SUCCESS, \"Failure expected, succeeded!\");\n+            return this;\n+        }\n+\n+        protected JextractResult checkFailure(int expectedExitCode) {\n+            assertEquals(exitCode, expectedExitCode, \"Expected error code \" + expectedExitCode);\n+            return this;\n+        }\n+\n+        protected JextractResult checkContainsOutput(String expected) {\n+            Objects.requireNonNull(expected);\n+            assertTrue(output.contains(expected), \"Output does not contain string: \" + expected);\n+            return this;\n+        }\n+\n+        protected JextractResult checkMatchesOutput(String regex) {\n+            Objects.requireNonNull(regex);\n+            assertTrue(output.trim().matches(regex), \"Output does not match regex: \" + regex);\n+            return this;\n+        }\n+    }\n+\n+    protected static JextractResult run(Object... options) {\n+        return run(Arrays.stream(options).map(Objects::toString).toArray(String[]::new));\n+    }\n+\n+    protected static JextractResult run(String... options) {\n+        StringWriter writer = new StringWriter();\n+        PrintWriter pw = new PrintWriter(writer);\n+        String[] args = new String[options.length + 1];\n+        int result = JEXTRACT_TOOL.run(pw, pw, options);\n+        String output = writer.toString();\n+        System.err.println(output);\n+        return new JextractResult(result, output);\n+    }\n+\n+    protected static void deleteFile(Path path) {\n+        try {\n+            FileUtils.deleteFileIfExistsWithRetry(path);\n+        } catch (IOException ioExp) {\n+            throw new RuntimeException(ioExp);\n+        }\n+    }\n+\n+    protected static void deleteDir(Path path) {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(path);\n+        } catch (IOException ioExp) {\n+            throw new RuntimeException(ioExp);\n+        }\n+    }\n+\n+    protected static Loader classLoader(Path... paths) {\n+        try {\n+            URL[] urls = new URL[paths.length];\n+            for (int i = 0; i < paths.length; i++) {\n+                urls[i] = paths[i].toUri().toURL();\n+            }\n+            URLClassLoader ucl = new URLClassLoader(urls,\n+                    JextractToolRunner.class.getClassLoader());\n+            return new Loader(ucl);\n+        } catch (RuntimeException re) {\n+            throw re;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    protected static Field findField(Class<?> cls, String name) {\n+        try {\n+            return cls.getField(name);\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            return null;\n+        }\n+    }\n+\n+    protected Method checkIntGetter(Class<?> cls, String name, int value) {\n+        Method method = findMethod(cls, name);\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), int.class);\n+        try {\n+            assertEquals((int)method.invoke(null), value);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return method;\n+    }\n+\n+    protected static Method findMethod(Class<?> cls, String name, Class<?>... argTypes) {\n+        try {\n+            return cls.getMethod(name, argTypes);\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            return null;\n+        }\n+    }\n+\n+    protected static Method findFirstMethod(Class<?> cls, String name) {\n+        try {\n+            for (Method m : cls.getMethods()) {\n+                if (name.equals(m.getName())) {\n+                    return m;\n+                }\n+            }\n+            return null;\n+        } catch (Exception e) {\n+            System.err.println(e);\n+            return null;\n+        }\n+    }\n+\n+    protected static Class<?> findNestedClass(Class<?> clz, String name) {\n+        return findClass(clz.getClasses(), name);\n+    }\n+\n+    protected static Class<?> findClass(Class<?>[] clz, String name) {\n+        for (Class<?> cls: clz) {\n+            if (cls.getSimpleName().equals(name)) {\n+                return cls;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    protected Method checkMethod(Class<?> cls, String name, MethodType type) {\n+        return checkMethod(cls, name, type.returnType(), type.parameterArray());\n+    }\n+\n+    protected Method checkMethod(Class<?> cls, String name, Class<?> returnType, Class<?>... args) {\n+        Method m = findMethod(cls, name, args);\n+        assertNotNull(m);\n+        assertEquals(m.getReturnType(), returnType);\n+        assertEquals(m.getParameterTypes(), args);\n+        return m;\n+    }\n+\n+    protected static MemoryLayout findLayout(Class<?> cls, String name) {\n+        Method method = findMethod(cls, name + \"$LAYOUT\");\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), MemoryLayout.class);\n+        try {\n+            return (MemoryLayout)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return null;\n+    }\n+\n+    protected static MemoryLayout findLayout(Class<?> cls) {\n+        return findLayout(cls, \"\");\n+    }\n+\n+    protected static void checkField(MemoryLayout group, String fieldName, MemoryLayout expected) {\n+        assertEquals(group.select(PathElement.groupElement(fieldName)), expected.withName(fieldName));\n+    }\n+\n+    protected static class Loader implements AutoCloseable {\n+\n+        private final URLClassLoader loader;\n+\n+        public Loader(URLClassLoader loader) {\n+            this.loader = loader;\n+        }\n+\n+        public Class<?> loadClass(String className) {\n+            try {\n+                return Class.forName(className, false, loader);\n+            } catch (ClassNotFoundException e) {\n+                \/\/ return null so caller can check if class loading\n+                \/\/ was successful with assertNotNull\/assertNull\n+                return null;\n+            }\n+        }\n+\n+        @Override\n+        public void close() {\n+            try {\n+                loader.close();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/JextractToolRunner.java","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.File;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class JtregJextract {\n+    private final Path inputDir;\n+    private final Path outputDir;\n+\n+    JtregJextract() {\n+        this(null, null);\n+    }\n+\n+    JtregJextract(Path input, Path output) {\n+        inputDir = (input != null) ? input :\n+                Paths.get(System.getProperty(\"test.src\", \".\"));\n+        outputDir = (output != null) ? output :\n+                Paths.get(System.getProperty(\"test.classes\", \".\"));\n+\n+    }\n+\n+    protected String[] processArgs(String... args) {\n+        Pattern sysPropPattern = Pattern.compile(\"'?\\\\$\\\\((.*)\\\\)'?\");\n+        ArrayList<String> jextrOpts = new ArrayList<>();\n+\n+        jextrOpts.clear();\n+        jextrOpts.add(\"-C-nostdinc\");\n+        jextrOpts.add(\"-I\");\n+        jextrOpts.add(inputDir.toAbsolutePath().toString());\n+        jextrOpts.add(\"-d\");\n+        jextrOpts.add(outputDir.toAbsolutePath().toString());\n+\n+        int i = 0;\n+        while (i < args.length) {\n+            String opt = args[i++];\n+            if (\"--\".equals(opt)) {\n+                break;\n+            }\n+\n+            if (\"-libpath\".equals(opt)) {\n+                String lib = args[i];\n+                jextrOpts.add(\"-l\");\n+                String libpath = System.getProperty(\"test.nativepath\") + File.separator + System.mapLibraryName(lib);\n+                System.err.println(\"jextract driver libpath passed: \" + libpath);\n+                jextrOpts.add(libpath);\n+                i++;\n+                continue;\n+            }\n+\n+            if (\"-d\".equals(opt)) {\n+                i++;\n+                continue;\n+            }\n+            \/\/ Pattern $(system.property.name) is replaced with the\n+            \/\/ value of the System property of that name.\n+            Matcher m = sysPropPattern.matcher(opt);\n+            if (m.matches()) {\n+                jextrOpts.add(System.getProperty(m.group(1)));\n+            } else {\n+                jextrOpts.add(opt);\n+            }\n+        }\n+\n+        while (i < args.length) {\n+            jextrOpts.add(getInputFilePath(args[i++]).toString());\n+        }\n+\n+        return jextrOpts.toArray(String[]::new);\n+    }\n+\n+    protected int jextract(String... options) {\n+        String[] args = processArgs(options);\n+        String[] commands = new String[args.length + 1];\n+        commands[0] = Paths.get(System.getProperty(\"test.jdk\"), \"bin\", \"jextract\").toString();\n+        System.arraycopy(args, 0, commands, 1, args.length);\n+        try {\n+            Process proc = new ProcessBuilder(commands).inheritIO().start();\n+            int result = proc.waitFor();\n+            if (result != 0) {\n+                throw new RuntimeException(\"jextract returns non-zero value\");\n+            }\n+            return result;\n+        } catch (IOException ioExp) {\n+            throw new UncheckedIOException(ioExp);\n+        } catch (InterruptedException intExp) {\n+            throw new RuntimeException(intExp);\n+        }\n+    }\n+\n+    private Path getInputFilePath(String filename) {\n+        return inputDir.resolve(filename).toAbsolutePath();\n+    }\n+\n+    public static int main(String[] args) {\n+        JtregJextract jj =  new JtregJextract();\n+        return jj.jextract(args);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/JtregJextract.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.lang.reflect.Array;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class JtregJextractSources {\n+    private static Path getJextractSourcePath() {\n+        Path testSrc = Path.of(System.getProperty(\"test.file\"));\n+        return Path.of(testSrc.toFile().getName() + \"_sources\");\n+    }\n+\n+    public static int main(String[] args) throws IOException {\n+        System.err.println(\"jextract --source mode\");\n+        Path sourcePath = getJextractSourcePath();\n+        JtregJextract jj =  new JtregJextract(null, sourcePath);\n+        String[] newArgs = new String[args.length + 1];\n+        newArgs[0] = \"--source\";\n+        System.arraycopy(args, 0, newArgs, 1, args.length);\n+        jj.jextract(newArgs);\n+\n+        Path outputDir = Paths.get(System.getProperty(\"test.classes\", \".\"));\n+\n+        List<String> files = Files.find(sourcePath.toAbsolutePath(), 999, (path, ignored) -> path.toString().endsWith(\".java\"))\n+                .map(p -> p.toAbsolutePath().toString())\n+                .collect(Collectors.toList());\n+\n+        System.err.println(\"compiling jextracted sources @ \" + sourcePath.toAbsolutePath());\n+        List<String> commands = new ArrayList<>();\n+        commands.add(Paths.get(System.getProperty(\"test.jdk\"), \"bin\", \"javac\").toString());\n+        commands.add(\"--add-modules\");\n+        commands.add(\"jdk.incubator.foreign\");\n+        commands.add(\"-d\");\n+        commands.add(outputDir.toAbsolutePath().toString());\n+        commands.addAll(files);\n+\n+        try {\n+            Process proc = new ProcessBuilder(commands).inheritIO().start();\n+            int result = proc.waitFor();\n+            if (result != 0) {\n+                throw new RuntimeException(\"javac returns non-zero value: \" + result);\n+            }\n+            return result;\n+        } catch (IOException ioExp) {\n+            throw new UncheckedIOException(ioExp);\n+        } catch (InterruptedException intExp) {\n+            throw new RuntimeException(intExp);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/JtregJextractSources.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8240300\n+ * @summary jextract produces non compilable code with repeated declarations\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED RepeatedDeclsTest\n+ *\/\n+public class RepeatedDeclsTest extends JextractToolRunner {\n+    @Test\n+    public void repeatedDecls() throws Throwable {\n+        Path repeatedDeclsOutput = getOutputFilePath(\"repeatedDeclsgen\");\n+        Path repeatedDeclsH = getInputFilePath(\"repeatedDecls.h\");\n+        run(\"-d\", repeatedDeclsOutput.toString(), repeatedDeclsH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(repeatedDeclsOutput)) {\n+            Class<?> cls = loader.loadClass(\"repeatedDecls_h\");\n+            \/\/ check a method for \"void func(int)\"\n+            assertNotNull(findMethod(cls, \"func\", int.class));\n+\n+            \/\/ check a method for \"void func2(int)\"\n+            assertNotNull(findMethod(cls, \"func2\", int.class));\n+\n+            \/\/ check a method for \"void func3(int*)\"\n+            assertNotNull(findMethod(cls, \"func3\", Addressable.class));\n+\n+            \/\/ check a method for \"void func4(int*)\"\n+            assertNotNull(findMethod(cls, \"func4\", Addressable.class));\n+\n+            \/\/ check a method for \"void func5(int)\"\n+            assertNotNull(findMethod(cls, \"func5\", int.class));\n+\n+            \/\/ check a method for \"double distance(struct Point)\"\n+            assertNotNull(findMethod(cls, \"distance\", MemorySegment.class));\n+\n+            \/\/ check a getter method for \"i\"\n+            assertNotNull(findMethod(cls, \"i$get\"));\n+\n+            \/\/ check a setter method for \"i\"\n+            assertNotNull(findMethod(cls, \"i$set\", int.class));\n+\n+            \/\/ make sure that enum constants are generated fine\n+            checkIntGetter(cls, \"R\", 0);\n+            checkIntGetter(cls, \"G\", 1);\n+            checkIntGetter(cls, \"B\", 2);\n+            checkIntGetter(cls, \"C\", 0);\n+            checkIntGetter(cls, \"M\", 1);\n+            checkIntGetter(cls, \"Y\", 2);\n+\n+            \/\/ check Point layout\n+            Class<?> pointCls = loader.loadClass(\"Point\");\n+            checkPoint(pointCls);\n+            Class<?> point_tCls = loader.loadClass(\"Point_t\");\n+            checkPoint(point_tCls);\n+            assertTrue(pointCls.isAssignableFrom(point_tCls));\n+            Class<?> point$0Cls = loader.loadClass(\"POINT$0\");\n+            checkPoint(point$0Cls);\n+            assertTrue(pointCls.isAssignableFrom(point$0Cls));\n+\n+            \/\/ check Point3D layout\n+            Class<?> point3DCls = loader.loadClass(\"Point3D\");\n+            checkPoint3D(point3DCls);\n+            Class<?> point3D_tCls = loader.loadClass(\"Point3D_t\");\n+            checkPoint3D(point3D_tCls);\n+            assertTrue(point3DCls.isAssignableFrom(point3D_tCls));\n+        } finally {\n+            deleteDir(repeatedDeclsOutput);\n+        }\n+    }\n+\n+    private void checkPoint(Class<?> pointCls) {\n+        MemoryLayout pointLayout = findLayout(pointCls);\n+        assertNotNull(pointLayout);\n+        assertTrue(((GroupLayout)pointLayout).isStruct());\n+        checkField(pointLayout, \"i\", CLinker.C_INT);\n+        checkField(pointLayout, \"j\", CLinker.C_INT);\n+    }\n+\n+    private void checkPoint3D(Class<?> point3DCls) {\n+        MemoryLayout point3DLayout = findLayout(point3DCls);\n+        assertNotNull(point3DLayout);\n+        assertTrue(((GroupLayout)point3DLayout).isStruct());\n+        checkField(point3DLayout, \"i\", CLinker.C_INT);\n+        checkField(point3DLayout, \"j\", CLinker.C_INT);\n+        checkField(point3DLayout, \"k\", CLinker.C_INT);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/RepeatedDeclsTest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240181\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED -Duser.language=en --add-modules jdk.incubator.jextract Test8240181\n+ *\/\n+public class Test8240181 extends JextractToolRunner {\n+    @Test\n+    public void testAnonymousEnum() {\n+        Path anonenumOutput = getOutputFilePath(\"anonenumgen\");\n+        Path anonenumH = getInputFilePath(\"anonenum.h\");\n+        run(\"-d\", anonenumOutput.toString(), anonenumH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(anonenumOutput)) {\n+            Class<?> cls = loader.loadClass(\"anonenum_h\");\n+            checkIntGetter(cls, \"RED\", 0xff0000);\n+            checkIntGetter(cls, \"GREEN\", 0x00ff00);\n+            checkIntGetter(cls, \"BLUE\", 0x0000ff);\n+            checkIntGetter(cls, \"Java\", 0);\n+            checkIntGetter(cls, \"C\", 1);\n+            checkIntGetter(cls, \"CPP\", 2);\n+            checkIntGetter(cls, \"Python\", 3);\n+            checkIntGetter(cls, \"Ruby\", 4);\n+            checkIntGetter(cls, \"ONE\", 1);\n+            checkIntGetter(cls, \"TWO\", 2);\n+        } finally {\n+            deleteDir(anonenumOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8240181.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240657\n+ * @summary when Java keywords are used as identifiers in C header, jextract generates non-compilable java code\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8240657\n+ *\/\n+public class Test8240657 extends JextractToolRunner {\n+    @Test\n+    public void testKeywordIdentifiers() {\n+        Path exportsOutput = getOutputFilePath(\"exportsgen\");\n+        Path exportsH = getInputFilePath(\"exports.h\");\n+        run(\"-d\", exportsOutput.toString(), exportsH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(exportsOutput)) {\n+            Class<?> cls = loader.loadClass(\"exports_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            deleteDir(exportsOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8240657.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240752\n+ * @summary jextract generates non-compilable code for special floating point values\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8240752\n+ *\/\n+public class Test8240752 extends JextractToolRunner {\n+    private float getFloatConstant(Class<?> cls, String name) {\n+        Method method = findMethod(cls, name);\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), float.class);\n+        try {\n+            return (float)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return 0.0f;\n+    }\n+\n+    private double getDoubleConstant(Class<?> cls, String name) {\n+        Method method = findMethod(cls, name);\n+        assertNotNull(method);\n+        assertEquals(method.getReturnType(), double.class);\n+        try {\n+            return (double)method.invoke(null);\n+        } catch (Exception exp) {\n+            System.err.println(exp);\n+            assertTrue(false, \"should not reach here\");\n+        }\n+        return 0.0d;\n+    }\n+\n+    @Test\n+    public void testConstants() {\n+        Path floatConstsOutput = getOutputFilePath(\"floatconstsgen\");\n+        Path floatConstsH = getInputFilePath(\"float_constants.h\");\n+        run(\"-d\", floatConstsOutput.toString(), floatConstsH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(floatConstsOutput)) {\n+            Class<?> cls = loader.loadClass(\"float_constants_h\");\n+            assertNotNull(cls);\n+\n+            double d = getDoubleConstant(cls, \"NAN\");\n+            assertTrue(Double.isNaN(d));\n+            d = getDoubleConstant(cls, \"PINFINITY\");\n+            assertTrue(Double.isInfinite(d) && d > 0);\n+            d = getDoubleConstant(cls, \"NINFINITY\");\n+            assertTrue(Double.isInfinite(d) && d < 0);\n+\n+            float f = getFloatConstant(cls, \"NANF\");\n+            assertTrue(Float.isNaN(f));\n+            f = getFloatConstant(cls, \"PINFINITYF\");\n+            assertTrue(Float.isInfinite(f) && f > 0);\n+            f = getFloatConstant(cls, \"NINFINITYF\");\n+            assertTrue(Float.isInfinite(f) && f < 0);\n+        } finally {\n+            deleteDir(floatConstsOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8240752.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8240811\n+ * @summary jextract generates non-compilable code for name collision between a struct and a global variable\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8240811\n+ *\/\n+public class Test8240811 extends JextractToolRunner {\n+    @Test\n+    public void testNameCollision() {\n+        Path nameCollisionOutput = getOutputFilePath(\"name_collision_gen\");\n+        Path nameCollisionH = getInputFilePath(\"name_collision.h\");\n+        run(\"-d\", nameCollisionOutput.toString(), nameCollisionH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(nameCollisionOutput)) {\n+            Class<?> cls = loader.loadClass(\"name_collision_h\");\n+            assertNotNull(cls);\n+\n+            \/\/ check foo layout\n+            Class<?> fooCls = loader.loadClass(\"foo\");\n+            MemoryLayout fooLayout = findLayout(fooCls);\n+            assertNotNull(fooLayout);\n+            assertTrue(((GroupLayout)fooLayout).isStruct());\n+            checkField(fooLayout, \"x\",  CLinker.C_INT);\n+            checkField(fooLayout, \"y\",  CLinker.C_INT);\n+            checkField(fooLayout, \"z\",  CLinker.C_INT);\n+\n+            MemoryLayout fooVarLayout = findLayout(cls, \"foo\");\n+            assertNotNull(fooVarLayout);\n+\n+            \/\/ check foo2 layout\n+            Class<?> foo2Cls = loader.loadClass(\"foo2\");\n+            MemoryLayout foo2Layout = findLayout(foo2Cls);\n+            assertNotNull(foo2Layout);\n+            assertTrue(((GroupLayout)foo2Layout).isUnion());\n+            checkField(foo2Layout, \"i\",  CLinker.C_INT);\n+            checkField(foo2Layout, \"l\",  CLinker.C_LONG);\n+\n+            MemoryLayout foo2VarLayout = findLayout(cls, \"foo2\");\n+            assertNotNull(foo2VarLayout);\n+\n+            MemoryLayout barVarLayout = findLayout(cls, \"bar\");\n+            assertNotNull(barVarLayout);\n+\n+            \/\/ check bar layout\n+            Class<?> barCls = loader.loadClass(\"bar\");\n+            MemoryLayout barLayout = findLayout(barCls);\n+            assertNotNull(barLayout);\n+            assertTrue(((GroupLayout)barLayout).isStruct());\n+            checkField(barLayout, \"f1\",  CLinker.C_FLOAT);\n+            checkField(barLayout, \"f2\",  CLinker.C_FLOAT);\n+\n+            MemoryLayout bar2VarLayout = findLayout(cls, \"bar2\");\n+            assertNotNull(bar2VarLayout);\n+\n+            \/\/ check bar layout\n+            Class<?> bar2Cls = loader.loadClass(\"bar2\");\n+            MemoryLayout bar2Layout = findLayout(bar2Cls);\n+            assertNotNull(bar2Layout);\n+            assertTrue(((GroupLayout)bar2Layout).isUnion());\n+            checkField(bar2Layout, \"f\",  CLinker.C_FLOAT);\n+            checkField(bar2Layout, \"d\",  CLinker.C_DOUBLE);\n+        } finally {\n+            deleteDir(nameCollisionOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8240811.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.jextract.Declaration;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @bug 8241650\n+ * @summary jextract module should be mapped to application class loader\n+ * @run testng Test8241650\n+ *\/\n+public class Test8241650 {\n+    @Test\n+    public void testClassLoader() {\n+        assertTrue(ClassLoader.getSystemClassLoader() == Declaration.class.getClassLoader());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8241650.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8244412\n+ * @summary jextract should generate static utils class for primitive typedefs\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8244412\n+ *\/\n+public class Test8244412 extends JextractToolRunner {\n+    @Test\n+    public void testPrimitiveTypedefs() {\n+        Path typedefsOutput = getOutputFilePath(\"typedefsgen\");\n+        Path typedefsH = getInputFilePath(\"typedefs.h\");\n+        run(\"-d\", typedefsOutput.toString(), typedefsH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(typedefsOutput)) {\n+            Class<?> headerCls = loader.loadClass(\"typedefs_h\");\n+            assertNotNull(findField(headerCls, \"byte_t\"));\n+            assertNotNull(findField(headerCls, \"mysize_t\"));\n+        } finally {\n+            deleteDir(typedefsOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8244412.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8245767\n+ * @summary jextract crashes with typedef on a opaque struct or union\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8245767\n+ *\/\n+public class Test8245767 extends JextractToolRunner {\n+    @Test\n+    public void testTypedefs() {\n+        Path test8245767Output = getOutputFilePath(\"test8245767_gen\");\n+        Path test8245767H = getInputFilePath(\"test8245767.h\");\n+        run(\"-d\", test8245767Output.toString(), test8245767H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8245767Output)) {\n+            Class<?> cls = loader.loadClass(\"test8245767_h\");\n+            assertNotNull(cls);\n+\n+            \/\/ class should be generated for typedef on opaque struct\n+            Class<?> fooCls = loader.loadClass(\"Foo\");\n+            assertNotNull(fooCls);\n+\n+            \/\/ check Point_t\n+            Class<?> point_tCls = loader.loadClass(\"Point_t\");\n+            assertNotNull(point_tCls);\n+\n+            \/\/ check Point\n+            Class<?> pointCls = loader.loadClass(\"Point\");\n+            assertNotNull(pointCls);\n+            assertTrue(pointCls.isAssignableFrom(point_tCls));\n+        } finally {\n+            deleteDir(test8245767Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8245767.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8248415\n+ * @summary jextract does not generate getter and setter for pointer typed fields in structs\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8248415\n+ *\/\n+public class Test8248415 extends JextractToolRunner {\n+\n+    @Test\n+    public void testPointerFields() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8248415.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> nodeClass = loader.loadClass(\"Node\");\n+\n+            \/\/ Check if getters for pointer fields were generated\n+            checkMethod(nodeClass, \"next$get\", MemoryAddress.class, MemorySegment.class);\n+            checkMethod(nodeClass, \"next$get\", MemoryAddress.class, MemorySegment.class, long.class);\n+\n+            \/\/ Check if setters for pointer fields were generated\n+            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, MemoryAddress.class);\n+            checkMethod(nodeClass, \"next$set\", void.class, MemorySegment.class, long.class, MemoryAddress.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8248415.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8248474\n+ * @summary jextract uses header file name as part of identifier\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8248474\n+ *\/\n+public class Test8248474 extends JextractToolRunner {\n+    @Test\n+    public void testUnsafeHeaderName() {\n+        Path test8248474Output = getOutputFilePath(\"test8248474_gen\");\n+        Path test8248474H = getInputFilePath(\"JDK-8248474.h\");\n+        run(\"-d\", test8248474Output.toString(), test8248474H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8248474Output)) {\n+            Class<?> cls = loader.loadClass(\"JDK_8248474_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            deleteDir(test8248474Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8248474.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.Addressable;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8249290\n+ * @summary jextract does not handle void typedef in function pointer argument\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8249290\n+ *\/\n+public class Test8249290 extends JextractToolRunner {\n+    @Test\n+    public void testVoidTypedef() {\n+        Path outputPath = getOutputFilePath(\"output8249290\");\n+        Path headerFile = getInputFilePath(\"test8249290.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> headerClass = loader.loadClass(\"test8249290_h\");\n+            checkMethod(headerClass, \"func\", void.class, Addressable.class);\n+            Class<?> fiClass = loader.loadClass(\"func$f\");\n+            checkMethod(fiClass, \"apply\", void.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8249290.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+\n+import jdk.incubator.foreign.Addressable;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8249300\n+ * @summary jextract does not handle empty parameter list of a function pointer parameters\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8249300\n+ *\/\n+public class Test8249300 extends JextractToolRunner {\n+    @Test\n+    public void testVoidTypedef() {\n+        Path outputPath = getOutputFilePath(\"output8249300\");\n+        Path headerFile = getInputFilePath(\"test8249300.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> headerClass = loader.loadClass(\"test8249300_h\");\n+            checkMethod(headerClass, \"func\", void.class, Addressable.class);\n+            Class<?> fiClass = loader.loadClass(\"func$f\");\n+            checkMethod(fiClass, \"apply\", void.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8249300.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8251943\n+ * @summary jextract should not generate MemorySegment typed fields for variables, struct fields if layout size info is not available\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8251943\n+ *\/\n+public class Test8251943 extends JextractToolRunner {\n+\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8251943.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> headerClass = loader.loadClass(\"test8251943_h\");\n+            assertNull(findMethod(headerClass, \"tzname$SEGMENT\"));\n+\n+            Class<?> fooClass = loader.loadClass(\"Foo\");\n+            assertNotNull(findMethod(fooClass, \"bar$get\", MemorySegment.class));\n+            assertNull(findMethod(fooClass, \"names$get\", MemorySegment.class));\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8251943.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8258223\n+ * @summary jextract throws exception when unsupport type is used in anonymous struct\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8258223\n+ *\/\n+public class Test8258223 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8258223Output = getOutputFilePath(\"test8258223_gen\");\n+        Path test8258223H = getInputFilePath(\"test8258223.h\");\n+        run(\"-d\", test8258223Output.toString(), test8258223H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8258223Output)) {\n+            Class<?> cls = loader.loadClass(\"test8258223_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            deleteDir(test8258223Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8258223.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8258405\n+ * @summary functional interfaces are not generated for struct fields\/global variables with function pointers\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8258405\n+ *\/\n+public class Test8258405 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8258405Output = getOutputFilePath(\"test8258405_gen\");\n+        Path test8258405H = getInputFilePath(\"test8258405.h\");\n+        run(\"-d\", test8258405Output.toString(), test8258405H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8258405Output)) {\n+            Class<?> cls = loader.loadClass(\"test8258405_h\");\n+            assertNotNull(cls);\n+            \/\/ check global function pointer variable 'func'\n+            cls = loader.loadClass(\"func\");\n+            assertNotNull(cls);\n+            assertNotNull(findMethod(cls, \"apply\", int.class));\n+            \/\/ check function pointer member 'bar' of struct 'Foo'\n+            cls = loader.loadClass(\"Foo$bar\");\n+            assertNotNull(cls);\n+            assertNotNull(findMethod(cls, \"apply\", float.class, double.class));\n+        } finally {\n+            deleteDir(test8258405Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8258405.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8260344\n+ * @summary jextract crashes with exception for log.h from libdebian-installer4-dev\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract -Duser.language=en --add-modules jdk.incubator.jextract Test8260344\n+ *\/\n+public class Test8260344 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8260344Output = getOutputFilePath(\"test8260344gen\");\n+        try {\n+            Path test8260344H = getInputFilePath(\"test8260344.h\");\n+            run(\"-d\", test8260344Output.toString(), test8260344H.toString()).checkSuccess();\n+        } finally {\n+            deleteDir(test8260344Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8260344.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8260705\n+ * @summary jextract crash with libbart's types.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8260705\n+ *\/\n+public class Test8260705 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8260705.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> FooClass = loader.loadClass(\"Foo\");\n+            checkMethod(FooClass, \"c$get\", byte.class, MemorySegment.class);\n+            checkMethod(FooClass, \"c$get\", byte.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"c$set\", void.class, MemorySegment.class, byte.class);\n+            checkMethod(FooClass, \"c$set\", void.class, MemorySegment.class, long.class, byte.class);\n+\n+            Class<?> Foo2Class = loader.loadClass(\"Foo2\");\n+            checkMethod(Foo2Class, \"z$get\", int.class, MemorySegment.class);\n+            checkMethod(Foo2Class, \"z$get\", int.class, MemorySegment.class, long.class);\n+            checkMethod(Foo2Class, \"z$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(Foo2Class, \"z$set\", void.class, MemorySegment.class, long.class, int.class);\n+            checkMethod(Foo2Class, \"w$get\", int.class, MemorySegment.class);\n+            checkMethod(Foo2Class, \"w$get\", int.class, MemorySegment.class, long.class);\n+            checkMethod(Foo2Class, \"w$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(Foo2Class, \"w$set\", void.class, MemorySegment.class, long.class, int.class);\n+\n+            assertNotNull(loader.loadClass(\"Foo3\"));\n+\n+            Class<?> Foo4Class = loader.loadClass(\"Foo4\");\n+            assertTrue(sizeof(Foo4Class) == 8L);\n+\n+            Class<?> Foo5Class = loader.loadClass(\"Foo5\");\n+            assertTrue(sizeof(Foo5Class) == 4L);\n+\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+\n+    private long sizeof(Class<?> cls) {\n+        Method m = findMethod(cls, \"sizeof\");\n+        try {\n+            return (long)m.invoke(null);\n+        } catch (Exception ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/tools\/jextract\/Test8260705.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8260717\n+ * @summary jextract crashes with 'Crossing storage unit boundaries' for libcoap's block.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8260717\n+ *\/\n+public class Test8260717 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8260717.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> FooClass = loader.loadClass(\"foo_t\");\n+            checkMethod(FooClass, \"s$get\", short.class, MemorySegment.class);\n+            checkMethod(FooClass, \"s$get\", short.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"s$set\", void.class, MemorySegment.class, short.class);\n+            checkMethod(FooClass, \"s$set\", void.class, MemorySegment.class, long.class, short.class);\n+\n+            checkMethod(FooClass, \"ptr$get\", MemoryAddress.class, MemorySegment.class);\n+            checkMethod(FooClass, \"ptr$get\", MemoryAddress.class, MemorySegment.class, long.class);\n+            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, MemoryAddress.class);\n+            checkMethod(FooClass, \"ptr$set\", void.class, MemorySegment.class, long.class, MemoryAddress.class);\n+\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8260717.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8260929\n+ * @summary jextract crashes with libdnet's rabdef.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8260929\n+ *\/\n+public class Test8260929 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path outputPath = getOutputFilePath(\"output\");\n+        Path headerFile = getInputFilePath(\"test8260929.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            assertNotNull(loader.loadClass(\"rab\"));\n+            Class<?> rab2Class = loader.loadClass(\"rab2\");\n+            assertNotNull(rab2Class);\n+\n+            checkMethod(rab2Class, \"y$get\", int.class, MemorySegment.class);\n+            checkMethod(rab2Class, \"y$get\", int.class, MemorySegment.class, long.class);\n+            checkMethod(rab2Class, \"y$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(rab2Class, \"y$set\", void.class, MemorySegment.class, long.class, int.class);\n+\n+            checkMethod(rab2Class, \"x$get\", short.class, MemorySegment.class);\n+            checkMethod(rab2Class, \"x$get\", short.class, MemorySegment.class, long.class);\n+            checkMethod(rab2Class, \"x$set\", void.class, MemorySegment.class, short.class);\n+            checkMethod(rab2Class, \"x$set\", void.class, MemorySegment.class, long.class, short.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8260929.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8261893\n+ * @summary jextract generates class names that are restricted type names\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract -Duser.language=en --add-modules jdk.incubator.jextract Test8261893\n+ *\/\n+public class Test8261893 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path test8261893Output = getOutputFilePath(\"test8261893gen\");\n+        Path test8261893H = getInputFilePath(\"test8261893.h\");\n+        run(\"-d\", test8261893Output.toString(), test8261893H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8261893Output)) {\n+            assertNotNull(loader.loadClass(\"permits_\"));\n+            assertNotNull(loader.loadClass(\"record_\"));\n+            assertNotNull(loader.loadClass(\"sealed_\"));\n+            assertNotNull(loader.loadClass(\"var_\"));\n+            assertNotNull(loader.loadClass(\"yield_\"));\n+        } finally {\n+            deleteDir(test8261893Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8261893.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262117\n+ * @summary jextract crashes with javac compilation error \"class u is already defined\"\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8262117\n+ *\/\n+public class Test8262117 extends JextractToolRunner {\n+    @Test\n+    public void testNameClash() {\n+        Path test8262117Output = getOutputFilePath(\"test8262117_gen\");\n+        Path test8262117H = getInputFilePath(\"test8262117.h\");\n+        run(\"-d\", test8262117Output.toString(), test8262117H.toString()).checkSuccess();\n+        try(Loader loader = classLoader(test8262117Output)) {\n+            Class<?> cls = loader.loadClass(\"test8262117_h\");\n+            assertNotNull(cls);\n+\n+            assertNotNull(loader.loadClass(\"u\"));\n+            assertNotNull(loader.loadClass(\"u$outer$u$0\"));\n+            assertNotNull(loader.loadClass(\"v\"));\n+            assertNotNull(loader.loadClass(\"v$v$0\"));\n+        } finally {\n+            deleteDir(test8262117Output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8262117.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262733\n+ * @summary jextract generates clashing names which results in compilation error with javac\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8262733\n+ *\/\n+public class Test8262733 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path output = getOutputFilePath(\"8262733gen\");\n+        Path outputH = getInputFilePath(\"test8262733.h\");\n+        run(\"-d\", output.toString(), outputH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(output)) {\n+            Class<?> cls = loader.loadClass(\"test8262733_h\");\n+            assertNotNull(cls);\n+        } finally {\n+            deleteDir(output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8262733.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262825\n+ * @summary jextract crashes when Java type names like String are used as identifiers in C header\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8262825\n+ *\/\n+public class Test8262825 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path output = getOutputFilePath(\"8262825gen\");\n+        Path outputH = getInputFilePath(\"test8262825.h\");\n+        run(\"-d\", output.toString(), outputH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(output)) {\n+            Class<?> cls = loader.loadClass(\"test8262825_h\");\n+            assertNotNull(cls);\n+\n+            assertNotNull(findField(cls, \"MemoryLayout_\"));\n+            assertNotNull(findField(cls, \"ValueLayout_\"));\n+\n+            assertNotNull(loader.loadClass(\"RuntimeHelper_\"));\n+            assertNotNull(loader.loadClass(\"String_\"));\n+            assertNotNull(loader.loadClass(\"MemoryAddress_\"));\n+            assertNotNull(loader.loadClass(\"MemorySegment_\"));\n+        } finally {\n+            deleteDir(output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8262825.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8262851\n+ * @summary jextract crashes with \"Cannot compute size of a layout which is, or depends on a sequence layout with unspecified size\"\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract Test8262851\n+ *\/\n+public class Test8262851 extends JextractToolRunner {\n+    @Test\n+    public void test() {\n+        Path output = getOutputFilePath(\"8262851gen\");\n+        Path outputH = getInputFilePath(\"test8262851.h\");\n+        run(\"-d\", output.toString(), outputH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(output)) {\n+            assertNotNull(loader.loadClass(\"test8262851_h\"));\n+            assertNotNull(loader.loadClass(\"Odd\"));\n+            assertNotNull(loader.loadClass(\"Odd$before\"));\n+            assertNotNull(loader.loadClass(\"Odd$after\"));\n+        } finally {\n+            deleteDir(output);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/Test8262851.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract -Duser.language=en --add-modules jdk.incubator.jextract TestFilters\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertNull;\n+import static org.testng.Assert.fail;\n+\n+public class TestFilters extends JextractToolRunner {\n+    @Test\n+    public void testFilter() {\n+        for (FilterKind expectedKind : FilterKind.values()) {\n+            Path filterOutput = getOutputFilePath(\"filters_\" + expectedKind);\n+            Path filterH = getInputFilePath(\"filters.h\");\n+            run(\"-d\", filterOutput.toString(), expectedKind.filterOption, expectedKind.symbolName, filterH.toString()).checkSuccess();\n+            try (Loader loader = classLoader(filterOutput)) {\n+                Class<?> cls = loader.loadClass(\"filters_h\");\n+                for (FilterKind kind : FilterKind.values()) {\n+                    Object res = kind.get(cls);\n+                    if (kind == expectedKind) {\n+                        assertNotNull(res);\n+                    } else {\n+                        assertNull(res);\n+                    }\n+                }\n+            } finally {\n+                deleteDir(filterOutput);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testDumpIncludes() throws IOException {\n+        Path filterOutput = getOutputFilePath(\"filters_dump\");\n+        try {\n+            Files.createDirectory(filterOutput);\n+            Path includes = filterOutput.resolve(\"test.conf\");\n+            Path filterH = getInputFilePath(\"filters.h\");\n+            run(\"--dump-includes\", includes.toString(), filterH.toString()).checkSuccess();\n+            List<String> includeLines = Files.readAllLines(includes);\n+            outer: for (FilterKind kind : FilterKind.values()) {\n+                String filterLine = kind.filterOption + \" \" + kind.symbolName;\n+                Iterator<String> linesIt = includeLines.iterator();\n+                while (linesIt.hasNext()) {\n+                    String line = linesIt.next();\n+                    if (line.startsWith(filterLine)) {\n+                        linesIt.remove();\n+                        continue outer;\n+                    }\n+                }\n+                fail(\"Filter line not found: \" + filterLine);\n+            }\n+        } finally {\n+            deleteDir(filterOutput);\n+        }\n+    }\n+\n+    enum FilterKind {\n+        VAR(\"_global\", \"--include-var\"),\n+        FUNCTION(\"_function\", \"--include-function\"),\n+        CONSTANT(\"_constant\", \"--include-macro\"),\n+        TYPEDEF(\"_typedef\", \"--include-typedef\"),\n+        STRUCT(\"_struct\", \"--include-struct\"),\n+        UNION(\"_union\", \"--include-union\");\n+\n+        final String symbolName;\n+        final String filterOption;\n+\n+        FilterKind(String symbolName, String filterOption) {\n+            this.symbolName = symbolName;\n+            this.filterOption = filterOption;\n+        }\n+\n+        Object get(Class<?> headerClass) {\n+            return switch (this) {\n+                case FUNCTION, CONSTANT -> findMethod(headerClass, symbolName);\n+                case VAR -> findMethod(headerClass, symbolName + \"$get\");\n+                case TYPEDEF -> findField(headerClass, symbolName);\n+                case STRUCT, UNION -> {\n+                    try {\n+                        yield headerClass.getClassLoader().loadClass(symbolName);\n+                    } catch (ReflectiveOperationException ex) {\n+                        yield null;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/TestFilters.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+import java.nio.file.Path;\n+import java.util.function.BiConsumer;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.groupElement;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.fail;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8244512 8252759\n+ * @summary test nested structs and unions\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract TestNested\n+ *\/\n+public class TestNested extends JextractToolRunner {\n+    @Test\n+    public void testNestedStructs() {\n+        Path nestedOutput = getOutputFilePath(\"nestedgen\");\n+        Path nestedH = getInputFilePath(\"nested.h\");\n+        run(\"-d\", nestedOutput.toString(), nestedH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(nestedOutput)) {\n+            checkClass(loader, \"Foo\",\n+                checkField(\"bar\", MemorySegment.class, 0),\n+                checkField(\"color\", int.class, 8)\n+            );\n+            checkClass(loader, \"Foo$Bar\",\n+                checkField(\"x\", int.class, 0),\n+                checkField(\"y\", int.class, 4)\n+            );\n+            checkClass(loader, \"U\",\n+                checkField(\"point\", MemorySegment.class, 0),\n+                checkField(\"rgb\", int.class, 0),\n+                checkField(\"i\", int.class, 0)\n+            );\n+            checkClass(loader, \"U$Point\",\n+                checkField(\"x\", short.class, 0),\n+                checkField(\"y\", short.class, 2)\n+            );\n+            checkClass(loader, \"MyStruct\",\n+                checkField(\"a\", byte.class, 0),\n+\n+                checkField(\"b\", int.class, 4, \"$anon$0\"),\n+                checkField(\"c\", int.class, 8, \"$anon$0\", \"$anon$0\"),\n+\n+                checkField(\"d\", byte.class, 12, \"$anon$0\"),\n+                checkField(\"f\", MemorySegment.class, 13, \"$anon$0\"),\n+\n+                checkField(\"g\", int.class, 16, \"$anon$1\"),\n+                checkField(\"h\", long.class, 16, \"$anon$1\"),\n+\n+                checkField(\"k\", MemorySegment.class, 24)\n+            );\n+            checkClass(loader, \"MyStruct$MyStruct_Z\",\n+                checkField(\"e\", byte.class, 0)\n+            );\n+            checkClass(loader, \"MyStruct$k\",\n+                checkField(\"i\", int.class, 0),\n+                checkField(\"j\", int.class, 4)\n+            );\n+            checkClass(loader, \"MyUnion\",\n+                checkField(\"a\", byte.class, 0),\n+\n+                checkField(\"b\", int.class, 0, \"$anon$0\"),\n+                checkField(\"c\", int.class, 4, \"$anon$0\", \"$anon$0\"),\n+\n+                checkField(\"d\", byte.class, 8, \"$anon$0\"),\n+                checkField(\"f\", MemorySegment.class, 9, \"$anon$0\"),\n+\n+                checkField(\"g\", int.class, 0, \"$anon$1\"),\n+                checkField(\"h\", int.class, 4, \"$anon$1\"),\n+\n+                checkField(\"k\", MemorySegment.class, 0)\n+            );\n+            checkClass(loader, \"MyUnion$MyUnion_Z\",\n+                checkField(\"e\", byte.class, 0)\n+            );\n+            checkClass(loader, \"MyUnion$k\",\n+                checkField(\"i\", int.class, 0),\n+                checkField(\"j\", long.class, 0)\n+            );\n+            checkClass(loader, \"X\",\n+                checkField(\"Z\", MemorySegment.class, 0, \"$anon$0\")\n+            );\n+            checkClass(loader, \"X$Z\",\n+                checkField(\"y\", int.class, 0)\n+            );\n+            checkClass(loader, \"X2\",\n+                checkField(\"y\", int.class, 0, \"$anon$0\", \"$anon$0\")\n+            );\n+            checkClass(loader, \"NestedUnion\",\n+                checkField(\"x\", int.class, 0),\n+                checkField(\"y\", int.class, 4, \"$anon$0\"),\n+                checkField(\"z\", int.class, 4, \"$anon$0\")\n+            );\n+        } finally {\n+            deleteDir(nestedOutput);\n+        }\n+    }\n+\n+    @SafeVarargs\n+    private static void checkClass(Loader loader, String name, BiConsumer<Class<?>, MemoryLayout>... checks) {\n+        Class<?> cls = loader.loadClass(name);\n+        assertNotNull(cls);\n+        MemoryLayout layout = findLayout(cls);\n+        for (var check : checks) {\n+            check.accept(cls, layout);\n+        }\n+    }\n+\n+    private static BiConsumer<Class<?>, MemoryLayout> checkField(String fieldName, Class<?> fieldType,\n+                                                                 long expectedOffset, String... fieldPath) {\n+        MemoryLayout.PathElement[] path = new MemoryLayout.PathElement[fieldPath.length + 1];\n+        int i = 0;\n+        for (; i < fieldPath.length; i++) {\n+            path[i] = groupElement(fieldPath[i]);\n+        }\n+        path[i] = groupElement(fieldName);\n+        return (cls, layout) -> {\n+            assertEquals(layout.byteOffset(path), expectedOffset);\n+            checkAccessors(cls, layout, fieldName, fieldType, layout.select(path));\n+        };\n+    }\n+\n+    private static void checkAccessors(Class<?> cls, MemoryLayout layout, String fieldName, Class<?> type,\n+                                       MemoryLayout fieldLayout) {\n+        try {\n+            if (type == MemorySegment.class) {\n+                Method slicer = cls.getMethod(fieldName + \"$slice\", MemorySegment.class);\n+                assertEquals(slicer.getReturnType(), MemorySegment.class);\n+                try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                    MemorySegment struct = MemorySegment.allocateNative(layout, scope);\n+                    MemorySegment slice = (MemorySegment) slicer.invoke(null, struct);\n+                    assertEquals(slice.byteSize(), fieldLayout.byteSize());\n+                }\n+            } else {\n+                Method getter = cls.getMethod(fieldName + \"$get\", MemorySegment.class);\n+                assertEquals(getter.getReturnType(), type);\n+                Method setter = cls.getMethod(fieldName + \"$set\", MemorySegment.class, type);\n+                assertEquals(setter.getReturnType(), void.class);\n+\n+                Object zero = MethodHandles.zero(type).invoke();\n+                try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                    MemorySegment struct = MemorySegment.allocateNative(layout, scope);\n+                    setter.invoke(null, struct, zero);\n+                    Object actual = getter.invoke(null, struct);\n+                    assertEquals(actual, zero);\n+                }\n+            }\n+        } catch (Throwable t) {\n+            fail(\"Unexpected exception\", t);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/TestNested.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @bug 8244512\n+ * @summary jextract throws NPE for a nested struct declaration\n+ * @run testng\/othervm -Djextract.decls.per.header=1 --enable-native-access=jdk.incubator.jextract TestSplit\n+ *\/\n+public class TestSplit extends JextractToolRunner {\n+    @Test\n+    public void testSplit() {\n+        Path splitOutput = getOutputFilePath(\"split\");\n+        Path splitH = getInputFilePath(\"split.h\");\n+        run(\"-d\", splitOutput.toString(), splitH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(splitOutput)) {\n+            checkPresent(loader, \"split_h\");\n+            checkPresent(loader, \"split_h_1\");\n+            checkPresent(loader, \"split_h_2\");\n+            checkPresent(loader, \"split_h_3\");\n+            checkPresent(loader, \"split_h_4\");\n+            checkMissing(loader, \"split_h_5\");\n+        } finally {\n+            deleteDir(splitOutput);\n+        }\n+    }\n+\n+    private static void checkPresent(Loader loader, String name) {\n+        assertNotNull(loader.loadClass(name));\n+    }\n+\n+    private static void checkMissing(Loader loader, String name) {\n+        assertNull(loader.loadClass(name));\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/TestSplit.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import org.testng.annotations.Test;\n+import java.nio.file.Path;\n+import jdk.incubator.foreign.GroupLayout;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ * @library \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract UniondeclTest\n+ *\/\n+public class UniondeclTest extends JextractToolRunner {\n+    @Test\n+    public void unionDecl() {\n+        Path uniondeclOutput = getOutputFilePath(\"uniondecl.h\");\n+        Path uniondeclH = getInputFilePath(\"uniondecl.h\");\n+        run(\"-d\", uniondeclOutput.toString(), uniondeclH.toString()).checkSuccess();\n+        try(Loader loader = classLoader(uniondeclOutput)) {\n+            Class<?> cls = loader.loadClass(\"uniondecl_h\");\n+            \/\/ check a method for \"void func(IntOrFloat*)\"\n+            assertNotNull(findMethod(cls, \"func\", Addressable.class));\n+            \/\/ check IntOrFloat layout\n+            Class<?> intOrFloatCls = loader.loadClass(\"IntOrFloat\");\n+            GroupLayout intOrFloatLayout = (GroupLayout)findLayout(intOrFloatCls);\n+            assertNotNull(intOrFloatLayout);\n+            assertTrue(intOrFloatLayout.isUnion());\n+            checkField(intOrFloatLayout, \"i\",  CLinker.C_INT);\n+            checkField(intOrFloatLayout, \"f\", CLinker.C_FLOAT);\n+        } finally {\n+            deleteDir(uniondeclOutput);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/UniondeclTest.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+enum {\n+    RED = 0xff0000,\n+    GREEN = 0x00ff00,\n+    BLUE = 0x0000ff\n+};\n+\n+typedef enum {\n+   Java,\n+   C,\n+   CPP,\n+   Python,\n+   Ruby\n+} codetype_t;\n+\n+enum SIZE {\n+   XS,\n+   S,\n+   M,\n+   L,\n+   XL,\n+   XXL\n+};\n+\n+typedef enum temp {\n+   ONE = 1,\n+   TWO\n+} temp_t;\n","filename":"test\/jdk\/tools\/jextract\/anonenum.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#pragma pack(1)\n+struct Foo {\n+    long long a: 45;\n+    long long b: 24;\n+    long long c: 1;\n+    long long d: 58;\n+};\n","filename":"test\/jdk\/tools\/jextract\/badBitfields.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"constants_aux.h\"\n+\n+#define ZERO 0\n+#define ONE ZERO + 1 \/\/backward ref\n+#define THREE ONE + TWO \/* forward ref *\/\n+#define TWO ONE + ONE\n+\n+#define FOUR (long long)0x1L + THREE \/\/hack: force long carrier\n+#define FIVE (long long)0x1UL + FOUR \/\/hack: force long carrier\n+\n+#define SIX ONE +\\\n+              TWO +\\\n+              THREE\n+\n+#define STR \"Hello\" \/\/ a string\n+\n+#define ID(x) x \/\/function-like\n+#define SUM(x,y) x + y \/\/function-like\n+\n+#define BLOCK_BEGIN { \/\/not a constant\n+#define BLOCK_END } \/\/not a constant\n+\n+#define INTEGER_MAX_VALUE Integer.MAX_VALUE \/\/constant in Java, not in C\n+#define QUOTE \"QUOTE\" \/\/should be ok\n+\n+#define FLOAT_VALUE 1.32F;\n+#define DOUBLE_VALUE 1.32;\n+\n+#define CYCLIC_1 1 + CYCLIC_1 \/\/cycle\n+\n+#define CYCLIC_2 1 + TEMP \/\/indirect cycle\n+#define TEMP 1 + CYCLIC_2\n+\n+#define CHAR_VALUE 'h'\n+#define MULTICHAR_VALUE 'hh'\n+\n+#define BOOL_VALUE (_Bool)1\n+\/\/we should have tests for char and shorts, but these are likely to be platform dependent\n+\n+#define SUB SUP + 2 \/\/dependency\n+\n+#define ZERO_PTR (void*)0;\n+#define F_PTR (void*) 0xFFFFFFFFFFFFFFFFLL; \/\/ all 1s\n+\n+#define ARRAY { 0, 1, 2, 3, 4, 5 }\n","filename":"test\/jdk\/tools\/jextract\/constants.h","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define SUP 5 \/\/this is used by the main test header file\n","filename":"test\/jdk\/tools\/jextract\/constants_aux.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+dummy file for this directory\n","filename":"test\/jdk\/tools\/jextract\/directory.h\/DUMMY.TXT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+void foo(int boolean);\n+\n+int finally;\n+\n+struct abstract {\n+    short is;\n+    short throws;\n+} abstract;\n+\n+typedef char Byte;\n+void func(Byte byte, Byte* out);\n+\n+#define byte 1\n+#define content byte + 1\n+\n+typedef struct {\n+    short s1;\n+    short s2;\n+} Long;\n+\n+long twoShorts(Long s, Long* out, long* rv);\n","filename":"test\/jdk\/tools\/jextract\/exports.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int _global;\n+\n+EXPORT int _function(void);\n+\n+#define _constant 10\n+\n+typedef int _typedef;\n+\n+struct _struct { int x; };\n+\n+union _union { int y; };\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/filters.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#define NANF (0.0f\/0.0f)\n+#define PINFINITYF (1.0f\/0.0f)\n+#define NINFINITYF (-1.0f\/0.0f)\n+\n+#define NAN (0.0\/0.0)\n+#define PINFINITY (1.0\/0.0)\n+#define NINFINITY (-1.0\/0.0)\n","filename":"test\/jdk\/tools\/jextract\/float_constants.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,133 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static org.testng.Assert.*;\n+\n+import static test.jextract.funcpointers.func_h.*;\n+import test.jextract.funcpointers.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Func -t test.jextract.funcpointers -- func.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED TestFuncPointerInvokers\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Func -t test.jextract.funcpointers -- func.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED TestFuncPointerInvokers\n+ *\/\n+public class TestFuncPointerInvokers {\n+    @Test\n+    public void testStructFieldTypedef() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Bar.foo(bar).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFITypedef() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment bar = Bar.allocate(scope);\n+            Bar.foo$set(bar, Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddress(Bar.foo$get(bar)).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalTypedef() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            f().apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFITypedef() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            f$set(Foo.allocate((i) -> val.set(i), scope).address());\n+            Foo.ofAddress(f$get()).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFunctionPointer() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment baz = Baz.allocate(scope);\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), scope).address());\n+            Baz.fp(baz).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFieldFIFunctionPointer() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            MemorySegment baz = Baz.allocate(scope);\n+            Baz.fp$set(baz, Baz.fp.allocate((i) -> val.set(i), scope).address());\n+            Baz.fp.ofAddress(Baz.fp$get(baz)).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFunctionPointer() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            fp$set(fp.allocate((i) -> val.set(i), scope).address());\n+            fp().apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testGlobalFIFunctionPointer() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            AtomicInteger val = new AtomicInteger(-1);\n+            fp$set(fp.allocate((i) -> val.set(i), scope).address());\n+            fp.ofAddress(fp$get()).apply(42);\n+            assertEquals(val.get(), 42);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/TestFuncPointerInvokers.java","additions":133,"deletions":0,"binary":false,"changes":133,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void (*Foo)(int arg);\n+\n+struct Bar {\n+   Foo foo;\n+};\n+\n+EXPORT Foo f;\n+\n+struct Baz {\n+   void (*fp)(int arg);\n+};\n+\n+EXPORT void (*fp)(int arg);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/func.h","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"func.h\"\n","filename":"test\/jdk\/tools\/jextract\/funcPointerInvokers\/libFunc.c","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* make sure compiler built-in headers can be included *\/\n+#include <stddef.h>\n+\n+void func(int);\n+int printf(char* fmt, ...);\n+void f();\n","filename":"test\/jdk\/tools\/jextract\/hello.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+short long x;\n","filename":"test\/jdk\/tools\/jextract\/illegal_decls.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library .. \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ *\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED IncompleteArrayTest\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import org.testng.annotations.Test;\n+\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static org.testng.Assert.*;\n+\n+import java.nio.file.Path;\n+\n+public class IncompleteArrayTest extends JextractToolRunner {\n+\n+    @Test\n+    public void testIncompleteArray() {\n+        Path output = getOutputFilePath(\"incompleteArray_out\");\n+        Path input = getInputFilePath(\"incompleteArray.h\");\n+        run(\n+            \"-t\", \"org.jextract\",\n+            \"-d\", output,\n+            \"--\",\n+            input).checkSuccess();\n+        try (Loader loader = classLoader(output)) {\n+            Class<?> cls = loader.loadClass(\"org.jextract.Foo\");\n+            assertNotNull(cls);\n+\n+            MemoryLayout actualLayout = findLayout(cls);\n+            MemoryLayout expectedLayout = MemoryLayout.structLayout(\n+                C_INT.withName(\"size\"),\n+                MemoryLayout.paddingLayout(32),\n+                MemoryLayout.sequenceLayout(C_POINTER).withName(\"data\")\n+            ).withName(\"Foo\");\n+            assertEquals(actualLayout, expectedLayout);\n+        } finally {\n+            \/\/deleteDir(output);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jextract\/incompleteArray\/IncompleteArrayTest.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    int size;\n+    void* data[]; \/\/ incomplete array\n+};\n","filename":"test\/jdk\/tools\/jextract\/incompleteArray\/incompleteArray.h","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct foo {\n+  int x;\n+  int y;\n+  int z;\n+};\n+\n+\/\/ variable name clashing with struct name declared earlier\n+long foo;\n+\n+union foo2 {\n+   int i;\n+   long l;\n+};\n+\n+\/\/ variable name clashing with union name declared earlier\n+char foo2;\n+\n+int bar;\n+\n+\/\/ struct name clashing with variable name declared earlier\n+struct bar {\n+   float f1;\n+   float f2;\n+};\n+\n+int bar2;\n+\n+\/\/ union name clashing with variable name declared earlier\n+union bar2 {\n+   float f;\n+   double d;\n+};\n","filename":"test\/jdk\/tools\/jextract\/name_collision.h","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    struct Bar {\n+        int x, y;\n+    } bar;\n+\n+    enum Color {\n+        red, green, blue\n+    } color;\n+};\n+\n+union U {\n+    struct Point {\n+        short x, y;\n+    } point;\n+\n+    enum RGB {\n+        r, g, b\n+    } rgb;\n+\n+    int i;\n+};\n+\n+struct MyStruct {\n+    char a;\n+    struct {\n+        int b;\n+        union {\n+            int c;\n+        };\n+        char d;\n+        struct MyStruct_Z {\n+            char e;\n+        } f;\n+    };\n+    union {\n+        int g;\n+        long long h;\n+    };\n+    enum {\n+        X, Y, Z\n+    };\n+    struct {\n+        int i;\n+        int j;\n+    } k;\n+};\n+\n+union MyUnion {\n+    char a;\n+    struct {\n+        int b;\n+        union {\n+            int c;\n+        };\n+        char d;\n+        struct MyUnion_Z {\n+            char e;\n+        } f;\n+    };\n+    struct {\n+        int g;\n+        int h;\n+    };\n+    enum {\n+        A, B, C\n+    };\n+    union {\n+        int i;\n+        long long j;\n+    } k;\n+};\n+\n+struct X {\n+    struct {\n+        union {\n+            int y;\n+        } Z;\n+    };\n+};\n+\n+struct X2 {\n+    struct {\n+        union {\n+            int y;\n+        }; \/\/ no name this time\n+    };\n+};\n+\n+struct NestedUnion {\n+    int x;\n+    union {\n+        int y;\n+        int z;\n+    };\n+};\n","filename":"test\/jdk\/tools\/jextract\/nested.h","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"non_existent.h\"\n","filename":"test\/jdk\/tools\/jextract\/non_existent_includer.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Point;\n+struct Point;\n+\n+int i;\n+int i;\n+\n+void func(int);\n+void func(int abc);\n+void func(int xyz);\n+void func2(int);\n+void func2(int abc);\n+void func2(int xyz);\n+\n+typedef int INT;\n+void func(INT);\n+void func(INT abc);\n+void func(INT xyz);\n+void func2(INT);\n+void func2(INT abc);\n+void func2(INT xyz);\n+\n+typedef int* INTPTR;\n+void func3(INTPTR x);\n+void func3(int* x);\n+void func4(INTPTR x);\n+void func4(int* x);\n+\n+typedef int Integer;\n+void func(Integer x);\n+void func5(int x);\n+void func5(Integer x);\n+void func5(INT x);\n+\n+struct Point;\n+struct Point {\n+   int i;\n+   int j;\n+};\n+\n+typedef struct Point POINT;\n+typedef struct Point Point_t;\n+\n+double distance(struct Point p);\n+double distance(POINT p);\n+\n+typedef struct Point3D {\n+    int i;\n+    int j;\n+    int k;\n+} Point3D_t;\n+struct Point3D;\n+\n+enum RGBColor;\n+enum RGBColor {\n+   R, G, B\n+};\n+\n+enum CMYColor {\n+  C, M, Y\n+};\n+enum CMYColor;\n","filename":"test\/jdk\/tools\/jextract\/repeatedDecls.h","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,11 @@\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int a();\n+EXPORT int b();\n+EXPORT int c();\n+EXPORT int d();\n+EXPORT int e();\n","filename":"test\/jdk\/tools\/jextract\/split.h","additions":11,"deletions":0,"binary":false,"changes":11,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8239918.test8239918_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8239918\n+ * @summary jextract generates uncompilable code for no argument C function\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8239918 -t test.jextract.test8239918 -- test8239918.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8239918Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8239918\n+ * @summary jextract generates uncompilable code for no argument C function\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8239918 -t test.jextract.test8239918 -- test8239918.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8239918Test\n+ *\/\n+public class LibTest8239918Test {\n+    @Test\n+    public void testRand() {\n+        assertEquals(rand(), 1729);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8239918\/LibTest8239918Test.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8239918.h\"\n+\n+EXPORT int rand(void) {\n+    return 1729;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8239918\/libTest8239918.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int rand(void);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8239918\/test8239918.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8240373.test8240373_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8240373\n+ * @summary Jextract assigns type \"Void\" to enum macros\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.test8240373 -- test8240373.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Lib8240373Test\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @bug 8240373\n+ * @summary Jextract assigns type \"Void\" to enum macros\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ *\n+ * @run driver JtregJextractSources -t test.jextract.test8240373 -- test8240373.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Lib8240373Test\n+ *\/\n+\n+public class Lib8240373Test {\n+    @Test\n+    public void test() {\n+        assertTrue(A() == 0);\n+        assertTrue(B() == 1);\n+        assertTrue(C() == 2);\n+        assertTrue(E_INVALID() == -1);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8240373\/Lib8240373Test.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+typedef enum E { A, B, C } E;\n+#define E_INVALID ((E)-1)\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8240373\/test8240373.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+import test.jextract.test8241925.*;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8241925.test8241925_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8241925\n+ * @summary jextract should generate simple allocation, access API for C primitive types\n+ * @run driver JtregJextract -l Test8241925 -t test.jextract.test8241925 -- test8241925.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8241925Test\n+ *\/\n+public class LibTest8241925Test {\n+    @Test\n+    public void test() {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            var addr = allocator.allocate(C_INT, 12);\n+            assertEquals(MemoryAccess.getInt(addr), 12);\n+            square(addr);\n+            assertEquals(MemoryAccess.getInt(addr), 144);\n+\n+            addr = allocator.allocate(C_DOUBLE, 12.0);\n+            assertEquals(MemoryAccess.getDouble(addr), 12.0, 0.1);\n+            square_fp(addr);\n+            assertEquals(MemoryAccess.getDouble(addr), 144.0, 0.1);\n+\n+            int[] intArray = { 34, 67, 78, 8 };\n+            addr = allocator.allocateArray(C_INT, intArray);\n+            int sum = sum(addr, intArray.length);\n+            assertEquals(sum, IntStream.of(intArray).sum());\n+            int[] convertedArray = addr.toIntArray();\n+            assertEquals(convertedArray, intArray);\n+\n+            double[] dblArray = { 34.5, 67.56, 78.2, 8.45 };\n+            addr = allocator.allocateArray(C_DOUBLE, dblArray);\n+            double sumd = sum_fp(addr, dblArray.length);\n+            assertEquals(sumd, DoubleStream.of(dblArray).sum(), 0.1);\n+            double[] convertedDblArray = addr.toDoubleArray();\n+            for (int i = 0; i < dblArray.length; i++) {\n+                assertEquals(dblArray[i], convertedDblArray[i], 0.1);\n+            }\n+\n+            assertEquals(toJavaString(name()), \"java\");\n+\n+            var dest = allocator.allocateArray(C_CHAR, 12);\n+            dest.copyFrom(toCString(\"hello \", scope));\n+            var src = toCString(\"world\", scope);\n+            assertEquals(toJavaString(concatenate(dest, src)), \"hello world\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8241925\/LibTest8241925Test.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8241925.h\"\n+#include <string.h>\n+\n+EXPORT void square(int* v) {\n+    *v = (*v) * (*v);\n+}\n+\n+EXPORT int sum(int* arr, int num) {\n+    int res = 0;\n+    int i = 0;\n+    for (; i < num; i++) {\n+        res += arr[i];\n+    }\n+    return res;\n+}\n+\n+EXPORT void square_fp(double* v) {\n+    *v = (*v) * (*v);\n+}\n+\n+EXPORT double sum_fp(double* arr, int num) {\n+    double res = 0;\n+    int i = 0;\n+    for (; i < num; i++) {\n+        res += arr[i];\n+    }\n+    return res;\n+}\n+\n+const char* cptr = \"java\";\n+\n+EXPORT const char* name(void) {\n+    return cptr;\n+}\n+\n+EXPORT char* concatenate(char* dest, char* src) {\n+    return strcat(dest, src);\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8241925\/libTest8241925.c","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void square(int* v);\n+EXPORT int sum(int* arr, int num);\n+\n+EXPORT void square_fp(double* v);\n+EXPORT double sum_fp(double* arr, int num);\n+\n+EXPORT const char* name(void);\n+\n+EXPORT char* concatenate(char* dest, char* src);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8241925\/test8241925.h","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+\n+import test.jextract.test8244412.*;\n+import static test.jextract.test8244412.test8244412_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8244412\n+ * @summary jextract should generate static utils class for primitive typedefs\n+ * @run driver JtregJextract -t test.jextract.test8244412 -- test8244412.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8244412Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8244412\n+ * @summary jextract should generate static utils class for primitive typedefs\n+ * @run driver JtregJextractSources -t test.jextract.test8244412 -- test8244412.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8244412Test\n+ *\/\n+public class LibTest8244412Test {\n+    @Test\n+    public void test() {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            var addr = allocator.allocate(mysize_t, 0L);\n+            assertEquals(MemoryAccess.getLong(addr), 0L);\n+            MemoryAccess.setLong(addr, 13455566L);\n+            assertEquals(MemoryAccess.getLong(addr), 13455566L);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244412\/LibTest8244412Test.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef long long mysize_t;\n+typedef long long MYSIZE_T;\n","filename":"test\/jdk\/tools\/jextract\/test8244412\/test8244412.h","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.ResourceScope;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8244938.test8244938_h.*;\n+import test.jextract.test8244938.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8244938\n+ * @summary Crash in foreign ABI CallArranger class when a test native function returns a nested struct\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8244938 -t test.jextract.test8244938 -- test8244938.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8244938\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @bug 8244938\n+ * @summary Crash in foreign ABI CallArranger class when a test native function returns a nested struct\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8244938 -t test.jextract.test8244938 -- test8244938.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8244938\n+ *\/\n+public class Test8244938 {\n+    @Test\n+    public void testNestedStructReturn() {\n+         try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+             var seg = func(scope);\n+             assertEquals(seg.byteSize(), Point.sizeof());\n+             assertEquals(Point.k$get(seg), 44);\n+             var point2dSeg = Point.point2d$slice(seg);\n+             assertEquals(Point2D.i$get(point2dSeg), 567);\n+             assertEquals(Point2D.j$get(point2dSeg), 33);\n+         }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244938\/Test8244938.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8244938.h\"\n+\n+static struct Point point = { 44, { 567, 33 } };\n+EXPORT struct Point func(void) {\n+    return point;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244938\/libTest8244938.c","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Point2D {\n+   int i, j;\n+};\n+\n+struct Point {\n+  int k;\n+  struct Point2D point2d;\n+};\n+\n+EXPORT struct Point func(void);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8244938\/test8244938.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.printf.printf_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8244959\n+ * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.printf -l Printf -- printf.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8244959\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8244959\n+ * @summary Jextract's VarargsInvoker fails to link functions when passing integer types other than long\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.printf -l Printf -- printf.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8244959\n+ *\/\n+public class Test8244959 {\n+    @Test\n+    public void testsPrintf() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(1024, scope);\n+            my_sprintf(s,\n+                    toCString(\"%hhd %c %.2f %.2f %lld %lld %d %hd %d %d %lld %c\", scope), 12,\n+                    (byte) 1, 'b', -1.25f, 5.5d, -200L, Long.MAX_VALUE, (byte) -2, (short) 2, 3, (short) -4, 5L, 'a');\n+            String str = toJavaString(s);\n+            assertEquals(str, \"1 b -1.25 5.50 -200 \" + Long.MAX_VALUE + \" -2 2 3 -4 5 a\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244959\/Test8244959.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"printf.h\"\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+\n+EXPORT int my_sprintf(char *buf, const char *fmt, int arg_num, ...) {\n+    va_list list;\n+    va_start(list, arg_num);\n+    int result = vsprintf(buf, fmt, list);\n+    va_end(list);\n+    return result;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8244959\/libPrintf.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int my_sprintf(char *buf, const char *fmt, int arg_num, ...);\n","filename":"test\/jdk\/tools\/jextract\/test8244959\/printf.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import test.jextract.test8245003.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static test.jextract.test8245003.test8245003_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8245003\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8245003 -t test.jextract.test8245003 -- test8245003.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8245003\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8245003\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8245003 -t test.jextract.test8245003 -- test8245003.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8245003\n+ *\/\n+public class Test8245003 {\n+    @Test\n+    public void testStructAccessor() {\n+        var seg = special_pt$SEGMENT();\n+        assertEquals(seg.byteSize(), Point.sizeof());\n+        assertEquals(Point.x$get(seg), 56);\n+        assertEquals(Point.y$get(seg), 75);\n+\n+        seg = special_pt3d$SEGMENT();\n+        assertEquals(seg.byteSize(), Point3D.sizeof());\n+        assertEquals(Point3D.z$get(seg), 35);\n+        var pointSeg = Point3D.p$slice(seg);\n+        assertEquals(pointSeg.byteSize(), Point.sizeof());\n+        assertEquals(Point.x$get(pointSeg), 43);\n+        assertEquals(Point.y$get(pointSeg), 45);\n+    }\n+\n+    @Test\n+    public void testArrayAccessor() {\n+        var seg = iarr$SEGMENT();\n+        assertEquals(seg.byteSize(), C_INT.byteSize()*5);\n+        int[] arr = seg.toIntArray();\n+        assertEquals(arr.length, 5);\n+        assertEquals(arr[0], 2);\n+        assertEquals(arr[1], -2);\n+        assertEquals(arr[2], 42);\n+        assertEquals(arr[3], -42);\n+        assertEquals(arr[4], 345);\n+\n+        seg = foo$SEGMENT();\n+        assertEquals(seg.byteSize(), Foo.sizeof());\n+        assertEquals(Foo.count$get(seg), 37);\n+        var greeting = Foo.greeting$slice(seg);\n+        byte[] barr = greeting.toByteArray();\n+        assertEquals(new String(barr), \"hello\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8245003\/Test8245003.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8245003.h\"\n+\n+EXPORT Point special_pt = { 56, 75 };\n+\n+EXPORT Point3D special_pt3d = { 35, { 43, 45 } };\n+\n+EXPORT int iarr[5] = { 2, -2, 42, -42, 345 };\n+\n+EXPORT Foo foo = { 37, { 'h', 'e', 'l', 'l', 'o' } };\n","filename":"test\/jdk\/tools\/jextract\/test8245003\/libTest8245003.c","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Point {\n+    int x;\n+    int y;\n+} Point;\n+\n+EXPORT Point special_pt;\n+\n+typedef struct Point3D {\n+    int z;\n+    struct Point p;\n+} Point3D;\n+\n+EXPORT Point3D special_pt3d;\n+\n+EXPORT int iarr[5];\n+\n+typedef struct Foo {\n+    int count;\n+    char greeting[5];\n+} Foo;\n+\n+EXPORT Foo foo;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8245003\/test8245003.h","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct _Bar Foo;\n+\n+typedef struct Point Point_t;\n+\n+struct Point {\n+    int x, y;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8245767.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import org.testng.annotations.Test;\n+import test.jextract.test8246341.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8246341.test8246341_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8246341\n+ * @summary jextract should generate Cpointer utilities class\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8246341 -t test.jextract.test8246341 -- test8246341.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8246341Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8246341\n+ * @summary jextract should generate Cpointer utilities class\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8246341 -t test.jextract.test8246341 -- test8246341.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8246341Test\n+ *\/\n+public class LibTest8246341Test {\n+    @Test\n+    public void testPointerArray() {\n+        boolean[] callbackCalled = new boolean[1];\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var callback = func$callback.allocate((argc, argv) -> {\n+                callbackCalled[0] = true;\n+                var addr = argv.asSegment(C_POINTER.byteSize() * argc, scope);\n+                assertEquals(argc, 4);\n+                assertEquals(toJavaString(MemoryAccess.getAddressAtIndex(addr, 0)), \"java\");\n+                assertEquals(toJavaString(MemoryAccess.getAddressAtIndex(addr, 1)), \"python\");\n+                assertEquals(toJavaString(MemoryAccess.getAddressAtIndex(addr, 2)), \"javascript\");\n+                assertEquals(toJavaString(MemoryAccess.getAddressAtIndex(addr, 3)), \"c++\");\n+            }, scope);\n+            func(callback);\n+        }\n+        assertTrue(callbackCalled[0]);\n+    }\n+\n+    @Test\n+    public void testPointerAllocate() {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.arenaAllocator(C_POINTER.byteSize(), scope);\n+            var addr = allocator.allocate(C_POINTER);\n+            MemoryAccess.setAddress(addr, MemoryAddress.NULL);\n+            fillin(addr);\n+            assertEquals(toJavaString(MemoryAccess.getAddress(addr)), \"hello world\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8246341\/LibTest8246341Test.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8246341.h\"\n+\n+#define NUM_STRINGS 4\n+\n+static char* table[NUM_STRINGS] = { \"java\", \"python\", \"javascript\", \"c++\" };\n+static char* msg = \"hello world\";\n+\n+EXPORT void func(void (*callback)(int argc, char** argv)) {\n+    callback(NUM_STRINGS, table);\n+}\n+\n+EXPORT void fillin(char** pmsg) {\n+    *pmsg = msg;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8246341\/libTest8246341.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void func(void (*callback)(int argc, char** argv));\n+EXPORT void fillin(char** pmsg);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8246341\/test8246341.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import test.jextract.test8246400.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8246400.test8246400_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8246400\n+ * @summary jextract should generate a utility to manage mutliple MemorySegments\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8246400 -t test.jextract.test8246400 -- test8246400.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED  LibTest8246400Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8246400\n+ * @summary jextract should generate a utility to manage mutliple MemorySegments\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8246400 -t test.jextract.test8246400 -- test8246400.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8246400Test\n+ *\/\n+public class LibTest8246400Test {\n+    @Test\n+    public void testSegmentRegister() {\n+        MemorySegment sum = null;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var v1 = Vector.allocate(scope);\n+            Vector.x$set(v1, 1.0);\n+            Vector.y$set(v1, 0.0);\n+\n+            var v2 = Vector.allocate(scope);\n+            Vector.x$set(v2, 0.0);\n+            Vector.y$set(v2, 1.0);\n+\n+            sum = add(scope, v1, v2);\n+\n+            assertEquals(Vector.x$get(sum), 1.0, 0.1);\n+            assertEquals(Vector.y$get(sum), 1.0, 0.1);\n+\n+            MemoryAddress callback = cosine_similarity$dot.allocate((a, b) -> {\n+                return (Vector.x$get(a) * Vector.x$get(b)) +\n+                    (Vector.y$get(a) * Vector.y$get(b));\n+            }, scope);\n+\n+            var value = cosine_similarity(v1, v2, callback);\n+            assertEquals(value, 0.0, 0.1);\n+\n+            value = cosine_similarity(v1, v1, callback);\n+            assertEquals(value, 1.0, 0.1);\n+        }\n+        assertTrue(!sum.scope().isAlive());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8246400\/LibTest8246400Test.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8246400.h\"\n+#include <math.h>\n+\n+EXPORT Vector add(Vector v1, Vector v2) {\n+    Vector res = { v1.x + v2.x, v1.y + v2. y };\n+    return res;\n+}\n+\n+EXPORT double cosine_similarity(Vector v1, Vector v2,\n+        double (*dot)(Vector, Vector)) {\n+    double normv1 = sqrt(dot(v1, v1));\n+    double normv2 = sqrt(dot(v2, v2));\n+    return dot(v1, v2)\/(normv1 * normv2);\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8246400\/libTest8246400.c","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Vector {\n+    double x;\n+    double y;\n+} Vector;\n+\n+EXPORT Vector add(Vector v1, Vector v2);\n+EXPORT double cosine_similarity(Vector v1, Vector v2, double (*dot)(Vector, Vector));\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8246400\/test8246400.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Node {\n+  struct Node *next;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8248415.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void MyVoid;\n+EXPORT void func(MyVoid (*f)(MyVoid));\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8249290.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void MyVoid;\n+EXPORT void func(MyVoid (*f)());\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8249300.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8249757.test8249757_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8249757\n+ * @summary jextract should expose a way to load library from a given absolute path\n+ * @run driver JtregJextract -libpath Test8249757 -t test.jextract.test8249757 -- test8249757.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8249757Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8249757\n+ * @summary jextract should expose a way to load library from a given absolute path\n+ * @run driver JtregJextractSources -libpath Test8249757 -t test.jextract.test8249757 -- test8249757.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8249757Test\n+ *\/\n+public class LibTest8249757Test {\n+    @Test\n+    public void testSquare() {\n+        assertEquals(square(5), 25);\n+        assertEquals(square(16), 256);\n+        assertEquals(square(20), 400);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8249757\/LibTest8249757Test.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8249757.h\"\n+\n+EXPORT int square(int x) {\n+    return x*x;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8249757\/libTest8249757.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int square(int);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8249757\/test8249757.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+extern char* tzname[];\n+\n+struct Foo {\n+   int bar;\n+   char* names[];\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8251943.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.vsprintf.vsprintf_h.*;\n+import static jdk.incubator.foreign.CLinker.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8252016\n+ * @summary jextract should handle va_list\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.vsprintf -l VSPrintf -- vsprintf.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8252016\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8252016\n+ * @summary jextract should handle va_list\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.vsprintf -l VSPrintf -- vsprintf.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8252016\n+ *\/\n+public class Test8252016 {\n+    @Test\n+    public void testsVsprintf() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment s = MemorySegment.allocateNative(1024, scope);\n+            VaList vaList = VaList.make(b -> {\n+                b.vargFromInt(C_INT, 12);\n+                b.vargFromDouble(C_DOUBLE, 5.5d);\n+                b.vargFromLong(C_LONG_LONG, -200L);\n+                b.vargFromLong(C_LONG_LONG, Long.MAX_VALUE);\n+            }, scope);\n+            my_vsprintf(s, toCString(\"%hhd %.2f %lld %lld\", scope), vaList);\n+            String str = toJavaString(s);\n+            assertEquals(str, \"12 5.50 -200 \" + Long.MAX_VALUE);\n+       }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252016\/Test8252016.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"vsprintf.h\"\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+\n+EXPORT int my_vsprintf(char *s, const char* format, va_list arg) {\n+    return vsprintf(s, format, arg);\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252016\/libVSPrintf.c","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#include <stdarg.h>\n+\n+EXPORT int my_vsprintf(char *s, const char* format, va_list arg);\n","filename":"test\/jdk\/tools\/jextract\/test8252016\/vsprintf.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.util.stream.IntStream;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SegmentAllocator;\n+import static org.testng.Assert.assertEquals;\n+\n+import test.jextract.arrayparam.*;\n+import static test.jextract.arrayparam.arrayparam_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8252121\n+ * @summary jextract generated code fails with ABI for typedefed array type parameters\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.arrayparam -l Arrayparam -- arrayparam.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8252121\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8252121\n+ * @summary jextract generated code fails with ABI for typedefed array type parameters\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.arrayparam -l Arrayparam -- arrayparam.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8252121\n+ *\/\n+public class Test8252121 {\n+    @Test\n+    public void test() {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var allocator = SegmentAllocator.ofScope(scope);\n+            int[] array = { 3, 5, 89, 34, -33 };\n+            MemorySegment seg = allocator.allocateArray(CLinker.C_INT, array);\n+            assertEquals(IntStream.of(array).sum(), sum(seg));\n+            assertEquals(IntStream.of(array).reduce(1, (a,b) -> a*b), mul(seg));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252121\/Test8252121.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#define NUM_ELEMENTS 5\n+typedef int Array[NUM_ELEMENTS];\n+\n+typedef Array MyArray;\n+\n+EXPORT int sum(Array a);\n+EXPORT int mul(MyArray a);\n","filename":"test\/jdk\/tools\/jextract\/test8252121\/arrayparam.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"arrayparam.h\"\n+\n+int sum(Array a) {\n+    int res = 0;\n+    for (int i = 0; i < NUM_ELEMENTS; i++) {\n+        res += a[i];\n+    }\n+    return res;\n+}\n+\n+int mul(MyArray a) {\n+    int res = 1;\n+    for (int i = 0; i < NUM_ELEMENTS; i++) {\n+        res *= a[i];\n+    }\n+    return res;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252121\/libArrayparam.c","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+import test.jextract.test8252465.*;\n+import static test.jextract.test8252465.test8252465_h.*;\n+import test.jextract.test8252465.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8252465\n+ * @summary jextract generates wrong layout and varhandle when different structs have same named field\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.test8252465 -- test8252465.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8252465Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8252465\n+ * @summary jextract generates wrong layout and varhandle when different structs have same named field\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.test8252465 -- test8252465.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8252465Test\n+ *\/\n+public class LibTest8252465Test {\n+    @Test\n+    public void test() {\n+        try (var scope = ResourceScope.newConfinedScope()) {\n+            var foo = Foo.allocate(scope);\n+            Foo.x$set(foo, 3.14f);\n+            assertEquals(Foo.x$get(foo), 3.14f, 0.001f);\n+            var bar = Bar.allocate(scope);\n+            Bar.x$set(bar, -42);\n+            assertEquals(Bar.x$get(bar), -42);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8252465\/LibTest8252465Test.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    float x;\n+};\n+\n+struct Bar {\n+    int x;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8252465\/test8252465.h","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8253102.test8253102_h.*;\n+import test.jextract.test8253102.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8253102\n+ * @summary jextract should emit address to segment utility method on struct classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8253102 -t test.jextract.test8253102 -- test8253102.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8253102Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8253102\n+ * @summary jextract should emit address to segment utility method on struct classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8253102 -t test.jextract.test8253102 -- test8253102.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8253102Test\n+ *\/\n+public class LibTest8253102Test {\n+    @Test\n+    public void test() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemoryAddress addr = make(14, 99);\n+            MemorySegment seg = Point.ofAddress(addr, scope);\n+            assertEquals(Point.x$get(seg), 14);\n+            assertEquals(Point.y$get(seg), 99);\n+            CLinker.freeMemory(addr);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/LibTest8253102Test.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8253102.h\"\n+#include <stdlib.h>\n+\n+EXPORT Point* make(int x, int y) {\n+    Point* p = (Point*)malloc(sizeof(Point));\n+    p->x = x; p->y = y;\n+    return p;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/libTest8253102.c","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Point {\n+    int x;\n+    int y;\n+} Point;\n+\n+EXPORT Point* make(int x, int y);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8253102\/test8253102.h","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static jdk.incubator.foreign.CLinker.toJavaString;\n+import static test.jextract.test8253390.test8253390_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8253390\n+ * @summary jextract should quote string literals\n+ * @run driver JtregJextract -t test.jextract.test8253390 -- test8253390.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8253390Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8253390\n+ * @summary jextract should quote string literals\n+ * @run driver JtregJextractSources -t test.jextract.test8253390 -- test8253390.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8253390Test\n+ *\/\n+public class LibTest8253390Test {\n+    @Test\n+    public void testSquare() {\n+        assertEquals(toJavaString(GREETING()), \"hello\\nworld\");\n+        assertEquals(toJavaString(GREETING2()), \"hello\\tworld\");\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8253390\/LibTest8253390Test.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#define GREETING \"hello\\nworld\"\n+#define GREETING2 \"hello\\tworld\"\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8253390\/test8253390.h","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8254983.test8254983_h.*;\n+import test.jextract.test8254983.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8254983\n+ * @summary jextract fails to hande layout paths nested structs\/union\n+ * @run driver JtregJextract -t test.jextract.test8254983 -- test8254983.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8254983Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @bug 8254983\n+ * @summary jextract fails to hande layout paths nested structs\/union\n+ * @run driver JtregJextractSources -t test.jextract.test8254983 -- test8254983.h\n+ * @run testng\/othervm -Dforeign.restricted=permit LibTest8254983Test\n+ *\/\n+public class LibTest8254983Test {\n+    @Test\n+    public void testOuterStruct() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            assertEquals(((GroupLayout)Foo._struct.$LAYOUT()).memberLayouts().size(), 1);\n+            MemorySegment str = Foo._struct.allocate(scope);\n+            Foo._struct.x$set(str, 42);\n+            assertEquals(Foo._struct.x$get(str), 42);\n+        }\n+    }\n+\n+    @Test\n+    public void testInnerStruct() {\n+        assertEquals(((GroupLayout)Foo._union._struct.$LAYOUT()).memberLayouts().size(), 2);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment str = Foo._union._struct.allocate(scope);\n+            Foo._union._struct.x$set(str, 42);\n+            assertEquals(Foo._union._struct.x$get(str), 42);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8254983\/LibTest8254983Test.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+   struct {\n+       int x;\n+   } _struct;\n+\n+   union {\n+       struct {\n+           int u;\n+           int x;\n+       } _struct;\n+   } _union;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8254983\/test8254983.h","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayout.PathElement;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import test.jextract.unsupported.unsupported_h;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNull;\n+import static test.jextract.unsupported.unsupported_h.*;\n+import test.jextract.unsupported.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Unsupported -t test.jextract.unsupported -- unsupported.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibUnsupportedTest\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ *\n+ * @run driver JtregJextractSources -l Unsupported -t test.jextract.unsupported -- unsupported.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibUnsupportedTest\n+ *\/\n+\n+public class LibUnsupportedTest {\n+    @Test\n+    public void testAllocateFoo() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = Foo.allocate(scope);\n+            Foo.i$set(seg, 32);\n+            Foo.c$set(seg, (byte)'z');\n+            assertEquals(Foo.i$get(seg), 32);\n+            assertEquals(Foo.c$get(seg), (byte)'z');\n+        }\n+    }\n+\n+    @Test\n+    public void testGetFoo() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = getFoo().asSegment(Foo.sizeof(), scope);\n+            Foo.i$set(seg, 42);\n+            Foo.c$set(seg, (byte)'j');\n+            assertEquals(Foo.i$get(seg), 42);\n+            assertEquals(Foo.c$get(seg), (byte)'j');\n+        }\n+    }\n+\n+    private static void checkField(GroupLayout group, String fieldName, MemoryLayout expected) {\n+        assertEquals(group.select(PathElement.groupElement(fieldName)), expected.withName(fieldName));\n+    }\n+\n+    @Test\n+    public void testFieldTypes() {\n+        GroupLayout g = (GroupLayout)Foo.$LAYOUT();\n+        checkField(g, \"i\", CLinker.C_INT);\n+        checkField(g, \"c\", CLinker.C_CHAR);\n+    }\n+\n+    @Test\n+    public void testIgnoredMethods() {\n+        assertNull(findMethod(unsupported_h.class, \"func\"));\n+        assertNull(findMethod(unsupported_h.class, \"func2\"));\n+        assertNull(findMethod(unsupported_h.class, \"func3\"));\n+        assertNull(findMethod(unsupported_h.class, \"func4\"));\n+        assertNull(findMethod(unsupported_h.class, \"makeFoo\"));\n+        assertNull(findMethod(unsupported_h.class, \"copyFoo\"));\n+    }\n+\n+    private Method findMethod(Class<?> cls, String name) {\n+        for (Method m : cls.getMethods()) {\n+            if (m.getName().equals(name)) {\n+                return m;\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8257892\/LibUnsupportedTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"unsupported.h\"\n+\n+static Foo f = { 42, 343.55, 'j' };\n+\n+EXPORT Foo* getFoo() {\n+    return &f;\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8257892\/libUnsupported.c","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Foo {\n+    int i;\n+    long double ld;\n+    char c;\n+} Foo;\n+\n+EXPORT void func(long double ll);\n+EXPORT void func2(void (*f)(long double l));\n+EXPORT void func3(long double (*f)());\n+EXPORT void func4(void (*f)(Foo f));\n+EXPORT Foo* getFoo();\n+EXPORT Foo makeFoo();\n+EXPORT void copyFoo(Foo f1, Foo f2);\n+\n+long double ld;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8257892\/unsupported.h","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+  struct {\n+   long double dl;\n+  } x;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8258223.h","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Foo {\n+  int (*bar)(float, double);\n+};\n+\n+void (*func)(int);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8258405.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import test.jextract.test8258605.*;\n+import static jdk.incubator.foreign.MemoryAddress.NULL;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8258605.funcParam_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8258605\n+ * @summary regression: jextract can not handle function prototypes as function arguments\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l FuncParam -t test.jextract.test8258605 -- funcParam.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8258605Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8258605\n+ * @summary regression: jextract can not handle function prototypes as function arguments\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l FuncParam -t test.jextract.test8258605 -- funcParam.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8258605Test\n+ *\/\n+public class LibTest8258605Test {\n+    @Test\n+    public void testFunctionCallback() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+             boolean[] callbackReached = new boolean[1];\n+             f(CB.allocate(i -> {\n+                 assertTrue(i == 10);\n+                 callbackReached[0] = true;\n+             }, scope));\n+             assertTrue(callbackReached[0]);\n+        }\n+    }\n+\n+    @Test\n+    public void testStructFunctionPointerCallback() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+             boolean[] callbackReached = new boolean[1];\n+\n+             \/\/ get struct Foo instance\n+             var foo = getFoo(scope);\n+             \/\/ make sure that foo.bar is not NULL\n+             assertFalse(Foo.bar$get(foo).equals(NULL));\n+\n+             f2(foo, CB.allocate(i -> {\n+                 assertTrue(i == 42);\n+                 callbackReached[0] = true;\n+             }, scope));\n+             assertTrue(callbackReached[0]);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8258605\/LibTest8258605Test.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void CB(int);\n+\n+EXPORT void f(CB x);\n+\n+struct Foo {\n+    void (*bar)(CB cb);\n+};\n+\n+\/* get initialised Foo struct instance *\/\n+EXPORT struct Foo getFoo();\n+\n+\/* first param should be initialized struct instance returned by getFoo *\/\n+EXPORT void f2(struct Foo foo, CB cb);\n","filename":"test\/jdk\/tools\/jextract\/test8258605\/funcParam.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"funcParam.h\"\n+\n+EXPORT void f(CB x) {\n+    x(10);\n+}\n+\n+static void barFunc(CB cb) {\n+    cb(42);\n+}\n+\n+static struct Foo theFoo;\n+\n+EXPORT struct Foo getFoo() {\n+    theFoo.bar = barFunc;\n+    return theFoo;\n+}\n+\n+EXPORT void f2(struct Foo foo, CB cb) {\n+    foo.bar(cb);\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8258605\/libFuncParam.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.testng.annotations.Test;\n+import test.jextract.test8259473.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static test.jextract.test8259473.test8259473_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8259473\n+ * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.test8259473 -- test8259473.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8259473Test\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8259473\n+ * @summary jextract generated code should throw exception for unfound native symbols from calls, variable access, set immediately\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.test8259473 -- test8259473.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibTest8259473Test\n+ *\/\n+public class LibTest8259473Test {\n+    @Test\n+    public void nullChecksTest() {\n+        try {\n+            func();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n+        }\n+\n+        try {\n+            func$MH();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: func\"));\n+        }\n+\n+        try {\n+            x$get();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n+        }\n+\n+        try {\n+            x$set(1);\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n+        }\n+\n+        try {\n+            x$SEGMENT();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: x\"));\n+        }\n+\n+        try {\n+            y$SEGMENT();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: y\"));\n+        }\n+\n+        try {\n+            pt$SEGMENT();\n+            throw new AssertionError(\"should not reach here\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            assertTrue(ule.getMessage().contains(\"unresolved symbol: pt\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8259473\/LibTest8259473Test.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+void func();\n+extern int x;\n+extern int y[10];\n+\n+struct Point {\n+    int x;\n+    int y;\n+};\n+\n+extern struct Point pt;\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8259473\/test8259473.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef void di_log_handler (const char *message, void *user_data);\n+di_log_handler di_log_handler_default;\n+\n+struct json_object;\n+typedef void (json_object_delete_fn)(struct json_object *jso, void *userdata);\n+json_object_delete_fn json_object_free_userdata;\n+\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8260344.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Foo {\n+    int: 0;\n+    char c;\n+};\n+\n+struct Foo2 {\n+    int z;\n+    int: 16;\n+    int y:16;\n+    int w;\n+};\n+\n+struct Foo3 {\n+    int: 0;\n+    int: 32;\n+};\n+\n+struct Foo4 {\n+  int    a:3;\n+  int    b:2;\n+  int     :0; \/\/ Force alignment to next boundary.\n+  int    c:4;\n+  int    d:3;\n+};\n+\n+struct Foo5 {\n+  int    a:3;\n+  int    b:2;\n+  int    c:4;\n+  int    d:3;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8260705.h","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct {\n+  short s;\n+  int i1:1;\n+  int i2:1;\n+  void* ptr;\n+} foo_t;\n","filename":"test\/jdk\/tools\/jextract\/test8260717.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct {\n+     unsigned : 6;\n+     unsigned r1 : 8;\n+     unsigned r2 : 1;\n+     unsigned r3 : 1;\n+} rab;\n+\n+struct {\n+   int y;\n+   short x;\n+   int r1 : 23;\n+   int r2 : 5;\n+} rab2;\n","filename":"test\/jdk\/tools\/jextract\/test8260929.h","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.ResourceScope;\n+import test.jextract.test8261511.*;\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.test8261511.test8261511_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @bug 8261511\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Test8261511 -t test.jextract.test8261511 -- test8261511.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8261511\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @bug 8261511\n+ * @summary jextract does not generate accessor for MemorySegement typed values\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l Test8261511 -t test.jextract.test8261511 -- test8261511.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8261511\n+ *\/\n+public class Test8261511 {\n+    @Test\n+    public void test() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var funcPtr = Foo.sum$get(get_foo(scope));\n+            var sumIface = Foo.sum.ofAddress(funcPtr);\n+            assertEquals(sumIface.apply(15,20), 35);\n+            assertEquals(sum(1.2, 4.5), 5.7, 0.001);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8261511\/Test8261511.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"test8261511.h\"\n+#include <stdio.h>\n+\n+struct Foo theFoo;\n+\n+int foo_sum(int x, int y) {\n+    printf(\"foo_sum called\\n\");\n+    return x + y;\n+}\n+\n+EXPORT struct Foo get_foo() {\n+    theFoo.sum = foo_sum;\n+    return theFoo;\n+}\n+\n+EXPORT double sum(double x, double y) {\n+    printf(\"sum called\\n\");\n+    return x + y;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8261511\/libTest8261511.c","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+struct Foo {\n+    int (*sum)(int x, int y);\n+};\n+\n+EXPORT struct Foo get_foo();\n+EXPORT double sum(double x, double y);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/test8261511\/test8261511.h","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import org.testng.annotations.Test;\n+import jdk.incubator.foreign.MemorySegment;\n+import static org.testng.Assert.assertNotNull;\n+\n+\/*\n+ * @test\n+ * @library .. \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8260929\n+ * @summary jextract crashes with Crossing storage unit boundaries\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED Test8261578\n+ *\/\n+public class Test8261578 extends JextractToolRunner {\n+    @Test\n+    public void test1() {\n+        Path outputPath = getOutputFilePath(\"output_1\");\n+        Path headerFile = getInputFilePath(\"test8261578_1.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> ndpi_class = loader.loadClass(\"ndpi_flow_tcp_struct\");\n+            assertNotNull(ndpi_class);\n+\n+            checkMethod(ndpi_class, \"gnutella_msg_id$slice\", MemorySegment.class, MemorySegment.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+\n+    @Test\n+    public void test2() {\n+        Path outputPath = getOutputFilePath(\"output_2\");\n+        Path headerFile = getInputFilePath(\"test8261578_2.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> foo_class = loader.loadClass(\"foo\");\n+            assertNotNull(foo_class);\n+\n+            checkMethod(foo_class, \"clear_color$slice\", MemorySegment.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z$get\", int.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_z$set\", void.class, MemorySegment.class, int.class);\n+            checkMethod(foo_class, \"clear_s$get\", byte.class, MemorySegment.class);\n+            checkMethod(foo_class, \"clear_s$set\", void.class, MemorySegment.class, byte.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+\n+    @Test\n+    public void test3() {\n+        Path outputPath = getOutputFilePath(\"output_3\");\n+        Path headerFile = getInputFilePath(\"test8261578_3.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        try(Loader loader = classLoader(outputPath)) {\n+            Class<?> plugin_class = loader.loadClass(\"PluginCodec_H323AudioG7231AnnexC\");\n+            assertNotNull(plugin_class);\n+\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames$get\", byte.class, MemorySegment.class);\n+            checkMethod(plugin_class, \"maxAl_sduAudioFrames$set\", void.class, MemorySegment.class, byte.class);\n+        } finally {\n+            deleteDir(outputPath);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/Test8261578.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct ndpi_flow_tcp_struct {\n+  char gnutella_msg_id[3];\n+  int irc_3a_counter:3;\n+  int irc_stage2:5;\n+  int irc_direction:2;\n+  int irc_0x1000_full:1;\n+  int soulseek_stage:2;\n+  int filetopia_stage:2;\n+  int tds_stage:3;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/test8261578_1.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct foo {\n+   int clear_color[2];\n+   int clear_z;\n+   char clear_s;\n+   int pad:24;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/test8261578_2.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct PluginCodec_H323AudioG7231AnnexC {\n+  unsigned char maxAl_sduAudioFrames;\n+  int silenceSuppression:1;\n+  int highRateMode0:6; \/\/ INTEGER (27..78), -- units octets\n+  int highRateMode1:6; \/\/ INTEGER (27..78), -- units octets\n+  int lowRateMode0:6; \/\/ INTEGER (23..66), -- units octets\n+  int lowRateMode1:6; \/\/ INTEGER (23..66), -- units octets\n+  int sidMode0:4; \/\/ INTEGER (6..17), -- units octets\n+  int sidMode1:4; \/\/ INTEGER (6..17), -- units octets\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8261578\/test8261578_3.h","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef struct {\n+  int x, y;\n+} permits;\n+\n+struct record {\n+  int foo;\n+};\n+\n+union sealed {\n+  float i;\n+  int j;\n+};\n+\n+struct var {\n+  int x;\n+};\n+\n+typedef struct {\n+  int bar;\n+} yield;\n+\n","filename":"test\/jdk\/tools\/jextract\/test8261893.h","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+union {\n+   struct {\n+      union {\n+         struct { int x; } inner;\n+      } u;\n+   } outer;\n+} u;\n+\n+\n+union {\n+    union {\n+       int x; long y;\n+    } v;\n+} v;\n","filename":"test\/jdk\/tools\/jextract\/test8262117.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+struct {\n+   int x, y;\n+} x;\n+\n+struct Foo {\n+   union {\n+       int i;\n+       float f;\n+   } x;\n+};\n+\n+struct seg {\n+  int x;\n+};\n+\n+struct index {\n+  int x;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8262733.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct String {\n+   int x, y;\n+};\n+\n+struct RuntimeHelper {\n+   int x;\n+};\n+\n+union MemorySegment {\n+   int x; float f;\n+};\n+\n+union MemoryAddress {\n+   long l; double d;\n+};\n+\n+typedef long MemoryLayout;\n+typedef double ValueLayout;\n","filename":"test\/jdk\/tools\/jextract\/test8262825.h","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+struct Odd {\n+   struct {\n+    int size;\n+    char data[];\n+   } before;\n+   struct {\n+     int a; int b;\n+   } after;\n+};\n","filename":"test\/jdk\/tools\/jextract\/test8262851.h","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.jextract\n+ *          jdk.incubator.foreign\/jdk.incubator.foreign.unsafe\n+ *          jdk.incubator.foreign\/jdk.internal.foreign\n+ *          jdk.incubator.foreign\/jdk.internal.foreign.abi\n+ *          java.base\/sun.security.action\n+ * @library .. \/test\/lib\n+ * @build JextractToolRunner\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED -Duser.language=en TestClassGeneration\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Method;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Path;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.CLinker.C_CHAR;\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_FLOAT;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_SHORT;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertNotNull;\n+\n+public class TestClassGeneration extends JextractToolRunner {\n+\n+    private static final VarHandle VH_bytes = MemoryLayout.sequenceLayout(C_CHAR).varHandle(byte.class, sequenceElement());\n+\n+    private Path outputDir;\n+    private Loader loader;\n+    private Class<?> cls;\n+\n+    @DataProvider\n+    public static Object[][] simpleConstants() {\n+        return new Object[][]{\n+            { \"macro_byte\",         byte.class,   (byte) 1                         },\n+            { \"macro_short\",        short.class, (short) 1                         },\n+            { \"macro_int\",          int.class,           1                         },\n+            { \"macro_long\",         long.class,          1L                        },\n+            { \"macro_float\",        float.class,         1.0F                      },\n+            { \"macro_double\",       double.class,        1.0D                      },\n+            { \"macro_address_NULL\", MemoryAddress.class, MemoryAddress.NULL        },\n+            { \"macro_address_123\",  MemoryAddress.class, MemoryAddress.ofLong(123) },\n+            { \"enum_0\",             int.class,           0                         },\n+            { \"enum_1\",             int.class,           1                         },\n+            { \"enum_2\",             int.class,           2                         },\n+            { \"enum_anon_0\",        int.class,           0                         },\n+            { \"enum_anon_1\",        int.class,           1                         },\n+            { \"enum_anon_2\",        int.class,           2                         },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] stringConstants() {\n+        return new Object[][]{\n+            { \"macro_string\",         \"abc\"      },\n+            { \"macro_string_noident\", \"123.asdf\" },\n+        };\n+    }\n+\n+    private static final Object[] NO_ARGS = {};\n+\n+    @DataProvider\n+    public static Object[][] method() {\n+        return new Object[][]{\n+            { \"func_byte\",   methodType(byte.class),   (byte) 1,  NO_ARGS },\n+            { \"func_short\",  methodType(short.class), (short) 2,  NO_ARGS },\n+            { \"func_int\",    methodType(int.class),           3,  NO_ARGS },\n+            { \"func_long\",   methodType(long.class),          4L, NO_ARGS },\n+            { \"func_float\",  methodType(float.class),         5F, NO_ARGS },\n+            { \"func_double\", methodType(double.class),        6D, NO_ARGS },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] globals() {\n+        return new Object[][]{\n+            { \"global_byte\",   byte.class,   C_CHAR,   (byte) 1  },\n+            { \"global_short\",  short.class,  C_SHORT, (short) 2  },\n+            { \"global_int\",    int.class,    C_INT,           3  },\n+            { \"global_long\",   long.class,   C_LONG_LONG,      4L },\n+            { \"global_float\",  float.class,  C_FLOAT,         5F },\n+            { \"global_double\", double.class, C_DOUBLE,        6D },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] structMembers() {\n+        return new Object[][] {\n+            { \"Foo\", C_CHAR.withName(\"c\"),      byte.class,   (byte) 10  },\n+            { \"Foo\", C_SHORT.withName(\"s\"),     short.class, (short) 10  },\n+            { \"Foo\", C_INT.withName(\"i\"),       int.class,           10  },\n+            { \"Foo\", C_LONG_LONG.withName(\"ll\"), long.class,          10L },\n+            { \"Foo\", C_FLOAT.withName(\"f\"),     float.class,         10F },\n+            { \"Foo\", C_DOUBLE.withName(\"d\"),    double.class,        10D },\n+            { \"Bar\", C_INT.withName(\"a\"),       int.class,           10 },\n+            { \"Bar\", C_INT.withName(\"b\"),       int.class,           10 },\n+        };\n+    }\n+\n+    @DataProvider\n+    public static Object[][] functionalInterfaces() {\n+        return new Object[][]{\n+            { \"CB\", methodType(void.class, int.class) }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"simpleConstants\")\n+    public void testConstant(String name, Class<?> expectedType, Object expectedValue) throws Throwable {\n+        Method getter = checkMethod(cls, name, expectedType);\n+        assertEquals(getter.invoke(null), expectedValue);\n+    }\n+\n+    @Test(dataProvider = \"stringConstants\")\n+    public void testStringConstant(String name, String expectedValue) throws Throwable {\n+        Method getter = checkMethod(cls, name, MemorySegment.class);\n+        MemorySegment actual = (MemorySegment) getter.invoke(null);\n+        byte[] expected = expectedValue.getBytes(StandardCharsets.UTF_8);\n+        assertEquals(actual.byteSize(), expected.length + 1);\n+        for (int i = 0; i < expected.length; i++) {\n+            assertEquals((byte) VH_bytes.get(actual, (long) i), expected[i]);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"method\")\n+    public void testMethod(String name, MethodType expectedType, Object expectedReturn, Object[] args) throws Throwable {\n+        Method mh_getter = checkMethod(cls, name + \"$MH\", MethodHandle.class);\n+        MethodHandle mh = (MethodHandle) mh_getter.invoke(null);\n+        assertEquals(mh.type(), expectedType);\n+\n+        Object actualReturn = mh.invokeWithArguments(args);\n+        assertEquals(actualReturn.getClass(), expectedReturn.getClass());\n+        assertEquals(actualReturn, expectedReturn);\n+\n+        Method func = checkMethod(cls, name, expectedType);\n+        assertEquals(func.invoke(null, args), expectedReturn);\n+    }\n+\n+    @Test(dataProvider = \"globals\")\n+    public void testGlobal(String name, Class<?> expectedType, MemoryLayout expectedLayout, Object expectedValue) throws Throwable {\n+        Method layout_getter = checkMethod(cls, name + \"$LAYOUT\", MemoryLayout.class);\n+        assertEquals(layout_getter.invoke(null), expectedLayout);\n+\n+        Method addr_getter = checkMethod(cls, name + \"$SEGMENT\", MemorySegment.class);\n+        MemorySegment segment = (MemorySegment)addr_getter.invoke(null);\n+\n+        Method vh_getter = checkMethod(cls, name + \"$VH\", VarHandle.class);\n+        VarHandle vh = (VarHandle) vh_getter.invoke(null);\n+        assertEquals(vh.varType(), expectedType);\n+        assertEquals(vh.get(segment), expectedValue);\n+\n+        checkMethod(cls, name + \"$get\", expectedType);\n+        checkMethod(cls, name + \"$set\", void.class, expectedType);\n+    }\n+\n+    @Test(dataProvider = \"structMembers\")\n+    public void testStructMember(String structName, MemoryLayout memberLayout, Class<?> expectedType, Object testValue) throws Throwable {\n+        String memberName = memberLayout.name().orElseThrow();\n+\n+        Class<?> structCls = loader.loadClass(\"com.acme.\" + structName);\n+        Method layout_getter = checkMethod(structCls, \"$LAYOUT\", MemoryLayout.class);\n+        MemoryLayout structLayout = (MemoryLayout) layout_getter.invoke(null);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment struct = MemorySegment.allocateNative(structLayout, scope);\n+            Method vh_getter = checkMethod(structCls, memberName + \"$VH\", VarHandle.class);\n+            VarHandle vh = (VarHandle) vh_getter.invoke(null);\n+            assertEquals(vh.varType(), expectedType);\n+\n+            Method getter = checkMethod(structCls, memberName + \"$get\", expectedType, MemorySegment.class);\n+            Method setter = checkMethod(structCls, memberName + \"$set\", void.class, MemorySegment.class, expectedType);\n+            MemorySegment addr = struct;\n+            setter.invoke(null, addr, testValue);\n+            assertEquals(getter.invoke(null, addr), testValue);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"functionalInterfaces\")\n+    public void testFunctionalInterface(String name, MethodType type) {\n+        Class<?> fiClass = loader.loadClass(\"com.acme.\" + name);\n+        assertNotNull(fiClass);\n+        checkMethod(fiClass, \"apply\", type);\n+        checkMethod(fiClass, \"allocate\", MemoryAddress.class, fiClass);\n+    }\n+\n+    @BeforeClass\n+    public void setup() {\n+        outputDir = getOutputFilePath(\"exmples_out\");\n+        Path inputHeader = getInputFilePath(\"examples.h\");\n+        run(\n+            \"-t\", \"com.acme\",\n+            \"-d\", outputDir,\n+            \"-l\", \"Examples\",\n+            \"--\",\n+            inputHeader\n+        ).checkSuccess();\n+        loader = classLoader(outputDir);\n+        cls = loader.loadClass(\"com.acme.examples_h\");\n+    }\n+\n+    @AfterClass\n+    public void tearDown() {\n+        loader.close();\n+        deleteDir(outputDir);\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jextract\/testClassGen\/TestClassGeneration.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+#define macro_byte (char) 1\n+#define macro_short (short) 1\n+#define macro_int 1\n+#define macro_long 1LL\n+#define macro_float 1.0F\n+#define macro_double 1.0\n+#define macro_address_NULL (void*) 0\n+#define macro_address_123 (void*) 123\n+#define macro_string \"abc\"\n+#define macro_string_noident \"123.asdf\"\n+\n+EXPORT char func_byte(void);\n+EXPORT short func_short(void);\n+EXPORT int func_int(void);\n+EXPORT long long func_long(void);\n+EXPORT float func_float(void);\n+EXPORT double func_double(void);\n+\n+EXPORT extern char global_byte;\n+EXPORT extern short global_short;\n+EXPORT extern int global_int;\n+EXPORT extern long long global_long;\n+EXPORT extern float global_float;\n+EXPORT extern double global_double;\n+\n+typedef void(*CB)(int);\n+EXPORT void func_cb(CB cb);\n+\n+struct Foo {\n+    char c;\n+    short s;\n+    int i;\n+    long long ll;\n+    float f;\n+    double d;\n+};\n+\n+typedef struct {\n+    int a;\n+    int b;\n+} Bar;\n+\n+enum Enum {\n+    enum_0,\n+    enum_1,\n+    enum_2,\n+};\n+\n+enum {\n+    enum_anon_0,\n+    enum_anon_1,\n+    enum_anon_2,\n+};\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jextract\/testClassGen\/examples.h","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"examples.h\"\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT char func_byte(void) { return 1; }\n+EXPORT short func_short(void) { return 2; }\n+EXPORT int func_int(void) { return 3; }\n+EXPORT long long func_long(void) { return 4; }\n+EXPORT float func_float(void) { return 5; }\n+EXPORT double func_double(void) { return 6; }\n+\n+EXPORT char global_byte = 1;\n+EXPORT short global_short = 2;\n+EXPORT int global_int = 3;\n+EXPORT long long global_long = 4;\n+EXPORT float global_float = 5;\n+EXPORT double global_double = 6;\n+\n+EXPORT void func_cb(CB cb) {\n+    cb(1);\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/tools\/jextract\/testClassGen\/libExamples.c","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.fp.funcPtr_h.*;\n+import test.jextract.fp.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l FuncPtr -t test.jextract.fp -- funcPtr.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibFuncPtrTest\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -l FuncPtr -t test.jextract.fp -- funcPtr.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibFuncPtrTest\n+ *\/\n+public class LibFuncPtrTest {\n+    @Test\n+    public void test() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var handle = func$f.allocate(x -> x * x, scope);\n+            assertEquals(func(handle, 35), 35 * 35 + 35);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/testFunctionPointer\/LibFuncPtrTest.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int func(int (*f)(int), int);\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/testFunctionPointer\/funcPtr.h","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"funcPtr.h\"\n+\n+EXPORT int func(int (*f)(int), int x) {\n+    return x + f(x);\n+}\n","filename":"test\/jdk\/tools\/jextract\/testFunctionPointer\/libFuncPtr.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import test.jextract.redef.*;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.redef.redef_h.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -t test.jextract.redef -- redef.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestGlobalRedefinition\n+ *\/\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextractSources -t test.jextract.redef -- redef.h\n+ * @run testng\/othervm -Dforeign.restricted=permit TestGlobalRedefinition\n+ *\/\n+public class TestGlobalRedefinition {\n+    @Test\n+    public void test() throws Throwable {\n+        Method mGet = redef_h.class.getMethod(\"x$get\");\n+        assertEquals(mGet.getReturnType(), int.class);\n+\n+        Method mSet = redef_h.class.getMethod(\"x$set\", int.class);\n+        assertEquals(mSet.getParameterTypes()[0], int.class);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/testGlobalRedefinition\/TestGlobalRedefinition.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+typedef int MyInt;\n+\n+extern const int x;\n+extern const MyInt x;\n","filename":"test\/jdk\/tools\/jextract\/testGlobalRedefinition\/redef.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.GroupLayout;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayout.PathElement;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+import static test.jextract.struct.struct_h.*;\n+import test.jextract.struct.*;\n+\n+\/*\n+ * @test id=classes\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ * @run driver JtregJextract -l Struct -t test.jextract.struct -- struct.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibStructTest\n+ *\/\n+\n+\/*\n+ * @test id=sources\n+ * @library ..\n+ * @modules jdk.incubator.jextract\n+ *\n+ * @run driver JtregJextractSources -l Struct -t test.jextract.struct -- struct.h\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract,ALL-UNNAMED LibStructTest\n+ *\/\n+\n+public class LibStructTest {\n+    @Test\n+    public void testMakePoint() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = makePoint(scope, 42, -39);\n+            assertEquals(Point.x$get(seg), 42);\n+            assertEquals(Point.y$get(seg), -39);\n+        }\n+    }\n+\n+    @Test\n+    public void testAllocate() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = Point.allocate(scope);\n+            Point.x$set(seg, 56);\n+            Point.y$set(seg, 65);\n+            assertEquals(Point.x$get(seg), 56);\n+            assertEquals(Point.y$get(seg), 65);\n+        }\n+    }\n+\n+    @Test\n+    public void testAllocateArray() {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            var seg = Point.allocateArray(3, scope);\n+            for (int i = 0; i < 3; i++) {\n+                Point.x$set(seg, i, 56 + i);\n+                Point.y$set(seg, i, 65 + i);\n+            }\n+            for (int i = 0; i < 3; i++) {\n+                assertEquals(Point.x$get(seg, i), 56 + i);\n+                assertEquals(Point.y$get(seg, i), 65 + i);\n+            }\n+        }\n+    }\n+\n+    private static void checkField(GroupLayout group, String fieldName, MemoryLayout expected) {\n+        assertEquals(group.select(PathElement.groupElement(fieldName)), expected.withName(fieldName));\n+    }\n+\n+    @Test\n+    public void testFieldTypes() {\n+        GroupLayout g = (GroupLayout)AllTypes.$LAYOUT();\n+        checkField(g, \"sc\", CLinker.C_CHAR);\n+        checkField(g, \"uc\", CLinker.C_CHAR);\n+        checkField(g, \"s\",  CLinker.C_SHORT);\n+        checkField(g, \"us\", CLinker.C_SHORT);\n+        checkField(g, \"i\",  CLinker.C_INT);\n+        checkField(g, \"ui\", CLinker.C_INT);\n+        checkField(g, \"l\",  CLinker.C_LONG);\n+        checkField(g, \"ul\", CLinker.C_LONG);\n+        checkField(g, \"ll\", CLinker.C_LONG_LONG);\n+        checkField(g, \"ull\",CLinker.C_LONG_LONG);\n+        checkField(g, \"f\",  CLinker.C_FLOAT);\n+        checkField(g, \"d\",  CLinker.C_DOUBLE);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/testStruct\/LibStructTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"struct.h\"\n+\n+EXPORT Point makePoint(int x, int y) {\n+    Point pt = { x, y };\n+    return pt;\n+}\n","filename":"test\/jdk\/tools\/jextract\/testStruct\/libStruct.c","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/\/ __cplusplus\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+typedef struct Point {\n+    int x;\n+    int y;\n+} Point;\n+\n+EXPORT Point makePoint(int x, int y);\n+\n+struct AllTypes {\n+    signed char sc;\n+    unsigned char uc;\n+    short s;\n+    unsigned short us;\n+    int i;\n+    unsigned int ui;\n+    long l;\n+    unsigned long ul;\n+    long long ll;\n+    unsigned long long ull;\n+    float f;\n+    double d;\n+    long double ld;\n+};\n+\n+#ifdef __cplusplus\n+}\n+#endif \/\/ __cplusplus\n","filename":"test\/jdk\/tools\/jextract\/testStruct\/struct.h","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.nio.file.Path;\n+\n+\/*\n+ * @test\n+ * @library .. \/test\/lib\n+ * @modules jdk.incubator.jextract\n+ * @build JextractToolRunner\n+ * @bug 8249301\n+ * @summary jextract fails with CCE when encountering a typedefdecl whose type is FunctionProto\n+ * @run testng\/othervm --enable-native-access=jdk.incubator.jextract TestTypedefIsFunctionProto\n+ *\/\n+public class TestTypedefIsFunctionProto extends JextractToolRunner {\n+    @Test\n+    public void testVoidTypedef() {\n+        Path outputPath = getOutputFilePath(\"outputTDIFP\");\n+        Path headerFile = getInputFilePath(\"funcproto.h\");\n+        run(\"-d\", outputPath.toString(), headerFile.toString()).checkSuccess();\n+        \/\/ nothing is generated that we can check, so we just check that jextract ran successfully\n+        deleteDir(outputPath);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jextract\/testTypedefIsFunctionProto\/TestTypedefIsFunctionProto.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef void __stdcall foo();\n","filename":"test\/jdk\/tools\/jextract\/testTypedefIsFunctionProto\/funcproto.h","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef char byte_t;\n+typedef long mysize_t;\n+typedef long MYSIZE_T;\n","filename":"test\/jdk\/tools\/jextract\/typedefs.h","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+typedef union {\n+    int i;\n+    float f;\n+} IntOrFloat;\n+\n+void func(IntOrFloat* value);\n","filename":"test\/jdk\/tools\/jextract\/uniondecl.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class Point {\n+   public:\n+       int x, y;\n+};\n","filename":"test\/jdk\/tools\/jextract\/unsupported_lang.h","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -152,0 +152,2 @@\n+        \/\/ Panama\n+        new ToolHelpSpec(\"jextract\"    ,1,   1,   1,   0,         1,    1,   1),       \/\/ -?, -h, --help -help, Documents -help\n","filename":"test\/jdk\/tools\/launcher\/HelpFlagsTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+        \"jextract\",\n@@ -88,0 +89,1 @@\n+        \"jextract\",\n@@ -174,0 +176,4 @@\n+            if (f.getName().startsWith(\"jextract\")) {\n+                \/\/ skip the WARNING: Unknown module: jdk.incubator.jextract specified to --enable-native-access line\n+                testStr = testStr.substring(testStr.indexOf('\\n') + 1);\n+            }\n","filename":"test\/jdk\/tools\/launcher\/VersionCheck.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2021, Rado Smogura. All rights reserved.\n+ *\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\n+    \"--add-modules=jdk.incubator.foreign,jdk.incubator.vector\",\n+    \"-Dforeign.restricted=permit\",\n+    \"--enable-native-access\", \"ALL-UNNAMED\",\n+    \"-Djdk.incubator.vector.VECTOR_ACCESS_OOB_CHECK=1\"})\n+public class ByteBufferVectorAccess {\n+  private static final VectorSpecies<Byte> SPECIES = VectorSpecies.ofLargestShape(byte.class);\n+\n+  @Param(\"1024\")\n+  private int size;\n+\n+  ByteBuffer directIn, directOut;\n+  ByteBuffer heapIn, heapOut;\n+\n+  @Setup\n+  public void setup() {\n+    directIn = ByteBuffer.allocateDirect(size);\n+    directOut = ByteBuffer.allocateDirect(size);\n+\n+    heapIn = ByteBuffer.wrap(new byte[size]);\n+    heapOut = ByteBuffer.wrap(new byte[size]);\n+  }\n+\n+  @Benchmark\n+  public void directBuffers() {\n+    copyMemory(directIn, directOut);\n+  }\n+\n+  @Benchmark\n+  public void heapBuffers() {\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @Benchmark\n+  public void pollutedBuffers() {\n+    copyMemory(directIn, directOut);\n+    copyMemory(heapIn, heapOut);\n+  }\n+\n+  @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+  protected void copyMemory(ByteBuffer in, ByteBuffer out) {\n+    for (int i=0; i < SPECIES.loopBound(in.limit()); i += SPECIES.vectorByteSize()) {\n+      final var v = ByteVector.fromByteBuffer(SPECIES, in, i, ByteOrder.nativeOrder());\n+      v.intoByteBuffer(out, i, ByteOrder.nativeOrder());\n+    }\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ByteBufferVectorAccess.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}