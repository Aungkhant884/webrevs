{"files":[{"patch":"@@ -155,4 +155,0 @@\n-  if (_needs_return_buffer) {\n-    allocated_frame_size += 8; \/\/ for address spill\n-  }\n-  allocated_frame_size += arg_shuffle.out_arg_bytes();\n@@ -160,0 +156,1 @@\n+  allocated_frame_size += arg_shuffle.out_arg_bytes();\n@@ -161,1 +158,2 @@\n-  int ret_buf_addr_sp_offset = -1;\n+  StubLocations locs;\n+  locs.set(StubLocations::TARGET_ADDRESS, _abi._scratch1);\n@@ -163,2 +161,2 @@\n-     \/\/ in sync with the above\n-     ret_buf_addr_sp_offset = allocated_frame_size - 8;\n+    locs.set_frame_data(StubLocations::RETURN_BUFFER, allocated_frame_size);\n+    allocated_frame_size += 8; \/\/ for address spill\n@@ -167,0 +165,1 @@\n+  bool should_save_return_value = !_needs_return_buffer;\n@@ -170,1 +169,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -202,5 +201,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes);\n-  if (_needs_return_buffer) {\n-    assert(ret_buf_addr_sp_offset != -1, \"no return buffer addr spill\");\n-    __ str(_abi._ret_buf_addr_reg, Address(sp, ret_buf_addr_sp_offset));\n-  }\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes, locs);\n@@ -209,1 +204,1 @@\n-  __ blr(_abi._target_addr_reg);\n+  __ blr(as_Register(locs.get(StubLocations::TARGET_ADDRESS)));\n@@ -213,2 +208,1 @@\n-    assert(ret_buf_addr_sp_offset != -1, \"no return buffer addr spill\");\n-    __ ldr(tmp1, Address(sp, ret_buf_addr_sp_offset));\n+    __ ldr(tmp1, Address(sp, locs.data_offset(StubLocations::RETURN_BUFFER)));\n@@ -218,1 +212,1 @@\n-      if (reg.type() == RegType::INTEGER) {\n+      if (reg.type() == StorageType::INTEGER) {\n@@ -221,1 +215,1 @@\n-      } else if(reg.type() == RegType::VECTOR) {\n+      } else if(reg.type() == StorageType::VECTOR) {\n@@ -274,1 +268,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -284,1 +278,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -296,1 +290,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -302,1 +296,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -51,2 +51,2 @@\n-  parse_register_array(inputStorage, (int) RegType::INTEGER, abi._integer_argument_registers, as_Register);\n-  parse_register_array(inputStorage, (int) RegType::VECTOR, abi._vector_argument_registers, as_FloatRegister);\n+  parse_register_array(inputStorage, (int) StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, (int) StorageType::VECTOR, abi._vector_argument_registers, as_FloatRegister);\n@@ -55,2 +55,2 @@\n-  parse_register_array(outputStorage, (int) RegType::INTEGER, abi._integer_return_registers, as_Register);\n-  parse_register_array(outputStorage, (int) RegType::VECTOR, abi._vector_return_registers, as_FloatRegister);\n+  parse_register_array(outputStorage, (int) StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, (int) StorageType::VECTOR, abi._vector_return_registers, as_FloatRegister);\n@@ -59,2 +59,2 @@\n-  parse_register_array(volatileStorage, (int) RegType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n-  parse_register_array(volatileStorage, (int) RegType::VECTOR, abi._vector_additional_volatile_registers, as_FloatRegister);\n+  parse_register_array(volatileStorage, (int) StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, (int) StorageType::VECTOR, abi._vector_additional_volatile_registers, as_FloatRegister);\n@@ -65,2 +65,2 @@\n-  abi._target_addr_reg = as_Register(parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop)));\n-  abi._ret_buf_addr_reg = as_Register(parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop)));\n+  abi._scratch1 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch1(abi_oop));\n+  abi._scratch2 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch2(abi_oop));\n@@ -72,1 +72,1 @@\n-  if (reg.type() == RegType::INTEGER) {\n+  if (reg.type() == StorageType::INTEGER) {\n@@ -74,1 +74,1 @@\n-  } else if (reg.type() == RegType::VECTOR) {\n+  } else if (reg.type() == StorageType::VECTOR) {\n@@ -81,1 +81,1 @@\n-  if (reg.type() == RegType::INTEGER) {\n+  if (reg.type() == StorageType::INTEGER) {\n@@ -83,1 +83,1 @@\n-  } else if (reg.type() == RegType::VECTOR) {\n+  } else if (reg.type() == StorageType::VECTOR) {\n@@ -91,1 +91,1 @@\n-  if (reg.type() == RegType::INTEGER) {\n+  if (reg.type() == StorageType::INTEGER) {\n@@ -93,1 +93,1 @@\n-  } else if (reg.type() == RegType::VECTOR) {\n+  } else if (reg.type() == StorageType::VECTOR) {\n@@ -104,0 +104,1 @@\n+  int out_bias = 0;\n@@ -105,1 +106,1 @@\n-    case RegType::INTEGER:\n+    case StorageType::INTEGER:\n@@ -109,1 +110,3 @@\n-    case RegType::STACK:\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA:\n@@ -124,0 +127,2 @@\n+  Address from_addr(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias);\n+  int out_bias = 0;\n@@ -125,1 +130,1 @@\n-    case RegType::INTEGER:\n+    case StorageType::INTEGER:\n@@ -130,1 +135,1 @@\n-          masm->ldr(as_Register(to_reg), Address(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias));\n+          masm->ldr(as_Register(to_reg), from_addr);\n@@ -135,1 +140,1 @@\n-    case RegType::VECTOR:\n+    case StorageType::VECTOR:\n@@ -139,1 +144,1 @@\n-          masm->ldrd(as_FloatRegister(to_reg), Address(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias));\n+          masm->ldrd(as_FloatRegister(to_reg), from_addr);\n@@ -142,1 +147,1 @@\n-          masm->ldrs(as_FloatRegister(to_reg), Address(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias));\n+          masm->ldrs(as_FloatRegister(to_reg), from_addr);\n@@ -147,1 +152,3 @@\n-    case RegType::STACK:\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA:\n@@ -153,2 +160,2 @@\n-          masm->ldr(tmp_reg, Address(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias));\n-          masm->str(tmp_reg, Address(sp, to_reg.offset() + out_stk_bias));\n+          masm->ldr(tmp_reg, from_addr);\n+          masm->str(tmp_reg, Address(sp, to_reg.offset() + out_bias));\n@@ -166,1 +173,1 @@\n-    case RegType::VECTOR:\n+    case StorageType::VECTOR:\n@@ -170,1 +177,1 @@\n-    case RegType::STACK:\n+    case StorageType::STACK:\n@@ -185,1 +192,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n@@ -192,0 +199,8 @@\n+    \/\/ replace any placeholders\n+    if (from_reg.type() == StorageType::PLACEHOLDER) {\n+      from_reg = locs.get(from_reg);\n+    }\n+    if (to_reg.type() == StorageType::PLACEHOLDER) {\n+      to_reg = locs.get(to_reg);\n+    }\n+\n@@ -193,1 +208,1 @@\n-      case RegType::INTEGER:\n+      case StorageType::INTEGER:\n@@ -197,1 +212,1 @@\n-      case RegType::VECTOR:\n+      case StorageType::VECTOR:\n@@ -201,1 +216,1 @@\n-      case RegType::STACK:\n+      case StorageType::STACK:\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":45,"deletions":30,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -45,2 +45,2 @@\n-  Register _target_addr_reg;\n-  Register _ret_buf_addr_reg;\n+  VMStorage _scratch1;\n+  VMStorage _scratch2;\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -162,0 +162,1 @@\n+  StubLocations locs;\n@@ -166,0 +167,3 @@\n+    \/\/ use a free register for shuffling code to pick up return\n+    \/\/ buffer address from\n+    locs.set(StubLocations::RETURN_BUFFER, abi._scratch1);\n@@ -222,1 +226,1 @@\n-    __ lea(abi._ret_buf_addr_reg, Address(sp, ret_buf_offset));\n+    __ lea(as_Register(locs.get(StubLocations::RETURN_BUFFER)), Address(sp, ret_buf_offset));\n@@ -224,1 +228,1 @@\n-  arg_shuffle.generate(_masm, as_VMStorage(shuffle_reg), abi._shadow_space_bytes, 0);\n+  arg_shuffle.generate(_masm, as_VMStorage(shuffle_reg), abi._shadow_space_bytes, 0, locs);\n@@ -271,1 +275,1 @@\n-      if (reg.type() == RegType::INTEGER) {\n+      if (reg.type() == StorageType::INTEGER) {\n@@ -274,1 +278,1 @@\n-      } else if (reg.type() == RegType::VECTOR) {\n+      } else if (reg.type() == StorageType::VECTOR) {\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-enum class RegType : int8_t {\n+enum class StorageType : int8_t {\n@@ -37,0 +37,4 @@\n+  PLACEHOLDER = 3,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n@@ -39,2 +43,3 @@\n-constexpr inline RegType VMStorage::stack_type() {\n-  return RegType::STACK;\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return type == StorageType::INTEGER || type == StorageType::VECTOR;\n@@ -42,0 +47,3 @@\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n@@ -46,3 +54,3 @@\n-constexpr VMStorage VMS_R0 = VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, 0);\n-constexpr VMStorage VMS_R19 = VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, 19);\n-constexpr VMStorage VMS_V0 = VMStorage::reg_storage(RegType::VECTOR, V128_MASK, 0);\n+constexpr VMStorage VMS_R0 = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 0);\n+constexpr VMStorage VMS_R19 = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 19);\n+constexpr VMStorage VMS_V0 = VMStorage::reg_storage(StorageType::VECTOR, V128_MASK, 0);\n@@ -51,1 +59,1 @@\n-  assert(vms.type() == RegType::INTEGER, \"not the right type\");\n+  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n@@ -56,1 +64,1 @@\n-  assert(vms.type() == RegType::VECTOR, \"not the right type\");\n+  assert(vms.type() == StorageType::VECTOR, \"not the right type\");\n@@ -61,1 +69,1 @@\n-  return VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, reg->encoding());\n+  return VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, reg->encoding());\n@@ -65,1 +73,1 @@\n-  return VMStorage::reg_storage(RegType::VECTOR, V128_MASK, reg->encoding());\n+  return VMStorage::reg_storage(StorageType::VECTOR, V128_MASK, reg->encoding());\n","filename":"src\/hotspot\/cpu\/aarch64\/vmstorage_aarch64.inline.hpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/arm\/foreignGlobals_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,6 @@\n-enum class RegType : int8_t {\n-  STACK = 0\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n@@ -36,2 +40,3 @@\n-constexpr inline RegType VMStorage::stack_type() {\n-  return RegType::STACK;\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n@@ -39,0 +44,3 @@\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n","filename":"src\/hotspot\/cpu\/arm\/vmstorage_arm.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,6 @@\n-enum class RegType : int8_t {\n-  STACK = 0\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n@@ -36,2 +40,3 @@\n-constexpr inline RegType VMStorage::stack_type() {\n-  return RegType::STACK;\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n@@ -39,0 +44,3 @@\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n","filename":"src\/hotspot\/cpu\/ppc\/vmstorage_ppc.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,6 @@\n-enum class RegType : int8_t {\n-  STACK = 0\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n@@ -36,2 +40,3 @@\n-constexpr inline RegType VMStorage::stack_type() {\n-  return RegType::STACK;\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n@@ -39,0 +44,3 @@\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n","filename":"src\/hotspot\/cpu\/riscv\/vmstorage_riscv.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,6 @@\n-enum class RegType : int8_t {\n-  STACK = 0\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n@@ -36,2 +40,3 @@\n-constexpr inline RegType VMStorage::stack_type() {\n-  return RegType::STACK;\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n@@ -39,0 +44,3 @@\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n","filename":"src\/hotspot\/cpu\/s390\/vmstorage_s390.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -152,4 +152,0 @@\n-  if (_needs_return_buffer) {\n-    allocated_frame_size += 8; \/\/ store address\n-  }\n-  allocated_frame_size += arg_shuffle.out_arg_bytes();\n@@ -157,0 +153,1 @@\n+  allocated_frame_size += arg_shuffle.out_arg_bytes();\n@@ -158,1 +155,2 @@\n-  int ret_buf_addr_rsp_offset = -1;\n+  StubLocations locs;\n+  locs.set(StubLocations::TARGET_ADDRESS, _abi._scratch1);\n@@ -160,2 +158,2 @@\n-    \/\/ the above\n-    ret_buf_addr_rsp_offset = allocated_frame_size - 8;\n+    locs.set_frame_data(StubLocations::RETURN_BUFFER, allocated_frame_size);\n+    allocated_frame_size += 8;\n@@ -164,2 +162,2 @@\n-  \/\/ when we don't use a return buffer we need to spill the return value around our slowpath calls\n-  \/\/ when we use a return buffer case this SHOULD be unused.\n+  \/\/ when we don't use a return buffer we need to spill the return value around our slow path calls\n+  bool should_save_return_value = !_needs_return_buffer;\n@@ -169,1 +167,1 @@\n-  if (!_needs_return_buffer) {\n+  if (should_save_return_value) {\n@@ -202,6 +200,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes);\n-  if (_needs_return_buffer) {\n-    \/\/ spill our return buffer address\n-    assert(ret_buf_addr_rsp_offset != -1, \"no return buffer addr spill\");\n-    __ movptr(Address(rsp, ret_buf_addr_rsp_offset), _abi._ret_buf_addr_reg);\n-  }\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes, locs);\n@@ -210,1 +203,1 @@\n-  __ call(_abi._target_addr_reg);\n+  __ call(as_Register(locs.get(StubLocations::TARGET_ADDRESS)));\n@@ -214,2 +207,1 @@\n-    assert(ret_buf_addr_rsp_offset != -1, \"no return buffer addr spill\");\n-    __ movptr(rscratch1, Address(rsp, ret_buf_addr_rsp_offset));\n+    __ movptr(rscratch1, Address(rsp, locs.data_offset(StubLocations::RETURN_BUFFER)));\n@@ -219,1 +211,1 @@\n-      if (reg.type() == RegType::INTEGER) {\n+      if (reg.type() == StorageType::INTEGER) {\n@@ -222,1 +214,1 @@\n-      } else if (reg.type() == RegType::VECTOR) {\n+      } else if (reg.type() == StorageType::VECTOR) {\n@@ -274,1 +266,1 @@\n-  if(!_needs_return_buffer) {\n+  if(should_save_return_value) {\n@@ -286,1 +278,1 @@\n-  if(!_needs_return_buffer) {\n+  if(should_save_return_value) {\n@@ -299,1 +291,1 @@\n-  if(!_needs_return_buffer) {\n+  if(should_save_return_value) {\n@@ -310,1 +302,1 @@\n-  if(!_needs_return_buffer) {\n+  if(should_save_return_value) {\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-  Register _target_addr_reg;\n-  Register _ret_buf_addr_reg;\n+  VMStorage _scratch1;\n+  VMStorage _scratch2;\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-  parse_register_array(inputStorage, (int) RegType::INTEGER, abi._integer_argument_registers, as_Register);\n-  parse_register_array(inputStorage, (int) RegType::VECTOR, abi._vector_argument_registers, as_XMMRegister);\n+  parse_register_array(inputStorage, (int) StorageType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, (int) StorageType::VECTOR, abi._vector_argument_registers, as_XMMRegister);\n@@ -52,3 +52,3 @@\n-  parse_register_array(outputStorage, (int) RegType::INTEGER, abi._integer_return_registers, as_Register);\n-  parse_register_array(outputStorage, (int) RegType::VECTOR, abi._vector_return_registers, as_XMMRegister);\n-  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at(((int) RegType::X87)));\n+  parse_register_array(outputStorage, (int) StorageType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, (int) StorageType::VECTOR, abi._vector_return_registers, as_XMMRegister);\n+  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at(((int) StorageType::X87)));\n@@ -58,2 +58,2 @@\n-  parse_register_array(volatileStorage, (int) RegType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n-  parse_register_array(volatileStorage, (int) RegType::VECTOR, abi._vector_additional_volatile_registers, as_XMMRegister);\n+  parse_register_array(volatileStorage, (int) StorageType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, (int) StorageType::VECTOR, abi._vector_additional_volatile_registers, as_XMMRegister);\n@@ -64,2 +64,2 @@\n-  abi._target_addr_reg = as_Register(parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop)));\n-  abi._ret_buf_addr_reg = as_Register(parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop)));\n+  abi._scratch1 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch1(abi_oop));\n+  abi._scratch2 = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::scratch2(abi_oop));\n@@ -71,1 +71,1 @@\n-  if (reg.type() == RegType::INTEGER) {\n+  if (reg.type() == StorageType::INTEGER) {\n@@ -73,1 +73,1 @@\n-  } else if (reg.type() == RegType::VECTOR) {\n+  } else if (reg.type() == StorageType::VECTOR) {\n@@ -80,1 +80,1 @@\n-  if (reg.type() == RegType::INTEGER) {\n+  if (reg.type() == StorageType::INTEGER) {\n@@ -82,1 +82,1 @@\n-  } else if (reg.type() == RegType::VECTOR) {\n+  } else if (reg.type() == StorageType::VECTOR) {\n@@ -90,1 +90,1 @@\n-  if (reg.type() == RegType::INTEGER) {\n+  if (reg.type() == StorageType::INTEGER) {\n@@ -92,1 +92,1 @@\n-  } else if (reg.type() == RegType::VECTOR) {\n+  } else if (reg.type() == StorageType::VECTOR) {\n@@ -103,0 +103,1 @@\n+  int out_bias = 0;\n@@ -104,1 +105,1 @@\n-    case RegType::INTEGER:\n+    case StorageType::INTEGER:\n@@ -108,1 +109,3 @@\n-    case RegType::STACK:\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA:\n@@ -110,1 +113,1 @@\n-      masm->movq(Address(rsp, to_reg.offset() + out_stk_bias), from_reg);\n+      masm->movq(Address(rsp, to_reg.offset() + out_bias), from_reg);\n@@ -116,2 +119,3 @@\n-static void move_stack64(MacroAssembler* masm, Register tmp_reg, int in_stk_bias, int out_stk_bias,\n-                         int from_offset, VMStorage to_reg) {\n+static void move_stack64(MacroAssembler* masm, Register tmp_reg, int out_stk_bias,\n+                         Address from_address, VMStorage to_reg) {\n+  int out_bias = 0;\n@@ -119,1 +123,1 @@\n-    case RegType::INTEGER:\n+    case StorageType::INTEGER:\n@@ -121,1 +125,1 @@\n-      masm->movq(as_Register(to_reg), Address(rbp, RBP_BIAS + from_offset + in_stk_bias));\n+      masm->movq(as_Register(to_reg), from_address);\n@@ -123,1 +127,1 @@\n-    case RegType::VECTOR:\n+    case StorageType::VECTOR:\n@@ -125,1 +129,1 @@\n-      masm->movdqu(as_XMMRegister(to_reg), Address(rbp, RBP_BIAS + from_offset + in_stk_bias));\n+      masm->movdqu(as_XMMRegister(to_reg), from_address);\n@@ -127,1 +131,3 @@\n-    case RegType::STACK:\n+    case StorageType::STACK:\n+      out_bias = out_stk_bias;\n+    case StorageType::FRAME_DATA:\n@@ -129,2 +135,2 @@\n-      masm->movq(tmp_reg, Address(rbp, RBP_BIAS + from_offset + in_stk_bias));\n-      masm->movq(Address(rsp, to_reg.offset() + out_stk_bias), tmp_reg);\n+      masm->movq(tmp_reg, from_address);\n+      masm->movq(Address(rsp, to_reg.offset() + out_bias), tmp_reg);\n@@ -139,1 +145,1 @@\n-    case RegType::INTEGER: \/\/ windows vargarg floats\n+    case StorageType::INTEGER: \/\/ windows vargarg floats\n@@ -143,1 +149,1 @@\n-    case RegType::VECTOR:\n+    case StorageType::VECTOR:\n@@ -147,1 +153,1 @@\n-    case RegType::STACK:\n+    case StorageType::STACK:\n@@ -155,1 +161,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n@@ -162,0 +168,8 @@\n+    \/\/ replace any placeholders\n+    if (from_reg.type() == StorageType::PLACEHOLDER) {\n+      from_reg = locs.get(from_reg);\n+    }\n+    if (to_reg.type() == StorageType::PLACEHOLDER) {\n+      to_reg = locs.get(to_reg);\n+    }\n+\n@@ -163,1 +177,1 @@\n-      case RegType::INTEGER:\n+      case StorageType::INTEGER:\n@@ -167,1 +181,1 @@\n-      case RegType::VECTOR:\n+      case StorageType::VECTOR:\n@@ -171,1 +185,1 @@\n-      case RegType::STACK:\n+      case StorageType::STACK: {\n@@ -173,2 +187,3 @@\n-        move_stack64(masm, tmp_reg, in_stk_bias, out_stk_bias, from_reg.offset(), to_reg);\n-        break;\n+        Address from_addr(rbp, RBP_BIAS + from_reg.offset() + in_stk_bias);\n+        move_stack64(masm, tmp_reg, out_stk_bias, from_addr, to_reg);\n+      } break;\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":51,"deletions":36,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -212,0 +212,1 @@\n+  StubLocations locs;\n@@ -216,0 +217,3 @@\n+    \/\/ use a free register for shuffling code to pick up return\n+    \/\/ buffer address from\n+    locs.set(StubLocations::RETURN_BUFFER, abi._scratch1);\n@@ -277,1 +281,1 @@\n-    __ lea(abi._ret_buf_addr_reg, Address(rsp, ret_buf_offset));\n+    __ lea(as_Register(locs.get(StubLocations::RETURN_BUFFER)), Address(rsp, ret_buf_offset));\n@@ -279,1 +283,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg, abi._shadow_space_bytes, 0);\n+  arg_shuffle.generate(_masm, shuffle_reg, abi._shadow_space_bytes, 0, locs);\n@@ -325,1 +329,1 @@\n-      if (reg.type() == RegType::INTEGER) {\n+      if (reg.type() == StorageType::INTEGER) {\n@@ -328,1 +332,1 @@\n-      } else if (reg.type() == RegType::VECTOR) {\n+      } else if (reg.type() == StorageType::VECTOR) {\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-enum class RegType : int8_t {\n+enum class StorageType : int8_t {\n@@ -39,0 +39,3 @@\n+  PLACEHOLDER = 4,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n@@ -43,2 +46,2 @@\n-constexpr inline RegType VMStorage::stack_type() {\n-  return RegType::STACK;\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return type == StorageType::INTEGER || type == StorageType::VECTOR || type == StorageType::X87;\n@@ -46,0 +49,3 @@\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n@@ -50,3 +56,3 @@\n-constexpr VMStorage VMS_RAX = VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, 0);\n-constexpr VMStorage VMS_RBX = VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, 3);\n-constexpr VMStorage VMS_XMM0 = VMStorage::reg_storage(RegType::VECTOR, XMM_MASK, 0);\n+constexpr VMStorage VMS_RAX = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 0);\n+constexpr VMStorage VMS_RBX = VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, 3);\n+constexpr VMStorage VMS_XMM0 = VMStorage::reg_storage(StorageType::VECTOR, XMM_MASK, 0);\n@@ -55,1 +61,1 @@\n-  assert(vms.type() == RegType::INTEGER, \"not the right type\");\n+  assert(vms.type() == StorageType::INTEGER, \"not the right type\");\n@@ -60,1 +66,1 @@\n-  assert(vms.type() == RegType::VECTOR, \"not the right type\");\n+  assert(vms.type() == StorageType::VECTOR, \"not the right type\");\n@@ -66,3 +72,3 @@\n-    case RegType::INTEGER: return as_Register(vms)->as_VMReg();\n-    case RegType::VECTOR:  return as_XMMRegister(vms)->as_VMReg();\n-    case RegType::STACK: {\n+    case StorageType::INTEGER: return as_Register(vms)->as_VMReg();\n+    case StorageType::VECTOR:  return as_XMMRegister(vms)->as_VMReg();\n+    case StorageType::STACK: {\n@@ -77,1 +83,1 @@\n-  return VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, reg->encoding());\n+  return VMStorage::reg_storage(StorageType::INTEGER, REG64_MASK, reg->encoding());\n@@ -81,1 +87,1 @@\n-  return VMStorage::reg_storage(RegType::VECTOR, XMM_MASK, reg->encoding());\n+  return VMStorage::reg_storage(StorageType::VECTOR, XMM_MASK, reg->encoding());\n","filename":"src\/hotspot\/cpu\/x86\/vmstorage_x86.inline.hpp","additions":19,"deletions":13,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n","filename":"src\/hotspot\/cpu\/zero\/foreignGlobals_zero.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,6 @@\n-enum class RegType : int8_t {\n-  STACK = 0\n+enum class StorageType : int8_t {\n+  STACK = 0,\n+  PLACEHOLDER = 1,\n+\/\/ special locations used only by native code\n+  FRAME_DATA = PLACEHOLDER + 1,\n+  INVALID = -1\n@@ -36,2 +40,3 @@\n-constexpr inline RegType VMStorage::stack_type() {\n-  return RegType::STACK;\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline bool VMStorage::is_reg(StorageType type) {\n+   return false;\n@@ -39,0 +44,3 @@\n+constexpr inline StorageType VMStorage::stack_type() { return StorageType::STACK; }\n+constexpr inline StorageType VMStorage::placeholder_type() { return StorageType::PLACEHOLDER; }\n+constexpr inline StorageType VMStorage::frame_data_type() { return StorageType::FRAME_DATA; }\n","filename":"src\/hotspot\/cpu\/zero\/vmstorage_zero.inline.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4219,2 +4219,2 @@\n-int jdk_internal_foreign_abi_ABIDescriptor::_targetAddrStorage_offset;\n-int jdk_internal_foreign_abi_ABIDescriptor::_retBufAddrStorage_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_scratch1_offset;\n+int jdk_internal_foreign_abi_ABIDescriptor::_scratch2_offset;\n@@ -4223,7 +4223,7 @@\n-  macro(_inputStorage_offset,      k, \"inputStorage\",      jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_outputStorage_offset,     k, \"outputStorage\",     jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_volatileStorage_offset,   k, \"volatileStorage\",   jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n-  macro(_stackAlignment_offset,    k, \"stackAlignment\",    int_signature, false); \\\n-  macro(_shadowSpace_offset,       k, \"shadowSpace\",       int_signature, false); \\\n-  macro(_targetAddrStorage_offset, k, \"targetAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false); \\\n-  macro(_retBufAddrStorage_offset, k, \"retBufAddrStorage\", jdk_internal_foreign_abi_VMStorage_signature, false);\n+  macro(_inputStorage_offset,    k, \"inputStorage\",    jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_outputStorage_offset,   k, \"outputStorage\",   jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_volatileStorage_offset, k, \"volatileStorage\", jdk_internal_foreign_abi_VMStorage_array_array_signature, false); \\\n+  macro(_stackAlignment_offset,  k, \"stackAlignment\",  int_signature, false); \\\n+  macro(_shadowSpace_offset,     k, \"shadowSpace\",     int_signature, false); \\\n+  macro(_scratch1_offset,        k, \"scratch1\",        jdk_internal_foreign_abi_VMStorage_signature, false); \\\n+  macro(_scratch2_offset,        k, \"scratch2\",        jdk_internal_foreign_abi_VMStorage_signature, false);\n@@ -4266,2 +4266,2 @@\n-oop jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(oop entry) {\n-  return entry->obj_field(_targetAddrStorage_offset);\n+oop jdk_internal_foreign_abi_ABIDescriptor::scratch1(oop entry) {\n+  return entry->obj_field(_scratch1_offset);\n@@ -4270,2 +4270,2 @@\n-oop jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(oop entry) {\n-  return entry->obj_field(_retBufAddrStorage_offset);\n+oop jdk_internal_foreign_abi_ABIDescriptor::scratch2(oop entry) {\n+  return entry->obj_field(_scratch2_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1141,2 +1141,2 @@\n-  static int _targetAddrStorage_offset;\n-  static int _retBufAddrStorage_offset;\n+  static int _scratch1_offset;\n+  static int _scratch2_offset;\n@@ -1155,2 +1155,2 @@\n-  static oop         targetAddrStorage(oop entry);\n-  static oop         retBufAddrStorage(oop entry);\n+  static oop         scratch1(oop entry);\n+  static oop         scratch2(oop entry);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,0 +31,33 @@\n+StubLocations::StubLocations() {\n+  for (uint32_t i = 0; i < MAX; i++) {\n+    _locs[i] = VMStorage::invalid();\n+  }\n+}\n+\n+void StubLocations::set(uint32_t loc, VMStorage storage) {\n+  assert(loc < MAX, \"oob\");\n+  _locs[loc] = storage;\n+}\n+\n+void StubLocations::set_frame_data(uint32_t loc, int offset) {\n+  set(loc, VMStorage(StorageType::FRAME_DATA, 8, offset));\n+}\n+\n+VMStorage StubLocations::get(uint32_t loc) const {\n+  assert(loc < MAX, \"oob\");\n+  VMStorage storage = _locs[loc];\n+  assert(storage.is_valid(), \"not set\");\n+  return storage;\n+}\n+\n+VMStorage StubLocations::get(VMStorage placeholder) const {\n+  assert(placeholder.type() == StorageType::PLACEHOLDER, \"must be\");\n+  return get(placeholder.index());\n+}\n+\n+int StubLocations::data_offset(uint32_t loc) const {\n+  VMStorage storage = get(loc);\n+  assert(storage.type() == StorageType::FRAME_DATA, \"must be\");\n+  return storage.offset();\n+}\n+\n@@ -57,6 +90,1 @@\n-  RegType rType = static_cast<RegType>(type);\n-  if (rType == VMStorage::stack_type()) {\n-    return VMStorage::stack_storage(segment_mask_or_size, index_or_offset);\n-  } else {\n-    return VMStorage::reg_storage(rType, segment_mask_or_size, index_or_offset);\n-  }\n+  return VMStorage(static_cast<StorageType>(type), segment_mask_or_size, index_or_offset);\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -36,0 +36,22 @@\n+\/\/ needs to match StubLocations in Java code.\n+\/\/ placeholder locations to be filled in by\n+\/\/ the code gen code\n+class StubLocations {\n+public:\n+  enum Location : uint32_t {\n+    TARGET_ADDRESS,\n+    RETURN_BUFFER,\n+    MAX\n+  };\n+private:\n+  VMStorage _locs[MAX];\n+public:\n+  StubLocations();\n+\n+  void set(uint32_t loc, VMStorage storage);\n+  void set_frame_data(uint32_t loc, int offset);\n+  VMStorage get(uint32_t loc) const;\n+  VMStorage get(VMStorage placeholder) const;\n+  int data_offset(uint32_t loc) const;\n+};\n+\n@@ -113,2 +135,2 @@\n-  void generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n-    pd_generate(masm, tmp, in_stk_bias, out_stk_bias);\n+  void generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const {\n+    pd_generate(masm, tmp, in_stk_bias, out_stk_bias, locs);\n@@ -119,1 +141,1 @@\n-  void pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const;\n+  void pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias, const StubLocations& locs) const;\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-enum class RegType : int8_t; \/\/ defined in arch specific headers\n+enum class StorageType : int8_t; \/\/ defined in arch specific headers\n@@ -39,1 +39,1 @@\n-  constexpr static RegType INVALID_TYPE = static_cast<RegType>(-1);\n+  constexpr static StorageType INVALID_TYPE = static_cast<StorageType>(-1);\n@@ -41,1 +41,1 @@\n-  RegType _type;\n+  StorageType _type;\n@@ -47,2 +47,5 @@\n-  constexpr VMStorage(RegType type, uint16_t segment_mask_or_size, uint32_t index_or_offset)\n-    : _type(type), _segment_mask_or_size(segment_mask_or_size), _index_or_offset(index_or_offset) {};\n+\n+  constexpr inline static bool is_reg(StorageType type);\n+  constexpr inline static StorageType stack_type();\n+  constexpr inline static StorageType placeholder_type();\n+  constexpr inline static StorageType frame_data_type();\n@@ -51,0 +54,2 @@\n+  constexpr VMStorage(StorageType type, uint16_t segment_mask_or_size, uint32_t index_or_offset)\n+    : _type(type), _segment_mask_or_size(segment_mask_or_size), _index_or_offset(index_or_offset) {};\n@@ -52,3 +57,2 @@\n-  constexpr static VMStorage reg_storage(RegType type, uint16_t segment_mask, uint32_t index) {\n-    assert(type != stack_type(), \"can not be stack type\");\n-    assert(type != INVALID_TYPE, \"can not be invalid type\");\n+  constexpr static VMStorage reg_storage(StorageType type, uint16_t segment_mask, uint32_t index) {\n+    assert(is_reg(type), \"must be reg\");\n@@ -72,1 +76,1 @@\n-  constexpr inline static RegType stack_type();\n+  StorageType type() const { return _type; }\n@@ -74,1 +78,0 @@\n-  RegType type()              const { return _type; }\n@@ -76,9 +79,11 @@\n-  uint16_t segment_mask()     const { assert(is_reg(), \"must be reg\");     return _segment_mask_or_size; }\n-  uint16_t stack_size()       const { assert(is_stack(), \"must be stack\"); return _segment_mask_or_size; }\n-  uint32_t index()            const { assert(is_reg(), \"must be reg\");     return _index_or_offset; }\n-  uint32_t offset()           const { assert(is_stack(), \"must be stack\"); return _index_or_offset; }\n-  uint32_t index_or_offset()  const { assert(is_valid(), \"must be valid\"); return _index_or_offset; }\n-\n-  bool is_valid() const { return _type != INVALID_TYPE; }\n-  bool is_reg() const { return is_valid() && !is_stack(); }\n-  bool is_stack() const { return _type == stack_type(); }\n+  uint16_t segment_mask()    const { assert(is_reg(), \"must be reg\");                  return _segment_mask_or_size; }\n+  uint16_t stack_size()      const { assert(is_stack() || is_frame_data(), \"must be\"); return _segment_mask_or_size; }\n+  uint32_t index()           const { assert(is_reg() || is_placeholder(), \"must be\");  return _index_or_offset; }\n+  uint32_t offset()          const { assert(is_stack() || is_frame_data(), \"must be\"); return _index_or_offset; }\n+  uint32_t index_or_offset() const { assert(is_valid(), \"must be valid\");              return _index_or_offset; }\n+\n+  bool is_valid()       const { return _type != INVALID_TYPE; }\n+  bool is_reg()         const { return is_reg(_type); }\n+  bool is_stack()       const { return _type == stack_type(); }\n+  bool is_placeholder() const { return _type == placeholder_type(); }\n+  bool is_frame_data()  const { return _type == frame_data_type(); }\n","filename":"src\/hotspot\/share\/prims\/vmstorageBase.inline.hpp","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+    final VMStorage scratch1;\n+    final VMStorage scratch2;\n+\n@@ -48,0 +51,1 @@\n+                         VMStorage scratch1, VMStorage scratch2,\n@@ -55,0 +59,2 @@\n+        this.scratch1 = scratch1;\n+        this.scratch2 = scratch2;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/ABIDescriptor.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi;\n+\n+\/\/ must keep in sync with StubLocations in VM code\n+public enum StubLocations {\n+    TARGET_ADDRESS,\n+    RETURN_BUFFER;\n+\n+    public VMStorage storage(byte type) {\n+        return new VMStorage(type, (short) 8, ordinal());\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/StubLocations.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.StubLocations;\n@@ -43,1 +44,1 @@\n-        return cls == StorageClasses.STACK;\n+        return cls == StorageType.STACK;\n@@ -49,2 +50,2 @@\n-            case StorageClasses.INTEGER: return INTEGER_REG_SIZE;\n-            case StorageClasses.VECTOR: return VECTOR_REG_SIZE;\n+            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n+            case StorageType.VECTOR: return VECTOR_REG_SIZE;\n@@ -57,1 +58,1 @@\n-    public interface StorageClasses {\n+    public interface StorageType {\n@@ -61,0 +62,1 @@\n+        byte PLACEHOLDER = 3;\n@@ -96,1 +98,0 @@\n-\n@@ -132,1 +133,1 @@\n-        return new VMStorage(StorageClasses.INTEGER, REG64_MASK, index, \"r\" + index);\n+        return new VMStorage(StorageType.INTEGER, REG64_MASK, index, \"r\" + index);\n@@ -136,1 +137,1 @@\n-        return new VMStorage(StorageClasses.VECTOR, V128_MASK, index, \"v\" + index);\n+        return new VMStorage(StorageType.VECTOR, V128_MASK, index, \"v\" + index);\n@@ -140,1 +141,1 @@\n-        return new VMStorage(StorageClasses.STACK, size, byteOffset);\n+        return new VMStorage(StorageType.STACK, size, byteOffset);\n@@ -151,1 +152,1 @@\n-                                       VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n+                                       VMStorage scratch1, VMStorage scratch2) {\n@@ -168,1 +169,3 @@\n-            targetAddrStorage, retBufAddrStorage);\n+            scratch1, scratch2,\n+            StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER),\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -92,2 +92,1 @@\n-        r9,  \/\/ target addr reg\n-        r10  \/\/ return buffer addr reg\n+        r9, r10  \/\/ scratch 1 & 2\n@@ -252,2 +251,2 @@\n-            nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n-            nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n+            nRegs[StorageType.INTEGER] = MAX_REGISTER_ARGUMENTS;\n+            nRegs[StorageType.VECTOR] = MAX_REGISTER_ARGUMENTS;\n@@ -331,1 +330,1 @@\n-                        StorageClasses.INTEGER, layout);\n+                        StorageType.INTEGER, layout);\n@@ -338,1 +337,1 @@\n-                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -357,1 +356,1 @@\n-                        StorageClasses.INTEGER, AArch64.C_POINTER);\n+                        StorageType.INTEGER, AArch64.C_POINTER);\n@@ -365,1 +364,1 @@\n-                        StorageClasses.VECTOR, group.memberLayouts().size());\n+                        StorageType.VECTOR, group.memberLayouts().size());\n@@ -371,1 +370,1 @@\n-                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -388,1 +387,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                        storageCalculator.nextStorage(StorageType.INTEGER, layout);\n@@ -394,1 +393,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                        storageCalculator.nextStorage(StorageType.INTEGER, layout);\n@@ -400,1 +399,1 @@\n-                        storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                        storageCalculator.nextStorage(StorageType.VECTOR, layout);\n@@ -433,1 +432,1 @@\n-                            StorageClasses.INTEGER, layout);\n+                            StorageType.INTEGER, layout);\n@@ -441,1 +440,1 @@\n-                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -454,1 +453,1 @@\n-                            StorageClasses.INTEGER, AArch64.C_POINTER);\n+                            StorageType.INTEGER, AArch64.C_POINTER);\n@@ -463,1 +462,1 @@\n-                            StorageClasses.VECTOR, group.memberLayouts().size());\n+                            StorageType.VECTOR, group.memberLayouts().size());\n@@ -469,1 +468,1 @@\n-                            boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                            boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -482,1 +481,1 @@\n-                            storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                            storageCalculator.nextStorage(StorageType.INTEGER, layout);\n@@ -488,1 +487,1 @@\n-                            storageCalculator.nextStorage(StorageClasses.INTEGER, layout);\n+                            storageCalculator.nextStorage(StorageType.INTEGER, layout);\n@@ -493,1 +492,1 @@\n-                            storageCalculator.nextStorage(StorageClasses.VECTOR, layout);\n+                            storageCalculator.nextStorage(StorageType.VECTOR, layout);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.StubLocations;\n@@ -52,1 +53,1 @@\n-        return cls == StorageClasses.STACK;\n+        return cls == StorageType.STACK;\n@@ -58,3 +59,3 @@\n-            case StorageClasses.INTEGER: return INTEGER_REG_SIZE;\n-            case StorageClasses.VECTOR: return VECTOR_REG_SIZE;\n-            case StorageClasses.X87: return X87_REG_SIZE;\n+            case StorageType.INTEGER: return INTEGER_REG_SIZE;\n+            case StorageType.VECTOR: return VECTOR_REG_SIZE;\n+            case StorageType.X87: return X87_REG_SIZE;\n@@ -67,1 +68,2 @@\n-    public interface StorageClasses {\n+    \/\/ must keep in sync with StorageType in VM code\n+    public interface StorageType {\n@@ -72,0 +74,1 @@\n+        byte PLACEHOLDER = 4;\n@@ -127,1 +130,1 @@\n-        return new VMStorage(StorageClasses.INTEGER, REG64_MASK, index, debugName);\n+        return new VMStorage(StorageType.INTEGER, REG64_MASK, index, debugName);\n@@ -131,1 +134,1 @@\n-        return new VMStorage(StorageClasses.VECTOR, XMM_MASK, index, debugName);\n+        return new VMStorage(StorageType.VECTOR, XMM_MASK, index, debugName);\n@@ -135,1 +138,1 @@\n-        return new VMStorage(StorageClasses.STACK, size, byteOffset);\n+        return new VMStorage(StorageType.STACK, size, byteOffset);\n@@ -139,1 +142,1 @@\n-        return new VMStorage(StorageClasses.X87, STP_MASK, index, \"X87(\" + index + \")\");\n+        return new VMStorage(StorageType.X87, STP_MASK, index, \"X87(\" + index + \")\");\n@@ -145,1 +148,1 @@\n-                                       VMStorage targetAddrStorage, VMStorage retBufAddrStorage) {\n+                                       VMStorage scratch1, VMStorage scratch2) {\n@@ -165,1 +168,3 @@\n-            targetAddrStorage, retBufAddrStorage);\n+            scratch1, scratch2,\n+            StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER),\n+            StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.abi.LinkerOptions;\n@@ -76,2 +77,1 @@\n-        r10, \/\/ target addr reg\n-        r11  \/\/ ret buf addr reg\n+        r10, r11 \/\/ scratch 1 & 2\n@@ -160,1 +160,1 @@\n-            return type == StorageClasses.INTEGER ?\n+            return type == StorageType.INTEGER ?\n@@ -206,1 +206,1 @@\n-                storage[i] = nextStorage(sse ? StorageClasses.VECTOR : StorageClasses.INTEGER);\n+                storage[i] = nextStorage(sse ? StorageType.VECTOR : StorageType.INTEGER);\n@@ -213,2 +213,2 @@\n-                case StorageClasses.INTEGER -> nIntegerReg;\n-                case StorageClasses.VECTOR -> nVectorReg;\n+                case StorageType.INTEGER -> nIntegerReg;\n+                case StorageType.VECTOR -> nVectorReg;\n@@ -221,2 +221,2 @@\n-                case StorageClasses.INTEGER -> nIntegerReg++;\n-                case StorageClasses.VECTOR -> nVectorReg++;\n+                case StorageType.INTEGER -> nIntegerReg++;\n+                case StorageType.VECTOR -> nVectorReg++;\n@@ -260,1 +260,1 @@\n-                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -269,1 +269,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -273,1 +273,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -277,1 +277,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n@@ -307,1 +307,1 @@\n-                        boolean useFloat = storage.type() == StorageClasses.VECTOR;\n+                        boolean useFloat = storage.type() == StorageType.VECTOR;\n@@ -315,1 +315,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -320,1 +320,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -324,1 +324,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -73,2 +73,1 @@\n-        r10, \/\/ target addr reg\n-        r11  \/\/ ret buf addr reg\n+        r10, r11 \/\/ scratch 1 & 2\n@@ -180,1 +179,1 @@\n-            return CWindows.inputStorage[StorageClasses.INTEGER][nRegs - 1];\n+            return CWindows.inputStorage[StorageType.INTEGER][nRegs - 1];\n@@ -202,1 +201,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -212,1 +211,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -218,1 +217,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -223,1 +222,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -228,1 +227,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n@@ -233,1 +232,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n@@ -266,1 +265,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -274,1 +273,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -280,1 +279,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -286,1 +285,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.INTEGER);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.INTEGER);\n@@ -291,1 +290,1 @@\n-                    VMStorage storage = storageCalculator.nextStorage(StorageClasses.VECTOR);\n+                    VMStorage storage = storageCalculator.nextStorage(StorageType.VECTOR);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.foreign.Linker;\n@@ -42,0 +41,2 @@\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n@@ -60,1 +61,2 @@\n-    private static final short STACK_SLOT_SIZE = 8;\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n@@ -74,1 +76,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) }\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n@@ -98,1 +100,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -128,1 +130,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -150,1 +152,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -210,1 +212,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -241,1 +243,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -265,2 +267,2 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n-            { unboxAddress(), vmStore(r9, long.class) }\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n@@ -294,2 +296,2 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -332,1 +334,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -386,1 +388,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -416,1 +418,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -439,1 +441,1 @@\n-            { unboxAddress(), vmStore(r9, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n@@ -59,0 +61,2 @@\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n@@ -72,1 +76,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -100,1 +104,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -131,1 +135,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -161,1 +165,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -191,1 +195,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -216,1 +220,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -247,1 +251,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -282,1 +286,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -339,1 +343,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -382,1 +386,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -404,1 +408,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -463,2 +467,2 @@\n-            { unboxAddress(), vmStore(r11, long.class) },\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -495,1 +499,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.lang.foreign.Linker;\n@@ -43,0 +42,2 @@\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n@@ -60,0 +61,1 @@\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n@@ -73,1 +75,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) }\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n@@ -90,1 +92,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -112,1 +114,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -136,1 +138,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -167,1 +169,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -204,1 +206,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -238,1 +240,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -268,1 +270,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -299,1 +301,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -320,1 +322,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -344,1 +346,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n@@ -373,1 +375,1 @@\n-            { unboxAddress(), vmStore(r10, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"}]}