{"files":[{"patch":"@@ -267,3 +267,1 @@\n-    if test \"x$OPENJDK_TARGET_OS\" = xaix || \\\n-        ( test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\" && \\\n-        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ) ; then\n+    if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n","filename":"make\/autoconf\/jvm-features.m4","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3529,1 +3529,1 @@\n-  format %{ \"addv  $tmp, T8B, $src1\\t# src1 and src2 are the same\\n\\t\"\n+  format %{ \"addv  $tmp, T8B, $src1\\n\\t\"\n@@ -3532,1 +3532,1 @@\n-            \"cset  $dst\" %}\n+            \"cset  $dst\\t# anytrue 8B\" %}\n@@ -3534,0 +3534,1 @@\n+    \/\/ No need to use src2.\n@@ -3548,1 +3549,1 @@\n-  format %{ \"addv  $tmp, T16B, $src1\\t# src1 and src2 are the same\\n\\t\"\n+  format %{ \"addv  $tmp, T16B, $src1\\n\\t\"\n@@ -3551,1 +3552,1 @@\n-            \"cset  $dst\" %}\n+            \"cset  $dst\\t# anytrue 16B\" %}\n@@ -3553,0 +3554,1 @@\n+    \/\/ No need to use src2.\n@@ -3567,3 +3569,1 @@\n-  format %{ \"andr  $tmp, T8B, $src1, $src2\\t# src2 is maskAllTrue\\n\\t\"\n-            \"notr  $tmp, T8B, $tmp\\n\\t\"\n-            \"addv  $tmp, T8B, $tmp\\n\\t\"\n+  format %{ \"uminv $tmp, T8B, $src1\\n\\t\"\n@@ -3571,2 +3571,2 @@\n-            \"cmp   $dst, 0\\n\\t\"\n-            \"cset  $dst\" %}\n+            \"cmp   $dst, 0xff\\n\\t\"\n+            \"cset  $dst\\t# alltrue 8B\" %}\n@@ -3574,4 +3574,2 @@\n-    __ andr(as_FloatRegister($tmp$$reg), __ T8B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($tmp$$reg));\n-    __ addv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($tmp$$reg));\n+    \/\/ No need to use src2.\n+    __ uminv(as_FloatRegister($tmp$$reg), __ T8B, as_FloatRegister($src1$$reg));\n@@ -3579,1 +3577,1 @@\n-    __ cmpw($dst$$Register, zr);\n+    __ cmpw($dst$$Register, 0xff);\n@@ -3591,3 +3589,1 @@\n-  format %{ \"andr  $tmp, T16B, $src1, $src2\\t# src2 is maskAllTrue\\n\\t\"\n-            \"notr  $tmp, T16B, $tmp\\n\\t\"\n-            \"addv  $tmp, T16B, $tmp\\n\\t\"\n+  format %{ \"uminv $tmp, T16B, $src1\\n\\t\"\n@@ -3595,2 +3591,2 @@\n-            \"cmp   $dst, 0\\n\\t\"\n-            \"cset  $dst\" %}\n+            \"cmp   $dst, 0xff\\n\\t\"\n+            \"cset  $dst\\t# alltrue 16B\" %}\n@@ -3598,4 +3594,2 @@\n-    __ andr(as_FloatRegister($tmp$$reg), __ T16B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($tmp$$reg));\n-    __ addv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($tmp$$reg));\n+    \/\/ No need to use src2.\n+    __ uminv(as_FloatRegister($tmp$$reg), __ T16B, as_FloatRegister($src1$$reg));\n@@ -3603,1 +3597,1 @@\n-    __ cmpw($dst$$Register, zr);\n+    __ cmpw($dst$$Register, 0xff);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":18,"deletions":24,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1418,1 +1418,1 @@\n-  format %{ \"addv  $tmp, T$1B, $src1\\t# src1 and src2 are the same\\n\\t\"\n+  format %{ \"addv  $tmp, T$1B, $src1\\n\\t\"\n@@ -1421,1 +1421,1 @@\n-            \"cset  $dst\" %}\n+            \"cset  $dst\\t# anytrue $1B\" %}\n@@ -1423,0 +1423,1 @@\n+    \/\/ No need to use src2.\n@@ -1441,3 +1442,1 @@\n-  format %{ \"andr  $tmp, T$1B, $src1, $src2\\t# src2 is maskAllTrue\\n\\t\"\n-            \"notr  $tmp, T$1B, $tmp\\n\\t\"\n-            \"addv  $tmp, T$1B, $tmp\\n\\t\"\n+  format %{ \"uminv $tmp, T$1B, $src1\\n\\t\"\n@@ -1445,2 +1444,2 @@\n-            \"cmp   $dst, 0\\n\\t\"\n-            \"cset  $dst\" %}\n+            \"cmp   $dst, 0xff\\n\\t\"\n+            \"cset  $dst\\t# alltrue $1B\" %}\n@@ -1448,4 +1447,2 @@\n-    __ andr(as_FloatRegister($tmp$$reg), __ T$1B,\n-            as_FloatRegister($src1$$reg), as_FloatRegister($src2$$reg));\n-    __ notr(as_FloatRegister($tmp$$reg), __ T$1B, as_FloatRegister($tmp$$reg));\n-    __ addv(as_FloatRegister($tmp$$reg), __ T$1B, as_FloatRegister($tmp$$reg));\n+    \/\/ No need to use src2.\n+    __ uminv(as_FloatRegister($tmp$$reg), __ T$1B, as_FloatRegister($src1$$reg));\n@@ -1453,1 +1450,1 @@\n-    __ cmpw($dst$$Register, zr);\n+    __ cmpw($dst$$Register, 0xff);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":9,"deletions":12,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2430,0 +2430,1 @@\n+  INSN(uminv,  1, 0b110001101010, 1); \/\/ accepted arrangements: T8B, T16B, T4H, T8H,      T4S\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-      ContendedPaddingWidth = dcache_line;\n+    ContendedPaddingWidth = dcache_line;\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -42,1 +42,23 @@\n-  ShouldNotReachHere();\n+  if (UseSIGTRAP) {\n+    DEBUG_ONLY( __ should_not_reach_here(\"C1SafepointPollStub::emit_code\"); )\n+  } else {\n+    assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+           \"polling page return stub not created yet\");\n+    address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+    __ bind(_entry);\n+    \/\/ Using pc relative address computation.\n+    {\n+      Label next_pc;\n+      __ bl(next_pc);\n+      __ bind(next_pc);\n+    }\n+    int current_offset = __ offset();\n+    __ mflr(R12);\n+    __ add_const_optimized(R12, R12, safepoint_offset() - current_offset);\n+    __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n+\n+    __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n+    __ mtctr(R0);\n+    __ bctr();\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1323,2 +1323,2 @@\n-  const Register return_pc        = R31;  \/\/ Must survive C-call to enable_stack_reserved_zone().\n-  const Register polling_page     = R12;\n+  const Register return_pc = R31;  \/\/ Must survive C-call to enable_stack_reserved_zone().\n+  const Register temp      = R12;\n@@ -1334,2 +1334,0 @@\n-  __ ld(polling_page, in_bytes(Thread::polling_page_offset()), R16_thread);\n-\n@@ -1347,2 +1345,5 @@\n-  __ relocate(relocInfo::poll_return_type);\n-  __ load_from_polling_page(polling_page);\n+  if (!UseSIGTRAP) {\n+    code_stub->set_safepoint_offset(__ offset());\n+    __ relocate(relocInfo::poll_return_type);\n+  }\n+  __ safepoint_poll(*code_stub->entry(), temp, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"macroAssembler_ppc.inline.hpp\"\n+#include \"opto\/compile.hpp\"\n+#include \"opto\/node.hpp\"\n+#include \"opto\/output.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+\n+#define __ masm.\n+void C2SafepointPollStubTable::emit_stub_impl(MacroAssembler& masm, C2SafepointPollStub* entry) const {\n+  assert(SharedRuntime::polling_page_return_handler_blob() != NULL,\n+         \"polling page return stub not created yet\");\n+  address stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  __ bind(entry->_stub_label);\n+  \/\/ Using pc relative address computation.\n+  {\n+    Label next_pc;\n+    __ bl(next_pc);\n+    __ bind(next_pc);\n+  }\n+  int current_offset = __ offset();\n+  \/\/ Code size should not depend on offset: see _stub_size computation in output.cpp\n+  __ load_const32(R12, entry->_safepoint_offset - current_offset);\n+  __ mflr(R0);\n+  __ add(R12, R12, R0);\n+  __ std(R12, in_bytes(JavaThread::saved_exception_pc_offset()), R16_thread);\n+\n+  __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));\n+  __ mtctr(R0);\n+  __ bctr();\n+}\n+#undef __\n","filename":"src\/hotspot\/cpu\/ppc\/c2_safepointPollStubTable_ppc.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -232,1 +233,1 @@\n-frame frame::sender(RegisterMap* map) const {\n+frame frame::sender_raw(RegisterMap* map) const {\n@@ -249,0 +250,10 @@\n+frame frame::sender(RegisterMap* map) const {\n+  frame result = sender_raw(map);\n+\n+  if (map->process_frames()) {\n+    StackWatermarkSet::on_iteration(map->thread(), result);\n+  }\n+\n+  return result;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2015 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -421,0 +421,3 @@\n+  \/\/ returns the sending frame, without applying any barriers\n+  frame sender_raw(RegisterMap* map) const;\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -830,0 +830,1 @@\n+\/\/ Apply stack watermark barrier.\n@@ -845,0 +846,17 @@\n+\n+  \/\/ The below poll is for the stack watermark barrier. It allows fixing up frames lazily,\n+  \/\/ that would normally not be safe to use. Such bad returns into unsafe territory of\n+  \/\/ the stack, will call InterpreterRuntime::at_unwind.\n+  Label slow_path;\n+  Label fast_path;\n+  safepoint_poll(slow_path, R11_scratch1, true \/* at_return *\/, false \/* in_nmethod *\/);\n+  b(fast_path);\n+  bind(slow_path);\n+  push(state);\n+  set_last_Java_frame(R1_SP, noreg);\n+  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::at_unwind), R16_thread);\n+  reset_last_Java_frame();\n+  pop(state);\n+  align(32);\n+  bind(fast_path);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3060,5 +3060,26 @@\n-void MacroAssembler::safepoint_poll(Label& slow_path, Register temp_reg) {\n-  ld(temp_reg, in_bytes(Thread::polling_word_offset()), R16_thread);\n-  \/\/ Armed page has poll_bit set.\n-  andi_(temp_reg, temp_reg, SafepointMechanism::poll_bit());\n-  bne(CCR0, slow_path);\n+void MacroAssembler::safepoint_poll(Label& slow_path, Register temp, bool at_return, bool in_nmethod) {\n+  ld(temp, in_bytes(Thread::polling_word_offset()), R16_thread);\n+\n+  if (at_return) {\n+    if (in_nmethod) {\n+      if (UseSIGTRAP) {\n+        \/\/ Use Signal Handler.\n+        relocate(relocInfo::poll_return_type);\n+        td(traptoGreaterThanUnsigned, R1_SP, temp);\n+      } else {\n+        cmpld(CCR0, R1_SP, temp);\n+        \/\/ Stub may be out of range for short conditional branch.\n+        bc_far_optimized(Assembler::bcondCRbiIs1, bi0(CCR0, Assembler::greater), slow_path);\n+      }\n+    } else { \/\/ Not in nmethod.\n+      \/\/ Frame still on stack, need to get fp.\n+      Register fp = R0;\n+      ld(fp, _abi0(callers_sp), R1_SP);\n+      cmpld(CCR0, fp, temp);\n+      bgt(CCR0, slow_path);\n+    }\n+  } else { \/\/ Normal safepoint poll. Not at return.\n+    assert(!in_nmethod, \"should use load_from_polling_page\");\n+    andi_(temp, temp, SafepointMechanism::poll_bit());\n+    bne(CCR0, slow_path);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -669,1 +669,1 @@\n-  void safepoint_poll(Label& slow_path, Register temp_reg);\n+  void safepoint_poll(Label& slow_path, Register temp, bool at_return, bool in_nmethod);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2018 SAP SE. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -86,1 +86,0 @@\n-    \/\/ Is the current instruction a POTENTIAL read access to the polling page?\n@@ -95,0 +94,6 @@\n+\n+  bool is_safepoint_poll_return() {\n+    \/\/ Safepoint poll at nmethod return with watermark check.\n+    return MacroAssembler::is_td(long_at(0), Assembler::traptoGreaterThanUnsigned,\n+                                 \/* R1_SP *\/ 1, \/* any reg *\/ -1);\n+  }\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+\/\/ Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -1565,1 +1565,1 @@\n-    st->print(\"touch polling page\\n\\t\");\n+    st->print(\"safepoint poll\\n\\t\");\n@@ -1580,1 +1580,1 @@\n-  const Register polling_page     = R12;\n+  const Register temp             = R12;\n@@ -1585,7 +1585,0 @@\n-  }\n-\n-  if (method_needs_polling) {\n-    __ ld(polling_page, in_bytes(JavaThread::polling_page_offset()), R16_thread);\n-  }\n-\n-  if (!method_is_frameless) {\n@@ -1603,4 +1596,7 @@\n-    \/\/ We need to mark the code position where the load from the safepoint\n-    \/\/ polling page was emitted as relocInfo::poll_return_type here.\n-    __ relocate(relocInfo::poll_return_type);\n-    __ load_from_polling_page(polling_page);\n+    Label dummy_label;\n+    Label* code_stub = &dummy_label;\n+    if (!UseSIGTRAP && !C->output()->in_scratch_emit_size()) {\n+      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      __ relocate(relocInfo::poll_return_type);\n+    }\n+    __ safepoint_poll(*code_stub, temp, true \/* at_return *\/, true \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2265,1 +2265,4 @@\n-    __ safepoint_poll(needs_safepoint, sync_state);\n+    \/\/ Note: We should not reach here with active stack watermark. There's no safepoint between\n+    \/\/       start of the native wrapper and this check where it could have been added.\n+    \/\/       We don't check the watermark in the fast path.\n+    __ safepoint_poll(needs_safepoint, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -2312,1 +2315,1 @@\n-    __ safepoint_poll(sync, sync_state);\n+    __ safepoint_poll(sync, sync_state, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -3011,1 +3014,1 @@\n-    return_pc_location = RegisterSaver::return_pc_is_lr;\n+    return_pc_location = RegisterSaver::return_pc_is_pre_saved;\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1452,1 +1452,1 @@\n-  __ safepoint_poll(do_safepoint, sync_state);\n+  __ safepoint_poll(do_safepoint, sync_state, true \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1752,1 +1752,1 @@\n-    __ safepoint_poll(slow_path, sync_state);\n+    __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n@@ -1806,1 +1806,1 @@\n-    __ safepoint_poll(slow_path, sync_state);\n+    __ safepoint_poll(slow_path, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -101,0 +101,1 @@\n+  constexpr static bool supports_stack_watermark_barrier() { return true; }\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3235,1 +3235,3 @@\n-instruct sqrtF_reg(regF dst, regF src) %{\n+\/\/ sqrtss instruction needs destination register to be pre initialized for best performance\n+\/\/ Therefore only the instruct rule where the input is pre-loaded into dst register is defined below\n+instruct sqrtF_reg(regF dst) %{\n@@ -3237,28 +3239,2 @@\n-  match(Set dst (SqrtF src));\n-\n-  format %{ \"sqrtss  $dst, $src\" %}\n-  ins_cost(150);\n-  ins_encode %{\n-    __ sqrtss($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct sqrtF_mem(regF dst, memory src) %{\n-  predicate(UseSSE>=1);\n-  match(Set dst (SqrtF (LoadF src)));\n-\n-  format %{ \"sqrtss  $dst, $src\" %}\n-  ins_cost(150);\n-  ins_encode %{\n-    __ sqrtss($dst$$XMMRegister, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct sqrtF_imm(regF dst, immF con) %{\n-  predicate(UseSSE>=1);\n-  match(Set dst (SqrtF con));\n-\n-  format %{ \"sqrtss  $dst, [$constantaddress]\\t# load from constant table: float=$con\" %}\n-  ins_cost(150);\n+  match(Set dst (SqrtF dst));\n+  format %{ \"sqrtss  $dst, $dst\" %}\n@@ -3266,1 +3242,1 @@\n-    __ sqrtss($dst$$XMMRegister, $constantaddress($con));\n+    __ sqrtss($dst$$XMMRegister, $dst$$XMMRegister);\n@@ -3271,1 +3247,3 @@\n-instruct sqrtD_reg(regD dst, regD src) %{\n+\/\/ sqrtsd instruction needs destination register to be pre initialized for best performance\n+\/\/ Therefore only the instruct rule where the input is pre-loaded into dst register is defined below\n+instruct sqrtD_reg(regD dst) %{\n@@ -3273,27 +3251,2 @@\n-  match(Set dst (SqrtD src));\n-\n-  format %{ \"sqrtsd  $dst, $src\" %}\n-  ins_cost(150);\n-  ins_encode %{\n-    __ sqrtsd($dst$$XMMRegister, $src$$XMMRegister);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct sqrtD_mem(regD dst, memory src) %{\n-  predicate(UseSSE>=2);\n-  match(Set dst (SqrtD (LoadD src)));\n-\n-  format %{ \"sqrtsd  $dst, $src\" %}\n-  ins_cost(150);\n-  ins_encode %{\n-    __ sqrtsd($dst$$XMMRegister, $src$$Address);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct sqrtD_imm(regD dst, immD con) %{\n-  predicate(UseSSE>=2);\n-  match(Set dst (SqrtD con));\n-  format %{ \"sqrtsd  $dst, [$constantaddress]\\t# load from constant table: double=$con\" %}\n-  ins_cost(150);\n+  match(Set dst (SqrtD dst));\n+  format %{ \"sqrtsd  $dst, $dst\" %}\n@@ -3301,1 +3254,1 @@\n-    __ sqrtsd($dst$$XMMRegister, $constantaddress($con));\n+    __ sqrtsd($dst$$XMMRegister, $dst$$XMMRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":12,"deletions":59,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-  _poll_page_armed_value    = bad_page_val  + poll_bit();\n+  _poll_page_armed_value    = bad_page_val;\n","filename":"src\/hotspot\/os\/aix\/safepointMechanism_aix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1407,1 +1407,1 @@\n-#ifdef __APPLE__\n+#if defined(__APPLE__) && !defined(ZERO)\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -224,0 +224,1 @@\n+      CodeBlob *cb = NULL;\n@@ -234,3 +235,5 @@\n-      else if (USE_POLL_BIT_ONLY\n-               ? (sig == SIGTRAP && ((NativeInstruction*)pc)->is_safepoint_poll())\n-               : (sig == SIGSEGV && SafepointMechanism::is_poll_address(addr))) {\n+      else if ((sig == USE_POLL_BIT_ONLY ? SIGTRAP : SIGSEGV) &&\n+               ((NativeInstruction*)pc)->is_safepoint_poll() &&\n+               CodeCache::contains((void*) pc) &&\n+               ((cb = CodeCache::find_blob(pc)) != NULL) &&\n+               cb->is_compiled()) {\n@@ -245,0 +248,12 @@\n+      else if (UseSIGTRAP && sig == SIGTRAP &&\n+               ((NativeInstruction*)pc)->is_safepoint_poll_return() &&\n+               CodeCache::contains((void*) pc) &&\n+               ((cb = CodeCache::find_blob(pc)) != NULL) &&\n+               cb->is_compiled()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: safepoint_poll at return at \" INTPTR_FORMAT \" (nmethod)\", p2i(pc));\n+        }\n+        stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+        goto run_stub;\n+      }\n+\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2012, 2019 SAP SE. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n@@ -273,0 +273,11 @@\n+      else if (UseSIGTRAP && sig == SIGTRAP &&\n+               ((NativeInstruction*)pc)->is_safepoint_poll_return() &&\n+               CodeCache::contains((void*) pc) &&\n+               ((cb = CodeCache::find_blob(pc)) != NULL) &&\n+               cb->is_compiled()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: safepoint_poll at return at \" INTPTR_FORMAT \" (nmethod)\", p2i(pc));\n+        }\n+        stub = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+      }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -784,0 +784,1 @@\n+       !strcmp(_matrule->_rChild->_opType,\"StrInflatedCopy\") ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -245,0 +245,1 @@\n+    NewMultiArray* nma;\n@@ -249,0 +250,4 @@\n+    } else if ((nma = x->array()->as_NewMultiArray()) != NULL &&\n+               (length = nma->dims()->at(0)->as_Constant()) != NULL) {\n+      assert(length->type()->as_IntConstant() != NULL, \"array length must be integer\");\n+      set_constant(length->type()->as_IntConstant()->value());\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -987,0 +987,1 @@\n+      (array->as_Constant() != NULL) ||\n@@ -988,1 +989,2 @@\n-      (array->as_NewArray() && array->as_NewArray()->length() && array->as_NewArray()->length()->type()->is_constant())) {\n+      (array->as_NewArray() && array->as_NewArray()->length() && array->as_NewArray()->length()->type()->is_constant()) ||\n+      (array->as_NewMultiArray() && array->as_NewMultiArray()->dims()->at(0)->type()->is_constant())) {\n@@ -1004,0 +1006,1 @@\n+      (array->as_Constant() != NULL) ||\n@@ -1005,1 +1008,2 @@\n-      (array->as_NewArray() && array->as_NewArray()->length() && array->as_NewArray()->length()->type()->is_constant())) {\n+      (array->as_NewArray() && array->as_NewArray()->length() && array->as_NewArray()->length()->type()->is_constant()) ||\n+      (array->as_NewMultiArray() && array->as_NewMultiArray()->dims()->at(0)->type()->is_constant())) {\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -408,1 +408,1 @@\n-  EXCEPTION_CONTEXT;\n+  Thread* current = Thread::current();\n@@ -428,2 +428,2 @@\n-  Handle loader(THREAD, (oop)NULL);\n-  Handle domain(THREAD, (oop)NULL);\n+  Handle loader;\n+  Handle domain;\n@@ -431,2 +431,2 @@\n-    loader = Handle(THREAD, accessing_klass->loader());\n-    domain = Handle(THREAD, accessing_klass->protection_domain());\n+    loader = Handle(current, accessing_klass->loader());\n+    domain = Handle(current, accessing_klass->protection_domain());\n@@ -445,1 +445,1 @@\n-    MutexLocker ml(Compile_lock);\n+    MutexLocker ml(current, Compile_lock);\n@@ -448,1 +448,1 @@\n-      kls = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, THREAD);\n+      kls = SystemDictionary::find_constrained_instance_or_array_klass(current, sym, loader);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -712,3 +712,2 @@\n-    Klass* context = actual_recv->get_Klass();\n-    target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context,\n-                                                       root_m->get_Method()));\n+    InstanceKlass* context = actual_recv->get_instanceKlass();\n+    target = methodHandle(THREAD, Dependencies::find_unique_concrete_method(context, root_m->get_Method()));\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1243,2 +1243,1 @@\n-                              const bool can_access_vm_annotations,\n-                              TRAPS) {\n+                              const bool can_access_vm_annotations) {\n@@ -1421,2 +1420,1 @@\n-                          _can_access_vm_annotations,\n-                          CHECK);\n+                          _can_access_vm_annotations);\n@@ -2737,2 +2735,1 @@\n-                          _can_access_vm_annotations,\n-                          CHECK_NULL);\n+                          _can_access_vm_annotations);\n@@ -3566,1 +3563,1 @@\n-void ClassFileParser::parse_classfile_synthetic_attribute(TRAPS) {\n+void ClassFileParser::parse_classfile_synthetic_attribute() {\n@@ -3766,1 +3763,1 @@\n-      parse_classfile_synthetic_attribute(CHECK);\n+      parse_classfile_synthetic_attribute();\n@@ -3804,2 +3801,1 @@\n-                          _can_access_vm_annotations,\n-                          CHECK);\n+                          _can_access_vm_annotations);\n@@ -4075,2 +4071,1 @@\n-                                            int java_fields_count,\n-                                            TRAPS) {\n+                                            int java_fields_count) {\n@@ -5421,1 +5416,1 @@\n-  apply_parsed_class_metadata(ik, _java_fields_count, CHECK);\n+  apply_parsed_class_metadata(ik, _java_fields_count);\n@@ -5640,2 +5635,2 @@\n-void ClassFileParser::prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS) {\n-  ResourceMark rm(THREAD);\n+void ClassFileParser::prepend_host_package_name(Thread* current, const InstanceKlass* unsafe_anonymous_host) {\n+  ResourceMark rm(current);\n@@ -5677,1 +5672,1 @@\n-    prepend_host_package_name(_unsafe_anonymous_host, CHECK);\n+    prepend_host_package_name(THREAD, _unsafe_anonymous_host);\n@@ -6264,2 +6259,1 @@\n-                                                    _local_interfaces,\n-                                                    CHECK);\n+                                                    _local_interfaces);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":12,"deletions":18,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -214,1 +214,1 @@\n-  void prepend_host_package_name(const InstanceKlass* unsafe_anonymous_host, TRAPS);\n+  void prepend_host_package_name(Thread* current, const InstanceKlass* unsafe_anonymous_host);\n@@ -231,1 +231,1 @@\n-  void apply_parsed_class_metadata(InstanceKlass* k, int fields_count, TRAPS);\n+  void apply_parsed_class_metadata(InstanceKlass* k, int fields_count);\n@@ -352,1 +352,1 @@\n-  void parse_classfile_synthetic_attribute(TRAPS);\n+  void parse_classfile_synthetic_attribute();\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-void ClassLoader::setup_bootstrap_search_path(TRAPS) {\n+void ClassLoader::setup_bootstrap_search_path(Thread* current) {\n@@ -512,1 +512,1 @@\n-  setup_bootstrap_search_path_impl(sys_class_path, CHECK);\n+  setup_bootstrap_search_path_impl(current, sys_class_path);\n@@ -516,1 +516,1 @@\n-void ClassLoader::setup_app_search_path(const char *class_path, TRAPS) {\n+void ClassLoader::setup_app_search_path(Thread* current, const char *class_path) {\n@@ -519,1 +519,1 @@\n-  ResourceMark rm;\n+  ResourceMark rm(current);\n@@ -524,1 +524,1 @@\n-    update_class_path_entry_list(path, false, false, false, CHECK);\n+    update_class_path_entry_list(current, path, false, false, false);\n@@ -544,1 +544,1 @@\n-void ClassLoader::setup_module_search_path(const char* path, TRAPS) {\n+void ClassLoader::setup_module_search_path(Thread* current, const char* path) {\n@@ -554,4 +554,4 @@\n-  new_entry = create_class_path_entry(path, &st, true \/* throw_exception *\/,\n-                                      false \/*is_boot_append *\/, false \/* from_class_path_attr *\/, CHECK);\n-  if (new_entry == NULL) {\n-    return;\n+  new_entry = create_class_path_entry(current, path, &st,\n+                                      false \/*is_boot_append *\/, false \/* from_class_path_attr *\/);\n+  if (new_entry != NULL) {\n+    add_to_module_path_entries(path, new_entry);\n@@ -559,3 +559,0 @@\n-\n-  add_to_module_path_entries(path, new_entry);\n-  return;\n@@ -598,1 +595,1 @@\n-        ClassPathEntry* new_entry = create_class_path_entry(path, &st, false, false, false, CHECK);\n+        ClassPathEntry* new_entry = create_class_path_entry(THREAD, path, &st, false, false);\n@@ -630,2 +627,2 @@\n-void ClassLoader::setup_bootstrap_search_path_impl(const char *class_path, TRAPS) {\n-  ResourceMark rm(THREAD);\n+void ClassLoader::setup_bootstrap_search_path_impl(Thread* current, const char *class_path) {\n+  ResourceMark rm(current);\n@@ -655,1 +652,1 @@\n-        ClassPathEntry* new_entry = create_class_path_entry(path, &st, false, false, false, CHECK);\n+        ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n@@ -672,1 +669,1 @@\n-      update_class_path_entry_list(path, false, true, false, CHECK);\n+      update_class_path_entry_list(current, path, false, true, false);\n@@ -679,1 +676,1 @@\n-void ClassLoader::add_to_exploded_build_list(Symbol* module_sym, TRAPS) {\n+void ClassLoader::add_to_exploded_build_list(Thread* current, Symbol* module_sym) {\n@@ -684,1 +681,1 @@\n-  ResourceMark rm(THREAD);\n+  ResourceMark rm(current);\n@@ -696,1 +693,1 @@\n-    ClassPathEntry* new_entry = create_class_path_entry(path, &st, false, false, false, CHECK);\n+    ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n@@ -706,1 +703,1 @@\n-        MutexLocker ml(THREAD, Module_lock);\n+        MutexLocker ml(current, Module_lock);\n@@ -722,2 +719,2 @@\n-ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const struct stat* st,\n-                                                     bool throw_exception,\n+ClassPathEntry* ClassLoader::create_class_path_entry(Thread* current,\n+                                                     const char *path, const struct stat* st,\n@@ -725,3 +722,2 @@\n-                                                     bool from_class_path_attr,\n-                                                     TRAPS) {\n-  JavaThread* thread = THREAD->as_Java_thread();\n+                                                     bool from_class_path_attr) {\n+  JavaThread* thread = current->as_Java_thread();\n@@ -735,6 +731,1 @@\n-      \/\/ This matches the classic VM\n-      if (throw_exception) {\n-        THROW_MSG_(vmSymbols::java_io_IOException(), \"Bad pathname\", NULL);\n-      } else {\n-        return NULL;\n-      }\n+      return NULL;\n@@ -752,15 +743,1 @@\n-        char *msg;\n-        if (error_msg == NULL) {\n-          msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;\n-          jio_snprintf(msg, strlen(path) + 127, \"error in opening JAR file %s\", path);\n-        } else {\n-          int len = (int)(strlen(path) + strlen(error_msg) + 128);\n-          msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, len); ;\n-          jio_snprintf(msg, len - 1, \"error in opening JAR file <%s> %s\", error_msg, path);\n-        }\n-        \/\/ Don't complain about bad jar files added via -Xbootclasspath\/a:.\n-        if (throw_exception && is_init_completed()) {\n-          THROW_MSG_(vmSymbols::java_lang_ClassNotFoundException(), msg, NULL);\n-        } else {\n-          return NULL;\n-        }\n+        return NULL;\n@@ -837,1 +814,2 @@\n-void ClassLoader::add_to_app_classpath_entries(const char* path,\n+void ClassLoader::add_to_app_classpath_entries(Thread* current,\n+                                               const char* path,\n@@ -839,2 +817,1 @@\n-                                               bool check_for_duplicates,\n-                                               TRAPS) {\n+                                               bool check_for_duplicates) {\n@@ -864,1 +841,1 @@\n-    ClassLoaderExt::process_jar_manifest(entry, check_for_duplicates, CHECK);\n+    ClassLoaderExt::process_jar_manifest(current, entry, check_for_duplicates);\n@@ -870,1 +847,2 @@\n-bool ClassLoader::update_class_path_entry_list(const char *path,\n+bool ClassLoader::update_class_path_entry_list(Thread* current,\n+                                               const char *path,\n@@ -873,2 +851,1 @@\n-                                               bool from_class_path_attr,\n-                                               TRAPS) {\n+                                               bool from_class_path_attr) {\n@@ -879,1 +856,1 @@\n-    new_entry = create_class_path_entry(path, &st, \/*throw_exception=*\/true, is_boot_append, from_class_path_attr, CHECK_false);\n+    new_entry = create_class_path_entry(current, path, &st, is_boot_append, from_class_path_attr);\n@@ -889,1 +866,1 @@\n-      add_to_app_classpath_entries(path, new_entry, check_for_duplicates, CHECK_false);\n+      add_to_app_classpath_entries(current, path, new_entry, check_for_duplicates);\n@@ -1119,1 +1096,2 @@\n-ClassFileStream* ClassLoader::search_module_entries(const GrowableArray<ModuleClassPathList*>* const module_list,\n+ClassFileStream* ClassLoader::search_module_entries(Thread* current,\n+                                                    const GrowableArray<ModuleClassPathList*>* const module_list,\n@@ -1121,2 +1099,1 @@\n-                                                    const char* const file_name,\n-                                                    TRAPS) {\n+                                                    const char* const file_name) {\n@@ -1149,1 +1126,1 @@\n-      MutexLocker ml(THREAD, Module_lock);\n+      MutexLocker ml(current, Module_lock);\n@@ -1158,1 +1135,1 @@\n-    stream = e->open_stream(THREAD, file_name);\n+    stream = e->open_stream(current, file_name);\n@@ -1221,1 +1198,1 @@\n-      stream = search_module_entries(_patch_mod_entries, class_name, file_name, CHECK_NULL);\n+      stream = search_module_entries(THREAD, _patch_mod_entries, class_name, file_name);\n@@ -1233,1 +1210,1 @@\n-      stream = search_module_entries(_exploded_entries, class_name, file_name, CHECK_NULL);\n+      stream = search_module_entries(THREAD, _exploded_entries, class_name, file_name);\n@@ -1444,1 +1421,1 @@\n-  setup_bootstrap_search_path(CHECK);\n+  setup_bootstrap_search_path(THREAD);\n@@ -1481,1 +1458,1 @@\n-void ClassLoader::initialize_shared_path(TRAPS) {\n+void ClassLoader::initialize_shared_path(Thread* current) {\n@@ -1483,1 +1460,1 @@\n-    ClassLoaderExt::setup_search_paths(CHECK);\n+    ClassLoaderExt::setup_search_paths(current);\n@@ -1489,1 +1466,1 @@\n-    ClassLoaderExt::setup_module_paths(CHECK);\n+    ClassLoaderExt::setup_module_paths(THREAD);\n@@ -1554,1 +1531,1 @@\n-void ClassLoader::classLoader_init2(TRAPS) {\n+void ClassLoader::classLoader_init2(Thread* current) {\n@@ -1579,1 +1556,1 @@\n-    add_to_exploded_build_list(vmSymbols::java_base(), CHECK);\n+    add_to_exploded_build_list(current, vmSymbols::java_base());\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":47,"deletions":70,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -225,3 +225,4 @@\n-  CDS_ONLY(static void setup_app_search_path(const char* class_path, TRAPS);)\n-  CDS_ONLY(static void setup_module_search_path(const char* path, TRAPS);)\n-  static void add_to_app_classpath_entries(const char* path,\n+  CDS_ONLY(static void setup_app_search_path(Thread* current, const char* class_path);)\n+  CDS_ONLY(static void setup_module_search_path(Thread* current, const char* path);)\n+  static void add_to_app_classpath_entries(Thread* current,\n+                                           const char* path,\n@@ -229,2 +230,1 @@\n-                                           bool check_for_duplicates,\n-                                           TRAPS);\n+                                           bool check_for_duplicates);\n@@ -244,2 +244,2 @@\n-  static void setup_bootstrap_search_path(TRAPS);\n-  static void setup_bootstrap_search_path_impl(const char *class_path, TRAPS);\n+  static void setup_bootstrap_search_path(Thread* current);\n+  static void setup_bootstrap_search_path_impl(Thread* current, const char *class_path);\n@@ -261,2 +261,2 @@\n-  static ClassPathEntry* create_class_path_entry(const char *path, const struct stat* st,\n-                                                 bool throw_exception,\n+  static ClassPathEntry* create_class_path_entry(Thread* current,\n+                                                 const char *path, const struct stat* st,\n@@ -264,1 +264,1 @@\n-                                                 bool from_class_path_attr, TRAPS);\n+                                                 bool from_class_path_attr);\n@@ -273,1 +273,2 @@\n-  static bool update_class_path_entry_list(const char *path,\n+  static bool update_class_path_entry_list(Thread* current,\n+                                           const char *path,\n@@ -276,2 +277,1 @@\n-                                           bool from_class_path_attr,\n-                                           TRAPS);\n+                                           bool from_class_path_attr);\n@@ -314,1 +314,1 @@\n-  static void add_to_exploded_build_list(Symbol* module_name, TRAPS);\n+  static void add_to_exploded_build_list(Thread* current, Symbol* module_name);\n@@ -317,1 +317,2 @@\n-  static ClassFileStream* search_module_entries(const GrowableArray<ModuleClassPathList*>* const module_list,\n+  static ClassFileStream* search_module_entries(Thread* current,\n+                                                const GrowableArray<ModuleClassPathList*>* const module_list,\n@@ -319,1 +320,1 @@\n-                                                const char* const file_name, TRAPS);\n+                                                const char* const file_name);\n@@ -340,2 +341,2 @@\n-  static void classLoader_init2(TRAPS);\n-  CDS_ONLY(static void initialize_shared_path(TRAPS);)\n+  static void classLoader_init2(Thread* current);\n+  CDS_ONLY(static void initialize_shared_path(Thread* current);)\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-void ClassLoaderExt::setup_app_search_path(TRAPS) {\n+void ClassLoaderExt::setup_app_search_path(Thread* current) {\n@@ -80,1 +80,1 @@\n-    ClassLoader::setup_app_search_path(app_class_path, CHECK);\n+    ClassLoader::setup_app_search_path(current, app_class_path);\n@@ -84,2 +84,2 @@\n-void ClassLoaderExt::process_module_table(ModuleEntryTable* met, TRAPS) {\n-  ResourceMark rm(THREAD);\n+void ClassLoaderExt::process_module_table(Thread* current, ModuleEntryTable* met) {\n+  ResourceMark rm(current);\n@@ -91,1 +91,1 @@\n-        ClassLoader::setup_module_search_path(path, CHECK);\n+        ClassLoader::setup_module_search_path(current, path);\n@@ -97,1 +97,1 @@\n-void ClassLoaderExt::setup_module_paths(TRAPS) {\n+void ClassLoaderExt::setup_module_paths(Thread* current) {\n@@ -101,1 +101,1 @@\n-  Handle system_class_loader (THREAD, SystemDictionary::java_system_loader());\n+  Handle system_class_loader (current, SystemDictionary::java_system_loader());\n@@ -103,1 +103,1 @@\n-  process_module_table(met, CHECK);\n+  process_module_table(current, met);\n@@ -166,3 +166,3 @@\n-void ClassLoaderExt::process_jar_manifest(ClassPathEntry* entry,\n-                                          bool check_for_duplicates, TRAPS) {\n-  ResourceMark rm(THREAD);\n+void ClassLoaderExt::process_jar_manifest(Thread* current, ClassPathEntry* entry,\n+                                          bool check_for_duplicates) {\n+  ResourceMark rm(current);\n@@ -170,1 +170,1 @@\n-  char* manifest = read_manifest(THREAD, entry, &manifest_size);\n+  char* manifest = read_manifest(current, entry, &manifest_size);\n@@ -210,1 +210,1 @@\n-        ResourceMark rm(THREAD);\n+        ResourceMark rm(current);\n@@ -215,2 +215,1 @@\n-        bool status = ClassLoader::update_class_path_entry_list(libname, true, false, true \/* from_class_path_attr *\/, CHECK);\n-        if (status) {\n+        if (ClassLoader::update_class_path_entry_list(current, libname, true, false, true \/* from_class_path_attr *\/)) {\n@@ -229,2 +228,2 @@\n-void ClassLoaderExt::setup_search_paths(TRAPS) {\n-  ClassLoaderExt::setup_app_search_path(CHECK);\n+void ClassLoaderExt::setup_search_paths(Thread* current) {\n+  ClassLoaderExt::setup_app_search_path(current);\n@@ -330,4 +329,1 @@\n-  ExceptionMark em(current);\n-  Thread* THREAD = current; \/\/ For exception macros.\n-  new_entry = create_class_path_entry(path, &st, \/*throw_exception=*\/false,\n-                                      false, false, CATCH); \/\/ will never throw\n+  new_entry = create_class_path_entry(current, path, &st, false, false);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-  static void setup_app_search_path(TRAPS); \/\/ Only when -Xshare:dump\n-  static void process_module_table(ModuleEntryTable* met, TRAPS);\n+  static void setup_app_search_path(Thread* current); \/\/ Only when -Xshare:dump\n+  static void process_module_table(Thread* current, ModuleEntryTable* met);\n@@ -64,1 +64,1 @@\n-  static void process_jar_manifest(ClassPathEntry* entry, bool check_for_duplicates, TRAPS);\n+  static void process_jar_manifest(Thread* current, ClassPathEntry* entry, bool check_for_duplicates);\n@@ -69,2 +69,2 @@\n-  static void setup_search_paths(TRAPS);\n-  static void setup_module_paths(TRAPS);\n+  static void setup_search_paths(Thread* current);\n+  static void setup_module_paths(Thread* current);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -345,3 +345,3 @@\n-  Symbol* generate_no_defaults_message(TRAPS) const;\n-  Symbol* generate_method_message(Symbol *klass_name, Method* method, TRAPS) const;\n-  Symbol* generate_conflicts_message(GrowableArray<MethodState>* methods, TRAPS) const;\n+  Symbol* generate_no_defaults_message() const;\n+  Symbol* generate_method_message(Symbol *klass_name, Method* method) const;\n+  Symbol* generate_conflicts_message(GrowableArray<MethodState>* methods) const;\n@@ -380,1 +380,1 @@\n-  void determine_target_or_set_exception_message(InstanceKlass* root, TRAPS) {\n+  void determine_target_or_set_exception_message(InstanceKlass* root) {\n@@ -403,1 +403,1 @@\n-      generate_and_set_exception_message(root, num_defaults, default_index, CHECK);\n+      generate_and_set_exception_message(root, num_defaults, default_index);\n@@ -407,1 +407,1 @@\n-  void generate_and_set_exception_message(InstanceKlass* root, int num_defaults, int default_index, TRAPS) {\n+  void generate_and_set_exception_message(InstanceKlass* root, int num_defaults, int default_index) {\n@@ -422,1 +422,1 @@\n-        _exception_message = generate_no_defaults_message(CHECK);\n+        _exception_message = generate_no_defaults_message();\n@@ -425,1 +425,1 @@\n-        _exception_message = generate_method_message(root->name(), qualified_methods.at(0), CHECK);\n+        _exception_message = generate_method_message(root->name(), qualified_methods.at(0));\n@@ -429,1 +429,1 @@\n-      _exception_message = generate_conflicts_message(&_members,CHECK);\n+      _exception_message = generate_conflicts_message(&_members);\n@@ -460,1 +460,1 @@\n-Symbol* MethodFamily::generate_no_defaults_message(TRAPS) const {\n+Symbol* MethodFamily::generate_no_defaults_message() const {\n@@ -464,1 +464,1 @@\n-Symbol* MethodFamily::generate_method_message(Symbol *klass_name, Method* method, TRAPS) const {\n+Symbol* MethodFamily::generate_method_message(Symbol *klass_name, Method* method) const {\n@@ -477,1 +477,1 @@\n-Symbol* MethodFamily::generate_conflicts_message(GrowableArray<MethodState>* methods, TRAPS) const {\n+Symbol* MethodFamily::generate_conflicts_message(GrowableArray<MethodState>* methods) const {\n@@ -628,1 +628,1 @@\n-    InstanceKlass* klass, const GrowableArray<Method*>* mirandas, TRAPS) {\n+    InstanceKlass* klass, const GrowableArray<Method*>* mirandas) {\n@@ -784,1 +784,1 @@\n-    InstanceKlass* klass, EmptyVtableSlot* slot, bool is_intf, TRAPS) {\n+    InstanceKlass* klass, EmptyVtableSlot* slot, bool is_intf) {\n@@ -796,1 +796,1 @@\n-    family->determine_target_or_set_exception_message(klass, CHECK);\n+    family->determine_target_or_set_exception_message(klass);\n@@ -838,1 +838,1 @@\n-    ResourceMark rm;\n+    ResourceMark rm(THREAD);\n@@ -848,1 +848,1 @@\n-  find_empty_vtable_slots(&empty_slots, klass, mirandas, CHECK);\n+  find_empty_vtable_slots(&empty_slots, klass, mirandas);\n@@ -862,1 +862,1 @@\n-      generate_erased_defaults(&findMethodsByErasedSig, klass, slot, klass->is_interface(), CHECK);\n+      generate_erased_defaults(&findMethodsByErasedSig, klass, slot, klass->is_interface());\n@@ -871,1 +871,1 @@\n-    BytecodeConstantPool* cp, BytecodeBuffer* buffer, Symbol* errorName, Symbol* message, TRAPS) {\n+    BytecodeConstantPool* cp, BytecodeBuffer* buffer, Symbol* errorName, Symbol* message) {\n@@ -995,1 +995,1 @@\n-           method->get_exception_name(), method->get_exception_message(), CHECK);\n+           method->get_exception_name(), method->get_exception_message());\n@@ -1035,0 +1035,4 @@\n+  \/\/ Create an array for mapping default methods to their vtable indices in\n+  \/\/ this class, since default methods vtable indices are the indices for\n+  \/\/ the defining class.\n+  klass->create_new_default_vtable_indices(new_size, CHECK);\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-  \/\/                                           bool is_method, TRAPS)\n+  \/\/                                           bool is_method)\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-static PackageEntry* get_locked_package_entry(ModuleEntry* module_entry, const char* package_name, int len, TRAPS) {\n+static PackageEntry* get_locked_package_entry(ModuleEntry* module_entry, const char* package_name, int len) {\n@@ -123,3 +123,1 @@\n-static PackageEntry* get_package_entry_by_name(Symbol* package,\n-                                               Handle h_loader,\n-                                               TRAPS) {\n+static PackageEntry* get_package_entry_by_name(Symbol* package, Handle h_loader) {\n@@ -135,2 +133,2 @@\n-bool Modules::is_package_defined(Symbol* package, Handle h_loader, TRAPS) {\n-  PackageEntry* res = get_package_entry_by_name(package, h_loader, CHECK_false);\n+bool Modules::is_package_defined(Symbol* package, Handle h_loader) {\n+  PackageEntry* res = get_package_entry_by_name(package, h_loader);\n@@ -454,1 +452,1 @@\n-    ClassLoader::add_to_exploded_build_list(module_symbol, CHECK);\n+    ClassLoader::add_to_exploded_build_list(THREAD, module_symbol);\n@@ -589,1 +587,1 @@\n-    package_entry = get_locked_package_entry(from_module_entry, pkg, package_len, CHECK);\n+    package_entry = get_locked_package_entry(from_module_entry, pkg, package_len);\n@@ -711,1 +709,1 @@\n-jobject Modules::get_named_module(Handle h_loader, const char* package_name, TRAPS) {\n+oop Modules::get_named_module(Handle h_loader, const char* package_name) {\n@@ -723,1 +721,1 @@\n-    get_package_entry_by_name(package_sym, h_loader, THREAD);\n+    get_package_entry_by_name(package_sym, h_loader);\n@@ -727,1 +725,1 @@\n-    return JNIHandles::make_local(THREAD, module_entry->module());\n+    return module_entry->module();\n@@ -760,1 +758,1 @@\n-    package_entry = get_locked_package_entry(module_entry, pkg, pkg_len, CHECK);\n+    package_entry = get_locked_package_entry(module_entry, pkg, pkg_len);\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -104,1 +104,2 @@\n-  \/\/ Returns NULL if the class loader has not loaded any classes in the package.\n+  \/\/ Returns NULL if the package name is empty, if the resulting package\n+  \/\/ entry is NULL, if the module is not found or is unnamed.\n@@ -106,4 +107,1 @@\n-  \/\/ NullPointerException is thrown if package is null.\n-  \/\/ IllegalArgumentException is thrown if loader is neither null nor a subtype of\n-  \/\/ java\/lang\/ClassLoader.\n-  static jobject get_named_module(Handle h_loader, const char* package, TRAPS);\n+  static oop get_named_module(Handle h_loader, const char* package);\n@@ -118,1 +116,1 @@\n-  static bool is_package_defined(Symbol* package_name, Handle h_loader, TRAPS);\n+  static bool is_package_defined(Symbol* package_name, Handle h_loader);\n","filename":"src\/hotspot\/share\/classfile\/modules.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-    const methodHandle& m, VerificationType thisKlass, TRAPS) {\n+    const methodHandle& m, VerificationType thisKlass) {\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,1 +156,1 @@\n-    const methodHandle& m, VerificationType thisKlass, TRAPS);\n+    const methodHandle& m, VerificationType thisKlass);\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,0 +278,7 @@\n+\/\/ Call function for all symbols in shared table. Used by -XX:+PrintSharedArchiveAndExit\n+void SymbolTable::shared_symbols_do(SymbolClosure *cl) {\n+  SharedSymbolIterator iter(cl);\n+  _shared_table.iterate(&iter);\n+  _dynamic_shared_table.iterate(&iter);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,1 @@\n+  static void shared_symbols_do(SymbolClosure *cl);  \/\/ no safepoint iteration.\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -325,0 +325,10 @@\n+static inline void log_circularity_error(Thread* thread, PlaceholderEntry* probe) {\n+  LogTarget(Debug, class, load, placeholders) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm(thread);\n+    LogStream ls(lt);\n+    ls.print(\"ClassCircularityError detected for placeholder \");\n+    probe->print_entry(&ls);\n+    ls.cr();\n+  }\n+}\n@@ -326,1 +336,1 @@\n-\/\/ Must be called for any super-class or super-interface resolution\n+\/\/ Must be called for any superclass or superinterface resolution\n@@ -328,4 +338,4 @@\n-\/\/ super-interface callers:\n-\/\/    parse_interfaces - for defineClass\n-\/\/ super-class callers:\n-\/\/   ClassFileParser - for defineClass\n+\/\/ superinterface callers:\n+\/\/    parse_interfaces - from defineClass\n+\/\/ superclass callers:\n+\/\/   ClassFileParser - from defineClass\n@@ -337,25 +347,9 @@\n-\/\/      if another thread is trying to resolve the class, it must do\n-\/\/      super-class checks on its own thread to catch class circularity\n-\/\/ This last call is critical in class circularity checking for cases\n-\/\/ where classloading is delegated to different threads and the\n-\/\/ classloader lock is released.\n-\/\/ Take the case: Base->Super->Base\n-\/\/   1. If thread T1 tries to do a defineClass of class Base\n-\/\/    resolve_super_or_fail creates placeholder: T1, Base (super Super)\n-\/\/   2. resolve_instance_class_or_null does not find SD or placeholder for Super\n-\/\/    so it tries to load Super\n-\/\/   3. If we load the class internally, or user classloader uses same thread\n-\/\/      loadClassFromxxx or defineClass via parseClassFile Super ...\n-\/\/      3.1 resolve_super_or_fail creates placeholder: T1, Super (super Base)\n-\/\/      3.3 resolve_instance_class_or_null Base, finds placeholder for Base\n-\/\/      3.4 calls resolve_super_or_fail Base\n-\/\/      3.5 finds T1,Base -> throws class circularity\n-\/\/OR 4. If T2 tries to resolve Super via defineClass Super ...\n-\/\/      4.1 resolve_super_or_fail creates placeholder: T2, Super (super Base)\n-\/\/      4.2 resolve_instance_class_or_null Base, finds placeholder for Base (super Super)\n-\/\/      4.3 calls resolve_super_or_fail Super in parallel on own thread T2\n-\/\/      4.4 finds T2, Super -> throws class circularity\n-\/\/ Be careful when modifying this code: once you have run\n-\/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_SUPER),\n-\/\/ you need to find_and_remove it before returning.\n-\/\/ So be careful to not exit with a CHECK_ macro between these calls.\n+\/\/      If another thread is trying to resolve the class, it must do\n+\/\/      superclass checks on its own thread to catch class circularity and\n+\/\/      to avoid deadlock.\n+\/\/\n+\/\/ resolve_super_or_fail adds a LOAD_SUPER placeholder to the placeholder table before calling\n+\/\/ resolve_instance_class_or_null. ClassCircularityError is detected when a LOAD_SUPER or LOAD_INSTANCE\n+\/\/ placeholder for the same thread, class, classloader is found.\n+\/\/ This can be seen with logging option: -Xlog:class+load+placeholders=debug.\n+\/\/\n@@ -368,1 +362,3 @@\n-  assert(!Signature::is_array(super_name), \"invalid super class name\");\n+\n+  assert(super_name != NULL, \"null superclass for resolving\");\n+  assert(!Signature::is_array(super_name), \"invalid superclass name\");\n@@ -380,14 +376,4 @@\n-  \/\/ Double-check, if klass is already loaded, just return super-class,interface\n-  \/\/ Don't add a placedholder if already loaded, i.e. already in appropriate class loader\n-  \/\/ dictionary.\n-  \/\/ Make sure there's a placeholder for the *klass* before resolving.\n-  \/\/ Used as a claim that this thread is currently loading superclass\/classloader\n-  \/\/ Used here for ClassCircularity checks and also for heap verification\n-  \/\/ (every InstanceKlass needs to be in its class loader dictionary or have a placeholder).\n-  \/\/ Must check ClassCircularity before checking if super class is already loaded.\n-  \/\/\n-  \/\/ We might not already have a placeholder if this class_name was\n-  \/\/ first seen via resolve_from_stream (jni_DefineClass or JVM_DefineClass);\n-  \/\/ the name of the class might not be known until the stream is actually\n-  \/\/ parsed.\n-  \/\/ Bugs 4643874, 4715493\n+  \/\/ If klass is already loaded, just return the superclass or superinterface.\n+  \/\/ Make sure there's a placeholder for the class_name before resolving.\n+  \/\/ This is used as a claim that this thread is currently loading superclass\/classloader\n+  \/\/ and for ClassCircularity checks.\n@@ -399,0 +385,1 @@\n+\n@@ -414,0 +401,1 @@\n+      \/\/ Must check ClassCircularity before checking if superclass is already loaded.\n@@ -416,0 +404,1 @@\n+          log_circularity_error(THREAD, probe);\n@@ -419,0 +408,1 @@\n+\n@@ -421,1 +411,5 @@\n-      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash, class_name, loader_data, PlaceholderTable::LOAD_SUPER, super_name, THREAD);\n+      PlaceholderEntry* newprobe = placeholders()->find_and_add(name_hash,\n+                                                                class_name,\n+                                                                loader_data,\n+                                                                PlaceholderTable::LOAD_SUPER,\n+                                                                super_name, THREAD);\n@@ -424,0 +418,1 @@\n+\n@@ -429,3 +424,1 @@\n-  \/\/ java.lang.Object should have been found above\n-  assert(super_name != NULL, \"null super class for resolving\");\n-  \/\/ Resolve the super class or interface, check results on return\n+  \/\/ Resolve the superclass or superinterface, check results on return\n@@ -438,6 +431,1 @@\n-  \/\/ Clean up of placeholders moved so that each classloadAction registrar self-cleans up\n-  \/\/ It is no longer necessary to keep the placeholder table alive until update_dictionary\n-  \/\/ or error. GC used to walk the placeholder table as strong roots.\n-  \/\/ The instanceKlass is kept alive because the class loader is on the stack,\n-  \/\/ which keeps the loader_data alive, as well as all instanceKlasses in\n-  \/\/ the loader_data. parseClassFile adds the instanceKlass to loader_data.\n+  \/\/ Clean up placeholder entry.\n@@ -482,1 +470,1 @@\n-void SystemDictionary::double_lock_wait(JavaThread* thread, Handle lockObject) {\n+static void double_lock_wait(JavaThread* thread, Handle lockObject) {\n@@ -499,1 +487,1 @@\n-\/\/ If the class in is in the placeholder table, class loading is in progress\n+\/\/ If the class in is in the placeholder table, class loading is in progress.\n@@ -502,14 +490,7 @@\n-\/\/ the superclass on the same thread internally, so we do parallel\n-\/\/ super class loading here.\n-\/\/ This also is critical in cases where the original thread gets stalled\n-\/\/ even in non-circularity situations.\n-\/\/ Returns non-null Klass* if other thread has completed load\n-\/\/ and we are done.  If this returns a null Klass* and no pending exception,\n-\/\/ the caller must load the class.\n-InstanceKlass* SystemDictionary::handle_parallel_super_load(\n-    Symbol* name, Symbol* superclassname, Handle class_loader,\n-    Handle protection_domain, Handle lockObject, TRAPS) {\n-\n-  ClassLoaderData* loader_data = class_loader_data(class_loader);\n-  Dictionary* dictionary = loader_data->dictionary();\n-  unsigned int name_hash = dictionary->compute_hash(name);\n+\/\/ the superclass on the new thread internally, so we do parallel\n+\/\/ superclass loading here.  This avoids deadlock for ClassCircularity\n+\/\/ detection for parallelCapable class loaders that lock on a per-class lock.\n+static void handle_parallel_super_load(Symbol* name,\n+                                       Symbol* superclassname,\n+                                       Handle class_loader,\n+                                       Handle protection_domain, TRAPS) {\n@@ -523,1 +504,2 @@\n-                                                          CHECK_NULL);\n+                                                          CHECK);\n+}\n@@ -525,6 +507,5 @@\n-  \/\/ parallelCapable class loaders do NOT wait for parallel superclass loads to complete\n-  \/\/ Serial class loaders and bootstrap classloader do wait for superclass loads\n- if (!class_loader.is_null() && is_parallelCapable(class_loader)) {\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    return dictionary->find_class(name_hash, name);\n-  }\n+\/\/ parallelCapable class loaders do NOT wait for parallel superclass loads to complete\n+\/\/ Serial class loaders and bootstrap classloader do wait for superclass loads\n+static bool should_wait_for_loading(Handle class_loader) {\n+  return class_loader.is_null() || !is_parallelCapable(class_loader);\n+}\n@@ -532,11 +513,16 @@\n-  \/\/ must loop to both handle other placeholder updates\n-  \/\/ and spurious notifications\n-  bool super_load_in_progress = true;\n-  PlaceholderEntry* placeholder;\n-  while (super_load_in_progress) {\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n-    \/\/ Check if classloading completed while we were loading superclass or waiting\n-    InstanceKlass* check = dictionary->find_class(name_hash, name);\n-    if (check != NULL) {\n-      \/\/ Klass is already loaded, so just return it\n-      return check;\n+\/\/ For bootstrap and non-parallelCapable class loaders, check and wait for\n+\/\/ another thread to complete loading this class.\n+InstanceKlass* SystemDictionary::handle_parallel_loading(JavaThread* current,\n+                                                         unsigned int name_hash,\n+                                                         Symbol* name,\n+                                                         ClassLoaderData* loader_data,\n+                                                         Handle lockObject,\n+                                                         bool* throw_circularity_error) {\n+  PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n+  if (oldprobe != NULL) {\n+    \/\/ only need check_seen_thread once, not on each loop\n+    \/\/ 6341374 java\/lang\/Instrument with -Xcomp\n+    if (oldprobe->check_seen_thread(current, PlaceholderTable::LOAD_INSTANCE)) {\n+      log_circularity_error(current, oldprobe);\n+      *throw_circularity_error = true;\n+      return NULL;\n@@ -544,2 +530,5 @@\n-      placeholder = placeholders()->get_entry(name_hash, name, loader_data);\n-      if (placeholder != NULL && placeholder->super_load_in_progress()) {\n+      \/\/ Wait until the first thread has finished loading this class. Also wait until all the\n+      \/\/ threads trying to load its superclass have removed their placeholders.\n+      while (oldprobe != NULL &&\n+             (oldprobe->instance_load_in_progress() || oldprobe->super_load_in_progress())) {\n+\n@@ -558,2 +547,3 @@\n-        \/\/ We also get here for parallel bootstrap classloader\n-        if (class_loader.is_null()) {\n+        oldprobe = NULL;  \/\/ Other thread could delete this placeholder entry\n+\n+        if (lockObject.is_null()) {\n@@ -562,1 +552,1 @@\n-          double_lock_wait(THREAD->as_Java_thread(), lockObject);\n+          double_lock_wait(current, lockObject);\n@@ -564,4 +554,9 @@\n-      } else {\n-        \/\/ If not in SD and not in PH, the other thread is done loading the super class\n-        \/\/ but not done loading this class. We'll give up the lock and wait for that below.\n-        super_load_in_progress = false;\n+\n+        \/\/ Check if classloading completed while we were waiting\n+        InstanceKlass* check = loader_data->dictionary()->find_class(name_hash, name);\n+        if (check != NULL) {\n+          \/\/ Klass is already loaded, so just return it\n+          return check;\n+        }\n+        \/\/ check if other thread failed to load and cleaned up\n+        oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n@@ -584,7 +579,5 @@\n-\n-\/\/ Be careful when modifying this code: once you have run\n-\/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_INSTANCE),\n-\/\/ you need to find_and_remove it before returning.\n-\/\/ So be careful to not exit with a CHECK_ macro betweeen these calls.\n-\/\/\n-\/\/ name must be in the form of \"java\/lang\/Object\" -- cannot be \"Ljava\/lang\/Object;\"\n+\/\/ SystemDictionary::resolve_instance_class_or_null is the main function for class name resolution.\n+\/\/ After checking if the InstanceKlass already exists, it checks for ClassCircularityError and\n+\/\/ whether the thread must wait for loading in parallel.  It eventually calls load_instance_class,\n+\/\/ which will load the class via the bootstrap loader or call ClassLoader.loadClass().\n+\/\/ This can return NULL, an exception or an InstanceKlass.\n@@ -595,0 +588,1 @@\n+  \/\/ name must be in the form of \"java\/lang\/Object\" -- cannot be \"Ljava\/lang\/Object;\"\n@@ -608,2 +602,2 @@\n-  \/\/ Do lookup to see if class already exist and the protection domain\n-  \/\/ has the right access\n+  \/\/ Do lookup to see if class already exists and the protection domain\n+  \/\/ has the right access.\n@@ -611,7 +605,4 @@\n-  \/\/ All subsequent calls use find_class, and set has_loaded_class so that\n-  \/\/ before we return a result we call out to java to check for valid protection domain\n-  \/\/ to allow returning the Klass* and add it to the pd_set if it is valid\n-  {\n-    InstanceKlass* probe = dictionary->find(name_hash, name, protection_domain);\n-    if (probe != NULL) return probe;\n-  }\n+  \/\/ All subsequent calls use find_class, and set loaded_class so that\n+  \/\/ before we return a result, we call out to java to check for valid protection domain.\n+  InstanceKlass* probe = dictionary->find(name_hash, name, protection_domain);\n+  if (probe != NULL) return probe;\n@@ -626,1 +617,1 @@\n-  \/\/ ParallelCapable Classloaders and the bootstrap classloader\n+  \/\/ ParallelCapable class loaders and the bootstrap classloader\n@@ -631,2 +622,0 @@\n-  \/\/ Check again (after locking) if the class already exists in SystemDictionary\n-  bool class_has_been_loaded   = false;\n@@ -644,0 +633,1 @@\n+  \/\/ Check again (after locking) if the class already exists in SystemDictionary\n@@ -648,2 +638,1 @@\n-      \/\/ InstanceKlass is already loaded, so just return it\n-      class_has_been_loaded = true;\n+      \/\/ InstanceKlass is already loaded, but we still need to check protection domain below.\n@@ -661,1 +650,2 @@\n-  \/\/ If the class is in the placeholder table, class loading is in progress\n+  \/\/ If the class is in the placeholder table with super_class set,\n+  \/\/ handle superclass loading in progress.\n@@ -663,8 +653,4 @@\n-    loaded_class = handle_parallel_super_load(name,\n-                                              superclassname,\n-                                              class_loader,\n-                                              protection_domain,\n-                                              lockObject, CHECK_NULL);\n-    if (loaded_class != NULL) {\n-      class_has_been_loaded = true;\n-    }\n+    handle_parallel_super_load(name, superclassname,\n+                               class_loader,\n+                               protection_domain,\n+                               CHECK_NULL);\n@@ -674,2 +660,2 @@\n-  if (!class_has_been_loaded) {\n-    bool load_instance_added = false;\n+  if (loaded_class == NULL) {\n+    bool load_placeholder_added = false;\n@@ -678,1 +664,1 @@\n-    \/\/ Three cases:\n+    \/\/ Four cases:\n@@ -694,1 +680,1 @@\n-    if (class_loader.is_null() || !is_parallelCapable(class_loader)) {\n+    {\n@@ -696,30 +682,7 @@\n-      PlaceholderEntry* oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n-      if (oldprobe != NULL) {\n-        \/\/ only need check_seen_thread once, not on each loop\n-        \/\/ 6341374 java\/lang\/Instrument with -Xcomp\n-        if (oldprobe->check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) {\n-          throw_circularity_error = true;\n-        } else {\n-          \/\/ case 3: traditional: should never see load_in_progress.\n-          while (!class_has_been_loaded && oldprobe != NULL && oldprobe->instance_load_in_progress()) {\n-\n-            \/\/ case 1: bootstrap classloader: prevent futile classloading,\n-            \/\/ wait on first requestor\n-            if (class_loader.is_null()) {\n-              SystemDictionary_lock->wait();\n-            } else {\n-              \/\/ case 4: traditional with broken classloader lock. wait on first\n-              \/\/ requestor.\n-              double_lock_wait(THREAD->as_Java_thread(), lockObject);\n-            }\n-            \/\/ Check if classloading completed while we were waiting\n-            InstanceKlass* check = dictionary->find_class(name_hash, name);\n-            if (check != NULL) {\n-              \/\/ Klass is already loaded, so just return it\n-              loaded_class = check;\n-              class_has_been_loaded = true;\n-            }\n-            \/\/ check if other thread failed to load and cleaned up\n-            oldprobe = placeholders()->get_entry(name_hash, name, loader_data);\n-          }\n-        }\n+      if (should_wait_for_loading(class_loader)) {\n+        loaded_class = handle_parallel_loading(THREAD->as_Java_thread(),\n+                                               name_hash,\n+                                               name,\n+                                               loader_data,\n+                                               lockObject,\n+                                               &throw_circularity_error);\n@@ -728,5 +691,3 @@\n-      \/\/ Add LOAD_INSTANCE while holding the SystemDictionary_lock\n-      if (!throw_circularity_error && !class_has_been_loaded) {\n-        \/\/ For the bootclass loader, if the thread did not catch another thread holding\n-        \/\/ the LOAD_INSTANCE token, we need to check whether it completed loading\n-        \/\/ while holding the SD_lock.\n+      \/\/ Recheck if the class has been loaded for all class loader cases and\n+      \/\/ add a LOAD_INSTANCE placeholder while holding the SystemDictionary_lock.\n+      if (!throw_circularity_error && loaded_class == NULL) {\n@@ -735,1 +696,0 @@\n-          \/\/ Klass is already loaded, so return it after checking\/adding protection domain\n@@ -737,3 +697,2 @@\n-          class_has_been_loaded = true;\n-        } else {\n-          \/\/ Now we've got the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n+        } else if (should_wait_for_loading(class_loader)) {\n+          \/\/ Add the LOAD_INSTANCE token. Threads will wait on loading to complete for this thread.\n@@ -744,1 +703,1 @@\n-          load_instance_added = true;\n+          load_placeholder_added = true;\n@@ -749,1 +708,1 @@\n-    \/\/ must throw error outside of owning lock\n+    \/\/ Must throw error outside of owning lock\n@@ -751,1 +710,1 @@\n-      assert(!HAS_PENDING_EXCEPTION && !load_instance_added, \"circularity error cleanup\");\n+      assert(!HAS_PENDING_EXCEPTION && !load_placeholder_added, \"circularity error cleanup\");\n@@ -756,1 +715,4 @@\n-    if (!class_has_been_loaded) {\n+    \/\/ Be careful when modifying this code: once you have run\n+    \/\/ placeholders()->find_and_add(PlaceholderTable::LOAD_INSTANCE),\n+    \/\/ you need to find_and_remove it before returning.\n+    \/\/ So be careful to not exit with a CHECK_ macro between these calls.\n@@ -758,0 +720,1 @@\n+    if (loaded_class == NULL) {\n@@ -759,31 +722,2 @@\n-      loaded_class = load_instance_class(name, class_loader, THREAD);\n-\n-      \/\/ If everything was OK (no exceptions, no null return value), and\n-      \/\/ class_loader is NOT the defining loader, do a little more bookkeeping.\n-      if (!HAS_PENDING_EXCEPTION && loaded_class != NULL &&\n-        loaded_class->class_loader() != class_loader()) {\n-\n-        check_constraints(name_hash, loaded_class, class_loader, false, THREAD);\n-\n-        \/\/ Need to check for a PENDING_EXCEPTION again; check_constraints\n-        \/\/ can throw but we may have to remove entry from the placeholder table below.\n-        if (!HAS_PENDING_EXCEPTION) {\n-          \/\/ Record dependency for non-parent delegation.\n-          \/\/ This recording keeps the defining class loader of the klass (loaded_class) found\n-          \/\/ from being unloaded while the initiating class loader is loaded\n-          \/\/ even if the reference to the defining class loader is dropped\n-          \/\/ before references to the initiating class loader.\n-          loader_data->record_dependency(loaded_class);\n-\n-          { \/\/ Grabbing the Compile_lock prevents systemDictionary updates\n-            \/\/ during compilations.\n-            MutexLocker mu(THREAD, Compile_lock);\n-            update_dictionary(name_hash, loaded_class, class_loader);\n-          }\n-\n-          if (JvmtiExport::should_post_class_load()) {\n-            JvmtiExport::post_class_load(THREAD->as_Java_thread(), loaded_class);\n-          }\n-        }\n-      }\n-    } \/\/ load_instance_class\n+      loaded_class = load_instance_class(name_hash, name, class_loader, THREAD);\n+    }\n@@ -791,1 +725,1 @@\n-    if (load_instance_added) {\n+    if (load_placeholder_added) {\n@@ -804,0 +738,1 @@\n+\n@@ -882,9 +817,9 @@\n-\/\/ Note: this method is much like resolve_from_stream, but\n-\/\/ does not publish the classes via the SystemDictionary.\n-\/\/ Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass\n-\/\/ and redefineclasses. RedefinedClasses do not add to the class hierarchy.\n-InstanceKlass* SystemDictionary::parse_stream(Symbol* class_name,\n-                                              Handle class_loader,\n-                                              ClassFileStream* st,\n-                                              const ClassLoadInfo& cl_info,\n-                                              TRAPS) {\n+\/\/ Note: this method is much like resolve_class_from_stream, but\n+\/\/ does not publish the classes in the SystemDictionary.\n+\/\/ Handles Lookup.defineClass hidden and unsafe_DefineAnonymousClass.\n+InstanceKlass* SystemDictionary::resolve_hidden_class_from_stream(\n+                                                     ClassFileStream* st,\n+                                                     Symbol* class_name,\n+                                                     Handle class_loader,\n+                                                     const ClassLoadInfo& cl_info,\n+                                                     TRAPS) {\n@@ -901,2 +836,2 @@\n-  if (is_unsafe_anon_class || cl_info.is_hidden()) {\n-    guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()->class_loader() == class_loader(),\n+  assert (is_unsafe_anon_class || cl_info.is_hidden(), \"only used for hidden classes\");\n+  guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()->class_loader() == class_loader(),\n@@ -904,5 +839,2 @@\n-    bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();\n-    loader_data = register_loader(class_loader, create_mirror_cld);\n-  } else {\n-    loader_data = ClassLoaderData::class_loader_data(class_loader());\n-  }\n+  bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();\n+  loader_data = register_loader(class_loader, create_mirror_cld);\n@@ -914,4 +846,0 @@\n-  \/\/ Note that we do this even though this klass might\n-  \/\/ already be present in the SystemDictionary, otherwise we would not\n-  \/\/ throw potential ClassFormatErrors.\n-\n@@ -925,7 +853,6 @@\n-  if (cl_info.is_hidden() || is_unsafe_anon_class) {\n-    \/\/ Hidden classes that are not strong and unsafe anonymous classes must update\n-    \/\/ ClassLoaderData holder so that they can be unloaded when the mirror is no\n-    \/\/ longer referenced.\n-    if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {\n-      k->class_loader_data()->initialize_holder(Handle(THREAD, k->java_mirror()));\n-    }\n+  \/\/ Hidden classes that are not strong and unsafe anonymous classes must update\n+  \/\/ ClassLoaderData holder so that they can be unloaded when the mirror is no\n+  \/\/ longer referenced.\n+  if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {\n+    k->class_loader_data()->initialize_holder(Handle(THREAD, k->java_mirror()));\n+  }\n@@ -933,6 +860,6 @@\n-    {\n-      MutexLocker mu_r(THREAD, Compile_lock);\n-      \/\/ Add to class hierarchy, and do possible deoptimizations.\n-      add_to_hierarchy(k);\n-      \/\/ But, do not add to dictionary.\n-    }\n+  {\n+    MutexLocker mu_r(THREAD, Compile_lock);\n+    \/\/ Add to class hierarchy, and do possible deoptimizations.\n+    add_to_hierarchy(k);\n+    \/\/ But, do not add to dictionary.\n+  }\n@@ -940,5 +867,5 @@\n-    \/\/ Rewrite and patch constant pool here.\n-    k->link_class(CHECK_NULL);\n-    if (cl_info.cp_patches() != NULL) {\n-      k->constants()->patch_resolved_references(cl_info.cp_patches());\n-    }\n+  \/\/ Rewrite and patch constant pool here.\n+  k->link_class(CHECK_NULL);\n+  if (cl_info.cp_patches() != NULL) {\n+    k->constants()->patch_resolved_references(cl_info.cp_patches());\n+  }\n@@ -946,4 +873,4 @@\n-    \/\/ If it's anonymous, initialize it now, since nobody else will.\n-    if (is_unsafe_anon_class) {\n-      k->eager_initialize(CHECK_NULL);\n-    }\n+  \/\/ If it's anonymous, initialize it now, since nobody else will.\n+  if (is_unsafe_anon_class) {\n+    k->eager_initialize(CHECK_NULL);\n+  }\n@@ -951,7 +878,6 @@\n-    \/\/ notify jvmti\n-    if (JvmtiExport::should_post_class_load()) {\n-      JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n-    }\n-    if (class_load_start_event.should_commit()) {\n-      post_class_load_event(&class_load_start_event, k, loader_data);\n-    }\n+  \/\/ notify jvmti\n+  if (JvmtiExport::should_post_class_load()) {\n+    JvmtiExport::post_class_load(THREAD->as_Java_thread(), k);\n+  }\n+  if (class_load_start_event.should_commit()) {\n+    post_class_load_event(&class_load_start_event, k, loader_data);\n@@ -959,0 +885,1 @@\n+\n@@ -971,3 +898,1 @@\n-InstanceKlass* SystemDictionary::resolve_from_stream(Symbol* class_name,\n-                                                     Handle class_loader,\n-                                                     Handle protection_domain,\n+InstanceKlass* SystemDictionary::resolve_class_from_stream(\n@@ -975,0 +900,3 @@\n+                                                     Symbol* class_name,\n+                                                     Handle class_loader,\n+                                                     const ClassLoadInfo& cl_info,\n@@ -996,1 +924,1 @@\n-                                                   protection_domain,\n+                                                   cl_info.protection_domain(),\n@@ -1003,1 +931,0 @@\n-    ClassLoadInfo cl_info(protection_domain);\n@@ -1034,0 +961,14 @@\n+InstanceKlass* SystemDictionary::resolve_from_stream(ClassFileStream* st,\n+                                                     Symbol* class_name,\n+                                                     Handle class_loader,\n+                                                     const ClassLoadInfo& cl_info,\n+                                                     TRAPS) {\n+  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;\n+  if (cl_info.is_hidden() || is_unsafe_anon_class) {\n+    return resolve_hidden_class_from_stream(st, class_name, class_loader, cl_info, CHECK_NULL);\n+  } else {\n+    return resolve_class_from_stream(st, class_name, class_loader, cl_info, CHECK_NULL);\n+  }\n+}\n+\n+\n@@ -1036,1 +977,1 @@\n-\/\/ forces the super class and all interfaces to be loaded.\n+\/\/ forces the superclass and all interfaces to be loaded.\n@@ -1052,1 +993,1 @@\n-                                               Handle class_loader, TRAPS) {\n+                                               Handle class_loader) {\n@@ -1084,1 +1025,1 @@\n-    assert(SystemDictionary::is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD),\n+    assert(SystemDictionary::is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader),\n@@ -1088,1 +1029,1 @@\n-  return is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD);\n+  return is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader);\n@@ -1094,1 +1035,1 @@\n-                                                    Handle class_loader, TRAPS) {\n+                                                    Handle class_loader) {\n@@ -1146,1 +1087,1 @@\n-    \/\/ Check if the super class is loaded by the current class_loader\n+    \/\/ Check if the superclass is loaded by the current class_loader\n@@ -1234,3 +1175,1 @@\n-  bool visible = is_shared_class_visible(\n-                          class_name, ik, pkg_entry, class_loader, CHECK_NULL);\n-  if (!visible) {\n+  if (!is_shared_class_visible(class_name, ik, pkg_entry, class_loader)) {\n@@ -1313,1 +1252,1 @@\n-InstanceKlass* SystemDictionary::load_instance_class(Symbol* class_name, Handle class_loader, TRAPS) {\n+InstanceKlass* SystemDictionary::load_instance_class_impl(Symbol* class_name, Handle class_loader, TRAPS) {\n@@ -1452,0 +1391,35 @@\n+InstanceKlass* SystemDictionary::load_instance_class(unsigned int name_hash,\n+                                                     Symbol* name,\n+                                                     Handle class_loader,\n+                                                     TRAPS) {\n+\n+  InstanceKlass* loaded_class = load_instance_class_impl(name, class_loader, CHECK_NULL);\n+\n+  \/\/ If everything was OK (no exceptions, no null return value), and\n+  \/\/ class_loader is NOT the defining loader, do a little more bookkeeping.\n+  if (loaded_class != NULL &&\n+    loaded_class->class_loader() != class_loader()) {\n+\n+    check_constraints(name_hash, loaded_class, class_loader, false, CHECK_NULL);\n+\n+    \/\/ Record dependency for non-parent delegation.\n+    \/\/ This recording keeps the defining class loader of the klass (loaded_class) found\n+    \/\/ from being unloaded while the initiating class loader is loaded\n+    \/\/ even if the reference to the defining class loader is dropped\n+    \/\/ before references to the initiating class loader.\n+    ClassLoaderData* loader_data = class_loader_data(class_loader);\n+    loader_data->record_dependency(loaded_class);\n+\n+    { \/\/ Grabbing the Compile_lock prevents systemDictionary updates\n+      \/\/ during compilations.\n+      MutexLocker mu(THREAD, Compile_lock);\n+      update_dictionary(name_hash, loaded_class, class_loader);\n+    }\n+\n+    if (JvmtiExport::should_post_class_load()) {\n+      JvmtiExport::post_class_load(THREAD->as_Java_thread(), loaded_class);\n+    }\n+  }\n+  return loaded_class;\n+}\n+\n@@ -1821,1 +1795,1 @@\n-                    Symbol* class_name, Handle class_loader, Thread* THREAD) {\n+                    Thread* current, Symbol* class_name, Handle class_loader) {\n@@ -1843,1 +1817,1 @@\n-      MutexLocker mu(THREAD, SystemDictionary_lock);\n+      MutexLocker mu(current, SystemDictionary_lock);\n@@ -1851,1 +1825,1 @@\n-    MutexLocker mu(THREAD, SystemDictionary_lock);\n+    MutexLocker mu(current, SystemDictionary_lock);\n@@ -1862,2 +1836,1 @@\n-                                             Handle class_loader2,\n-                                             Thread* THREAD) {\n+                                             Handle class_loader2) {\n@@ -1893,1 +1866,1 @@\n-    MutexLocker mu_s(THREAD, SystemDictionary_lock);\n+    MutexLocker mu_s(SystemDictionary_lock);\n@@ -1903,1 +1876,1 @@\n-                                     class_loader1, class_loader2, THREAD);\n+                                     class_loader1, class_loader2);\n@@ -2041,3 +2014,3 @@\n-                                               Klass* klass_being_linked,\n-                                               Handle loader1, Handle loader2,\n-                                               bool is_method, TRAPS)  {\n+                                                  Klass* klass_being_linked,\n+                                                  Handle loader1, Handle loader2,\n+                                                  bool is_method)  {\n@@ -2055,1 +2028,1 @@\n-      if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2, THREAD)) {\n+      if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2)) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":255,"deletions":282,"binary":false,"changes":537,"status":"modified"},{"patch":"@@ -49,3 +49,1 @@\n-\/\/ a side data structure, and is used to detect ClassCircularityErrors\n-\/\/ and to perform verification during GC.  A GC can occur in the midst\n-\/\/ of class loading, as we call out to Java, have to take locks, etc.\n+\/\/ a side data structure, and is used to detect ClassCircularityErrors.\n@@ -61,3 +59,2 @@\n-\/\/    - entries are only deleted at safepoints\n-\/\/    - readers cannot come to a safepoint while actively examining\n-\/\/         an entry  (an entry cannot be deleted from under a reader)\n+\/\/    - entries are only deleted when the class loader is not alive, when the\n+\/\/      entire dictionary is deleted.\n@@ -124,0 +121,16 @@\n+ private:\n+  \/\/ Parse the stream to create an unsafe anonymous or hidden class.\n+  \/\/ Used by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.\n+  static InstanceKlass* resolve_hidden_class_from_stream(ClassFileStream* st,\n+                                                         Symbol* class_name,\n+                                                         Handle class_loader,\n+                                                         const ClassLoadInfo& cl_info,\n+                                                         TRAPS);\n+\n+  \/\/ Resolve a class from stream (called by jni_DefineClass and JVM_DefineClass)\n+  \/\/ This class is added to the SystemDictionary.\n+  static InstanceKlass* resolve_class_from_stream(ClassFileStream* st,\n+                                                  Symbol* class_name,\n+                                                  Handle class_loader,\n+                                                  const ClassLoadInfo& cl_info,\n+                                                  TRAPS);\n@@ -125,11 +138,4 @@\n-  \/\/ Parse new stream. This won't update the dictionary or class\n-  \/\/ hierarchy, simply parse the stream. Used by JVMTI RedefineClasses\n-  \/\/ and by Unsafe_DefineAnonymousClass and jvm_lookup_define_class.\n-  static InstanceKlass* parse_stream(Symbol* class_name,\n-                                     Handle class_loader,\n-                                     ClassFileStream* st,\n-                                     const ClassLoadInfo& cl_info,\n-                                     TRAPS);\n-\n-  \/\/ Resolve from stream (called by jni_DefineClass and JVM_DefineClass)\n-  static InstanceKlass* resolve_from_stream(Symbol* class_name,\n+ public:\n+  \/\/ Resolve either a hidden or normal class from a stream of bytes, based on ClassLoadInfo\n+  static InstanceKlass* resolve_from_stream(ClassFileStream* st,\n+                                            Symbol* class_name,\n@@ -137,2 +143,1 @@\n-                                            Handle protection_domain,\n-                                            ClassFileStream* st,\n+                                            const ClassLoadInfo& cl_info,\n@@ -172,3 +177,3 @@\n-  static Klass* find_constrained_instance_or_array_klass(Symbol* class_name,\n-                                                           Handle class_loader,\n-                                                           Thread* THREAD);\n+  static Klass* find_constrained_instance_or_array_klass(Thread* current,\n+                                                         Symbol* class_name,\n+                                                         Handle class_loader);\n@@ -221,1 +226,1 @@\n-                                         Handle loader1, Handle loader2, bool is_method, TRAPS);\n+                                         Handle loader1, Handle loader2, bool is_method);\n@@ -335,10 +340,7 @@\n-  static InstanceKlass* handle_parallel_super_load(Symbol* class_name,\n-                                                   Symbol* supername,\n-                                                   Handle class_loader,\n-                                                   Handle protection_domain,\n-                                                   Handle lockObject, TRAPS);\n-  \/\/ Wait on SystemDictionary_lock; unlocks lockObject before\n-  \/\/ waiting; relocks lockObject with correct recursion count\n-  \/\/ after waiting, but before reentering SystemDictionary_lock\n-  \/\/ to preserve lock order semantics.\n-  static void double_lock_wait(JavaThread* thread, Handle lockObject);\n+  static InstanceKlass* handle_parallel_loading(JavaThread* current,\n+                                                unsigned int name_hash,\n+                                                Symbol* name,\n+                                                ClassLoaderData* loader_data,\n+                                                Handle lockObject,\n+                                                bool* throw_circularity_error);\n+\n@@ -349,1 +351,4 @@\n-  static InstanceKlass* load_instance_class(Symbol* class_name, Handle class_loader, TRAPS);\n+  static InstanceKlass* load_instance_class_impl(Symbol* class_name, Handle class_loader, TRAPS);\n+  static InstanceKlass* load_instance_class(unsigned int name_hash,\n+                                            Symbol* class_name,\n+                                            Handle class_loader, TRAPS);\n@@ -353,1 +358,1 @@\n-                                      Handle class_loader, TRAPS);\n+                                      Handle class_loader);\n@@ -357,1 +362,1 @@\n-                                           Handle class_loader, TRAPS);\n+                                           Handle class_loader);\n@@ -369,1 +374,1 @@\n-                                    Handle loader2, TRAPS);\n+                                    Handle loader2);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":42,"deletions":37,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -1826,1 +1826,1 @@\n-                                                    Handle loader1, Handle loader2, TRAPS) {\n+                                                    Handle loader1, Handle loader2) {\n@@ -1864,2 +1864,1 @@\n-  if (THREAD->is_VM_thread()) {\n-    assert(DynamicDumpSharedSpaces, \"must be\");\n+  if (DynamicDumpSharedSpaces && Thread::current()->is_VM_thread()) {\n@@ -1871,0 +1870,2 @@\n+  assert(!Thread::current()->is_VM_thread(), \"must be\");\n+\n@@ -1880,1 +1881,1 @@\n-bool SystemDictionaryShared::check_linking_constraints(InstanceKlass* klass, TRAPS) {\n+bool SystemDictionaryShared::check_linking_constraints(Thread* current, InstanceKlass* klass) {\n@@ -1891,1 +1892,1 @@\n-      HandleMark hm(THREAD);\n+      HandleMark hm(current);\n@@ -1895,2 +1896,2 @@\n-        Handle loader1(THREAD, get_class_loader_by(lc->_loader_type1));\n-        Handle loader2(THREAD, get_class_loader_by(lc->_loader_type2));\n+        Handle loader1(current, get_class_loader_by(lc->_loader_type1));\n+        Handle loader2(current, get_class_loader_by(lc->_loader_type2));\n@@ -1898,1 +1899,1 @@\n-          ResourceMark rm(THREAD);\n+          ResourceMark rm(current);\n@@ -1904,1 +1905,1 @@\n-        if (!SystemDictionary::add_loader_constraint(name, klass, loader1, loader2, THREAD)) {\n+        if (!SystemDictionary::add_loader_constraint(name, klass, loader1, loader2)) {\n@@ -1921,1 +1922,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -2226,0 +2227,18 @@\n+const char* class_loader_name_for_shared(Klass* k) {\n+  assert(k != nullptr, \"Sanity\");\n+  assert(k->is_shared(), \"Must be\");\n+  assert(k->is_instance_klass(), \"Must be\");\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  if (ik->is_shared_boot_class()) {\n+    return \"boot_loader\";\n+  } else if (ik->is_shared_platform_class()) {\n+    return \"platform_loader\";\n+  } else if (ik->is_shared_app_class()) {\n+    return \"app_loader\";\n+  } else if (ik->is_shared_unregistered_class()) {\n+    return \"unregistered_loader\";\n+  } else {\n+    return \"unknown loader\";\n+  }\n+}\n+\n@@ -2234,1 +2253,2 @@\n-    _st->print_cr(\"%4d:  %s\", (_index++), record->_klass->external_name());\n+    _st->print_cr(\"%4d: %s %s\", (_index++), record->_klass->external_name(),\n+        class_loader_name_for_shared(record->_klass));\n@@ -2236,0 +2256,1 @@\n+  int index() const { return _index; }\n@@ -2242,1 +2263,1 @@\n-  SharedLambdaDictionaryPrinter(outputStream* st) : _st(st), _index(0) {}\n+  SharedLambdaDictionaryPrinter(outputStream* st, int idx) : _st(st), _index(idx) {}\n@@ -2247,4 +2268,4 @@\n-      _st->print_cr(\"%4d:  %s\", (_index++), record->proxy_klass_head()->external_name());\n-      Klass* k = record->proxy_klass_head()->next_link();\n-      while (k != NULL) {\n-        _st->print_cr(\"%4d:  %s\", (_index++), k->external_name());\n+      Klass* k = record->proxy_klass_head();\n+      while (k != nullptr) {\n+        _st->print_cr(\"%4d: %s %s\", (++_index), k->external_name(),\n+                      class_loader_name_for_shared(k));\n@@ -2264,0 +2285,1 @@\n+  st->print_cr(\"%sShared Builtin Dictionary\", prefix);\n@@ -2265,0 +2287,1 @@\n+  st->print_cr(\"%sShared Unregistered Dictionary\", prefix);\n@@ -2268,1 +2291,1 @@\n-    SharedLambdaDictionaryPrinter ldp(st);\n+    SharedLambdaDictionaryPrinter ldp(st, p.index());\n@@ -2273,0 +2296,13 @@\n+void SystemDictionaryShared::print_shared_archive(outputStream* st, bool is_static) {\n+  if (UseSharedSpaces) {\n+    if (is_static) {\n+      print_on(\"\", &_builtin_dictionary, &_unregistered_dictionary, &_lambda_proxy_class_dictionary, st);\n+    } else {\n+      if (DynamicArchive::is_mapped()) {\n+        print_on(\"\", &_dynamic_builtin_dictionary, &_dynamic_unregistered_dictionary,\n+               &_dynamic_lambda_proxy_class_dictionary, st);\n+      }\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":53,"deletions":17,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-  static bool check_linking_constraints(InstanceKlass* klass, TRAPS) NOT_CDS_RETURN_(false);\n+  static bool check_linking_constraints(Thread* current, InstanceKlass* klass) NOT_CDS_RETURN_(false);\n@@ -302,1 +302,1 @@\n-                                     Handle loader1, Handle loader2, TRAPS) NOT_CDS_RETURN;\n+                                     Handle loader1, Handle loader2) NOT_CDS_RETURN;\n@@ -319,0 +319,1 @@\n+  static void print_shared_archive(outputStream* st, bool is_static = true) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n-    VerificationType comp_this = get_component(context, CHECK_false);\n-    VerificationType comp_from = from.get_component(context, CHECK_false);\n+    VerificationType comp_this = get_component(context);\n+    VerificationType comp_from = from.get_component(context);\n@@ -135,1 +135,1 @@\n-VerificationType VerificationType::get_component(ClassVerifier *context, TRAPS) const {\n+VerificationType VerificationType::get_component(ClassVerifier *context) const {\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-  VerificationType get_component(ClassVerifier* context, TRAPS) const;\n+  VerificationType get_component(ClassVerifier* context) const;\n","filename":"src\/hotspot\/share\/classfile\/verificationType.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,2 +137,2 @@\n-void Verifier::log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, TRAPS) {\n-  if (HAS_PENDING_EXCEPTION) {\n+void Verifier::log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, oop pending_exception) {\n+  if (pending_exception != NULL) {\n@@ -140,1 +140,1 @@\n-    oop message = java_lang_Throwable::message(PENDING_EXCEPTION);\n+    oop message = java_lang_Throwable::message(pending_exception);\n@@ -144,1 +144,1 @@\n-                 PENDING_EXCEPTION->klass()->external_name(), ex_msg);\n+                   pending_exception->klass()->external_name(), ex_msg);\n@@ -147,1 +147,1 @@\n-                 PENDING_EXCEPTION->klass()->external_name());\n+                   pending_exception->klass()->external_name());\n@@ -196,1 +196,2 @@\n-    ClassVerifier split_verifier(klass, THREAD);\n+    ClassVerifier split_verifier(jt, klass);\n+    \/\/ We don't use CHECK here, or on inference_verify below, so that we can log any exception.\n@@ -231,1 +232,1 @@\n-    log_end_verification(&ls, klass->external_name(), exception_name, THREAD);\n+    log_end_verification(&ls, klass->external_name(), exception_name, PENDING_EXCEPTION);\n@@ -236,1 +237,1 @@\n-    log_end_verification(&ls, klass->external_name(), exception_name, THREAD);\n+    log_end_verification(&ls, klass->external_name(), exception_name, PENDING_EXCEPTION);\n@@ -592,3 +593,2 @@\n-ClassVerifier::ClassVerifier(\n-    InstanceKlass* klass, TRAPS)\n-    : _thread(THREAD), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),\n+ClassVerifier::ClassVerifier(JavaThread* current, InstanceKlass* klass)\n+    : _thread(current), _previous_symbol(NULL), _symbols(NULL), _exception_type(NULL),\n@@ -619,0 +619,1 @@\n+\n@@ -656,2 +657,1 @@\n-                                        sig_as_verification_types* sig_verif_types,\n-                                        TRAPS) {\n+                                        sig_as_verification_types* sig_verif_types) {\n@@ -691,1 +691,1 @@\n-                                            int sig_index, TRAPS) {\n+                                            int sig_index) {\n@@ -695,1 +695,1 @@\n-  translate_signature(method_sig, sig_verif_types, CHECK_VERIFY(this));\n+  translate_signature(method_sig, sig_verif_types);\n@@ -721,2 +721,1 @@\n-  VerificationType return_type = current_frame.set_locals_from_arg(\n-    m, current_type(), CHECK_VERIFY(this));\n+  VerificationType return_type = current_frame.set_locals_from_arg( m, current_type());\n@@ -1052,2 +1051,1 @@\n-            VerificationType component =\n-              atype.get_component(this, CHECK_VERIFY(this));\n+            VerificationType component = atype.get_component(this);\n@@ -2830,1 +2828,1 @@\n-    create_method_sig_entry(mth_sig_verif_types, sig_index, CHECK_VERIFY(this));\n+    create_method_sig_entry(mth_sig_verif_types, sig_index);\n","filename":"src\/hotspot\/share\/classfile\/verifier.cpp","additions":18,"deletions":20,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-  static void log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name, TRAPS);\n+  static void log_end_verification(outputStream* st, const char* klassName, Symbol* exception_name,\n+                                    oop pending_exception);\n@@ -401,1 +402,1 @@\n-  ClassVerifier(InstanceKlass* klass, TRAPS);\n+  ClassVerifier(JavaThread* current, InstanceKlass* klass);\n@@ -418,1 +419,1 @@\n-  void translate_signature(Symbol* const method_sig, sig_as_verification_types* sig_verif_types, TRAPS);\n+  void translate_signature(Symbol* const method_sig, sig_as_verification_types* sig_verif_types);\n@@ -421,1 +422,1 @@\n-  void create_method_sig_entry(sig_as_verification_types* sig_verif_types, int sig_index, TRAPS);\n+  void create_method_sig_entry(sig_as_verification_types* sig_verif_types, int sig_index);\n","filename":"src\/hotspot\/share\/classfile\/verifier.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-  ClassLoader::classLoader_init2(CHECK);\n+  ClassLoader::classLoader_init2(THREAD);\n","filename":"src\/hotspot\/share\/classfile\/vmClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -972,0 +972,3 @@\n+}\n+\n+void AOTLoader_init() {\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  if (cache == NULL)  cache = (void*)Universe::non_oop_word();\n+  if (cache == NULL)  cache = Universe::non_oop_word();\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -911,1 +911,1 @@\n-Klass* Dependencies::DepStream::context_type() {\n+InstanceKlass* Dependencies::DepStream::context_type() {\n@@ -920,1 +920,1 @@\n-      return (Klass*)k;\n+      return InstanceKlass::cast((Klass*)k);\n@@ -930,2 +930,2 @@\n-      assert(k != NULL && k->is_klass(), \"type check\");\n-      return (Klass*) k;\n+      assert(k != NULL, \"type check\");\n+      return InstanceKlass::cast(k);\n@@ -1054,1 +1054,1 @@\n-  bool check_method_context(Klass* ctxk, Method* m) {\n+  bool check_method_context(InstanceKlass* ctxk, Method* m) {\n@@ -1172,0 +1172,1 @@\n+\n@@ -1199,1 +1200,1 @@\n-  Klass* find_witness_subtype(Klass* k, KlassDepChange* changes = NULL) {\n+  Klass* find_witness_subtype(InstanceKlass* context_type, KlassDepChange* changes = NULL) {\n@@ -1201,2 +1202,0 @@\n-    assert(k->is_instance_klass(), \"required\");\n-    InstanceKlass* context_type = InstanceKlass::cast(k);\n@@ -1214,1 +1213,1 @@\n-  Klass* find_witness_definer(Klass* k, KlassDepChange* changes = NULL) {\n+  Klass* find_witness_definer(InstanceKlass* context_type, KlassDepChange* changes = NULL) {\n@@ -1216,2 +1215,0 @@\n-    assert(k->is_instance_klass(), \"required\");\n-    InstanceKlass* context_type = InstanceKlass::cast(k);\n@@ -1451,1 +1448,1 @@\n-Klass* Dependencies::check_leaf_type(Klass* ctxk) {\n+Klass* Dependencies::check_leaf_type(InstanceKlass* ctxk) {\n@@ -1454,2 +1451,1 @@\n-  InstanceKlass* ctx = InstanceKlass::cast(ctxk);\n-  Klass* sub = ctx->subklass();\n+  Klass* sub = ctxk->subklass();\n@@ -1458,1 +1454,1 @@\n-  } else if (ctx->nof_implementors() != 0) {\n+  } else if (ctxk->nof_implementors() != 0) {\n@@ -1461,1 +1457,1 @@\n-    Klass* impl = ctx->implementor();\n+    InstanceKlass* impl = ctxk->implementor();\n@@ -1473,1 +1469,1 @@\n-Klass* Dependencies::check_abstract_with_unique_concrete_subtype(Klass* ctxk,\n+Klass* Dependencies::check_abstract_with_unique_concrete_subtype(InstanceKlass* ctxk,\n@@ -1486,1 +1482,1 @@\n-Klass* Dependencies::find_unique_concrete_subtype(Klass* ctxk) {\n+Klass* Dependencies::find_unique_concrete_subtype(InstanceKlass* ctxk) {\n@@ -1514,1 +1510,1 @@\n-Klass* Dependencies::check_unique_concrete_method(Klass*  ctxk,\n+Klass* Dependencies::check_unique_concrete_method(InstanceKlass* ctxk,\n@@ -1529,1 +1525,1 @@\n-Method* Dependencies::find_unique_concrete_method(Klass* ctxk, Method* m) {\n+Method* Dependencies::find_unique_concrete_method(InstanceKlass* ctxk, Method* m) {\n@@ -1560,1 +1556,1 @@\n-Klass* Dependencies::check_has_no_finalizable_subclasses(Klass* ctxk, KlassDepChange* changes) {\n+Klass* Dependencies::check_has_no_finalizable_subclasses(InstanceKlass* ctxk, KlassDepChange* changes) {\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -400,4 +400,4 @@\n-  static Klass* check_leaf_type(Klass* ctxk);\n-  static Klass* check_abstract_with_unique_concrete_subtype(Klass* ctxk, Klass* conck, KlassDepChange* changes = NULL);\n-  static Klass* check_unique_concrete_method(Klass* ctxk, Method* uniqm, KlassDepChange* changes = NULL);\n-  static Klass* check_has_no_finalizable_subclasses(Klass* ctxk, KlassDepChange* changes = NULL);\n+  static Klass* check_leaf_type(InstanceKlass* ctxk);\n+  static Klass* check_abstract_with_unique_concrete_subtype(InstanceKlass* ctxk, Klass* conck, KlassDepChange* changes = NULL);\n+  static Klass* check_unique_concrete_method(InstanceKlass* ctxk, Method* uniqm, KlassDepChange* changes = NULL);\n+  static Klass* check_has_no_finalizable_subclasses(InstanceKlass* ctxk, KlassDepChange* changes = NULL);\n@@ -420,2 +420,2 @@\n-  static Klass*  find_unique_concrete_subtype(Klass* ctxk);\n-  static Method* find_unique_concrete_method(Klass* ctxk, Method* m);\n+  static Klass*  find_unique_concrete_subtype(InstanceKlass* ctxk);\n+  static Method* find_unique_concrete_method(InstanceKlass* ctxk, Method* m);\n@@ -579,1 +579,1 @@\n-    Klass* context_type();\n+    InstanceKlass* context_type();\n","filename":"src\/hotspot\/share\/code\/dependencies.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1029,1 +1029,1 @@\n-    (*dest) = cast_to_oop(handle);\n+    *(void**)dest = handle;\n@@ -1031,1 +1031,1 @@\n-    (*dest) = JNIHandles::resolve_non_null(handle);\n+    *dest = JNIHandles::resolve_non_null(handle);\n@@ -2619,1 +2619,1 @@\n-      if (*p == Universe::non_oop_word()) {\n+      if (Universe::contains_non_oop_word(p)) {\n@@ -2715,0 +2715,30 @@\n+void nmethod::print_recorded_oop(int log_n, int i) {\n+  void* value;\n+\n+  if (i == 0) {\n+    value = NULL;\n+  } else {\n+    \/\/ Be careful around non-oop words. Don't create an oop\n+    \/\/ with that value, or it will assert in verification code.\n+    if (Universe::contains_non_oop_word(oop_addr_at(i))) {\n+      value = Universe::non_oop_word();\n+    } else {\n+      value = oop_at(i);\n+    }\n+  }\n+\n+  tty->print(\"#%*d: \" INTPTR_FORMAT \" \", log_n, i, p2i(value));\n+\n+  if (value == Universe::non_oop_word()) {\n+    tty->print(\"non-oop word\");\n+  } else {\n+    if (value == 0) {\n+      tty->print(\"NULL-oop\");\n+    } else {\n+      oop_at(i)->print_value_on(tty);\n+    }\n+  }\n+\n+  tty->cr();\n+}\n+\n@@ -2722,10 +2752,1 @@\n-      oop o = oop_at(i);\n-      tty->print(\"#%*d: \" INTPTR_FORMAT \" \", log_n, i, p2i(o));\n-      if ((void*)o == Universe::non_oop_word()) {\n-        tty->print(\"non-oop word\");\n-      } else if (o == NULL) {\n-        tty->print(\"NULL-oop\");\n-      } else {\n-        o->print_value_on(tty);\n-      }\n-      tty->cr();\n+      print_recorded_oop(log_n, i);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":34,"deletions":13,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -674,0 +674,1 @@\n+  void print_recorded_oop(int log_n, int index);\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,1 +544,0 @@\n-  oop v = *oop_addr();\n@@ -546,2 +545,4 @@\n-  if (v == Universe::non_oop_word())  v = NULL;\n-  return v;\n+  if (Universe::contains_non_oop_word(oop_addr())) {\n+    return NULL;\n+  }\n+  return *oop_addr();\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  if (comp_level == CompLevel_all) {\n+  if (comp_level == CompLevel_any) {\n@@ -128,1 +128,1 @@\n-  assert(WhiteBoxAPI || comp_level == CompLevel_all || is_compile(comp_level), \"illegal compilation level\");\n+  assert(WhiteBoxAPI || comp_level == CompLevel_any || is_compile(comp_level), \"illegal compilation level\");\n@@ -143,1 +143,1 @@\n-  if (comp_level == CompLevel_all || is_compile(comp_level)) {\n+  if (comp_level == CompLevel_any || is_compile(comp_level)) {\n@@ -153,1 +153,1 @@\n-  if (comp_level == CompLevel_all || is_compile(comp_level)) {\n+  if (comp_level == CompLevel_any || is_compile(comp_level)) {\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -240,1 +240,1 @@\n-  static bool must_be_compiled(const methodHandle& m, int comp_level = CompLevel_all);\n+  static bool must_be_compiled(const methodHandle& m, int comp_level = CompLevel_any);\n@@ -251,1 +251,1 @@\n-  static bool can_be_compiled(const methodHandle& m, int comp_level = CompLevel_all);\n+  static bool can_be_compiled(const methodHandle& m, int comp_level = CompLevel_any);\n@@ -253,1 +253,1 @@\n-  static bool can_be_osr_compiled(const methodHandle& m, int comp_level = CompLevel_all);\n+  static bool can_be_osr_compiled(const methodHandle& m, int comp_level = CompLevel_any);\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-  CompLevel_any               = -2,\n-  CompLevel_all               = -2,\n+  CompLevel_any               = -2,        \/\/ Used for querying the state\n+  CompLevel_all               = -2,        \/\/ Used for changing the state\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,0 +53,18 @@\n+static_assert(sizeof(oop) == sizeof(intptr_t), \"Derived pointer sanity check\");\n+\n+static inline intptr_t derived_pointer_value(derived_pointer p) {\n+  return static_cast<intptr_t>(p);\n+}\n+\n+static inline derived_pointer to_derived_pointer(oop obj) {\n+  return static_cast<derived_pointer>(cast_from_oop<intptr_t>(obj));\n+}\n+\n+static inline intptr_t operator-(derived_pointer p, derived_pointer p1) {\n+  return derived_pointer_value(p) - derived_pointer_value(p1);\n+}\n+\n+static inline derived_pointer operator+(derived_pointer p, intptr_t offset) {\n+  return static_cast<derived_pointer>(derived_pointer_value(p) + offset);\n+}\n+\n@@ -196,1 +214,1 @@\n-static void add_derived_oop(oop* base, oop* derived, OopClosure* oop_fn) {\n+static void add_derived_oop(oop* base, derived_pointer* derived, OopClosure* oop_fn) {\n@@ -202,1 +220,1 @@\n-static void ignore_derived_oop(oop* base, oop* derived, OopClosure* oop_fn) {\n+static void ignore_derived_oop(oop* base, derived_pointer* derived, OopClosure* oop_fn) {\n@@ -205,1 +223,1 @@\n-static void process_derived_oop(oop* base, oop* derived, OopClosure* oop_fn) {\n+static void process_derived_oop(oop* base, derived_pointer* derived, OopClosure* oop_fn) {\n@@ -209,4 +227,5 @@\n-  uintptr_t offset = cast_from_oop<uintptr_t>(*derived) - cast_from_oop<uintptr_t>(*base);\n-  *derived = *base;\n-  oop_fn->do_oop(derived);\n-  *derived = cast_to_oop(cast_from_oop<uintptr_t>(*derived) + offset);\n+  derived_pointer derived_base = to_derived_pointer(*base);\n+  intptr_t offset = *derived - derived_base;\n+  *derived = derived_base;\n+  oop_fn->do_oop((oop*)derived);\n+  *derived = *derived + offset;\n@@ -247,1 +266,1 @@\n-    all_do(fr, reg_map, f, process_derived_oop, &do_nothing_cl);\n+    all_do(fr, reg_map, f, process_derived_oop);\n@@ -250,1 +269,1 @@\n-    all_do(fr, reg_map, f, add_derived_oop, &do_nothing_cl);\n+    all_do(fr, reg_map, f, add_derived_oop);\n@@ -253,1 +272,1 @@\n-    all_do(fr, reg_map, f, ignore_derived_oop, &do_nothing_cl);\n+    all_do(fr, reg_map, f, ignore_derived_oop);\n@@ -260,2 +279,1 @@\n-                       OopClosure* oop_fn, void derived_oop_fn(oop*, oop*, OopClosure*),\n-                       OopClosure* value_fn) {\n+                       OopClosure* oop_fn, void derived_oop_fn(oop*, derived_pointer*, OopClosure*)) {\n@@ -287,4 +305,3 @@\n-      oop* loc = fr->oopmapreg_to_location(omv.reg(),reg_map);\n-      guarantee(loc != NULL, \"missing saved register\");\n-      oop *derived_loc = loc;\n-      oop *base_loc    = fr->oopmapreg_to_location(omv.content_reg(), reg_map);\n+      derived_pointer* derived_loc = (derived_pointer*)fr->oopmapreg_to_location(omv.reg(),reg_map);\n+      guarantee(derived_loc != NULL, \"missing saved register\");\n+      oop* base_loc = fr->oopmapreg_to_oop_location(omv.content_reg(), reg_map);\n@@ -306,1 +323,1 @@\n-      oop* loc = fr->oopmapreg_to_location(omv.reg(),reg_map);\n+      oop* loc = fr->oopmapreg_to_oop_location(omv.reg(),reg_map);\n@@ -369,1 +386,1 @@\n-      oop* loc = fr->oopmapreg_to_location(omv.reg(), reg_map);\n+      oop* loc = fr->oopmapreg_to_oop_location(omv.reg(), reg_map);\n@@ -660,3 +677,3 @@\n-  oop* _location;   \/\/ Location of derived pointer, also pointing to base\n-  intptr_t _offset; \/\/ Offset from base pointer\n-  Entry* volatile _next;\n+  derived_pointer* _location; \/\/ Location of derived pointer, also pointing to base\n+  intptr_t         _offset;   \/\/ Offset from base pointer\n+  Entry* volatile  _next;\n@@ -667,1 +684,1 @@\n-  Entry(oop* location, intptr_t offset) :\n+  Entry(derived_pointer* location, intptr_t offset) :\n@@ -670,1 +687,1 @@\n-  oop* location() const { return _location; }\n+  derived_pointer* location() const { return _location; }\n@@ -698,6 +715,1 @@\n-\/\/ Returns value of location as an int\n-inline intptr_t value_of_loc(oop *pointer) {\n-  return cast_from_oop<intptr_t>((*pointer));\n-}\n-\n-void DerivedPointerTable::add(oop *derived_loc, oop *base_loc) {\n+void DerivedPointerTable::add(derived_pointer* derived_loc, oop *base_loc) {\n@@ -705,2 +717,4 @@\n-  assert(derived_loc != base_loc, \"Base and derived in same location\");\n-  assert(*derived_loc != (void*)base_loc, \"location already added\");\n+  assert(derived_loc != (void*)base_loc, \"Base and derived in same location\");\n+  derived_pointer base_loc_as_derived_pointer =\n+    static_cast<derived_pointer>(reinterpret_cast<intptr_t>(base_loc));\n+  assert(*derived_loc != base_loc_as_derived_pointer, \"location already added\");\n@@ -709,1 +723,1 @@\n-  intptr_t offset = value_of_loc(derived_loc) - value_of_loc(base_loc);\n+  intptr_t offset = *derived_loc - to_derived_pointer(*base_loc);\n@@ -719,1 +733,1 @@\n-      p2i(derived_loc), p2i(*derived_loc), p2i(*base_loc), p2i(base_loc), offset\n+      p2i(derived_loc), derived_pointer_value(*derived_loc), p2i(*base_loc), p2i(base_loc), offset\n@@ -723,1 +737,1 @@\n-  *derived_loc = cast_to_oop(base_loc);\n+  *derived_loc = base_loc_as_derived_pointer;\n@@ -734,1 +748,1 @@\n-    oop* derived_loc = entry->location();\n+    derived_pointer* derived_loc = entry->location();\n@@ -737,1 +751,1 @@\n-    oop base = **(oop**)derived_loc;\n+    oop base = **reinterpret_cast<oop**>(derived_loc);\n@@ -740,2 +754,3 @@\n-    *derived_loc = cast_to_oop(cast_from_oop<address>(base) + offset);\n-    assert(value_of_loc(derived_loc) - value_of_loc(&base) == offset, \"sanity check\");\n+    derived_pointer derived_base = to_derived_pointer(base);\n+    *derived_loc = derived_base + offset;\n+    assert(*derived_loc - derived_base == offset, \"sanity check\");\n@@ -746,1 +761,1 @@\n-          p2i(derived_loc), p2i(*derived_loc), p2i(base), offset);\n+                    p2i(derived_loc), derived_pointer_value(*derived_loc), p2i(base), offset);\n","filename":"src\/hotspot\/share\/compiler\/oopMap.cpp","additions":54,"deletions":39,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+enum class derived_pointer : intptr_t {};\n+\n@@ -232,2 +234,1 @@\n-                     void derived_oop_fn(oop* base, oop* derived, OopClosure* oop_fn),\n-                     OopClosure* value_fn);\n+                     void derived_oop_fn(oop* base, derived_pointer* derived, OopClosure* oop_fn));\n@@ -416,1 +417,1 @@\n-  static bool _active;                      \/\/ do not record pointers for verify pass etc.\n+  static bool _active;                                  \/\/ do not record pointers for verify pass etc.\n@@ -419,3 +420,3 @@\n-  static void clear();                       \/\/ Called before scavenge\/GC\n-  static void add(oop *derived, oop *base);  \/\/ Called during scavenge\/GC\n-  static void update_pointers();             \/\/ Called after  scavenge\/GC\n+  static void clear();                                  \/\/ Called before scavenge\/GC\n+  static void add(derived_pointer* derived, oop *base); \/\/ Called during scavenge\/GC\n+  static void update_pointers();                        \/\/ Called after  scavenge\/GC\n","filename":"src\/hotspot\/share\/compiler\/oopMap.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"utilities\/lockFreeQueue.inline.hpp\"\n@@ -49,0 +50,1 @@\n+#include \"utilities\/pair.hpp\"\n@@ -119,109 +121,0 @@\n-#ifdef ASSERT\n-G1DirtyCardQueueSet::Queue::~Queue() {\n-  assert(_head == NULL, \"precondition\");\n-  assert(_tail == NULL, \"precondition\");\n-}\n-#endif \/\/ ASSERT\n-\n-BufferNode* G1DirtyCardQueueSet::Queue::top() const {\n-  return Atomic::load(&_head);\n-}\n-\n-\/\/ An append operation atomically exchanges the new tail with the queue tail.\n-\/\/ It then sets the \"next\" value of the old tail to the head of the list being\n-\/\/ appended; it is an invariant that the old tail's \"next\" value is NULL.\n-\/\/ But if the old tail is NULL then the queue was empty.  In this case the\n-\/\/ head of the list being appended is instead stored in the queue head; it is\n-\/\/ an invariant that the queue head is NULL in this case.\n-\/\/\n-\/\/ This means there is a period between the exchange and the old tail update\n-\/\/ where the queue sequence is split into two parts, the list from the queue\n-\/\/ head to the old tail, and the list being appended.  If there are concurrent\n-\/\/ push\/append operations, each may introduce another such segment.  But they\n-\/\/ all eventually get resolved by their respective updates of their old tail's\n-\/\/ \"next\" value.  This also means that pop operations must handle a buffer\n-\/\/ with a NULL \"next\" value specially.\n-\/\/\n-\/\/ A push operation is just a degenerate append, where the buffer being pushed\n-\/\/ is both the head and the tail of the list being appended.\n-void G1DirtyCardQueueSet::Queue::append(BufferNode& first, BufferNode& last) {\n-  assert(last.next() == NULL, \"precondition\");\n-  BufferNode* old_tail = Atomic::xchg(&_tail, &last);\n-  if (old_tail == NULL) {       \/\/ Was empty.\n-    Atomic::store(&_head, &first);\n-  } else {\n-    assert(old_tail->next() == NULL, \"invariant\");\n-    old_tail->set_next(&first);\n-  }\n-}\n-\n-BufferNode* G1DirtyCardQueueSet::Queue::pop() {\n-  Thread* current_thread = Thread::current();\n-  while (true) {\n-    \/\/ Use a critical section per iteration, rather than over the whole\n-    \/\/ operation.  We're not guaranteed to make progress.  Lingering in one\n-    \/\/ CS could lead to excessive allocation of buffers, because the CS\n-    \/\/ blocks return of released buffers to the free list for reuse.\n-    GlobalCounter::CriticalSection cs(current_thread);\n-\n-    BufferNode* result = Atomic::load_acquire(&_head);\n-    if (result == NULL) return NULL; \/\/ Queue is empty.\n-\n-    BufferNode* next = Atomic::load_acquire(BufferNode::next_ptr(*result));\n-    if (next != NULL) {\n-      \/\/ The \"usual\" lock-free pop from the head of a singly linked list.\n-      if (result == Atomic::cmpxchg(&_head, result, next)) {\n-        \/\/ Former head successfully taken; it is not the last.\n-        assert(Atomic::load(&_tail) != result, \"invariant\");\n-        assert(result->next() != NULL, \"invariant\");\n-        result->set_next(NULL);\n-        return result;\n-      }\n-      \/\/ Lost the race; try again.\n-      continue;\n-    }\n-\n-    \/\/ next is NULL.  This case is handled differently from the \"usual\"\n-    \/\/ lock-free pop from the head of a singly linked list.\n-\n-    \/\/ If _tail == result then result is the only element in the list. We can\n-    \/\/ remove it from the list by first setting _tail to NULL and then setting\n-    \/\/ _head to NULL, the order being important.  We set _tail with cmpxchg in\n-    \/\/ case of a concurrent push\/append\/pop also changing _tail.  If we win\n-    \/\/ then we've claimed result.\n-    if (Atomic::cmpxchg(&_tail, result, (BufferNode*)NULL) == result) {\n-      assert(result->next() == NULL, \"invariant\");\n-      \/\/ Now that we've claimed result, also set _head to NULL.  But we must\n-      \/\/ be careful of a concurrent push\/append after we NULLed _tail, since\n-      \/\/ it may have already performed its list-was-empty update of _head,\n-      \/\/ which we must not overwrite.\n-      Atomic::cmpxchg(&_head, result, (BufferNode*)NULL);\n-      return result;\n-    }\n-\n-    \/\/ If _head != result then we lost the race to take result; try again.\n-    if (result != Atomic::load_acquire(&_head)) {\n-      continue;\n-    }\n-\n-    \/\/ An in-progress concurrent operation interfered with taking the head\n-    \/\/ element when it was the only element.  A concurrent pop may have won\n-    \/\/ the race to clear the tail but not yet cleared the head. Alternatively,\n-    \/\/ a concurrent push\/append may have changed the tail but not yet linked\n-    \/\/ result->next().  We cannot take result in either case.  We don't just\n-    \/\/ try again, because we could spin for a long time waiting for that\n-    \/\/ concurrent operation to finish.  In the first case, returning NULL is\n-    \/\/ fine; we lost the race for the only element to another thread.  We\n-    \/\/ also return NULL for the second case, and let the caller cope.\n-    return NULL;\n-  }\n-}\n-\n-G1DirtyCardQueueSet::HeadTail G1DirtyCardQueueSet::Queue::take_all() {\n-  assert_at_safepoint();\n-  HeadTail result(Atomic::load(&_head), Atomic::load(&_tail));\n-  Atomic::store(&_head, (BufferNode*)NULL);\n-  Atomic::store(&_tail, (BufferNode*)NULL);\n-  return result;\n-}\n-\n@@ -240,0 +133,33 @@\n+\/\/ Thread-safe attempt to remove and return the first buffer from\n+\/\/ the _completed queue, using the LockFreeQueue::try_pop() underneath.\n+\/\/ It has a restriction that it may return NULL when there are objects\n+\/\/ in the queue if there is a concurrent push\/append operation.\n+BufferNode* G1DirtyCardQueueSet::dequeue_completed_buffer() {\n+  using Status = LockFreeQueuePopStatus;\n+  Thread* current_thread = Thread::current();\n+  while (true) {\n+    \/\/ Use GlobalCounter critical section to avoid ABA problem.\n+    \/\/ The release of a buffer to its allocator's free list uses\n+    \/\/ GlobalCounter::write_synchronize() to coordinate with this\n+    \/\/ dequeuing operation.\n+    \/\/ We use a CS per iteration, rather than over the whole loop,\n+    \/\/ because we're not guaranteed to make progress. Lingering in\n+    \/\/ one CS could defer releasing buffer to the free list for reuse,\n+    \/\/ leading to excessive allocations.\n+    GlobalCounter::CriticalSection cs(current_thread);\n+    Pair<Status, BufferNode*> pop_result = _completed.try_pop();\n+    switch (pop_result.first) {\n+      case Status::success:\n+        return pop_result.second;\n+      case Status::operation_in_progress:\n+        \/\/ Returning NULL instead retrying, in order to mitigate the\n+        \/\/ chance of spinning for a long time. In the case of getting a\n+        \/\/ buffer to refine, it is also OK to return NULL when there is\n+        \/\/ an interfering concurrent push\/append operation.\n+        return NULL;\n+      case Status::lost_race:\n+        break;  \/\/ Try again.\n+    }\n+  }\n+}\n+\n@@ -241,1 +167,1 @@\n-  BufferNode* result = _completed.pop();\n+  BufferNode* result = dequeue_completed_buffer();\n@@ -244,1 +170,1 @@\n-    result = _completed.pop();\n+    result = dequeue_completed_buffer();\n@@ -428,1 +354,1 @@\n-  HeadTail buffers = _completed.take_all();\n+  Pair<BufferNode*, BufferNode*> pair = _completed.take_all();\n@@ -431,1 +357,1 @@\n-  return G1BufferNodeList(buffers._head, buffers._tail, num_cards);\n+  return G1BufferNodeList(pair.first, pair.second, num_cards);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":39,"deletions":113,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/lockFreeQueue.hpp\"\n@@ -79,37 +80,0 @@\n-  \/\/ A lock-free FIFO of BufferNodes, linked through their next() fields.\n-  \/\/ This class has a restriction that pop() may return NULL when there are\n-  \/\/ buffers in the queue if there is a concurrent push\/append operation.\n-  class Queue {\n-    BufferNode* volatile _head;\n-    DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(BufferNode*));\n-    BufferNode* volatile _tail;\n-    DEFINE_PAD_MINUS_SIZE(2, DEFAULT_CACHE_LINE_SIZE, sizeof(BufferNode*));\n-\n-    NONCOPYABLE(Queue);\n-\n-  public:\n-    Queue() : _head(NULL), _tail(NULL) {}\n-    DEBUG_ONLY(~Queue();)\n-\n-    \/\/ Return the first buffer in the queue.\n-    \/\/ Thread-safe, but the result may change immediately.\n-    BufferNode* top() const;\n-\n-    \/\/ Thread-safe add the buffer to the end of the queue.\n-    void push(BufferNode& node) { append(node, node); }\n-\n-    \/\/ Thread-safe add the buffers from first to last to the end of the queue.\n-    void append(BufferNode& first, BufferNode& last);\n-\n-    \/\/ Thread-safe attempt to remove and return the first buffer in the queue.\n-    \/\/ Returns NULL if the queue is empty, or if a concurrent push\/append\n-    \/\/ interferes.  Uses GlobalCounter critical sections to address the ABA\n-    \/\/ problem; this works with the buffer allocator's use of GlobalCounter\n-    \/\/ synchronization.\n-    BufferNode* pop();\n-\n-    \/\/ Take all the buffers from the queue, leaving the queue empty.\n-    \/\/ Not thread-safe.\n-    HeadTail take_all();\n-  };\n-\n@@ -203,1 +167,4 @@\n-  Queue _completed;           \/\/ Has inner padding, including trailer.\n+  \/\/ LockFreeQueue has inner padding of one cache line.\n+  LockFreeQueue<BufferNode, &BufferNode::next_ptr> _completed;\n+  \/\/ Add a trailer padding after LockFreeQueue.\n+  DEFINE_PAD_MINUS_SIZE(3, DEFAULT_CACHE_LINE_SIZE, sizeof(BufferNode*));\n@@ -205,1 +172,2 @@\n-  PausedBuffers _paused;      \/\/ Has inner padding, including trailer.\n+  \/\/ PausedBuffers has inner padding, including trailer.\n+  PausedBuffers _paused;\n@@ -251,0 +219,5 @@\n+  \/\/ Thread-safe attempt to remove and return the first buffer from\n+  \/\/ the _completed queue.\n+  \/\/ Returns NULL if the queue is empty, or if a concurrent push\/append\n+  \/\/ interferes. It uses GlobalCounter critical section to avoid ABA problem.\n+  BufferNode* dequeue_completed_buffer();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":12,"deletions":39,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -537,0 +537,1 @@\n+  \/\/ end_region is inclusive\n@@ -552,1 +553,0 @@\n-  Klass* klass = cast_to_oop(addr)->klass();\n@@ -568,2 +568,2 @@\n-  assert(region_offset(beg) == 0, \"not RegionSize aligned\");\n-  assert(region_offset(end) == 0, \"not RegionSize aligned\");\n+  assert(is_region_aligned(beg), \"not RegionSize aligned\");\n+  assert(is_region_aligned(end), \"not RegionSize aligned\");\n@@ -765,1 +765,1 @@\n-      } else if (region_offset(dest_addr) == 0) {\n+      } else if (is_region_aligned(dest_addr)) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -678,1 +678,2 @@\n-  assert(addr <= _region_end, \"bad addr\");\n+  \/\/ would mistakenly return 0 for _region_end\n+  assert(addr < _region_end, \"bad addr\");\n@@ -737,1 +738,1 @@\n-  return region_offset(addr) == 0;\n+  return (size_t(addr) & RegionAddrOffsetMask) == 0;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+  assert(_thread->is_Java_thread(), \"non Java threads shouldn't allocate on the Heap\");\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,0 +114,4 @@\n+bool OopStorage::AllocationList::contains(const Block& block) const {\n+  return (next(block) != NULL) || (ctail() == &block);\n+}\n+\n@@ -248,2 +252,2 @@\n-inline bool is_full_bitmask(uintx bitmask) { return ~bitmask == 0; }\n-inline bool is_empty_bitmask(uintx bitmask) { return bitmask == 0; }\n+static inline bool is_full_bitmask(uintx bitmask) { return ~bitmask == 0; }\n+static inline bool is_empty_bitmask(uintx bitmask) { return bitmask == 0; }\n@@ -670,1 +674,1 @@\n-  \/\/ Process popped block.\n+  \/\/ Make list state consistent with bitmask state.\n@@ -672,15 +676,11 @@\n-\n-  \/\/ Make membership in list consistent with bitmask state.\n-  if ((_allocation_list.ctail() != NULL) &&\n-      ((_allocation_list.ctail() == block) ||\n-       (_allocation_list.next(*block) != NULL))) {\n-    \/\/ Block is in the _allocation_list.\n-    assert(!is_full_bitmask(allocated), \"invariant\");\n-  } else if (!is_full_bitmask(allocated)) {\n-    \/\/ Block is not in the _allocation_list, but now should be.\n-    _allocation_list.push_front(*block);\n-  } \/\/ Else block is full and not in list, which is correct.\n-\n-  \/\/ Move empty block to end of list, for possible deletion.\n-  if (is_empty_bitmask(allocated)) {\n-    _allocation_list.unlink(*block);\n+  if (is_full_bitmask(allocated)) {\n+    \/\/ If full then it shouldn't be in the list, and should stay that way.\n+    assert(!_allocation_list.contains(*block), \"invariant\");\n+  } else if (_allocation_list.contains(*block)) {\n+    \/\/ Block is in list.  If empty, move to the end for possible deletion.\n+    if (is_empty_bitmask(allocated)) {\n+      _allocation_list.unlink(*block);\n+      _allocation_list.push_back(*block);\n+    }\n+  } else if (is_empty_bitmask(allocated)) {\n+    \/\/ Block is empty and not in list. Add to back for possible deletion.\n@@ -688,0 +688,3 @@\n+  } else {\n+    \/\/ Block is neither full nor empty, and not in list.  Add to front.\n+    _allocation_list.push_front(*block);\n@@ -695,1 +698,1 @@\n-inline void check_release_entry(const oop* entry) {\n+static inline void check_release_entry(const oop* entry) {\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":22,"deletions":19,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -215,1 +215,2 @@\n-  \/\/ Doubly-linked list of Blocks.\n+  \/\/ Doubly-linked list of Blocks.  For all operations with a block\n+  \/\/ argument, the block must be from the list's OopStorage.\n@@ -240,0 +241,2 @@\n+\n+    bool contains(const Block& block) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -114,4 +114,0 @@\n-  if (FLAG_IS_DEFAULT(ParallelRefProcEnabled)) {\n-    FLAG_SET_DEFAULT(ParallelRefProcEnabled, true);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -810,0 +810,6 @@\n+\n+  \/\/ Perform handshake to flush out dead oops\n+  {\n+    ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_weak_roots_rendezvous);\n+    heap->rendezvous_threads();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1554,0 +1554,11 @@\n+class ShenandoahRendezvousClosure : public HandshakeClosure {\n+public:\n+  inline ShenandoahRendezvousClosure() : HandshakeClosure(\"ShenandoahRendezvous\") {}\n+  inline void do_thread(Thread* thread) {}\n+};\n+\n+void ShenandoahHeap::rendezvous_threads() {\n+  ShenandoahRendezvousClosure cl;\n+  Handshake::execute(&cl);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  friend class ShenandoahUnload;\n@@ -374,0 +375,1 @@\n+  void rendezvous_threads();\n@@ -375,1 +377,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+  f(conc_weak_roots_rendezvous,                     \"  Rendezvous\")                    \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -136,6 +136,0 @@\n-class ShenandoahRendezvousClosure : public HandshakeClosure {\n-public:\n-  inline ShenandoahRendezvousClosure() : HandshakeClosure(\"ShenandoahRendezvous\") {}\n-  inline void do_thread(Thread* thread) {}\n-};\n-\n@@ -175,2 +169,1 @@\n-    ShenandoahRendezvousClosure cl;\n-    Handshake::execute(&cl);\n+    heap->rendezvous_threads();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-      if (*p != Universe::non_oop_word()) {\n+      if (!Universe::contains_non_oop_word(p)) {\n@@ -235,1 +235,1 @@\n-      if (**p != Universe::non_oop_word()) {\n+      if (*p != Universe::non_oop_word()) {\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1118,7 +1118,1 @@\n-  MethodCounters* mcs = Method::build_method_counters(m, thread);\n-  if (HAS_PENDING_EXCEPTION) {\n-    \/\/ Only metaspace OOM is expected. No Java code executed.\n-    assert((PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())), \"we expect only an OOM error here\");\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-  return mcs;\n+  return Method::build_method_counters(thread, m);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -161,1 +161,1 @@\n-  static MethodCounters* build_method_counters(JavaThread* thread, Method* m);\n+  static MethodCounters* build_method_counters(JavaThread* current, Method* m);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-                                              resolved_loader, true, CHECK);\n+                                              resolved_loader, true);\n@@ -715,2 +715,1 @@\n-                                              false,\n-                                              CHECK);\n+                                              false);\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -605,1 +605,0 @@\n-  Thread* const t = Thread::current();\n@@ -608,1 +607,1 @@\n-  return Modules::is_package_defined(pkg_sym, Handle(), t);\n+  return Modules::is_package_defined(pkg_sym, Handle());\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -428,2 +428,1 @@\n-    KlassCallback callback(&kwr);\n-    _subsystem_callback = &callback;\n+    KlassCallback callback(&_subsystem_callback, &kwr);\n@@ -435,2 +434,1 @@\n-    CompositeKlassCallback callback(&ckwr);\n-    _subsystem_callback = &callback;\n+    CompositeKlassCallback callback(&_subsystem_callback, &ckwr);\n@@ -477,2 +475,1 @@\n-  RegisterKlassCallback callback(&reg);\n-  _subsystem_callback = &callback;\n+  RegisterKlassCallback callback(&_subsystem_callback, &reg);\n@@ -555,2 +552,1 @@\n-    PackageCallback callback(&pwwc);\n-    _subsystem_callback = &callback;\n+    PackageCallback callback(&_subsystem_callback, &pwwc);\n@@ -565,2 +561,1 @@\n-    CompositePackageCallback callback(&cpwwc);\n-    _subsystem_callback = &callback;\n+    CompositePackageCallback callback(&_subsystem_callback, &cpwwc);\n@@ -576,2 +571,1 @@\n-  ClearPackageCallback callback(&clear);\n-  _subsystem_callback = &callback;\n+  ClearPackageCallback callback(&_subsystem_callback, &clear);\n@@ -654,2 +648,1 @@\n-    ModuleCallback callback(&mwwc);\n-    _subsystem_callback = &callback;\n+    ModuleCallback callback(&_subsystem_callback, &mwwc);\n@@ -664,2 +657,1 @@\n-    CompositeModuleCallback callback(&cmwwc);\n-    _subsystem_callback = &callback;\n+    CompositeModuleCallback callback(&_subsystem_callback, &cmwwc);\n@@ -675,2 +667,1 @@\n-  ClearModuleCallback callback(&clear);\n-  _subsystem_callback = &callback;\n+  ClearModuleCallback callback(&_subsystem_callback, &clear);\n@@ -788,2 +779,1 @@\n-    CldCallback callback(&cldwwc);\n-    _subsystem_callback = &callback;\n+    CldCallback callback(&_subsystem_callback, &cldwwc);\n@@ -800,2 +790,1 @@\n-    CompositeCldCallback callback(&ccldwwc);\n-    _subsystem_callback = &callback;\n+    CompositeCldCallback callback(&_subsystem_callback, &ccldwwc);\n@@ -811,2 +800,1 @@\n-  ClearCLDCallback callback(&clear);\n-  _subsystem_callback = &callback;\n+  ClearCLDCallback callback(&_subsystem_callback, &clear);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  JfrArtifactClosure** _subsystem_callback_loc;\n@@ -63,1 +64,8 @@\n-  JfrArtifactCallbackHost(Callback* callback) : _callback(callback) {}\n+  JfrArtifactCallbackHost(JfrArtifactClosure** subsystem_callback_loc, Callback* callback) :\n+          _subsystem_callback_loc(subsystem_callback_loc), _callback(callback) {\n+    assert(*_subsystem_callback_loc == NULL, \"Subsystem callback should not be set yet\");\n+    *_subsystem_callback_loc = this;\n+  }\n+  ~JfrArtifactCallbackHost() {\n+    *_subsystem_callback_loc = NULL;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -203,0 +203,9 @@\n+\n+    intptr_t* frame_id = st.frame_id();\n+    st.samples_next();\n+    if (type == JfrStackFrame::FRAME_JIT && !st.at_end() && frame_id == st.frame_id()) {\n+      \/\/ This frame and the caller frame are both the same physical\n+      \/\/ frame, so this frame is inlined into the caller.\n+      type = JfrStackFrame::FRAME_INLINE;\n+    }\n+\n@@ -204,1 +213,0 @@\n-    \/\/ Can we determine if it's inlined?\n@@ -209,1 +217,0 @@\n-    st.samples_next();\n@@ -262,0 +269,8 @@\n+    intptr_t* frame_id = vfs.frame_id();\n+    vfs.next();\n+    if (type == JfrStackFrame::FRAME_JIT && !vfs.at_end() && frame_id == vfs.frame_id()) {\n+      \/\/ This frame and the caller frame are both the same physical\n+      \/\/ frame, so this frame is inlined into the caller.\n+      type = JfrStackFrame::FRAME_INLINE;\n+    }\n+\n@@ -266,1 +281,0 @@\n-    vfs.next();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -461,1 +461,1 @@\n-  Klass* holder = JVMCIENV->asKlass(jvmci_type);\n+  InstanceKlass* holder = InstanceKlass::cast(JVMCIENV->asKlass(jvmci_type));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1258,2 +1258,2 @@\n-  Handle loader(THREAD, (oop)NULL);\n-  Handle domain(THREAD, (oop)NULL);\n+  Handle loader;\n+  Handle domain;\n@@ -1268,1 +1268,1 @@\n-    MutexLocker ml(Compile_lock);\n+    MutexLocker ml(THREAD, Compile_lock);\n@@ -1270,1 +1270,1 @@\n-      found_klass = SystemDictionary::find_constrained_instance_or_array_klass(sym, loader, THREAD);\n+      found_klass = SystemDictionary::find_constrained_instance_or_array_klass(THREAD, sym, loader);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -185,0 +185,3 @@\n+  nonstatic_field(JavaThread,                  _jvmci_reserved0,                              intptr_t*)                             \\\n+  nonstatic_field(JavaThread,                  _jvmci_reserved1,                              intptr_t*)                             \\\n+  nonstatic_field(JavaThread,                  _jvmci_reserved_oop0,                          oop)                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  \/\/ Klass has it's own operator new\n+  \/\/ Klass has its own operator new\n@@ -86,0 +86,7 @@\n+void* MetaspaceObj::operator new(size_t size, ClassLoaderData* loader_data,\n+                                 size_t word_size,\n+                                 MetaspaceObj::Type type) throw() {\n+  assert(!Thread::current()->is_Java_thread(), \"only allowed by non-Java thread\");\n+  return Metaspace::allocate(loader_data, word_size, type);\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/allocation.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -348,0 +348,3 @@\n+  void* operator new(size_t size, ClassLoaderData* loader_data,\n+                     size_t word_size,\n+                     Type type) throw();\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -1092,0 +1093,4 @@\n+  if (mapinfo->header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    mapinfo->set_header_base_archive_name_size(strlen(Arguments::GetSharedArchivePath()) + 1);\n+    mapinfo->set_header_base_archive_is_default(FLAG_IS_DEFAULT(SharedArchiveFile));\n+  }\n@@ -1093,0 +1098,2 @@\n+  \/\/ After this point, we should not write any data into mapinfo->header() since this\n+  \/\/ would corrupt its checksum we have calculated before.\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -256,2 +256,2 @@\n-  ik->vtable().initialize_vtable(true, THREAD); assert(!HAS_PENDING_EXCEPTION, \"cannot fail\");\n-  ik->itable().initialize_itable(true, THREAD); assert(!HAS_PENDING_EXCEPTION, \"cannot fail\");\n+  ik->vtable().initialize_vtable();\n+  ik->itable().initialize_itable();\n","filename":"src\/hotspot\/share\/memory\/dynamicArchive.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n@@ -1239,7 +1238,0 @@\n-  char* base_archive_name = NULL;\n-  if (header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    base_archive_name = (char*)Arguments::GetSharedArchivePath();\n-    header()->set_base_archive_name_size(strlen(base_archive_name) + 1);\n-    header()->set_base_archive_is_default(FLAG_IS_DEFAULT(SharedArchiveFile));\n-  }\n-\n@@ -1248,2 +1240,6 @@\n-  if (base_archive_name != NULL) {\n-    write_bytes(base_archive_name, header()->base_archive_name_size());\n+\n+  if (header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    char* base_archive_name = (char*)Arguments::GetSharedArchivePath();\n+    if (base_archive_name != NULL) {\n+      write_bytes(base_archive_name, header()->base_archive_name_size());\n+    }\n@@ -1660,1 +1656,1 @@\n-  if (VerifySharedSpaces && !region_crc_check(bitmap_base, si->used_aligned(), si->crc())) {\n+  if (VerifySharedSpaces && !region_crc_check(bitmap_base, si->used(), si->crc())) {\n@@ -2339,2 +2335,2 @@\n-        char *msg = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(path) + 128); ;\n-        jio_snprintf(msg, strlen(path) + 127, \"error in opening JAR file %s\", path);\n+        char *msg = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(path) + 128);\n+        jio_snprintf(msg, strlen(path) + 127, \"error in finding JAR file %s\", path);\n@@ -2343,1 +2339,6 @@\n-        ent = ClassLoader::create_class_path_entry(path, &st, \/*throw_exception=*\/true, false, false, CHECK_NULL);\n+        ent = ClassLoader::create_class_path_entry(THREAD, path, &st, false, false);\n+        if (ent == NULL) {\n+          char *msg = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(path) + 128);\n+          jio_snprintf(msg, strlen(path) + 127, \"error in opening JAR file %s\", path);\n+          THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);\n+        }\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-  unsigned int magic() const {return _magic;}\n+  unsigned int magic()                    const { return _magic; }\n@@ -386,0 +386,1 @@\n+  unsigned int magic()         const { return header()->magic(); }\n@@ -393,0 +394,3 @@\n+  void   set_header_base_archive_name_size(size_t size)      { header()->set_base_archive_name_size(size); }\n+  void   set_header_base_archive_is_default(bool is_default) { header()->set_base_archive_is_default(is_default); }\n+\n@@ -547,0 +551,4 @@\n+  const char* vm_version() {\n+    return header()->jvm_ident();\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/filemap.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -838,1 +838,4 @@\n-    assert((count == 0) || (extra_hops < (16 + 2*count)), \"CodeHeap: many extra hops due to optimization. blocks: %d, extra hops: %d.\", count, extra_hops);\n+    assert(extra_hops <= _fragmentation_count, \"CodeHeap: extra hops wrong. fragmentation: %d, extra hops: %d.\", _fragmentation_count, extra_hops);\n+    if (extra_hops >= (16 + 2 * count)) {\n+      warning(\"CodeHeap: many extra hops due to optimization. blocks: %d, extra hops: %d.\", count, extra_hops);\n+    }\n","filename":"src\/hotspot\/share\/memory\/heap.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -792,0 +792,3 @@\n+\/\/ This version of Metaspace::allocate does not throw OOM but simply returns NULL, and\n+\/\/ is suitable for calling from non-Java threads.\n+\/\/ Callers are responsible for checking null.\n@@ -793,1 +796,1 @@\n-                              MetaspaceObj::Type type, TRAPS) {\n+                              MetaspaceObj::Type type) {\n@@ -797,6 +800,0 @@\n-  assert(!(DumpSharedSpaces && THREAD->is_VM_thread()), \"sanity\");\n-\n-  if (HAS_PENDING_EXCEPTION) {\n-    assert(false, \"Should not allocate with exception pending\");\n-    return NULL;  \/\/ caller does a CHECK_NULL too\n-  }\n@@ -812,0 +809,22 @@\n+  if (result != NULL) {\n+    \/\/ Zero initialize.\n+    Copy::fill_to_words((HeapWord*)result, word_size, 0);\n+\n+    log_trace(metaspace)(\"Metaspace::allocate: type %d return \" PTR_FORMAT \".\", (int)type, p2i(result));\n+  }\n+\n+  return result;\n+}\n+\n+MetaWord* Metaspace::allocate(ClassLoaderData* loader_data, size_t word_size,\n+                              MetaspaceObj::Type type, TRAPS) {\n+\n+  assert(THREAD->is_Java_thread(), \"can't allocate in non-Java thread because we cannot throw exception\");\n+\n+  if (HAS_PENDING_EXCEPTION) {\n+    assert(false, \"Should not allocate with exception pending\");\n+    return NULL;  \/\/ caller does a CHECK_NULL too\n+  }\n+\n+  MetaWord* result = allocate(loader_data, word_size, type);\n+\n@@ -813,0 +832,1 @@\n+    MetadataType mdtype = (type == MetaspaceObj::ClassType) ? ClassType : NonClassType;\n@@ -822,1 +842,0 @@\n-  }\n@@ -824,5 +843,5 @@\n-  if (result == NULL) {\n-    report_metadata_oome(loader_data, word_size, type, mdtype, THREAD);\n-    assert(HAS_PENDING_EXCEPTION, \"sanity\");\n-    return NULL;\n-  }\n+    if (result == NULL) {\n+      report_metadata_oome(loader_data, word_size, type, mdtype, THREAD);\n+      assert(HAS_PENDING_EXCEPTION, \"sanity\");\n+      return NULL;\n+    }\n@@ -830,2 +849,2 @@\n-  \/\/ Zero initialize.\n-  Copy::fill_to_words((HeapWord*)result, word_size, 0);\n+    \/\/ Zero initialize.\n+    Copy::fill_to_words((HeapWord*)result, word_size, 0);\n@@ -833,1 +852,2 @@\n-  log_trace(metaspace)(\"Metaspace::allocate: type %d return \" PTR_FORMAT \".\", (int)type, p2i(result));\n+    log_trace(metaspace)(\"Metaspace::allocate: type %d return \" PTR_FORMAT \".\", (int)type, p2i(result));\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":36,"deletions":16,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -127,0 +127,5 @@\n+  \/\/ Non-TRAPS version of allocate which can be called by a non-Java thread, that returns\n+  \/\/ NULL on failure.\n+  static MetaWord* allocate(ClassLoaderData* loader_data, size_t word_size,\n+                            MetaspaceObj::Type type);\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -605,6 +605,1 @@\n-  EXCEPTION_MARK;\n-  ClassLoader::initialize_shared_path(THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    java_lang_Throwable::print(PENDING_EXCEPTION, tty);\n-    vm_exit_during_initialization(\"ClassLoader::initialize_shared_path() failed unexpectedly\");\n-  }\n+  ClassLoader::initialize_shared_path(Thread::current());\n@@ -1336,0 +1331,28 @@\n+\/\/ For -XX:PrintSharedArchiveAndExit\n+class CountSharedSymbols : public SymbolClosure {\n+ private:\n+   int _count;\n+ public:\n+   CountSharedSymbols() : _count(0) {}\n+  void do_symbol(Symbol** sym) {\n+    _count++;\n+  }\n+  int total() { return _count; }\n+\n+};\n+\n+\/\/ For -XX:PrintSharedArchiveAndExit\n+class CountSharedStrings : public OopClosure {\n+ private:\n+  int _count;\n+ public:\n+  CountSharedStrings() : _count(0) {}\n+  void do_oop(oop* p) {\n+    _count++;\n+  }\n+  void do_oop(narrowOop* p) {\n+    _count++;\n+  }\n+  int total() { return _count; }\n+};\n+\n@@ -1370,3 +1393,7 @@\n-    if (PrintSharedDictionary) {\n-      tty->print_cr(\"\\nShared classes:\\n\");\n-      SystemDictionaryShared::print_on(tty);\n+    \/\/ Print archive names\n+    if (dynamic_mapinfo != nullptr) {\n+      tty->print_cr(\"\\n\\nBase archive name: %s\", Arguments::GetSharedArchivePath());\n+      tty->print_cr(\"Base archive version %d\", static_mapinfo->version());\n+    } else {\n+      tty->print_cr(\"Static archive name: %s\", static_mapinfo->full_path());\n+      tty->print_cr(\"Static archive version %d\", static_mapinfo->version());\n@@ -1374,0 +1401,16 @@\n+\n+    SystemDictionaryShared::print_shared_archive(tty);\n+    if (dynamic_mapinfo != nullptr) {\n+      tty->print_cr(\"\\n\\nDynamic archive name: %s\", dynamic_mapinfo->full_path());\n+      tty->print_cr(\"Dynamic archive version %d\", dynamic_mapinfo->version());\n+      SystemDictionaryShared::print_shared_archive(tty, false\/*dynamic*\/);\n+    }\n+\n+    \/\/ collect shared symbols and strings\n+    CountSharedSymbols cl;\n+    SymbolTable::shared_symbols_do(&cl);\n+    tty->print_cr(\"Number of shared symbols: %d\", cl.total());\n+    CountSharedStrings cs;\n+    StringTable::shared_oops_do(&cs);\n+    tty->print_cr(\"Number of shared strings: %d\", cs.total());\n+    tty->print_cr(\"VM version: %s\\r\\n\", static_mapinfo->vm_version());\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":52,"deletions":9,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -516,1 +516,1 @@\n-void Universe::reinitialize_vtable_of(Klass* ko, TRAPS) {\n+static void reinitialize_vtable_of(Klass* ko) {\n@@ -518,1 +518,1 @@\n-  ko->vtable().initialize_vtable(false, CHECK);\n+  ko->vtable().initialize_vtable();\n@@ -523,1 +523,1 @@\n-      reinitialize_vtable_of(sk, CHECK);\n+      reinitialize_vtable_of(sk);\n@@ -528,1 +528,1 @@\n-void Universe::reinitialize_vtables(TRAPS) {\n+static void reinitialize_vtables() {\n@@ -533,1 +533,1 @@\n-  Universe::reinitialize_vtable_of(ok, THREAD);\n+  reinitialize_vtable_of(ok);\n@@ -537,2 +537,2 @@\n-void initialize_itable_for_klass(InstanceKlass* k, TRAPS) {\n-  k->itable().initialize_itable(false, CHECK);\n+static void initialize_itable_for_klass(InstanceKlass* k) {\n+  k->itable().initialize_itable();\n@@ -542,3 +542,3 @@\n-void Universe::reinitialize_itables(TRAPS) {\n-  MutexLocker mcld(THREAD, ClassLoaderDataGraph_lock);\n-  ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass, CHECK);\n+static void reinitialize_itables() {\n+  MutexLocker mcld(ClassLoaderDataGraph_lock);\n+  ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass);\n@@ -719,0 +719,4 @@\n+bool Universe::contains_non_oop_word(void* p) {\n+  return *(void**)p == non_oop_word();\n+}\n+\n@@ -945,3 +949,2 @@\n-    ResourceMark rm;\n-    Universe::reinitialize_vtables(CHECK_false);\n-    Universe::reinitialize_itables(CHECK_false);\n+    reinitialize_vtables();\n+    reinitialize_itables();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -175,3 +175,0 @@\n-  static void reinitialize_vtable_of(Klass* k, TRAPS);\n-  static void reinitialize_vtables(TRAPS);\n-  static void reinitialize_itables(TRAPS);\n@@ -370,1 +367,2 @@\n-  static void*   non_oop_word();\n+  static void*         non_oop_word();\n+  static bool contains_non_oop_word(void* p);\n","filename":"src\/hotspot\/share\/memory\/universe.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  k->vtable().initialize_vtable(false, CHECK);\n+  k->vtable().initialize_vtable();\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -987,1 +987,1 @@\n-      if (is_shared() && SystemDictionaryShared::check_linking_constraints(this, THREAD)) {\n+      if (is_shared() && SystemDictionaryShared::check_linking_constraints(THREAD, this)) {\n@@ -991,2 +991,2 @@\n-        vtable().initialize_vtable(true, CHECK_false);\n-        itable().initialize_itable(true, CHECK_false);\n+        vtable().initialize_vtable_and_check_constraints(CHECK_false);\n+        itable().initialize_itable_and_check_constraints(CHECK_false);\n@@ -2602,2 +2602,2 @@\n-    vtable().initialize_vtable(false, CHECK);\n-    itable().initialize_itable(false, CHECK);\n+    vtable().initialize_vtable();\n+    itable().initialize_itable();\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -71,2 +71,1 @@\n-    Handle classloader, Symbol* classname, Array<InstanceKlass*>* local_interfaces,\n-    TRAPS) {\n+    Handle classloader, Symbol* classname, Array<InstanceKlass*>* local_interfaces) {\n@@ -163,1 +162,1 @@\n-void klassVtable::initialize_vtable(bool checkconstraints, TRAPS) {\n+void klassVtable::initialize_vtable(GrowableArray<InstanceKlass*>* supers) {\n@@ -169,0 +168,1 @@\n+  Thread* current = Thread::current();\n@@ -171,1 +171,1 @@\n-    ResourceMark rm(THREAD);\n+    ResourceMark rm(current);\n@@ -202,1 +202,1 @@\n-      methodHandle mh(THREAD, methods->at(i));\n+      methodHandle mh(current, methods->at(i));\n@@ -204,1 +204,1 @@\n-      bool needs_new_entry = update_inherited_vtable(mh, super_vtable_len, -1, checkconstraints, CHECK);\n+      bool needs_new_entry = update_inherited_vtable(current, mh, super_vtable_len, -1, supers);\n@@ -218,7 +218,3 @@\n-        Array<int>* def_vtable_indices = NULL;\n-        if ((def_vtable_indices = ik()->default_vtable_indices()) == NULL) {\n-          assert(!is_shared, \"shared class def_vtable_indices does not exist\");\n-          def_vtable_indices = ik()->create_new_default_vtable_indices(len, CHECK);\n-        } else {\n-          assert(def_vtable_indices->length() == len, \"reinit vtable len?\");\n-        }\n+        Array<int>* def_vtable_indices = ik()->default_vtable_indices();\n+        assert(def_vtable_indices != NULL, \"should be created\");\n+        assert(def_vtable_indices->length() == len, \"reinit vtable len?\");\n@@ -231,1 +227,1 @@\n-            methodHandle mh(THREAD, default_methods->at(i));\n+            methodHandle mh(current, default_methods->at(i));\n@@ -233,1 +229,1 @@\n-            needs_new_entry = update_inherited_vtable(mh, super_vtable_len, i, checkconstraints, CHECK);\n+            needs_new_entry = update_inherited_vtable(current, mh, super_vtable_len, i, supers);\n@@ -261,1 +257,1 @@\n-      initialized = fill_in_mirandas(initialized, THREAD);\n+      initialized = fill_in_mirandas(current, initialized);\n@@ -361,2 +357,1 @@\n-                        Klass* target_klass, Method* super_method,\n-                        Thread* thread) {\n+                        Klass* target_klass, Method* super_method) {\n@@ -365,1 +360,1 @@\n-    ResourceMark rm(thread);\n+    ResourceMark rm;\n@@ -388,1 +383,2 @@\n-bool klassVtable::update_inherited_vtable(const methodHandle& target_method,\n+bool klassVtable::update_inherited_vtable(Thread* current,\n+                                          const methodHandle& target_method,\n@@ -390,2 +386,1 @@\n-                                          bool checkconstraints, TRAPS) {\n-  ResourceMark rm(THREAD);\n+                                          GrowableArray<InstanceKlass*>* supers) {\n@@ -464,2 +459,2 @@\n-  HandleMark hm(THREAD);\n-  Handle target_loader(THREAD, target_klass->class_loader());\n+  HandleMark hm(current);\n+  Handle target_loader(current, target_klass->class_loader());\n@@ -511,36 +506,3 @@\n-\n-        \/\/ Do not check loader constraints for overpass methods because overpass\n-        \/\/ methods are created by the jvm to throw exceptions.\n-        if (checkconstraints && !target_method->is_overpass()) {\n-          \/\/ Override vtable entry if passes loader constraint check\n-          \/\/ if loader constraint checking requested\n-          \/\/ No need to visit his super, since he and his super\n-          \/\/ have already made any needed loader constraints.\n-          \/\/ Since loader constraints are transitive, it is enough\n-          \/\/ to link to the first super, and we get all the others.\n-          Handle super_loader(THREAD, super_klass->class_loader());\n-\n-          if (target_loader() != super_loader()) {\n-            ResourceMark rm(THREAD);\n-            Symbol* failed_type_symbol =\n-              SystemDictionary::check_signature_loaders(signature, _klass,\n-                                                        target_loader, super_loader,\n-                                                        true, CHECK_(false));\n-            if (failed_type_symbol != NULL) {\n-              stringStream ss;\n-              ss.print(\"loader constraint violation for class %s: when selecting \"\n-                       \"overriding method '\", klass->external_name());\n-              target_method->print_external_name(&ss),\n-              ss.print(\"' the class loader %s of the \"\n-                       \"selected method's type %s, and the class loader %s for its super \"\n-                       \"type %s have different Class objects for the type %s used in the signature (%s; %s)\",\n-                       target_klass->class_loader_data()->loader_name_and_id(),\n-                       target_klass->external_name(),\n-                       super_klass->class_loader_data()->loader_name_and_id(),\n-                       super_klass->external_name(),\n-                       failed_type_symbol->as_klass_external_name(),\n-                       target_klass->class_in_module_of_loader(false, true),\n-                       super_klass->class_in_module_of_loader(false, true));\n-              THROW_MSG_(vmSymbols::java_lang_LinkageError(), ss.as_string(), false);\n-            }\n-          }\n+        \/\/ Save super for constraint checking.\n+        if (supers != NULL) {\n+          supers->at_put(i, super_klass);\n@@ -570,1 +532,1 @@\n-      log_vtables(i, overrides, target_method, target_klass, super_method, THREAD);\n+      log_vtables(i, overrides, target_method, target_klass, super_method);\n@@ -602,0 +564,60 @@\n+void klassVtable::check_constraints(GrowableArray<InstanceKlass*>* supers, TRAPS) {\n+  assert(supers->length() == length(), \"lengths are different\");\n+  \/\/ For each method in the vtable, check constraints against any super class\n+  \/\/ if overridden.\n+  for (int i = 0; i < length(); i++) {\n+    methodHandle target_method(THREAD, unchecked_method_at(i));\n+    InstanceKlass* super_klass = supers->at(i);\n+    if (target_method() != NULL && super_klass != NULL) {\n+      \/\/ Do not check loader constraints for overpass methods because overpass\n+      \/\/ methods are created by the jvm to throw exceptions.\n+      if (!target_method->is_overpass()) {\n+        \/\/ Override vtable entry if passes loader constraint check\n+        \/\/ if loader constraint checking requested\n+        \/\/ No need to visit his super, since he and his super\n+        \/\/ have already made any needed loader constraints.\n+        \/\/ Since loader constraints are transitive, it is enough\n+        \/\/ to link to the first super, and we get all the others.\n+        Handle super_loader(THREAD, super_klass->class_loader());\n+        InstanceKlass* target_klass = target_method->method_holder();\n+        Handle target_loader(THREAD, target_klass->class_loader());\n+\n+        if (target_loader() != super_loader()) {\n+          ResourceMark rm(THREAD);\n+          Symbol* failed_type_symbol =\n+            SystemDictionary::check_signature_loaders(target_method->signature(),\n+                                                      _klass,\n+                                                      target_loader, super_loader,\n+                                                      true);\n+          if (failed_type_symbol != NULL) {\n+            stringStream ss;\n+            ss.print(\"loader constraint violation for class %s: when selecting \"\n+                     \"overriding method '\", _klass->external_name());\n+            target_method->print_external_name(&ss),\n+            ss.print(\"' the class loader %s of the \"\n+                     \"selected method's type %s, and the class loader %s for its super \"\n+                     \"type %s have different Class objects for the type %s used in the signature (%s; %s)\",\n+                     target_klass->class_loader_data()->loader_name_and_id(),\n+                     target_klass->external_name(),\n+                     super_klass->class_loader_data()->loader_name_and_id(),\n+                     super_klass->external_name(),\n+                     failed_type_symbol->as_klass_external_name(),\n+                     target_klass->class_in_module_of_loader(false, true),\n+                     super_klass->class_in_module_of_loader(false, true));\n+            THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void klassVtable::initialize_vtable_and_check_constraints(TRAPS) {\n+  \/\/ Save a superclass from each vtable entry to do constraint checking\n+  ResourceMark rm(THREAD);\n+  GrowableArray<InstanceKlass*>* supers = new GrowableArray<InstanceKlass*>(_length, _length, NULL);\n+  initialize_vtable(supers);\n+  check_constraints(supers, CHECK);\n+}\n+\n+\n@@ -940,2 +962,2 @@\n-int klassVtable::fill_in_mirandas(int initialized, TRAPS) {\n-  ResourceMark rm(THREAD);\n+int klassVtable::fill_in_mirandas(Thread* current, int initialized) {\n+  ResourceMark rm(current);\n@@ -1111,1 +1133,1 @@\n-void klassItable::initialize_itable(bool checkconstraints, TRAPS) {\n+void klassItable::initialize_itable(GrowableArray<Method*>* supers) {\n@@ -1115,1 +1137,1 @@\n-    assign_itable_indices_for_interface(InstanceKlass::cast(_klass), THREAD);\n+    assign_itable_indices_for_interface(InstanceKlass::cast(_klass));\n@@ -1128,2 +1150,3 @@\n-    ResourceMark rm(THREAD);\n-    log_develop_debug(itables)(\"%3d: Initializing itables for %s\", ++initialize_count,\n+    if (log_develop_is_enabled(Debug, itables)) {\n+      ResourceMark rm;\n+      log_develop_debug(itables)(\"%3d: Initializing itables for %s\", ++initialize_count,\n@@ -1131,1 +1154,1 @@\n-\n+    }\n@@ -1134,2 +1157,1 @@\n-    int i;\n-    for(i = 0; i < num_interfaces; i++) {\n+    for(int i = 0; i < num_interfaces; i++) {\n@@ -1137,1 +1159,0 @@\n-      HandleMark hm(THREAD);\n@@ -1140,1 +1161,2 @@\n-      initialize_itable_for_interface(ioe->offset(), interf, checkconstraints, CHECK);\n+      initialize_itable_for_interface(ioe->offset(), interf, supers,\n+                       (ioe->offset() - offset_entry(0)->offset())\/wordSize);\n@@ -1142,1 +1164,0 @@\n-\n@@ -1149,0 +1170,56 @@\n+void klassItable::check_constraints(GrowableArray<Method*>* supers, TRAPS) {\n+\n+  assert(_size_method_table == supers->length(), \"wrong size\");\n+  itableMethodEntry* ime = method_entry(0);\n+  for (int i = 0; i < _size_method_table; i++) {\n+    Method* target = ime->method();\n+    Method* interface_method = supers->at(i); \/\/ method overridden\n+\n+    if (target != NULL && interface_method != NULL) {\n+      InstanceKlass* method_holder = target->method_holder();\n+      InstanceKlass* interf = interface_method->method_holder();\n+      HandleMark hm(THREAD);\n+      Handle method_holder_loader(THREAD, method_holder->class_loader());\n+      Handle interface_loader(THREAD, interf->class_loader());\n+\n+      if (method_holder_loader() != interface_loader()) {\n+        ResourceMark rm(THREAD);\n+        Symbol* failed_type_symbol =\n+          SystemDictionary::check_signature_loaders(target->signature(),\n+                                                    _klass,\n+                                                    method_holder_loader,\n+                                                    interface_loader,\n+                                                    true);\n+        if (failed_type_symbol != NULL) {\n+          stringStream ss;\n+          ss.print(\"loader constraint violation in interface itable\"\n+                   \" initialization for class %s: when selecting method '\",\n+                   _klass->external_name());\n+          interface_method->print_external_name(&ss),\n+          ss.print(\"' the class loader %s for super interface %s, and the class\"\n+                   \" loader %s of the selected method's %s, %s have\"\n+                   \" different Class objects for the type %s used in the signature (%s; %s)\",\n+                   interf->class_loader_data()->loader_name_and_id(),\n+                   interf->external_name(),\n+                   method_holder->class_loader_data()->loader_name_and_id(),\n+                   method_holder->external_kind(),\n+                   method_holder->external_name(),\n+                   failed_type_symbol->as_klass_external_name(),\n+                   interf->class_in_module_of_loader(false, true),\n+                   method_holder->class_in_module_of_loader(false, true));\n+          THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n+        }\n+      }\n+    }\n+    ime++;\n+  }\n+}\n+\n+void klassItable::initialize_itable_and_check_constraints(TRAPS) {\n+  \/\/ Save a super interface from each itable entry to do constraint checking\n+  ResourceMark rm(THREAD);\n+  GrowableArray<Method*>* supers =\n+    new GrowableArray<Method*>(_size_method_table, _size_method_table, NULL);\n+  initialize_itable(supers);\n+  check_constraints(supers, CHECK);\n+}\n@@ -1161,1 +1238,1 @@\n-int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS) {\n+int klassItable::assign_itable_indices_for_interface(InstanceKlass* klass) {\n@@ -1163,3 +1240,6 @@\n-  ResourceMark rm(THREAD);\n-  log_develop_debug(itables)(\"%3d: Initializing itable indices for interface %s\",\n-                             ++initialize_count, klass->name()->as_C_string());\n+  if (log_develop_is_enabled(Trace, itables)) {\n+    ResourceMark rm;\n+    log_develop_debug(itables)(\"%3d: Initializing itable indices for interface %s\",\n+                               ++initialize_count, klass->name()->as_C_string());\n+  }\n+\n@@ -1175,0 +1255,1 @@\n+        ResourceMark rm;\n@@ -1229,1 +1310,3 @@\n-void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf, bool checkconstraints, TRAPS) {\n+void klassItable::initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf,\n+                                                  GrowableArray<Method*>* supers,\n+                                                  int start_offset) {\n@@ -1233,2 +1316,0 @@\n-  HandleMark hm(THREAD);\n-  Handle interface_loader (THREAD, interf->class_loader());\n@@ -1260,34 +1341,0 @@\n-      \/\/ Entry did resolve, check loader constraints before initializing\n-      \/\/ if checkconstraints requested\n-      if (checkconstraints) {\n-        Handle method_holder_loader (THREAD, target->method_holder()->class_loader());\n-        InstanceKlass* method_holder = target->method_holder();\n-        if (method_holder_loader() != interface_loader()) {\n-          ResourceMark rm(THREAD);\n-          Symbol* failed_type_symbol =\n-            SystemDictionary::check_signature_loaders(m->signature(),\n-                                                      _klass,\n-                                                      method_holder_loader,\n-                                                      interface_loader,\n-                                                      true, CHECK);\n-          if (failed_type_symbol != NULL) {\n-            stringStream ss;\n-            ss.print(\"loader constraint violation in interface itable\"\n-                     \" initialization for class %s: when selecting method '\",\n-                     _klass->external_name());\n-            m->print_external_name(&ss),\n-            ss.print(\"' the class loader %s for super interface %s, and the class\"\n-                     \" loader %s of the selected method's %s, %s have\"\n-                     \" different Class objects for the type %s used in the signature (%s; %s)\",\n-                     interf->class_loader_data()->loader_name_and_id(),\n-                     interf->external_name(),\n-                     method_holder->class_loader_data()->loader_name_and_id(),\n-                     method_holder->external_kind(),\n-                     method_holder->external_name(),\n-                     failed_type_symbol->as_klass_external_name(),\n-                     interf->class_in_module_of_loader(false, true),\n-                     method_holder->class_in_module_of_loader(false, true));\n-            THROW_MSG(vmSymbols::java_lang_LinkageError(), ss.as_string());\n-          }\n-        }\n-      }\n@@ -1295,1 +1342,0 @@\n-      \/\/ ime may have moved during GC so recalculate address\n@@ -1298,0 +1344,7 @@\n+\n+      \/\/ Save super interface method to perform constraint checks.\n+      \/\/ The method is in the error message, that's why.\n+      if (supers != NULL) {\n+        supers->at_put(start_offset + ime_num, m);\n+      }\n+\n@@ -1300,1 +1353,1 @@\n-        ResourceMark rm(THREAD);\n+        ResourceMark rm;\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":169,"deletions":116,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,2 @@\n+  void check_constraints(GrowableArray<InstanceKlass*>* supers, TRAPS);\n+\n@@ -66,1 +68,3 @@\n-  void initialize_vtable(bool checkconstraints, TRAPS);   \/\/ initialize vtable of a new klass\n+  \/\/ initialize vtable of a new klass\n+  void initialize_vtable(GrowableArray<InstanceKlass*>* supers = NULL);\n+  void initialize_vtable_and_check_constraints(TRAPS);\n@@ -78,2 +82,1 @@\n-                                                   Array<InstanceKlass*>* local_interfaces,\n-                                                   TRAPS);\n+                                                   Array<InstanceKlass*>* local_interfaces);\n@@ -119,1 +122,2 @@\n-  bool update_inherited_vtable(const methodHandle& target_method,\n+  bool update_inherited_vtable(Thread* current,\n+                               const methodHandle& target_method,\n@@ -122,1 +126,1 @@\n-                               bool checkconstraints, TRAPS);\n+                               GrowableArray<InstanceKlass*>* supers);\n@@ -129,1 +133,1 @@\n-  int fill_in_mirandas(int initialized, TRAPS);\n+  int fill_in_mirandas(Thread* current, int initialized);\n@@ -282,1 +286,3 @@\n-  void initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf_h, bool checkconstraints, TRAPS);\n+  void initialize_itable_for_interface(int method_table_offset, InstanceKlass* interf_h,\n+                                       GrowableArray<Method*>* supers, int start_offset);\n+  void check_constraints(GrowableArray<Method*>* supers, TRAPS);\n@@ -295,1 +301,2 @@\n-  void initialize_itable(bool checkconstraints, TRAPS);\n+  void initialize_itable_and_check_constraints(TRAPS);\n+  void initialize_itable(GrowableArray<Method*>* supers = NULL);\n@@ -310,1 +317,1 @@\n-  static int assign_itable_indices_for_interface(InstanceKlass* klass, TRAPS);\n+  static int assign_itable_indices_for_interface(InstanceKlass* klass);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -560,1 +560,1 @@\n-MethodCounters* Method::build_method_counters(Method* m, TRAPS) {\n+MethodCounters* Method::build_method_counters(Thread* current, Method* m) {\n@@ -566,3 +566,17 @@\n-  methodHandle mh(THREAD, m);\n-  MethodCounters* counters = MethodCounters::allocate(mh, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n+  methodHandle mh(current, m);\n+  MethodCounters* counters;\n+  if (current->is_Java_thread()) {\n+    Thread* THREAD = current;\n+    \/\/ Use the TRAPS version for a JavaThread so it will adjust the GC threshold\n+    \/\/ if needed.\n+    counters = MethodCounters::allocate_with_exception(mh, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      CLEAR_PENDING_EXCEPTION;\n+    }\n+  } else {\n+    \/\/ Call metaspace allocation that doesn't throw exception if the\n+    \/\/ current thread isn't a JavaThread, ie. the VMThread.\n+    counters = MethodCounters::allocate_no_exception(mh);\n+  }\n+\n+  if (counters == NULL) {\n@@ -571,1 +585,1 @@\n-    return NULL;   \/\/ return the exception (which is cleared)\n+    return NULL;\n@@ -573,0 +587,1 @@\n+\n@@ -578,1 +593,1 @@\n-    mh->log_touched(CHECK_NULL);\n+    mh->log_touched(current);\n@@ -2377,1 +2392,1 @@\n-void Method::log_touched(TRAPS) {\n+void Method::log_touched(Thread* current) {\n@@ -2389,1 +2404,1 @@\n-  MutexLocker ml(THREAD, TouchedMethodLog_lock);\n+  MutexLocker ml(current, TouchedMethodLog_lock);\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":23,"deletions":8,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  u2   number_of_breakpoints()             const {\n+  u2   number_of_breakpoints() const {\n@@ -239,2 +239,2 @@\n-  void incr_number_of_breakpoints(TRAPS)         {\n-    MethodCounters* mcs = get_method_counters(CHECK);\n+  void incr_number_of_breakpoints(Thread* current) {\n+    MethodCounters* mcs = get_method_counters(current);\n@@ -245,2 +245,2 @@\n-  void decr_number_of_breakpoints(TRAPS)         {\n-    MethodCounters* mcs = get_method_counters(CHECK);\n+  void decr_number_of_breakpoints(Thread* current) {\n+    MethodCounters* mcs = get_method_counters(current);\n@@ -252,1 +252,1 @@\n-  void clear_number_of_breakpoints()             {\n+  void clear_number_of_breakpoints() {\n@@ -295,2 +295,2 @@\n-  void interpreter_throwout_increment(TRAPS) {\n-    MethodCounters* mcs = get_method_counters(CHECK);\n+  void interpreter_throwout_increment(Thread* current) {\n+    MethodCounters* mcs = get_method_counters(current);\n@@ -435,1 +435,1 @@\n-  static MethodCounters* build_method_counters(Method* m, TRAPS);\n+  static MethodCounters* build_method_counters(Thread* current, Method* m);\n@@ -947,1 +947,1 @@\n-  MethodCounters* get_method_counters(TRAPS) {\n+  MethodCounters* get_method_counters(Thread* current) {\n@@ -949,1 +949,1 @@\n-      build_method_counters(this, CHECK_AND_CLEAR_NULL);\n+      build_method_counters(current, this);\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -58,1 +58,6 @@\n-MethodCounters* MethodCounters::allocate(const methodHandle& mh, TRAPS) {\n+MethodCounters* MethodCounters::allocate_no_exception(const methodHandle& mh) {\n+  ClassLoaderData* loader_data = mh->method_holder()->class_loader_data();\n+  return new(loader_data, method_counters_size(), MetaspaceObj::MethodCountersType) MethodCounters(mh);\n+}\n+\n+MethodCounters* MethodCounters::allocate_with_exception(const methodHandle& mh, TRAPS) {\n","filename":"src\/hotspot\/share\/oops\/methodCounters.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -72,1 +72,2 @@\n-  static MethodCounters* allocate(const methodHandle& mh, TRAPS);\n+  static MethodCounters* allocate_no_exception(const methodHandle& mh);\n+  static MethodCounters* allocate_with_exception(const methodHandle& mh, TRAPS);\n","filename":"src\/hotspot\/share\/oops\/methodCounters.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -323,2 +323,1 @@\n-    ResourceMark rm;\n-    JavaThread *jt = THREAD->as_Java_thread();\n+    ResourceMark rm(THREAD);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,2 +103,2 @@\n-  bool operator==(nullptr_t) const     { return _o == nullptr; }\n-  bool operator!=(nullptr_t) const     { return _o != nullptr; }\n+  bool operator==(std::nullptr_t) const     { return _o == nullptr; }\n+  bool operator!=(std::nullptr_t) const     { return _o != nullptr; }\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-    if (!Matcher::has_match_rule(Op_StrCompressedCopy)) return false;\n+    if (!Matcher::match_rule_supported(Op_StrCompressedCopy)) return false;\n@@ -186,1 +186,1 @@\n-    if (!Matcher::has_match_rule(Op_StrInflatedCopy)) return false;\n+    if (!Matcher::match_rule_supported(Op_StrInflatedCopy)) return false;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -243,3 +243,2 @@\n-static Node* find_or_make_CastII(PhaseIterGVN* igvn, Node* parent, Node* control,\n-                                 const TypeInt* type) {\n-  Node* n = new CastIINode(parent, type);\n+static Node* find_or_make_CastII(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInt* type, bool carry_dependency) {\n+  Node* n = new CastIINode(parent, type, carry_dependency);\n@@ -278,2 +277,2 @@\n-    Node* cx = find_or_make_CastII(igvn, x, in(0), rx->is_int());\n-    Node* cy = find_or_make_CastII(igvn, y, in(0), ry->is_int());\n+    Node* cx = find_or_make_CastII(igvn, x, in(0), rx->is_int(), _carry_dependency);\n+    Node* cy = find_or_make_CastII(igvn, y, in(0), ry->is_int(), _carry_dependency);\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2757,1 +2757,0 @@\n-    print_method(PHASE_AFTER_MATCHING, 3);\n@@ -4689,1 +4688,1 @@\n-void Compile::print_method(CompilerPhaseType cpt, const char *name, int level, int idx) {\n+void Compile::print_method(CompilerPhaseType cpt, const char *name, int level) {\n@@ -4711,1 +4710,1 @@\n-  print_method(cpt, output, level, idx);\n+  print_method(cpt, output, level);\n@@ -4777,1 +4776,1 @@\n-  Compile::current()->print_method(PHASE_DEBUG, 0, 0);\n+  Compile::current()->print_method(PHASE_DEBUG, 0);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -646,1 +646,1 @@\n-  void print_method(CompilerPhaseType cpt, const char *name, int level = 1, int idx = 0);\n+  void print_method(CompilerPhaseType cpt, const char *name, int level = 1);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4213,1 +4213,1 @@\n-  Node* res_mem = _gvn.transform(new SCMemProjNode(str));\n+  Node* res_mem = _gvn.transform(new SCMemProjNode(_gvn.transform(str)));\n@@ -4235,0 +4235,2 @@\n+  C->set_has_loops(true);\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1275,1 +1275,1 @@\n-  AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(dst);\n@@ -1392,1 +1392,2 @@\n-    AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy, NULL);\n+    AllocateArrayNode* alloc = tightly_coupled_allocation(newcopy);\n+    guarantee(alloc != NULL, \"created above\");\n@@ -1410,19 +1411,7 @@\n-    if (alloc != NULL) {\n-      if (alloc->maybe_set_complete(&_gvn)) {\n-        \/\/ \"You break it, you buy it.\"\n-        InitializeNode* init = alloc->initialization();\n-        assert(init->is_complete(), \"we just did this\");\n-        init->set_complete_with_arraycopy();\n-        assert(newcopy->is_CheckCastPP(), \"sanity\");\n-        assert(newcopy->in(0)->in(0) == init, \"dest pinned\");\n-      }\n-      \/\/ Do not let stores that initialize this object be reordered with\n-      \/\/ a subsequent store that would make this object accessible by\n-      \/\/ other threads.\n-      \/\/ Record what AllocateNode this StoreStore protects so that\n-      \/\/ escape analysis can go from the MemBarStoreStoreNode to the\n-      \/\/ AllocateNode and eliminate the MemBarStoreStoreNode if possible\n-      \/\/ based on the escape status of the AllocateNode.\n-      insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n-    } else {\n-      insert_mem_bar(Op_MemBarCPUOrder);\n+    if (alloc->maybe_set_complete(&_gvn)) {\n+      \/\/ \"You break it, you buy it.\"\n+      InitializeNode* init = alloc->initialization();\n+      assert(init->is_complete(), \"we just did this\");\n+      init->set_complete_with_arraycopy();\n+      assert(newcopy->is_CheckCastPP(), \"sanity\");\n+      assert(newcopy->in(0)->in(0) == init, \"dest pinned\");\n@@ -1430,0 +1419,8 @@\n+    \/\/ Do not let stores that initialize this object be reordered with\n+    \/\/ a subsequent store that would make this object accessible by\n+    \/\/ other threads.\n+    \/\/ Record what AllocateNode this StoreStore protects so that\n+    \/\/ escape analysis can go from the MemBarStoreStoreNode to the\n+    \/\/ AllocateNode and eliminate the MemBarStoreStoreNode if possible\n+    \/\/ based on the escape status of the AllocateNode.\n+    insert_mem_bar(Op_MemBarStoreStore, alloc->proj_out_or_null(AllocateNode::RawAddress));\n@@ -1457,1 +1454,1 @@\n-  AllocateArrayNode* alloc = tightly_coupled_allocation(dst, NULL);\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(dst);\n@@ -4398,1 +4395,1 @@\n-  AllocateArrayNode* alloc = tightly_coupled_allocation(dest, NULL);\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(dest);\n@@ -4434,1 +4431,1 @@\n-    alloc = tightly_coupled_allocation(dest, NULL);\n+    alloc = tightly_coupled_allocation(dest);\n@@ -4647,2 +4644,1 @@\n-LibraryCallKit::tightly_coupled_allocation(Node* ptr,\n-                                           RegionNode* slow_region) {\n+LibraryCallKit::tightly_coupled_allocation(Node* ptr) {\n@@ -4686,4 +4682,0 @@\n-      if (slow_region != NULL && slow_region->find_edge(not_ctl) >= 1) {\n-        ctl = iff->in(0);       \/\/ This test feeds the known slow_region.\n-        continue;\n-      }\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":22,"deletions":30,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -254,2 +254,1 @@\n-  AllocateArrayNode* tightly_coupled_allocation(Node* ptr,\n-                                                RegionNode* slow_region);\n+  AllocateArrayNode* tightly_coupled_allocation(Node* ptr);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1810,1 +1810,1 @@\n-              assert(n->in(0) == be, \"should be on the backedge\");\n+              assert(n->in(0) == be || n->find_prec_edge(be) > 0, \"should be on the backedge\");\n@@ -5045,1 +5045,2 @@\n-              if ((worklist.member(in) || in == mem) && is_dominator(early, r_in)) {\n+              \/\/ We can't reach any node from a Phi because we don't enqueue Phi's uses above\n+              if (((worklist.member(in) && !in->is_Phi()) || in == mem) && is_dominator(early, r_in)) {\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -159,55 +159,0 @@\n-void PhaseMacroExpand::extract_call_projections(CallNode *call) {\n-  _fallthroughproj = NULL;\n-  _fallthroughcatchproj = NULL;\n-  _ioproj_fallthrough = NULL;\n-  _ioproj_catchall = NULL;\n-  _catchallcatchproj = NULL;\n-  _memproj_fallthrough = NULL;\n-  _memproj_catchall = NULL;\n-  _resproj = NULL;\n-  for (DUIterator_Fast imax, i = call->fast_outs(imax); i < imax; i++) {\n-    ProjNode *pn = call->fast_out(i)->as_Proj();\n-    switch (pn->_con) {\n-      case TypeFunc::Control:\n-      {\n-        \/\/ For Control (fallthrough) and I_O (catch_all_index) we have CatchProj -> Catch -> Proj\n-        _fallthroughproj = pn;\n-        DUIterator_Fast jmax, j = pn->fast_outs(jmax);\n-        const Node *cn = pn->fast_out(j);\n-        if (cn->is_Catch()) {\n-          ProjNode *cpn = NULL;\n-          for (DUIterator_Fast kmax, k = cn->fast_outs(kmax); k < kmax; k++) {\n-            cpn = cn->fast_out(k)->as_Proj();\n-            assert(cpn->is_CatchProj(), \"must be a CatchProjNode\");\n-            if (cpn->_con == CatchProjNode::fall_through_index)\n-              _fallthroughcatchproj = cpn;\n-            else {\n-              assert(cpn->_con == CatchProjNode::catch_all_index, \"must be correct index.\");\n-              _catchallcatchproj = cpn;\n-            }\n-          }\n-        }\n-        break;\n-      }\n-      case TypeFunc::I_O:\n-        if (pn->_is_io_use)\n-          _ioproj_catchall = pn;\n-        else\n-          _ioproj_fallthrough = pn;\n-        break;\n-      case TypeFunc::Memory:\n-        if (pn->_is_io_use)\n-          _memproj_catchall = pn;\n-        else\n-          _memproj_fallthrough = pn;\n-        break;\n-      case TypeFunc::Parms:\n-        _resproj = pn;\n-        break;\n-      default:\n-        assert(false, \"unexpected projection from allocation node.\");\n-    }\n-  }\n-\n-}\n-\n@@ -254,0 +199,3 @@\n+#ifdef ASSERT\n+        in->dump();\n+        mem->dump();\n@@ -255,0 +203,1 @@\n+#endif\n@@ -265,1 +214,1 @@\n-        if (adr_offset == offset && adr_iid == alloc->_idx)\n+        if (adr_offset == offset && adr_iid == alloc->_idx) {\n@@ -267,0 +216,1 @@\n+        }\n@@ -280,1 +230,1 @@\n-        if (init != NULL)\n+        if (init != NULL) {\n@@ -282,1 +232,1 @@\n-        else\n+        } else {\n@@ -284,0 +234,1 @@\n+        }\n@@ -478,2 +429,1 @@\n-#ifdef ASSERT\n-        val->dump();\n+        DEBUG_ONLY( val->dump(); )\n@@ -481,1 +431,0 @@\n-#endif\n@@ -558,0 +507,1 @@\n+      DEBUG_ONLY( mem->dump(); )\n@@ -995,1 +945,1 @@\n-  if (_resproj != NULL && _resproj->outcnt() != 0) {\n+  if (_callprojs.resproj != NULL && _callprojs.resproj->outcnt() != 0) {\n@@ -999,2 +949,2 @@\n-    for (DUIterator_Fast jmax, j = _resproj->fast_outs(jmax);  j < jmax; j++) {\n-      Node *use = _resproj->fast_out(j);\n+    for (DUIterator_Fast jmax, j = _callprojs.resproj->fast_outs(jmax);  j < jmax; j++) {\n+      Node* use = _callprojs.resproj->fast_out(j);\n@@ -1007,3 +957,3 @@\n-    for (DUIterator_Last jmin, j = _resproj->last_outs(jmin); j >= jmin; ) {\n-      Node *use = _resproj->last_out(j);\n-      uint oc1 = _resproj->outcnt();\n+    for (DUIterator_Last jmin, j = _callprojs.resproj->last_outs(jmin); j >= jmin; ) {\n+      Node* use = _callprojs.resproj->last_out(j);\n+      uint oc1 = _callprojs.resproj->outcnt();\n@@ -1019,1 +969,1 @@\n-          assert(tmp == _fallthroughcatchproj, \"allocation control projection\");\n+          assert(tmp == _callprojs.fallthrough_catchproj, \"allocation control projection\");\n@@ -1027,1 +977,1 @@\n-            assert(mem->in(TypeFunc::Memory) == _memproj_fallthrough, \"allocation memory projection\");\n+            assert(mem->in(TypeFunc::Memory) == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n@@ -1029,1 +979,1 @@\n-            assert(mem == _memproj_fallthrough, \"allocation memory projection\");\n+            assert(mem == _callprojs.fallthrough_memproj, \"allocation memory projection\");\n@@ -1037,1 +987,1 @@\n-      j -= (oc1 - _resproj->outcnt());\n+      j -= (oc1 - _callprojs.resproj->outcnt());\n@@ -1040,2 +990,2 @@\n-  if (_fallthroughcatchproj != NULL) {\n-    _igvn.replace_node(_fallthroughcatchproj, alloc->in(TypeFunc::Control));\n+  if (_callprojs.fallthrough_catchproj != NULL) {\n+    _igvn.replace_node(_callprojs.fallthrough_catchproj, alloc->in(TypeFunc::Control));\n@@ -1043,2 +993,2 @@\n-  if (_memproj_fallthrough != NULL) {\n-    _igvn.replace_node(_memproj_fallthrough, alloc->in(TypeFunc::Memory));\n+  if (_callprojs.fallthrough_memproj != NULL) {\n+    _igvn.replace_node(_callprojs.fallthrough_memproj, alloc->in(TypeFunc::Memory));\n@@ -1046,2 +996,2 @@\n-  if (_memproj_catchall != NULL) {\n-    _igvn.replace_node(_memproj_catchall, C->top());\n+  if (_callprojs.catchall_memproj != NULL) {\n+    _igvn.replace_node(_callprojs.catchall_memproj, C->top());\n@@ -1049,2 +999,2 @@\n-  if (_ioproj_fallthrough != NULL) {\n-    _igvn.replace_node(_ioproj_fallthrough, alloc->in(TypeFunc::I_O));\n+  if (_callprojs.fallthrough_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs.fallthrough_ioproj, alloc->in(TypeFunc::I_O));\n@@ -1052,2 +1002,2 @@\n-  if (_ioproj_catchall != NULL) {\n-    _igvn.replace_node(_ioproj_catchall, C->top());\n+  if (_callprojs.catchall_ioproj != NULL) {\n+    _igvn.replace_node(_callprojs.catchall_ioproj, C->top());\n@@ -1055,2 +1005,2 @@\n-  if (_catchallcatchproj != NULL) {\n-    _igvn.replace_node(_catchallcatchproj, C->top());\n+  if (_callprojs.catchall_catchproj != NULL) {\n+    _igvn.replace_node(_callprojs.catchall_catchproj, C->top());\n@@ -1081,1 +1031,1 @@\n-  extract_call_projections(alloc);\n+  alloc->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1136,1 +1086,1 @@\n-  extract_call_projections(boxing);\n+  boxing->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1466,1 +1416,1 @@\n-  extract_call_projections(call);\n+  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -1472,9 +1422,9 @@\n-  if (expand_fast_path && _memproj_fallthrough != NULL) {\n-    migrate_outs(_memproj_fallthrough, result_phi_rawmem);\n-  }\n-  \/\/ Now change uses of _memproj_catchall to use _memproj_fallthrough and delete\n-  \/\/ _memproj_catchall so we end up with a call that has only 1 memory projection.\n-  if (_memproj_catchall != NULL ) {\n-    if (_memproj_fallthrough == NULL) {\n-      _memproj_fallthrough = new ProjNode(call, TypeFunc::Memory);\n-      transform_later(_memproj_fallthrough);\n+  if (expand_fast_path && _callprojs.fallthrough_memproj != NULL) {\n+    migrate_outs(_callprojs.fallthrough_memproj, result_phi_rawmem);\n+  }\n+  \/\/ Now change uses of catchall_memproj to use fallthrough_memproj and delete\n+  \/\/ catchall_memproj so we end up with a call that has only 1 memory projection.\n+  if (_callprojs.catchall_memproj != NULL ) {\n+    if (_callprojs.fallthrough_memproj == NULL) {\n+      _callprojs.fallthrough_memproj = new ProjNode(call, TypeFunc::Memory);\n+      transform_later(_callprojs.fallthrough_memproj);\n@@ -1482,2 +1432,2 @@\n-    migrate_outs(_memproj_catchall, _memproj_fallthrough);\n-    _igvn.remove_dead_node(_memproj_catchall);\n+    migrate_outs(_callprojs.catchall_memproj, _callprojs.fallthrough_memproj);\n+    _igvn.remove_dead_node(_callprojs.catchall_memproj);\n@@ -1491,9 +1441,9 @@\n-  if (_ioproj_fallthrough != NULL) {\n-    migrate_outs(_ioproj_fallthrough, result_phi_i_o);\n-  }\n-  \/\/ Now change uses of _ioproj_catchall to use _ioproj_fallthrough and delete\n-  \/\/ _ioproj_catchall so we end up with a call that has only 1 i_o projection.\n-  if (_ioproj_catchall != NULL ) {\n-    if (_ioproj_fallthrough == NULL) {\n-      _ioproj_fallthrough = new ProjNode(call, TypeFunc::I_O);\n-      transform_later(_ioproj_fallthrough);\n+  if (_callprojs.fallthrough_ioproj != NULL) {\n+    migrate_outs(_callprojs.fallthrough_ioproj, result_phi_i_o);\n+  }\n+  \/\/ Now change uses of catchall_ioproj to use fallthrough_ioproj and delete\n+  \/\/ catchall_ioproj so we end up with a call that has only 1 i_o projection.\n+  if (_callprojs.catchall_ioproj != NULL ) {\n+    if (_callprojs.fallthrough_ioproj == NULL) {\n+      _callprojs.fallthrough_ioproj = new ProjNode(call, TypeFunc::I_O);\n+      transform_later(_callprojs.fallthrough_ioproj);\n@@ -1501,2 +1451,2 @@\n-    migrate_outs(_ioproj_catchall, _ioproj_fallthrough);\n-    _igvn.remove_dead_node(_ioproj_catchall);\n+    migrate_outs(_callprojs.catchall_ioproj, _callprojs.fallthrough_ioproj);\n+    _igvn.remove_dead_node(_callprojs.catchall_ioproj);\n@@ -1521,2 +1471,2 @@\n-  if (_fallthroughcatchproj != NULL) {\n-    ctrl = _fallthroughcatchproj->clone();\n+  if (_callprojs.fallthrough_catchproj != NULL) {\n+    ctrl = _callprojs.fallthrough_catchproj->clone();\n@@ -1524,1 +1474,1 @@\n-    _igvn.replace_node(_fallthroughcatchproj, result_region);\n+    _igvn.replace_node(_callprojs.fallthrough_catchproj, result_region);\n@@ -1529,1 +1479,1 @@\n-  if (_resproj == NULL) {\n+  if (_callprojs.resproj == NULL) {\n@@ -1533,1 +1483,1 @@\n-    slow_result = _resproj->clone();\n+    slow_result = _callprojs.resproj->clone();\n@@ -1535,1 +1485,1 @@\n-    _igvn.replace_node(_resproj, result_phi_rawoop);\n+    _igvn.replace_node(_callprojs.resproj, result_phi_rawoop);\n@@ -1545,1 +1495,1 @@\n-  result_phi_rawmem->init_req(slow_result_path, _memproj_fallthrough);\n+  result_phi_rawmem->init_req(slow_result_path, _callprojs.fallthrough_memproj);\n@@ -1557,4 +1507,4 @@\n-  extract_call_projections(alloc);\n-  if (_resproj != NULL) {\n-    for (DUIterator_Fast imax, i = _resproj->fast_outs(imax); i < imax; i++) {\n-      Node* use = _resproj->fast_out(i);\n+  alloc->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  if (_callprojs.resproj != NULL) {\n+    for (DUIterator_Fast imax, i = _callprojs.resproj->fast_outs(imax); i < imax; i++) {\n+      Node* use = _callprojs.resproj->fast_out(i);\n@@ -1565,2 +1515,2 @@\n-    assert(_resproj->outcnt() == 0, \"all uses must be deleted\");\n-    _igvn.remove_dead_node(_resproj);\n+    assert(_callprojs.resproj->outcnt() == 0, \"all uses must be deleted\");\n+    _igvn.remove_dead_node(_callprojs.resproj);\n@@ -1568,3 +1518,3 @@\n-  if (_fallthroughcatchproj != NULL) {\n-    migrate_outs(_fallthroughcatchproj, ctrl);\n-    _igvn.remove_dead_node(_fallthroughcatchproj);\n+  if (_callprojs.fallthrough_catchproj != NULL) {\n+    migrate_outs(_callprojs.fallthrough_catchproj, ctrl);\n+    _igvn.remove_dead_node(_callprojs.fallthrough_catchproj);\n@@ -1572,3 +1522,3 @@\n-  if (_catchallcatchproj != NULL) {\n-    _igvn.rehash_node_delayed(_catchallcatchproj);\n-    _catchallcatchproj->set_req(0, top());\n+  if (_callprojs.catchall_catchproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs.catchall_catchproj);\n+    _callprojs.catchall_catchproj->set_req(0, top());\n@@ -1576,2 +1526,2 @@\n-  if (_fallthroughproj != NULL) {\n-    Node* catchnode = _fallthroughproj->unique_ctrl_out();\n+  if (_callprojs.fallthrough_proj != NULL) {\n+    Node* catchnode = _callprojs.fallthrough_proj->unique_ctrl_out();\n@@ -1579,1 +1529,1 @@\n-    _igvn.remove_dead_node(_fallthroughproj);\n+    _igvn.remove_dead_node(_callprojs.fallthrough_proj);\n@@ -1581,3 +1531,3 @@\n-  if (_memproj_fallthrough != NULL) {\n-    migrate_outs(_memproj_fallthrough, mem);\n-    _igvn.remove_dead_node(_memproj_fallthrough);\n+  if (_callprojs.fallthrough_memproj != NULL) {\n+    migrate_outs(_callprojs.fallthrough_memproj, mem);\n+    _igvn.remove_dead_node(_callprojs.fallthrough_memproj);\n@@ -1585,3 +1535,3 @@\n-  if (_ioproj_fallthrough != NULL) {\n-    migrate_outs(_ioproj_fallthrough, i_o);\n-    _igvn.remove_dead_node(_ioproj_fallthrough);\n+  if (_callprojs.fallthrough_ioproj != NULL) {\n+    migrate_outs(_callprojs.fallthrough_ioproj, i_o);\n+    _igvn.remove_dead_node(_callprojs.fallthrough_ioproj);\n@@ -1589,3 +1539,3 @@\n-  if (_memproj_catchall != NULL) {\n-    _igvn.rehash_node_delayed(_memproj_catchall);\n-    _memproj_catchall->set_req(0, top());\n+  if (_callprojs.catchall_memproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs.catchall_memproj);\n+    _callprojs.catchall_memproj->set_req(0, top());\n@@ -1593,3 +1543,3 @@\n-  if (_ioproj_catchall != NULL) {\n-    _igvn.rehash_node_delayed(_ioproj_catchall);\n-    _ioproj_catchall->set_req(0, top());\n+  if (_callprojs.catchall_ioproj != NULL) {\n+    _igvn.rehash_node_delayed(_callprojs.catchall_ioproj);\n+    _callprojs.catchall_ioproj->set_req(0, top());\n@@ -2154,1 +2104,1 @@\n-  extract_call_projections(alock);\n+  alock->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -2158,2 +2108,2 @@\n-         _fallthroughproj != NULL &&\n-         _memproj_fallthrough != NULL,\n+         _callprojs.fallthrough_proj != NULL &&\n+         _callprojs.fallthrough_memproj != NULL,\n@@ -2162,2 +2112,2 @@\n-  Node* fallthroughproj = _fallthroughproj;\n-  Node* memproj_fallthrough = _memproj_fallthrough;\n+  Node* fallthroughproj = _callprojs.fallthrough_proj;\n+  Node* memproj_fallthrough = _callprojs.fallthrough_memproj;\n@@ -2417,1 +2367,1 @@\n-  extract_call_projections(call);\n+  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n@@ -2423,2 +2373,2 @@\n-  assert ( _ioproj_fallthrough == NULL && _ioproj_catchall == NULL &&\n-           _memproj_catchall == NULL && _catchallcatchproj == NULL, \"Unexpected projection from Lock\");\n+  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n+         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2429,1 +2379,1 @@\n-  Node *slow_ctrl = _fallthroughproj->clone();\n+  Node *slow_ctrl = _callprojs.fallthrough_proj->clone();\n@@ -2431,2 +2381,2 @@\n-  _igvn.hash_delete(_fallthroughproj);\n-  _fallthroughproj->disconnect_inputs(C);\n+  _igvn.hash_delete(_callprojs.fallthrough_proj);\n+  _callprojs.fallthrough_proj->disconnect_inputs(C);\n@@ -2436,1 +2386,1 @@\n-  _igvn.replace_node(_fallthroughproj, region);\n+  _igvn.replace_node(_callprojs.fallthrough_proj, region);\n@@ -2441,1 +2391,1 @@\n-  _igvn.replace_node(_memproj_fallthrough, mem_phi);\n+  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n@@ -2488,4 +2438,3 @@\n-  extract_call_projections(call);\n-\n-  assert ( _ioproj_fallthrough == NULL && _ioproj_catchall == NULL &&\n-           _memproj_catchall == NULL && _catchallcatchproj == NULL, \"Unexpected projection from Lock\");\n+  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  assert(_callprojs.fallthrough_ioproj == NULL && _callprojs.catchall_ioproj == NULL &&\n+         _callprojs.catchall_memproj == NULL && _callprojs.catchall_catchproj == NULL, \"Unexpected projection from Lock\");\n@@ -2497,1 +2446,1 @@\n-  Node *slow_ctrl = _fallthroughproj->clone();\n+  Node *slow_ctrl = _callprojs.fallthrough_proj->clone();\n@@ -2499,2 +2448,2 @@\n-  _igvn.hash_delete(_fallthroughproj);\n-  _fallthroughproj->disconnect_inputs(C);\n+  _igvn.hash_delete(_callprojs.fallthrough_proj);\n+  _callprojs.fallthrough_proj->disconnect_inputs(C);\n@@ -2504,1 +2453,1 @@\n-  _igvn.replace_node(_fallthroughproj, region);\n+  _igvn.replace_node(_callprojs.fallthrough_proj, region);\n@@ -2510,1 +2459,1 @@\n-  _igvn.replace_node(_memproj_fallthrough, mem_phi);\n+  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":113,"deletions":164,"binary":false,"changes":277,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,8 +85,1 @@\n-  ProjNode *_fallthroughproj;\n-  ProjNode *_fallthroughcatchproj;\n-  ProjNode *_ioproj_fallthrough;\n-  ProjNode *_ioproj_catchall;\n-  ProjNode *_catchallcatchproj;\n-  ProjNode *_memproj_fallthrough;\n-  ProjNode *_memproj_catchall;\n-  ProjNode *_resproj;\n+  CallProjections _callprojs;\n@@ -202,1 +195,0 @@\n-  void extract_call_projections(CallNode *call);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -829,3 +829,3 @@\n-  _igvn.replace_node(_memproj_fallthrough, out_mem);\n-  _igvn.replace_node(_ioproj_fallthrough, *io);\n-  _igvn.replace_node(_fallthroughcatchproj, *ctrl);\n+  _igvn.replace_node(_callprojs.fallthrough_memproj, out_mem);\n+  _igvn.replace_node(_callprojs.fallthrough_ioproj, *io);\n+  _igvn.replace_node(_callprojs.fallthrough_catchproj, *ctrl);\n@@ -1077,2 +1077,2 @@\n-  extract_call_projections(call);\n-  *ctrl = _fallthroughcatchproj->clone();\n+  call->extract_projections(&_callprojs, false \/*separate_io_proj*\/, false \/*do_asserts*\/);\n+  *ctrl = _callprojs.fallthrough_catchproj->clone();\n@@ -1081,1 +1081,1 @@\n-  Node* m = _memproj_fallthrough->clone();\n+  Node* m = _callprojs.fallthrough_memproj->clone();\n@@ -1094,1 +1094,1 @@\n-  *io = _ioproj_fallthrough->clone();\n+  *io = _callprojs.fallthrough_ioproj->clone();\n@@ -1329,3 +1329,3 @@\n-    _igvn.replace_node(_memproj_fallthrough, merge_mem);\n-    _igvn.replace_node(_ioproj_fallthrough, io);\n-    _igvn.replace_node(_fallthroughcatchproj, ctrl);\n+    _igvn.replace_node(_callprojs.fallthrough_memproj, merge_mem);\n+    _igvn.replace_node(_callprojs.fallthrough_ioproj, io);\n+    _igvn.replace_node(_callprojs.fallthrough_catchproj, ctrl);\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2972,7 +2972,1 @@\n-  \/\/ Either input is TOP ==> the result is TOP\n-  const Type *t = phase->type( in(MemNode::Memory) );\n-  if( t == Type::TOP ) return Type::TOP;\n-  t = phase->type( in(MemNode::Address) );\n-  if( t == Type::TOP ) return Type::TOP;\n-  t = phase->type( in(MemNode::ValueIn) );\n-  if( t == Type::TOP ) return Type::TOP;\n+  \/\/ Either input is TOP ==> the result is TOP (checked in StoreNode::Value).\n@@ -2980,4 +2974,5 @@\n-  t = phase->type( in(MemNode::OopStore) );\n-  if( t == Type::TOP ) return Type::TOP;\n-\n-  return StoreNode::Value( phase );\n+  const Type* t = phase->type(in(MemNode::OopStore));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return StoreNode::Value(phase);\n@@ -2991,0 +2986,3 @@\n+  if (in(0) == NULL || phase->type(in(0)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n@@ -3009,0 +3007,21 @@\n+\/\/------------------------------Value-----------------------------------------\n+const Type* LoadStoreNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  if (!in(MemNode::Control) || phase->type(in(MemNode::Control)) == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  const Type* t = phase->type(in(MemNode::Memory));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  t = phase->type(in(MemNode::Address));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  t = phase->type(in(MemNode::ValueIn));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return bottom_type();\n+}\n+\n@@ -3054,0 +3073,9 @@\n+const Type* LoadStoreConditionalNode::Value(PhaseGVN* phase) const {\n+  \/\/ Either input is TOP ==> the result is TOP\n+  const Type* t = phase->type(in(ExpectedIn));\n+  if (t == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  return LoadStoreNode::Value(phase);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -852,0 +852,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n@@ -866,0 +867,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  PHASE_AFTER_MATCHING,\n@@ -103,1 +102,0 @@\n-      case PHASE_AFTER_MATCHING:             return \"After Matching\";\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -238,3 +238,4 @@\n-  \/\/ Convert \"0 - (x-y)\" into \"y-x\"\n-  if( t1 == TypeInt::ZERO && op2 == Op_SubI )\n-    return new SubINode( in2->in(2), in2->in(1) );\n+  \/\/ Convert \"0 - (x-y)\" into \"y-x\", leave the double negation \"-(-y)\" to SubNode::Identity().\n+  if (t1 == TypeInt::ZERO && op2 == Op_SubI && phase->type(in2->in(1)) != TypeInt::ZERO) {\n+    return new SubINode(in2->in(2), in2->in(1));\n+  }\n@@ -376,3 +377,4 @@\n-  \/\/ Convert \"0 - (x-y)\" into \"y-x\"\n-  if( phase->type( in1 ) == TypeLong::ZERO && op2 == Op_SubL )\n-    return new SubLNode( in2->in(2), in2->in(1) );\n+  \/\/ Convert \"0 - (x-y)\" into \"y-x\", leave the double negation \"-(-y)\" to SubNode::Identity.\n+  if (t1 == TypeLong::ZERO && op2 == Op_SubL && phase->type(in2->in(1)) != TypeLong::ZERO) {\n+    return new SubLNode(in2->in(2), in2->in(1));\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3783,44 +3783,2 @@\n-    const TypeAryPtr *tp = t->is_aryptr();\n-    int offset = meet_offset(tp->offset());\n-    PTR ptr = meet_ptr(tp->ptr());\n-    int instance_id = meet_instance_id(tp->instance_id());\n-    const TypePtr* speculative = xmeet_speculative(tp);\n-    int depth = meet_inline_depth(tp->inline_depth());\n-    switch (ptr) {\n-    case TopPTR:\n-    case AnyNull:                \/\/ Fall 'down' to dual of object klass\n-      \/\/ For instances when a subclass meets a superclass we fall\n-      \/\/ below the centerline when the superclass is exact. We need to\n-      \/\/ do the same here.\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n-        return TypeAryPtr::make(ptr, tp->ary(), tp->klass(), tp->klass_is_exact(), offset, instance_id, speculative, depth);\n-      } else {\n-        \/\/ cannot subclass, so the meet has to fall badly below the centerline\n-        ptr = NotNull;\n-        instance_id = InstanceBot;\n-        return TypeInstPtr::make( ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n-      }\n-    case Constant:\n-    case NotNull:\n-    case BotPTR:                \/\/ Fall down to object klass\n-      \/\/ LCA is object_klass, but if we subclass from the top we can do better\n-      if( above_centerline(_ptr) ) { \/\/ if( _ptr == TopPTR || _ptr == AnyNull )\n-        \/\/ If 'this' (InstPtr) is above the centerline and it is Object class\n-        \/\/ then we can subclass in the Java class hierarchy.\n-        \/\/ For instances when a subclass meets a superclass we fall\n-        \/\/ below the centerline when the superclass is exact. We need\n-        \/\/ to do the same here.\n-        if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n-          \/\/ that is, tp's array type is a subtype of my klass\n-          return TypeAryPtr::make(ptr, (ptr == Constant ? tp->const_oop() : NULL),\n-                                  tp->ary(), tp->klass(), tp->klass_is_exact(), offset, instance_id, speculative, depth);\n-        }\n-      }\n-      \/\/ The other case cannot happen, since I cannot be a subtype of an array.\n-      \/\/ The meet falls down to Object class below centerline.\n-      if( ptr == Constant )\n-         ptr = NotNull;\n-      instance_id = InstanceBot;\n-      return make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n-    default: typerr(t);\n-    }\n+    \/\/ Call in reverse direction to avoid duplication\n+    return t->is_aryptr()->xmeet_helper(this);\n@@ -3964,2 +3922,6 @@\n-        if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n-        instance_id = InstanceBot;\n+        if (ptr == Constant) {\n+          ptr = NotNull;  \/\/ forget it was a constant\n+        }\n+        if (instance_id > 0) {\n+          instance_id = InstanceBot;\n+        }\n@@ -4054,1 +4016,1 @@\n-    if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )\n+    if (ptr == TopPTR || ptr == AnyNull || ptr == Constant) {\n@@ -4056,1 +4018,1 @@\n-\n+    }\n@@ -4498,1 +4460,1 @@\n-      return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n+      return make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n@@ -4503,5 +4465,7 @@\n-      if (above_centerline(this->_ptr))\n-            xk = tap->_klass_is_exact;\n-      else  xk = (tap->_klass_is_exact & this->_klass_is_exact) &&\n-              (klass() == tap->klass()); \/\/ Only precise for identical arrays\n-      return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n+      if (above_centerline(this->_ptr)) {\n+        xk = tap->_klass_is_exact;\n+      } else {\n+        xk = (tap->_klass_is_exact & this->_klass_is_exact) &&\n+             (klass() == tap->klass()); \/\/ Only precise for identical arrays\n+      }\n+      return make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);\n@@ -4527,1 +4491,1 @@\n-        return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+        return make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n@@ -4552,1 +4516,1 @@\n-      if( ptr == Constant )\n+      if (ptr == Constant) {\n@@ -4554,2 +4518,5 @@\n-      instance_id = InstanceBot;\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n+      }\n+      if (instance_id > 0) {\n+        instance_id = InstanceBot;\n+      }\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":25,"deletions":58,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoadInfo.hpp\"\n@@ -286,1 +288,3 @@\n-  Klass* k = SystemDictionary::resolve_from_stream(class_name,\n+  Handle protection_domain;\n+  ClassLoadInfo cl_info(protection_domain);\n+  Klass* k = SystemDictionary::resolve_from_stream(&st, class_name,\n@@ -288,2 +292,1 @@\n-                                                   Handle(),\n-                                                   &st,\n+                                                   cl_info,\n@@ -3726,0 +3729,4 @@\n+\n+  \/\/ We are going to VM, change W^X state to the expected one.\n+  MACOS_AARCH64_ONLY(WXMode oldmode = thread->enable_wx(WXWrite));\n+\n@@ -3734,0 +3741,1 @@\n+    MACOS_AARCH64_ONLY(thread->enable_wx(oldmode));\n@@ -3913,0 +3921,3 @@\n+  \/\/ We are going to VM, change W^X state to the expected one.\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXWrite));\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -863,1 +863,2 @@\n-  Klass* k = SystemDictionary::resolve_from_stream(class_name,\n+  ClassLoadInfo cl_info(protection_domain);\n+  Klass* k = SystemDictionary::resolve_from_stream(&st, class_name,\n@@ -865,2 +866,1 @@\n-                                                   protection_domain,\n-                                                   &st,\n+                                                   cl_info,\n@@ -950,1 +950,2 @@\n-    ik = SystemDictionary::resolve_from_stream(class_name,\n+    ClassLoadInfo cl_info(protection_domain);\n+    ik = SystemDictionary::resolve_from_stream(&st, class_name,\n@@ -952,2 +953,1 @@\n-                                               protection_domain,\n-                                               &st,\n+                                               cl_info,\n@@ -969,5 +969,4 @@\n-    ik = SystemDictionary::parse_stream(class_name,\n-                                        class_loader,\n-                                        &st,\n-                                        cl_info,\n-                                        CHECK_NULL);\n+    ik = SystemDictionary::resolve_from_stream(&st, class_name,\n+                                               class_loader,\n+                                               cl_info,\n+                                               CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -226,6 +226,2 @@\n-  jobject module = Modules::get_named_module(h_loader, package_name, THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    CLEAR_PENDING_EXCEPTION;\n-    return JVMTI_ERROR_INTERNAL; \/\/ unexpected exception\n-  }\n-  *module_ptr = module;\n+  oop module = Modules::get_named_module(h_loader, package_name);\n+  *module_ptr = module != NULL ? JNIHandles::make_local(THREAD, module) : NULL;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/klassFactory.hpp\"\n@@ -1370,1 +1370,0 @@\n-    Symbol*  the_class_sym = the_class->name();\n@@ -1381,3 +1380,0 @@\n-    \/\/ Parse the stream.\n-    Handle the_class_loader(current, the_class->class_loader());\n-    Handle protection_domain(current, the_class->protection_domain());\n@@ -1391,0 +1387,1 @@\n+    Handle protection_domain(THREAD, the_class->protection_domain());\n@@ -1392,4 +1389,5 @@\n-    InstanceKlass* scratch_class = SystemDictionary::parse_stream(\n-                                                      the_class_sym,\n-                                                      the_class_loader,\n-                                                      &st,\n+    \/\/ Parse and create a class from the bytes, but this class isn't added\n+    \/\/ to the dictionary, so do not call resolve_from_stream.\n+    InstanceKlass* scratch_class = KlassFactory::create_from_stream(&st,\n+                                                      the_class->name(),\n+                                                      the_class->class_loader_data(),\n@@ -1398,0 +1396,1 @@\n+\n@@ -1410,1 +1409,1 @@\n-      log_info(redefine, class, load, exceptions)(\"parse_stream exception: '%s'\", ex_name->as_C_string());\n+      log_info(redefine, class, load, exceptions)(\"create_from_stream exception: '%s'\", ex_name->as_C_string());\n@@ -4373,3 +4372,2 @@\n-  the_class->vtable().initialize_vtable(false, THREAD);\n-  the_class->itable().initialize_itable(false, THREAD);\n-  assert(!HAS_PENDING_EXCEPTION || (THREAD->pending_exception()->is_a(vmClasses::ThreadDeath_klass())), \"redefine exception\");\n+  the_class->vtable().initialize_vtable();\n+  the_class->itable().initialize_itable();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -305,6 +305,0 @@\n-\/\/ - SystemDictionary::parse_stream() was called with a NULL protection\n-\/\/   domain since the initial version. This has been changed to pass\n-\/\/   the_class->protection_domain(). This change has been tested with\n-\/\/   all NSK tests and nothing broke, but what will adding it now break\n-\/\/   in ways that we don't test?\n-\/\/\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -868,5 +868,4 @@\n-  InstanceKlass* anonk = SystemDictionary::parse_stream(no_class_name,\n-                                                        host_loader,\n-                                                        &st,\n-                                                        cl_info,\n-                                                        CHECK_NULL);\n+  InstanceKlass* anonk = SystemDictionary::resolve_from_stream(&st, no_class_name,\n+                                                               host_loader,\n+                                                               cl_info,\n+                                                               CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -835,0 +835,19 @@\n+static bool is_excluded_for_compiler(AbstractCompiler* comp, methodHandle& mh) {\n+  if (comp == NULL) {\n+    return true;\n+  }\n+  DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);\n+  if (directive->ExcludeOption) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static bool can_be_compiled_at_level(methodHandle& mh, jboolean is_osr, int level) {\n+  if (is_osr) {\n+    return CompilationPolicy::can_be_osr_compiled(mh, level);\n+  } else {\n+    return CompilationPolicy::can_be_compiled(mh, level);\n+  }\n+}\n+\n@@ -843,4 +862,23 @@\n-  if (is_osr) {\n-    return CompilationPolicy::can_be_osr_compiled(mh, comp_level);\n-  } else {\n-    return CompilationPolicy::can_be_compiled(mh, comp_level);\n+\n+  \/\/ The ExcludeOption directive is evaluated lazily upon compilation attempt. If a method was not tried to be compiled by\n+  \/\/ a compiler, yet, the method object is not set to be not compilable by that compiler. Thus, evaluate the compiler directive\n+  \/\/ to exclude a compilation of 'method'.\n+  if (comp_level == CompLevel_any) {\n+    \/\/ Both compilers could have ExcludeOption set. Check all combinations.\n+    bool excluded_c1 = is_excluded_for_compiler(CompileBroker::compiler1(), mh);\n+    bool excluded_c2 = is_excluded_for_compiler(CompileBroker::compiler2(), mh);\n+    if (excluded_c1 && excluded_c2) {\n+      \/\/ Compilation of 'method' excluded by both compilers.\n+      return false;\n+    }\n+\n+    if (excluded_c1) {\n+      \/\/ C1 only has ExcludeOption set: Check if compilable with C2.\n+      return can_be_compiled_at_level(mh, is_osr, CompLevel_full_optimization);\n+    } else if (excluded_c2) {\n+      \/\/ C2 only has ExcludeOption set: Check if compilable with C1.\n+      return can_be_compiled_at_level(mh, is_osr, CompLevel_simple);\n+    }\n+  } else if (comp_level > CompLevel_none && is_excluded_for_compiler(CompileBroker::compiler((int)comp_level), mh)) {\n+    \/\/ Compilation of 'method' excluded by compiler used for 'comp_level'.\n+    return false;\n@@ -848,0 +886,2 @@\n+\n+  return can_be_compiled_at_level(mh, is_osr, (int)comp_level);\n@@ -1335,2 +1375,0 @@\n-  ccstr ccstrResult = ccstrValue;\n-  bool needFree;\n@@ -1338,0 +1376,1 @@\n+    ccstr param = ccstrValue;\n@@ -1339,1 +1378,3 @@\n-    needFree = SetVMFlag <JVM_FLAG_TYPE(ccstr)> (thread, env, name, &ccstrResult);\n+    if (SetVMFlag <JVM_FLAG_TYPE(ccstr)> (thread, env, name, &param)) {\n+      assert(param == NULL, \"old value is freed automatically and not returned\");\n+    }\n@@ -1344,3 +1385,0 @@\n-  if (needFree) {\n-    FREE_C_HEAP_ARRAY(char, ccstrResult);\n-  }\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":48,"deletions":10,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/flags\/debug_globals.hpp\"\n@@ -115,0 +116,9 @@\n+  DEBUG_RUNTIME_FLAGS(        \\\n+    develop,                  \\\n+    develop_pd,               \\\n+    product,                  \\\n+    product_pd,               \\\n+    notproduct,               \\\n+    range,                    \\\n+    constraint)               \\\n+                              \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/allFlags.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_DEBUG_GLOBALS_HPP\n+#define SHARE_RUNTIME_DEBUG_GLOBALS_HPP\n+\n+#include \"runtime\/globals_shared.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/\n+\/\/ These flags are needed for testing the implementation of various flag access\n+\/\/ APIs.\n+\/\/\n+\/\/ For example, DummyManageableStringFlag is needed because we don't\n+\/\/ have any MANAGEABLE flags of the ccstr type, but we really need to\n+\/\/ make sure the implementation is correct (in terms of memory allocation)\n+\/\/ just in case someone may add such a flag in the future.\n+\/\/\n+\n+#ifndef ASSERT\n+\n+#define DEBUG_RUNTIME_FLAGS(develop,                                        \\\n+                            develop_pd,                                     \\\n+                            product,                                        \\\n+                            product_pd,                                     \\\n+                            notproduct,                                     \\\n+                            range,                                          \\\n+                            constraint)                                     \\\n+                                                                            \\\n+\n+#else\n+\n+#define DEBUG_RUNTIME_FLAGS(develop,                                        \\\n+                            develop_pd,                                     \\\n+                            product,                                        \\\n+                            product_pd,                                     \\\n+                            notproduct,                                     \\\n+                            range,                                          \\\n+                            constraint)                                     \\\n+                                                                            \\\n+  product(ccstr, DummyManageableStringFlag, NULL, MANAGEABLE,               \\\n+          \"Dummy flag for testing string handling in WriteableFlags\")       \\\n+                                                                            \\\n+\n+\/\/ end of DEBUG_RUNTIME_FLAGS\n+\n+#endif \/\/ ASSERT\n+\n+DECLARE_FLAGS(DEBUG_RUNTIME_FLAGS)\n+\n+#endif \/\/ SHARE_RUNTIME_DEBUG_GLOBALS_HPP\n","filename":"src\/hotspot\/share\/runtime\/flags\/debug_globals.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -320,3 +320,3 @@\n-  if (flag->is_default() && old_value != NULL) {\n-    \/\/ Prior value is NOT heap allocated, but was a literal constant.\n-    old_value = os::strdup_check_oom(old_value);\n+  if (!flag->is_default() && old_value != NULL) {\n+    \/\/ Old value is heap allocated so free it.\n+    FREE_C_HEAP_ARRAY(char, old_value);\n@@ -324,1 +324,5 @@\n-  *value = old_value;\n+  \/\/ Unlike the other APIs, the old vale is NOT returned, so the caller won't need to free it.\n+  \/\/ The callers typically don't care what the old value is.\n+  \/\/ If the caller really wants to know the old value, read it (and make a copy if necessary)\n+  \/\/ before calling this API.\n+  *value = NULL;\n@@ -331,4 +335,0 @@\n-  if (type_enum == JVMFlag::TYPE_ccstr || type_enum == JVMFlag::TYPE_ccstrlist) {\n-    return ccstrAtPut((JVMFlagsEnum)flag_enum, *((ccstr*)value), origin);\n-  }\n-\n@@ -336,15 +336,6 @@\n-  assert(flag->type() == type_enum, \"wrong flag type\");\n-  return set_impl(flag, type_enum, value, origin);\n-}\n-\n-\/\/ This is called by the FLAG_SET_XXX macros.\n-JVMFlag::Error JVMFlagAccess::ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlagOrigin origin) {\n-  JVMFlag* faddr = JVMFlag::flag_from_enum(flag);\n-  assert(faddr->is_ccstr(), \"wrong flag type\");\n-  ccstr old_value = faddr->get_ccstr();\n-  trace_flag_changed<ccstr, EventStringFlagChanged>(faddr, old_value, value, origin);\n-  char* new_value = os::strdup_check_oom(value);\n-  faddr->set_ccstr(new_value);\n-  if (!faddr->is_default() && old_value != NULL) {\n-    \/\/ Prior value is heap allocated so free it.\n-    FREE_C_HEAP_ARRAY(char, old_value);\n+  if (type_enum == JVMFlag::TYPE_ccstr || type_enum == JVMFlag::TYPE_ccstrlist) {\n+    assert(flag->is_ccstr(), \"must be\");\n+    return ccstrAtPut(flag, (ccstr*)value, origin);\n+  } else {\n+    assert(flag->type() == type_enum, \"wrong flag type\");\n+    return set_impl(flag, type_enum, value, origin);\n@@ -352,2 +343,0 @@\n-  faddr->set_origin(origin);\n-  return JVMFlag::SUCCESS;\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.cpp","additions":14,"deletions":25,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,0 @@\n-  static JVMFlag::Error ccstrAtPut(JVMFlagsEnum flag, ccstr value, JVMFlagOrigin origin);\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagAccess.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -945,1 +945,1 @@\n-    oop *loc = _fr.oopmapreg_to_location(reg, _reg_map);\n+    oop *loc = _fr.oopmapreg_to_oop_location(reg, _reg_map);\n@@ -1000,1 +1000,1 @@\n-  oop* oop_adr = caller.oopmapreg_to_location(reg, reg_map);\n+  oop* oop_adr = caller.oopmapreg_to_oop_location(reg, reg_map);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -369,1 +369,2 @@\n-  oop* oopmapreg_to_location(VMReg reg, const RegisterMap* reg_map) const;\n+  address oopmapreg_to_location(VMReg reg, const RegisterMap* reg_map) const;\n+  oop* oopmapreg_to_oop_location(VMReg reg, const RegisterMap* reg_map) const;\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-inline oop* frame::oopmapreg_to_location(VMReg reg, const RegisterMap* reg_map) const {\n+inline address frame::oopmapreg_to_location(VMReg reg, const RegisterMap* reg_map) const {\n@@ -61,1 +61,1 @@\n-    return (oop *)reg_map->location(reg);\n+    return reg_map->location(reg);\n@@ -64,1 +64,1 @@\n-    return (oop*)(((address)unextended_sp()) + sp_offset_in_bytes);\n+    return ((address)unextended_sp()) + sp_offset_in_bytes;\n@@ -68,0 +68,4 @@\n+inline oop* frame::oopmapreg_to_oop_location(VMReg reg, const RegisterMap* reg_map) const {\n+  return (oop*)oopmapreg_to_location(reg, reg_map);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+void AOTLoader_init();\n@@ -118,1 +119,2 @@\n-  VM_Version_init();\n+  VM_Version_init();              \/\/ depends on codeCache_init for emitting code\n+  AOTLoader_init();               \/\/ depends on VM_Version_init to adjust vm options\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -391,0 +391,1 @@\n+    assert(current->current_pending_monitor() == NULL, \"invariant\");\n@@ -424,1 +425,1 @@\n-      exit(false, current);\n+      exit(current, false \/* not_suspended *\/);\n@@ -1142,1 +1143,1 @@\n-void ObjectMonitor::exit(bool not_suspended, JavaThread* current) {\n+void ObjectMonitor::exit(JavaThread* current, bool not_suspended) {\n@@ -1375,1 +1376,1 @@\n-  exit(true, current);     \/\/ exit the monitor\n+  exit(current);           \/\/ exit the monitor\n@@ -1509,1 +1510,1 @@\n-  exit(true, current);         \/\/ exit the monitor\n+  exit(current);               \/\/ exit the monitor\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-  void      exit(bool not_suspended, JavaThread* current);\n+  void      exit(JavaThread* current, bool not_suspended = true);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1036,1 +1036,1 @@\n-#ifdef __APPLE__\n+#if defined(__APPLE__) && !defined(ZERO)\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -521,1 +521,1 @@\n-  monitor->exit(true, current);\n+  monitor->exit(current);\n@@ -611,1 +611,1 @@\n-    monitor->exit(true, current);\n+    monitor->exit(current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1205,0 +1205,3 @@\n+  _jvmci_reserved0(nullptr),\n+  _jvmci_reserved1(nullptr),\n+  _jvmci_reserved_oop0(nullptr),\n@@ -2313,0 +2316,3 @@\n+#if INCLUDE_JVMCI\n+  f->do_oop((oop*) &_jvmci_reserved_oop0);\n+#endif\n@@ -3958,11 +3964,0 @@\n-void Threads::nmethods_do(CodeBlobClosure* cf) {\n-  ALL_JAVA_THREADS(p) {\n-    \/\/ This is used by the code cache sweeper to mark nmethods that are active\n-    \/\/ on the stack of a Java thread. Ignore the sweeper thread itself to avoid\n-    \/\/ marking CodeCacheSweeperThread::_scanned_compiled_method as active.\n-    if(!p->is_Code_cache_sweeper_thread()) {\n-      p->nmethods_do(cf);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1027,0 +1027,5 @@\n+  \/\/ Fast thread locals for use by JVMCI\n+  intptr_t*  _jvmci_reserved0;\n+  intptr_t*  _jvmci_reserved1;\n+  oop        _jvmci_reserved_oop0;\n+\n@@ -1841,3 +1846,0 @@\n-  \/\/ Sweeper\n-  static void nmethods_do(CodeBlobClosure* cf);\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -247,0 +248,3 @@\n+  if (err == JVMFlag::SUCCESS) {\n+    assert(value == NULL, \"old value is freed automatically and not returned\");\n+  }\n@@ -360,0 +364,1 @@\n+    ResourceMark rm;\n@@ -362,3 +367,0 @@\n-    if (ret != JVMFlag::SUCCESS) {\n-      FREE_C_HEAP_ARRAY(char, svalue);\n-    }\n","filename":"src\/hotspot\/share\/services\/writeableFlags.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+#include <cstddef>\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n+#define SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n+\n+#include \"memory\/padded.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/pair.hpp\"\n+\n+\/\/ Return status of a LockFreeQueue::try_pop() call.\n+\/\/ See description for try_pop() below.\n+enum class LockFreeQueuePopStatus {\n+  success,\n+  lost_race,\n+  operation_in_progress\n+};\n+\n+\/\/ The LockFreeQueue template provides a lock-free FIFO. Its structure\n+\/\/ and usage is similar to LockFreeStack. It provides a try_pop() function\n+\/\/ for the client to implement pop() according to its need (e.g., whether\n+\/\/ or not to retry or prevent ABA problem). It has inner padding of one\n+\/\/ cache line between its two internal pointer fields.\n+\/\/\n+\/\/ \\tparam T is the class of the elements in the queue.\n+\/\/\n+\/\/ \\tparam next_ptr is a function pointer.  Applying this function to\n+\/\/ an object of type T must return a pointer to the list entry member\n+\/\/ of the object associated with the LockFreeQueue type.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+class LockFreeQueue {\n+  T* volatile _head;\n+  \/\/ Padding of one cache line to avoid false sharing.\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(T*));\n+  T* volatile _tail;\n+\n+  NONCOPYABLE(LockFreeQueue);\n+\n+  \/\/ Return the entry following node in the list used by the\n+  \/\/ specialized LockFreeQueue class.\n+  static inline T* next(const T& node);\n+\n+  \/\/ Set the entry following node to new_next in the list used by the\n+  \/\/ specialized LockFreeQueue class. Not thread-safe, as it cannot\n+  \/\/ concurrently run with push or try_pop operations that modify this\n+  \/\/ node.\n+  static inline void set_next(T& node, T* new_next);\n+\n+public:\n+  inline LockFreeQueue();\n+  DEBUG_ONLY(~LockFreeQueue();)\n+\n+  \/\/ Return the first object in the queue.\n+  \/\/ Thread-safe, but the result may change immediately.\n+  inline T* top() const;\n+\n+  \/\/ Return true if the queue is empty.\n+  inline bool empty() const { return top() == NULL; }\n+\n+  \/\/ Return the number of objects in the queue.\n+  \/\/ Not thread-safe. There must be no concurrent modification\n+  \/\/ while the length is being determined.\n+  inline size_t length() const;\n+\n+  \/\/ Thread-safe add the object to the end of the queue.\n+  inline void push(T& node) { append(node, node); }\n+\n+  \/\/ Thread-safe add the objects from first to last to the end of the queue.\n+  inline void append(T& first, T& last);\n+\n+  \/\/ Thread-safe attempt to remove and return the first object in the queue.\n+  \/\/ Returns a <LockFreeQueuePopStatus, T*> pair for the caller to determine\n+  \/\/ further operation. 3 possible cases depending on pair.first:\n+  \/\/ - success:\n+  \/\/   The operation succeeded. If pair.second is NULL, the queue is empty;\n+  \/\/   otherwise caller can assume ownership of the object pointed by\n+  \/\/   pair.second. Note that this case is still subject to ABA behavior;\n+  \/\/   callers must ensure usage is safe.\n+  \/\/ - lost_race:\n+  \/\/   An atomic operation failed. pair.second is NULL.\n+  \/\/   The caller can typically retry in this case.\n+  \/\/ - operation_in_progress:\n+  \/\/   An in-progress concurrent operation interfered with taking what had been\n+  \/\/   the only remaining element in the queue. pair.second is NULL.\n+  \/\/   A concurrent try_pop may have already claimed it, but not completely\n+  \/\/   updated the queue. Alternatively, a concurrent push\/append may have not\n+  \/\/   yet linked the new entry(s) to the former sole entry. Retrying the try_pop\n+  \/\/   will continue to fail in this way until that other thread has updated the\n+  \/\/   queue's internal structure.\n+  inline Pair<LockFreeQueuePopStatus, T*> try_pop();\n+\n+  \/\/ Take all the objects from the queue, leaving the queue empty.\n+  \/\/ Not thread-safe. It should only be used when there is no concurrent\n+  \/\/ push\/append\/try_pop operation.\n+  \/\/ Returns a pair of <head, tail> pointers to the current queue.\n+  inline Pair<T*, T*> take_all();\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_LOCKFREEQUEUE_HPP\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.hpp","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n+#define SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n+\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/lockFreeQueue.hpp\"\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* LockFreeQueue<T, next_ptr>::next(const T& node) {\n+  return Atomic::load(next_ptr(const_cast<T&>(node)));\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+void LockFreeQueue<T, next_ptr>::set_next(T& node, T* new_next) {\n+    Atomic::store(next_ptr(node), new_next);\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+LockFreeQueue<T, next_ptr>::LockFreeQueue() : _head(NULL), _tail(NULL) {}\n+\n+#ifdef ASSERT\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+LockFreeQueue<T, next_ptr>::~LockFreeQueue() {\n+  assert(_head == NULL, \"precondition\");\n+  assert(_tail == NULL, \"precondition\");\n+}\n+#endif\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+T* LockFreeQueue<T, next_ptr>::top() const {\n+  return Atomic::load(&_head);\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+size_t LockFreeQueue<T, next_ptr>::length() const {\n+  size_t result = 0;\n+  for (const T* current = top(); current != NULL; current = next(*current)) {\n+    ++result;\n+  }\n+  return result;\n+}\n+\n+\/\/ An append operation atomically exchanges the new tail with the queue tail.\n+\/\/ It then sets the \"next\" value of the old tail to the head of the list being\n+\/\/ appended; it is an invariant that the old tail's \"next\" value is NULL.\n+\/\/ But if the old tail is NULL then the queue was empty.  In this case the\n+\/\/ head of the list being appended is instead stored in the queue head; it is\n+\/\/ an invariant that the queue head is NULL in this case.\n+\/\/\n+\/\/ This means there is a period between the exchange and the old tail update\n+\/\/ where the queue sequence is split into two parts, the list from the queue\n+\/\/ head to the old tail, and the list being appended.  If there are concurrent\n+\/\/ push\/append operations, each may introduce another such segment.  But they\n+\/\/ all eventually get resolved by their respective updates of their old tail's\n+\/\/ \"next\" value.  This also means that try_pop operation must handle an object\n+\/\/ with a NULL \"next\" value specially.\n+\/\/\n+\/\/ A push operation is just a degenerate append, where the object being pushed\n+\/\/ is both the head and the tail of the list being appended.\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+void LockFreeQueue<T, next_ptr>::append(T& first, T& last) {\n+  assert(next(last) == NULL, \"precondition\");\n+  T* old_tail = Atomic::xchg(&_tail, &last);\n+  if (old_tail == NULL) {       \/\/ Was empty.\n+    Atomic::store(&_head, &first);\n+  } else {\n+    assert(next(*old_tail) == NULL, \"invariant\");\n+    set_next(*old_tail, &first);\n+  }\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+Pair<LockFreeQueuePopStatus, T*> LockFreeQueue<T, next_ptr>::try_pop() {\n+  typedef Pair<LockFreeQueuePopStatus, T*> StatusPair;\n+  \/\/ We only need memory_order_consume. Upgrade it to \"load_acquire\"\n+  \/\/ as the memory_order_consume API is not ready for use yet.\n+  T* result = Atomic::load_acquire(&_head);\n+  if (result == NULL) {\n+    \/\/ Queue is empty.\n+    return StatusPair(LockFreeQueuePopStatus::success, NULL);\n+  }\n+\n+  \/\/ This relaxed load is always followed by a cmpxchg(), thus it\n+  \/\/ is OK as the reader-side of the release-acquire ordering.\n+  T* next_node = Atomic::load(next_ptr(*result));\n+  if (next_node != NULL) {\n+    \/\/ The \"usual\" lock-free pop from the head of a singly linked list.\n+    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n+      \/\/ Former head successfully taken; it is not the last.\n+      assert(Atomic::load(&_tail) != result, \"invariant\");\n+      assert(next(*result) != NULL, \"invariant\");\n+      set_next(*result, NULL);\n+      return StatusPair(LockFreeQueuePopStatus::success, result);\n+    }\n+    \/\/ Lost the race; the caller should try again.\n+    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n+  }\n+\n+  \/\/ next is NULL.  This case is handled differently from the \"usual\"\n+  \/\/ lock-free pop from the head of a singly linked list.\n+\n+  \/\/ If _tail == result then result is the only element in the list. We can\n+  \/\/ remove it from the list by first setting _tail to NULL and then setting\n+  \/\/ _head to NULL, the order being important.  We set _tail with cmpxchg in\n+  \/\/ case of a concurrent push\/append\/try_pop also changing _tail.  If we win\n+  \/\/ then we've claimed result.\n+  if (Atomic::cmpxchg(&_tail, result, (T*)NULL) == result) {\n+    assert(next(*result) == NULL, \"invariant\");\n+    \/\/ Now that we've claimed result, also set _head to NULL.  But we must\n+    \/\/ be careful of a concurrent push\/append after we NULLed _tail, since\n+    \/\/ it may have already performed its list-was-empty update of _head,\n+    \/\/ which we must not overwrite.\n+    Atomic::cmpxchg(&_head, result, (T*)NULL);\n+    return StatusPair(LockFreeQueuePopStatus::success, result);\n+  }\n+\n+  \/\/ If _head != result then we lost the race to take result;\n+  \/\/ the caller should try again.\n+  if (result != Atomic::load_acquire(&_head)) {\n+    return StatusPair(LockFreeQueuePopStatus::lost_race, NULL);\n+  }\n+\n+  \/\/ An in-progress concurrent operation interfered with taking the head\n+  \/\/ element when it was the only element.  A concurrent try_pop may have won\n+  \/\/ the race to clear the tail but not yet cleared the head. Alternatively,\n+  \/\/ a concurrent push\/append may have changed the tail but not yet linked\n+  \/\/ result->next(). This case slightly differs from the \"lost_race\" case,\n+  \/\/ because the caller could wait for a long time for the other concurrent\n+  \/\/ operation to finish.\n+  return StatusPair(LockFreeQueuePopStatus::operation_in_progress, NULL);\n+}\n+\n+template<typename T, T* volatile* (*next_ptr)(T&)>\n+Pair<T*, T*> LockFreeQueue<T, next_ptr>::take_all() {\n+  Pair<T*, T*> result(Atomic::load(&_head), Atomic::load(&_tail));\n+  Atomic::store(&_head, (T*)NULL);\n+  Atomic::store(&_tail, (T*)NULL);\n+  return result;\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_LOCKFREEQUEUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/lockFreeQueue.inline.hpp","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -316,0 +316,9 @@\n+        \/\/ No further process if z <= 1 or z == (p - 1) (See section 5.7.1,\n+        \/\/ NIST SP 800-56A Rev 3).\n+        BigInteger z = this.y.modPow(this.x, modulus);\n+        if ((z.compareTo(BigInteger.ONE) <= 0) ||\n+                z.equals(modulus.subtract(BigInteger.ONE))) {\n+            throw new ProviderException(\n+                    \"Generated secret is out-of-range of (1, p -1)\");\n+        }\n+\n@@ -330,1 +339,1 @@\n-        byte[] secret = this.y.modPow(this.x, modulus).toByteArray();\n+        byte[] secret = z.toByteArray();\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DHKeyAgreement.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1196,1 +1196,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n@@ -1226,1 +1226,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n@@ -1257,1 +1257,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n@@ -1286,1 +1286,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n@@ -1316,1 +1316,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,7 +36,0 @@\n- * <p>As of release 1.4, this exception has been retrofitted to conform to\n- * the general purpose exception-chaining mechanism.  The \"exception causing\n- * the abort\" that is provided at construction time and\n- * accessed via the public {@link #detail} field is now known as the\n- * <i>cause<\/i>, and may be accessed via the {@link Throwable#getCause()}\n- * method, as well as the aforementioned \"legacy field.\"\n- *\n@@ -52,3 +45,3 @@\n-     * <p>This field predates the general-purpose exception chaining facility.\n-     * The {@link Throwable#getCause()} method is now the preferred means of\n-     * obtaining this information.\n+     * @deprecated This field predates the general-purpose exception\n+     * chaining facility.  The {@link Throwable#getCause()} method is\n+     * now the preferred means of obtaining this information.\n@@ -58,0 +51,1 @@\n+    @Deprecated(since=\"17\")\n@@ -90,0 +84,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/io\/WriteAbortedException.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,7 +45,0 @@\n- * <p>As of release 1.4, this exception has been retrofitted to conform to\n- * the general purpose exception-chaining mechanism.  The \"optional exception\n- * that was raised while loading the class\" that may be provided at\n- * construction time and accessed via the {@link #getException()} method is\n- * now known as the <i>cause<\/i>, and may be accessed via the {@link\n- * Throwable#getCause()} method, as well as the aforementioned \"legacy method.\"\n- *\n@@ -98,1 +91,2 @@\n-     * <p>This method predates the general-purpose exception chaining facility.\n+     * @apiNote\n+     * This method predates the general-purpose exception chaining facility.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassNotFoundException.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,7 +39,0 @@\n- * <p>As of release 1.4, this exception has been retrofitted to conform to\n- * the general purpose exception-chaining mechanism.  The \"saved throwable\n- * object\" that may be provided at construction time and accessed via\n- * the {@link #getException()} method is now known as the <i>cause<\/i>,\n- * and may be accessed via the {@link Throwable#getCause()} method, as well\n- * as the aforementioned \"legacy method.\"\n- *\n@@ -95,1 +88,2 @@\n-     * <p>This method predates the general-purpose exception chaining facility.\n+     * @apiNote\n+     * This method predates the general-purpose exception chaining facility.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ExceptionInInitializerError.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,2 @@\n-     * <p>This implementation returns the result of {@link #intValue} cast\n+     * @implSpec\n+     * The default implementation returns the result of {@link #intValue} cast\n@@ -110,1 +111,2 @@\n-     * <p>This implementation returns the result of {@link #intValue} cast\n+     * @implSpec\n+     * The default implementation returns the result of {@link #intValue} cast\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Number.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1853,1 +1853,1 @@\n-            StringBuffer sb = new StringBuffer(\"LoopClauses -- \");\n+            StringBuilder sb = new StringBuilder(\"LoopClauses -- \");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,7 +32,0 @@\n- * <p>As of release 1.4, this exception has been retrofitted to conform to\n- * the general purpose exception-chaining mechanism.  The \"target exception\"\n- * that is provided at construction time and accessed via the\n- * {@link #getTargetException()} method is now known as the <i>cause<\/i>,\n- * and may be accessed via the {@link Throwable#getCause()} method,\n- * as well as the aforementioned \"legacy method.\"\n- *\n@@ -93,1 +86,2 @@\n-     * <p>This method predates the general-purpose exception chaining facility.\n+     * @apiNote\n+     * This method predates the general-purpose exception chaining facility.\n@@ -110,0 +104,1 @@\n+    @Override\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationTargetException.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,9 +51,0 @@\n- * <p>As of release 1.4, this exception has been retrofitted to\n- * conform to the general purpose exception-chaining mechanism.  The\n- * \"undeclared checked exception that was thrown by the invocation\n- * handler\" that may be provided at construction time and accessed via\n- * the {@link #getUndeclaredThrowable()} method is now known as the\n- * <i>cause<\/i>, and may be accessed via the {@link\n- * Throwable#getCause()} method, as well as the aforementioned \"legacy\n- * method.\"\n- *\n@@ -97,1 +88,2 @@\n-     * <p>This method predates the general-purpose exception chaining facility.\n+     * @apiNote\n+     * This method predates the general-purpose exception chaining facility.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/UndeclaredThrowableException.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -45,7 +45,0 @@\n- * <p>As of release 1.4, this exception has been retrofitted to conform to\n- * the general purpose exception-chaining mechanism.  The \"exception thrown\n- * by the privileged computation\" that is provided at construction time and\n- * accessed via the {@link #getException()} method is now known as the\n- * <i>cause<\/i>, and may be accessed via the {@link Throwable#getCause()}\n- * method, as well as the aforementioned \"legacy method.\"\n- *\n@@ -76,1 +69,2 @@\n-     * <p>This method predates the general-purpose exception chaining facility.\n+     * @apiNote\n+     * This method predates the general-purpose exception chaining facility.\n","filename":"src\/java.base\/share\/classes\/java\/security\/PrivilegedActionException.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-    public boolean isHexDigit(int ch) {\n+    public static boolean isHexDigit(int ch) {\n@@ -892,1 +892,0 @@\n-     * The delimiter, prefix, suffix, and uppercase parameters are not used.\n@@ -898,1 +897,1 @@\n-    public int fromHexDigit(int ch) {\n+    public static int fromHexDigit(int ch) {\n@@ -910,1 +909,0 @@\n-     * The delimiter, prefix, suffix, and uppercase parameters are not used.\n@@ -920,1 +918,1 @@\n-    private int fromHexDigits(CharSequence string, int index) {\n+    private static int fromHexDigits(CharSequence string, int index) {\n@@ -932,1 +930,0 @@\n-     * The delimiter, prefix, suffix, and uppercase parameters are not used.\n@@ -947,1 +944,1 @@\n-    public int fromHexDigits(CharSequence string) {\n+    public static int fromHexDigits(CharSequence string) {\n@@ -964,1 +961,0 @@\n-     * The delimiter, prefix, suffix, and uppercase parameters are not used.\n@@ -983,1 +979,1 @@\n-    public int fromHexDigits(CharSequence string, int fromIndex, int toIndex) {\n+    public static int fromHexDigits(CharSequence string, int fromIndex, int toIndex) {\n@@ -999,1 +995,0 @@\n-     * The delimiter, prefix, suffix, and uppercase parameters are not used.\n@@ -1014,1 +1009,1 @@\n-    public long fromHexDigitsToLong(CharSequence string) {\n+    public static long fromHexDigitsToLong(CharSequence string) {\n@@ -1031,1 +1026,0 @@\n-     * The delimiter, prefix, suffix, and uppercase parameters are not used.\n@@ -1050,1 +1044,1 @@\n-    public long fromHexDigitsToLong(CharSequence string, int fromIndex, int toIndex) {\n+    public static long fromHexDigitsToLong(CharSequence string, int fromIndex, int toIndex) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -3198,1 +3198,1 @@\n-                            assert e.getException() instanceof NoSuchMethodException;\n+                            assert e.getCause() instanceof NoSuchMethodException;\n@@ -3233,1 +3233,1 @@\n-                    throw (IOException) e.getException();\n+                    throw (IOException) e.getCause();\n","filename":"src\/java.base\/share\/classes\/java\/util\/ResourceBundle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.io.BufferedInputStream;\n@@ -55,2 +54,1 @@\n-        try (InputStream in = Files.newInputStream(file);\n-             BufferedInputStream bis = new BufferedInputStream(in)) {\n+        try (InputStream in = Files.newInputStream(file)) {\n@@ -58,2 +56,4 @@\n-            byte[] magic = new byte[4];\n-            bis.read(magic);\n+            byte[] magic = in.readNBytes(4);\n+            if (magic.length != 4) {\n+                throw new IOException(\"Invalid JMOD file: \" + file);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jmod\/JmodFile.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.StringJoiner;\n@@ -233,1 +232,1 @@\n-                StringBuffer sb = new StringBuffer();\n+                StringBuilder sb = new StringBuilder();\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotatedTypeFactory.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,2 @@\n-            throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type.\");\n+            throw new AnnotationFormatError(\"Attempt to create proxy for a non-annotation type: \" +\n+                                            type.getName());\n@@ -373,0 +374,2 @@\n+            if (memberMethod.isSynthetic())\n+                continue;\n@@ -493,0 +496,1 @@\n+        Method currentMethod = null;\n@@ -494,0 +498,12 @@\n+            currentMethod = method;\n+            int modifiers = method.getModifiers();\n+            \/\/ Skip over methods that may be a static initializer or\n+            \/\/ similar construct. A static initializer may be used for\n+            \/\/ purposes such as initializing a lambda stored in an\n+            \/\/ interface field.\n+            if (method.isSynthetic() &&\n+                (modifiers & (Modifier.STATIC | Modifier.PRIVATE)) != 0 &&\n+                method.getParameterCount() == 0) {\n+                continue;\n+            }\n+\n@@ -504,1 +520,1 @@\n-            if (method.getModifiers() != (Modifier.PUBLIC | Modifier.ABSTRACT) ||\n+            if (modifiers != (Modifier.PUBLIC | Modifier.ABSTRACT) ||\n@@ -565,1 +581,2 @@\n-            throw new AnnotationFormatError(\"Malformed method on an annotation type\");\n+            throw new AnnotationFormatError(\"Malformed method on an annotation type: \" +\n+                                            currentMethod.toString());\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationInvocationHandler.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -768,1 +768,1 @@\n-                                       ite.getTargetException().toString()};\n+                                       ite.getCause().toString()};\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/PolicyFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -818,1 +818,0 @@\n-        HexFormat hex = HexFormat.of();\n@@ -822,1 +821,1 @@\n-            if (hex.isHexDigit(chars[i])) {\n+            if (HexFormat.isHexDigit(chars[i])) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/RevocationChecker.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -409,0 +409,1 @@\n+                \/\/ All supported keyspecs (other than PKCS8_KEYSPEC_CLS) descend from RSA_PRIVCRT_KEYSPEC_CLS\n@@ -422,3 +423,13 @@\n-                } else {\n-                    throw new InvalidKeySpecException\n-                    (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n+                } else { \/\/ RSAPrivateKey (non-CRT)\n+                    if (!keySpec.isAssignableFrom(RSA_PRIV_KEYSPEC_CLS)) {\n+                        throw new InvalidKeySpecException\n+                            (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n+                    }\n+\n+                    \/\/ fall through to RSAPrivateKey (non-CRT)\n+                    RSAPrivateKey rsaKey = (RSAPrivateKey) key;\n+                    return keySpec.cast(new RSAPrivateKeySpec(\n+                        rsaKey.getModulus(),\n+                        rsaKey.getPrivateExponent(),\n+                        rsaKey.getParams()\n+                    ));\n@@ -426,7 +437,0 @@\n-            } else if (keySpec.isAssignableFrom(RSA_PRIV_KEYSPEC_CLS)) {\n-                RSAPrivateKey rsaKey = (RSAPrivateKey)key;\n-                return keySpec.cast(new RSAPrivateKeySpec(\n-                    rsaKey.getModulus(),\n-                    rsaKey.getPrivateExponent(),\n-                    rsaKey.getParams()\n-                ));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -692,6 +692,8 @@\n-            List<SignatureScheme> sss = new LinkedList<>();\n-            for (int id : crm.algorithmIds) {\n-                SignatureScheme ss = SignatureScheme.valueOf(id);\n-                if (ss != null) {\n-                    sss.add(ss);\n-                }\n+            List<SignatureScheme> sss =\n+                    SignatureScheme.getSupportedAlgorithms(\n+                            chc.sslConfig,\n+                            chc.algorithmConstraints, chc.negotiatedProtocol,\n+                            crm.algorithmIds);\n+            if (sss == null || sss.isEmpty()) {\n+                throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n@@ -699,0 +701,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateRequest.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -282,0 +282,4 @@\n+            if (sss == null || sss.isEmpty()) {\n+                throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n+            }\n@@ -333,1 +337,1 @@\n-                    \"received CertificateRequest handshake message\");\n+                    \"received ClientHello handshake message\");\n@@ -506,0 +510,4 @@\n+            if (sss == null || sss.isEmpty()) {\n+                throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,\n+                        \"No supported signature algorithm\");\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureAlgorithmsExtension.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.security.spec.AlgorithmParameterSpec;\n@@ -4577,1 +4576,0 @@\n-                        HexFormat hexFmt = HexFormat.of();\n@@ -4583,1 +4581,1 @@\n-                                if (!hexFmt.isHexDigit(c)) {\n+                                if (!HexFormat.isHexDigit(c)) {\n@@ -4586,1 +4584,1 @@\n-                                int hex = hexFmt.fromHexDigit(c);\n+                                int hex = HexFormat.fromHexDigit(c);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.security.AccessController;\n@@ -254,1 +253,0 @@\n-        HexFormat hex = HexFormat.of();\n@@ -266,1 +264,1 @@\n-                int cVal = hex.fromHexDigit(c);     \/\/ throws on invalid character\n+                int cVal = HexFormat.fromHexDigit(c);     \/\/ throws on invalid character\n@@ -505,2 +503,1 @@\n-        HexFormat hex = HexFormat.of();\n-        if (hex.isHexDigit(c1)) {\n+        if (HexFormat.isHexDigit(c1)) {\n@@ -510,3 +507,3 @@\n-            if (hex.isHexDigit(c2)) {\n-                int hi = hex.fromHexDigit(c1);\n-                int lo = hex.fromHexDigit(c2);\n+            if (HexFormat.isHexDigit(c2)) {\n+                int hi = HexFormat.fromHexDigit(c1);\n+                int lo = HexFormat.fromHexDigit(c2);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AVA.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-            throw new CRLException(invk.getTargetException().getMessage());\n+            throw new CRLException(invk.getCause().getMessage());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CRLExtensions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-            Throwable e = invk.getTargetException();\n+            Throwable e = invk.getCause();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/CertificateExtensions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -288,1 +288,1 @@\n-            if (dstoffset > 0 && tz.getOffset(msec - dstoffset) == rawoffset) {\n+            if (dstoffset > 0 && tz.getOffset(msec - dstoffset) == rawoffset && type == WALL_TIME) {\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/ZoneInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-            throw (IOException) ex.getException();\n+            throw (IOException) ex.getCause();\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.ref.Reference;\n@@ -48,0 +49,11 @@\n+    private static final int MIN_LISTXATTR_BUF_SIZE = 1024;\n+    private static final int MAX_LISTXATTR_BUF_SIZE = 32 * 1024;\n+\n+    private final UnixPath file;\n+    private final boolean followLinks;\n+\n+    UnixUserDefinedFileAttributeView(UnixPath file, boolean followLinks) {\n+        this.file = file;\n+        this.followLinks = followLinks;\n+    }\n+\n@@ -60,0 +72,5 @@\n+    \/**\n+     * @return the maximum supported length of xattr names (in bytes, including namespace)\n+     *\/\n+    protected abstract int maxNameLength();\n+\n@@ -61,1 +78,1 @@\n-    private List<String> asList(long address, int size) {\n+    private static List<String> asList(long address, int size) {\n@@ -72,4 +89,1 @@\n-                if (s.startsWith(USER_NAMESPACE)) {\n-                    s = s.substring(USER_NAMESPACE.length());\n-                    list.add(s);\n-                }\n+                list.add(s);\n@@ -83,6 +97,14 @@\n-    private final UnixPath file;\n-    private final boolean followLinks;\n-\n-    UnixUserDefinedFileAttributeView(UnixPath file, boolean followLinks) {\n-        this.file = file;\n-        this.followLinks = followLinks;\n+    \/\/ runs flistxattr, increases buffer size up to MAX_LISTXATTR_BUF_SIZE if required\n+    private static List<String> list(int fd, int bufSize) throws UnixException {\n+        try {\n+            try (NativeBuffer buffer = NativeBuffers.getNativeBuffer(bufSize)) {\n+                int n = flistxattr(fd, buffer.address(), bufSize);\n+                return asList(buffer.address(), n);\n+            } \/\/ release buffer before recursion\n+        } catch (UnixException x) {\n+            if (x.errno() == ERANGE && bufSize < MAX_LISTXATTR_BUF_SIZE) {\n+                return list(fd, bufSize * 2); \/\/ try larger buffer size:\n+            } else {\n+                throw x;\n+            }\n+        }\n@@ -91,5 +113,0 @@\n-    \/**\n-     * @return the maximum supported length of xattr names (in bytes, including namespace)\n-     *\/\n-    protected abstract int maxNameLength();\n-\n@@ -107,1 +124,0 @@\n-        NativeBuffer buffer = null;\n@@ -109,21 +125,9 @@\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n-                try {\n-                    int n = flistxattr(fd, buffer.address(), size);\n-                    List<String> list = asList(buffer.address(), n);\n-                    return Collections.unmodifiableList(list);\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-                    throw new FileSystemException(file.getPathForExceptionMessage(),\n-                        null, \"Unable to get list of extended attributes: \" +\n-                        x.getMessage());\n-                }\n-            }\n+            List<String> attrNames = list(fd, MIN_LISTXATTR_BUF_SIZE);\n+            return attrNames.stream()\n+                    .filter(s -> s.startsWith(USER_NAMESPACE))\n+                    .map(s -> s.substring(USER_NAMESPACE.length()))\n+                    .toList();\n+        } catch (UnixException x) {\n+            throw new FileSystemException(file.getPathForExceptionMessage(),\n+                null, \"Unable to get list of extended attributes: \" +\n+                x.getMessage());\n@@ -131,2 +135,0 @@\n-            if (buffer != null)\n-                buffer.release();\n@@ -172,5 +174,9 @@\n-        NativeBuffer nb;\n-        long address;\n-        if (dst instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)dst).address() + pos;\n+        if (dst instanceof sun.nio.ch.DirectBuffer buf) {\n+            try {\n+                long address = buf.address() + pos;\n+                int n = read(name, address, rem);\n+                dst.position(pos + n);\n+                return n;\n+            } finally {\n+                Reference.reachabilityFence(buf);\n+            }\n@@ -178,3 +184,11 @@\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n+            try (NativeBuffer nb = NativeBuffers.getNativeBuffer(rem)) {\n+                long address = nb.address();\n+                int n = read(name, address, rem);\n+\n+                \/\/ copy from buffer into backing array\n+                int off = dst.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+                unsafe.copyMemory(null, address, dst.array(), off, n);\n+                dst.position(pos + n);\n+\n+                return n;\n+            }\n@@ -182,0 +196,1 @@\n+    }\n@@ -183,0 +198,1 @@\n+    private int read(String name, long address, int rem) throws IOException {\n@@ -190,2 +206,1 @@\n-            try {\n-                int n = fgetxattr(fd, nameAsBytes(file,name), address, rem);\n+            int n = fgetxattr(fd, nameAsBytes(file, name), address, rem);\n@@ -193,16 +208,9 @@\n-                \/\/ if remaining is zero then fgetxattr returns the size\n-                if (rem == 0) {\n-                    if (n > 0)\n-                        throw new UnixException(ERANGE);\n-                    return 0;\n-                }\n-\n-                \/\/ copy from buffer into backing array if necessary\n-                if (nb != null) {\n-                    int off = dst.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                    unsafe.copyMemory(null, address, dst.array(), off, n);\n-                }\n-                dst.position(pos + n);\n-                return n;\n-            } catch (UnixException x) {\n-                String msg = (x.errno() == ERANGE) ?\n+            \/\/ if remaining is zero then fgetxattr returns the size\n+            if (rem == 0) {\n+                if (n > 0)\n+                    throw new UnixException(ERANGE);\n+                return 0;\n+            }\n+            return n;\n+        } catch (UnixException x) {\n+            String msg = (x.errno() == ERANGE) ?\n@@ -210,1 +218,1 @@\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n+            throw new FileSystemException(file.getPathForExceptionMessage(),\n@@ -212,3 +220,0 @@\n-            } finally {\n-                close(fd);\n-            }\n@@ -216,2 +221,1 @@\n-            if (nb != null)\n-                nb.release();\n+            close(fd);\n@@ -221,0 +225,1 @@\n+    @Override\n@@ -230,5 +235,9 @@\n-        NativeBuffer nb;\n-        long address;\n-        if (src instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)src).address() + pos;\n+        if (src instanceof sun.nio.ch.DirectBuffer buf) {\n+            try {\n+                long address = buf.address() + pos;\n+                write(name, address, rem);\n+                src.position(pos + rem);\n+                return rem;\n+            } finally {\n+                Reference.reachabilityFence(buf);\n+            }\n@@ -236,15 +245,19 @@\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n-\n-            if (src.hasArray()) {\n-                \/\/ copy from backing array into buffer\n-                int off = src.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                unsafe.copyMemory(src.array(), off, null, address, rem);\n-            } else {\n-                \/\/ backing array not accessible so transfer via temporary array\n-                byte[] tmp = new byte[rem];\n-                src.get(tmp);\n-                src.position(pos);  \/\/ reset position as write may fail\n-                unsafe.copyMemory(tmp, Unsafe.ARRAY_BYTE_BASE_OFFSET, null,\n-                    address, rem);\n+            try (NativeBuffer nb = NativeBuffers.getNativeBuffer(rem)) {\n+                long address = nb.address();\n+\n+                if (src.hasArray()) {\n+                    \/\/ copy from backing array into buffer\n+                    int off = src.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+                    unsafe.copyMemory(src.array(), off, null, address, rem);\n+                } else {\n+                    \/\/ backing array not accessible so transfer via temporary array\n+                    byte[] tmp = new byte[rem];\n+                    src.get(tmp);\n+                    src.position(pos);  \/\/ reset position as write may fail\n+                    unsafe.copyMemory(tmp, Unsafe.ARRAY_BYTE_BASE_OFFSET, null,\n+                            address, rem);\n+                }\n+\n+                write(name, address, rem);\n+                src.position(pos + rem);\n+                return rem;\n@@ -253,0 +266,1 @@\n+    }\n@@ -254,0 +268,1 @@\n+    private void write(String name, long address, int rem) throws IOException {\n@@ -261,6 +276,3 @@\n-            try {\n-                fsetxattr(fd, nameAsBytes(file,name), address, rem);\n-                src.position(pos + rem);\n-                return rem;\n-            } catch (UnixException x) {\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n+            fsetxattr(fd, nameAsBytes(file,name), address, rem);\n+        } catch (UnixException x) {\n+            throw new FileSystemException(file.getPathForExceptionMessage(),\n@@ -269,3 +281,0 @@\n-            } finally {\n-                close(fd);\n-            }\n@@ -273,2 +282,1 @@\n-            if (nb != null)\n-                nb.release();\n+            close(fd);\n@@ -308,1 +316,0 @@\n-        NativeBuffer buffer = null;\n@@ -310,5 +317,2 @@\n-\n-            \/\/ call flistxattr to get list of extended attributes.\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n+            List<String> attrNames = list(ofd, MIN_LISTXATTR_BUF_SIZE);\n+            for (String name : attrNames) {\n@@ -316,36 +320,3 @@\n-                    size = flistxattr(ofd, buffer.address(), size);\n-                    break;\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-\n-                    \/\/ unable to get list of attributes\n-                    return;\n-                }\n-            }\n-\n-            \/\/ parse buffer as array of NULL-terminated C strings.\n-            long address = buffer.address();\n-            int start = 0;\n-            int pos = 0;\n-            while (pos < size) {\n-                if (unsafe.getByte(address + pos) == 0) {\n-                    \/\/ extract attribute name and copy attribute to target.\n-                    \/\/ FIXME: We can avoid needless copying by using address+pos\n-                    \/\/ as the address of the name.\n-                    int len = pos - start;\n-                    byte[] name = new byte[len];\n-                    unsafe.copyMemory(null, address+start, name,\n-                        Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n-                    try {\n-                        copyExtendedAttribute(ofd, name, nfd);\n-                    } catch (UnixException ignore) {\n-                        \/\/ ignore\n-                    }\n-                    start = pos + 1;\n+                    copyExtendedAttribute(ofd, Util.toBytes(name), nfd);\n+                } catch(UnixException ignore){\n+                    \/\/ ignore\n@@ -353,1 +324,0 @@\n-                pos++;\n@@ -355,4 +325,3 @@\n-\n-        } finally {\n-            if (buffer != null)\n-                buffer.release();\n+        } catch (UnixException e) {\n+            \/\/ unable to get list of attributes\n+            return;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":119,"deletions":150,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -378,1 +378,1 @@\n-    result == -1;\n+    result = -1;\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import java.util.Map;\n@@ -323,4 +322,3 @@\n-            StringBuffer message =  new StringBuffer(\"An exception occurred\" +\n-                                       \" during the execution of select(): \\n\");\n-            message.append(exception);\n-            message.append('\\n');\n+            String message = \"An exception occurred\" +\n+                    \" during the execution of select(): \\n\" +\n+                    exception + '\\n';\n@@ -328,1 +326,1 @@\n-            throw new IOException(message.toString());\n+            throw new IOException(message);\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/WindowsSelectorImpl.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,2 +331,5 @@\n-                CloseHandle(handle);\n-                throw x;\n+                \/\/ ignore exception if file size is zero\n+                if (GetFileSizeEx(handle) != 0) {\n+                    CloseHandle(handle);\n+                    throw x;\n+                }\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsChannelFactory.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -175,0 +175,10 @@\n+    \/**\n+     * Retrieves the size of the specified file.\n+     *\n+     * BOOL GetFileSizeEx(\n+     *   HANDLE hFile,\n+     *   PLARGE_INTEGER lpFileSize\n+     * )\n+     *\/\n+    static native long GetFileSizeEx(long handle) throws WindowsException;\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsNativeDispatcher.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -312,0 +312,12 @@\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_fs_WindowsNativeDispatcher_GetFileSizeEx(JNIEnv *env,\n+    jclass this, jlong handle)\n+{\n+    HANDLE h = (HANDLE)jlong_to_ptr(handle);\n+    LARGE_INTEGER size;\n+    if (GetFileSizeEx(h, &size) == 0) {\n+        throwWindowsException(env, GetLastError());\n+    }\n+    return long_to_jlong(size.QuadPart);\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/fs\/WindowsNativeDispatcher.c","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -434,1 +434,1 @@\n-        @SuppressWarnings(\"deprecation\")\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaInternalFrameUI.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n-\/\/ <https:\/\/docs.oracle.com\/javase\/8\/docs\/technotes\/guides\/access\/index.html>\n-\/\/ <http:\/\/www-106.ibm.com\/developerworks\/library\/j-access\/?n-j-10172>\n-\/\/ <http:\/\/archives.java.sun.com\/archives\/java-access.html> (Sun's mailing list for Java accessibility)\n+\/\/ <https:\/\/docs.oracle.com\/en\/java\/javase\/11\/access\/java-accessibility-overview.html>\n+\/\/ <https:\/\/www.ibm.com\/able\/guidelines\/java\/snsjavagjfc.html>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/JavaComponentAccessibility.m","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -108,1 +108,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/SwingUtilities3.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-@SuppressWarnings(\"deprecation\")\n+@SuppressWarnings({\"deprecation\", \"removal\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/JavaSoundAudioClip.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-@Deprecated(since = \"9\")\n+@Deprecated(since = \"9\", forRemoval = true)\n+@SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/java\/applet\/Applet.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,2 @@\n-@Deprecated(since = \"9\")\n+@Deprecated(since = \"9\", forRemoval = true)\n+@SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/java\/applet\/AppletContext.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,2 @@\n-@Deprecated(since = \"9\")\n+@Deprecated(since = \"9\", forRemoval = true)\n+@SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/java\/applet\/AppletStub.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-@Deprecated(since = \"9\")\n+@Deprecated(since = \"9\", forRemoval = true)\n","filename":"src\/java.desktop\/share\/classes\/java\/applet\/AudioClip.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,5 @@\n- * The APIs in this package are all deprecated without replacement.\n+ * This package has been deprecated and may be removed in\n+ * a future version of the Java Platform. There is no replacement.\n+ * All of the classes and interfaces in this package have been terminally\n+ * deprecated.\n+ * Users are advised to migrate their applications to other technologies.\n","filename":"src\/java.desktop\/share\/classes\/java\/applet\/package-info.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4050,1 +4050,1 @@\n-        @SuppressWarnings(\"deprecation\")\n+        @SuppressWarnings(\"removal\")\n@@ -8182,1 +8182,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Component.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-@Deprecated(since = \"9\")\n+@Deprecated(since = \"9\", forRemoval = true)\n@@ -76,0 +76,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -87,0 +88,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/AppletInitializer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -170,1 +170,2 @@\n-    @Deprecated(since = \"9\")\n+    @Deprecated(since = \"9\", forRemoval = true)\n+    @SuppressWarnings(\"removal\")\n@@ -519,1 +520,2 @@\n-@Deprecated(since = \"9\")\n+@Deprecated(since = \"9\", forRemoval = true)\n+@SuppressWarnings(\"removal\")\n@@ -604,1 +606,2 @@\n-@Deprecated(since = \"9\")\n+@Deprecated(since = \"9\", forRemoval = true)\n+@SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/Beans.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -488,1 +488,1 @@\n-                Throwable th = ex.getTargetException();\n+                Throwable th = ex.getCause();\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/EventHandler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -316,1 +316,1 @@\n-                Throwable te = ite.getTargetException();\n+                Throwable te = ite.getCause();\n","filename":"src\/java.desktop\/share\/classes\/java\/beans\/Statement.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-@Deprecated(since = \"9\")\n+@Deprecated(since = \"9\", forRemoval = true)\n@@ -102,1 +102,1 @@\n-@SuppressWarnings(\"serial\") \/\/ Same-version serialization only\n+@SuppressWarnings({\"serial\", \"removal\"}) \/\/ Same-version serialization only\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JApplet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -602,1 +602,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -659,2 +659,3 @@\n-     * Resets the UI property to a value from the current look and feel.\n-     * <code>JComponent<\/code> subclasses must override this method\n+     * This method is called to update the UI property to a value from the\n+     * current look and feel.\n+     * {@code JComponent} subclasses must override this method\n@@ -668,0 +669,2 @@\n+     * @implSpec The default implementation of this method does nothing.\n+     *\n@@ -2934,1 +2937,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings({\"deprecation\", \"removal\"})\n@@ -2963,1 +2966,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings({\"deprecation\", \"removal\"})\n@@ -4521,1 +4524,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -4690,1 +4693,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -5098,1 +5101,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComponent.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -6090,1 +6090,1 @@\n-        @SuppressWarnings(\"deprecation\")\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,1 @@\n-     @SuppressWarnings(\"deprecation\")\n+     @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/KeyboardManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -278,1 +278,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -633,1 +633,1 @@\n-        @SuppressWarnings(\"deprecation\")\n+        @SuppressWarnings(\"removal\")\n@@ -804,1 +804,1 @@\n-        @SuppressWarnings(\"deprecation\")\n+        @SuppressWarnings(\"removal\")\n@@ -959,1 +959,1 @@\n-        @SuppressWarnings(\"deprecation\")\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/PopupFactory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -423,1 +423,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -541,1 +541,2 @@\n-    @Deprecated(since = \"9\")\n+    @Deprecated(since = \"9\", forRemoval = true)\n+    @SuppressWarnings(\"removal\")\n@@ -546,1 +547,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -424,1 +424,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -464,1 +464,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -1665,1 +1665,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -1706,1 +1706,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n@@ -2221,1 +2221,1 @@\n-    @SuppressWarnings(\"deprecation\")\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingUtilities.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -787,1 +787,1 @@\n- @SuppressWarnings(\"deprecation\")\n+ @SuppressWarnings(\"removal\")\n@@ -813,1 +813,1 @@\n-  @SuppressWarnings(\"deprecation\")\n+  @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/ToolTipManager.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -935,1 +935,1 @@\n-        @SuppressWarnings(\"deprecation\")\n+        @SuppressWarnings(\"removal\")\n@@ -1153,1 +1153,1 @@\n-        @SuppressWarnings(\"deprecation\")\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicPopupMenuUI.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-    private static final ColorUIResource controlHighlight = new\n-                              ColorUIResource(102, 102, 102);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalHighContrastTheme.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -525,1 +525,2 @@\n-    @Deprecated(since = \"9\")\n+    @Deprecated(since = \"9\", forRemoval = true)\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/EmbeddedFrame.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.io.BufferedInputStream;\n@@ -55,4 +54,2 @@\n-        InputStream is =\n-            new BufferedInputStream(new ByteArrayInputStream(imagedata,\n-                                                             imageoffset,\n-                                                             imagelength));\n+        InputStream is = new ByteArrayInputStream(imagedata, imageoffset,\n+                imagelength);\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ByteArrayImageSource.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -28,0 +29,1 @@\n+import java.awt.image.ColorModel;\n@@ -30,1 +32,0 @@\n-import java.awt.image.ColorModel;\n@@ -32,1 +33,1 @@\n-import java.awt.image.SampleModel;\n+\n@@ -34,1 +35,0 @@\n-import sun.awt.image.ShortComponentRaster;\n@@ -36,0 +36,1 @@\n+import sun.awt.image.ShortComponentRaster;\n@@ -37,1 +38,1 @@\n-class LCMSImageLayout {\n+final class LCMSImageLayout {\n@@ -198,1 +199,6 @@\n-                if (cm instanceof ComponentColorModel) {\n+                \/* todo\n+                 * Our generic code for rasters does not support alpha channels,\n+                 * but it would be good to improve it when it is used from here.\n+                 * See \"createImageLayout(image.getRaster())\" below.\n+                 *\/\n+                if (!cm.hasAlpha() && cm instanceof ComponentColorModel) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSImageLayout.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-public class LCMSTransform implements ColorTransform {\n+final class LCMSTransform implements ColorTransform {\n@@ -152,0 +152,16 @@\n+    \/**\n+     * Returns {@code true} if lcms may supports this format directly.\n+     *\/\n+    private static boolean isLCMSSupport(BufferedImage src, BufferedImage dst) {\n+        if (!dst.getColorModel().hasAlpha()) {\n+            return true;\n+        }\n+        \/\/ lcms as of now does not support pre-alpha\n+        if (src.isAlphaPremultiplied() || dst.isAlphaPremultiplied()) {\n+            return false;\n+        }\n+        \/\/ lcms does not set correct alpha for transparent dst if src is opaque\n+        \/\/ is it feature or bug?\n+        return dst.getColorModel().hasAlpha() == src.getColorModel().hasAlpha();\n+    }\n+\n@@ -155,1 +171,1 @@\n-            if (!dst.getColorModel().hasAlpha()) {\n+            if (isLCMSSupport(src, dst)) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-        inFormatter, outFormatter, renderType, 0);\n+        inFormatter, outFormatter, renderType, cmsFLAGS_COPY_ALPHA);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/LCMS.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,2 @@\n+    private static final float precisionScale = 1000.0f;\n+\n@@ -1722,0 +1724,5 @@\n+    private void precisionScaleUp(float[] values, int size) {\n+        for (int i = 0; i < size; i++) {\n+            values[i] = values[i] * precisionScale;\n+        }\n+    }\n@@ -1746,0 +1753,1 @@\n+        wPrinterJob.scaleTransform(1.0f \/ precisionScale);\n@@ -1753,0 +1761,1 @@\n+                precisionScaleUp(segment, 2);\n@@ -1757,0 +1766,1 @@\n+                precisionScaleUp(segment, 2);\n@@ -1763,0 +1773,1 @@\n+                precisionScaleUp(segment, 4);\n@@ -1775,0 +1786,1 @@\n+                precisionScaleUp(segment, 6);\n@@ -1790,0 +1802,1 @@\n+        wPrinterJob.restoreTransform();\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPathGraphics.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -365,0 +365,3 @@\n+    private int graphicsMode;\n+    private double[] worldTransform = new double[6];\n+\n@@ -963,0 +966,11 @@\n+    protected void scaleTransform(float scale) {\n+        graphicsMode = setAdvancedGraphicsMode();\n+        getWorldTransform(worldTransform);\n+        scale(scale, scale);\n+    }\n+\n+    protected void restoreTransform() {\n+        setWorldTransform(worldTransform);\n+        setGraphicsMode(graphicsMode);\n+    }\n+\n@@ -998,0 +1012,38 @@\n+    \/**\n+     * Set the GDI graphics mode to {@code GM_ADVANCED}.\n+     *\/\n+    private int setAdvancedGraphicsMode() {\n+        return setAdvancedGraphicsMode(getPrintDC());\n+    }\n+\n+    \/**\n+     * Set the GDI graphics mode.\n+     * The {@code mode} should\n+     * be one of the following Windows constants:\n+     * {@code GM_COMPATIBLE} or {@code GM_ADVANCED}.\n+     *\/\n+    private void setGraphicsMode(int mode) {\n+        setGraphicsMode(getPrintDC(), mode);\n+    }\n+\n+    \/**\n+     * Scale the GDI World Transform.\n+     *\/\n+    private void scale(double scaleX, double scaleY) {\n+        scale(getPrintDC(), scaleX, scaleY);\n+    }\n+\n+    \/**\n+     * Get the GDI World Transform.\n+     *\/\n+    private void getWorldTransform(double[] transform) {\n+        getWorldTransform(getPrintDC(), transform);\n+    }\n+\n+    \/**\n+     * Set the GDI World Transform.\n+     *\/\n+    private void setWorldTransform(double[] transform) {\n+        setWorldTransform(getPrintDC(), transform);\n+    }\n+\n@@ -1473,0 +1525,33 @@\n+    \/**\n+     * Set the GDI graphics mode to {@code GM_ADVANCED}\n+     * into the device context {@code printDC}.\n+     *\/\n+    protected native int setAdvancedGraphicsMode(long printDC);\n+\n+    \/**\n+     * Set the GDI graphics {@code mode}\n+     * into the device context {@code printDC}.\n+     * The {@code mode} should\n+     * be one of the following Windows constants:\n+     * {@code GM_COMPATIBLE} or {@code GM_ADVANCED}.\n+     *\/\n+    protected native void setGraphicsMode(long printDC, int mode);\n+\n+    \/**\n+     * Scale the GDI World Transform\n+     * of the device context {@code printDC}.\n+     *\/\n+    protected native void scale(long printDC, double scaleX, double scaleY);\n+\n+    \/**\n+     * Get the GDI World Transform\n+     * from the device context {@code printDC}.\n+     *\/\n+    protected native void getWorldTransform(long printDC, double[] transform);\n+\n+    \/**\n+     * Set the GDI World Transform\n+     * into the device context {@code printDC}.\n+     *\/\n+    protected native void setWorldTransform(long printDC, double[] transform);\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPrinterJob.java","additions":86,"deletions":1,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1934,0 +1934,111 @@\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    setAdvancedGraphicsMode\n+ * Signature: (J)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_sun_awt_windows_WPrinterJob_setAdvancedGraphicsMode\n+(JNIEnv *env, jobject self, jlong printDC) {\n+    TRY;\n+\n+    int oldGraphicsMode = ::SetGraphicsMode((HDC)printDC, GM_ADVANCED);\n+    DASSERT(oldGraphicsMode != 0);\n+    return (jint) oldGraphicsMode;\n+\n+    CATCH_BAD_ALLOC_RET(0);\n+}\n+\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    setGraphicsMode\n+ * Signature: (JI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_setGraphicsMode\n+(JNIEnv *env, jobject self, jlong printDC, jint mode) {\n+    TRY;\n+\n+    int oldGraphicsMode = ::SetGraphicsMode((HDC)printDC, mode);\n+    DASSERT(oldGraphicsMode != 0);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    scale\n+ * Signature: (JDD)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_scale\n+(JNIEnv *env, jobject self, jlong printDC, jdouble scaleX, jdouble scaleY) {\n+    TRY;\n+\n+    XFORM xForm;\n+\n+    xForm.eM11 = (FLOAT) scaleX;\n+    xForm.eM12 = (FLOAT) 0;\n+    xForm.eM21 = (FLOAT) 0;\n+    xForm.eM22 = (FLOAT) scaleY;\n+    xForm.eDx  = (FLOAT) 0;\n+    xForm.eDy  = (FLOAT) 0;\n+\n+    BOOL result = ::ModifyWorldTransform((HDC)printDC, &xForm, MWT_RIGHTMULTIPLY);\n+    DASSERT(result);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    getWorldTransform\n+ * Signature: (J[D)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_getWorldTransform\n+(JNIEnv* env, jobject self, jlong printDC, jdoubleArray transform) {\n+    TRY;\n+\n+    double elems[6];\n+    XFORM xForm;\n+\n+    BOOL result = ::GetWorldTransform((HDC)printDC, &xForm);\n+    DASSERT(result);\n+\n+    elems[0] = (double) xForm.eM11;\n+    elems[1] = (double) xForm.eM12;\n+    elems[2] = (double) xForm.eM21;\n+    elems[3] = (double) xForm.eM22;\n+    elems[4] = (double) xForm.eDx;\n+    elems[5] = (double) xForm.eDy;\n+\n+    env->SetDoubleArrayRegion(transform, 0, 6, elems);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    setWorldTransform\n+ * Signature: (J[D)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_setWorldTransform\n+(JNIEnv* env, jobject self, jlong printDC, jdoubleArray transform) {\n+    TRY;\n+\n+    double *elems;\n+    XFORM xForm;\n+\n+    elems = env->GetDoubleArrayElements(transform, 0);\n+\n+    xForm.eM11 = (FLOAT) elems[0];\n+    xForm.eM12 = (FLOAT) elems[1];\n+    xForm.eM21 = (FLOAT) elems[2];\n+    xForm.eM22 = (FLOAT) elems[3];\n+    xForm.eDx  = (FLOAT) elems[4];\n+    xForm.eDy  = (FLOAT) elems[5];\n+\n+    env->ReleaseDoubleArrayElements(transform, elems, 0);\n+\n+    BOOL result = ::SetWorldTransform((HDC)printDC, &xForm);\n+    DASSERT(result);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":112,"deletions":1,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-            Throwable t = e.getTargetException();\n+            Throwable t = e.getCause();\n@@ -321,1 +321,1 @@\n-            Throwable th = e.getTargetException();\n+            Throwable th = e.getCause();\n","filename":"src\/java.management\/share\/classes\/com\/sun\/jmx\/mbeanserver\/MBeanInstantiator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1204,1 +1204,1 @@\n-            Throwable mmbTargEx = ite.getTargetException();\n+            Throwable mmbTargEx = ite.getCause();\n","filename":"src\/java.management\/share\/classes\/javax\/management\/modelmbean\/RequiredModelMBean.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-            Throwable realException = e.getTargetException();\n+            Throwable realException = e.getCause();\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/Connection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1085,1 +1085,1 @@\n-    @Deprecated\n+    @Deprecated(since = \"9\", forRemoval = true)\n","filename":"src\/java.naming\/share\/classes\/javax\/naming\/Context.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1488,1 +1488,1 @@\n-                Throwable targetException = e.getTargetException();\n+                Throwable targetException = e.getCause();\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/Activation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-                                          e.getTargetException());\n+                                          e.getCause());\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/ActivationGroupImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.util.Map;\n-import java.util.Iterator;\n@@ -144,1 +142,1 @@\n-            context.setBindings(bindings, ScriptContext.GLOBAL_SCOPE);;\n+            context.setBindings(bindings, ScriptContext.GLOBAL_SCOPE);\n@@ -146,1 +144,1 @@\n-            context.setBindings(bindings, ScriptContext.ENGINE_SCOPE);;\n+            context.setBindings(bindings, ScriptContext.ENGINE_SCOPE);\n","filename":"src\/java.scripting\/share\/classes\/javax\/script\/AbstractScriptEngine.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n@@ -61,2 +63,1 @@\n-        ClassLoader ctxtLoader = Thread.currentThread().getContextClassLoader();\n-        init(ctxtLoader);\n+        this(Thread.currentThread().getContextClassLoader());\n@@ -75,12 +76,0 @@\n-        init(loader);\n-    }\n-\n-    private void init(final ClassLoader loader) {\n-        globalScope = new SimpleBindings();\n-        engineSpis = new TreeSet<ScriptEngineFactory>(Comparator.comparing(\n-            ScriptEngineFactory::getEngineName,\n-            Comparator.nullsLast(Comparator.naturalOrder()))\n-        );\n-        nameAssociations = new HashMap<String, ScriptEngineFactory>();\n-        extensionAssociations = new HashMap<String, ScriptEngineFactory>();\n-        mimeTypeAssociations = new HashMap<String, ScriptEngineFactory>();\n@@ -99,1 +88,1 @@\n-        Iterator<ScriptEngineFactory> itr = null;\n+        Iterator<ScriptEngineFactory> itr;\n@@ -101,8 +90,2 @@\n-            ServiceLoader<ScriptEngineFactory> sl = AccessController.doPrivileged(\n-                new PrivilegedAction<ServiceLoader<ScriptEngineFactory>>() {\n-                    @Override\n-                    public ServiceLoader<ScriptEngineFactory> run() {\n-                        return getServiceLoader(loader);\n-                    }\n-                });\n-\n+            var sl = AccessController.doPrivileged(\n+                (PrivilegedAction<ServiceLoader<ScriptEngineFactory>>)() -> getServiceLoader(loader));\n@@ -111,5 +94,1 @@\n-            System.err.println(\"Can't find ScriptEngineFactory providers: \" +\n-                          err.getMessage());\n-            if (DEBUG) {\n-                err.printStackTrace();\n-            }\n+            reportException(\"Can't find ScriptEngineFactory providers: \", err);\n@@ -128,5 +107,1 @@\n-                    System.err.println(\"ScriptEngineManager providers.next(): \"\n-                                 + err.getMessage());\n-                    if (DEBUG) {\n-                        err.printStackTrace();\n-                    }\n+                    reportException(\"ScriptEngineManager providers.next(): \", err);\n@@ -134,1 +109,0 @@\n-                    continue;\n@@ -138,5 +112,1 @@\n-            System.err.println(\"ScriptEngineManager providers.hasNext(): \"\n-                            + err.getMessage());\n-            if (DEBUG) {\n-                err.printStackTrace();\n-            }\n+            reportException(\"ScriptEngineManager providers.hasNext(): \", err);\n@@ -146,1 +116,0 @@\n-            return;\n@@ -215,38 +184,1 @@\n-        if (shortName == null) throw new NullPointerException();\n-        \/\/look for registered name first\n-        Object obj;\n-        if (null != (obj = nameAssociations.get(shortName))) {\n-            ScriptEngineFactory spi = (ScriptEngineFactory)obj;\n-            try {\n-                ScriptEngine engine = spi.getScriptEngine();\n-                engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n-                return engine;\n-            } catch (Exception exp) {\n-                if (DEBUG) exp.printStackTrace();\n-            }\n-        }\n-\n-        for (ScriptEngineFactory spi : engineSpis) {\n-            List<String> names = null;\n-            try {\n-                names = spi.getNames();\n-            } catch (Exception exp) {\n-                if (DEBUG) exp.printStackTrace();\n-            }\n-\n-            if (names != null) {\n-                for (String name : names) {\n-                    if (shortName.equals(name)) {\n-                        try {\n-                            ScriptEngine engine = spi.getScriptEngine();\n-                            engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n-                            return engine;\n-                        } catch (Exception exp) {\n-                            if (DEBUG) exp.printStackTrace();\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-\n-        return null;\n+        return getEngineBy(shortName, nameAssociations, ScriptEngineFactory::getNames);\n@@ -266,35 +198,1 @@\n-        if (extension == null) throw new NullPointerException();\n-        \/\/look for registered extension first\n-        Object obj;\n-        if (null != (obj = extensionAssociations.get(extension))) {\n-            ScriptEngineFactory spi = (ScriptEngineFactory)obj;\n-            try {\n-                ScriptEngine engine = spi.getScriptEngine();\n-                engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n-                return engine;\n-            } catch (Exception exp) {\n-                if (DEBUG) exp.printStackTrace();\n-            }\n-        }\n-\n-        for (ScriptEngineFactory spi : engineSpis) {\n-            List<String> exts = null;\n-            try {\n-                exts = spi.getExtensions();\n-            } catch (Exception exp) {\n-                if (DEBUG) exp.printStackTrace();\n-            }\n-            if (exts == null) continue;\n-            for (String ext : exts) {\n-                if (extension.equals(ext)) {\n-                    try {\n-                        ScriptEngine engine = spi.getScriptEngine();\n-                        engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n-                        return engine;\n-                    } catch (Exception exp) {\n-                        if (DEBUG) exp.printStackTrace();\n-                    }\n-                }\n-            }\n-        }\n-        return null;\n+        return getEngineBy(extension, extensionAssociations, ScriptEngineFactory::getExtensions);\n@@ -314,13 +212,2 @@\n-        if (mimeType == null) throw new NullPointerException();\n-        \/\/look for registered types first\n-        Object obj;\n-        if (null != (obj = mimeTypeAssociations.get(mimeType))) {\n-            ScriptEngineFactory spi = (ScriptEngineFactory)obj;\n-            try {\n-                ScriptEngine engine = spi.getScriptEngine();\n-                engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n-                return engine;\n-            } catch (Exception exp) {\n-                if (DEBUG) exp.printStackTrace();\n-            }\n-        }\n+        return getEngineBy(mimeType, mimeTypeAssociations, ScriptEngineFactory::getMimeTypes);\n+    }\n@@ -328,17 +215,15 @@\n-        for (ScriptEngineFactory spi : engineSpis) {\n-            List<String> types = null;\n-            try {\n-                types = spi.getMimeTypes();\n-            } catch (Exception exp) {\n-                if (DEBUG) exp.printStackTrace();\n-            }\n-            if (types == null) continue;\n-            for (String type : types) {\n-                if (mimeType.equals(type)) {\n-                    try {\n-                        ScriptEngine engine = spi.getScriptEngine();\n-                        engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n-                        return engine;\n-                    } catch (Exception exp) {\n-                        if (DEBUG) exp.printStackTrace();\n-                    }\n+    private ScriptEngine getEngineBy(String selector, Map<String, ScriptEngineFactory> associations,\n+        Function<ScriptEngineFactory, List<String>> valuesFn)\n+    {\n+        Objects.requireNonNull(selector);\n+        Stream<ScriptEngineFactory> spis = Stream.concat(\n+            \/\/look for registered types first\n+            Stream.ofNullable(associations.get(selector)),\n+\n+            engineSpis.stream().filter(spi -> {\n+                try {\n+                    List<String> matches = valuesFn.apply(spi);\n+                    return matches != null && matches.contains(selector);\n+                } catch (Exception exp) {\n+                    debugPrint(exp);\n+                    return false;\n@@ -346,1 +231,26 @@\n-            }\n+            })\n+        );\n+        return spis\n+            .map(spi -> {\n+                try {\n+                    ScriptEngine engine = spi.getScriptEngine();\n+                    engine.setBindings(getBindings(), ScriptContext.GLOBAL_SCOPE);\n+                    return engine;\n+                } catch (Exception exp) {\n+                    debugPrint(exp);\n+                    return null;\n+                }\n+            })\n+            .filter(Objects::nonNull)\n+            .findFirst()\n+            .orElse(null);\n+    }\n+\n+    private static void reportException(String msg, Throwable exp) {\n+        System.err.println(msg + exp.getMessage());\n+        debugPrint(exp);\n+    }\n+\n+    private static void debugPrint(Throwable exp) {\n+        if (DEBUG) {\n+            exp.printStackTrace();\n@@ -348,1 +258,0 @@\n-        return null;\n@@ -357,5 +266,1 @@\n-        List<ScriptEngineFactory> res = new ArrayList<ScriptEngineFactory>(engineSpis.size());\n-        for (ScriptEngineFactory spi : engineSpis) {\n-            res.add(spi);\n-        }\n-        return Collections.unmodifiableList(res);\n+        return List.copyOf(engineSpis);\n@@ -372,2 +277,1 @@\n-        if (name == null || factory == null) throw new NullPointerException();\n-        nameAssociations.put(name, factory);\n+        associateFactory(nameAssociations, name, factory);\n@@ -387,2 +291,1 @@\n-        if (type == null || factory == null) throw new NullPointerException();\n-        mimeTypeAssociations.put(type, factory);\n+        associateFactory(mimeTypeAssociations, type, factory);\n@@ -401,2 +304,1 @@\n-        if (extension == null || factory == null) throw new NullPointerException();\n-        extensionAssociations.put(extension, factory);\n+        associateFactory(extensionAssociations, extension, factory);\n@@ -405,0 +307,12 @@\n+    private static void associateFactory(Map<String, ScriptEngineFactory> associations, String association,\n+        ScriptEngineFactory factory)\n+    {\n+        if (association == null || factory == null) throw new NullPointerException();\n+        associations.put(association, factory);\n+    }\n+\n+    private static final Comparator<ScriptEngineFactory> COMPARATOR = Comparator.comparing(\n+        ScriptEngineFactory::getEngineName,\n+        Comparator.nullsLast(Comparator.naturalOrder())\n+    );\n+\n@@ -406,1 +320,1 @@\n-    private TreeSet<ScriptEngineFactory> engineSpis;\n+    private final TreeSet<ScriptEngineFactory> engineSpis = new TreeSet<>(COMPARATOR);\n@@ -409,1 +323,1 @@\n-    private HashMap<String, ScriptEngineFactory> nameAssociations;\n+    private final HashMap<String, ScriptEngineFactory> nameAssociations = new HashMap<>();\n@@ -412,1 +326,1 @@\n-    private HashMap<String, ScriptEngineFactory> extensionAssociations;\n+    private final HashMap<String, ScriptEngineFactory> extensionAssociations = new HashMap<>();\n@@ -415,1 +329,1 @@\n-    private HashMap<String, ScriptEngineFactory> mimeTypeAssociations;\n+    private final HashMap<String, ScriptEngineFactory> mimeTypeAssociations = new HashMap<>();\n@@ -418,1 +332,1 @@\n-    private Bindings globalScope;\n+    private Bindings globalScope = new SimpleBindings();\n","filename":"src\/java.scripting\/share\/classes\/javax\/script\/ScriptEngineManager.java","additions":75,"deletions":161,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -41,3 +41,3 @@\n-    private String fileName;\n-    private int lineNumber;\n-    private int columnNumber;\n+    private final String fileName;\n+    private final int lineNumber;\n+    private final int columnNumber;\n","filename":"src\/java.scripting\/share\/classes\/javax\/script\/ScriptException.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -45,1 +46,1 @@\n-    private Map<String,Object> map;\n+    private final Map<String,Object> map;\n@@ -53,4 +54,1 @@\n-        if (m == null) {\n-            throw new NullPointerException();\n-        }\n-        this.map = m;\n+        this.map = Objects.requireNonNull(m);\n@@ -63,1 +61,1 @@\n-        this(new HashMap<String,Object>());\n+        this(new HashMap<>());\n@@ -94,3 +92,1 @@\n-        if (toMerge == null) {\n-            throw new NullPointerException(\"toMerge map is null\");\n-        }\n+        Objects.requireNonNull(toMerge, \"toMerge map is null\");\n@@ -214,3 +210,1 @@\n-        if (key == null) {\n-            throw new NullPointerException(\"key can not be null\");\n-        }\n+        Objects.requireNonNull(key, \"key can not be null\");\n","filename":"src\/java.scripting\/share\/classes\/javax\/script\/SimpleBindings.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -341,7 +341,1 @@\n-    private static List<Integer> scopes;\n-    static {\n-        scopes = new ArrayList<Integer>(2);\n-        scopes.add(ENGINE_SCOPE);\n-        scopes.add(GLOBAL_SCOPE);\n-        scopes = Collections.unmodifiableList(scopes);\n-    }\n+    private static final List<Integer> scopes = List.of(ENGINE_SCOPE, GLOBAL_SCOPE);\n","filename":"src\/java.scripting\/share\/classes\/javax\/script\/SimpleScriptContext.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-        final static SingleByte.Decoder DEC0201 =\n+        static final SingleByte.Decoder DEC0201 =\n@@ -76,1 +76,1 @@\n-        final static DoubleByte.Decoder DEC0208 =\n+        static final DoubleByte.Decoder DEC0208 =\n@@ -79,1 +79,1 @@\n-        final static DoubleByte.Decoder DEC0212 =\n+        static final DoubleByte.Decoder DEC0212 =\n@@ -228,1 +228,1 @@\n-        final static SingleByte.Encoder ENC0201 =\n+        static final SingleByte.Encoder ENC0201 =\n@@ -231,1 +231,1 @@\n-        final static DoubleByte.Encoder ENC0208 =\n+        static final DoubleByte.Encoder ENC0208 =\n@@ -234,1 +234,1 @@\n-        final static DoubleByte.Encoder ENC0212 =\n+        static final DoubleByte.Encoder ENC0212 =\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/EUC_JP.java.template","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    private final static String innerDecoderIndex0=\n+    private static final String innerDecoderIndex0=\n@@ -628,1 +628,1 @@\n-    private final static String innerDecoderIndex1=\n+    private static final String innerDecoderIndex1=\n@@ -1142,1 +1142,1 @@\n-    private final static String innerDecoderIndex2=\n+    private static final String innerDecoderIndex2=\n@@ -1656,1 +1656,1 @@\n-    private final static String innerDecoderIndex3=\n+    private static final String innerDecoderIndex3=\n@@ -2170,1 +2170,1 @@\n-    private final static String innerDecoderIndex4=\n+    private static final String innerDecoderIndex4=\n@@ -2684,1 +2684,1 @@\n-    private final static String innerDecoderIndex5=\n+    private static final String innerDecoderIndex5=\n@@ -2814,1 +2814,1 @@\n-    private final static short decoderIndex1[] = {\n+    private static final short decoderIndex1[] = {\n@@ -2845,1 +2845,1 @@\n-    private final static String innerIndex0=\n+    private static final String innerIndex0=\n@@ -3229,1 +3229,1 @@\n-    private final static String innerIndex1=\n+    private static final String innerIndex1=\n@@ -3613,1 +3613,1 @@\n-    private final static String innerIndex2=\n+    private static final String innerIndex2=\n@@ -3997,1 +3997,1 @@\n-    private final static String innerIndex3=\n+    private static final String innerIndex3=\n@@ -4381,1 +4381,1 @@\n-    private final static String innerIndex4=\n+    private static final String innerIndex4=\n@@ -4765,1 +4765,1 @@\n-    private final static String innerIndex5=\n+    private static final String innerIndex5=\n@@ -5149,1 +5149,1 @@\n-    private final static String innerIndex6=\n+    private static final String innerIndex6=\n@@ -5533,1 +5533,1 @@\n-    private final static String innerIndex7=\n+    private static final String innerIndex7=\n@@ -5894,1 +5894,1 @@\n-    final static short index1[] = {\n+    static final short index1[] = {\n@@ -5928,1 +5928,1 @@\n-    private final static String innerEncoderIndex0=\n+    private static final String innerEncoderIndex0=\n@@ -6442,1 +6442,1 @@\n-    private final static String innerEncoderIndex1=\n+    private static final String innerEncoderIndex1=\n@@ -6956,1 +6956,1 @@\n-    private final static String innerEncoderIndex2=\n+    private static final String innerEncoderIndex2=\n@@ -7470,1 +7470,1 @@\n-    private final static String innerEncoderIndex3=\n+    private static final String innerEncoderIndex3=\n@@ -7984,1 +7984,1 @@\n-    private final static String innerEncoderIndex4=\n+    private static final String innerEncoderIndex4=\n@@ -8498,1 +8498,1 @@\n-    private final static String innerEncoderIndex5=\n+    private static final String innerEncoderIndex5=\n@@ -9012,1 +9012,1 @@\n-    private final static String innerEncoderIndex6=\n+    private static final String innerEncoderIndex6=\n@@ -9526,1 +9526,1 @@\n-    private final static String innerEncoderIndex7=\n+    private static final String innerEncoderIndex7=\n@@ -10040,1 +10040,1 @@\n-    private final static String innerEncoderIndex8=\n+    private static final String innerEncoderIndex8=\n@@ -10554,1 +10554,1 @@\n-    private final static String innerEncoderIndex9=\n+    private static final String innerEncoderIndex9=\n@@ -11068,1 +11068,1 @@\n-    private final static String innerEncoderIndex10=\n+    private static final String innerEncoderIndex10=\n@@ -11582,1 +11582,1 @@\n-    private final static String innerEncoderIndex11=\n+    private static final String innerEncoderIndex11=\n@@ -12096,1 +12096,1 @@\n-    private final static String innerEncoderIndex12=\n+    private static final String innerEncoderIndex12=\n@@ -12258,1 +12258,1 @@\n-    private final static short encoderIndex1[] = {\n+    private static final short encoderIndex1[] = {\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/GB18030.java.template","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -212,5 +212,5 @@\n-        private final static String byteToCharTable;\n-        private final static String mappingTableG1;\n-        private final static String mappingTableG2a2;\n-        private final static String mappingTableG2ac;\n-        private final static String mappingTableG2ad;\n+        private static final String byteToCharTable;\n+        private static final String mappingTableG1;\n+        private static final String mappingTableG2a2;\n+        private static final String mappingTableG2ac;\n+        private static final String mappingTableG2ad;\n@@ -4818,4 +4818,4 @@\n-        private final static String index2;\n-        private final static String index2a;\n-        private final static String index2b;\n-        private final static String index2c;\n+        private static final String index2;\n+        private static final String index2a;\n+        private static final String index2b;\n+        private static final String index2c;\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/IBM964.java.template","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -461,1 +461,1 @@\n-        final static DoubleByte.Encoder ENC0208 =\n+        static final DoubleByte.Encoder ENC0208 =\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ISO2022_JP.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        final static DoubleByte.Decoder DEC0212 =\n+        static final DoubleByte.Decoder DEC0212 =\n@@ -62,1 +62,1 @@\n-        final static DoubleByte.Encoder ENC0212 =\n+        static final DoubleByte.Encoder ENC0212 =\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/ISO2022_JP_2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,5 +49,5 @@\n-    private final static int EUCJP_MASK       = 0x01;\n-    private final static int SJIS2B_MASK      = 0x02;\n-    private final static int SJIS1B_MASK      = 0x04;\n-    private final static int EUCJP_KANA1_MASK = 0x08;\n-    private final static int EUCJP_KANA2_MASK = 0x10;\n+    private static final int EUCJP_MASK       = 0x01;\n+    private static final int SJIS2B_MASK      = 0x02;\n+    private static final int SJIS1B_MASK      = 0x04;\n+    private static final int EUCJP_KANA1_MASK = 0x08;\n+    private static final int EUCJP_KANA2_MASK = 0x10;\n@@ -96,1 +96,1 @@\n-        private final static String osName = AccessController.doPrivileged(\n+        private static final String osName = AccessController.doPrivileged(\n@@ -99,2 +99,2 @@\n-        private final static String SJISName = getSJISName();\n-        private final static String EUCJPName = \"EUC_JP\";\n+        private static final String SJISName = getSJISName();\n+        private static final String EUCJPName = \"EUC_JP\";\n","filename":"src\/jdk.charsets\/share\/classes\/sun\/nio\/cs\/ext\/JISAutoDetect.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-            final static Factory<JavaCompiler> factory = ReusableJavaCompiler::new;\n+            static final Factory<JavaCompiler> factory = ReusableJavaCompiler::new;\n@@ -390,1 +390,1 @@\n-            final static Factory<Log> factory = ReusableLog::new;\n+            static final Factory<Log> factory = ReusableLog::new;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTaskPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -802,1 +802,1 @@\n-        static public Name formFullName(Name name, Symbol owner) {\n+        public static Name formFullName(Name name, Symbol owner) {\n@@ -817,1 +817,1 @@\n-        static public Name formFlatName(Name name, Symbol owner) {\n+        public static Name formFlatName(Name name, Symbol owner) {\n@@ -2473,1 +2473,1 @@\n-            static public AccessCode getFromCode(int code) {\n+            public static AccessCode getFromCode(int code) {\n@@ -2515,1 +2515,1 @@\n-        public final static Completer NULL_COMPLETER = new Completer() {\n+        public static final Completer NULL_COMPLETER = new Completer() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-        private final static TypeMapping<Void> stripMetadata = new StructuralTypeMapping<Void>() {\n+        private static final TypeMapping<Void> stripMetadata = new StructuralTypeMapping<Void>() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1066,1 +1066,1 @@\n-    final public boolean isSubtype(Type t, Type s) {\n+    public final boolean isSubtype(Type t, Type s) {\n@@ -1069,1 +1069,1 @@\n-    final public boolean isSubtypeNoCapture(Type t, Type s) {\n+    public final boolean isSubtypeNoCapture(Type t, Type s) {\n@@ -4898,1 +4898,1 @@\n-        final public R visit(Type t, S s)               { return t.accept(this, s); }\n+        public final R visit(Type t, S s)               { return t.accept(this, s); }\n@@ -4925,1 +4925,1 @@\n-        final public R visit(Symbol s, S arg)                   { return s.accept(this, arg); }\n+        public final R visit(Symbol s, S arg)                   { return s.accept(this, arg); }\n@@ -4978,1 +4978,1 @@\n-        final public R visit(Type t) { return t.accept(this, null); }\n+        public final R visit(Type t) { return t.accept(this, null); }\n@@ -4992,1 +4992,1 @@\n-        final public Type visit(Type t) { return t.accept(this, null); }\n+        public final Type visit(Type t) { return t.accept(this, null); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -359,1 +359,1 @@\n-        final public Type complete(DeferredType dt, ResultInfo resultInfo, DeferredAttrContext deferredAttrContext) {\n+        public final Type complete(DeferredType dt, ResultInfo resultInfo, DeferredAttrContext deferredAttrContext) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/ArgumentAttr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2065,1 +2065,1 @@\n-    final static TypeTag[] primitiveTags = new TypeTag[]{\n+    static final TypeTag[] primitiveTags = new TypeTag[]{\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+import java.util.LinkedHashMap;\n@@ -73,1 +74,0 @@\n-import java.util.HashMap;\n@@ -390,1 +390,1 @@\n-            this.hoistedVarMap = new HashMap<>();\n+            this.hoistedVarMap = new LinkedHashMap<>();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-    final static boolean checkClash = true;\n+    static final boolean checkClash = true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    public final static int JAVA_MAGIC = 0xCAFEBABE;\n+    public static final int JAVA_MAGIC = 0xCAFEBABE;\n@@ -70,18 +70,18 @@\n-    public final static int CONSTANT_Utf8 = 1;\n-    public final static int CONSTANT_Unicode = 2;\n-    public final static int CONSTANT_Integer = 3;\n-    public final static int CONSTANT_Float = 4;\n-    public final static int CONSTANT_Long = 5;\n-    public final static int CONSTANT_Double = 6;\n-    public final static int CONSTANT_Class = 7;\n-    public final static int CONSTANT_String = 8;\n-    public final static int CONSTANT_Fieldref = 9;\n-    public final static int CONSTANT_Methodref = 10;\n-    public final static int CONSTANT_InterfaceMethodref = 11;\n-    public final static int CONSTANT_NameandType = 12;\n-    public final static int CONSTANT_MethodHandle = 15;\n-    public final static int CONSTANT_MethodType = 16;\n-    public final static int CONSTANT_Dynamic = 17;\n-    public final static int CONSTANT_InvokeDynamic = 18;\n-    public final static int CONSTANT_Module = 19;\n-    public final static int CONSTANT_Package = 20;\n+    public static final int CONSTANT_Utf8 = 1;\n+    public static final int CONSTANT_Unicode = 2;\n+    public static final int CONSTANT_Integer = 3;\n+    public static final int CONSTANT_Float = 4;\n+    public static final int CONSTANT_Long = 5;\n+    public static final int CONSTANT_Double = 6;\n+    public static final int CONSTANT_Class = 7;\n+    public static final int CONSTANT_String = 8;\n+    public static final int CONSTANT_Fieldref = 9;\n+    public static final int CONSTANT_Methodref = 10;\n+    public static final int CONSTANT_InterfaceMethodref = 11;\n+    public static final int CONSTANT_NameandType = 12;\n+    public static final int CONSTANT_MethodHandle = 15;\n+    public static final int CONSTANT_MethodType = 16;\n+    public static final int CONSTANT_Dynamic = 17;\n+    public static final int CONSTANT_InvokeDynamic = 18;\n+    public static final int CONSTANT_Module = 19;\n+    public static final int CONSTANT_Package = 20;\n@@ -89,9 +89,9 @@\n-    public final static int REF_getField = 1;\n-    public final static int REF_getStatic = 2;\n-    public final static int REF_putField = 3;\n-    public final static int REF_putStatic = 4;\n-    public final static int REF_invokeVirtual = 5;\n-    public final static int REF_invokeStatic = 6;\n-    public final static int REF_invokeSpecial = 7;\n-    public final static int REF_newInvokeSpecial = 8;\n-    public final static int REF_invokeInterface = 9;\n+    public static final int REF_getField = 1;\n+    public static final int REF_getStatic = 2;\n+    public static final int REF_putField = 3;\n+    public static final int REF_putStatic = 4;\n+    public static final int REF_invokeVirtual = 5;\n+    public static final int REF_invokeStatic = 6;\n+    public static final int REF_invokeSpecial = 7;\n+    public static final int REF_newInvokeSpecial = 8;\n+    public static final int REF_invokeInterface = 9;\n@@ -99,5 +99,5 @@\n-    public final static int MAX_PARAMETERS = 0xff;\n-    public final static int MAX_DIMENSIONS = 0xff;\n-    public final static int MAX_CODE = 0xffff;\n-    public final static int MAX_LOCALS = 0xffff;\n-    public final static int MAX_STACK = 0xffff;\n+    public static final int MAX_PARAMETERS = 0xff;\n+    public static final int MAX_DIMENSIONS = 0xff;\n+    public static final int MAX_CODE = 0xffff;\n+    public static final int MAX_LOCALS = 0xffff;\n+    public static final int MAX_STACK = 0xffff;\n@@ -105,1 +105,1 @@\n-    public final static int PREVIEW_MINOR_VERSION = 0xffff;\n+    public static final int PREVIEW_MINOR_VERSION = 0xffff;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-        private final static String[] flagName = {\n+        private static final String[] flagName = {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2246,1 +2246,1 @@\n-        private final static String[] mnem = new String[ByteCodeCount];\n+        private static final String[] mnem = new String[ByteCodeCount];\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    static private boolean hasFlag(Symbol m, int flag) {\n+    private static boolean hasFlag(Symbol m, int flag) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/JNIWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-            throw e.getTargetException();\n+            throw e.getCause();\n@@ -425,1 +425,1 @@\n-            Throwable target = e.getTargetException();\n+            Throwable target = e.getCause();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/launcher\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1884,1 +1884,1 @@\n-    private final static Fragment[][] decisionTable = new Fragment[][] {\n+    private static final Fragment[][] decisionTable = new Fragment[][] {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    static public class Reference {\n+    public static class Reference {\n@@ -69,1 +69,1 @@\n-    static public class ParseException extends Exception {\n+    public static class ParseException extends Exception {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/ReferenceParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-    final static class NamedToken extends Token {\n+    static final class NamedToken extends Token {\n@@ -435,1 +435,1 @@\n-    final static class NumericToken extends StringToken {\n+    static final class NumericToken extends StringToken {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    private final static String trimSequence = \"[...]\";\n+    private static final String trimSequence = \"[...]\";\n@@ -91,1 +91,1 @@\n-    private final static int PREFERRED_LENGTH = 20;\n+    private static final int PREFERRED_LENGTH = 20;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-    static public class SimpleConfiguration implements Configuration {\n+    public static class SimpleConfiguration implements Configuration {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/AbstractDiagnosticFormatter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-    static public class BasicConfiguration extends SimpleConfiguration {\n+    public static class BasicConfiguration extends SimpleConfiguration {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/BasicDiagnosticFormatter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,3 +87,3 @@\n-    private final static int wordlen = 32;\n-    private final static int wordshift = 5;\n-    private final static int wordmask = wordlen - 1;\n+    private static final int wordlen = 32;\n+    private static final int wordshift = 5;\n+    private static final int wordmask = wordlen - 1;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Bits.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-    abstract public void push(ClassSymbol s, CompletionCause phase);\n+    public abstract void push(ClassSymbol s, CompletionCause phase);\n@@ -86,1 +86,1 @@\n-    abstract public void pop();\n+    public abstract void pop();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Dependencies.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-    private final static Object DELETED = new Object();\n+    private static final Object DELETED = new Object();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/IntHashTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    private final static Iterator EMPTY = new Iterator() {\n+    private static final Iterator EMPTY = new Iterator() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Iterators.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-    static private String getLocalizedString(List<ResourceBundle> bundles,\n+    private static String getLocalizedString(List<ResourceBundle> bundles,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/JavacMessages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    final static int TabInc = 8;\n+    static final int TabInc = 8;\n@@ -44,1 +44,1 @@\n-    final static int DiagInc = 4;\n+    static final int DiagInc = 4;\n@@ -48,1 +48,1 @@\n-    final static int DetailsInc = 2;\n+    static final int DetailsInc = 2;\n@@ -52,1 +52,1 @@\n-    final static byte TAB   = 0x9;\n+    static final byte TAB   = 0x9;\n@@ -56,1 +56,1 @@\n-    final static byte LF    = 0xA;\n+    static final byte LF    = 0xA;\n@@ -60,1 +60,1 @@\n-    final static byte FF    = 0xC;\n+    static final byte FF    = 0xC;\n@@ -64,1 +64,1 @@\n-    final static byte CR    = 0xD;\n+    static final byte CR    = 0xD;\n@@ -70,1 +70,1 @@\n-    final static byte EOI   = 0x1A;\n+    static final byte EOI   = 0x1A;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/LayoutCharacters.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static public synchronized SharedNameTable create(Names names) {\n+    public static synchronized SharedNameTable create(Names names) {\n@@ -57,1 +57,1 @@\n-    static private synchronized void dispose(SharedNameTable t) {\n+    private static synchronized void dispose(SharedNameTable t) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/SharedNameTable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    static public Name.Table create(Names names) {\n+    public static Name.Table create(Names names) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/UnsharedNameTable.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    final static int limitOnConcurrency = 3;\n+    static final int limitOnConcurrency = 3;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/CompileJavaPackages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    static public void trace(String msg) {\n+    public static void trace(String msg) {\n@@ -91,1 +91,1 @@\n-    static public void debug(String msg) {\n+    public static void debug(String msg) {\n@@ -95,1 +95,1 @@\n-    static public void info(String msg) {\n+    public static void info(String msg) {\n@@ -99,1 +99,1 @@\n-    static public void warn(String msg) {\n+    public static void warn(String msg) {\n@@ -103,1 +103,1 @@\n-    static public void error(String msg) {\n+    public static void error(String msg) {\n@@ -107,1 +107,1 @@\n-    static public void error(Throwable t) {\n+    public static void error(Throwable t) {\n@@ -111,1 +111,1 @@\n-    static public void log(Level l, String msg) {\n+    public static void log(Level l, String msg) {\n@@ -125,1 +125,1 @@\n-    static public boolean isDebugging() {\n+    public static boolean isDebugging() {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Log.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-    static public Package load(Module module, String l) {\n+    public static Package load(Module module, String l) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Package.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-    static public Source load(Package lastPackage, String l, boolean isGenerated) {\n+    public static Source load(Package lastPackage, String l, boolean isGenerated) {\n@@ -188,1 +188,1 @@\n-    static public void scanRoot(File root,\n+    public static void scanRoot(File root,\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Source.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-            \/\/ from, say, 0 to 0L? (And the field is public final static so that\n+            \/\/ from, say, 0 to 0L? (And the field is public static final so that\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/PubapiVisitor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-    private final static String MODIFIERS = Stream.of(Modifier.values())\n+    private static final String MODIFIERS = Stream.of(Modifier.values())\n@@ -191,4 +191,4 @@\n-    private final static Pattern MOD_PATTERN = Pattern.compile(\"(\" + MODIFIERS + \" )*\");\n-    private final static Pattern METHOD_PATTERN = Pattern.compile(\"(?<ret>.+?) (?<name>\\\\S+)\\\\((?<params>.*)\\\\)( throws (?<throws>.*))?\");\n-    private final static Pattern VAR_PATTERN = Pattern.compile(\"VAR (?<modifiers>(\"+MODIFIERS+\" )*)(?<type>.+?) (?<id>\\\\S+)( = (?<val>.*))?\");\n-    private final static Pattern TYPE_PATTERN = Pattern.compile(\"TYPE (?<modifiers>(\"+MODIFIERS+\" )*)(?<fullyQualified>\\\\S+)\");\n+    private static final Pattern MOD_PATTERN = Pattern.compile(\"(\" + MODIFIERS + \" )*\");\n+    private static final Pattern METHOD_PATTERN = Pattern.compile(\"(?<ret>.+?) (?<name>\\\\S+)\\\\((?<params>.*)\\\\)( throws (?<throws>.*))?\");\n+    private static final Pattern VAR_PATTERN = Pattern.compile(\"VAR (?<modifiers>(\"+MODIFIERS+\" )*)(?<type>.+?) (?<id>\\\\S+)( = (?<val>.*))?\");\n+    private static final Pattern TYPE_PATTERN = Pattern.compile(\"TYPE (?<modifiers>(\"+MODIFIERS+\" )*)(?<fullyQualified>\\\\S+)\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/PubApi.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    private final static int magicNr = 0x1174;\n+    private static final int magicNr = 0x1174;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/PortFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    private final static int CHECK_PORTFILE_INTERVAL = 5000;\n+    private static final int CHECK_PORTFILE_INTERVAL = 5000;\n@@ -50,3 +50,3 @@\n-    final private Timer timer = new Timer();\n-    final private PortFile portFile;\n-    final private SjavacServer server;\n+    private final Timer timer = new Timer();\n+    private final PortFile portFile;\n+    private final SjavacServer server;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/PortFileMonitor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    public final static String LINE_TYPE_RC = \"RC\";\n+    public static final String LINE_TYPE_RC = \"RC\";\n@@ -64,3 +64,3 @@\n-    final private String portfilename;\n-    final private int poolsize;\n-    final private int keepalive;\n+    private final String portfilename;\n+    private final int poolsize;\n+    private final int keepalive;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/SjavacServer.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -280,0 +280,9 @@\n+        if (key.sensitive || !key.extractable) {\n+            throw new InvalidKeySpecException(\"Key is sensitive or not extractable\");\n+        }\n+        \/\/ If the key is both extractable and not sensitive, then when it was converted into a P11Key\n+        \/\/ it was also converted into subclass of RSAPrivateKey which encapsulates all of the logic\n+        \/\/ necessary to retrieve the attributes we need. This sub-class will also cache these attributes\n+        \/\/ so that we do not need to query them more than once.\n+        \/\/ Rather than rewrite this logic and make possibly slow calls to the token, we'll just use\n+        \/\/ that existing logic.\n@@ -281,17 +290,19 @@\n-            session[0] = token.getObjSession();\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIME_1),\n-                new CK_ATTRIBUTE(CKA_PRIME_2),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-            };\n-            long keyID = key.getKeyID();\n-            try {\n-                token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n-            } finally {\n-                key.releaseKeyID();\n-            }\n+            \/\/ All supported keyspecs (other than PKCS8EncodedKeySpec) descend from RSAPrivateCrtKeySpec\n+            if (key instanceof RSAPrivateCrtKey) {\n+                RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey)key;\n+                return keySpec.cast(new RSAPrivateCrtKeySpec(\n+                    crtKey.getModulus(),\n+                    crtKey.getPublicExponent(),\n+                    crtKey.getPrivateExponent(),\n+                    crtKey.getPrimeP(),\n+                    crtKey.getPrimeQ(),\n+                    crtKey.getPrimeExponentP(),\n+                    crtKey.getPrimeExponentQ(),\n+                    crtKey.getCrtCoefficient(),\n+                    crtKey.getParams()\n+                ));\n+            } else { \/\/ RSAPrivateKey (non-CRT)\n+                if (!keySpec.isAssignableFrom(RSAPrivateKeySpec.class)) {\n+                    throw new InvalidKeySpecException\n+                        (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n+                }\n@@ -299,23 +310,6 @@\n-            KeySpec spec = new RSAPrivateCrtKeySpec(\n-                attributes[0].getBigInteger(),\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger(),\n-                attributes[4].getBigInteger(),\n-                attributes[5].getBigInteger(),\n-                attributes[6].getBigInteger(),\n-                attributes[7].getBigInteger()\n-            );\n-            return keySpec.cast(spec);\n-        } else if (keySpec.isAssignableFrom(RSAPrivateKeySpec.class)) {\n-            session[0] = token.getObjSession();\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            long keyID = key.getKeyID();\n-            try {\n-                token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n-            } finally {\n-                key.releaseKeyID();\n-            }\n+                if (!(key instanceof RSAPrivateKey)) {\n+                    \/\/ We should never reach here as P11Key.privateKey() should always produce an instance\n+                    \/\/ of RSAPrivateKey when the RSA key is both extractable and non-sensitive.\n+                    throw new InvalidKeySpecException\n+                    (\"Key must be an instance of RSAPrivateKeySpec. Was \" + key.getClass());\n+                }\n@@ -323,5 +317,8 @@\n-            KeySpec spec = new RSAPrivateKeySpec(\n-                attributes[0].getBigInteger(),\n-                attributes[1].getBigInteger()\n-            );\n-            return keySpec.cast(spec);\n+                \/\/ fall through to RSAPrivateKey (non-CRT)\n+                RSAPrivateKey rsaKey = (RSAPrivateKey) key;\n+                return keySpec.cast(new RSAPrivateKeySpec(\n+                    rsaKey.getModulus(),\n+                    rsaKey.getPrivateExponent(),\n+                    rsaKey.getParams()\n+                ));\n+            }\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11RSAKeyFactory.java","additions":42,"deletions":45,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -117,0 +117,4 @@\n+        \/\/ Add record component getters\n+        for (final Method rcg: introspector.getRecordComponentGetters()) {\n+            setPropertyGetter(rcg, 0);\n+        }\n@@ -140,3 +144,1 @@\n-            if(!propertyGetters.containsKey(name)) {\n-                setPropertyGetter(name, introspector.unreflectGetter(field), ValidationType.EXACT_CLASS);\n-            }\n+            setPropertyGetter(name, introspector.unreflectGetter(field), ValidationType.EXACT_CLASS);\n@@ -151,4 +153,1 @@\n-            final String name = innerClassSpec.getKey();\n-            if(!propertyGetters.containsKey(name)) {\n-                setPropertyGetter(name, innerClassSpec.getValue(), ValidationType.EXACT_CLASS);\n-            }\n+            setPropertyGetter(innerClassSpec.getKey(), innerClassSpec.getValue(), ValidationType.EXACT_CLASS);\n@@ -207,1 +206,3 @@\n-        propertyGetters.put(name, new AnnotatedDynamicMethod(handle, validationType));\n+        if (!propertyGetters.containsKey(name)) {\n+            propertyGetters.put(name, new AnnotatedDynamicMethod(handle, validationType));\n+        }\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/AbstractJavaLinker.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -104,0 +104,4 @@\n+    Method getAccessibleMethod(final Method m) {\n+        return methods.get(new MethodSignature(m));\n+    }\n+\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/AccessibleMembersLookup.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,7 @@\n-import java.util.Collections;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.RecordComponent;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n@@ -66,0 +72,1 @@\n+import java.util.Objects;\n@@ -68,0 +75,2 @@\n+    private final Class<?> clazz;\n+\n@@ -70,0 +79,1 @@\n+        this.clazz = clazz;\n@@ -74,1 +84,21 @@\n-        return Collections.emptyMap(); \/\/ NOTE: non-static inner classes are also on StaticClassIntrospector.\n+        return Map.of(); \/\/ NOTE: non-static inner classes are also on StaticClassIntrospector.\n+    }\n+\n+    @Override Collection<Method> getRecordComponentGetters() {\n+        if (clazz.isRecord()) {\n+            try {\n+                \/\/ Need to use doPrivileged as getRecordComponents is rather strict.\n+                final RecordComponent[] rcs = AccessController.doPrivileged(\n+                    (PrivilegedAction<RecordComponent[]>) clazz::getRecordComponents);\n+                return Arrays.stream(rcs)\n+                    .map(RecordComponent::getAccessor)\n+                    .map(membersLookup::getAccessibleMethod)\n+                    .filter(Objects::nonNull) \/\/ no accessible counterpart\n+                    .toList();\n+            } catch (SecurityException e) {\n+                \/\/ We couldn't execute getRecordComponents.\n+                return List.of();\n+            }\n+        } else {\n+            return List.of();\n+        }\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/BeanIntrospector.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+ * <li>if the object is a {@link java.lang.Record record}, expose all public accessors of\n+ * record components as property getters for {@link StandardOperation#GET} operations\n+ * in the {@link StandardNamespace#PROPERTY} namespace;<\/li>\n@@ -84,1 +87,2 @@\n- * {@link StandardNamespace#PROPERTY} namespace;<\/li>\n+ * {@link StandardNamespace#PROPERTY} namespace, except for getters for properties\n+ * with names already handled by record component getters;<\/li>\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/BeansLinker.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+            \/\/ Classes in unexported packages of modules are always restricted\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/CheckRestrictedPackage.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,0 +98,6 @@\n+    \/**\n+     * Returns getter methods for record components.\n+     * @return getter methods for record components.\n+     *\/\n+    abstract Collection<Method> getRecordComponentGetters();\n+\n@@ -144,1 +150,0 @@\n-\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/FacetIntrospector.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n@@ -67,0 +69,1 @@\n+import java.util.List;\n@@ -84,0 +87,4 @@\n+    @Override Collection<Method> getRecordComponentGetters() {\n+        return List.of();\n+    }\n+\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/StaticClassIntrospector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -258,1 +258,1 @@\n-        StringBuffer buf = new StringBuffer(message.length());\n+        StringBuilder buf = new StringBuilder(message.length());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CLHSDB.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -230,1 +230,1 @@\n-            StringBuffer result = new StringBuffer();\n+            StringBuilder result = new StringBuilder();\n@@ -353,1 +353,1 @@\n-            StringBuffer mangled = new StringBuffer(\"__1c\");\n+            StringBuilder mangled = new StringBuilder(\"__1c\");\n@@ -1758,1 +1758,1 @@\n-                StringBuffer buf = new StringBuffer();\n+                StringBuilder buf = new StringBuilder();\n@@ -1970,1 +1970,1 @@\n-                StringBuffer result = new StringBuffer();\n+                StringBuilder result = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/CommandProcessor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1814,1 +1814,1 @@\n-    StringBuffer buf = new StringBuffer(message.length());\n+    StringBuilder buf = new StringBuilder(message.length());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HSDB.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,10 +447,6 @@\n-        if (!isServer) {\n-            \/\/ Do not initialize the VM on the server (unnecessary, since it's\n-            \/\/ instantiated on the client)\n-            try {\n-                VM.initialize(db, debugger);\n-            } catch (DebuggerException e) {\n-                throw (e);\n-            } catch (Exception e) {\n-                throw new DebuggerException(e);\n-            }\n+        try {\n+            VM.initialize(db, debugger);\n+        } catch (DebuggerException e) {\n+            throw (e);\n+        } catch (Exception e) {\n+            throw new DebuggerException(e);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotAgent.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-        StringBuffer nameBuf = new StringBuffer(\"\/\/\");\n+        StringBuilder nameBuf = new StringBuilder(\"\/\/\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/RMIHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerUtilities.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    StringBuffer res = new StringBuffer();\n+    StringBuilder res = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/cdbg\/basic\/BasicFunctionSym.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -139,1 +139,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/dummy\/DummyDebugger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.*;\n@@ -79,0 +80,4 @@\n+\n+  public default String execCommandOnServer(String command, Map<String, Object> options) throws RemoteException {\n+    throw new DebuggerException(\"Command execution is not supported\");\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/remote\/RemoteDebugger.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -418,0 +418,8 @@\n+\n+  public String execCommandOnServer(String command, Map<String, Object> options) {\n+    try {\n+      return remoteDebugger.execCommandOnServer(command, options);\n+    } catch (RemoteException e) {\n+      throw new DebuggerException(e);\n+    }\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/remote\/RemoteDebuggerClient.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.io.*;\n@@ -29,0 +30,1 @@\n+import java.util.*;\n@@ -31,0 +33,1 @@\n+import sun.jvm.hotspot.tools.*;\n@@ -38,1 +41,1 @@\n-  private transient Debugger debugger;\n+  private transient JVMDebugger debugger;\n@@ -47,1 +50,1 @@\n-  public RemoteDebuggerServer(Debugger debugger, int port) throws RemoteException {\n+  public RemoteDebuggerServer(JVMDebugger debugger, int port) throws RemoteException {\n@@ -54,1 +57,1 @@\n-  public RemoteDebuggerServer(Debugger debugger) throws RemoteException {\n+  public RemoteDebuggerServer(JVMDebugger debugger) throws RemoteException {\n@@ -178,0 +181,19 @@\n+\n+  @Override\n+  public String execCommandOnServer(String command, Map<String, Object> options) throws RemoteException {\n+    ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+    try (var out = new PrintStream(bout)) {\n+      if (command.equals(\"pmap\")) {\n+        (new PMap(debugger)).run(out, debugger);\n+      } else if (command.equals(\"pstack\")) {\n+        PStack pstack = new PStack(debugger);\n+        pstack.setVerbose(false);\n+        pstack.setConcurrentLocks((boolean)options.get(\"concurrentLocks\"));\n+        pstack.run(out, debugger);\n+      } else {\n+        throw new DebuggerException(command + \" is not supported in this debugger\");\n+      }\n+    }\n+\n+    return bout.toString();\n+  }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/remote\/RemoteDebuggerServer.java","additions":26,"deletions":4,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,1 +108,1 @@\n-    StringBuffer buf = new StringBuffer(getJavaBytecodeName());\n+    StringBuilder buf = new StringBuilder(getJavaBytecodeName());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/Bytecode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -71,1 +71,1 @@\n-    buf.append(Byte.toString(getValue()));\n+    buf.append(getValue());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeBipush.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -58,1 +58,1 @@\n-    buf.append(Integer.toString(indexForFieldOrMethod()));\n+    buf.append(indexForFieldOrMethod());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeGetPut.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -73,1 +73,1 @@\n-    buf.append(Integer.toString(getLocalVarIndex()));\n+    buf.append(getLocalVarIndex());\n@@ -75,1 +75,1 @@\n-    buf.append(Integer.toString(getIncrement()));\n+    buf.append(getIncrement());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeIinc.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -113,1 +113,1 @@\n-    buf.append(Integer.toString(indexForFieldOrMethod()));\n+    buf.append(indexForFieldOrMethod());\n@@ -118,1 +118,1 @@\n-      buf.append(Integer.toString(poolIndex));\n+      buf.append(poolIndex);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeInvoke.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -41,1 +41,1 @@\n-    buf.append(Integer.toString(getTargetBCI()));\n+    buf.append(getTargetBCI());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeJmp.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,1 +198,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -202,1 +202,1 @@\n-    buf.append(Integer.toString(poolIndex()));\n+    buf.append(poolIndex());\n@@ -205,1 +205,1 @@\n-       buf.append(Integer.toString(cacheIndex()));\n+       buf.append(cacheIndex());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeLoadConstant.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -39,1 +39,1 @@\n-    buf.append(Integer.toString(getLocalVarIndex()));\n+    buf.append(getLocalVarIndex());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeLoadStore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -85,1 +85,1 @@\n-    buf.append(Integer.toString(bci() + defaultOffset()));\n+    buf.append(bci() + defaultOffset());\n@@ -91,1 +91,1 @@\n-      buf.append(Integer.toString(pair.match()));\n+      buf.append(pair.match());\n@@ -93,1 +93,1 @@\n-      buf.append(Integer.toString(bci() + pair.offset()));\n+      buf.append(bci() + pair.offset());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeLookupswitch.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -75,1 +75,1 @@\n-    buf.append(Integer.toString(getDimension()));\n+    buf.append(getDimension());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeMultiANewArray.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeNewArray.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -68,1 +68,1 @@\n-    buf.append(Integer.toString(getLocalVarIndex()));\n+    buf.append(getLocalVarIndex());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeRet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -71,1 +71,1 @@\n-    buf.append(Short.toString(getValue()));\n+    buf.append(getValue());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeSipush.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -91,1 +91,1 @@\n-    buf.append(Integer.toString(bci() + defaultOffset()));\n+    buf.append(bci() + defaultOffset());\n@@ -98,1 +98,1 @@\n-       buf.append(Integer.toString(lo + i));\n+       buf.append(lo + i);\n@@ -100,1 +100,1 @@\n-       buf.append(Integer.toString(bci() + destOffsetAt(i)));\n+       buf.append(bci() + destOffsetAt(i));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeTableswitch.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n@@ -48,1 +48,1 @@\n-    buf.append(Integer.toString(index()));\n+    buf.append(index());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/interpreter\/BytecodeWithKlass.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,2 +68,2 @@\n-    int totalCount=0;\n-    int totalSize=0;\n+    long totalCount=0;\n+    long totalSize=0;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ObjectHistogram.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    return (int) (other.size - size);\n+    return Long.compare(other.size, size);\n@@ -89,1 +89,1 @@\n-          StringBuffer buf = new StringBuffer();\n+          StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ObjectHistogramElement.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-    StringBuffer buf = new StringBuffer(length);\n+    StringBuilder buf = new StringBuilder(length);\n@@ -114,1 +114,1 @@\n-    StringBuffer buf = new StringBuffer(length);\n+    StringBuilder buf = new StringBuilder(length);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/OopUtilities.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -355,1 +355,1 @@\n-                StringBuffer buf = new StringBuffer();\n+                StringBuilder buf = new StringBuilder();\n@@ -358,1 +358,1 @@\n-                    buf.append(Boolean.toString(res[i]));\n+                    buf.append(res[i]);\n@@ -372,1 +372,1 @@\n-                StringBuffer buf = new StringBuffer();\n+                StringBuilder buf = new StringBuilder();\n@@ -375,1 +375,1 @@\n-                    buf.append(Short.toString(res[i]));\n+                    buf.append(res[i]);\n@@ -382,1 +382,1 @@\n-                StringBuffer buf = new StringBuffer();\n+                StringBuilder buf = new StringBuilder();\n@@ -385,1 +385,1 @@\n-                    buf.append(Integer.toString(res[i]));\n+                    buf.append(res[i]);\n@@ -392,1 +392,1 @@\n-                StringBuffer buf = new StringBuffer();\n+                StringBuilder buf = new StringBuilder();\n@@ -395,1 +395,1 @@\n-                    buf.append(Long.toString(res[i]));\n+                    buf.append(res[i]);\n@@ -402,1 +402,1 @@\n-                StringBuffer buf = new StringBuffer();\n+                StringBuilder buf = new StringBuilder();\n@@ -405,1 +405,1 @@\n-                    buf.append(Float.toString(res[i]));\n+                    buf.append(res[i]);\n@@ -412,1 +412,1 @@\n-                StringBuffer buf = new StringBuffer();\n+                StringBuilder buf = new StringBuilder();\n@@ -415,1 +415,1 @@\n-                    buf.append(Double.toString(res[i]));\n+                    buf.append(res[i]);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/PerfDataEntry.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-        if (ite.getTargetException() instanceof RuntimeException) {\n-            throw (RuntimeException)ite.getTargetException();\n+        if (ite.getCause() instanceof RuntimeException) {\n+            throw (RuntimeException)ite.getCause();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VMObjectFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,6 +37,2 @@\n-        StringBuffer msg = new StringBuffer();\n-        msg.append(\"Supported versions are \");\n-        msg.append(supportedVersions);\n-        msg.append(\". Target VM is \");\n-        msg.append(targetVersion);\n-        return msg.toString();\n+        return \"Supported versions are \" + supportedVersions +\n+                \". Target VM is \" + targetVersion;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VMVersionMismatchException.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import sun.jvm.hotspot.debugger.remote.*;\n@@ -80,1 +81,1 @@\n-              out.println(\"remote configuration is not yet implemented\");\n+              out.print(((RemoteDebuggerClient)dbg).execCommandOnServer(\"pmap\", null));\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/PMap.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import sun.jvm.hotspot.debugger.remote.*;\n@@ -200,1 +201,1 @@\n-              out.println(\"remote configuration is not yet implemented\");\n+              out.print(((RemoteDebuggerClient)dbg).execCommandOnServer(\"pstack\", Map.of(\"concurrentLocks\", concurrentLocks)));\n@@ -258,1 +259,1 @@\n-            StringBuffer sb = new StringBuffer();\n+            StringBuilder sb = new StringBuilder();\n@@ -263,1 +264,1 @@\n-            sb.append(\" bci:\" + vf.getBCI());\n+            sb.append(\" bci:\").append(vf.getBCI());\n@@ -266,1 +267,1 @@\n-                sb.append(\" line:\" + lineNumber);\n+                sb.append(\" line:\").append(lineNumber);\n@@ -270,1 +271,1 @@\n-               sb.append(\" Method*:\" + method.getAddress());\n+               sb.append(\" Method*:\").append(method.getAddress());\n@@ -292,0 +293,8 @@\n+\n+   public void setVerbose(boolean verbose) {\n+       this.verbose = verbose;\n+   }\n+\n+   public void setConcurrentLocks(boolean concurrentLocks) {\n+       this.concurrentLocks = concurrentLocks;\n+   }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/PStack.java","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -405,1 +405,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/AnnotatedMemoryPanel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-            StringBuffer buf = new StringBuffer();\n+            StringBuilder buf = new StringBuilder();\n@@ -556,1 +556,1 @@\n-    StringBuffer buf = new StringBuffer();\n+    StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/MemoryPanel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-    StringBuffer result = new StringBuffer();\n+    StringBuilder result = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/SAEditorPane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,1 @@\n-      StringBuffer buf = new StringBuffer(len); \/\/ Approximation\n+      StringBuilder buf = new StringBuilder(len); \/\/ Approximation\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/SourceCodePanel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-       final StringBuffer buf = new StringBuffer();\n+       final StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/SysPropsPanel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-       StringBuffer buf = new StringBuffer();\n+       StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/VMFlagsPanel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-       StringBuffer buf = new StringBuffer();\n+       StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/VMVersionInfoPanel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -886,4 +886,1 @@\n-      StringBuffer buf = new StringBuffer(genBaseHref());\n-      buf.append(\"pc_multiple=\");\n-      buf.append(pcs);\n-      return buf.toString();\n+      return genBaseHref() + \"pc_multiple=\" + pcs;\n@@ -1545,1 +1542,1 @@\n-      StringBuffer buf = new StringBuffer(genBaseHref());\n+      StringBuilder buf = new StringBuilder(genBaseHref());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/classbrowser\/HTMLGenerator.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -289,1 +289,1 @@\n-        StringBuffer result = null;\n+        StringBuilder result = null;\n@@ -314,1 +314,1 @@\n-                    result = new StringBuffer(s);\n+                    result = new StringBuilder(s);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapGXLWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -777,1 +777,1 @@\n-         StringBuffer buf = new StringBuffer();\n+         StringBuilder buf = new StringBuilder();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/ObjectReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,2 +155,1 @@\n-        \/\/ FIXME: Generate good code here.\n-        return bOp(m, (i, a, b) -> a && !b);\n+        return and(m.not());\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/AbstractMask.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,10 +64,10 @@\n-    final static int PERFDATA_PROLOG_OFFSET=0;\n-    final static int PERFDATA_PROLOG_MAGIC_OFFSET=0;\n-    final static int PERFDATA_PROLOG_BYTEORDER_OFFSET=4;\n-    final static int PERFDATA_PROLOG_BYTEORDER_SIZE=1;         \/\/ sizeof(byte)\n-    final static int PERFDATA_PROLOG_MAJOR_OFFSET=5;\n-    final static int PERFDATA_PROLOG_MAJOR_SIZE=1;             \/\/ sizeof(byte)\n-    final static int PERFDATA_PROLOG_MINOR_OFFSET=6;\n-    final static int PERFDATA_PROLOG_MINOR_SIZE=1;             \/\/ sizeof(byte)\n-    final static int PERFDATA_PROLOG_RESERVEDB1_OFFSET=7;\n-    final static int PERFDATA_PROLOG_RESERVEDB1_SIZE=1;        \/\/ sizeof(byte)\n+    static final int PERFDATA_PROLOG_OFFSET=0;\n+    static final int PERFDATA_PROLOG_MAGIC_OFFSET=0;\n+    static final int PERFDATA_PROLOG_BYTEORDER_OFFSET=4;\n+    static final int PERFDATA_PROLOG_BYTEORDER_SIZE=1;         \/\/ sizeof(byte)\n+    static final int PERFDATA_PROLOG_MAJOR_OFFSET=5;\n+    static final int PERFDATA_PROLOG_MAJOR_SIZE=1;             \/\/ sizeof(byte)\n+    static final int PERFDATA_PROLOG_MINOR_OFFSET=6;\n+    static final int PERFDATA_PROLOG_MINOR_SIZE=1;             \/\/ sizeof(byte)\n+    static final int PERFDATA_PROLOG_RESERVEDB1_OFFSET=7;\n+    static final int PERFDATA_PROLOG_RESERVEDB1_SIZE=1;        \/\/ sizeof(byte)\n@@ -75,1 +75,1 @@\n-    final static int PERFDATA_PROLOG_SIZE=8;   \/\/ sizeof(struct PerfDataProlog)\n+    static final int PERFDATA_PROLOG_SIZE=8;   \/\/ sizeof(struct PerfDataProlog)\n@@ -78,3 +78,3 @@\n-    final static byte PERFDATA_BIG_ENDIAN=0;\n-    final static byte PERFDATA_LITTLE_ENDIAN=1;\n-    final static int  PERFDATA_MAGIC = 0xcafec0c0;\n+    static final byte PERFDATA_BIG_ENDIAN=0;\n+    static final byte PERFDATA_LITTLE_ENDIAN=1;\n+    static final int  PERFDATA_MAGIC = 0xcafec0c0;\n@@ -83,1 +83,1 @@\n-    public final static String PERFDATA_MAJOR_NAME =\n+    public static final String PERFDATA_MAJOR_NAME =\n@@ -85,1 +85,1 @@\n-    public final static String PERFDATA_MINOR_NAME =\n+    public static final String PERFDATA_MINOR_NAME =\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/AbstractPerfDataBufferPrologue.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,15 +57,15 @@\n-    private final static int PERFDATA_ENTRYLENGTH_OFFSET=0;\n-    private final static int PERFDATA_ENTRYLENGTH_SIZE=4;   \/\/ sizeof(int)\n-    private final static int PERFDATA_NAMELENGTH_OFFSET=4;\n-    private final static int PERFDATA_NAMELENGTH_SIZE=4;    \/\/ sizeof(int)\n-    private final static int PERFDATA_VECTORLENGTH_OFFSET=8;\n-    private final static int PERFDATA_VECTORLENGTH_SIZE=4;  \/\/ sizeof(int)\n-    private final static int PERFDATA_DATATYPE_OFFSET=12;\n-    private final static int PERFDATA_DATATYPE_SIZE=1;      \/\/ sizeof(byte)\n-    private final static int PERFDATA_FLAGS_OFFSET=13;\n-    private final static int PERFDATA_FLAGS_SIZE=1;        \/\/ sizeof(byte)\n-    private final static int PERFDATA_DATAUNITS_OFFSET=14;\n-    private final static int PERFDATA_DATAUNITS_SIZE=1;     \/\/ sizeof(byte)\n-    private final static int PERFDATA_DATAATTR_OFFSET=15;\n-    private final static int PERFDATA_DATAATTR_SIZE=1;      \/\/ sizeof(byte)\n-    private final static int PERFDATA_NAME_OFFSET=16;\n+    private static final int PERFDATA_ENTRYLENGTH_OFFSET=0;\n+    private static final int PERFDATA_ENTRYLENGTH_SIZE=4;   \/\/ sizeof(int)\n+    private static final int PERFDATA_NAMELENGTH_OFFSET=4;\n+    private static final int PERFDATA_NAMELENGTH_SIZE=4;    \/\/ sizeof(int)\n+    private static final int PERFDATA_VECTORLENGTH_OFFSET=8;\n+    private static final int PERFDATA_VECTORLENGTH_SIZE=4;  \/\/ sizeof(int)\n+    private static final int PERFDATA_DATATYPE_OFFSET=12;\n+    private static final int PERFDATA_DATATYPE_SIZE=1;      \/\/ sizeof(byte)\n+    private static final int PERFDATA_FLAGS_OFFSET=13;\n+    private static final int PERFDATA_FLAGS_SIZE=1;        \/\/ sizeof(byte)\n+    private static final int PERFDATA_DATAUNITS_OFFSET=14;\n+    private static final int PERFDATA_DATAUNITS_SIZE=1;     \/\/ sizeof(byte)\n+    private static final int PERFDATA_DATAATTR_OFFSET=15;\n+    private static final int PERFDATA_DATAATTR_SIZE=1;      \/\/ sizeof(byte)\n+    private static final int PERFDATA_NAME_OFFSET=16;\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/v1_0\/PerfDataBuffer.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,7 +59,7 @@\n-    final static int PERFDATA_PROLOG_USED_OFFSET=8;\n-    final static int PERFDATA_PROLOG_USED_SIZE=4;              \/\/ sizeof(int)\n-    final static int PERFDATA_PROLOG_OVERFLOW_OFFSET=12;\n-    final static int PERFDATA_PROLOG_OVERFLOW_SIZE=4;          \/\/ sizeof(int)\n-    final static int PERFDATA_PROLOG_MODTIMESTAMP_OFFSET=16;\n-    final static int PERFDATA_PROLOG_MODTIMESTAMP_SIZE=8;      \/\/ sizeof(long)\n-    final static int PERFDATA_PROLOG_SIZE=24;  \/\/ sizeof(struct PerfDataProlog)\n+    static final int PERFDATA_PROLOG_USED_OFFSET=8;\n+    static final int PERFDATA_PROLOG_USED_SIZE=4;              \/\/ sizeof(int)\n+    static final int PERFDATA_PROLOG_OVERFLOW_OFFSET=12;\n+    static final int PERFDATA_PROLOG_OVERFLOW_SIZE=4;          \/\/ sizeof(int)\n+    static final int PERFDATA_PROLOG_MODTIMESTAMP_OFFSET=16;\n+    static final int PERFDATA_PROLOG_MODTIMESTAMP_SIZE=8;      \/\/ sizeof(long)\n+    static final int PERFDATA_PROLOG_SIZE=24;  \/\/ sizeof(struct PerfDataProlog)\n@@ -68,4 +68,4 @@\n-    final static String PERFDATA_BUFFER_SIZE_NAME  = \"sun.perfdata.size\";\n-    final static String PERFDATA_BUFFER_USED_NAME  = \"sun.perfdata.used\";\n-    final static String PERFDATA_OVERFLOW_NAME     = \"sun.perfdata.overflow\";\n-    final static String PERFDATA_MODTIMESTAMP_NAME = \"sun.perfdata.timestamp\";\n+    static final String PERFDATA_BUFFER_SIZE_NAME  = \"sun.perfdata.size\";\n+    static final String PERFDATA_BUFFER_USED_NAME  = \"sun.perfdata.used\";\n+    static final String PERFDATA_OVERFLOW_NAME     = \"sun.perfdata.overflow\";\n+    static final String PERFDATA_MODTIMESTAMP_NAME = \"sun.perfdata.timestamp\";\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/v1_0\/PerfDataBufferPrologue.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,16 +77,16 @@\n-    private final static int PERFDATA_ENTRYLENGTH_OFFSET=0;\n-    private final static int PERFDATA_ENTRYLENGTH_SIZE=4;   \/\/ sizeof(int)\n-    private final static int PERFDATA_NAMEOFFSET_OFFSET=4;\n-    private final static int PERFDATA_NAMEOFFSET_SIZE=4;    \/\/ sizeof(int)\n-    private final static int PERFDATA_VECTORLENGTH_OFFSET=8;\n-    private final static int PERFDATA_VECTORLENGTH_SIZE=4;  \/\/ sizeof(int)\n-    private final static int PERFDATA_DATATYPE_OFFSET=12;\n-    private final static int PERFDATA_DATATYPE_SIZE=1;      \/\/ sizeof(byte)\n-    private final static int PERFDATA_FLAGS_OFFSET=13;\n-    private final static int PERFDATA_FLAGS_SIZE=1;       \/\/ sizeof(byte)\n-    private final static int PERFDATA_DATAUNITS_OFFSET=14;\n-    private final static int PERFDATA_DATAUNITS_SIZE=1;     \/\/ sizeof(byte)\n-    private final static int PERFDATA_DATAVAR_OFFSET=15;\n-    private final static int PERFDATA_DATAVAR_SIZE=1;       \/\/ sizeof(byte)\n-    private final static int PERFDATA_DATAOFFSET_OFFSET=16;\n-    private final static int PERFDATA_DATAOFFSET_SIZE=4;    \/\/ sizeof(int)\n+    private static final int PERFDATA_ENTRYLENGTH_OFFSET=0;\n+    private static final int PERFDATA_ENTRYLENGTH_SIZE=4;   \/\/ sizeof(int)\n+    private static final int PERFDATA_NAMEOFFSET_OFFSET=4;\n+    private static final int PERFDATA_NAMEOFFSET_SIZE=4;    \/\/ sizeof(int)\n+    private static final int PERFDATA_VECTORLENGTH_OFFSET=8;\n+    private static final int PERFDATA_VECTORLENGTH_SIZE=4;  \/\/ sizeof(int)\n+    private static final int PERFDATA_DATATYPE_OFFSET=12;\n+    private static final int PERFDATA_DATATYPE_SIZE=1;      \/\/ sizeof(byte)\n+    private static final int PERFDATA_FLAGS_OFFSET=13;\n+    private static final int PERFDATA_FLAGS_SIZE=1;       \/\/ sizeof(byte)\n+    private static final int PERFDATA_DATAUNITS_OFFSET=14;\n+    private static final int PERFDATA_DATAUNITS_SIZE=1;     \/\/ sizeof(byte)\n+    private static final int PERFDATA_DATAVAR_OFFSET=15;\n+    private static final int PERFDATA_DATAVAR_SIZE=1;       \/\/ sizeof(byte)\n+    private static final int PERFDATA_DATAOFFSET_OFFSET=16;\n+    private static final int PERFDATA_DATAOFFSET_SIZE=4;    \/\/ sizeof(int)\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/v2_0\/PerfDataBuffer.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,2 +54,2 @@\n-    private final static int SUPPORTED_MAJOR_VERSION = 2;\n-    private final static int SUPPORTED_MINOR_VERSION = 0;\n+    private static final int SUPPORTED_MAJOR_VERSION = 2;\n+    private static final int SUPPORTED_MINOR_VERSION = 0;\n@@ -65,12 +65,12 @@\n-    final static int PERFDATA_PROLOG_ACCESSIBLE_OFFSET=7;\n-    final static int PERFDATA_PROLOG_ACCESSIBLE_SIZE=1;        \/\/ sizeof(byte)\n-    final static int PERFDATA_PROLOG_USED_OFFSET=8;\n-    final static int PERFDATA_PROLOG_USED_SIZE=4;              \/\/ sizeof(int)\n-    final static int PERFDATA_PROLOG_OVERFLOW_OFFSET=12;\n-    final static int PERFDATA_PROLOG_OVERFLOW_SIZE=4;          \/\/ sizeof(int)\n-    final static int PERFDATA_PROLOG_MODTIMESTAMP_OFFSET=16;\n-    final static int PERFDATA_PROLOG_MODTIMESTAMP_SIZE=8;      \/\/ sizeof(long)\n-    final static int PERFDATA_PROLOG_ENTRYOFFSET_OFFSET=24;\n-    final static int PERFDATA_PROLOG_ENTRYOFFSET_SIZE=4;       \/\/ sizeof(int)\n-    final static int PERFDATA_PROLOG_NUMENTRIES_OFFSET=28;\n-    final static int PERFDATA_PROLOG_NUMENTRIES_SIZE=4;        \/\/ sizeof(int)\n+    static final int PERFDATA_PROLOG_ACCESSIBLE_OFFSET=7;\n+    static final int PERFDATA_PROLOG_ACCESSIBLE_SIZE=1;        \/\/ sizeof(byte)\n+    static final int PERFDATA_PROLOG_USED_OFFSET=8;\n+    static final int PERFDATA_PROLOG_USED_SIZE=4;              \/\/ sizeof(int)\n+    static final int PERFDATA_PROLOG_OVERFLOW_OFFSET=12;\n+    static final int PERFDATA_PROLOG_OVERFLOW_SIZE=4;          \/\/ sizeof(int)\n+    static final int PERFDATA_PROLOG_MODTIMESTAMP_OFFSET=16;\n+    static final int PERFDATA_PROLOG_MODTIMESTAMP_SIZE=8;      \/\/ sizeof(long)\n+    static final int PERFDATA_PROLOG_ENTRYOFFSET_OFFSET=24;\n+    static final int PERFDATA_PROLOG_ENTRYOFFSET_SIZE=4;       \/\/ sizeof(int)\n+    static final int PERFDATA_PROLOG_NUMENTRIES_OFFSET=28;\n+    static final int PERFDATA_PROLOG_NUMENTRIES_SIZE=4;        \/\/ sizeof(int)\n@@ -78,1 +78,1 @@\n-    final static int PERFDATA_PROLOG_SIZE=32;  \/\/ sizeof(struct PerfDataProlog)\n+    static final int PERFDATA_PROLOG_SIZE=32;  \/\/ sizeof(struct PerfDataProlog)\n@@ -81,5 +81,5 @@\n-    final static String PERFDATA_BUFFER_SIZE_NAME  = \"sun.perfdata.size\";\n-    final static String PERFDATA_BUFFER_USED_NAME  = \"sun.perfdata.used\";\n-    final static String PERFDATA_OVERFLOW_NAME     = \"sun.perfdata.overflow\";\n-    final static String PERFDATA_MODTIMESTAMP_NAME = \"sun.perfdata.timestamp\";\n-    final static String PERFDATA_NUMENTRIES_NAME   = \"sun.perfdata.entries\";\n+    static final String PERFDATA_BUFFER_SIZE_NAME  = \"sun.perfdata.size\";\n+    static final String PERFDATA_BUFFER_USED_NAME  = \"sun.perfdata.used\";\n+    static final String PERFDATA_OVERFLOW_NAME     = \"sun.perfdata.overflow\";\n+    static final String PERFDATA_MODTIMESTAMP_NAME = \"sun.perfdata.timestamp\";\n+    static final String PERFDATA_NUMENTRIES_NAME   = \"sun.perfdata.entries\";\n","filename":"src\/jdk.internal.jvmstat\/share\/classes\/sun\/jvmstat\/perfdata\/monitor\/v2_0\/PerfDataBufferPrologue.java","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-        if (primaryResults.length <= MIN_RESULTS && camelCaseMatcher.flags.indexOf(\"i\") === -1) {\n+        if (primaryResults.length <= MIN_RESULTS && !camelCaseMatcher.ignoreCase) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/search.js.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-            super(msg, cause);\n+            super(msg + (cause == null ? \"\" : \" (\" + cause + \")\"), cause);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Extern.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,4 +33,4 @@\n-    final static long SECOND = 1000;\n-    final static long MINUTE = 60 * SECOND;\n-    final static long HOUR   = 60 * MINUTE;\n-    final static long DAY    = 24 * HOUR;\n+    static final long SECOND = 1000;\n+    static final long MINUTE = 60 * SECOND;\n+    static final long HOUR   = 60 * MINUTE;\n+    static final long DAY    = 24 * HOUR;\n@@ -38,1 +38,1 @@\n-    final static String cr = System.getProperty(\"line.separator\");\n+    static final String cr = System.getProperty(\"line.separator\");\n@@ -40,4 +40,4 @@\n-    final static DateFormat timeDF            = new SimpleDateFormat(\"HH:mm\");\n-    private final static DateFormat timeWithSecondsDF = new SimpleDateFormat(\"HH:mm:ss\");\n-    private final static DateFormat dateDF            = new SimpleDateFormat(\"yyyy-MM-dd\");\n-    private final static String decimalZero =\n+    static final DateFormat timeDF            = new SimpleDateFormat(\"HH:mm\");\n+    private static final DateFormat timeWithSecondsDF = new SimpleDateFormat(\"HH:mm:ss\");\n+    private static final DateFormat dateDF            = new SimpleDateFormat(\"yyyy-MM-dd\");\n+    private static final String decimalZero =\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/Formatter.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-    private final static String title =\n+    private static final String title =\n@@ -87,1 +87,1 @@\n-    public final static String ROOT_URL =\n+    public static final String ROOT_URL =\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/JConsole.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-final public class Messages {\n+public final class Messages {\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/Messages.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,4 +94,4 @@\n-    final static long SECOND = 1000;\n-    final static long MINUTE = 60 * SECOND;\n-    final static long HOUR   = 60 * MINUTE;\n-    final static long DAY    = 24 * HOUR;\n+    static final long SECOND = 1000;\n+    static final long MINUTE = 60 * SECOND;\n+    static final long HOUR   = 60 * MINUTE;\n+    static final long DAY    = 24 * HOUR;\n@@ -99,2 +99,2 @@\n-    final static Color bgColor = new Color(250, 250, 250);\n-    final static Color defaultColor = Color.blue.darker();\n+    static final Color bgColor = new Color(250, 250, 250);\n+    static final Color defaultColor = Color.blue.darker();\n@@ -102,1 +102,1 @@\n-    final static int ARRAY_SIZE_INCREMENT = 4000;\n+    static final int ARRAY_SIZE_INCREMENT = 4000;\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/Plotter.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -90,2 +90,2 @@\n-    final private String connectionName;\n-    final private String displayName;\n+    private final String connectionName;\n+    private final String displayName;\n@@ -106,1 +106,1 @@\n-    final static private String HOTSPOT_DIAGNOSTIC_MXBEAN_NAME =\n+    private static final String HOTSPOT_DIAGNOSTIC_MXBEAN_NAME =\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/ProxyClient.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-     * Initializes all non-final public static fields in the given class with\n+     * Initializes all public static non-final fields in the given class with\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/Resources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n-            Throwable t = e.getTargetException();\n+            Throwable t = e.getCause();\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/inspector\/Utils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    private final static String[] columnNames =\n+    private static final String[] columnNames =\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/inspector\/XMBeanAttributes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    private final static String[] columnNames = {\n+    private static final String[] columnNames = {\n@@ -66,1 +66,1 @@\n-    public final static String NOTIFICATION_RECEIVED_EVENT =\n+    public static final String NOTIFICATION_RECEIVED_EVENT =\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/inspector\/XMBeanNotifications.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    public final static XObject NULL_OBJECT = new XObject(\"null\");\n+    public static final XObject NULL_OBJECT = new XObject(\"null\");\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/inspector\/XObject.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    public final static String OPERATION_INVOCATION_EVENT =\n+    public static final String OPERATION_INVOCATION_EVENT =\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/inspector\/XOperations.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,3 +47,3 @@\n-    protected final static int COMPATIBLE_VALUE = 1;\n-    protected final static int CURRENT_VALUE = 2;\n-    protected final static int NULL_VALUE = 3;\n+    protected static final int COMPATIBLE_VALUE = 1;\n+    protected static final int CURRENT_VALUE = 2;\n+    protected static final int NULL_VALUE = 3;\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/inspector\/XTextField.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,2 @@\n-    private String currentEventPath;\n+    private final StringBuilder currentCharacters = new StringBuilder();\n+    private String currentEventName;\n@@ -47,1 +48,0 @@\n-    private StringBuilder currentCharacters;\n@@ -65,1 +65,1 @@\n-            currentEventPath = attributes.getValue(ATTRIBUTE_NAME);\n+            currentEventName = attributes.getValue(ATTRIBUTE_NAME);\n@@ -71,1 +71,1 @@\n-        currentCharacters = null;\n+        currentCharacters.setLength(0);\n@@ -81,2 +81,2 @@\n-        if (currentCharacters == null) {\n-            currentCharacters = new StringBuilder(length);\n+        if (currentSettingsName != null) {\n+            currentCharacters.append(ch, start, length);\n@@ -84,1 +84,0 @@\n-        currentCharacters.append(ch, start, length);\n@@ -93,1 +92,1 @@\n-            currentEventPath = null;\n+            currentEventName = null;\n@@ -96,2 +95,2 @@\n-            String settingsValue = currentCharacters == null ? \"\" : currentCharacters.toString();\n-            settings.put(currentEventPath + \"#\" + currentSettingsName, \"\" + settingsValue);\n+            String settingsValue = currentCharacters.toString();\n+            settings.put(currentEventName + \"#\" + currentSettingsName, settingsValue);\n@@ -102,4 +101,0 @@\n-\n-    public Map<String, String> getSettings() {\n-        return settings;\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/jfc\/JFCParserHandler.java","additions":9,"deletions":14,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-final public class LibProvidersLookup {\n+public final class LibProvidersLookup {\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LibProvidersLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    final static String DEFAULT_ICON = \"JavaApp.png\";\n+    static final String DEFAULT_ICON = \"JavaApp.png\";\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppImageBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,3 +94,3 @@\n-    private final static String TOOL_DPKG_DEB = \"dpkg-deb\";\n-    private final static String TOOL_DPKG = \"dpkg\";\n-    private final static String TOOL_FAKEROOT = \"fakeroot\";\n+    private static final String TOOL_DPKG_DEB = \"dpkg-deb\";\n+    private static final String TOOL_DPKG = \"dpkg\";\n+    private static final String TOOL_FAKEROOT = \"fakeroot\";\n@@ -98,1 +98,1 @@\n-    private final static String DEB_ARCH;\n+    private static final String DEB_ARCH;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    final public boolean validate(Map<String, ? super Object> params)\n+    public final boolean validate(Map<String, ? super Object> params)\n@@ -109,1 +109,1 @@\n-    final public String getBundleType() {\n+    public final String getBundleType() {\n@@ -114,1 +114,1 @@\n-    final public Path execute(Map<String, ? super Object> params,\n+    public final Path execute(Map<String, ? super Object> params,\n@@ -236,1 +236,1 @@\n-    abstract protected List<ConfigException> verifyOutputBundle(\n+    protected abstract List<ConfigException> verifyOutputBundle(\n@@ -239,1 +239,1 @@\n-    abstract protected void initLibProvidersLookup(\n+    protected abstract void initLibProvidersLookup(\n@@ -243,1 +243,1 @@\n-    abstract protected List<ToolValidator> getToolValidators(\n+    protected abstract List<ToolValidator> getToolValidators(\n@@ -246,1 +246,1 @@\n-    abstract protected void doValidate(Map<String, ? super Object> params)\n+    protected abstract void doValidate(Map<String, ? super Object> params)\n@@ -249,1 +249,1 @@\n-    abstract protected Map<String, String> createReplacementData(\n+    protected abstract Map<String, String> createReplacementData(\n@@ -252,1 +252,1 @@\n-    abstract protected Path buildPackageBundle(\n+    protected abstract Path buildPackageBundle(\n@@ -257,1 +257,1 @@\n-    final protected PlatformPackage createMetaPackage(\n+    protected final PlatformPackage createMetaPackage(\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBundler.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    private final static String DEFAULT_SPEC_TEMPLATE = \"template.spec\";\n+    private static final String DEFAULT_SPEC_TEMPLATE = \"template.spec\";\n@@ -115,3 +115,3 @@\n-    public final static String TOOL_RPM = \"rpm\";\n-    public final static String TOOL_RPMBUILD = \"rpmbuild\";\n-    public final static DottedVersion TOOL_RPMBUILD_MIN_VERSION = DottedVersion.lazy(\n+    public static final String TOOL_RPM = \"rpm\";\n+    public static final String TOOL_RPMBUILD = \"rpmbuild\";\n+    public static final DottedVersion TOOL_RPMBUILD_MIN_VERSION = DottedVersion.lazy(\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-    public final static String[] required =\n+    public static final String[] required =\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    final public String getName() {\n+    public final String getName() {\n@@ -49,1 +49,1 @@\n-    final public String getID() {\n+    public final String getID() {\n@@ -54,1 +54,1 @@\n-    final public String getBundleType() {\n+    public final String getBundleType() {\n@@ -59,1 +59,1 @@\n-    final public boolean validate(Map<String, ? super Object> params)\n+    public final boolean validate(Map<String, ? super Object> params)\n@@ -84,1 +84,1 @@\n-    final public Path execute(Map<String, ? super Object> params,\n+    public final Path execute(Map<String, ? super Object> params,\n@@ -101,1 +101,1 @@\n-    final public boolean supported(boolean runtimeInstaller) {\n+    public final boolean supported(boolean runtimeInstaller) {\n@@ -106,1 +106,1 @@\n-    final public boolean isDefault() {\n+    public final boolean isDefault() {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageBundler.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    private final static String FILENAME = \".jpackage.xml\";\n+    private static final String FILENAME = \".jpackage.xml\";\n@@ -60,1 +60,1 @@\n-    private final static Map<Platform, String> PLATFORM_LABELS = Map.of(\n+    private static final Map<Platform, String> PLATFORM_LABELS = Map.of(\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    final protected Map<String, ? super Object> params;\n+    protected final Map<String, ? super Object> params;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BundleParams.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-    private final static Object SECTION_TAG = new Object();\n+    private static final Object SECTION_TAG = new Object();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CfgFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,3 +163,3 @@\n-    final private BigInteger[] components;\n-    final private String value;\n-    final private boolean greedy;\n+    private final BigInteger[] components;\n+    private final String value;\n+    private final boolean greedy;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/DottedVersion.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-final public class Executor {\n+public final class Executor {\n@@ -226,1 +226,1 @@\n-    public final static int INFINITE_TIMEOUT = -1;\n+    public static final int INFINITE_TIMEOUT = -1;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Executor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-    private final static String ALL_MODULE_PATH = \"ALL-MODULE-PATH\";\n+    private static final String ALL_MODULE_PATH = \"ALL-MODULE-PATH\";\n@@ -219,1 +219,1 @@\n-    private final static String ALL_DEFAULT = \"ALL-DEFAULT\";\n+    private static final String ALL_DEFAULT = \"ALL-DEFAULT\";\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkBundlerHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,3 +60,3 @@\n-    private final static String DEFAULT_VERSION = \"1.0\";\n-    private final static String DEFAULT_RELEASE = \"1\";\n-    private final static String[] DEFAULT_JLINK_OPTIONS = {\n+    private static final String DEFAULT_VERSION = \"1.0\";\n+    private static final String DEFAULT_RELEASE = \"1\";\n+    private static final String[] DEFAULT_JLINK_OPTIONS = {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -96,3 +96,2 @@\n-        << appDirPath\n-        << FileUtils::basename(FileUtils::replaceSuffix(\n-                launcherPath, _T(\".cfg\")));\n+        << appDirPath << FileUtils::stripExeSuffix(\n+            FileUtils::basename(launcherPath)) + _T(\".cfg\");\n","filename":"src\/jdk.jpackage\/share\/native\/applauncher\/AppLauncher.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,0 +75,3 @@\n+    \/\/ remove the executable suffix if there is one\n+    tstring stripExeSuffix(const tstring& path);\n+\n","filename":"src\/jdk.jpackage\/share\/native\/common\/FileUtils.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,5 @@\n+tstring stripExeSuffix(const tstring& path) {\n+    \/\/ for unix - there is no suffix to remove\n+    return path;\n+}\n+\n","filename":"src\/jdk.jpackage\/unix\/native\/common\/UnixFileUtils.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    private final static String EXE_WRAPPER_NAME = \"msiwrapper.exe\";\n+    private static final String EXE_WRAPPER_NAME = \"msiwrapper.exe\";\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -835,1 +835,1 @@\n-    private final static Path TARGETDIR = Path.of(\"TARGETDIR\");\n+    private static final Path TARGETDIR = Path.of(\"TARGETDIR\");\n@@ -837,1 +837,1 @@\n-    private final static Path INSTALLDIR = Path.of(\"INSTALLDIR\");\n+    private static final Path INSTALLDIR = Path.of(\"INSTALLDIR\");\n@@ -839,1 +839,1 @@\n-    private final static Set<Path> ROOT_DIRS = Set.of(INSTALLDIR, TARGETDIR);\n+    private static final Set<Path> ROOT_DIRS = Set.of(INSTALLDIR, TARGETDIR);\n@@ -841,1 +841,1 @@\n-    private final static Path PROGRAM_MENU_PATH = TARGETDIR.resolve(\"ProgramMenuFolder\");\n+    private static final Path PROGRAM_MENU_PATH = TARGETDIR.resolve(\"ProgramMenuFolder\");\n@@ -843,1 +843,1 @@\n-    private final static Path DESKTOP_PATH = TARGETDIR.resolve(\"DesktopFolder\");\n+    private static final Path DESKTOP_PATH = TARGETDIR.resolve(\"DesktopFolder\");\n@@ -845,1 +845,1 @@\n-    private final static Path PROGRAM_FILES = TARGETDIR.resolve(\n+    private static final Path PROGRAM_FILES = TARGETDIR.resolve(\n@@ -848,1 +848,1 @@\n-    private final static Path LOCAL_PROGRAM_FILES = TARGETDIR.resolve(\"LocalAppDataFolder\");\n+    private static final Path LOCAL_PROGRAM_FILES = TARGETDIR.resolve(\"LocalAppDataFolder\");\n@@ -850,1 +850,1 @@\n-    private final static Set<Path> SYSTEM_DIRS = Set.of(TARGETDIR,\n+    private static final Set<Path> SYSTEM_DIRS = Set.of(TARGETDIR,\n@@ -853,1 +853,1 @@\n-    private final static Set<Path> KNOWN_DIRS = Stream.of(Set.of(INSTALLDIR),\n+    private static final Set<Path> KNOWN_DIRS = Stream.of(Set.of(INSTALLDIR),\n@@ -857,1 +857,1 @@\n-    private final static Set<Path> USER_PROFILE_DIRS = Set.of(LOCAL_PROGRAM_FILES,\n+    private static final Set<Path> USER_PROFILE_DIRS = Set.of(LOCAL_PROGRAM_FILES,\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    private final static class WixSource {\n+    private static final class WixSource {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixPipeline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-    private final static DottedVersion MINIMAL_VERSION = DottedVersion.lazy(\"3.0\");\n+    private static final DottedVersion MINIMAL_VERSION = DottedVersion.lazy(\"3.0\");\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixTool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-    private final static class DialogPair {\n+    private static final class DialogPair {\n@@ -378,1 +378,1 @@\n-    private final static class Publish {\n+    private static final class Publish {\n@@ -391,1 +391,1 @@\n-    private final static class PublishBuilder {\n+    private static final class PublishBuilder {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixUiFragmentBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -661,0 +661,9 @@\n+tstring stripExeSuffix(const tstring& path) {\n+    \/\/ for windows - there is a \".exe\" suffix to remove\n+    const tstring::size_type pos = path.rfind(_T(\".exe\"));\n+    if (pos == tstring::npos) {\n+        return path;\n+    }\n+    return path.substr(0, pos);\n+}\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinFileUtils.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    private char buf[] = new char[20];\n+    private char[] buf = new char[20];\n@@ -49,1 +49,1 @@\n-    private final byte ctype[] = new byte[256];\n+    private final byte[] ctype = new byte[256];\n@@ -261,11 +261,4 @@\n-        switch (c) {\n-            case 0x1680:\n-            case 0x180E:\n-            case 0x200A:\n-            case 0x202F:\n-            case 0x205F:\n-            case 0x3000:\n-                return CT_WHITESPACE;\n-            default:\n-                return CT_ALPHA;\n-        }\n+        return switch (c) {\n+            case 0x1680, 0x180E, 0x200A, 0x202F, 0x205F, 0x3000 -> CT_WHITESPACE;\n+            default -> CT_ALPHA;\n+        };\n@@ -278,1 +271,1 @@\n-        byte ct[] = ctype;\n+        byte[] ct = ctype;\n@@ -333,23 +326,10 @@\n-                        switch (c) {\n-                        case 'a':\n-                            c = 0x7;\n-                            break;\n-                        case 'b':\n-                            c = '\\b';\n-                            break;\n-                        case 'f':\n-                            c = 0xC;\n-                            break;\n-                        case 'n':\n-                            c = '\\n';\n-                            break;\n-                        case 'r':\n-                            c = '\\r';\n-                            break;\n-                        case 't':\n-                            c = '\\t';\n-                            break;\n-                        case 'v':\n-                            c = 0xB;\n-                            break;\n-                        }\n+                        c = switch (c) {\n+                            case 'a' -> 0x7;\n+                            case 'b' -> '\\b';\n+                            case 'f' -> 0xC;\n+                            case 'n' -> '\\n';\n+                            case 'r' -> '\\r';\n+                            case 't' -> '\\t';\n+                            case 'v' -> 0xB;\n+                            default  -> c;\n+                        };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ArgTokenizer.java","additions":17,"deletions":37,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2805,8 +2805,5 @@\n-                switch (id.charAt(0)) {\n-                    case 's':\n-                        return Integer.parseInt(id.substring(1));\n-                    case 'e':\n-                        return 0x40000000 + Integer.parseInt(id.substring(1));\n-                    default:\n-                        return 0x20000000 + Integer.parseInt(id);\n-                }\n+                return switch (id.charAt(0)) {\n+                    case 's' -> Integer.parseInt(id.substring(1));\n+                    case 'e' -> 0x40000000 + Integer.parseInt(id.substring(1));\n+                    default -> 0x20000000 + Integer.parseInt(id);\n+                };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -233,11 +233,5 @@\n-                        final boolean isBuiltIn;\n-                        switch (all[i]) {\n-                            case \"*\":\n-                                isBuiltIn = true;\n-                                break;\n-                            case \"-\":\n-                                isBuiltIn = false;\n-                                break;\n-                            default:\n-                                throw new IllegalArgumentException(\"Unexpected StartupEntry kind: \" + all[i]);\n-                        }\n+                        final boolean isBuiltIn = switch (all[i]) {\n+                            case \"*\" -> true;\n+                            case \"-\" -> false;\n+                            default -> throw new IllegalArgumentException(\"Unexpected StartupEntry kind: \" + all[i]);\n+                        };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/Startup.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    public final static long NOPOS = Diagnostic.NOPOS;\n+    public static final long NOPOS = Diagnostic.NOPOS;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Diag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-import static jdk.jshell.Snippet.Status.RECOVERABLE_NOT_DEFINED;\n@@ -215,24 +214,22 @@\n-            switch (unitTree.getKind()) {\n-                case IMPORT:\n-                    return processImport(userSource, compileSourceInt);\n-                case VARIABLE:\n-                    return processVariables(userSource, units, compileSourceInt, pt);\n-                case EXPRESSION_STATEMENT:\n-                    return processExpression(userSource, unitTree, compileSourceInt, pt);\n-                case CLASS:\n-                    return processClass(userSource, unitTree, compileSourceInt, SubKind.CLASS_SUBKIND, pt);\n-                case ENUM:\n-                    return processClass(userSource, unitTree, compileSourceInt, SubKind.ENUM_SUBKIND, pt);\n-                case ANNOTATION_TYPE:\n-                    return processClass(userSource, unitTree, compileSourceInt, SubKind.ANNOTATION_TYPE_SUBKIND, pt);\n-                case INTERFACE:\n-                    return processClass(userSource, unitTree, compileSourceInt, SubKind.INTERFACE_SUBKIND, pt);\n-                case RECORD:\n-                    @SuppressWarnings(\"preview\")\n-                    List<Snippet> snippets = processClass(userSource, unitTree, compileSourceInt, SubKind.RECORD_SUBKIND, pt);\n-                    return snippets;\n-                case METHOD:\n-                    return processMethod(userSource, unitTree, compileSourceInt, pt);\n-                default:\n-                    return processStatement(userSource, compileSourceInt);\n-            }\n+            return switch (unitTree.getKind()) {\n+                case IMPORT\n+                    -> processImport(userSource, compileSourceInt);\n+                case VARIABLE\n+                    -> processVariables(userSource, units, compileSourceInt, pt);\n+                case EXPRESSION_STATEMENT\n+                    -> processExpression(userSource, unitTree, compileSourceInt, pt);\n+                case CLASS\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.CLASS_SUBKIND, pt);\n+                case ENUM\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.ENUM_SUBKIND, pt);\n+                case ANNOTATION_TYPE\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.ANNOTATION_TYPE_SUBKIND, pt);\n+                case INTERFACE\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.INTERFACE_SUBKIND, pt);\n+                case RECORD\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.RECORD_SUBKIND, pt);\n+                case METHOD\n+                    -> processMethod(userSource, unitTree, compileSourceInt, pt);\n+                default\n+                    -> processStatement(userSource, compileSourceInt);\n+            };\n@@ -373,26 +370,11 @@\n-                String sinit;\n-                switch (typeName) {\n-                    case \"byte\":\n-                    case \"short\":\n-                    case \"int\":\n-                        sinit = \"0\";\n-                        break;\n-                    case \"long\":\n-                        sinit = \"0L\";\n-                        break;\n-                    case \"float\":\n-                        sinit = \"0.0f\";\n-                        break;\n-                    case \"double\":\n-                        sinit = \"0.0d\";\n-                        break;\n-                    case \"boolean\":\n-                        sinit = \"false\";\n-                        break;\n-                    case \"char\":\n-                        sinit = \"'\\\\u0000'\";\n-                        break;\n-                    default:\n-                        sinit = \"null\";\n-                        break;\n-                }\n+                String sinit = switch (typeName) {\n+                    case \"byte\",\n+                         \"short\",\n+                         \"int\"     -> \"0\";\n+                    case \"long\"    -> \"0L\";\n+                    case \"float\"   -> \"0.0f\";\n+                    case \"double\"  -> \"0.0d\";\n+                    case \"boolean\" -> \"false\";\n+                    case \"char\"    -> \"'\\\\u0000'\";\n+                    default        -> \"null\";\n+                };\n@@ -865,17 +847,8 @@\n-        OuterWrap outer;\n-        switch (probableKind) {\n-            case IMPORT:\n-                outer = state.outerMap.wrapImport(Wrap.simpleWrap(compileSource), snip);\n-                break;\n-            case EXPRESSION:\n-                outer = state.outerMap.wrapInTrialClass(Wrap.methodReturnWrap(compileSource));\n-                break;\n-            case VAR:\n-            case TYPE_DECL:\n-            case METHOD:\n-                outer = state.outerMap.wrapInTrialClass(Wrap.classMemberWrap(compileSource));\n-                break;\n-            default:\n-                outer = state.outerMap.wrapInTrialClass(Wrap.methodWrap(compileSource));\n-                break;\n-        }\n+        OuterWrap outer = switch (probableKind) {\n+            case IMPORT     -> state.outerMap.wrapImport(Wrap.simpleWrap(compileSource), snip);\n+            case EXPRESSION -> state.outerMap.wrapInTrialClass(Wrap.methodReturnWrap(compileSource));\n+            case VAR,\n+                 TYPE_DECL,\n+                 METHOD     -> state.outerMap.wrapInTrialClass(Wrap.classMemberWrap(compileSource));\n+            default         -> state.outerMap.wrapInTrialClass(Wrap.methodWrap(compileSource));\n+        };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Eval.java","additions":41,"deletions":68,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    private final static Set<String> IGNORED_MODIFIERS =\n+    private static final Set<String> IGNORED_MODIFIERS =\n@@ -43,1 +43,1 @@\n-    private final static Set<String> ALL_MODIFIERS =\n+    private static final Set<String> ALL_MODIFIERS =\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/MaskCommentsAndModifiers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -278,13 +278,5 @@\n-        OuterWrap codeWrap;\n-        switch (guessKind(code)) {\n-            case IMPORT:\n-                codeWrap = proc.outerMap.wrapImport(Wrap.simpleWrap(code + \"any.any\"), null);\n-                break;\n-            case CLASS:\n-            case METHOD:\n-                codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(code));\n-                break;\n-            default:\n-                codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));\n-                break;\n-        }\n+        OuterWrap codeWrap = switch (guessKind(code)) {\n+            case IMPORT -> proc.outerMap.wrapImport(Wrap.simpleWrap(code + \"any.any\"), null);\n+            case CLASS, METHOD -> proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(code));\n+            default -> proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));\n+        };\n@@ -505,17 +497,8 @@\n-                        switch (parent.getKind()) {\n-                            case VARIABLE:\n-                                accept = ((VariableTree)parent).getType() == tp.getLeaf() ?\n-                                        IS_VOID.negate() :\n-                                        TRUE;\n-                                break;\n-                            case PARAMETERIZED_TYPE: \/\/ TODO: JEP 218: Generics over Primitive Types\n-                            case TYPE_PARAMETER:\n-                            case CLASS:\n-                            case INTERFACE:\n-                            case ENUM:\n-                                accept = FALSE;\n-                                break;\n-                            default:\n-                                accept = TRUE;\n-                                break;\n-                        }\n+                        accept = switch (parent.getKind()) {\n+                            case VARIABLE -> ((VariableTree) parent).getType() == tp.getLeaf() ?\n+                                             IS_VOID.negate() :\n+                                             TRUE;\n+                            case PARAMETERIZED_TYPE -> FALSE; \/\/ TODO: JEP 218: Generics over Primitive Types\n+                            case TYPE_PARAMETER, CLASS, INTERFACE, ENUM -> FALSE;\n+                            default -> TRUE;\n+                        };\n@@ -1106,9 +1089,6 @@\n-        switch (el.getKind()) {\n-            case METHOD:\n-                return ((ExecutableElement) el).getReturnType();\n-            case CONSTRUCTOR:\n-            case INSTANCE_INIT: case STATIC_INIT: \/\/TODO: should be filtered out\n-                return el.getEnclosingElement().asType();\n-            default:\n-                return el.asType();\n-        }\n+        return switch (el.getKind()) {\n+            case METHOD -> ((ExecutableElement) el).getReturnType();\n+            \/\/ TODO: INSTANCE_INIT and STATIC_INIT should be filtered out\n+            case CONSTRUCTOR, INSTANCE_INIT, STATIC_INIT -> el.getEnclosingElement().asType();\n+            default -> el.asType();\n+        };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":19,"deletions":39,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-    private final static Version INITIAL_SUPPORTED_VER = Version.parse(\"9\");\n+    private static final Version INITIAL_SUPPORTED_VER = Version.parse(\"9\");\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TaskFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1404,3 +1404,6 @@\n-          [\"sminv\", \"sminv\", \"8B\"], [\"sminv\", \"sminv\", \"16B\"],\n-          [\"sminv\", \"sminv\", \"4H\"], [\"sminv\", \"sminv\", \"8H\"],\n-          [\"sminv\", \"sminv\", \"4S\"], [\"fminv\", \"fminv\", \"4S\"],\n+          [\"sminv\", \"sminv\", \"8B\"], [\"uminv\", \"uminv\", \"8B\"],\n+          [\"sminv\", \"sminv\", \"16B\"],[\"uminv\", \"uminv\", \"16B\"],\n+          [\"sminv\", \"sminv\", \"4H\"], [\"uminv\", \"uminv\", \"4H\"],\n+          [\"sminv\", \"sminv\", \"8H\"], [\"uminv\", \"uminv\", \"8H\"],\n+          [\"sminv\", \"sminv\", \"4S\"], [\"uminv\", \"uminv\", \"4S\"],\n+          [\"fminv\", \"fminv\", \"4S\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -538,9 +538,14 @@\n-    __ sminv(v23, __ T16B, v24);                       \/\/       sminv   b23, v24.16B\n-    __ sminv(v4, __ T4H, v5);                          \/\/       sminv   h4, v5.4H\n-    __ sminv(v19, __ T8H, v20);                        \/\/       sminv   h19, v20.8H\n-    __ sminv(v15, __ T4S, v16);                        \/\/       sminv   s15, v16.4S\n-    __ fminv(v0, __ T4S, v1);                          \/\/       fminv   s0, v1.4S\n-    __ fmaxp(v4, v5, __ S);                            \/\/       fmaxp   s4, v5.2S\n-    __ fmaxp(v20, v21, __ D);                          \/\/       fmaxp   d20, v21.2D\n-    __ fminp(v11, v12, __ S);                          \/\/       fminp   s11, v12.2S\n-    __ fminp(v29, v30, __ D);                          \/\/       fminp   d29, v30.2D\n+    __ uminv(v23, __ T8B, v24);                        \/\/       uminv   b23, v24.8B\n+    __ sminv(v4, __ T16B, v5);                         \/\/       sminv   b4, v5.16B\n+    __ uminv(v19, __ T16B, v20);                       \/\/       uminv   b19, v20.16B\n+    __ sminv(v15, __ T4H, v16);                        \/\/       sminv   h15, v16.4H\n+    __ uminv(v0, __ T4H, v1);                          \/\/       uminv   h0, v1.4H\n+    __ sminv(v4, __ T8H, v5);                          \/\/       sminv   h4, v5.8H\n+    __ uminv(v20, __ T8H, v21);                        \/\/       uminv   h20, v21.8H\n+    __ sminv(v11, __ T4S, v12);                        \/\/       sminv   s11, v12.4S\n+    __ uminv(v29, __ T4S, v30);                        \/\/       uminv   s29, v30.4S\n+    __ fminv(v15, __ T4S, v16);                        \/\/       fminv   s15, v16.4S\n+    __ fmaxp(v21, v22, __ S);                          \/\/       fmaxp   s21, v22.2S\n+    __ fmaxp(v4, v5, __ D);                            \/\/       fmaxp   d4, v5.2D\n+    __ fminp(v14, v15, __ S);                          \/\/       fminp   s14, v15.2S\n+    __ fminp(v22, v23, __ D);                          \/\/       fminp   d22, v23.2D\n@@ -549,3 +554,3 @@\n-    __ absr(v15, __ T8B, v16);                         \/\/       abs     v15.8B, v16.8B\n-    __ absr(v21, __ T16B, v22);                        \/\/       abs     v21.16B, v22.16B\n-    __ absr(v4, __ T4H, v5);                           \/\/       abs     v4.4H, v5.4H\n+    __ absr(v25, __ T8B, v26);                         \/\/       abs     v25.8B, v26.8B\n+    __ absr(v6, __ T16B, v7);                          \/\/       abs     v6.16B, v7.16B\n+    __ absr(v12, __ T4H, v13);                         \/\/       abs     v12.4H, v13.4H\n@@ -553,14 +558,14 @@\n-    __ absr(v22, __ T2S, v23);                         \/\/       abs     v22.2S, v23.2S\n-    __ absr(v25, __ T4S, v26);                         \/\/       abs     v25.4S, v26.4S\n-    __ absr(v6, __ T2D, v7);                           \/\/       abs     v6.2D, v7.2D\n-    __ fabs(v12, __ T2S, v13);                         \/\/       fabs    v12.2S, v13.2S\n-    __ fabs(v14, __ T4S, v15);                         \/\/       fabs    v14.4S, v15.4S\n-    __ fabs(v13, __ T2D, v14);                         \/\/       fabs    v13.2D, v14.2D\n-    __ fneg(v14, __ T2S, v15);                         \/\/       fneg    v14.2S, v15.2S\n-    __ fneg(v9, __ T4S, v10);                          \/\/       fneg    v9.4S, v10.4S\n-    __ fneg(v25, __ T2D, v26);                         \/\/       fneg    v25.2D, v26.2D\n-    __ fsqrt(v28, __ T2S, v29);                        \/\/       fsqrt   v28.2S, v29.2S\n-    __ fsqrt(v10, __ T4S, v11);                        \/\/       fsqrt   v10.4S, v11.4S\n-    __ fsqrt(v19, __ T2D, v20);                        \/\/       fsqrt   v19.2D, v20.2D\n-    __ notr(v11, __ T8B, v12);                         \/\/       not     v11.8B, v12.8B\n-    __ notr(v17, __ T16B, v18);                        \/\/       not     v17.16B, v18.16B\n+    __ absr(v13, __ T2S, v14);                         \/\/       abs     v13.2S, v14.2S\n+    __ absr(v14, __ T4S, v15);                         \/\/       abs     v14.4S, v15.4S\n+    __ absr(v9, __ T2D, v10);                          \/\/       abs     v9.2D, v10.2D\n+    __ fabs(v25, __ T2S, v26);                         \/\/       fabs    v25.2S, v26.2S\n+    __ fabs(v28, __ T4S, v29);                         \/\/       fabs    v28.4S, v29.4S\n+    __ fabs(v10, __ T2D, v11);                         \/\/       fabs    v10.2D, v11.2D\n+    __ fneg(v19, __ T2S, v20);                         \/\/       fneg    v19.2S, v20.2S\n+    __ fneg(v11, __ T4S, v12);                         \/\/       fneg    v11.4S, v12.4S\n+    __ fneg(v17, __ T2D, v18);                         \/\/       fneg    v17.2D, v18.2D\n+    __ fsqrt(v21, __ T2S, v22);                        \/\/       fsqrt   v21.2S, v22.2S\n+    __ fsqrt(v15, __ T4S, v16);                        \/\/       fsqrt   v15.4S, v16.4S\n+    __ fsqrt(v20, __ T2D, v21);                        \/\/       fsqrt   v20.2D, v21.2D\n+    __ notr(v23, __ T8B, v24);                         \/\/       not     v23.8B, v24.8B\n+    __ notr(v26, __ T16B, v27);                        \/\/       not     v26.16B, v27.16B\n@@ -569,8 +574,8 @@\n-    __ andr(v21, __ T8B, v22, v23);                    \/\/       and     v21.8B, v22.8B, v23.8B\n-    __ andr(v15, __ T16B, v16, v17);                   \/\/       and     v15.16B, v16.16B, v17.16B\n-    __ orr(v20, __ T8B, v21, v22);                     \/\/       orr     v20.8B, v21.8B, v22.8B\n-    __ orr(v23, __ T16B, v24, v25);                    \/\/       orr     v23.16B, v24.16B, v25.16B\n-    __ eor(v26, __ T8B, v27, v28);                     \/\/       eor     v26.8B, v27.8B, v28.8B\n-    __ eor(v5, __ T16B, v6, v7);                       \/\/       eor     v5.16B, v6.16B, v7.16B\n-    __ addv(v6, __ T8B, v7, v8);                       \/\/       add     v6.8B, v7.8B, v8.8B\n-    __ addv(v15, __ T16B, v16, v17);                   \/\/       add     v15.16B, v16.16B, v17.16B\n+    __ andr(v5, __ T8B, v6, v7);                       \/\/       and     v5.8B, v6.8B, v7.8B\n+    __ andr(v6, __ T16B, v7, v8);                      \/\/       and     v6.16B, v7.16B, v8.16B\n+    __ orr(v15, __ T8B, v16, v17);                     \/\/       orr     v15.8B, v16.8B, v17.8B\n+    __ orr(v15, __ T16B, v16, v17);                    \/\/       orr     v15.16B, v16.16B, v17.16B\n+    __ eor(v25, __ T8B, v26, v27);                     \/\/       eor     v25.8B, v26.8B, v27.8B\n+    __ eor(v16, __ T16B, v17, v18);                    \/\/       eor     v16.16B, v17.16B, v18.16B\n+    __ addv(v27, __ T8B, v28, v29);                    \/\/       add     v27.8B, v28.8B, v29.8B\n+    __ addv(v24, __ T16B, v25, v26);                   \/\/       add     v24.16B, v25.16B, v26.16B\n@@ -579,8 +584,8 @@\n-    __ addv(v16, __ T2S, v17, v18);                    \/\/       add     v16.2S, v17.2S, v18.2S\n-    __ addv(v27, __ T4S, v28, v29);                    \/\/       add     v27.4S, v28.4S, v29.4S\n-    __ addv(v24, __ T2D, v25, v26);                    \/\/       add     v24.2D, v25.2D, v26.2D\n-    __ fadd(v15, __ T2S, v16, v17);                    \/\/       fadd    v15.2S, v16.2S, v17.2S\n-    __ fadd(v25, __ T4S, v26, v27);                    \/\/       fadd    v25.4S, v26.4S, v27.4S\n-    __ fadd(v14, __ T2D, v15, v16);                    \/\/       fadd    v14.2D, v15.2D, v16.2D\n-    __ subv(v10, __ T8B, v11, v12);                    \/\/       sub     v10.8B, v11.8B, v12.8B\n-    __ subv(v13, __ T16B, v14, v15);                   \/\/       sub     v13.16B, v14.16B, v15.16B\n+    __ addv(v14, __ T2S, v15, v16);                    \/\/       add     v14.2S, v15.2S, v16.2S\n+    __ addv(v10, __ T4S, v11, v12);                    \/\/       add     v10.4S, v11.4S, v12.4S\n+    __ addv(v13, __ T2D, v14, v15);                    \/\/       add     v13.2D, v14.2D, v15.2D\n+    __ fadd(v14, __ T2S, v15, v16);                    \/\/       fadd    v14.2S, v15.2S, v16.2S\n+    __ fadd(v20, __ T4S, v21, v22);                    \/\/       fadd    v20.4S, v21.4S, v22.4S\n+    __ fadd(v1, __ T2D, v2, v3);                       \/\/       fadd    v1.2D, v2.2D, v3.2D\n+    __ subv(v22, __ T8B, v23, v24);                    \/\/       sub     v22.8B, v23.8B, v24.8B\n+    __ subv(v30, __ T16B, v31, v0);                    \/\/       sub     v30.16B, v31.16B, v0.16B\n@@ -588,48 +593,48 @@\n-    __ subv(v20, __ T8H, v21, v22);                    \/\/       sub     v20.8H, v21.8H, v22.8H\n-    __ subv(v1, __ T2S, v2, v3);                       \/\/       sub     v1.2S, v2.2S, v3.2S\n-    __ subv(v22, __ T4S, v23, v24);                    \/\/       sub     v22.4S, v23.4S, v24.4S\n-    __ subv(v30, __ T2D, v31, v0);                     \/\/       sub     v30.2D, v31.2D, v0.2D\n-    __ fsub(v14, __ T2S, v15, v16);                    \/\/       fsub    v14.2S, v15.2S, v16.2S\n-    __ fsub(v2, __ T4S, v3, v4);                       \/\/       fsub    v2.4S, v3.4S, v4.4S\n-    __ fsub(v6, __ T2D, v7, v8);                       \/\/       fsub    v6.2D, v7.2D, v8.2D\n-    __ mulv(v3, __ T8B, v4, v5);                       \/\/       mul     v3.8B, v4.8B, v5.8B\n-    __ mulv(v7, __ T16B, v8, v9);                      \/\/       mul     v7.16B, v8.16B, v9.16B\n-    __ mulv(v24, __ T4H, v25, v26);                    \/\/       mul     v24.4H, v25.4H, v26.4H\n-    __ mulv(v0, __ T8H, v1, v2);                       \/\/       mul     v0.8H, v1.8H, v2.8H\n-    __ mulv(v27, __ T2S, v28, v29);                    \/\/       mul     v27.2S, v28.2S, v29.2S\n-    __ mulv(v29, __ T4S, v30, v31);                    \/\/       mul     v29.4S, v30.4S, v31.4S\n-    __ fabd(v5, __ T2S, v6, v7);                       \/\/       fabd    v5.2S, v6.2S, v7.2S\n-    __ fabd(v5, __ T4S, v6, v7);                       \/\/       fabd    v5.4S, v6.4S, v7.4S\n-    __ fabd(v29, __ T2D, v30, v31);                    \/\/       fabd    v29.2D, v30.2D, v31.2D\n-    __ fmul(v11, __ T2S, v12, v13);                    \/\/       fmul    v11.2S, v12.2S, v13.2S\n-    __ fmul(v25, __ T4S, v26, v27);                    \/\/       fmul    v25.4S, v26.4S, v27.4S\n-    __ fmul(v0, __ T2D, v1, v2);                       \/\/       fmul    v0.2D, v1.2D, v2.2D\n-    __ mlav(v30, __ T4H, v31, v0);                     \/\/       mla     v30.4H, v31.4H, v0.4H\n-    __ mlav(v0, __ T8H, v1, v2);                       \/\/       mla     v0.8H, v1.8H, v2.8H\n-    __ mlav(v17, __ T2S, v18, v19);                    \/\/       mla     v17.2S, v18.2S, v19.2S\n-    __ mlav(v28, __ T4S, v29, v30);                    \/\/       mla     v28.4S, v29.4S, v30.4S\n-    __ fmla(v25, __ T2S, v26, v27);                    \/\/       fmla    v25.2S, v26.2S, v27.2S\n-    __ fmla(v9, __ T4S, v10, v11);                     \/\/       fmla    v9.4S, v10.4S, v11.4S\n-    __ fmla(v25, __ T2D, v26, v27);                    \/\/       fmla    v25.2D, v26.2D, v27.2D\n-    __ mlsv(v12, __ T4H, v13, v14);                    \/\/       mls     v12.4H, v13.4H, v14.4H\n-    __ mlsv(v15, __ T8H, v16, v17);                    \/\/       mls     v15.8H, v16.8H, v17.8H\n-    __ mlsv(v11, __ T2S, v12, v13);                    \/\/       mls     v11.2S, v12.2S, v13.2S\n-    __ mlsv(v10, __ T4S, v11, v12);                    \/\/       mls     v10.4S, v11.4S, v12.4S\n-    __ fmls(v17, __ T2S, v18, v19);                    \/\/       fmls    v17.2S, v18.2S, v19.2S\n-    __ fmls(v24, __ T4S, v25, v26);                    \/\/       fmls    v24.4S, v25.4S, v26.4S\n-    __ fmls(v21, __ T2D, v22, v23);                    \/\/       fmls    v21.2D, v22.2D, v23.2D\n-    __ fdiv(v23, __ T2S, v24, v25);                    \/\/       fdiv    v23.2S, v24.2S, v25.2S\n-    __ fdiv(v0, __ T4S, v1, v2);                       \/\/       fdiv    v0.4S, v1.4S, v2.4S\n-    __ fdiv(v16, __ T2D, v17, v18);                    \/\/       fdiv    v16.2D, v17.2D, v18.2D\n-    __ maxv(v10, __ T8B, v11, v12);                    \/\/       smax    v10.8B, v11.8B, v12.8B\n-    __ maxv(v6, __ T16B, v7, v8);                      \/\/       smax    v6.16B, v7.16B, v8.16B\n-    __ maxv(v28, __ T4H, v29, v30);                    \/\/       smax    v28.4H, v29.4H, v30.4H\n-    __ maxv(v6, __ T8H, v7, v8);                       \/\/       smax    v6.8H, v7.8H, v8.8H\n-    __ maxv(v5, __ T2S, v6, v7);                       \/\/       smax    v5.2S, v6.2S, v7.2S\n-    __ maxv(v5, __ T4S, v6, v7);                       \/\/       smax    v5.4S, v6.4S, v7.4S\n-    __ fmax(v20, __ T2S, v21, v22);                    \/\/       fmax    v20.2S, v21.2S, v22.2S\n-    __ fmax(v17, __ T4S, v18, v19);                    \/\/       fmax    v17.4S, v18.4S, v19.4S\n-    __ fmax(v15, __ T2D, v16, v17);                    \/\/       fmax    v15.2D, v16.2D, v17.2D\n-    __ minv(v17, __ T8B, v18, v19);                    \/\/       smin    v17.8B, v18.8B, v19.8B\n-    __ minv(v29, __ T16B, v30, v31);                   \/\/       smin    v29.16B, v30.16B, v31.16B\n-    __ minv(v26, __ T4H, v27, v28);                    \/\/       smin    v26.4H, v27.4H, v28.4H\n+    __ subv(v2, __ T8H, v3, v4);                       \/\/       sub     v2.8H, v3.8H, v4.8H\n+    __ subv(v6, __ T2S, v7, v8);                       \/\/       sub     v6.2S, v7.2S, v8.2S\n+    __ subv(v3, __ T4S, v4, v5);                       \/\/       sub     v3.4S, v4.4S, v5.4S\n+    __ subv(v7, __ T2D, v8, v9);                       \/\/       sub     v7.2D, v8.2D, v9.2D\n+    __ fsub(v24, __ T2S, v25, v26);                    \/\/       fsub    v24.2S, v25.2S, v26.2S\n+    __ fsub(v0, __ T4S, v1, v2);                       \/\/       fsub    v0.4S, v1.4S, v2.4S\n+    __ fsub(v27, __ T2D, v28, v29);                    \/\/       fsub    v27.2D, v28.2D, v29.2D\n+    __ mulv(v29, __ T8B, v30, v31);                    \/\/       mul     v29.8B, v30.8B, v31.8B\n+    __ mulv(v5, __ T16B, v6, v7);                      \/\/       mul     v5.16B, v6.16B, v7.16B\n+    __ mulv(v5, __ T4H, v6, v7);                       \/\/       mul     v5.4H, v6.4H, v7.4H\n+    __ mulv(v29, __ T8H, v30, v31);                    \/\/       mul     v29.8H, v30.8H, v31.8H\n+    __ mulv(v11, __ T2S, v12, v13);                    \/\/       mul     v11.2S, v12.2S, v13.2S\n+    __ mulv(v25, __ T4S, v26, v27);                    \/\/       mul     v25.4S, v26.4S, v27.4S\n+    __ fabd(v0, __ T2S, v1, v2);                       \/\/       fabd    v0.2S, v1.2S, v2.2S\n+    __ fabd(v30, __ T4S, v31, v0);                     \/\/       fabd    v30.4S, v31.4S, v0.4S\n+    __ fabd(v0, __ T2D, v1, v2);                       \/\/       fabd    v0.2D, v1.2D, v2.2D\n+    __ fmul(v17, __ T2S, v18, v19);                    \/\/       fmul    v17.2S, v18.2S, v19.2S\n+    __ fmul(v28, __ T4S, v29, v30);                    \/\/       fmul    v28.4S, v29.4S, v30.4S\n+    __ fmul(v25, __ T2D, v26, v27);                    \/\/       fmul    v25.2D, v26.2D, v27.2D\n+    __ mlav(v9, __ T4H, v10, v11);                     \/\/       mla     v9.4H, v10.4H, v11.4H\n+    __ mlav(v25, __ T8H, v26, v27);                    \/\/       mla     v25.8H, v26.8H, v27.8H\n+    __ mlav(v12, __ T2S, v13, v14);                    \/\/       mla     v12.2S, v13.2S, v14.2S\n+    __ mlav(v15, __ T4S, v16, v17);                    \/\/       mla     v15.4S, v16.4S, v17.4S\n+    __ fmla(v11, __ T2S, v12, v13);                    \/\/       fmla    v11.2S, v12.2S, v13.2S\n+    __ fmla(v10, __ T4S, v11, v12);                    \/\/       fmla    v10.4S, v11.4S, v12.4S\n+    __ fmla(v17, __ T2D, v18, v19);                    \/\/       fmla    v17.2D, v18.2D, v19.2D\n+    __ mlsv(v24, __ T4H, v25, v26);                    \/\/       mls     v24.4H, v25.4H, v26.4H\n+    __ mlsv(v21, __ T8H, v22, v23);                    \/\/       mls     v21.8H, v22.8H, v23.8H\n+    __ mlsv(v23, __ T2S, v24, v25);                    \/\/       mls     v23.2S, v24.2S, v25.2S\n+    __ mlsv(v0, __ T4S, v1, v2);                       \/\/       mls     v0.4S, v1.4S, v2.4S\n+    __ fmls(v16, __ T2S, v17, v18);                    \/\/       fmls    v16.2S, v17.2S, v18.2S\n+    __ fmls(v10, __ T4S, v11, v12);                    \/\/       fmls    v10.4S, v11.4S, v12.4S\n+    __ fmls(v6, __ T2D, v7, v8);                       \/\/       fmls    v6.2D, v7.2D, v8.2D\n+    __ fdiv(v28, __ T2S, v29, v30);                    \/\/       fdiv    v28.2S, v29.2S, v30.2S\n+    __ fdiv(v6, __ T4S, v7, v8);                       \/\/       fdiv    v6.4S, v7.4S, v8.4S\n+    __ fdiv(v5, __ T2D, v6, v7);                       \/\/       fdiv    v5.2D, v6.2D, v7.2D\n+    __ maxv(v5, __ T8B, v6, v7);                       \/\/       smax    v5.8B, v6.8B, v7.8B\n+    __ maxv(v20, __ T16B, v21, v22);                   \/\/       smax    v20.16B, v21.16B, v22.16B\n+    __ maxv(v17, __ T4H, v18, v19);                    \/\/       smax    v17.4H, v18.4H, v19.4H\n+    __ maxv(v15, __ T8H, v16, v17);                    \/\/       smax    v15.8H, v16.8H, v17.8H\n+    __ maxv(v17, __ T2S, v18, v19);                    \/\/       smax    v17.2S, v18.2S, v19.2S\n+    __ maxv(v29, __ T4S, v30, v31);                    \/\/       smax    v29.4S, v30.4S, v31.4S\n+    __ fmax(v26, __ T2S, v27, v28);                    \/\/       fmax    v26.2S, v27.2S, v28.2S\n+    __ fmax(v28, __ T4S, v29, v30);                    \/\/       fmax    v28.4S, v29.4S, v30.4S\n+    __ fmax(v1, __ T2D, v2, v3);                       \/\/       fmax    v1.2D, v2.2D, v3.2D\n+    __ minv(v27, __ T8B, v28, v29);                    \/\/       smin    v27.8B, v28.8B, v29.8B\n+    __ minv(v0, __ T16B, v1, v2);                      \/\/       smin    v0.16B, v1.16B, v2.16B\n+    __ minv(v20, __ T4H, v21, v22);                    \/\/       smin    v20.4H, v21.4H, v22.4H\n@@ -637,4 +642,4 @@\n-    __ minv(v1, __ T2S, v2, v3);                       \/\/       smin    v1.2S, v2.2S, v3.2S\n-    __ minv(v27, __ T4S, v28, v29);                    \/\/       smin    v27.4S, v28.4S, v29.4S\n-    __ fmin(v0, __ T2S, v1, v2);                       \/\/       fmin    v0.2S, v1.2S, v2.2S\n-    __ fmin(v20, __ T4S, v21, v22);                    \/\/       fmin    v20.4S, v21.4S, v22.4S\n+    __ minv(v15, __ T2S, v16, v17);                    \/\/       smin    v15.2S, v16.2S, v17.2S\n+    __ minv(v12, __ T4S, v13, v14);                    \/\/       smin    v12.4S, v13.4S, v14.4S\n+    __ fmin(v10, __ T2S, v11, v12);                    \/\/       fmin    v10.2S, v11.2S, v12.2S\n+    __ fmin(v28, __ T4S, v29, v30);                    \/\/       fmin    v28.4S, v29.4S, v30.4S\n@@ -642,2 +647,2 @@\n-    __ cmeq(v15, __ T8B, v16, v17);                    \/\/       cmeq    v15.8B, v16.8B, v17.8B\n-    __ cmeq(v12, __ T16B, v13, v14);                   \/\/       cmeq    v12.16B, v13.16B, v14.16B\n+    __ cmeq(v19, __ T8B, v20, v21);                    \/\/       cmeq    v19.8B, v20.8B, v21.8B\n+    __ cmeq(v22, __ T16B, v23, v24);                   \/\/       cmeq    v22.16B, v23.16B, v24.16B\n@@ -645,23 +650,23 @@\n-    __ cmeq(v28, __ T8H, v29, v30);                    \/\/       cmeq    v28.8H, v29.8H, v30.8H\n-    __ cmeq(v28, __ T2S, v29, v30);                    \/\/       cmeq    v28.2S, v29.2S, v30.2S\n-    __ cmeq(v19, __ T4S, v20, v21);                    \/\/       cmeq    v19.4S, v20.4S, v21.4S\n-    __ cmeq(v22, __ T2D, v23, v24);                    \/\/       cmeq    v22.2D, v23.2D, v24.2D\n-    __ fcmeq(v10, __ T2S, v11, v12);                   \/\/       fcmeq   v10.2S, v11.2S, v12.2S\n-    __ fcmeq(v4, __ T4S, v5, v6);                      \/\/       fcmeq   v4.4S, v5.4S, v6.4S\n-    __ fcmeq(v30, __ T2D, v31, v0);                    \/\/       fcmeq   v30.2D, v31.2D, v0.2D\n-    __ cmgt(v20, __ T8B, v21, v22);                    \/\/       cmgt    v20.8B, v21.8B, v22.8B\n-    __ cmgt(v8, __ T16B, v9, v10);                     \/\/       cmgt    v8.16B, v9.16B, v10.16B\n-    __ cmgt(v30, __ T4H, v31, v0);                     \/\/       cmgt    v30.4H, v31.4H, v0.4H\n-    __ cmgt(v17, __ T8H, v18, v19);                    \/\/       cmgt    v17.8H, v18.8H, v19.8H\n-    __ cmgt(v10, __ T2S, v11, v12);                    \/\/       cmgt    v10.2S, v11.2S, v12.2S\n-    __ cmgt(v27, __ T4S, v28, v29);                    \/\/       cmgt    v27.4S, v28.4S, v29.4S\n-    __ cmgt(v2, __ T2D, v3, v4);                       \/\/       cmgt    v2.2D, v3.2D, v4.2D\n-    __ fcmgt(v24, __ T2S, v25, v26);                   \/\/       fcmgt   v24.2S, v25.2S, v26.2S\n-    __ fcmgt(v4, __ T4S, v5, v6);                      \/\/       fcmgt   v4.4S, v5.4S, v6.4S\n-    __ fcmgt(v3, __ T2D, v4, v5);                      \/\/       fcmgt   v3.2D, v4.2D, v5.2D\n-    __ cmge(v8, __ T8B, v9, v10);                      \/\/       cmge    v8.8B, v9.8B, v10.8B\n-    __ cmge(v22, __ T16B, v23, v24);                   \/\/       cmge    v22.16B, v23.16B, v24.16B\n-    __ cmge(v17, __ T4H, v18, v19);                    \/\/       cmge    v17.4H, v18.4H, v19.4H\n-    __ cmge(v13, __ T8H, v14, v15);                    \/\/       cmge    v13.8H, v14.8H, v15.8H\n-    __ cmge(v4, __ T2S, v5, v6);                       \/\/       cmge    v4.2S, v5.2S, v6.2S\n-    __ cmge(v28, __ T4S, v29, v30);                    \/\/       cmge    v28.4S, v29.4S, v30.4S\n+    __ cmeq(v4, __ T8H, v5, v6);                       \/\/       cmeq    v4.8H, v5.8H, v6.8H\n+    __ cmeq(v30, __ T2S, v31, v0);                     \/\/       cmeq    v30.2S, v31.2S, v0.2S\n+    __ cmeq(v20, __ T4S, v21, v22);                    \/\/       cmeq    v20.4S, v21.4S, v22.4S\n+    __ cmeq(v8, __ T2D, v9, v10);                      \/\/       cmeq    v8.2D, v9.2D, v10.2D\n+    __ fcmeq(v30, __ T2S, v31, v0);                    \/\/       fcmeq   v30.2S, v31.2S, v0.2S\n+    __ fcmeq(v17, __ T4S, v18, v19);                   \/\/       fcmeq   v17.4S, v18.4S, v19.4S\n+    __ fcmeq(v10, __ T2D, v11, v12);                   \/\/       fcmeq   v10.2D, v11.2D, v12.2D\n+    __ cmgt(v27, __ T8B, v28, v29);                    \/\/       cmgt    v27.8B, v28.8B, v29.8B\n+    __ cmgt(v2, __ T16B, v3, v4);                      \/\/       cmgt    v2.16B, v3.16B, v4.16B\n+    __ cmgt(v24, __ T4H, v25, v26);                    \/\/       cmgt    v24.4H, v25.4H, v26.4H\n+    __ cmgt(v4, __ T8H, v5, v6);                       \/\/       cmgt    v4.8H, v5.8H, v6.8H\n+    __ cmgt(v3, __ T2S, v4, v5);                       \/\/       cmgt    v3.2S, v4.2S, v5.2S\n+    __ cmgt(v8, __ T4S, v9, v10);                      \/\/       cmgt    v8.4S, v9.4S, v10.4S\n+    __ cmgt(v22, __ T2D, v23, v24);                    \/\/       cmgt    v22.2D, v23.2D, v24.2D\n+    __ fcmgt(v17, __ T2S, v18, v19);                   \/\/       fcmgt   v17.2S, v18.2S, v19.2S\n+    __ fcmgt(v13, __ T4S, v14, v15);                   \/\/       fcmgt   v13.4S, v14.4S, v15.4S\n+    __ fcmgt(v4, __ T2D, v5, v6);                      \/\/       fcmgt   v4.2D, v5.2D, v6.2D\n+    __ cmge(v28, __ T8B, v29, v30);                    \/\/       cmge    v28.8B, v29.8B, v30.8B\n+    __ cmge(v23, __ T16B, v24, v25);                   \/\/       cmge    v23.16B, v24.16B, v25.16B\n+    __ cmge(v21, __ T4H, v22, v23);                    \/\/       cmge    v21.4H, v22.4H, v23.4H\n+    __ cmge(v25, __ T8H, v26, v27);                    \/\/       cmge    v25.8H, v26.8H, v27.8H\n+    __ cmge(v24, __ T2S, v25, v26);                    \/\/       cmge    v24.2S, v25.2S, v26.2S\n+    __ cmge(v3, __ T4S, v4, v5);                       \/\/       cmge    v3.4S, v4.4S, v5.4S\n@@ -669,3 +674,3 @@\n-    __ fcmge(v21, __ T2S, v22, v23);                   \/\/       fcmge   v21.2S, v22.2S, v23.2S\n-    __ fcmge(v25, __ T4S, v26, v27);                   \/\/       fcmge   v25.4S, v26.4S, v27.4S\n-    __ fcmge(v24, __ T2D, v25, v26);                   \/\/       fcmge   v24.2D, v25.2D, v26.2D\n+    __ fcmge(v26, __ T2S, v27, v28);                   \/\/       fcmge   v26.2S, v27.2S, v28.2S\n+    __ fcmge(v23, __ T4S, v24, v25);                   \/\/       fcmge   v23.4S, v24.4S, v25.4S\n+    __ fcmge(v14, __ T2D, v15, v16);                   \/\/       fcmge   v14.2D, v15.2D, v16.2D\n@@ -765,9 +770,9 @@\n-    __ swp(Assembler::xword, r3, r24, r26);            \/\/       swp     x3, x24, [x26]\n-    __ ldadd(Assembler::xword, r23, r15, r21);         \/\/       ldadd   x23, x15, [x21]\n-    __ ldbic(Assembler::xword, r3, r24, r8);           \/\/       ldclr   x3, x24, [x8]\n-    __ ldeor(Assembler::xword, r25, r20, r16);         \/\/       ldeor   x25, x20, [x16]\n-    __ ldorr(Assembler::xword, r17, r2, r1);           \/\/       ldset   x17, x2, [x1]\n-    __ ldsmin(Assembler::xword, r0, r24, r4);          \/\/       ldsmin  x0, x24, [x4]\n-    __ ldsmax(Assembler::xword, r3, r12, sp);          \/\/       ldsmax  x3, x12, [sp]\n-    __ ldumin(Assembler::xword, r28, r10, r26);        \/\/       ldumin  x28, x10, [x26]\n-    __ ldumax(Assembler::xword, r2, r12, r15);         \/\/       ldumax  x2, x12, [x15]\n+    __ swp(Assembler::xword, r21, r3, r24);            \/\/       swp     x21, x3, [x24]\n+    __ ldadd(Assembler::xword, r8, r25, r20);          \/\/       ldadd   x8, x25, [x20]\n+    __ ldbic(Assembler::xword, r16, r17, r2);          \/\/       ldclr   x16, x17, [x2]\n+    __ ldeor(Assembler::xword, r1, r0, r24);           \/\/       ldeor   x1, x0, [x24]\n+    __ ldorr(Assembler::xword, r4, r3, r12);           \/\/       ldset   x4, x3, [x12]\n+    __ ldsmin(Assembler::xword, zr, r28, r10);         \/\/       ldsmin  xzr, x28, [x10]\n+    __ ldsmax(Assembler::xword, r26, r2, r12);         \/\/       ldsmax  x26, x2, [x12]\n+    __ ldumin(Assembler::xword, r16, zr, r1);          \/\/       ldumin  x16, xzr, [x1]\n+    __ ldumax(Assembler::xword, r13, r29, r0);         \/\/       ldumax  x13, x29, [x0]\n@@ -776,9 +781,9 @@\n-    __ swpa(Assembler::xword, zr, r1, r13);            \/\/       swpa    xzr, x1, [x13]\n-    __ ldadda(Assembler::xword, r29, r0, r19);         \/\/       ldadda  x29, x0, [x19]\n-    __ ldbica(Assembler::xword, r12, r17, r22);        \/\/       ldclra  x12, x17, [x22]\n-    __ ldeora(Assembler::xword, r13, r28, r30);        \/\/       ldeora  x13, x28, [x30]\n-    __ ldorra(Assembler::xword, zr, r1, r26);          \/\/       ldseta  xzr, x1, [x26]\n-    __ ldsmina(Assembler::xword, r28, r4, r30);        \/\/       ldsmina x28, x4, [x30]\n-    __ ldsmaxa(Assembler::xword, r4, r6, r30);         \/\/       ldsmaxa x4, x6, [x30]\n-    __ ldumina(Assembler::xword, r26, r16, r9);        \/\/       ldumina x26, x16, [x9]\n-    __ ldumaxa(Assembler::xword, r8, r12, r0);         \/\/       ldumaxa x8, x12, [x0]\n+    __ swpa(Assembler::xword, r19, r12, r17);          \/\/       swpa    x19, x12, [x17]\n+    __ ldadda(Assembler::xword, r22, r13, r28);        \/\/       ldadda  x22, x13, [x28]\n+    __ ldbica(Assembler::xword, r30, zr, r1);          \/\/       ldclra  x30, xzr, [x1]\n+    __ ldeora(Assembler::xword, r26, r28, r4);         \/\/       ldeora  x26, x28, [x4]\n+    __ ldorra(Assembler::xword, r30, r4, r6);          \/\/       ldseta  x30, x4, [x6]\n+    __ ldsmina(Assembler::xword, r30, r26, r15);       \/\/       ldsmina x30, x26, [x15]\n+    __ ldsmaxa(Assembler::xword, r9, r8, r12);         \/\/       ldsmaxa x9, x8, [x12]\n+    __ ldumina(Assembler::xword, r0, r20, r1);         \/\/       ldumina x0, x20, [x1]\n+    __ ldumaxa(Assembler::xword, r24, r2, r0);         \/\/       ldumaxa x24, x2, [x0]\n@@ -787,9 +792,9 @@\n-    __ swpal(Assembler::xword, r20, r1, r24);          \/\/       swpal   x20, x1, [x24]\n-    __ ldaddal(Assembler::xword, r2, r0, r9);          \/\/       ldaddal x2, x0, [x9]\n-    __ ldbical(Assembler::xword, r24, r26, r16);       \/\/       ldclral x24, x26, [x16]\n-    __ ldeoral(Assembler::xword, r30, r3, r10);        \/\/       ldeoral x30, x3, [x10]\n-    __ ldorral(Assembler::xword, r23, r10, r4);        \/\/       ldsetal x23, x10, [x4]\n-    __ ldsminal(Assembler::xword, r16, r2, r11);       \/\/       ldsminal        x16, x2, [x11]\n-    __ ldsmaxal(Assembler::xword, r8, r10, r15);       \/\/       ldsmaxal        x8, x10, [x15]\n-    __ lduminal(Assembler::xword, r17, r2, r10);       \/\/       lduminal        x17, x2, [x10]\n-    __ ldumaxal(Assembler::xword, r12, r12, r15);      \/\/       ldumaxal        x12, x12, [x15]\n+    __ swpal(Assembler::xword, r9, r24, r26);          \/\/       swpal   x9, x24, [x26]\n+    __ ldaddal(Assembler::xword, r16, r30, r3);        \/\/       ldaddal x16, x30, [x3]\n+    __ ldbical(Assembler::xword, r10, r23, r10);       \/\/       ldclral x10, x23, [x10]\n+    __ ldeoral(Assembler::xword, r4, r16, r2);         \/\/       ldeoral x4, x16, [x2]\n+    __ ldorral(Assembler::xword, r11, r8, r10);        \/\/       ldsetal x11, x8, [x10]\n+    __ ldsminal(Assembler::xword, r15, r17, r2);       \/\/       ldsminal        x15, x17, [x2]\n+    __ ldsmaxal(Assembler::xword, r10, r12, r12);      \/\/       ldsmaxal        x10, x12, [x12]\n+    __ lduminal(Assembler::xword, r15, r13, r2);       \/\/       lduminal        x15, x13, [x2]\n+    __ ldumaxal(Assembler::xword, r7, r20, r26);       \/\/       ldumaxal        x7, x20, [x26]\n@@ -798,9 +803,9 @@\n-    __ swpl(Assembler::xword, r13, r2, r7);            \/\/       swpl    x13, x2, [x7]\n-    __ ldaddl(Assembler::xword, r20, r26, r16);        \/\/       ldaddl  x20, x26, [x16]\n-    __ ldbicl(Assembler::xword, r4, r2, r4);           \/\/       ldclrl  x4, x2, [x4]\n-    __ ldeorl(Assembler::xword, r12, r16, r21);        \/\/       ldeorl  x12, x16, [x21]\n-    __ ldorrl(Assembler::xword, r16, r16, r11);        \/\/       ldsetl  x16, x16, [x11]\n-    __ ldsminl(Assembler::xword, r21, r23, r12);       \/\/       ldsminl x21, x23, [x12]\n-    __ ldsmaxl(Assembler::xword, r26, r23, r28);       \/\/       ldsmaxl x26, x23, [x28]\n-    __ lduminl(Assembler::xword, r14, r11, r24);       \/\/       lduminl x14, x11, [x24]\n-    __ ldumaxl(Assembler::xword, r1, r12, sp);         \/\/       ldumaxl x1, x12, [sp]\n+    __ swpl(Assembler::xword, r16, r4, r2);            \/\/       swpl    x16, x4, [x2]\n+    __ ldaddl(Assembler::xword, r4, r12, r15);         \/\/       ldaddl  x4, x12, [x15]\n+    __ ldbicl(Assembler::xword, r21, r16, r15);        \/\/       ldclrl  x21, x16, [x15]\n+    __ ldeorl(Assembler::xword, r11, r21, r23);        \/\/       ldeorl  x11, x21, [x23]\n+    __ ldorrl(Assembler::xword, r12, r26, r23);        \/\/       ldsetl  x12, x26, [x23]\n+    __ ldsminl(Assembler::xword, r28, r14, r11);       \/\/       ldsminl x28, x14, [x11]\n+    __ ldsmaxl(Assembler::xword, r24, r1, r12);        \/\/       ldsmaxl x24, x1, [x12]\n+    __ lduminl(Assembler::xword, zr, r10, r16);        \/\/       lduminl xzr, x10, [x16]\n+    __ ldumaxl(Assembler::xword, r7, r2, r3);          \/\/       ldumaxl x7, x2, [x3]\n@@ -809,9 +814,9 @@\n-    __ swp(Assembler::word, r10, r16, r7);             \/\/       swp     w10, w16, [x7]\n-    __ ldadd(Assembler::word, r2, r3, r13);            \/\/       ldadd   w2, w3, [x13]\n-    __ ldbic(Assembler::word, r19, r17, r16);          \/\/       ldclr   w19, w17, [x16]\n-    __ ldeor(Assembler::word, r3, r1, r11);            \/\/       ldeor   w3, w1, [x11]\n-    __ ldorr(Assembler::word, r30, r5, r8);            \/\/       ldset   w30, w5, [x8]\n-    __ ldsmin(Assembler::word, r15, r29, r30);         \/\/       ldsmin  w15, w29, [x30]\n-    __ ldsmax(Assembler::word, r0, r20, r7);           \/\/       ldsmax  w0, w20, [x7]\n-    __ ldumin(Assembler::word, r20, r23, r28);         \/\/       ldumin  w20, w23, [x28]\n-    __ ldumax(Assembler::word, r21, r27, r25);         \/\/       ldumax  w21, w27, [x25]\n+    __ swp(Assembler::word, r13, r19, r17);            \/\/       swp     w13, w19, [x17]\n+    __ ldadd(Assembler::word, r16, r3, r1);            \/\/       ldadd   w16, w3, [x1]\n+    __ ldbic(Assembler::word, r11, r30, r5);           \/\/       ldclr   w11, w30, [x5]\n+    __ ldeor(Assembler::word, r8, r15, r29);           \/\/       ldeor   w8, w15, [x29]\n+    __ ldorr(Assembler::word, r30, r0, r20);           \/\/       ldset   w30, w0, [x20]\n+    __ ldsmin(Assembler::word, r7, r20, r23);          \/\/       ldsmin  w7, w20, [x23]\n+    __ ldsmax(Assembler::word, r28, r21, r27);         \/\/       ldsmax  w28, w21, [x27]\n+    __ ldumin(Assembler::word, r25, r5, r1);           \/\/       ldumin  w25, w5, [x1]\n+    __ ldumax(Assembler::word, r23, r16, sp);          \/\/       ldumax  w23, w16, [sp]\n@@ -820,9 +825,9 @@\n-    __ swpa(Assembler::word, r5, r1, r23);             \/\/       swpa    w5, w1, [x23]\n-    __ ldadda(Assembler::word, r16, zr, r5);           \/\/       ldadda  w16, wzr, [x5]\n-    __ ldbica(Assembler::word, r12, r9, r28);          \/\/       ldclra  w12, w9, [x28]\n-    __ ldeora(Assembler::word, r15, r29, r22);         \/\/       ldeora  w15, w29, [x22]\n-    __ ldorra(Assembler::word, zr, r19, sp);           \/\/       ldseta  wzr, w19, [sp]\n-    __ ldsmina(Assembler::word, r5, r14, r15);         \/\/       ldsmina w5, w14, [x15]\n-    __ ldsmaxa(Assembler::word, zr, r16, r27);         \/\/       ldsmaxa wzr, w16, [x27]\n-    __ ldumina(Assembler::word, r20, r16, r12);        \/\/       ldumina w20, w16, [x12]\n-    __ ldumaxa(Assembler::word, r11, r9, r6);          \/\/       ldumaxa w11, w9, [x6]\n+    __ swpa(Assembler::word, r5, r12, r9);             \/\/       swpa    w5, w12, [x9]\n+    __ ldadda(Assembler::word, r28, r15, r29);         \/\/       ldadda  w28, w15, [x29]\n+    __ ldbica(Assembler::word, r22, zr, r19);          \/\/       ldclra  w22, wzr, [x19]\n+    __ ldeora(Assembler::word, zr, r5, r14);           \/\/       ldeora  wzr, w5, [x14]\n+    __ ldorra(Assembler::word, r16, zr, r15);          \/\/       ldseta  w16, wzr, [x15]\n+    __ ldsmina(Assembler::word, r27, r20, r16);        \/\/       ldsmina w27, w20, [x16]\n+    __ ldsmaxa(Assembler::word, r12, r11, r9);         \/\/       ldsmaxa w12, w11, [x9]\n+    __ ldumina(Assembler::word, r6, r30, r17);         \/\/       ldumina w6, w30, [x17]\n+    __ ldumaxa(Assembler::word, r27, r28, r30);        \/\/       ldumaxa w27, w28, [x30]\n@@ -831,9 +836,9 @@\n-    __ swpal(Assembler::word, r30, r17, r27);          \/\/       swpal   w30, w17, [x27]\n-    __ ldaddal(Assembler::word, r28, r30, r7);         \/\/       ldaddal w28, w30, [x7]\n-    __ ldbical(Assembler::word, r10, r20, r10);        \/\/       ldclral w10, w20, [x10]\n-    __ ldeoral(Assembler::word, r4, r24, r17);         \/\/       ldeoral w4, w24, [x17]\n-    __ ldorral(Assembler::word, r17, r22, r3);         \/\/       ldsetal w17, w22, [x3]\n-    __ ldsminal(Assembler::word, r29, r15, r22);       \/\/       ldsminal        w29, w15, [x22]\n-    __ ldsmaxal(Assembler::word, r19, r19, r22);       \/\/       ldsmaxal        w19, w19, [x22]\n-    __ lduminal(Assembler::word, r2, r15, r6);         \/\/       lduminal        w2, w15, [x6]\n-    __ ldumaxal(Assembler::word, r12, r16, r11);       \/\/       ldumaxal        w12, w16, [x11]\n+    __ swpal(Assembler::word, r7, r10, r20);           \/\/       swpal   w7, w10, [x20]\n+    __ ldaddal(Assembler::word, r10, r4, r24);         \/\/       ldaddal w10, w4, [x24]\n+    __ ldbical(Assembler::word, r17, r17, r22);        \/\/       ldclral w17, w17, [x22]\n+    __ ldeoral(Assembler::word, r3, r29, r15);         \/\/       ldeoral w3, w29, [x15]\n+    __ ldorral(Assembler::word, r22, r19, r19);        \/\/       ldsetal w22, w19, [x19]\n+    __ ldsminal(Assembler::word, r22, r2, r15);        \/\/       ldsminal        w22, w2, [x15]\n+    __ ldsmaxal(Assembler::word, r6, r12, r16);        \/\/       ldsmaxal        w6, w12, [x16]\n+    __ lduminal(Assembler::word, r11, r13, r23);       \/\/       lduminal        w11, w13, [x23]\n+    __ ldumaxal(Assembler::word, r1, r30, r19);        \/\/       ldumaxal        w1, w30, [x19]\n@@ -842,9 +847,9 @@\n-    __ swpl(Assembler::word, r13, r23, r1);            \/\/       swpl    w13, w23, [x1]\n-    __ ldaddl(Assembler::word, r30, r19, r5);          \/\/       ldaddl  w30, w19, [x5]\n-    __ ldbicl(Assembler::word, r17, r2, r16);          \/\/       ldclrl  w17, w2, [x16]\n-    __ ldeorl(Assembler::word, r22, r13, r10);         \/\/       ldeorl  w22, w13, [x10]\n-    __ ldorrl(Assembler::word, r21, r29, r27);         \/\/       ldsetl  w21, w29, [x27]\n-    __ ldsminl(Assembler::word, r12, r27, r3);         \/\/       ldsminl w12, w27, [x3]\n-    __ ldsmaxl(Assembler::word, r1, zr, r24);          \/\/       ldsmaxl w1, wzr, [x24]\n-    __ lduminl(Assembler::word, r19, r17, r9);         \/\/       lduminl w19, w17, [x9]\n-    __ ldumaxl(Assembler::word, r28, r27, r15);        \/\/       ldumaxl w28, w27, [x15]\n+    __ swpl(Assembler::word, r5, r17, r2);             \/\/       swpl    w5, w17, [x2]\n+    __ ldaddl(Assembler::word, r16, r22, r13);         \/\/       ldaddl  w16, w22, [x13]\n+    __ ldbicl(Assembler::word, r10, r21, r29);         \/\/       ldclrl  w10, w21, [x29]\n+    __ ldeorl(Assembler::word, r27, r12, r27);         \/\/       ldeorl  w27, w12, [x27]\n+    __ ldorrl(Assembler::word, r3, r1, sp);            \/\/       ldsetl  w3, w1, [sp]\n+    __ ldsminl(Assembler::word, r24, r19, r17);        \/\/       ldsminl w24, w19, [x17]\n+    __ ldsmaxl(Assembler::word, r9, r28, r27);         \/\/       ldsmaxl w9, w28, [x27]\n+    __ lduminl(Assembler::word, r15, r7, r21);         \/\/       lduminl w15, w7, [x21]\n+    __ ldumaxl(Assembler::word, r23, zr, r25);         \/\/       ldumaxl w23, wzr, [x25]\n@@ -853,4 +858,4 @@\n-    __ bcax(v6, __ T16B, v20, v22, v30);               \/\/       bcax            v6.16B, v20.16B, v22.16B, v30.16B\n-    __ eor3(v24, __ T16B, v2, v30, v26);               \/\/       eor3            v24.16B, v2.16B, v30.16B, v26.16B\n-    __ rax1(v17, __ T2D, v10, v22);                    \/\/       rax1            v17.2D, v10.2D, v22.2D\n-    __ xar(v17, __ T2D, v2, v17, 1);                   \/\/       xar             v17.2D, v2.2D, v17.2D, #1\n+    __ bcax(v2, __ T16B, v30, v26, v17);               \/\/       bcax            v2.16B, v30.16B, v26.16B, v17.16B\n+    __ eor3(v10, __ T16B, v22, v17, v2);               \/\/       eor3            v10.16B, v22.16B, v17.16B, v2.16B\n+    __ rax1(v17, __ T2D, v0, v24);                     \/\/       rax1            v17.2D, v0.2D, v24.2D\n+    __ xar(v25, __ T2D, v22, v2, 37);                  \/\/       xar             v25.2D, v22.2D, v2.2D, #37\n@@ -859,4 +864,4 @@\n-    __ sha512h(v24, __ T2D, v25, v22);                 \/\/       sha512h         q24, q25, v22.2D\n-    __ sha512h2(v2, __ T2D, v17, v12);                 \/\/       sha512h2                q2, q17, v12.2D\n-    __ sha512su0(v3, __ T2D, v27);                     \/\/       sha512su0               v3.2D, v27.2D\n-    __ sha512su1(v29, __ T2D, v28, v16);               \/\/       sha512su1               v29.2D, v28.2D, v16.2D\n+    __ sha512h(v12, __ T2D, v3, v27);                  \/\/       sha512h         q12, q3, v27.2D\n+    __ sha512h2(v29, __ T2D, v28, v16);                \/\/       sha512h2                q29, q28, v16.2D\n+    __ sha512su0(v26, __ T2D, v6);                     \/\/       sha512su0               v26.2D, v6.2D\n+    __ sha512su1(v9, __ T2D, v28, v17);                \/\/       sha512su1               v9.2D, v28.2D, v17.2D\n@@ -865,38 +870,38 @@\n-    __ sve_add(z26, __ D, z6, z9);                     \/\/       add     z26.d, z6.d, z9.d\n-    __ sve_sub(z17, __ B, z7, z4);                     \/\/       sub     z17.b, z7.b, z4.b\n-    __ sve_fadd(z15, __ S, z9, z22);                   \/\/       fadd    z15.s, z9.s, z22.s\n-    __ sve_fmul(z2, __ D, z27, z20);                   \/\/       fmul    z2.d, z27.d, z20.d\n-    __ sve_fsub(z5, __ D, z26, z0);                    \/\/       fsub    z5.d, z26.d, z0.d\n-    __ sve_abs(z14, __ H, p1, z25);                    \/\/       abs     z14.h, p1\/m, z25.h\n-    __ sve_add(z27, __ D, p5, z26);                    \/\/       add     z27.d, p5\/m, z27.d, z26.d\n-    __ sve_asr(z24, __ B, p5, z0);                     \/\/       asr     z24.b, p5\/m, z24.b, z0.b\n-    __ sve_cnt(z6, __ B, p4, z0);                      \/\/       cnt     z6.b, p4\/m, z0.b\n-    __ sve_lsl(z15, __ B, p0, z9);                     \/\/       lsl     z15.b, p0\/m, z15.b, z9.b\n-    __ sve_lsr(z5, __ B, p2, z27);                     \/\/       lsr     z5.b, p2\/m, z5.b, z27.b\n-    __ sve_mul(z20, __ B, p5, z20);                    \/\/       mul     z20.b, p5\/m, z20.b, z20.b\n-    __ sve_neg(z10, __ D, p2, z16);                    \/\/       neg     z10.d, p2\/m, z16.d\n-    __ sve_not(z6, __ H, p4, z2);                      \/\/       not     z6.h, p4\/m, z2.h\n-    __ sve_smax(z29, __ D, p7, z2);                    \/\/       smax    z29.d, p7\/m, z29.d, z2.d\n-    __ sve_smin(z22, __ H, p7, z14);                   \/\/       smin    z22.h, p7\/m, z22.h, z14.h\n-    __ sve_sub(z27, __ B, p4, z23);                    \/\/       sub     z27.b, p4\/m, z27.b, z23.b\n-    __ sve_fabs(z2, __ D, p3, z10);                    \/\/       fabs    z2.d, p3\/m, z10.d\n-    __ sve_fadd(z10, __ S, p6, z22);                   \/\/       fadd    z10.s, p6\/m, z10.s, z22.s\n-    __ sve_fdiv(z3, __ S, p5, z16);                    \/\/       fdiv    z3.s, p5\/m, z3.s, z16.s\n-    __ sve_fmax(z1, __ D, p4, z16);                    \/\/       fmax    z1.d, p4\/m, z1.d, z16.d\n-    __ sve_fmin(z12, __ S, p3, z12);                   \/\/       fmin    z12.s, p3\/m, z12.s, z12.s\n-    __ sve_fmul(z16, __ D, p0, z20);                   \/\/       fmul    z16.d, p0\/m, z16.d, z20.d\n-    __ sve_fneg(z5, __ D, p1, z7);                     \/\/       fneg    z5.d, p1\/m, z7.d\n-    __ sve_frintm(z12, __ D, p7, z16);                 \/\/       frintm  z12.d, p7\/m, z16.d\n-    __ sve_frintn(z6, __ S, p0, z28);                  \/\/       frintn  z6.s, p0\/m, z28.s\n-    __ sve_frintp(z4, __ D, p1, z17);                  \/\/       frintp  z4.d, p1\/m, z17.d\n-    __ sve_fsqrt(z13, __ S, p3, z19);                  \/\/       fsqrt   z13.s, p3\/m, z19.s\n-    __ sve_fsub(z24, __ S, p5, z17);                   \/\/       fsub    z24.s, p5\/m, z24.s, z17.s\n-    __ sve_fmla(z10, __ D, p6, z6, z19);               \/\/       fmla    z10.d, p6\/m, z6.d, z19.d\n-    __ sve_fmls(z13, __ S, p4, z6, z0);                \/\/       fmls    z13.s, p4\/m, z6.s, z0.s\n-    __ sve_fnmla(z14, __ S, p4, z25, z8);              \/\/       fnmla   z14.s, p4\/m, z25.s, z8.s\n-    __ sve_fnmls(z22, __ S, p5, z22, z27);             \/\/       fnmls   z22.s, p5\/m, z22.s, z27.s\n-    __ sve_mla(z3, __ B, p3, z17, z20);                \/\/       mla     z3.b, p3\/m, z17.b, z20.b\n-    __ sve_mls(z4, __ H, p7, z7, z0);                  \/\/       mls     z4.h, p7\/m, z7.h, z0.h\n-    __ sve_and(z16, z19, z22);                         \/\/       and     z16.d, z19.d, z22.d\n-    __ sve_eor(z15, z9, z22);                          \/\/       eor     z15.d, z9.d, z22.d\n-    __ sve_orr(z25, z5, z30);                          \/\/       orr     z25.d, z5.d, z30.d\n+    __ sve_add(z7, __ H, z4, z7);                      \/\/       add     z7.h, z4.h, z7.h\n+    __ sve_sub(z9, __ B, z22, z8);                     \/\/       sub     z9.b, z22.b, z8.b\n+    __ sve_fadd(z27, __ S, z20, z30);                  \/\/       fadd    z27.s, z20.s, z30.s\n+    __ sve_fmul(z26, __ S, z0, z16);                   \/\/       fmul    z26.s, z0.s, z16.s\n+    __ sve_fsub(z3, __ D, z25, z8);                    \/\/       fsub    z3.d, z25.d, z8.d\n+    __ sve_abs(z21, __ D, p6, z26);                    \/\/       abs     z21.d, p6\/m, z26.d\n+    __ sve_add(z22, __ B, p0, z4);                     \/\/       add     z22.b, p0\/m, z22.b, z4.b\n+    __ sve_asr(z17, __ H, p0, z3);                     \/\/       asr     z17.h, p0\/m, z17.h, z3.h\n+    __ sve_cnt(z1, __ B, p2, z6);                      \/\/       cnt     z1.b, p2\/m, z6.b\n+    __ sve_lsl(z9, __ S, p7, z7);                      \/\/       lsl     z9.s, p7\/m, z9.s, z7.s\n+    __ sve_lsr(z22, __ H, p5, z5);                     \/\/       lsr     z22.h, p5\/m, z22.h, z5.h\n+    __ sve_mul(z8, __ B, p4, z30);                     \/\/       mul     z8.b, p4\/m, z8.b, z30.b\n+    __ sve_neg(z17, __ D, p0, z11);                    \/\/       neg     z17.d, p0\/m, z11.d\n+    __ sve_not(z28, __ S, p0, z26);                    \/\/       not     z28.s, p0\/m, z26.s\n+    __ sve_smax(z28, __ D, p3, z13);                   \/\/       smax    z28.d, p3\/m, z28.d, z13.d\n+    __ sve_smin(z16, __ B, p6, z5);                    \/\/       smin    z16.b, p6\/m, z16.b, z5.b\n+    __ sve_sub(z13, __ H, p2, z15);                    \/\/       sub     z13.h, p2\/m, z13.h, z15.h\n+    __ sve_fabs(z26, __ S, p5, z11);                   \/\/       fabs    z26.s, p5\/m, z11.s\n+    __ sve_fadd(z22, __ S, p4, z4);                    \/\/       fadd    z22.s, p4\/m, z22.s, z4.s\n+    __ sve_fdiv(z19, __ S, p4, z17);                   \/\/       fdiv    z19.s, p4\/m, z19.s, z17.s\n+    __ sve_fmax(z14, __ D, p3, z2);                    \/\/       fmax    z14.d, p3\/m, z14.d, z2.d\n+    __ sve_fmin(z3, __ S, p5, z23);                    \/\/       fmin    z3.s, p5\/m, z3.s, z23.s\n+    __ sve_fmul(z6, __ S, p1, z17);                    \/\/       fmul    z6.s, p1\/m, z6.s, z17.s\n+    __ sve_fneg(z27, __ S, p4, z16);                   \/\/       fneg    z27.s, p4\/m, z16.s\n+    __ sve_frintm(z2, __ S, p7, z3);                   \/\/       frintm  z2.s, p7\/m, z3.s\n+    __ sve_frintn(z6, __ S, p4, z19);                  \/\/       frintn  z6.s, p4\/m, z19.s\n+    __ sve_frintp(z12, __ D, p5, z8);                  \/\/       frintp  z12.d, p5\/m, z8.d\n+    __ sve_fsqrt(z19, __ S, p4, z0);                   \/\/       fsqrt   z19.s, p4\/m, z0.s\n+    __ sve_fsub(z23, __ D, p1, z19);                   \/\/       fsub    z23.d, p1\/m, z23.d, z19.d\n+    __ sve_fmla(z13, __ S, p4, z6, z0);                \/\/       fmla    z13.s, p4\/m, z6.s, z0.s\n+    __ sve_fmls(z14, __ S, p4, z25, z8);               \/\/       fmls    z14.s, p4\/m, z25.s, z8.s\n+    __ sve_fnmla(z22, __ S, p5, z22, z27);             \/\/       fnmla   z22.s, p5\/m, z22.s, z27.s\n+    __ sve_fnmls(z3, __ S, p3, z17, z20);              \/\/       fnmls   z3.s, p3\/m, z17.s, z20.s\n+    __ sve_mla(z4, __ H, p7, z7, z0);                  \/\/       mla     z4.h, p7\/m, z7.h, z0.h\n+    __ sve_mls(z16, __ S, p5, z22, z4);                \/\/       mls     z16.s, p5\/m, z22.s, z4.s\n+    __ sve_and(z9, z22, z11);                          \/\/       and     z9.d, z22.d, z11.d\n+    __ sve_eor(z5, z30, z16);                          \/\/       eor     z5.d, z30.d, z16.d\n+    __ sve_orr(z22, z11, z1);                          \/\/       orr     z22.d, z11.d, z1.d\n@@ -905,9 +910,9 @@\n-    __ sve_andv(v13, __ B, p5, z11);                   \/\/       andv b13, p5, z11.b\n-    __ sve_orv(v13, __ S, p2, z20);                    \/\/       orv s13, p2, z20.s\n-    __ sve_eorv(v25, __ B, p3, z4);                    \/\/       eorv b25, p3, z4.b\n-    __ sve_smaxv(v17, __ D, p2, z6);                   \/\/       smaxv d17, p2, z6.d\n-    __ sve_sminv(v4, __ D, p7, z16);                   \/\/       sminv d4, p7, z16.d\n-    __ sve_fminv(v26, __ S, p2, z14);                  \/\/       fminv s26, p2, z14.s\n-    __ sve_fmaxv(v11, __ S, p7, z3);                   \/\/       fmaxv s11, p7, z3.s\n-    __ sve_fadda(v1, __ D, p6, z21);                   \/\/       fadda d1, p6, d1, z21.d\n-    __ sve_uaddv(v14, __ S, p2, z17);                  \/\/       uaddv d14, p2, z17.s\n+    __ sve_andv(v8, __ D, p5, z16);                    \/\/       andv d8, p5, z16.d\n+    __ sve_orv(v15, __ S, p1, z4);                     \/\/       orv s15, p1, z4.s\n+    __ sve_eorv(v8, __ B, p1, z29);                    \/\/       eorv b8, p1, z29.b\n+    __ sve_smaxv(v28, __ D, p4, z29);                  \/\/       smaxv d28, p4, z29.d\n+    __ sve_sminv(v9, __ H, p3, z2);                    \/\/       sminv h9, p3, z2.h\n+    __ sve_fminv(v28, __ S, p0, z7);                   \/\/       fminv s28, p0, z7.s\n+    __ sve_fmaxv(v26, __ S, p5, z17);                  \/\/       fmaxv s26, p5, z17.s\n+    __ sve_fadda(v8, __ D, p4, z21);                   \/\/       fadda d8, p4, d8, z21.d\n+    __ sve_uaddv(v5, __ S, p5, z21);                   \/\/       uaddv d5, p5, z21.s\n@@ -932,7 +937,7 @@\n-    0x14000000,     0x17ffffd7,     0x140002db,     0x94000000,\n-    0x97ffffd4,     0x940002d8,     0x3400000a,     0x34fffa2a,\n-    0x34005aaa,     0x35000008,     0x35fff9c8,     0x35005a48,\n-    0xb400000b,     0xb4fff96b,     0xb40059eb,     0xb500001d,\n-    0xb5fff91d,     0xb500599d,     0x10000013,     0x10fff8b3,\n-    0x10005933,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363058b6,     0x3758000c,     0x375ff7cc,     0x3758584c,\n+    0x14000000,     0x17ffffd7,     0x140002e0,     0x94000000,\n+    0x97ffffd4,     0x940002dd,     0x3400000a,     0x34fffa2a,\n+    0x34005b4a,     0x35000008,     0x35fff9c8,     0x35005ae8,\n+    0xb400000b,     0xb4fff96b,     0xb4005a8b,     0xb500001d,\n+    0xb5fff91d,     0xb5005a3d,     0x10000013,     0x10fff8b3,\n+    0x100059d3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36305956,     0x3758000c,     0x375ff7cc,     0x375858ec,\n@@ -943,13 +948,13 @@\n-    0x54005620,     0x54000001,     0x54fff541,     0x540055c1,\n-    0x54000002,     0x54fff4e2,     0x54005562,     0x54000002,\n-    0x54fff482,     0x54005502,     0x54000003,     0x54fff423,\n-    0x540054a3,     0x54000003,     0x54fff3c3,     0x54005443,\n-    0x54000004,     0x54fff364,     0x540053e4,     0x54000005,\n-    0x54fff305,     0x54005385,     0x54000006,     0x54fff2a6,\n-    0x54005326,     0x54000007,     0x54fff247,     0x540052c7,\n-    0x54000008,     0x54fff1e8,     0x54005268,     0x54000009,\n-    0x54fff189,     0x54005209,     0x5400000a,     0x54fff12a,\n-    0x540051aa,     0x5400000b,     0x54fff0cb,     0x5400514b,\n-    0x5400000c,     0x54fff06c,     0x540050ec,     0x5400000d,\n-    0x54fff00d,     0x5400508d,     0x5400000e,     0x54ffefae,\n-    0x5400502e,     0x5400000f,     0x54ffef4f,     0x54004fcf,\n+    0x540056c0,     0x54000001,     0x54fff541,     0x54005661,\n+    0x54000002,     0x54fff4e2,     0x54005602,     0x54000002,\n+    0x54fff482,     0x540055a2,     0x54000003,     0x54fff423,\n+    0x54005543,     0x54000003,     0x54fff3c3,     0x540054e3,\n+    0x54000004,     0x54fff364,     0x54005484,     0x54000005,\n+    0x54fff305,     0x54005425,     0x54000006,     0x54fff2a6,\n+    0x540053c6,     0x54000007,     0x54fff247,     0x54005367,\n+    0x54000008,     0x54fff1e8,     0x54005308,     0x54000009,\n+    0x54fff189,     0x540052a9,     0x5400000a,     0x54fff12a,\n+    0x5400524a,     0x5400000b,     0x54fff0cb,     0x540051eb,\n+    0x5400000c,     0x54fff06c,     0x5400518c,     0x5400000d,\n+    0x54fff00d,     0x5400512d,     0x5400000e,     0x54ffefae,\n+    0x540050ce,     0x5400000f,     0x54ffef4f,     0x5400506f,\n@@ -987,1 +992,1 @@\n-    0xbd1b1869,     0x5800401b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x580040bb,     0x1800000b,     0xf8945060,\n@@ -1029,87 +1034,88 @@\n-    0x0e31ab38,     0x4e31ab17,     0x0e71a8a4,     0x4e71aa93,\n-    0x4eb1aa0f,     0x6eb0f820,     0x7e30f8a4,     0x7e70fab4,\n-    0x7eb0f98b,     0x7ef0fbdd,     0x0e20ba0f,     0x4e20bad5,\n-    0x0e60b8a4,     0x4e60b9ee,     0x0ea0baf6,     0x4ea0bb59,\n-    0x4ee0b8e6,     0x0ea0f9ac,     0x4ea0f9ee,     0x4ee0f9cd,\n-    0x2ea0f9ee,     0x6ea0f949,     0x6ee0fb59,     0x2ea1fbbc,\n-    0x6ea1f96a,     0x6ee1fa93,     0x2e20598b,     0x6e205a51,\n-    0x0e371ed5,     0x4e311e0f,     0x0eb61eb4,     0x4eb91f17,\n-    0x2e3c1f7a,     0x6e271cc5,     0x0e2884e6,     0x4e31860f,\n-    0x0e71860f,     0x4e7b8759,     0x0eb28630,     0x4ebd879b,\n-    0x4efa8738,     0x0e31d60f,     0x4e3bd759,     0x4e70d5ee,\n-    0x2e2c856a,     0x6e2f85cd,     0x2e7085ee,     0x6e7686b4,\n-    0x2ea38441,     0x6eb886f6,     0x6ee087fe,     0x0eb0d5ee,\n-    0x4ea4d462,     0x4ee8d4e6,     0x0e259c83,     0x4e299d07,\n-    0x0e7a9f38,     0x4e629c20,     0x0ebd9f9b,     0x4ebf9fdd,\n-    0x2ea7d4c5,     0x6ea7d4c5,     0x6effd7dd,     0x2e2ddd8b,\n-    0x6e3bdf59,     0x6e62dc20,     0x0e6097fe,     0x4e629420,\n-    0x0eb39651,     0x4ebe97bc,     0x0e3bcf59,     0x4e2bcd49,\n-    0x4e7bcf59,     0x2e6e95ac,     0x6e71960f,     0x2ead958b,\n-    0x6eac956a,     0x0eb3ce51,     0x4ebacf38,     0x4ef7ced5,\n-    0x2e39ff17,     0x6e22fc20,     0x6e72fe30,     0x0e2c656a,\n-    0x4e2864e6,     0x0e7e67bc,     0x4e6864e6,     0x0ea764c5,\n-    0x4ea764c5,     0x0e36f6b4,     0x4e33f651,     0x4e71f60f,\n-    0x0e336e51,     0x4e3f6fdd,     0x0e7c6f7a,     0x4e7e6fbc,\n-    0x0ea36c41,     0x4ebd6f9b,     0x0ea2f420,     0x4eb6f6b4,\n-    0x4efef7bc,     0x2e318e0f,     0x6e2e8dac,     0x2e6c8d6a,\n-    0x6e7e8fbc,     0x2ebe8fbc,     0x6eb58e93,     0x6ef88ef6,\n-    0x0e2ce56a,     0x4e26e4a4,     0x4e60e7fe,     0x0e3636b4,\n-    0x4e2a3528,     0x0e6037fe,     0x4e733651,     0x0eac356a,\n-    0x4ebd379b,     0x4ee43462,     0x2ebae738,     0x6ea6e4a4,\n-    0x6ee5e483,     0x0e2a3d28,     0x4e383ef6,     0x0e733e51,\n-    0x4e6f3dcd,     0x0ea63ca4,     0x4ebe3fbc,     0x4ef93f17,\n-    0x2e37e6d5,     0x6e3be759,     0x6e7ae738,     0xba5fd3e3,\n-    0x3a5f03e5,     0xfa411be4,     0x7a42cbe2,     0x93df03ff,\n-    0xc820ffff,     0x8822fc7f,     0xc8247cbf,     0x88267fff,\n-    0x4e010fe0,     0x4e081fe1,     0x4e0c1fe1,     0x4e0a1fe1,\n-    0x4e071fe1,     0x4e042c20,     0x4e062c20,     0x4e052c20,\n-    0x4e083c20,     0x0e0c3c20,     0x0e0a3c20,     0x0e073c20,\n-    0x4cc0ac3f,     0x05a08020,     0x04b0e3e0,     0x0470e7e1,\n-    0x042f9c20,     0x043f9c35,     0x047f9c20,     0x04ff9c20,\n-    0x04299420,     0x04319160,     0x0461943e,     0x04a19020,\n-    0x042053ff,     0x047f5401,     0x25208028,     0x2538cfe0,\n-    0x2578d001,     0x25b8efe2,     0x25f8f007,     0xa400a3e0,\n-    0xa4a8a7ea,     0xa547a814,     0xa4084ffe,     0xa55c53e0,\n-    0xa5e1540b,     0xe400fbf6,     0xe408ffff,     0xe547e400,\n-    0xe4014be0,     0xe4a84fe0,     0xe5f15000,     0x858043e0,\n-    0x85a043ff,     0xe59f5d08,     0x1e601000,     0x1e603000,\n-    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n-    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n-    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n-    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n-    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n-    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n-    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n-    0x1e7e1000,     0x1e7e3000,     0xf8238358,     0xf83702af,\n-    0xf8231118,     0xf8392214,     0xf8313022,     0xf8205098,\n-    0xf82343ec,     0xf83c734a,     0xf82261ec,     0xf8bf81a1,\n-    0xf8bd0260,     0xf8ac12d1,     0xf8ad23dc,     0xf8bf3341,\n-    0xf8bc53c4,     0xf8a443c6,     0xf8ba7130,     0xf8a8600c,\n-    0xf8f48301,     0xf8e20120,     0xf8f8121a,     0xf8fe2143,\n-    0xf8f7308a,     0xf8f05162,     0xf8e841ea,     0xf8f17142,\n-    0xf8ec61ec,     0xf86d80e2,     0xf874021a,     0xf8641082,\n-    0xf86c22b0,     0xf8703170,     0xf8755197,     0xf87a4397,\n-    0xf86e730b,     0xf86163ec,     0xb82a80f0,     0xb82201a3,\n-    0xb8331211,     0xb8232161,     0xb83e3105,     0xb82f53dd,\n-    0xb82040f4,     0xb8347397,     0xb835633b,     0xb8a582e1,\n-    0xb8b000bf,     0xb8ac1389,     0xb8af22dd,     0xb8bf33f3,\n-    0xb8a551ee,     0xb8bf4370,     0xb8b47190,     0xb8ab60c9,\n-    0xb8fe8371,     0xb8fc00fe,     0xb8ea1154,     0xb8e42238,\n-    0xb8f13076,     0xb8fd52cf,     0xb8f342d3,     0xb8e270cf,\n-    0xb8ec6170,     0xb86d8037,     0xb87e00b3,     0xb8711202,\n-    0xb876214d,     0xb875337d,     0xb86c507b,     0xb861431f,\n-    0xb8737131,     0xb87c61fb,     0xce367a86,     0xce1e6858,\n-    0xce768d51,     0xce910451,     0xce768338,     0xce6c8622,\n-    0xcec08363,     0xce708b9d,     0x04e900da,     0x042404f1,\n-    0x6596012f,     0x65d40b62,     0x65c00745,     0x0456a72e,\n-    0x04c0175b,     0x04109418,     0x041ab006,     0x0413812f,\n-    0x04118b65,     0x04101694,     0x04d7aa0a,     0x045eb046,\n-    0x04c81c5d,     0x044a1dd6,     0x040112fb,     0x04dcad42,\n-    0x65809aca,     0x658d9603,     0x65c69201,     0x65878d8c,\n-    0x65c28290,     0x04dda4e5,     0x65c2be0c,     0x6580a386,\n-    0x65c1a624,     0x658dae6d,     0x65819638,     0x65f318ca,\n-    0x65a030cd,     0x65a8532e,     0x65bb76d6,     0x04144e23,\n-    0x04407ce4,     0x04363270,     0x04b6312f,     0x047e30b9,\n-    0x041a356d,     0x04982a8d,     0x04192c99,     0x04c828d1,\n-    0x04ca3e04,     0x658729da,     0x65863c6b,     0x65d83aa1,\n-    0x04812a2e,\n+    0x0e31ab38,     0x2e31ab17,     0x4e31a8a4,     0x6e31aa93,\n+    0x0e71aa0f,     0x2e71a820,     0x4e71a8a4,     0x6e71aab4,\n+    0x4eb1a98b,     0x6eb1abdd,     0x6eb0fa0f,     0x7e30fad5,\n+    0x7e70f8a4,     0x7eb0f9ee,     0x7ef0faf6,     0x0e20bb59,\n+    0x4e20b8e6,     0x0e60b9ac,     0x4e60b9ee,     0x0ea0b9cd,\n+    0x4ea0b9ee,     0x4ee0b949,     0x0ea0fb59,     0x4ea0fbbc,\n+    0x4ee0f96a,     0x2ea0fa93,     0x6ea0f98b,     0x6ee0fa51,\n+    0x2ea1fad5,     0x6ea1fa0f,     0x6ee1fab4,     0x2e205b17,\n+    0x6e205b7a,     0x0e271cc5,     0x4e281ce6,     0x0eb11e0f,\n+    0x4eb11e0f,     0x2e3b1f59,     0x6e321e30,     0x0e3d879b,\n+    0x4e3a8738,     0x0e71860f,     0x4e7b8759,     0x0eb085ee,\n+    0x4eac856a,     0x4eef85cd,     0x0e30d5ee,     0x4e36d6b4,\n+    0x4e63d441,     0x2e3886f6,     0x6e2087fe,     0x2e7085ee,\n+    0x6e648462,     0x2ea884e6,     0x6ea58483,     0x6ee98507,\n+    0x0ebad738,     0x4ea2d420,     0x4efdd79b,     0x0e3f9fdd,\n+    0x4e279cc5,     0x0e679cc5,     0x4e7f9fdd,     0x0ead9d8b,\n+    0x4ebb9f59,     0x2ea2d420,     0x6ea0d7fe,     0x6ee2d420,\n+    0x2e33de51,     0x6e3edfbc,     0x6e7bdf59,     0x0e6b9549,\n+    0x4e7b9759,     0x0eae95ac,     0x4eb1960f,     0x0e2dcd8b,\n+    0x4e2ccd6a,     0x4e73ce51,     0x2e7a9738,     0x6e7796d5,\n+    0x2eb99717,     0x6ea29420,     0x0eb2ce30,     0x4eaccd6a,\n+    0x4ee8cce6,     0x2e3effbc,     0x6e28fce6,     0x6e67fcc5,\n+    0x0e2764c5,     0x4e3666b4,     0x0e736651,     0x4e71660f,\n+    0x0eb36651,     0x4ebf67dd,     0x0e3cf77a,     0x4e3ef7bc,\n+    0x4e63f441,     0x0e3d6f9b,     0x4e226c20,     0x0e766eb4,\n+    0x4e7e6fbc,     0x0eb16e0f,     0x4eae6dac,     0x0eacf56a,\n+    0x4ebef7bc,     0x4efef7bc,     0x2e358e93,     0x6e388ef6,\n+    0x2e6c8d6a,     0x6e668ca4,     0x2ea08ffe,     0x6eb68eb4,\n+    0x6eea8d28,     0x0e20e7fe,     0x4e33e651,     0x4e6ce56a,\n+    0x0e3d379b,     0x4e243462,     0x0e7a3738,     0x4e6634a4,\n+    0x0ea53483,     0x4eaa3528,     0x4ef836f6,     0x2eb3e651,\n+    0x6eafe5cd,     0x6ee6e4a4,     0x0e3e3fbc,     0x4e393f17,\n+    0x0e773ed5,     0x4e7b3f59,     0x0eba3f38,     0x4ea53c83,\n+    0x4ef93f17,     0x2e3ce77a,     0x6e39e717,     0x6e70e5ee,\n+    0xba5fd3e3,     0x3a5f03e5,     0xfa411be4,     0x7a42cbe2,\n+    0x93df03ff,     0xc820ffff,     0x8822fc7f,     0xc8247cbf,\n+    0x88267fff,     0x4e010fe0,     0x4e081fe1,     0x4e0c1fe1,\n+    0x4e0a1fe1,     0x4e071fe1,     0x4e042c20,     0x4e062c20,\n+    0x4e052c20,     0x4e083c20,     0x0e0c3c20,     0x0e0a3c20,\n+    0x0e073c20,     0x4cc0ac3f,     0x05a08020,     0x04b0e3e0,\n+    0x0470e7e1,     0x042f9c20,     0x043f9c35,     0x047f9c20,\n+    0x04ff9c20,     0x04299420,     0x04319160,     0x0461943e,\n+    0x04a19020,     0x042053ff,     0x047f5401,     0x25208028,\n+    0x2538cfe0,     0x2578d001,     0x25b8efe2,     0x25f8f007,\n+    0xa400a3e0,     0xa4a8a7ea,     0xa547a814,     0xa4084ffe,\n+    0xa55c53e0,     0xa5e1540b,     0xe400fbf6,     0xe408ffff,\n+    0xe547e400,     0xe4014be0,     0xe4a84fe0,     0xe5f15000,\n+    0x858043e0,     0x85a043ff,     0xe59f5d08,     0x1e601000,\n+    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n+    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n+    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n+    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n+    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n+    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n+    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n+    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf8358303,\n+    0xf8280299,     0xf8301051,     0xf8212300,     0xf8243183,\n+    0xf83f515c,     0xf83a4182,     0xf830703f,     0xf82d601d,\n+    0xf8b3822c,     0xf8b6038d,     0xf8be103f,     0xf8ba209c,\n+    0xf8be30c4,     0xf8be51fa,     0xf8a94188,     0xf8a07034,\n+    0xf8b86002,     0xf8e98358,     0xf8f0007e,     0xf8ea1157,\n+    0xf8e42050,     0xf8eb3148,     0xf8ef5051,     0xf8ea418c,\n+    0xf8ef704d,     0xf8e76354,     0xf8708044,     0xf86401ec,\n+    0xf87511f0,     0xf86b22f5,     0xf86c32fa,     0xf87c516e,\n+    0xf8784181,     0xf87f720a,     0xf8676062,     0xb82d8233,\n+    0xb8300023,     0xb82b10be,     0xb82823af,     0xb83e3280,\n+    0xb82752f4,     0xb83c4375,     0xb8397025,     0xb83763f0,\n+    0xb8a5812c,     0xb8bc03af,     0xb8b6127f,     0xb8bf21c5,\n+    0xb8b031ff,     0xb8bb5214,     0xb8ac412b,     0xb8a6723e,\n+    0xb8bb63dc,     0xb8e7828a,     0xb8ea0304,     0xb8f112d1,\n+    0xb8e321fd,     0xb8f63273,     0xb8f651e2,     0xb8e6420c,\n+    0xb8eb72ed,     0xb8e1627e,     0xb8658051,     0xb87001b6,\n+    0xb86a13b5,     0xb87b236c,     0xb86333e1,     0xb8785233,\n+    0xb869437c,     0xb86f72a7,     0xb877633f,     0xce3a47c2,\n+    0xce110aca,     0xce788c11,     0xce8296d9,     0xce7b806c,\n+    0xce70879d,     0xcec080da,     0xce718b89,     0x04670087,\n+    0x042806c9,     0x659e029b,     0x6590081a,     0x65c80723,\n+    0x04d6bb55,     0x04000096,     0x04508071,     0x041aa8c1,\n+    0x04939ce9,     0x045194b6,     0x041013c8,     0x04d7a171,\n+    0x049ea35c,     0x04c80dbc,     0x040a18b0,     0x044109ed,\n+    0x049cb57a,     0x65809096,     0x658d9233,     0x65c68c4e,\n+    0x658796e3,     0x65828626,     0x049db21b,     0x6582bc62,\n+    0x6580b266,     0x65c1b50c,     0x658db013,     0x65c18677,\n+    0x65a010cd,     0x65a8332e,     0x65bb56d6,     0x65b46e23,\n+    0x04405ce4,     0x048476d0,     0x042b32c9,     0x04b033c5,\n+    0x04613176,     0x04da3608,     0x0498248f,     0x041927a8,\n+    0x04c833bc,     0x044a2c49,     0x658720fc,     0x6586363a,\n+    0x65d832a8,     0x048136a5,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":363,"deletions":357,"binary":false,"changes":720,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -74,0 +75,22 @@\n+\n+\n+\/\/ SharedArchiveConfigFile is used only during \"java -Xshare:dump\", so\n+\/\/ it's safe to modify its value in gtest\n+\n+TEST_VM(FlagAccess, ccstr_flag) {\n+  FLAG_SET_CMDLINE(SharedArchiveConfigFile, \"\");\n+  ASSERT_EQ(FLAG_IS_CMDLINE(SharedArchiveConfigFile), true);\n+  ASSERT_EQ(strcmp(SharedArchiveConfigFile, \"\"), 0);\n+\n+  FLAG_SET_ERGO(SharedArchiveConfigFile, \"foobar\");\n+  ASSERT_EQ(FLAG_IS_ERGO(SharedArchiveConfigFile), true);\n+  ASSERT_EQ(strcmp(SharedArchiveConfigFile, \"foobar\") , 0);\n+\n+  FLAG_SET_ERGO(SharedArchiveConfigFile, nullptr);\n+  ASSERT_EQ(FLAG_IS_ERGO(SharedArchiveConfigFile), true);\n+  ASSERT_EQ(SharedArchiveConfigFile, nullptr);\n+\n+  FLAG_SET_ERGO(SharedArchiveConfigFile, \"xyz\");\n+  ASSERT_EQ(FLAG_IS_ERGO(SharedArchiveConfigFile), true);\n+  ASSERT_EQ(strcmp(SharedArchiveConfigFile, \"xyz\"), 0);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_globals.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/lockFreeQueue.inline.hpp\"\n+#include \"utilities\/pair.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+#include <new>\n+\n+class LockFreeQueueTestElement {\n+  typedef LockFreeQueueTestElement Element;\n+\n+  Element* volatile _entry;\n+  Element* volatile _entry1;\n+  size_t _id;\n+\n+  static Element* volatile* entry_ptr(Element& e) { return &e._entry; }\n+  static Element* volatile* entry1_ptr(Element& e) { return &e._entry1; }\n+\n+public:\n+  class TestQueue: public LockFreeQueue<Element, &entry_ptr> {\n+  public:\n+    Element* pop() {\n+      using Status = LockFreeQueuePopStatus;\n+      while (true) {\n+        Pair<Status, Element*> pop_result = try_pop();\n+        if (pop_result.first == Status::success) {\n+          return pop_result.second;\n+        }\n+        \/\/ Retry until success.\n+      }\n+    }\n+  };\n+  class TestQueue1: public LockFreeQueue<Element, &entry1_ptr> {\n+  public:\n+    Element* pop() {\n+      using Status = LockFreeQueuePopStatus;\n+      while (true) {\n+        Pair<Status, Element*> pop_result = try_pop();\n+        if (pop_result.first == Status::success) {\n+          return pop_result.second;\n+        }\n+        \/\/ Retry until success.\n+      }\n+    }\n+  };\n+\n+  LockFreeQueueTestElement(size_t id = 0) : _entry(), _entry1(), _id(id) {}\n+  size_t id() const { return _id; }\n+  void set_id(size_t value) { _id = value; }\n+  Element* next() { return _entry; }\n+  Element* next1() { return _entry1; }\n+};\n+\n+typedef LockFreeQueueTestElement Element;\n+typedef Element::TestQueue TestQueue;\n+typedef Element::TestQueue1 TestQueue1;\n+\n+static void initialize(Element* elements, size_t size, TestQueue* queue) {\n+  for (size_t i = 0; i < size; ++i) {\n+    elements[i].set_id(i);\n+  }\n+  ASSERT_TRUE(queue->empty());\n+  ASSERT_EQ(0u, queue->length());\n+  ASSERT_TRUE(queue->pop() == NULL);\n+  ASSERT_TRUE(queue->top() == NULL);\n+\n+  for (size_t id = 0; id < size; ++id) {\n+    ASSERT_EQ(id, queue->length());\n+    Element* e = &elements[id];\n+    ASSERT_EQ(id, e->id());\n+    queue->push(*e);\n+    ASSERT_FALSE(queue->empty());\n+    \/\/ top() is always the oldest element.\n+    ASSERT_EQ(&elements[0], queue->top());\n+  }\n+}\n+\n+class LockFreeQueueTestBasics : public ::testing::Test {\n+public:\n+  LockFreeQueueTestBasics();\n+\n+  static const size_t nelements = 10;\n+  Element elements[nelements];\n+  TestQueue queue;\n+};\n+\n+const size_t LockFreeQueueTestBasics::nelements;\n+\n+LockFreeQueueTestBasics::LockFreeQueueTestBasics() : queue() {\n+  initialize(elements, nelements, &queue);\n+}\n+\n+TEST_F(LockFreeQueueTestBasics, pop) {\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_FALSE(queue.empty());\n+    ASSERT_EQ(nelements - i, queue.length());\n+    Element* e = queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+  }\n+  ASSERT_TRUE(queue.empty());\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_TRUE(queue.pop() == NULL);\n+}\n+\n+TEST_F(LockFreeQueueTestBasics, append) {\n+  TestQueue other_queue;\n+  ASSERT_TRUE(other_queue.empty());\n+  ASSERT_EQ(0u, other_queue.length());\n+  ASSERT_TRUE(other_queue.top() == NULL);\n+  ASSERT_TRUE(other_queue.pop() == NULL);\n+\n+  Pair<Element*, Element*> pair = queue.take_all();\n+  other_queue.append(*pair.first, *pair.second);\n+  ASSERT_EQ(nelements, other_queue.length());\n+  ASSERT_TRUE(queue.empty());\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_TRUE(queue.pop() == NULL);\n+  ASSERT_TRUE(queue.top() == NULL);\n+\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_EQ(nelements - i, other_queue.length());\n+    Element* e = other_queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+  }\n+  ASSERT_EQ(0u, other_queue.length());\n+  ASSERT_TRUE(other_queue.pop() == NULL);\n+}\n+\n+TEST_F(LockFreeQueueTestBasics, two_queues) {\n+  TestQueue1 queue1;\n+  ASSERT_TRUE(queue1.pop() == NULL);\n+\n+  for (size_t id = 0; id < nelements; ++id) {\n+    queue1.push(elements[id]);\n+  }\n+  ASSERT_EQ(nelements, queue1.length());\n+  Element* e0 = queue.top();\n+  Element* e1 = queue1.top();\n+  while (true) {\n+    ASSERT_EQ(e0, e1);\n+    if (e0 == NULL) break;\n+    e0 = e0->next();\n+    e1 = e1->next1();\n+  }\n+\n+  for (size_t i = 0; i < nelements; ++i) {\n+    ASSERT_EQ(nelements - i, queue.length());\n+    ASSERT_EQ(nelements - i, queue1.length());\n+\n+    Element* e = queue.pop();\n+    ASSERT_TRUE(e != NULL);\n+    ASSERT_EQ(&elements[i], e);\n+    ASSERT_EQ(i, e->id());\n+\n+    Element* e1 = queue1.pop();\n+    ASSERT_TRUE(e1 != NULL);\n+    ASSERT_EQ(&elements[i], e1);\n+    ASSERT_EQ(i, e1->id());\n+\n+    ASSERT_EQ(e, e1);\n+  }\n+  ASSERT_EQ(0u, queue.length());\n+  ASSERT_EQ(0u, queue1.length());\n+  ASSERT_TRUE(queue.pop() == NULL);\n+  ASSERT_TRUE(queue1.pop() == NULL);\n+}\n+\n+class LockFreeQueueTestThread : public JavaTestThread {\n+  uint _id;\n+  TestQueue* _from;\n+  TestQueue* _to;\n+  volatile size_t* _processed;\n+  size_t _process_limit;\n+  size_t _local_processed;\n+  volatile bool _ready;\n+\n+public:\n+  LockFreeQueueTestThread(Semaphore* post,\n+                          uint id,\n+                          TestQueue* from,\n+                          TestQueue* to,\n+                          volatile size_t* processed,\n+                          size_t process_limit) :\n+    JavaTestThread(post),\n+    _id(id),\n+    _from(from),\n+    _to(to),\n+    _processed(processed),\n+    _process_limit(process_limit),\n+    _local_processed(0),\n+    _ready(false)\n+  {}\n+\n+  virtual void main_run() {\n+    Atomic::release_store_fence(&_ready, true);\n+    while (true) {\n+      Element* e = _from->pop();\n+      if (e != NULL) {\n+        _to->push(*e);\n+        Atomic::inc(_processed);\n+        ++_local_processed;\n+      } else if (Atomic::load_acquire(_processed) == _process_limit) {\n+        tty->print_cr(\"thread %u processed \" SIZE_FORMAT, _id, _local_processed);\n+        return;\n+      }\n+    }\n+  }\n+\n+  bool ready() const { return Atomic::load_acquire(&_ready); }\n+};\n+\n+TEST_VM(LockFreeQueueTest, stress) {\n+  Semaphore post;\n+  TestQueue initial_queue;\n+  TestQueue start_queue;\n+  TestQueue middle_queue;\n+  TestQueue final_queue;\n+  volatile size_t stage1_processed = 0;\n+  volatile size_t stage2_processed = 0;\n+\n+  const size_t nelements = 10000;\n+  Element* elements = NEW_C_HEAP_ARRAY(Element, nelements, mtOther);\n+  for (size_t id = 0; id < nelements; ++id) {\n+    ::new (&elements[id]) Element(id);\n+    initial_queue.push(elements[id]);\n+  }\n+  ASSERT_EQ(nelements, initial_queue.length());\n+\n+  \/\/ - stage1 threads pop from start_queue and push to middle_queue.\n+  \/\/ - stage2 threads pop from middle_queue and push to final_queue.\n+  \/\/ - all threads in a stage count the number of elements processed in\n+  \/\/   their corresponding stageN_processed counter.\n+\n+  const uint stage1_threads = 2;\n+  const uint stage2_threads = 2;\n+  const uint nthreads = stage1_threads + stage2_threads;\n+  LockFreeQueueTestThread* threads[nthreads] = {};\n+\n+  for (uint i = 0; i < ARRAY_SIZE(threads); ++i) {\n+    TestQueue* from = &start_queue;\n+    TestQueue* to = &middle_queue;\n+    volatile size_t* processed = &stage1_processed;\n+    if (i >= stage1_threads) {\n+      from = &middle_queue;\n+      to = &final_queue;\n+      processed = &stage2_processed;\n+    }\n+    threads[i] =\n+      new LockFreeQueueTestThread(&post, i, from, to, processed, nelements);\n+    threads[i]->doit();\n+    while (!threads[i]->ready()) {} \/\/ Wait until ready to start test.\n+  }\n+\n+  \/\/ Transfer elements to start_queue to start test.\n+  Pair<Element*, Element*> pair = initial_queue.take_all();\n+  start_queue.append(*pair.first, *pair.second);\n+\n+  \/\/ Wait for all threads to complete.\n+  for (uint i = 0; i < nthreads; ++i) {\n+    post.wait();\n+  }\n+\n+  \/\/ Verify expected state.\n+  ASSERT_EQ(nelements, stage1_processed);\n+  ASSERT_EQ(nelements, stage2_processed);\n+  ASSERT_EQ(0u, initial_queue.length());\n+  ASSERT_EQ(0u, start_queue.length());\n+  ASSERT_EQ(0u, middle_queue.length());\n+  ASSERT_EQ(nelements, final_queue.length());\n+  while (final_queue.pop() != NULL) {}\n+\n+  FREE_C_HEAP_ARRAY(Element, elements);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_lockFreeQueue.cpp","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-        Path file = Paths.get(\"jatoc.cmd\");\n+        Path file = Paths.get(\"jaotc.cmd\");\n","filename":"test\/hotspot\/jtreg\/compiler\/aot\/cli\/jaotc\/AtFileTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8263707\n+ * @summary Test range check for constant array and NewMultiArray is removed properly\n+ * @requires vm.debug == true & vm.compiler1.enabled\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm compiler.c1.TestRangeCheckEliminated\n+ *\n+ * @author Hui Shi\n+*\/\n+\n+package compiler.c1;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestRangeCheckEliminated {\n+    static final String eliminated = \"can be fully eliminated\";\n+    public static void main(String[] args) throws Throwable {\n+        boolean error = false;\n+        String[] procArgs = new String[] {\n+            \"-XX:CompileCommand=compileonly,*test_constant_array::constant_array_rc\",\n+            \"-XX:TieredStopAtLevel=1\",\n+            \"-XX:+TraceRangeCheckElimination\",\n+            \"-XX:-BackgroundCompilation\",\n+            \"compiler.c1.TestRangeCheckEliminated$test_constant_array\"\n+            };\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(procArgs);\n+        String output = new OutputAnalyzer(pb.start()).getOutput();\n+        \/\/ should have 2 \"can be fully eliminated\"\n+        System.out.println(output);\n+        if ((output.split(eliminated, -1).length - 1) == 2) {\n+            System.out.println(\"test_constant_array pass\");\n+        } else {\n+            System.out.println(\"test_constant_array fail\");\n+            error = true;\n+        }\n+\n+        procArgs = new String[] {\n+            \"-XX:CompileCommand=compileonly,*test_multi_constant_array::multi_constant_array_rc\",\n+            \"-XX:TieredStopAtLevel=1\",\n+            \"-XX:+TraceRangeCheckElimination\",\n+            \"-XX:-BackgroundCompilation\",\n+            \"compiler.c1.TestRangeCheckEliminated$test_multi_constant_array\"\n+            };\n+\n+        pb = ProcessTools.createJavaProcessBuilder(procArgs);\n+        output = new OutputAnalyzer(pb.start()).getOutput();\n+        \/\/ should have 1 \"can be fully eliminated\"\n+        System.out.println(output);\n+        if ((output.split(eliminated, -1).length - 1) == 1) {\n+            System.out.println(\"test_multi_constant_array pass\");\n+        } else {\n+            System.out.println(\"test_multi_constant_array fail\");\n+            error = true;\n+        }\n+\n+        procArgs = new String[] {\n+            \"-XX:CompileCommand=compileonly,*test_multi_new_array::multi_new_array_rc\",\n+            \"-XX:TieredStopAtLevel=1\",\n+            \"-XX:+TraceRangeCheckElimination\",\n+            \"-XX:-BackgroundCompilation\",\n+            \"compiler.c1.TestRangeCheckEliminated$test_multi_new_array\"\n+            };\n+\n+        pb = ProcessTools.createJavaProcessBuilder(procArgs);\n+        output = new OutputAnalyzer(pb.start()).getOutput();\n+        \/\/ should have 2 \"can be fully eliminated\"\n+        System.out.println(output);\n+        if ((output.split(eliminated, -1).length - 1) == 2) {\n+            System.out.println(\"test_multi_new_array pass\");\n+        } else {\n+            System.out.println(\"test_multi_new_array fail\");\n+            error = true;\n+        }\n+\n+        if (error) {\n+            throw new InternalError();\n+        }\n+    }\n+\n+    public static class test_constant_array {\n+        static final int constant_array[] =\n+            {50,60,55,67,70,62,65,70,70,81,72,66,77,80,69};\n+        static void constant_array_rc() {\n+            constant_array[1] += 5;\n+        }\n+\n+        public static void main(String[] args) {\n+            for(int i = 0; i < 1_000; i++) {\n+                constant_array_rc();\n+            }\n+        }\n+    }\n+\n+    public static class test_multi_constant_array {\n+        static final int constant_multi_array[][] = {\n+            {50,60,55,67,70}, {62,65,70,70,81}, {72,66,77,80,69}};\n+        static void multi_constant_array_rc() {\n+            constant_multi_array[2][3] += 5;\n+        }\n+\n+        public static void main(String[] args) {\n+            for(int i = 0; i < 1_000; i++) {\n+                multi_constant_array_rc();\n+            }\n+        }\n+    }\n+\n+    public static class test_multi_new_array {\n+        static void foo(int i) {}\n+        static void multi_new_array_rc(int index) {\n+            int na[] = new int[800];\n+            int nma[][] = new int[600][2];\n+            nma[20][1] += 5;   \/\/ optimize rc on NewMultiArray first dimension\n+            nma[index][0] = 0; \/\/ index < 600 after this statement\n+            foo(na[index]);    \/\/ index must < 800, remove rc\n+        }\n+\n+        public static void main(String[] args) {\n+            for(int i = 0; i < 600; i++) {\n+                multi_new_array_rc(i);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestRangeCheckEliminated.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,8 @@\n+\/**\n+ * @test\n+ * @bug 8264223\n+ * @summary add CodeHeap verification\n+ *\n+ * @requires vm.debug\n+ * @run main\/othervm -Xcomp -XX:+VerifyCodeCache compiler.codegen.Test6935535\n+ *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/Test6935535.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8262739\n+ * @summary Test correct insertion of anti-dependencies after String inflation.\n+ * @run main\/othervm -Xbatch\n+ *                   compiler.controldependency.TestAntiDependencyAfterStringInflation\n+ *\/\n+\n+package compiler.controldependency;\n+\n+public class TestAntiDependencyAfterStringInflation {\n+\n+    static String reverseString(String str) {\n+        int size = str.length();\n+        char[] buffer = new char[size];\n+        reverse(str, buffer, size);\n+        return new String(buffer, 0, size);\n+    }\n+\n+    static void reverse(String str, char[] buffer, int size) {\n+        \/\/ Inflate String.value byte[] to char[]\n+        str.getChars(0, size, buffer, 0);\n+        \/\/ Reverse String by copying buffer elements. This will fail\n+        \/\/ if C2 does not insert anti-dependencies between loads\/stores.\n+        int half = size \/ 2;\n+        for (int l = 0, r = size - 1; l < half; l++, r--) {\n+            char tmp = buffer[l];\n+            buffer[l] = buffer[r];\n+            buffer[r] = tmp;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 50_000; i++) {\n+            String res = reverseString(\"0123456789\");\n+            if (!res.equals(\"9876543210\")) {\n+                throw new RuntimeException(\"Unexpected result: \" + res);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/controldependency\/TestAntiDependencyAfterStringInflation.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8263971\n+ * @summary C2 crashes with SIGFPE with -XX:+StressGCM and -XX:+StressIGVN\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestLostDependencyOnZeroTripGuard -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressGCM -XX:StressSeed=886771365 TestLostDependencyOnZeroTripGuard\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestLostDependencyOnZeroTripGuard -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+IgnoreUnrecognizedVMOptions -XX:+StressGCM TestLostDependencyOnZeroTripGuard\n+ *\n+ *\/\n+\n+public class TestLostDependencyOnZeroTripGuard {\n+\n+    public static final int N = 400;\n+\n+    public int iArrFld[]=new int[N];\n+\n+    public void mainTest(String[] strArr1) {\n+\n+        int i=57657, i1=577, i2=6, i3=157, i4=12, i23=61271;\n+        boolean bArr[]=new boolean[N];\n+\n+        for (i = 9; 379 > i; i++) {\n+            i2 = 1;\n+            do {\n+                i1 <<= i3;\n+            } while (++i2 < 68);\n+            for (i23 = 68; i23 > 3; i23--) {\n+                bArr[i23 + 1] = true;\n+                try {\n+                    i1 = (-42360 \/ i23);\n+                    iArrFld[i + 1] = (i4 % 15384);\n+                } catch (ArithmeticException a_e) {}\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestLostDependencyOnZeroTripGuard _instance = new TestLostDependencyOnZeroTripGuard();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLostDependencyOnZeroTripGuard.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n- * @run main\/othervm -XX:+UseZGC -XX:+UnlockDiagnosticVMOptions -XX:+StressGCM compiler.loopopts.TestRangeCheckPredicatesControl\n+ * @run main\/othervm -XX:+UseZGC -XX:+UnlockDiagnosticVMOptions -XX:+IgnoreUnrecognizedVMOptions -XX:+StressGCM compiler.loopopts.TestRangeCheckPredicatesControl\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestRangeCheckPredicatesControl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xcomp -XX:-PartialPeelLoop -XX:CompileCommand=compileonly,compiler.loopopts.TestUnswitchCloneSkeletonPredicates::*\n+ * @run main\/othervm -Xcomp -XX:+IgnoreUnrecognizedVMOptions -XX:-PartialPeelLoop -XX:CompileCommand=compileonly,compiler.loopopts.TestUnswitchCloneSkeletonPredicates::*\n@@ -32,1 +32,1 @@\n- * @run main\/othervm -XX:-PartialPeelLoop compiler.loopopts.TestUnswitchCloneSkeletonPredicates\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:-PartialPeelLoop compiler.loopopts.TestUnswitchCloneSkeletonPredicates\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestUnswitchCloneSkeletonPredicates.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.compiler2.enabled\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/Vec_MulAddS2I.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8264360\n+ * @summary Loop strip mining verification fails with \"should be on the backedge\"\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation TestLoadOnBackedgeWithPrec\n+ *\n+ *\/\n+\n+\n+class a {\n+    int g = 20;\n+    float h = 2;\n+    long b = 6;\n+}\n+\n+public class TestLoadOnBackedgeWithPrec {\n+    int c ;\n+    a[] i = {new a()};\n+    float j() {\n+        a k = new a();\n+        float l = 5;\n+        for (int d = 0; d < 8; ++d) {\n+            for (int e = 0; e < 9; ++e) {\n+                k = k;\n+                l *= k.g;\n+            }\n+            for (int f = 0; f < 9; ++f) {\n+                new a();\n+            }\n+            {\n+                a[] m = {\n+                    new a(), new a(), new a(),\n+                    new a(), new a(), new a(),\n+                    new a(), new a(), new a()};\n+                c = i[0].g + k.g;\n+            }\n+        }\n+        return k.h;\n+    }\n+    public static void main(String[] args) {\n+        TestLoadOnBackedgeWithPrec n = new TestLoadOnBackedgeWithPrec();\n+        for (int i = 0; i < 5_000; i++) {\n+            n.j();\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/TestLoadOnBackedgeWithPrec.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm -Xcomp -XX:CompileOnly=TestSubTypeCheckMacroNodeWrongMem::test -XX:-DoEscapeAnalysis TestSubTypeCheckMacroNodeWrongMem\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestSubTypeCheckMacroNodeWrongMem::test -XX:+IgnoreUnrecognizedVMOptions -XX:-DoEscapeAnalysis TestSubTypeCheckMacroNodeWrongMem\n","filename":"test\/hotspot\/jtreg\/compiler\/types\/TestSubTypeCheckMacroNodeWrongMem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm -XX:-BackgroundCompilation -XX:+UseCountedLoopSafepoints -XX:LoopStripMiningIter=2 -XX:-TieredCompilation TestVectorsNotSavedAtSafepoint test1\n+ * @run main\/othervm -XX:-BackgroundCompilation -XX:+IgnoreUnrecognizedVMOptions -XX:+UseCountedLoopSafepoints -XX:LoopStripMiningIter=2 -XX:-TieredCompilation TestVectorsNotSavedAtSafepoint test1\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestVectorsNotSavedAtSafepoint.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Tests WB::isMethodCompilable(m) in combination with compiler directives that prevent a compilation of m.\n+ * @bug 8263582\n+ * @library \/test\/lib \/\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:CompileCommand=compileonly,compiler.whitebox.TestMethodCompilableCompilerDirectives::doesNotExist\n+ *      compiler.whitebox.TestMethodCompilableCompilerDirectives\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      -XX:CompileCommand=exclude,compiler.whitebox.TestMethodCompilableCompilerDirectives::*\n+ *      compiler.whitebox.TestMethodCompilableCompilerDirectives\n+ *\/\n+\n+package compiler.whitebox;\n+\n+import jdk.test.lib.Asserts;\n+import sun.hotspot.WhiteBox;\n+import java.lang.reflect.Method;\n+\n+public class TestMethodCompilableCompilerDirectives {\n+    private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    \/\/ Method too simple for C2 and only C1 compiled.\n+    public static int c1Compiled() {\n+        return 3;\n+    }\n+\n+\n+    \/\/ Method first C1 and then C2 compiled.\n+    public static int c2Compiled() {\n+        for (int i = 0; i < 100; i++);\n+        return 3;\n+    }\n+\n+    \/\/ WB::isMethodCompilable(m) uses Method::is_not_compilable() to decide if m is compilable. Method::is_not_compilable(), however,\n+    \/\/ returns false regardless of any compiler directives if m was not yet tried to be compiled. The compiler directive ExcludeOption\n+    \/\/ to prevent a compilation is evaluated lazily and is only applied when a compilation for m is attempted.\n+    \/\/ Another problem is that Method::is_not_compilable() only returns true for CompLevel_any if C1 AND C2 cannot compile it.\n+    \/\/ This means that a compilation of m must have been attempted for C1 and C2 before WB::isMethodCompilable(m, CompLevel_any) will\n+    \/\/ ever return false. This disregards any compiler directives (e.g. compileonly, exclude) that prohibit a compilation of m completely.\n+    \/\/ WB::isMethodCompilable() should be aware of the ExcludeOption compiler directives at any point in time.\n+    public static void main(String[] args) throws NoSuchMethodException {\n+        Method c1CompiledMethod = TestMethodCompilableCompilerDirectives.class.getDeclaredMethod(\"c1Compiled\");\n+        Method c2CompiledMethod = TestMethodCompilableCompilerDirectives.class.getDeclaredMethod(\"c2Compiled\");\n+\n+        boolean compilable = WhiteBox.getWhiteBox().isMethodCompilable(c1CompiledMethod);\n+        Asserts.assertFalse(compilable);\n+        for (int i = 0; i < 3000; i++) {\n+            c1Compiled();\n+        }\n+        compilable = WhiteBox.getWhiteBox().isMethodCompilable(c1CompiledMethod);\n+        Asserts.assertFalse(compilable);\n+\n+\n+        compilable = WhiteBox.getWhiteBox().isMethodCompilable(c2CompiledMethod);\n+        Asserts.assertFalse(compilable);\n+        for (int i = 0; i < 3000; i++) {\n+            c2Compiled();\n+        }\n+        compilable = WhiteBox.getWhiteBox().isMethodCompilable(c2CompiledMethod);\n+        Asserts.assertFalse(compilable);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/whitebox\/TestMethodCompilableCompilerDirectives.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8258393\n+ * @bug 8258393 8263376\n@@ -41,3 +41,7 @@\n-            test(a);\n-            test(b);\n-            test(c);\n+            test1(a);\n+            test1(b);\n+            test1(c);\n+\n+            test2(a, i);\n+            test2(b, i);\n+            test2(c, i);\n@@ -47,1 +51,1 @@\n-    private static Object test(A a) {\n+    private static Object test1(A a) {\n@@ -61,0 +65,19 @@\n+    static int field;\n+\n+    private static Object test2(A a, int i) {\n+        if (a.getClass() == A.class) {\n+        }\n+\n+        Object o = null;\n+        try {\n+            a.m();\n+            o = a.getClass();\n+        } catch (Exception e) {\n+            i = 42;\n+        }\n+        if (i == 42) {\n+            field = 42;\n+        }\n+        return o;\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestBadRawMemoryAfterCall.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.*;\n+\n+public class AsmClasses implements Opcodes {\n+\n+    \/\/ class B extends A {} to generate ClassCircularityError\n+    \/\/ Can't use jcod, jasm or InMemoryCompiler because the compiler will\n+    \/\/ see that A extends B and fail.\n+    public static byte[] dumpB() throws Exception {\n+\n+        ClassWriter classWriter = new ClassWriter(0);\n+        FieldVisitor fieldVisitor;\n+        RecordComponentVisitor recordComponentVisitor;\n+        MethodVisitor methodVisitor;\n+        AnnotationVisitor annotationVisitor0;\n+\n+        classWriter.visit(61, ACC_PUBLIC | ACC_SUPER, \"B\", null, \"A\", null);\n+\n+        classWriter.visitSource(\"B.java\", null);\n+        methodVisitor = classWriter.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+        methodVisitor.visitCode();\n+        Label label0 = new Label();\n+        methodVisitor.visitLabel(label0);\n+        methodVisitor.visitLineNumber(24, label0);\n+        methodVisitor.visitVarInsn(ALOAD, 0);\n+        methodVisitor.visitMethodInsn(INVOKESPECIAL, \"A\", \"<init>\", \"()V\", false);\n+        methodVisitor.visitInsn(RETURN);\n+        methodVisitor.visitMaxs(1, 1);\n+        methodVisitor.visitEnd();\n+        classWriter.visitEnd();\n+\n+        return classWriter.toByteArray();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/AsmClasses.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class ClassLoadingThread extends Thread {\n+\n+    private ClassLoader ldr = null;\n+    private Object thread_sync = null;\n+\n+    public ClassLoadingThread(ClassLoader loader, Object sync) {\n+        ldr = loader;\n+        thread_sync = sync;\n+    }\n+\n+    private boolean success = true;\n+    public boolean report_success() { return success; }\n+\n+    public void run() {\n+        try {\n+            ThreadPrint.println(\"Starting...\");\n+            \/\/ Initiate class loading using specified type\n+            Class<?> a = Class.forName(\"ClassInLoader\", true, ldr);\n+            Object obj = a.getConstructor().newInstance();\n+\n+        } catch (Throwable e) {\n+            ThreadPrint.println(\"Exception is caught: \" + e);\n+            e.printStackTrace();\n+            success = false;\n+        } finally {\n+            ThreadPrint.println(\"Finished\");\n+            \/\/ Wake up the second thread\n+            synchronized (thread_sync) {\n+                thread_sync.notify();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ClassLoadingThread.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import jdk.test.lib.classloader.ClassUnloadCommon;\n+\n+\/\/ This class loader will deadlock where one thread has a lock for A, trying to get a lock for B\n+\/\/ and the other thread has a lock for B, trying to get a lock for A in the case of\n+\/\/ A extends B extends A.  It should throw ClassCircularityError from both threads.\n+\n+class MyLoader extends ClassLoader {\n+    static {\n+        registerAsParallelCapable();\n+    }\n+\n+    private static boolean first = true;\n+\n+    public Class loadClass(String name) throws ClassNotFoundException {\n+        \/\/ Wait before getting B lock.\n+        if (name.equals(\"B\") && first) {\n+            first = false;\n+            makeThreadWait();\n+        }\n+        synchronized(getClassLoadingLock(name)) {\n+            Class<?> c = findLoadedClass(name);\n+            if (c != null) return c;\n+\n+            if (name.equals(\"B\") && !first) {\n+              wakeUpThread();\n+            }\n+\n+            byte[] b = loadClassData(name);\n+            if (b != null) {\n+                return defineClass(name, b, 0, b.length);\n+            } else {\n+                return super.loadClass(name);\n+            }\n+        }\n+    }\n+\n+    private static boolean parallel = false;\n+    private Object sync = new Object();\n+    private Object thread_sync = new Object();\n+\n+    private void makeThreadWait() {\n+        if (!parallel) { return; }\n+\n+        \/\/ Wake up the second thread here.\n+        synchronized (thread_sync) {\n+            thread_sync.notify();\n+        }\n+        if (isRegisteredAsParallelCapable()) {\n+            synchronized(sync) {\n+                try {\n+                    ThreadPrint.println(\"t1 waits parallelCapable loader\");\n+                    sync.wait();  \/\/ Give up lock before request to load B\n+                } catch (InterruptedException e) {}\n+             }\n+         } else {\n+             try {\n+                ThreadPrint.println(\"t1 waits non-parallelCapable loader\");\n+                wait();  \/\/ Give up lock before request to load B\n+              } catch (InterruptedException e) {}\n+         }\n+    }\n+\n+    \/\/ Parallel capable loader should wake up the first thread.\n+    \/\/ Non-parallelCapable class loader thread will be woken up by the jvm.\n+    private void wakeUpThread() {\n+        if (isRegisteredAsParallelCapable()) {\n+            synchronized(sync) {\n+                sync.notify();\n+            }\n+        }\n+    }\n+\n+    private byte[] loadClassData(String name) {\n+        if (name.equals(\"A\")) {\n+            ThreadPrint.println(\"loading A extends B\");\n+            return ClassUnloadCommon.getClassData(\"A\");\n+        } else if (name.equals(\"B\")) {\n+            ThreadPrint.println(\"loading B extends A\");\n+            try {\n+                return AsmClasses.dumpB();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+                return null;\n+            }\n+        } else if (!name.startsWith(\"java\")) {\n+            return ClassUnloadCommon.getClassData(name);\n+        }\n+        return null;\n+    }\n+\n+\n+    ClassLoadingThread[] threads = new ClassLoadingThread[2];\n+    private boolean success = true;\n+\n+    public boolean report_success() {\n+        for (int i = 0; i < 2; i++) {\n+          try {\n+            threads[i].join();\n+            if (!threads[i].report_success()) success = false;\n+          } catch (InterruptedException e) {}\n+        }\n+        return success;\n+    }\n+\n+    void startLoading() {\n+\n+        for (int i = 0; i < 2; i++) {\n+            threads[i] = new ClassLoadingThread(this, thread_sync);\n+            threads[i].setName(\"Loading Thread #\" + (i + 1));\n+            threads[i].start();\n+            System.out.println(\"Thread \" + (i + 1) + \" was started...\");\n+            \/\/ wait to start the second thread if not concurrent\n+            if (i == 0) {\n+                synchronized(thread_sync) {\n+                    try {\n+                        ThreadPrint.println(\"t2 waits\");\n+                        thread_sync.wait();\n+                    } catch (InterruptedException e) {}\n+                }\n+            }\n+        }\n+    }\n+\n+    MyLoader(boolean load_in_parallel) {\n+       parallel = load_in_parallel;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyLoader.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+class MyNonParallelLoader extends MyLoader {\n+    \/\/ This loader isn't parallel capable because it's not registered in the static\n+    \/\/ initializer as such.  parallelCapable is not an inheritable attribute.\n+    MyNonParallelLoader(boolean load_in_parallel) {\n+       super(load_in_parallel);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/MyNonParallelLoader.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test MyLoaderTest\n+ * @bug 8262046\n+ * @summary Call handle_parallel_super_load, loading parallel threads that throw CCE\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @compile -XDignore.symbol.file AsmClasses.java\n+ * @compile test-classes\/ClassInLoader.java test-classes\/A.java test-classes\/B.java\n+ * @run main\/othervm ParallelSuperTest\n+ * @run main\/othervm ParallelSuperTest -parallel\n+ * @run main\/othervm ParallelSuperTest -parallel -parallelCapable\n+ *\/\n+\n+public class ParallelSuperTest {\n+    public static void main(java.lang.String[] args) throws Exception {\n+        boolean parallel = false;\n+        boolean parallelCapable = false;\n+        boolean success = true;\n+        for (int i = 0; i < args.length; i++) {\n+            try {\n+                \/\/ Don't print debug info\n+                if (args[i].equals(\"-parallel\")) {\n+                    parallel = true;\n+                } else if (args[i].equals(\"-parallelCapable\")) {\n+                    parallelCapable = true;\n+                } else {\n+                    System.out.println(\"Unrecognized \" + args[i]);\n+                }\n+            } catch (NumberFormatException e) {\n+                System.err.println(\"Invalid parameter: \" + args[i - 1] + \" \" + args[i]);\n+            }\n+        }\n+        \/\/ The -parallel -parallelCapable case will deadlock on locks for A and B if\n+        \/\/ the jvm doesn't eagerly try to load A's superclass from the second thread.\n+        \/\/ ie. needs to call SystemDictionary::handle_parallel_super_load\n+        if (parallelCapable) {\n+            MyLoader ldr = new MyLoader(parallel);\n+            ldr.startLoading();\n+            success = ldr.report_success();\n+        } else {\n+            MyNonParallelLoader ldr = new MyNonParallelLoader(parallel);\n+            ldr.startLoading();\n+            success = ldr.report_success();\n+        }\n+        if (success) {\n+            System.out.println(\"PASSED\");\n+        } else {\n+            throw new RuntimeException(\"FAILED\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ParallelSuperTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/\/ class to print thread-annotated output\n+class ThreadPrint {\n+    public static void println(String s) {\n+        System.out.println(Thread.currentThread().getName() + \": \" + s);\n+        System.out.flush();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/ThreadPrint.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class A extends B {\n+    public A() {\n+       System.out.println(\"A extends B\");\n+       throw new RuntimeException(\"Should throw CCE here\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/test-classes\/A.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class B { public B() { System.out.println(\"B\"); } }\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/test-classes\/B.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Create a class to load inside the loader instance, that will load\n+\/\/ A through a constant pool reference.\n+\/\/ Class A extends B extends A\n+class CP1 {\n+  void foo() throws Exception {\n+      ThreadPrint.println(\"CP1.foo()\");\n+      try {\n+          Class<?> a = A.class;\n+          Object obj = a.getConstructor().newInstance();\n+          throw new RuntimeException(\"Should throw CCE here\");\n+      } catch (Throwable e) {\n+          ThreadPrint.println(\"Exception is caught: \" + e);\n+          if (!(e instanceof java.lang.ClassCircularityError)) {\n+              throw new RuntimeException(\"Unexpected exception\");\n+          }\n+      }\n+  }\n+}\n+\n+\/\/ This class has a constant pool reference to B which will also get CCE, but\n+\/\/ starting at B.\n+class CP2 {\n+  void foo() throws Exception {\n+      ThreadPrint.println(\"CP2.foo()\");\n+      try {\n+          Class<?> a = B.class;\n+          Object obj = a.getConstructor().newInstance();\n+          throw new RuntimeException(\"Should throw CCE here\");\n+      } catch (Throwable e) {\n+          ThreadPrint.println(\"Exception is caught: \" + e);\n+          if (!(e instanceof java.lang.ClassCircularityError)) {\n+              throw new RuntimeException(\"Unexpected exception\");\n+          }\n+      }\n+  }\n+}\n+\n+public class ClassInLoader {\n+  private static boolean first = true;\n+  public ClassInLoader() throws Exception {\n+    ThreadPrint.println(\"ClassInLoader\");\n+    if (first) {\n+        first = false;\n+        CP1 c1 = new CP1();\n+        c1.foo();\n+    } else {\n+        CP2 c2 = new CP2();\n+        c2.foo();\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ParallelLoad\/test-classes\/ClassInLoader.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8264337\n+ * @summary test default cds archive when turning on VerifySharedSpaces\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver VerifyWithDefaultArchive\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class VerifyWithDefaultArchive {\n+    public static void main(String... args) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\"-Xlog:cds\", \"-XX:+VerifySharedSpaces\", \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldNotContain(\"relocation bitmap CRC error\");\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/VerifyWithDefaultArchive.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary test -XX:+PrintSharedArchiveAndExit output for shared class.\n+ * @comment the code is mostly copied from HelloCustom\n+ * @requires vm.cds\n+ * @requires vm.cds.custom.loaders\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/HelloUnload.java test-classes\/CustomLoadee.java\n+ * @build sun.hotspot.WhiteBox jdk.test.lib.classloader.ClassUnloadCommon\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar HelloUnload\n+ *                 jdk.test.lib.classloader.ClassUnloadCommon\n+ *                 jdk.test.lib.classloader.ClassUnloadCommon$1\n+ *                 jdk.test.lib.classloader.ClassUnloadCommon$TestFailure\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello_custom.jar CustomLoadee\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run driver PrintSharedArchiveAndExit\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import sun.hotspot.WhiteBox;\n+\n+public class PrintSharedArchiveAndExit {\n+    public static void main(String[] args) throws Exception {\n+        run();\n+    }\n+    public static void run(String... extra_runtime_args) throws Exception {\n+        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n+        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n+\n+        String appJar = ClassFileInstaller.getJarPath(\"hello.jar\");\n+        String customJarPath = ClassFileInstaller.getJarPath(\"hello_custom.jar\");\n+\n+        \/\/ Dump the archive\n+        String classlist[] = new String[] {\n+            \"HelloUnload\",\n+            \"java\/lang\/Object id: 1\",\n+            \"CustomLoadee id: 2 super: 1 source: \" + customJarPath\n+        };\n+\n+        OutputAnalyzer output;\n+        TestCommon.testDump(appJar, classlist,\n+                            \/\/ command-line arguments ...\n+                            use_whitebox_jar);\n+\n+        output = TestCommon.exec(appJar,\n+                                 TestCommon.concat(extra_runtime_args,\n+                                     \/\/ command-line arguments ...\n+                                     use_whitebox_jar,\n+                                     \"-XX:+UnlockDiagnosticVMOptions\",\n+                                     \"-XX:+WhiteBoxAPI\",\n+                                     \"-XX:+PrintSharedArchiveAndExit\",\n+                                     \"HelloUnload\", customJarPath, \"true\", \"true\"));\n+        output.shouldMatch(\".* archive version \\\\d+\")\n+              .shouldContain(\"java.lang.Object boot_loader\")\n+              .shouldContain(\"HelloUnload app_loader\")\n+              .shouldContain(\"CustomLoadee unregistered_loader\")\n+              .shouldContain(\"Shared Builtin Dictionary\")\n+              .shouldContain(\"Shared Unregistered Dictionary\")\n+              .shouldMatch(\"Number of shared symbols: \\\\d+\")\n+              .shouldMatch(\"Number of shared strings: \\\\d+\")\n+              .shouldMatch(\"VM version: .*\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/PrintSharedArchiveAndExit.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Hello World test for dynamic archive with custom loader\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\n+ * @build HelloUnload CustomLoadee jdk.test.lib.classloader.ClassUnloadCommon\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello.jar HelloUnload\n+ *                 jdk.test.lib.classloader.ClassUnloadCommon\n+ *                 jdk.test.lib.classloader.ClassUnloadCommon$1\n+ *                 jdk.test.lib.classloader.ClassUnloadCommon$TestFailure\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar hello_custom.jar CustomLoadee\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar WhiteBox.jar sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\/WhiteBox.jar PrintSharedArchiveAndExit\n+ *\/\n+\n+import java.io.File;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class PrintSharedArchiveAndExit extends DynamicArchiveTestBase {\n+    private static final String ARCHIVE_NAME = CDSTestUtils.getOutputFileName(\"top.jsa\");\n+\n+    public static void main(String... args) throws Exception {\n+        runTest(PrintSharedArchiveAndExit::testPrtNExit);\n+    }\n+\n+    public static void testPrtNExit() throws Exception {\n+        String wbJar = ClassFileInstaller.getJarPath(\"WhiteBox.jar\");\n+        String use_whitebox_jar = \"-Xbootclasspath\/a:\" + wbJar;\n+        String appJar = ClassFileInstaller.getJarPath(\"hello.jar\");\n+        String customJarPath = ClassFileInstaller.getJarPath(\"hello_custom.jar\");\n+        String mainAppClass = \"HelloUnload\";\n+\n+        dump(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:cds\",\n+            \"-Xlog:cds+dynamic=debug\",\n+            \"-cp\", appJar,\n+            mainAppClass, customJarPath, \"false\", \"false\")\n+            .assertNormalExit(output -> {\n+                output.shouldContain(\"Written dynamic archive 0x\")\n+                      .shouldNotContain(\"klasses.*=.*CustomLoadee\")\n+                      .shouldHaveExitValue(0);\n+                });\n+\n+        run(ARCHIVE_NAME,\n+            use_whitebox_jar,\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+WhiteBoxAPI\",\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds=debug\",\n+            \"-Xlog:cds+dynamic=info\",\n+            \"-cp\", appJar,\n+            \"-XX:+PrintSharedArchiveAndExit\",\n+            mainAppClass, customJarPath, \"false\", \"true\")\n+            .assertNormalExit(output -> {\n+                output.shouldHaveExitValue(0)\n+                      .shouldMatch(\"Base archive name: .*.jsa\")  \/\/ given name ends with .jsa, maynot default name.\n+                      .shouldMatch(\"Dynamic archive name: .*\" + ARCHIVE_NAME)\n+                      .shouldMatch(\"Base archive version \\\\d+\")\n+                      .shouldContain(\"java.lang.Object boot_loader\")\n+                      .shouldContain(\"HelloUnload app_loader\")\n+                      .shouldContain(\"CustomLoadee unregistered_loader\")\n+                      .shouldContain(\"Shared Builtin Dictionary\")\n+                      .shouldContain(\"Shared Unregistered Dictionary\")\n+                      .shouldMatch(\"Number of shared symbols: \\\\d+\")\n+                      .shouldMatch(\"Number of shared strings: \\\\d+\")\n+                      .shouldMatch(\"VM version: .*\");\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/PrintSharedArchiveAndExit.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8264413\n+ * @summary test dynamic cds archive when turning on VerifySharedSpaces\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile ..\/test-classes\/Hello.java\n+ * @compile ..\/test-classes\/HelloMore.java\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. VerifyWithDynamicArchive\n+ *\/\n+\n+public class VerifyWithDynamicArchive extends DynamicArchiveTestBase {\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(VerifyWithDynamicArchive::testDefaultBase);\n+    }\n+\n+    static void testDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(topArchiveName);\n+    }\n+\n+    private static void doTest(String topArchiveName) throws Exception {\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+\n+        dump(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\", appJar, \"Hello\")\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+\n+        run(topArchiveName,\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-XX:+VerifySharedSpaces\",\n+            \"-cp\", appJar,\n+            \"Hello\")\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Hello source: shared objects file\")\n+                          .shouldNotContain(\"Header checksum verification failed\")\n+                          .shouldHaveExitValue(0);\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/VerifyWithDynamicArchive.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+import jdk.test.lib.Platform;\n@@ -50,0 +51,1 @@\n+        setStringFlag(executor);\n@@ -150,0 +152,18 @@\n+    private void setStringFlag(CommandExecutor executor) {\n+        \/\/ Today we don't have any manageable flags of the string type in the product build,\n+        \/\/ so we can only test DummyManageableStringFlag in the debug build.\n+        if (!Platform.isDebugBuild()) {\n+            return;\n+        }\n+\n+        String flag = \"DummyManageableStringFlag\";\n+        String toValue = \"DummyManageableStringFlag_Is_Set_To_Hello\";\n+\n+        System.out.println(\"### Setting a string flag '\" + flag + \"'\");\n+        OutputAnalyzer out = executor.execute(\"VM.set_flag \" + flag + \" \" + toValue);\n+        out.stderrShouldBeEmpty();\n+\n+        out = getAllFlags(executor);\n+        out.stdoutShouldContain(toValue);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/SetVMFlagTest.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -48,12 +48,1 @@\n-\n-        if (SATestUtils.needsPrivileges()) {\n-            \/\/ This tests has issues if you try adding privileges on OSX. The debugd process cannot\n-            \/\/ be killed if you do this (because it is a root process and the test is not), so the destroy()\n-            \/\/ call fails to do anything, and then waitFor() will time out. If you try to manually kill it with\n-            \/\/ a \"sudo kill\" command, that seems to work, but then leaves the LingeredApp it was\n-            \/\/ attached to in a stuck state for some unknown reason, causing the stopApp() call\n-            \/\/ to timeout. For that reason we don't run this test when privileges are needed. Note\n-            \/\/ it does appear to run fine as root, so we still allow it to run on OSX when privileges\n-            \/\/ are not required.\n-            throw new SkippedException(\"Cannot run this test on OSX if adding privileges is required.\");\n-        }\n+        SATestUtils.validateSADebugDPrivileges();\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/ClhsdbAttachToDebugServer.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.SA.SATestUtils;\n+\n+import jtreg.SkippedException;\n+\n+\/**\n+ * @test\n+ * @bug 8263670\n+ * @requires vm.hasSA\n+ * @requires (os.family != \"windows\") & (os.family != \"mac\")\n+ * @library \/test\/lib\n+ * @run main\/othervm PmapOnDebugdTest\n+ *\/\n+\n+public class PmapOnDebugdTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        SATestUtils.skipIfCannotAttach(); \/\/ throws SkippedException if attach not expected to work.\n+        SATestUtils.validateSADebugDPrivileges();\n+\n+        LingeredApp theApp = null;\n+        DebugdUtils debugd = null;\n+        try {\n+            theApp = LingeredApp.startApp();\n+            System.out.println(\"Started LingeredApp with pid \" + theApp.getPid());\n+            debugd = new DebugdUtils(null);\n+            debugd.attach(theApp.getPid());\n+\n+            JDKToolLauncher jhsdbLauncher = JDKToolLauncher.createUsingTestJDK(\"jhsdb\");\n+            jhsdbLauncher.addToolArg(\"jmap\");\n+            jhsdbLauncher.addToolArg(\"--connect\");\n+            jhsdbLauncher.addToolArg(\"localhost\");\n+\n+            Process jhsdb = (SATestUtils.createProcessBuilder(jhsdbLauncher)).start();\n+            OutputAnalyzer out = new OutputAnalyzer(jhsdb);\n+\n+            jhsdb.waitFor();\n+            System.out.println(out.getStdout());\n+            System.err.println(out.getStderr());\n+\n+            out.stderrShouldBeEmptyIgnoreDeprecatedWarnings();\n+            out.shouldMatch(\"^0x[0-9a-f]+.+libjvm\\\\.so$\"); \/\/ Find libjvm from output\n+            out.shouldHaveExitValue(0);\n+\n+            \/\/ This will detect most SA failures, including during the attach.\n+            out.shouldNotMatch(\"^sun.jvm.hotspot.debugger.DebuggerException:.*$\");\n+        } catch (SkippedException se) {\n+            throw se;\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"Test ERROR \" + ex, ex);\n+        } finally {\n+            if (debugd != null) {\n+                debugd.detach();\n+            }\n+            LingeredApp.stopApp(theApp);\n+        }\n+        System.out.println(\"Test PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/PmapOnDebugdTest.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,12 +59,1 @@\n-\n-        if (SATestUtils.needsPrivileges()) {\n-            \/\/ This tests has issues if you try adding privileges on OSX. The debugd process cannot\n-            \/\/ be killed if you do this (because it is a root process and the test is not), so the destroy()\n-            \/\/ call fails to do anything, and then waitFor() will time out. If you try to manually kill it with\n-            \/\/ a \"sudo kill\" command, that seems to work, but then leaves the LingeredApp it was\n-            \/\/ attached to in a stuck state for some unknown reason, causing the stopApp() call\n-            \/\/ to timeout. For that reason we don't run this test when privileges are needed. Note\n-            \/\/ it does appear to run fine as root, so we still allow it to run on OSX when privileges\n-            \/\/ are not required.\n-            throw new SkippedException(\"Cannot run this test on OSX if adding privileges is required.\");\n-        }\n+        SATestUtils.validateSADebugDPrivileges();\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/sadebugd\/SADebugDTest.java","additions":2,"deletions":13,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -840,2 +840,0 @@\n-tools\/jpackage\/share\/jdk\/jpackage\/tests\/ModulePathTest3.java#id0    8248418 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+ * @library \/test\/lib\n@@ -40,0 +41,1 @@\n+import jdk.test.lib.Platform;\n@@ -97,0 +99,17 @@\n+\n+        \/\/ Today we don't have any manageable flags of the string type in the product build,\n+        \/\/ so we can only test DummyManageableStringFlag in the debug build.\n+        if (Platform.isDebugBuild()) {\n+            String optionName = \"DummyManageableStringFlag\";\n+            String toValue = \"DummyManageableStringFlag_Is_Set_To_Hello\";\n+\n+            mbean.setVMOption(optionName, toValue);\n+\n+            VMOption stringOption = findOption(optionName);\n+            Object newValue = stringOption.getValue();\n+            if (!toValue.equals(newValue)) {\n+                throw new RuntimeException(\"Unmatched value: \" +\n+                                           newValue + \" expected: \" + toValue);\n+            }\n+        }\n+\n@@ -126,0 +145,4 @@\n+        return findOption(HEAP_DUMP_ON_OOM);\n+    }\n+\n+    private static VMOption findOption(String optionName) {\n@@ -127,1 +150,1 @@\n-        VMOption gcDetails = null;\n+        VMOption found = null;\n@@ -129,2 +152,2 @@\n-            if (o.getName().equals(HEAP_DUMP_ON_OOM)) {\n-                 gcDetails = o;\n+            if (o.getName().equals(optionName)) {\n+                 found = o;\n@@ -134,2 +157,2 @@\n-        if (gcDetails == null) {\n-            throw new RuntimeException(\"VM option \" + HEAP_DUMP_ON_OOM +\n+        if (found == null) {\n+            throw new RuntimeException(\"VM option \" + optionName +\n@@ -138,1 +161,1 @@\n-        return gcDetails;\n+        return found;\n","filename":"test\/jdk\/com\/sun\/management\/HotSpotDiagnosticMXBean\/SetVMOption.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.event.*;\n+import javax.swing.*;\n+\n+public class MyMacCanvas extends Canvas {\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"mylib\");\n+        } catch (Throwable t) {\n+            System.out.println(\"Test failed!!\");\n+            t.printStackTrace();\n+            System.exit(1);\n+        }\n+    }\n+\n+    public void addNotify() {\n+        super.addNotify();\n+        addNativeCoreAnimationLayer();\n+    }\n+\n+    public native void addNativeCoreAnimationLayer();\n+\n+    static JAWTFrame f;\n+    public static void main(String[] args) {\n+        try {\n+            Robot robot = new Robot();\n+            EventQueue.invokeLater(new Runnable() {\n+                public void run() {\n+                    f = new JAWTFrame(\"JAWTExample\");\n+                    f.setBackground(Color.white);\n+                    f.setLayout(new BorderLayout(10, 20));\n+                    f.setLocation(50, 50);\n+                    ((JComponent) f.getContentPane()).setBorder(BorderFactory.createMatteBorder(10, 10, 10, 10, Color.cyan));\n+                    f.addNotify();\n+                    f.pack();\n+                    f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+                    f.setVisible(true);\n+                }\n+            });\n+            robot.delay(5000);\n+            Color col1 = new Color(0, 0, 0);\n+            Color col2 = robot.getPixelColor(f.getX()+50, f.getY()+50);\n+            if (col1.equals(col2)) {\n+                System.out.println(\"Test passed!\");\n+            } else {\n+                System.out.println(\"col1 \" + col1 + \" col2 \" + col2);\n+                throw new RuntimeException(\"Color of JAWT canvas is wrong or \" +\n+                        \"it was not rendered. \" + \"Check that other windows \" +\n+                        \"do not block the test frame.\");\n+            }\n+            System.exit(0);\n+        } catch (Throwable t) {\n+            System.out.println(\"Test failed!\");\n+            t.printStackTrace();\n+            System.exit(1);\n+        }\n+    }\n+\n+    private static class JAWTFrame extends JFrame {\n+        public JAWTFrame(final String title) {\n+            super(title);\n+        }\n+\n+        public void addNotify() {\n+            super.addNotify(); \/\/ ensures native component hierarchy is setup\n+\n+            final Component layerBackedCanvas = new MyMacCanvas();\n+            layerBackedCanvas.setPreferredSize(new Dimension(400, 200));\n+            add(layerBackedCanvas, BorderLayout.CENTER);\n+\n+            invalidate();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/JAWT\/MyMacCanvas.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,13 @@\n+#!\/bin\/sh\n+\n+set -e\n+\n+JAVA_HOME='\/export\/lanai\/build\/macosx-x64-debug\/jdk'\n+\n+$JAVA_HOME\/bin\/javac MyMacCanvas.java\n+\n+gcc -v myfile.m -I\"$JAVA_HOME\/include\" -c -o myfile.o\n+\n+gcc -v myfile.o -L$JAVA_HOME\/lib -ljawt -framework AppKit -framework OpenGL -framework Metal -framework Quartz -shared -o libmylib.jnilib\n+\n+$JAVA_HOME\/bin\/java -Djava.library.path=. -Dsun.java2d.metal=True MyMacCanvas\n","filename":"test\/jdk\/java\/awt\/JAWT\/jawt-mac-buildrun.sh","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import \"JAVAVM\/jawt_md.h\"\n+#import <Quartz\/Quartz.h>\n+\n+\/*\n+ * Pass the block to a selector of a class that extends NSObject\n+ * There is no need to copy the block since this class always waits.\n+ *\/\n+@interface BlockRunner : NSObject { }\n+\n++ (void)invokeBlock:(void (^)())block;\n+@end\n+\n+@implementation BlockRunner\n+\n++ (void)invokeBlock:(void (^)())block{\n+  block();\n+}\n+\n++ (void)performBlock:(void (^)())block {\n+  [self performSelectorOnMainThread:@selector(invokeBlock:) withObject:block waitUntilDone:YES];\n+}\n+\n+@end\n+\n+\n+\/*\n+ * Class:        MyMacCanvas\n+ * Method:       paint\n+ * SIgnature:    (Ljava\/awt\/Graphics;)V\n+ *\/\n+JNIEXPORT void JNICALL Java_MyMacCanvas_addNativeCoreAnimationLayer\n+(JNIEnv* env, jobject canvas, jobject graphics)\n+{\n+    printf(\"paint called\\n\");\n+\n+    JAWT awt;\n+    awt.version = JAWT_VERSION_1_4 | JAWT_MACOSX_USE_CALAYER;\n+    if (JAWT_GetAWT(env, &awt) == JNI_FALSE) {\n+        printf(\"AWT Not found\\n\");\n+        return;\n+    }\n+\n+    printf(\"JAWT found\\n\");\n+\n+    \/* Get the drawing surface *\/\n+    JAWT_DrawingSurface* ds = awt.GetDrawingSurface(env, canvas);\n+    if (ds == NULL) {\n+        printf(\"NULL drawing surface\\n\");\n+        return;\n+    }\n+\n+    \/* Lock the drawing surface *\/\n+    jint lock = ds->Lock(ds);\n+    printf(\"Lock value %d\\n\", (int)lock);\n+    if((lock & JAWT_LOCK_ERROR) != 0) {\n+        printf(\"Error locking surface\");\n+        return;\n+    }\n+\n+    \/* Get the drawing surface info *\/\n+    JAWT_DrawingSurfaceInfo *dsi = ds->GetDrawingSurfaceInfo(ds);\n+    if (dsi == NULL) {\n+        printf(\"Error getting surface info\\n\");\n+        ds->Unlock(ds);\n+        return;\n+    }\n+\n+    \/\/ create and attach the layer on the AppKit thread\n+    void (^block)() = ^(){\n+        \/\/ attach the \"root layer\" to the AWT Canvas surface layers\n+        CALayer *layer = [[CALayer new] autorelease];\n+        id <JAWT_SurfaceLayers> surfaceLayers = (id <JAWT_SurfaceLayers>)dsi->platformInfo;\n+        CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB ();\n+        CGFloat rgba[4] = {0.0, 0.0, 0.0, 1.0};\n+        CGColorRef color = CGColorCreate (colorspace, rgba);\n+        layer.backgroundColor = color;\n+        surfaceLayers.layer = layer;\n+    };\n+\n+    if ([NSThread isMainThread]) {\n+        block();\n+    } else {\n+        [BlockRunner performBlock:block];\n+    }\n+\n+    \/* Free the drawing surface info *\/\n+    ds->FreeDrawingSurfaceInfo(dsi);\n+\n+    \/* Unlock the drawing surface *\/\n+    ds->Unlock(ds);\n+\n+    \/* Free the drawing surface *\/\n+    awt.FreeDrawingSurface(ds);\n+}\n","filename":"test\/jdk\/java\/awt\/JAWT\/myfile.m","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8262470\n+ * @requires (os.family == \"windows\")\n+ * @summary Check thay shapes are properly painted with the precision scale factor\n+ * @run main\/othervm\/manual PathPrecisionScaleFactorShapeTest\n+ *\/\n+\n+import javax.print.PrintServiceLookup;\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.geom.QuadCurve2D;\n+import java.awt.geom.CubicCurve2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+public class PathPrecisionScaleFactorShapeTest {\n+\n+    private static final String DESCRIPTION =\n+            \" 1. Setup 'Microsoft Print to PDF' printer on Windows.\\n\" +\n+                    \" 2. Press Print button to print shapes with labels to PDF.\\n\" +\n+                    \" 3. Choose 'Microsoft Print to PDF' on the print dialog and press OK\\n\" +\n+                    \" 3. Open the PDF file and check that following shapes with labels are printed:\\n\" +\n+                    \"    Line\\n\" +\n+                    \"    Line2D\\n\" +\n+                    \"    QuadCurve2D\\n\" +\n+                    \"    CubicCurve2D\\n\" +\n+                    \" 4. If so, press PASS button, otherwise press FAIL button.\\n\";\n+\n+    private static final CountDownLatch testEndedSignal = new CountDownLatch(1);\n+    private static final int testTimeout = 300000;\n+    private static volatile String testFailureMsg;\n+    private static volatile boolean testPassed;\n+    private static volatile boolean testFinished;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        SwingUtilities.invokeLater(() -> createAndShowTestDialog());\n+\n+        try {\n+            if (!testEndedSignal.await(testTimeout, TimeUnit.MILLISECONDS)) {\n+                throw new RuntimeException(String.format(\n+                        \"Test timeout '%d ms' elapsed.\", testTimeout));\n+            }\n+            if (!testPassed) {\n+                String failureMsg = testFailureMsg;\n+                if ((failureMsg != null) && (!failureMsg.trim().isEmpty())) {\n+                    throw new RuntimeException(failureMsg);\n+                } else {\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        } finally {\n+            testFinished = true;\n+        }\n+    }\n+\n+    private static void pass() {\n+        testPassed = true;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static void fail(String failureMsg) {\n+        testFailureMsg = failureMsg;\n+        testPassed = false;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static String convertMillisToTimeStr(int millis) {\n+        if (millis < 0) {\n+            return \"00:00:00\";\n+        }\n+        int hours = millis \/ 3600000;\n+        int minutes = (millis - hours * 3600000) \/ 60000;\n+        int seconds = (millis - hours * 3600000 - minutes * 60000) \/ 1000;\n+        return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n+    }\n+\n+    private static void createAndShowTestDialog() {\n+\n+        final JDialog dialog = new JDialog();\n+        dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+        dialog.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowClosing(WindowEvent e) {\n+                dialog.dispose();\n+                fail(\"Main dialog was closed.\");\n+            }\n+        });\n+\n+        final JLabel testTimeoutLabel = new JLabel(String.format(\n+                \"Test timeout: %s\", convertMillisToTimeStr(testTimeout)));\n+        final long startTime = System.currentTimeMillis();\n+        final Timer timer = new Timer(0, null);\n+        timer.setDelay(1000);\n+        timer.addActionListener((e) -> {\n+            int leftTime = testTimeout - (int) (System.currentTimeMillis() - startTime);\n+            if ((leftTime < 0) || testFinished) {\n+                timer.stop();\n+                dialog.dispose();\n+            }\n+            testTimeoutLabel.setText(String.format(\n+                    \"Test timeout: %s\", convertMillisToTimeStr(leftTime)));\n+        });\n+        timer.start();\n+\n+        JTextArea textArea = new JTextArea(DESCRIPTION);\n+        textArea.setEditable(false);\n+\n+        final JButton testButton = new JButton(\"Print\");\n+        final JButton passButton = new JButton(\"PASS\");\n+        final JButton failButton = new JButton(\"FAIL\");\n+        testButton.addActionListener((e) -> {\n+            testButton.setEnabled(false);\n+            new Thread(() -> {\n+                try {\n+                    doTest();\n+\n+                    SwingUtilities.invokeLater(() -> {\n+                        passButton.setEnabled(true);\n+                        failButton.setEnabled(true);\n+                    });\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    dialog.dispose();\n+                    fail(\"Exception occurred in a thread executing the test.\");\n+                }\n+            }).start();\n+        });\n+        passButton.setEnabled(false);\n+        passButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            pass();\n+        });\n+        failButton.setEnabled(false);\n+        failButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            fail(\"TitledBorder label is cut off\");\n+        });\n+\n+        JPanel mainPanel = new JPanel(new BorderLayout());\n+        JPanel labelPanel = new JPanel(new FlowLayout());\n+        labelPanel.add(testTimeoutLabel);\n+        mainPanel.add(labelPanel, BorderLayout.NORTH);\n+        mainPanel.add(textArea, BorderLayout.CENTER);\n+        JPanel buttonPanel = new JPanel(new FlowLayout());\n+        buttonPanel.add(testButton);\n+        buttonPanel.add(passButton);\n+        buttonPanel.add(failButton);\n+        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n+        dialog.add(mainPanel);\n+\n+        dialog.pack();\n+        dialog.setVisible(true);\n+    }\n+\n+    private static void doTest() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                new PathPrecisionScaleFactorPrintable();\n+            } catch (PrinterException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    private static class PathPrecisionScaleFactorPrintable implements Printable {\n+\n+        PathPrecisionScaleFactorPrintable() throws PrinterException {\n+            PrinterJob job = PrinterJob.getPrinterJob();\n+            job.setPrintService(PrintServiceLookup.lookupDefaultPrintService());\n+            job.setPrintable(this);\n+\n+            if (job.printDialog()) {\n+                job.print();\n+            } else {\n+                throw new RuntimeException(\"Printing was canceled!\");\n+            }\n+        }\n+\n+        void paint(Graphics2D g) {\n+\n+            Rectangle clip = g.getClipBounds();\n+\n+            int x =  (int) clip.getX() + 10;\n+            int y = (int) clip.getY() + 20;\n+            int dy = ((int) clip.getHeight() - y) \/ 8;\n+\n+            int l = 80;\n+            int sx = x + l + 10;\n+\n+            g.drawLine(x, y, x + l, y);\n+            drawGlyphVector(g, sx, y, \"Line\");\n+\n+            y+= dy;\n+            g.draw(new Line2D.Float(x, y, x + l, y));\n+            drawGlyphVector(g, sx, y, \"Line2D\");\n+\n+            y+= dy;\n+            g.draw(new QuadCurve2D.Float(x, y, x + l \/ 2, y + l \/ 2, x + l, y));\n+            drawGlyphVector(g, sx, y, \"QuadCurve2D\");\n+\n+            y+= dy;\n+            g.draw(new CubicCurve2D.Float(x, y, x + l \/ 3, y + l \/ 3, x + 2 * l \/ 3, y - l \/ 3, x + l, y));\n+            drawGlyphVector(g, sx, y, \"CubicCurve2D\");\n+        }\n+\n+        private static void drawGlyphVector(Graphics2D g, int x, int y, String text) {\n+\n+            Font font = new Font(\"Times New Roman\", Font.PLAIN, 8);\n+            g.setFont(font);\n+            FontRenderContext frc = new FontRenderContext(new AffineTransform(), false, true);\n+\n+            GlyphVector gv = font.createGlyphVector(frc, text);\n+            g.fill(gv.getOutline(x, y));\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int index) {\n+            if (index == 0) {\n+                paint((Graphics2D) graphics);\n+                return PAGE_EXISTS;\n+            } else {\n+                return NO_SUCH_PAGE;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PathPrecisionScaleFactor\/PathPrecisionScaleFactorShapeTest.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8262470\n+ * @requires (os.family == \"windows\")\n+ * @summary Check that a GlyphVector outline is printed with good quility on low dpi printers\n+ * @run main\/othervm\/manual PathPrecisionScaleFactorTextTest\n+ *\/\n+\n+import javax.print.PrintServiceLookup;\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+public class PathPrecisionScaleFactorTextTest {\n+\n+    private static final String DESCRIPTION =\n+            \" 1. Setup 'Microsoft Print to PDF' printer on Windows.\\n\" +\n+                    \" 2. Press Print button to print the text to PDF.\\n\" +\n+                    \" 3. Choose 'Microsoft Print to PDF' on the print dialog and press OK\\n\" +\n+                    \"    Two strings should be printed.\\n\" +\n+                    \"    The first line is printed using drawString() method\\n\" +\n+                    \"    and the second line is printed using filling glyph vector outline.\\n\" +\n+                    \" 3. Open the PDF file, zoom in the text and check that chars on the second line\\n\" +\n+                    \"    (especially 'a' and 's') are not distorted and have the similar quality\\n\" +\n+                    \"     as on the first line.\\n\" +\n+                    \" 4. If so, press PASS button, otherwise press FAIL button.\\n\";\n+\n+    private static final CountDownLatch testEndedSignal = new CountDownLatch(1);\n+    private static final int testTimeout = 300000;\n+    private static volatile String testFailureMsg;\n+    private static volatile boolean testPassed;\n+    private static volatile boolean testFinished;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        SwingUtilities.invokeLater(() -> createAndShowTestDialog());\n+\n+        try {\n+            if (!testEndedSignal.await(testTimeout, TimeUnit.MILLISECONDS)) {\n+                throw new RuntimeException(String.format(\n+                        \"Test timeout '%d ms' elapsed.\", testTimeout));\n+            }\n+            if (!testPassed) {\n+                String failureMsg = testFailureMsg;\n+                if ((failureMsg != null) && (!failureMsg.trim().isEmpty())) {\n+                    throw new RuntimeException(failureMsg);\n+                } else {\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        } finally {\n+            testFinished = true;\n+        }\n+    }\n+\n+    private static void pass() {\n+        testPassed = true;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static void fail(String failureMsg) {\n+        testFailureMsg = failureMsg;\n+        testPassed = false;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static String convertMillisToTimeStr(int millis) {\n+        if (millis < 0) {\n+            return \"00:00:00\";\n+        }\n+        int hours = millis \/ 3600000;\n+        int minutes = (millis - hours * 3600000) \/ 60000;\n+        int seconds = (millis - hours * 3600000 - minutes * 60000) \/ 1000;\n+        return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n+    }\n+\n+    private static void createAndShowTestDialog() {\n+\n+        final JDialog dialog = new JDialog();\n+        dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+        dialog.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowClosing(WindowEvent e) {\n+                dialog.dispose();\n+                fail(\"Main dialog was closed.\");\n+            }\n+        });\n+\n+        final JLabel testTimeoutLabel = new JLabel(String.format(\n+                \"Test timeout: %s\", convertMillisToTimeStr(testTimeout)));\n+        final long startTime = System.currentTimeMillis();\n+        final Timer timer = new Timer(0, null);\n+        timer.setDelay(1000);\n+        timer.addActionListener((e) -> {\n+            int leftTime = testTimeout - (int) (System.currentTimeMillis() - startTime);\n+            if ((leftTime < 0) || testFinished) {\n+                timer.stop();\n+                dialog.dispose();\n+            }\n+            testTimeoutLabel.setText(String.format(\n+                    \"Test timeout: %s\", convertMillisToTimeStr(leftTime)));\n+        });\n+        timer.start();\n+\n+        JTextArea textArea = new JTextArea(DESCRIPTION);\n+        textArea.setEditable(false);\n+\n+        final JButton testButton = new JButton(\"Print\");\n+        final JButton passButton = new JButton(\"PASS\");\n+        final JButton failButton = new JButton(\"FAIL\");\n+        testButton.addActionListener((e) -> {\n+            testButton.setEnabled(false);\n+            new Thread(() -> {\n+                try {\n+                    doTest();\n+\n+                    SwingUtilities.invokeLater(() -> {\n+                        passButton.setEnabled(true);\n+                        failButton.setEnabled(true);\n+                    });\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    dialog.dispose();\n+                    fail(\"Exception occurred in a thread executing the test.\");\n+                }\n+            }).start();\n+        });\n+        passButton.setEnabled(false);\n+        passButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            pass();\n+        });\n+        failButton.setEnabled(false);\n+        failButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            fail(\"TitledBorder label is cut off\");\n+        });\n+\n+        JPanel mainPanel = new JPanel(new BorderLayout());\n+        JPanel labelPanel = new JPanel(new FlowLayout());\n+        labelPanel.add(testTimeoutLabel);\n+        mainPanel.add(labelPanel, BorderLayout.NORTH);\n+        mainPanel.add(textArea, BorderLayout.CENTER);\n+        JPanel buttonPanel = new JPanel(new FlowLayout());\n+        buttonPanel.add(testButton);\n+        buttonPanel.add(passButton);\n+        buttonPanel.add(failButton);\n+        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n+        dialog.add(mainPanel);\n+\n+        dialog.pack();\n+        dialog.setVisible(true);\n+    }\n+\n+    private static void doTest() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                new PathPrecisionScaleFactorPrintable();\n+            } catch (PrinterException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    private static class PathPrecisionScaleFactorPrintable implements Printable {\n+\n+        PathPrecisionScaleFactorPrintable() throws PrinterException {\n+            PrinterJob job = PrinterJob.getPrinterJob();\n+            job.setPrintService(PrintServiceLookup.lookupDefaultPrintService());\n+            job.setPrintable(this);\n+\n+            if (job.printDialog()) {\n+                job.print();\n+            } else {\n+                throw new RuntimeException(\"Printing was canceled!\");\n+            }\n+        }\n+\n+        void paint(Graphics2D g) {\n+\n+            String text = \"abcdefghijklmnopqrstuvwxyz\";\n+            Font font = new Font(\"Times New Roman\", Font.PLAIN, 8);\n+            drawText(g, font, text);\n+        }\n+\n+        private static void drawText(Graphics2D g, Font font, String text) {\n+\n+            g.setFont(font);\n+            FontRenderContext frc = new FontRenderContext(new AffineTransform(), false, true);\n+\n+            Rectangle clip = g.getClipBounds();\n+            int cx = (int) clip.getCenterX();\n+            int cy = (int) clip.getCenterY();\n+\n+            FontMetrics metrics = g.getFontMetrics();\n+            int w = metrics.stringWidth(text);\n+            int h = metrics.getHeight();\n+\n+            int x = cx - w \/ 2;\n+            int y = cy - h \/ 2;\n+\n+            g.drawString(text + \" [draw string]\", x, y);\n+            GlyphVector gv = font.createGlyphVector(frc, text + \" [glyph vector]\");\n+            g.fill(gv.getOutline(x, y + h));\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int index) {\n+            if (index == 0) {\n+                paint((Graphics2D) graphics);\n+                return PAGE_EXISTS;\n+            } else {\n+                return NO_SUCH_PAGE;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PathPrecisionScaleFactor\/PathPrecisionScaleFactorTextTest.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -29,1 +29,3 @@\n- * @run main\/othervm -Xmx4G LargeCopyWithMark\n+ * @run main\/othervm -Xmx4G -Xlog:gc,gc+heap,gc+ergo+heap -XX:+CrashOnOutOfMemoryError\n+                     -XX:+IgnoreUnrecognizedVMOptions -XX:+G1ExitOnExpansionFailure\n+                     LargeCopyWithMark\n","filename":"test\/jdk\/java\/io\/BufferedInputStream\/LargeCopyWithMark.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8071859\n+ * @bug 8071859 8169629\n@@ -28,0 +28,4 @@\n+ * @compile --release 8 EqualityTest.java\n+ * @run main EqualityTest\n+ * @compile EqualityTest.java\n+ * @run main EqualityTest\n@@ -43,0 +47,1 @@\n+        testEquality(annotation, AnnotationHost.class.getAnnotation(TestAnnotation.class), true);\n@@ -50,0 +55,3 @@\n+\n+    @TestAnnotation\n+    private static class AnnotationHost {}\n@@ -54,0 +62,2 @@\n+    \/\/ Trigger creation of synthetic method to initialize r.\n+    public static final Runnable r = () -> {};\n","filename":"test\/jdk\/java\/lang\/annotation\/EqualityTest.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.AsynchronousFileChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import static java.nio.file.StandardOpenOption.*;\n+import java.util.concurrent.ExecutionException;\n+\n+\/* @test\n+ * @bug 8263898\n+ * @summary Verify stream and channel behavior with NUL device\n+ * @requires os.family == \"windows\"\n+ * @run main NulDevice\n+*\/\n+public class NulDevice {\n+    public static void main(String[] args)\n+        throws ExecutionException, InterruptedException, IOException {\n+        Path path = Path.of(\"nul\");\n+\n+        try (OutputStream os = Files.newOutputStream(path)) {\n+            os.write(0x02);\n+            try (InputStream is = Files.newInputStream(path);) {\n+                if (is.available() != 0) {\n+                    throw new RuntimeException(\"No bytes should be available\");\n+                }\n+                int aByte = is.read();\n+                if (aByte != -1) {\n+                    throw new RuntimeException(\"Should only read -1 from NUL\");\n+                }\n+            }\n+        }\n+\n+        try (OutputStream os = Files.newOutputStream(path, WRITE)) {\n+            os.write(0x02);\n+        }\n+\n+        try (FileChannel ch = FileChannel.open(path, CREATE, TRUNCATE_EXISTING, WRITE)) {\n+            byte[] bytes = \"Whatever\".getBytes();\n+            ByteBuffer buf = ByteBuffer.allocate(2*bytes.length);\n+            buf.put(bytes);\n+            int nw = ch.write(buf);\n+            if (nw != bytes.length) {\n+                throw new RuntimeException(\"Should write \" + bytes.length +\n+                    \" to NUL\");\n+            }\n+        }\n+\n+        try (FileChannel ch = FileChannel.open(path, READ)) {\n+            if (ch.size() != 0) {\n+                throw new RuntimeException(\"Size should be zero\");\n+            }\n+            ByteBuffer buf = ByteBuffer.allocate(10);\n+            int nr = ch.read(buf);\n+            if (nr != -1) {\n+                throw new RuntimeException(\"Read returns \" + nr + \" not -1\");\n+            }\n+        }\n+\n+        try (AsynchronousFileChannel ch = AsynchronousFileChannel.open(path, READ, WRITE)) {\n+            if (ch.size() != 0) {\n+                throw new RuntimeException(\"Size should be zero\");\n+            }\n+            int nw = ch.write(ByteBuffer.wrap(new byte[] {(byte)0x02}), 0L).get();\n+            if (nw != 1) {\n+                throw new RuntimeException(\"Wrote \" + nw + \" bytes, not one\");\n+            }\n+            ByteBuffer buf = ByteBuffer.allocate(10);\n+            int nr = ch.read(buf, 0L).get();\n+            if (nr != -1) {\n+                throw new RuntimeException(\"Read returns \" + nr + \" not -1\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Files\/NulDevice.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8254717\n+ * @bug 8254717 8263404\n@@ -31,0 +31,1 @@\n+import java.math.BigInteger;\n@@ -34,0 +35,2 @@\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n@@ -37,0 +40,31 @@\n+\n+    \/\/ Test for 8263404: This method generates RSAPrivateKey (without Crt info) from a RSAPrivateCrtKey\n+    public static RSAPrivateKey privateCrtToPrivate(RSAPrivateCrtKey crtKey) {\n+        return new RSAPrivateKey() {\n+            @Override\n+            public BigInteger getPrivateExponent() {\n+                return crtKey.getPrivateExponent();\n+            }\n+\n+            @Override\n+            public String getAlgorithm() {\n+                return crtKey.getAlgorithm();\n+            }\n+\n+            @Override\n+            public String getFormat() {\n+                return crtKey.getFormat();\n+            }\n+\n+            @Override\n+            public byte[] getEncoded() {\n+                return crtKey.getEncoded();\n+            }\n+\n+            @Override\n+            public BigInteger getModulus() {\n+                return crtKey.getModulus();\n+            }\n+        };\n+    }\n+\n@@ -38,1 +72,1 @@\n-        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\", \"SunRsaSign\");\n@@ -44,0 +78,2 @@\n+        \/\/ === Case 1: private key is RSAPrivateCrtKey, keySpec is RSAPrivateKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n@@ -51,0 +87,28 @@\n+        \/\/ === Case 2: private key is RSAPrivateCrtKey, keySpec is RSAPrivateCrtKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateCrtKeySpec.class);\n+        if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+        }\n+\n+        \/\/ === Case 3: private key is RSAPrivateKey, keySpec is RSAPrivateKeySpec\n+        \/\/ === Expected: return RSAPrivateKeySpec not RSAPrivateCrtKeySpec\n+        RSAPrivateKey notCrtKey = privateCrtToPrivate((RSAPrivateCrtKey)pair.getPrivate());\n+        \/\/ InvalidKeySpecException should not be thrown\n+        KeySpec notCrtSpec = factory.getKeySpec(notCrtKey, RSAPrivateKeySpec.class);\n+        if (notCrtSpec instanceof RSAPrivateCrtKeySpec) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateKeySpec not RSAPrivateCrtKeySpec\");\n+        }\n+        if (!(notCrtSpec instanceof RSAPrivateKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateKeySpec\");\n+        }\n+\n+        \/\/ === Case 4: private key is RSAPrivateKey, keySpec is RSAPrivateCrtKeySpec\n+        \/\/ === Expected: throw InvalidKeySpecException\n+        try {\n+            factory.getKeySpec(notCrtKey, RSAPrivateCrtKeySpec.class);\n+            throw new Exception(\"InvalidKeySpecException is expected but not thrown\");\n+        } catch (InvalidKeySpecException e) {\n+            \/\/ continue;\n+        }\n+\n","filename":"test\/jdk\/java\/security\/KeyFactory\/KeyFactoryGetKeySpecForInvalidSpec.java","additions":66,"deletions":2,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-            int expected = hex.fromHexDigits(actual);\n+            int expected = HexFormat.fromHexDigits(actual);\n@@ -167,1 +167,0 @@\n-        HexFormat hex = HexFormat.of();\n@@ -169,1 +168,1 @@\n-            boolean actual = hex.isHexDigit(i);\n+            boolean actual = HexFormat.isHexDigit(i);\n@@ -177,1 +176,0 @@\n-        HexFormat hex = HexFormat.of();\n@@ -180,1 +178,1 @@\n-            int v = hex.fromHexDigit(chars.charAt(i));\n+            int v = HexFormat.fromHexDigit(chars.charAt(i));\n@@ -187,1 +185,0 @@\n-        HexFormat hex = HexFormat.of();\n@@ -191,1 +188,1 @@\n-                assertFalse(hex.isHexDigit(ch), \"isHexDigit incorrect for '\" + ch + \"'  = \" + i);\n+                assertFalse(HexFormat.isHexDigit(ch), \"isHexDigit incorrect for '\" + ch + \"'  = \" + i);\n@@ -193,1 +190,1 @@\n-                        () -> hex.fromHexDigit(ch));\n+                        () -> HexFormat.fromHexDigit(ch));\n@@ -211,1 +208,1 @@\n-            assertEquals(hex.fromHexDigits(sb), i, \"hex.format(sb, byte) wrong\");\n+            assertEquals(HexFormat.fromHexDigits(sb), i, \"hex.format(sb, byte) wrong\");\n@@ -247,1 +244,1 @@\n-                    () -> hex.fromHexDigits(chars.subSequence(ndx, ndx+2)));\n+                    () -> HexFormat.fromHexDigits(chars.subSequence(ndx, ndx+2)));\n@@ -292,4 +289,4 @@\n-        assertThrows(NPE, () -> HexFormat.of().fromHexDigits(null));\n-        assertThrows(NPE, () -> HexFormat.of().fromHexDigits(null, 0, 0));\n-        assertThrows(NPE, () -> HexFormat.of().fromHexDigitsToLong(null));\n-        assertThrows(NPE, () -> HexFormat.of().fromHexDigitsToLong(null, 0, 0));\n+        assertThrows(NPE, () -> HexFormat.fromHexDigits(null));\n+        assertThrows(NPE, () -> HexFormat.fromHexDigits(null, 0, 0));\n+        assertThrows(NPE, () -> HexFormat.fromHexDigitsToLong(null));\n+        assertThrows(NPE, () -> HexFormat.fromHexDigitsToLong(null, 0, 0));\n@@ -317,1 +314,1 @@\n-                () -> HexFormat.of().fromHexDigits(string, fromIndex, toIndex));\n+                () -> HexFormat.fromHexDigits(string, fromIndex, toIndex));\n@@ -319,1 +316,1 @@\n-                () -> HexFormat.of().fromHexDigitsToLong(string, fromIndex, toIndex));\n+                () -> HexFormat.fromHexDigitsToLong(string, fromIndex, toIndex));\n@@ -327,1 +324,1 @@\n-                () -> HexFormat.of().fromHexDigits(\"9876543210\"));\n+                () -> HexFormat.fromHexDigits(\"9876543210\"));\n@@ -329,1 +326,1 @@\n-                () -> HexFormat.of().fromHexDigits(\"9876543210\", 0, 9));\n+                () -> HexFormat.fromHexDigits(\"9876543210\", 0, 9));\n@@ -331,1 +328,1 @@\n-                () -> HexFormat.of().fromHexDigitsToLong(\"98765432109876543210\"));\n+                () -> HexFormat.fromHexDigitsToLong(\"98765432109876543210\"));\n@@ -333,1 +330,1 @@\n-                () -> HexFormat.of().fromHexDigitsToLong(\"98765432109876543210\", 0, 17));\n+                () -> HexFormat.fromHexDigitsToLong(\"98765432109876543210\", 0, 17));\n@@ -575,1 +572,1 @@\n-            long actual = hex.fromHexDigits(s, 0, digits);\n+            long actual = HexFormat.fromHexDigits(s, 0, digits);\n@@ -592,1 +589,1 @@\n-            long actual = hex.fromHexDigitsToLong(s, 0, digits);\n+            long actual = HexFormat.fromHexDigitsToLong(s, 0, digits);\n@@ -608,1 +605,1 @@\n-        long actual = hex.fromHexDigitsToLong(s);\n+        long actual = HexFormat.fromHexDigitsToLong(s);\n@@ -670,1 +667,1 @@\n-            byte byteVal = (byte)hex.fromHexDigits(byteStr);\n+            byte byteVal = (byte) HexFormat.fromHexDigits(byteStr);\n@@ -680,1 +677,1 @@\n-            int charVal = hex.fromHexDigits(charStr);\n+            int charVal = HexFormat.fromHexDigits(charStr);\n@@ -687,1 +684,1 @@\n-            int intVal = hex.fromHexDigits(intStr);\n+            int intVal = HexFormat.fromHexDigits(intStr);\n@@ -693,1 +690,1 @@\n-            long longVal = hex.fromHexDigitsToLong(longStr, 0, 16);\n+            long longVal = HexFormat.fromHexDigitsToLong(longStr, 0, 16);\n","filename":"test\/jdk\/java\/util\/HexFormat\/HexFormatTest.java","additions":24,"deletions":27,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -481,1 +481,1 @@\n-    private KeyManager createKeyManager(\n+    static KeyManager createKeyManager(\n@@ -537,1 +537,1 @@\n-    private TrustManager createTrustManager(\n+    static TrustManager createTrustManager(\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLContextTemplate.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-    private static boolean isOpen(SSLEngine engine) {\n+    static boolean isOpen(SSLEngine engine) {\n@@ -243,1 +243,1 @@\n-    private static void checkTransfer(ByteBuffer a, ByteBuffer b)\n+    static void checkTransfer(ByteBuffer a, ByteBuffer b)\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLEngineTemplate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,4 +2,1 @@\n- * To change this license header, choose License Headers in Project Properties.\n- * To change this template file, choose Tools | Templates\n- \/*\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/8072767\/bug8072767.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+        long timeout = 10_000;\n@@ -56,1 +57,1 @@\n-        while (!parsingDone && exception == null && System.currentTimeMillis() - s < 5_000) {\n+        while (!parsingDone && exception == null && System.currentTimeMillis() - s < timeout) {\n@@ -63,1 +64,1 @@\n-        if (took > 5_000) {\n+        if (took > timeout) {\n","filename":"test\/jdk\/javax\/swing\/text\/html\/parser\/Parser\/8078268\/bug8078268.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262503\n+ * @summary Dynalink supports property getters for record components\n+ *\/\n+\n+import static jdk.dynalink.StandardNamespace.PROPERTY;\n+import static jdk.dynalink.StandardOperation.GET;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Set;\n+import jdk.dynalink.CallSiteDescriptor;\n+import jdk.dynalink.DynamicLinker;\n+import jdk.dynalink.DynamicLinkerFactory;\n+import jdk.dynalink.NoSuchDynamicMethodException;\n+import jdk.dynalink.beans.BeansLinker;\n+import jdk.dynalink.support.SimpleRelinkableCallSite;\n+\n+public class BeanLinkerRecordsTest {\n+    public static record A(int num) {}\n+\n+    public interface I {\n+        int num();\n+    }\n+\n+    static record B(int num, int inaccessible) implements I {}\n+\n+    public static record C(int num) {\n+        public int num() { return 42; }\n+        public int getNum() { return 43; }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        DynamicLinker linker = new DynamicLinkerFactory().createLinker();\n+\n+        MethodHandle get_num = linker.link(makePropertyGetter(\"num\")).dynamicInvoker();\n+\n+        \/\/ Can access public record's component through its accessor\n+        assert(get_num.invoke(new A(100)).equals(100));\n+\n+        \/\/ Can access non-public record's component through accessor declared in public interface\n+        assert(get_num.invoke(new B(100, 200)).equals(100));\n+\n+        \/\/ Correctly selects overridden accessor; also ignores getXxx style getters\n+        assert(get_num.invoke(new C(100)).equals(42));\n+\n+        \/\/ Can not access non-public record's component without accessor declared in public interface\n+        MethodHandle get_inaccessible = linker.link(makePropertyGetter(\"inaccessible\")).dynamicInvoker();\n+        try {\n+            get_inaccessible.invoke(new B(100, 200));\n+            throw new AssertionError(); \/\/ should've failed\n+        } catch (NoSuchDynamicMethodException e) {\n+            \/\/ This is expected\n+        }\n+\n+        \/\/ Record components show up in the list of readable instance property names.\n+        List.of(A.class, B.class, C.class).forEach(clazz -> {\n+            var propNames = BeansLinker.getReadableInstancePropertyNames(clazz);\n+            assert propNames.equals(Set.of(\"num\", \"class\")): String.valueOf(propNames);\n+        });\n+    }\n+\n+    private static SimpleRelinkableCallSite makePropertyGetter(String name) {\n+        return new SimpleRelinkableCallSite(new CallSiteDescriptor(\n+            MethodHandles.publicLookup(),\n+            GET.withNamespace(PROPERTY).named(name),\n+            MethodType.methodType(Object.class, Object.class)));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/dynalink\/BeanLinkerRecordsTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -65,0 +65,1 @@\n+* @build org.jemmy2ext.JemmyExt\n","filename":"test\/jdk\/sanity\/client\/SwingSet\/src\/ColorChooserDemoTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+ * @build org.jemmy2ext.JemmyExt\n","filename":"test\/jdk\/sanity\/client\/SwingSet\/src\/GridBagLayoutDemoTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4405224\n+ * @bug 4405224 8012229\n@@ -79,1 +79,2 @@\n-            if (((dst.getRGB(0, i) >> 24) & 0xff) != 128) {\n+            int rgb = (dst.getRGB(0, i) >> 24) & 0xff;\n+            if (rgb != 128) {\n@@ -81,1 +82,1 @@\n-                    \"Incorrect destination alpha value.\");\n+                    \"Incorrect destination alpha value: \" + rgb);\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/ColCvtAlpha.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Graphics2D;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+\n+import static java.awt.image.BufferedImage.TYPE_3BYTE_BGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE;\n+import static java.awt.image.BufferedImage.TYPE_BYTE_BINARY;\n+import static java.awt.image.BufferedImage.TYPE_BYTE_GRAY;\n+import static java.awt.image.BufferedImage.TYPE_BYTE_INDEXED;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_BGR;\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_555_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_565_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_GRAY;\n+\n+\/*\n+ * @test\n+ * @bug 8012229\n+ * @summary one more test to check the alpha channel\n+ *\/\n+public final class ColCvtAlphaDifferentSrcDst {\n+\n+    private static final int WIDTH = 256;\n+    private static final int HEIGHT = 256;\n+\n+    public static void main(String[] args) throws Exception {\n+        differentToOpaqueDst();\n+        differentToTransparentDst(TYPE_INT_ARGB);\n+        differentToTransparentDst(TYPE_4BYTE_ABGR);\n+        differentToTransparentDst(TYPE_INT_ARGB_PRE);\n+    }\n+\n+    \/**\n+     * Various types of source images transform to the opaque destination, the\n+     * result should be the same.\n+     *\/\n+    private static void differentToOpaqueDst() {\n+        opaqueDst(TYPE_INT_ARGB, TYPE_INT_RGB);\n+        opaqueDst(TYPE_INT_ARGB, TYPE_INT_BGR);\n+        opaqueDst(TYPE_4BYTE_ABGR, TYPE_INT_BGR);\n+\n+        \/\/ It is unclear how to hangle pre colors in the opaque DST\n+        \/\/opaqueDst(TYPE_INT_ARGB_PRE, TYPE_4BYTE_ABGR_PRE);\n+        \/\/opaqueDst(TYPE_4BYTE_ABGR_PRE, TYPE_INT_BGR);\n+    }\n+\n+    \/**\n+     * Transparent types of source images transform to the transparent\n+     * destination, the alpha channel should be the same in src\/dst.\n+     *\/\n+    private static void differentToTransparentDst(int typeDst) {\n+        transparentDst(TYPE_INT_RGB, typeDst);\n+        transparentDst(TYPE_INT_ARGB, typeDst);\n+        transparentDst(TYPE_INT_ARGB_PRE, typeDst);\n+        transparentDst(TYPE_INT_BGR, typeDst);\n+        transparentDst(TYPE_3BYTE_BGR, typeDst);\n+        transparentDst(TYPE_4BYTE_ABGR, typeDst);\n+        transparentDst(TYPE_4BYTE_ABGR_PRE, typeDst);\n+        transparentDst(TYPE_USHORT_565_RGB, typeDst);\n+        transparentDst(TYPE_USHORT_555_RGB, typeDst);\n+        transparentDst(TYPE_BYTE_GRAY, typeDst);\n+        transparentDst(TYPE_USHORT_GRAY, typeDst);\n+        transparentDst(TYPE_BYTE_BINARY, typeDst);\n+        transparentDst(TYPE_BYTE_INDEXED, typeDst);\n+    }\n+\n+    private static void opaqueDst(int transparent, int opaque) {\n+        ColorSpace to = ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);\n+        ColorSpace from = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        ColorConvertOp op = new ColorConvertOp(from, to, null);\n+        \/\/ Source data\n+        BufferedImage timgSrc = createSrc(transparent);\n+        BufferedImage oimgSrc = createSrc(opaque);\n+\n+        \/\/ Destination data\n+        BufferedImage timgDst = createDst(TYPE_INT_RGB);\n+        BufferedImage oimgDst = createDst(TYPE_INT_RGB);\n+\n+        op.filter(timgSrc, timgDst);\n+        op.filter(oimgSrc, oimgDst);\n+\n+        validate(timgDst, oimgDst, false);\n+    }\n+\n+    private static void transparentDst(int typeSrc, int typeDst) {\n+        ColorSpace to = ColorSpace.getInstance(ColorSpace.CS_CIEXYZ);\n+        ColorSpace from = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        ColorConvertOp op = new ColorConvertOp(from, to, null);\n+\n+        BufferedImage src = createSrc(typeSrc);\n+        BufferedImage dst = createDst(typeDst);\n+\n+        op.filter(src, dst);\n+\n+        validate(src, dst, true);\n+    }\n+\n+    private static void validate(BufferedImage img1, BufferedImage img2,\n+                                 boolean alphaOnly) {\n+        for (int i = 0; i < WIDTH; i++) {\n+            for (int j = 0; j < HEIGHT; j++) {\n+                int rgb1 = img1.getRGB(i, j);\n+                int rgb2 = img2.getRGB(i, j);\n+                if (alphaOnly) {\n+                    rgb1 |= 0x00FFFFFF;\n+                    rgb2 |= 0x00FFFFFF;\n+                }\n+                if (rgb1 != rgb2) {\n+                    System.out.println(\"rgb1 = \" + Integer.toHexString(rgb1));\n+                    System.out.println(\"rgb2 = \" + Integer.toHexString(rgb2));\n+                    throw new RuntimeException();\n+                }\n+            }\n+        }\n+    }\n+\n+    private static BufferedImage createSrc(int type) {\n+        BufferedImage img = new BufferedImage(WIDTH, HEIGHT, type);\n+        fill(img);\n+        return img;\n+    }\n+\n+    private static BufferedImage createDst(int type) {\n+        BufferedImage img = new BufferedImage(WIDTH, HEIGHT, type);\n+\n+        Graphics2D g = img.createGraphics();\n+        g.setComposite(AlphaComposite.Clear);\n+        g.fillRect(0, 0, WIDTH, HEIGHT);\n+        g.dispose();\n+\n+        return img;\n+    }\n+\n+    private static void fill(BufferedImage image) {\n+        for (int i = 0; i < WIDTH; i++) {\n+            for (int j = 0; j < HEIGHT; j++) {\n+                image.setRGB(i, j,\n+                             (i << 24) | (i << 16) | (j << 8) | ((i + j) >> 1));\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/ColCvtAlphaDifferentSrcDst.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -193,1 +193,1 @@\n-                            + \"first arguemtn to enable security manager\");\n+                            + \"first argument to enable security manager\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\n+# Configuration to run unit tests with NSS\n+# Marks private and secret keys as sensitive\n+\n+name = NSS\n+\n+slot = 1\n+\n+#showInfo = true\n+\n+library = ${pkcs11test.nss.lib}\n+\n+nssArgs = \"configdir='${pkcs11test.nss.db}' certPrefix='' keyPrefix='' secmod='secmod.db' flags=readOnly\"\n+\n+disabledMechanisms = {\n+  CKM_DSA_SHA224\n+  CKM_DSA_SHA256\n+  CKM_DSA_SHA384\n+  CKM_DSA_SHA512\n+  CKM_DSA_SHA3_224\n+  CKM_DSA_SHA3_256\n+  CKM_DSA_SHA3_384\n+  CKM_DSA_SHA3_512\n+  CKM_ECDSA_SHA224\n+  CKM_ECDSA_SHA256\n+  CKM_ECDSA_SHA384\n+  CKM_ECDSA_SHA512\n+  CKM_ECDSA_SHA3_224\n+  CKM_ECDSA_SHA3_256\n+  CKM_ECDSA_SHA3_384\n+  CKM_ECDSA_SHA3_512\n+}\n+\n+attributes = compatibility\n+\n+# NSS needs CKA_NETSCAPE_DB for DSA and DH private keys\n+# just put an arbitrary value in there to make it happy\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DSA) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DH) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n+\n+# Everything above this line (with the exception of the comment at the top) is copy\/pasted from p11-nss.txt\n+\n+# Make all private keys sensitive\n+attributes(*,CKO_PRIVATE_KEY,*) = {\n+  CKA_SENSITIVE = true\n+}\n+\n+\n+# Make all secret keys sensitive\n+attributes(*,CKO_SECRET_KEY,*) = {\n+  CKA_SENSITIVE = true\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/nss\/p11-nss-sensitive.txt","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com, Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.Provider;\n+import java.security.PrivateKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.spec.*;\n+\n+\/**\n+ * @test\n+ * @bug 8263404\n+ * @summary RSAPrivateCrtKeySpec is prefered for CRT keys even when a RsaPrivateKeySpec is requested.\n+ * @summary Also checks to ensure that sensitive RSA keys are correctly not exposed\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestP11KeyFactoryGetRSAKeySpec\n+ * @run main\/othervm TestP11KeyFactoryGetRSAKeySpec sm rsakeys.ks.policy\n+ * @run main\/othervm -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt -DNO_DEIMOS=true -DNO_DEFAULT=true TestP11KeyFactoryGetRSAKeySpec\n+ * @modules jdk.crypto.cryptoki\n+ *\/\n+\n+public class TestP11KeyFactoryGetRSAKeySpec extends PKCS11Test {\n+    private static boolean testingSensitiveKeys = false;\n+    public static void main(String[] args) throws Exception {\n+        testingSensitiveKeys = \"p11-nss-sensitive.txt\".equals(System.getProperty(\"CUSTOM_P11_CONFIG_NAME\"));\n+        main(new TestP11KeyFactoryGetRSAKeySpec(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\", p);\n+        kg.initialize(2048);\n+        KeyPair pair = kg.generateKeyPair();\n+        PrivateKey privKey = pair.getPrivate();\n+\n+        KeyFactory factory = KeyFactory.getInstance(\"RSA\", p);\n+\n+        \/\/ If this is a sensitive key, then it shouldn't implement the RSAPrivateKey interface as that exposes sensitive fields\n+        boolean keyExposesSensitiveFields = privKey instanceof RSAPrivateKey;\n+        if (keyExposesSensitiveFields == testingSensitiveKeys) {\n+            throw new Exception(\"Key of type \" + privKey.getClass() + \" returned when testing sensitive keys is \" + testingSensitiveKeys);\n+        }\n+\n+        if (!testingSensitiveKeys) {\n+            \/\/ The remaining tests require that the PKCS #11 token actually generated a CRT key.\n+            \/\/ This is the normal and expected case, but we add an assertion here to detect a broken test due to bad assumptions.\n+            if (!(privKey instanceof RSAPrivateCrtKey)) {\n+                throw new Exception(\"Test assumption violated: PKCS #11 token did not generate a CRT key.\");\n+            }\n+        }\n+\n+        \/\/ === Case 1: private key is RSAPrivateCrtKey, keySpec is RSAPrivateKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        \/\/ Since RSAPrivateCrtKeySpec inherits from RSAPrivateKeySpec, we'd expect this next line to return an instance of RSAPrivateKeySpec\n+        \/\/ (because the private key has CRT parts).\n+        testKeySpec(factory, privKey, RSAPrivateKeySpec.class);\n+\n+        \/\/ === Case 2: private key is RSAPrivateCrtKey, keySpec is RSAPrivateCrtKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        testKeySpec(factory, privKey, RSAPrivateCrtKeySpec.class);\n+    }\n+\n+    private static void testKeySpec(KeyFactory factory, PrivateKey key, Class<? extends KeySpec> specClass) throws Exception {\n+        try {\n+            KeySpec spec = factory.getKeySpec(key, RSAPrivateKeySpec.class);\n+            if (testingSensitiveKeys) {\n+                throw new Exception(\"Able to retrieve spec from sensitive key\");\n+            }\n+            if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+                throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+            }\n+        } catch (final InvalidKeySpecException ex) {\n+            if (testingSensitiveKeys) {\n+                \/\/ Expected exception so swallow it\n+                System.err.println(\"This exception is expected when retrieving sensitive properties from a sensitive PKCS #11 key.\");\n+                ex.printStackTrace();\n+            } else {\n+                throw ex;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/rsa\/TestP11KeyFactoryGetRSAKeySpec.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,381 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8263188\n+ * @summary If TLS the server and client has no common signature algorithms,\n+ *     the connection should fail fast with \"No supported signature algorithm\".\n+ *     This test only covers TLS 1.2.\n+ *\n+ * @library \/test\/lib\n+ *          \/javax\/net\/ssl\/templates\n+ *\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ecdsa_secp384r1_sha384\n+ *     -Dtest.clientAuth=false\n+ *     -Dtest.expectFail=false\n+ *     SigAlgosExtTestWithTLS12\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.clientAuth=false\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS12\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.clientAuth=true\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS12\n+ *\/\n+\n+import javax.net.ssl.*;\n+import java.nio.ByteBuffer;\n+import java.util.*;\n+\n+public class SigAlgosExtTestWithTLS12 extends SSLEngineTemplate {\n+\n+    private static final boolean CLIENT_AUTH\n+            = Boolean.getBoolean(\"test.clientAuth\");\n+    private static final boolean EXPECT_FAIL\n+            = Boolean.getBoolean(\"test.expectFail\");\n+\n+    private static final String[] CA_CERTS = new String[] {\n+            \/\/ SHA256withECDSA, curve secp256r1\n+            \/\/ Validity\n+            \/\/     Not Before: May 22 07:18:16 2018 GMT\n+            \/\/     Not After : May 17 07:18:16 2038 GMT\n+            \/\/ Subject Key Identifier:\n+            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\\n\" +\n+            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\\n\" +\n+            \"MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB\/l11b5h0v\\n\" +\n+            \"LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\\n\" +\n+            \"A1UdDgQWBBRgz71z\/\/oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z\/\/oa\\n\" +\n+            \"MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH\/MAoGCCqGSM49BAMCA0kAMEYCIQCG\\n\" +\n+            \"6wluh1r2\/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\\n\" +\n+            \"2YEHlSQUAbwwqCDEVB5KxaqP\\n\" +\n+            \"-----END CERTIFICATE-----\",\n+\n+            \/\/ SHA384withECDSA, curve secp384r1\n+            \/\/ Validity\n+            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+            \/\/ Subject Key Identifier:\n+            \/\/     0a:93:a9:a0:bf:e7:d5:48:9d:4f:89:15:c6:51:98:80:05:51:4e:4e\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICCDCCAY6gAwIBAgIUCpOpoL\/n1UidT4kVxlGYgAVRTk4wCgYIKoZIzj0EAwMw\\n\" +\n+            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowOzEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+            \"dCBTZXJpdmNlMHYwEAYHKoZIzj0CAQYFK4EEACIDYgAENVQN1wXWFdgC6u\/dDdiC\\n\" +\n+            \"y+WtMTF66oL\/0BSm+1ZqsogamzCryawOcHgiuXgWzx5CQ3LuOC+tDFyXpGfHuCvb\\n\" +\n+            \"dkzxPrP5n9NrR8\/uRPe5l1KOUbchviU8z9cTP+LZxnZDo1MwUTAdBgNVHQ4EFgQU\\n\" +\n+            \"SktSFArR1p\/5mXV0kyo0RxIVa\/UwHwYDVR0jBBgwFoAUSktSFArR1p\/5mXV0kyo0\\n\" +\n+            \"RxIVa\/UwDwYDVR0TAQH\/BAUwAwEB\/zAKBggqhkjOPQQDAwNoADBlAjBZvoNmq3\/v\\n\" +\n+            \"RD2gBTyvxjS9h0rsMRLHDnvul\/KWngytwGPTOBo0Y8ixQXSjdKoc3rkCMQDkiNgx\\n\" +\n+            \"IDxuHedmrLQKIPnVcthTmwv7\/\/jHiqGoKofwChMo2a1P+DQdhszmeHD\/ARQ=\\n\" +\n+            \"-----END CERTIFICATE-----\"\n+    };\n+\n+    private static final String[] EE_CERTS = new String[] {\n+            \/\/ SHA256withECDSA, curve secp256r1\n+            \/\/ Validity\n+            \/\/     Not Before: May 22 07:18:16 2018 GMT\n+            \/\/     Not After : May 17 07:18:16 2038 GMT\n+            \/\/ Authority Key Identifier:\n+            \/\/     60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\\n\" +\n+            \"AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\\n\" +\n+            \"ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\\n\" +\n+            \"MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\\n\" +\n+            \"MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\\n\" +\n+            \"QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\\n\" +\n+            \"xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c\/\/6GjDSpOzT\\n\" +\n+            \"SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\\n\" +\n+            \"1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO\/\/wJIGQ==\\n\" +\n+            \"-----END CERTIFICATE-----\",\n+\n+            \/\/ SHA384withECDSA, curve secp384r1\n+            \/\/ Validity\n+            \/\/     Not Before: Jun 24 08:15:06 2019 GMT\n+            \/\/     Not After : Jun 19 08:15:06 2039 GMT\n+            \/\/ Authority Key Identifier:\n+            \/\/     40:2D:AA:EE:66:AA:33:27:AD:9B:5D:52:9B:60:67:6A:2B:AD:52:D2\n+            \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICEjCCAZegAwIBAgIUS3F0AqAXWRg07CnbknJzxofyBQMwCgYIKoZIzj0EAwMw\\n\" +\n+            \"OzELMAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0Ug\\n\" +\n+            \"VGVzdCBTZXJpdmNlMB4XDTE5MDYyNDA4MTUwNloXDTM5MDYxOTA4MTUwNlowVTEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDTALBgNVBAoMBEphdmExHTAbBgNVBAsMFFN1bkpTU0UgVGVz\\n\" +\n+            \"dCBTZXJpdmNlMRgwFgYDVQQDDA9SZWdyZXNzaW9uIFRlc3QwdjAQBgcqhkjOPQIB\\n\" +\n+            \"BgUrgQQAIgNiAARqElz8b6T07eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/w\\n\" +\n+            \"G8ASSevpgqgpi6EzpBZaaJxE3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEj\\n\" +\n+            \"iLjYmt3O0pwpklijQjBAMB0GA1UdDgQWBBRALaruZqozJ62bXVKbYGdqK61S0jAf\\n\" +\n+            \"BgNVHSMEGDAWgBRKS1IUCtHWn\/mZdXSTKjRHEhVr9TAKBggqhkjOPQQDAwNpADBm\\n\" +\n+            \"AjEArVDFKf48xijN6huVUJzKCOP0zlWB5Js+DItIkZmLQuhciPLhLIB\/rChf3Y4C\\n\" +\n+            \"xuP4AjEAmfLhQRI0O3pifpYzYSVh2G7\/jHNG4eO+2dvgAcU+Lh2IIj\/cpLaPFSvL\\n\" +\n+            \"J8FXY9Nj\\n\" +\n+            \"-----END CERTIFICATE-----\"\n+    };\n+\n+    private static final String[] EE_KEYS = new String[] {\n+            \"MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\\n\" +\n+            \"JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\\n\" +\n+            \"59bk2pyG8qd8l7L1WQnNHtAcu44RJ1\/GVHurxghaCKHeJYsZ8H7DEeI6\",\n+            \"MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDASuI9EtK29APXPipkc\\n\" +\n+            \"qDA+qwlewMjv\/OcjUJ77kP1Vz62oVF9iY9SRIyFIUju8wt+hZANiAARqElz8b6T0\\n\" +\n+            \"7eyKomIinhztV3\/3XBk9bKGtJ0W+JOltjuhMmP\/wG8ASSevpgqgpi6EzpBZaaJxE\\n\" +\n+            \"3zNfkNnxXOZmQi2Ypd1uK0zRdbEOKg0XOcTTZwEjiLjYmt3O0pwpklg=\"\n+    };\n+\n+    private static final String[] EE_ALGS = new String[] {\n+            \"EC\",\n+            \"EC\"\n+    };\n+\n+    private static final String[] EE_ALIASES = new String[] {\n+            \"EC-SHA256\",\n+            \"EC-SHA384\"\n+    };\n+\n+    private static final Map<Integer, String> SIG_SCHEMES_MAP = Map.of(\n+            0x0403, \"ecdsa_secp256r1_sha256\",\n+            0x0503, \"ecdsa_secp384r1_sha384\");\n+\n+    private static final int TLS_HS_CLI_HELLO = 1;\n+    private static final int TLS_HS_CERT_REQ = 13;\n+    private static final int HELLO_EXT_SIG_ALGS = 13;\n+\n+    public SigAlgosExtTestWithTLS12() throws Exception {\n+        super();\n+    }\n+\n+    \/*\n+     * Create an instance of KeyManager for client use.\n+     *\/\n+    public KeyManager createClientKeyManager() throws Exception {\n+        return SSLContextTemplate.createKeyManager(\n+                EE_CERTS,\n+                EE_KEYS,\n+                EE_ALGS,\n+                EE_ALIASES,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public TrustManager createClientTrustManager() throws Exception {\n+        return SSLContextTemplate.createTrustManager(\n+                CA_CERTS,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public KeyManager createServerKeyManager() throws Exception {\n+        return SSLContextTemplate.createKeyManager(\n+                EE_CERTS,\n+                EE_KEYS,\n+                EE_ALGS,\n+                EE_ALIASES,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    public TrustManager createServerTrustManager() throws Exception {\n+        return SSLContextTemplate.createTrustManager(\n+                CA_CERTS,\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    protected SSLEngine configureServerEngine(SSLEngine serverEngine) {\n+        serverEngine.setUseClientMode(false);\n+        serverEngine.setNeedClientAuth(CLIENT_AUTH);\n+        return serverEngine;\n+    }\n+\n+    @Override\n+    protected SSLEngine configureClientEngine(SSLEngine clientEngine) {\n+        clientEngine.setUseClientMode(true);\n+        clientEngine.setEnabledProtocols(new String[] { \"TLSv1.2\" });\n+        return clientEngine;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"javax.net.debug\", \"ssl:handshake\");\n+\n+        try {\n+            new SigAlgosExtTestWithTLS12().run();\n+            if (EXPECT_FAIL) {\n+                throw new RuntimeException(\n+                        \"Expected SSLHandshakeException wasn't thrown\");\n+            }\n+        } catch (SSLHandshakeException e) {\n+            if (EXPECT_FAIL && e.getMessage().equals(\n+                    \"No supported signature algorithm\")) {\n+                System.out.println(\"Expected SSLHandshakeException\");\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private void run() throws Exception {\n+        boolean dataDone = false;\n+        while (isOpen(clientEngine) || isOpen(serverEngine)) {\n+            clientEngine.wrap(clientOut, cTOs);\n+            cTOs.flip();\n+\n+            \/\/ Consume the ClientHello and get the server flight of handshake\n+            \/\/ messages.  We expect that it will be one TLS record containing\n+            \/\/ multiple handshake messages, one of which is a CertificateRequest\n+            \/\/ when the client authentication is required.\n+            serverEngine.unwrap(cTOs, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            \/\/ Wrap the server flight\n+            serverEngine.wrap(serverOut, sTOc);\n+            sTOc.flip();\n+\n+            if (CLIENT_AUTH && EXPECT_FAIL) {\n+                twistCertReqMsg(sTOc);\n+            }\n+\n+            clientEngine.unwrap(sTOc, clientIn);\n+            runDelegatedTasks(clientEngine);\n+\n+            serverEngine.unwrap(cTOs, serverIn);\n+            runDelegatedTasks(serverEngine);\n+\n+            cTOs.compact();\n+            sTOc.compact();\n+\n+            if (!dataDone && (clientOut.limit() == serverIn.position()) &&\n+                    (serverOut.limit() == clientIn.position())) {\n+                checkTransfer(serverOut, clientIn);\n+                checkTransfer(clientOut, serverIn);\n+\n+                clientEngine.closeOutbound();\n+                dataDone = true;\n+                serverEngine.closeOutbound();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Twists signature schemes in CertificateRequest message for negative\n+     * client authentication cases.\n+     *\n+     * @param tlsRecord a ByteBuffer containing a TLS record.  It is assumed\n+     *      that the position of the ByteBuffer is on the first byte of the TLS\n+     *      record header.\n+     *\n+     * @throws SSLException if the incoming ByteBuffer does not contain a\n+     *      well-formed TLS message.\n+     *\/\n+    private static void twistCertReqMsg(\n+            ByteBuffer tlsRecord) throws SSLException {\n+        Objects.requireNonNull(tlsRecord);\n+        tlsRecord.mark();\n+\n+        \/\/ Process the TLS record header\n+        int type = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_major = Byte.toUnsignedInt(tlsRecord.get());\n+        int ver_minor = Byte.toUnsignedInt(tlsRecord.get());\n+        int recLen = Short.toUnsignedInt(tlsRecord.getShort());\n+\n+        \/\/ Simple sanity checks\n+        if (type != 22) {\n+            throw new SSLException(\"Not a handshake: Type = \" + type);\n+        } else if (recLen > tlsRecord.remaining()) {\n+            throw new SSLException(\"Incomplete record in buffer: \" +\n+                    \"Record length = \" + recLen + \", Remaining = \" +\n+                    tlsRecord.remaining());\n+        }\n+\n+        while (tlsRecord.hasRemaining()) {\n+            \/\/ Grab the handshake message header.\n+            int msgHdr = tlsRecord.getInt();\n+            int msgType = (msgHdr >> 24) & 0x000000FF;\n+            int msgLen = msgHdr & 0x00FFFFFF;\n+\n+            if (msgType == TLS_HS_CERT_REQ) {\n+                \/\/ Slice the buffer such that it contains the entire\n+                \/\/ handshake message (less the handshake header).\n+                int bufPos = tlsRecord.position();\n+                ByteBuffer buf = tlsRecord.slice(bufPos, msgLen);\n+\n+                \/\/ Replace the signature scheme with an unknown value\n+                twistSigSchemesCertReq(buf, (short) 0x0000);\n+                byte[] bufBytes = new byte[buf.limit()];\n+                buf.get(bufBytes);\n+                tlsRecord.put(bufPos, bufBytes);\n+\n+                break;\n+            } else {\n+                \/\/ Skip to the next handshake message, if there is one\n+                tlsRecord.position(tlsRecord.position() + msgLen);\n+            }\n+        }\n+\n+        tlsRecord.reset();\n+    }\n+\n+    \/**\n+     * Replace the signature schemes in CertificateRequest message with an\n+     * alternative value.  It is assumed that the provided ByteBuffer has its\n+     * position set at the first byte of the CertificateRequest message body\n+     * (AFTER the handshake header) and contains the entire CR message.  Upon\n+     * successful completion of this method the ByteBuffer will have its\n+     * position reset to the initial offset in the buffer.\n+     * If an exception is thrown the position at the time of the exception\n+     * will be preserved.\n+     *\n+     * @param data the ByteBuffer containing the CertificateRequest bytes\n+     * @param altSigScheme an alternative signature scheme\n+     *\/\n+    private static void twistSigSchemesCertReq(ByteBuffer data,\n+                                               Short altSigScheme) {\n+        Objects.requireNonNull(data);\n+        data.mark();\n+\n+        \/\/ Jump past the certificate types\n+        int certTypeLen = Byte.toUnsignedInt(data.get());\n+        if (certTypeLen != 0) {\n+            data.position(data.position() + certTypeLen);\n+        }\n+\n+        int sigSchemeLen = Short.toUnsignedInt(data.getShort());\n+        for (int ssOff = 0; ssOff < sigSchemeLen; ssOff += 2) {\n+            System.err.println(\n+                    \"Use alternative signature scheme: \" + altSigScheme);\n+            data.putShort(data.position(), altSigScheme);\n+        }\n+\n+        data.reset();\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS12.java","additions":381,"deletions":0,"binary":false,"changes":381,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test 8263188\n+ * @summary If TLS the server and client has no common signature algorithms,\n+ *     the connection should fail fast with \"No supported signature algorithm\".\n+ *     This test only covers TLS 1.3, but doesn't cover client authentication.\n+ *\n+ * @library \/test\/lib\n+ *          \/javax\/net\/ssl\/templates\n+ *\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256,ecdsa_secp384r1_sha384\n+ *     -Dtest.expectFail=false\n+ *     SigAlgosExtTestWithTLS13\n+ * @run main\/othervm\n+ *     -Djdk.tls.server.SignatureSchemes=ecdsa_secp384r1_sha384\n+ *     -Djdk.tls.client.SignatureSchemes=ecdsa_secp256r1_sha256\n+ *     -Dtest.expectFail=true\n+ *     SigAlgosExtTestWithTLS13\n+ *\/\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLHandshakeException;\n+import javax.net.ssl.SSLSocket;\n+\n+public class SigAlgosExtTestWithTLS13 extends SSLSocketTemplate {\n+\n+    @Override\n+    protected SSLContext createServerSSLContext() throws Exception {\n+        return createSSLContext(\n+                new Cert[] { Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1 },\n+                new Cert[] { Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1 },\n+                getServerContextParameters());\n+    }\n+\n+    @Override\n+    protected SSLContext createClientSSLContext() throws Exception {\n+        return createSSLContext(\n+                new Cert[] { Cert.CA_ECDSA_SECP256R1, Cert.CA_ECDSA_SECP384R1 },\n+                new Cert[] { Cert.EE_ECDSA_SECP256R1, Cert.EE_ECDSA_SECP384R1 },\n+                getClientContextParameters());\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        socket.setEnabledProtocols(new String[] { \"TLSv1.3\" });\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean expectFail = Boolean.getBoolean(\"test.expectFail\");\n+        try {\n+            new SigAlgosExtTestWithTLS13().run();\n+            if (expectFail) {\n+                throw new RuntimeException(\n+                        \"Expected SSLHandshakeException wasn't thrown\");\n+            }\n+        } catch (SSLHandshakeException e) {\n+            if (expectFail && e.getMessage().equals(\n+                    \"No supported signature algorithm\")) {\n+                System.out.println(\"Expected SSLHandshakeException\");\n+            } else {\n+                throw e;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SignatureScheme\/SigAlgosExtTestWithTLS13.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8073446 8262110\n+ * @summary Tests DST related beyond the year 2037\n+ * @run testng Beyond2037\n+ *\/\n+\n+import java.text.SimpleDateFormat;\n+import java.util.TimeZone;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class Beyond2037 {\n+\n+    @DataProvider\n+    Object[][] dstTransition() {\n+        return new Object[][] {\n+            {\"2037\/03\/08 01:59:59:999\", \"2037\/03\/08 01:59:59:999\"},\n+            {\"2037\/03\/08 02:00:00:000\", \"2037\/03\/08 03:00:00:000\"},\n+            {\"2038\/03\/14 01:59:59:999\", \"2038\/03\/14 01:59:59:999\"},\n+            {\"2038\/03\/14 02:00:00:000\", \"2038\/03\/14 03:00:00:000\"},\n+            {\"2099\/03\/08 01:59:59:999\", \"2099\/03\/08 01:59:59:999\"},\n+            {\"2099\/03\/08 02:00:00:000\", \"2099\/03\/08 03:00:00:000\"},\n+            {\"2100\/03\/14 01:59:59:999\", \"2100\/03\/14 01:59:59:999\"},\n+            {\"2100\/03\/14 02:00:00:000\", \"2100\/03\/14 03:00:00:000\"},\n+            {\"8000\/03\/12 01:59:59:999\", \"8000\/03\/12 01:59:59:999\"},\n+            {\"8000\/03\/12 02:00:00:000\", \"8000\/03\/12 03:00:00:000\"},\n+        };\n+    }\n+\n+    @Test(dataProvider=\"dstTransition\")\n+    public void testDstTransition(String source, String expected) throws Exception {\n+        var timeZone = TimeZone.getTimeZone(\"America\/New_York\");\n+        var sdf = new SimpleDateFormat(\"yyyy\/MM\/dd HH:mm:ss:SSS\" );\n+        sdf.setTimeZone(timeZone);\n+        assertEquals(sdf.format(sdf.parse(source)), expected);\n+    }\n+\n+    @Test\n+    public void testGetOffset() throws Exception {\n+        var timeZone = TimeZone.getTimeZone(\"PST8PDT\");\n+        var df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n+        df.setTimeZone(timeZone);\n+        var tMilli = df.parse(\"7681-03-09 03:20:49\").getTime();\n+        assertEquals(timeZone.getOffset(tMilli), -25200000);\n+    }\n+}\n","filename":"test\/jdk\/sun\/util\/calendar\/zi\/Beyond2037.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.tests;\n+\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.HelloApp;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.Annotations.Parameters;\n+import jdk.jpackage.test.Annotations.Test;\n+\n+\n+\/*\n+ * @test\n+ * @summary jpackage create image with --java-options test\n+ * @library ..\/..\/..\/..\/helpers\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile DotInNameTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=jdk.jpackage.tests.DotInNameTest\n+ *  --jpt-before-run=jdk.jpackage.test.JPackageCommand.useToolProviderByDefault\n+ *\/\n+\n+public class DotInNameTest {\n+\n+    @Test\n+    public void test() {\n+        JPackageCommand cmd = JPackageCommand.helloAppImage(\"Hello\");\n+\n+        cmd.setArgumentValue(\"--name\",\n+                cmd.getArgumentValue(\"--name\") + \".with.dot\");\n+        \/\/ run the jpackage command\n+        cmd.executeAndAssertImageCreated();\n+\n+        \/\/ run the launcher it generated\n+        HelloApp.executeLauncherAndVerifyOutput(cmd);\n+\n+    }\n+\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/DotInNameTest.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -60,12 +60,0 @@\n-\/*\n- * @test\n- * @summary jpackage for app's module linked in external runtime\n- * @library ..\/..\/..\/..\/helpers\n- * @build jdk.jpackage.test.*\n- * @modules jdk.jpackage\/jdk.jpackage.internal\n- * @compile ModulePathTest3.java\n- * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n- *  --jpt-run=jdk.jpackage.tests.ModulePathTest3\n- *  --jpt-exclude=test8248418\n- *\/\n-\n@@ -88,9 +76,0 @@\n-    \/**\n-     * Test case for JDK-8248418.\n-     * App's module with version specified in runtime directory.\n-     *\/\n-    @Test\n-    public void test8248418() throws XPathExpressionException, IOException {\n-        testIt(\"me.mymodule\/me.mymodule.Main@3.7\");\n-    }\n-\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/ModulePathTest3.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.net.UnknownHostException;\n@@ -49,0 +50,2 @@\n+import java.time.Duration;\n+import java.time.Instant;\n@@ -87,1 +90,13 @@\n-        \/\/ first, test to see if access to external URLs is available\n+        \/\/ This test relies on access to an external resource, which may or may not be\n+        \/\/ reliably available, depending on the host system configuration and other\n+        \/\/ networking issues. Therefore, it is disabled by default, unless the system\n+        \/\/ property \"javadoc.dev\" is set \"true\".\n+        String property = \"javadoc.dev\";\n+        if (!Boolean.getBoolean(property)) {\n+            out.println(\"Test case disabled by default; \"\n+                    + \"set system property \\\"\" + property + \"\\\" to true to enable it.\");\n+            return;\n+        }\n+\n+        \/\/ test to see if access to external URLs is available, and that the URL uses a redirect\n+\n@@ -89,0 +104,9 @@\n+        String testURLHost = testURL.getHost();\n+        try {\n+            InetAddress testAddr = InetAddress.getByName(testURLHost);\n+            out.println(\"Found \" + testURLHost + \": \" + testAddr);\n+        } catch (UnknownHostException e) {\n+            out.println(\"Setup failed (\" + testURLHost + \" not found); this test skipped\");\n+            return;\n+        }\n+\n@@ -90,0 +114,1 @@\n+        Instant start = Instant.now();\n@@ -110,0 +135,2 @@\n+            Instant now = Instant.now();\n+            out.println(\"Attempt took \" + Duration.between(start, now).toSeconds() + \" seconds\");\n@@ -113,1 +140,1 @@\n-            out.println(\"Setup failed; this test skipped\");\n+            out.println(\"Setup failed (no redirect URL); this test skipped\");\n@@ -122,0 +149,1 @@\n+                \"-Xdoclint:none\",\n@@ -160,1 +188,2 @@\n-                        \"--module\", \"mA,mB\")\n+                        \"--module\", \"mA,mB\",\n+                        \"-Xdoclint:none\")\n@@ -166,1 +195,2 @@\n-                \"--module\", \"mA,mB\" );\n+                \"--module\", \"mA,mB\",\n+                \"-Xdoclint:none\" );\n@@ -169,1 +199,2 @@\n-        InetAddress localHost = InetAddress.getLocalHost();\n+        \/\/ use loopback address to avoid any issues if proxy is in use\n+        InetAddress localHost = InetAddress.getLoopbackAddress();\n@@ -204,1 +235,2 @@\n-                        \"--module\", \"mC\" );\n+                        \"--module\", \"mC\",\n+                        \"-Xdoclint:none\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkOption\/TestRedirectLinks.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+ *          jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRelatedPackages\/TestRelatedPackages.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8264306\n+ * @summary Verify patterns are desugaring in a reproducible manner\n+ * @library \/tools\/lib \/tools\/javac\/lib\n+ * @modules\n+ *      jdk.compiler\/com.sun.tools.javac.api\n+ *      jdk.compiler\/com.sun.tools.javac.file\n+ *      jdk.compiler\/com.sun.tools.javac.main\n+ *      jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @compile StablePatternDesugaring.java\n+ * @run main StablePatternDesugaring\n+ *\/\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import toolbox.ToolBox;\n+import toolbox.JavacTask;\n+\n+public class StablePatternDesugaring {\n+    protected ToolBox tb;\n+\n+    StablePatternDesugaring() {\n+        tb = new ToolBox();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new StablePatternDesugaring().run();\n+    }\n+\n+    void run() throws Exception {\n+        String code = \"\"\"\n+                      public class T {\n+                          private boolean t(Object o) {\n+                              if (o instanceof String s) {\n+                                  return s.isEmpty();\n+                              } else if (o instanceof CharSequence cs) {\n+                                  return cs.isEmpty();\n+                              } else if (o instanceof Integer i) {\n+                                  return i != 0;\n+                              } else if (o instanceof Float f) {\n+                                  return f != 0;\n+                              } else {\n+                                  return false;\n+                              }\n+                          }\n+                      }\n+                      \"\"\";\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src, code);\n+\n+        Path classes1 = base.resolve(\"classes1\");\n+\n+        if (Files.isDirectory(classes1)) {\n+            tb.cleanDirectory(classes1);\n+        } else {\n+            Files.createDirectories(classes1);\n+        }\n+\n+        new JavacTask(tb)\n+            .files(tb.findJavaFiles(src))\n+            .outdir(classes1)\n+            .run()\n+            .writeAll();\n+\n+        byte[] expected = Files.readAllBytes(classes1.resolve(\"T.class\"));\n+\n+        for (int i = 0; i < 10; i++) {\n+            Path classes2 = base.resolve(\"classes2\");\n+\n+            if (Files.isDirectory(classes2)) {\n+                tb.cleanDirectory(classes2);\n+            } else {\n+                Files.createDirectories(classes2);\n+            }\n+\n+            new JavacTask(tb)\n+                .files(tb.findJavaFiles(src))\n+                .outdir(classes2)\n+                .run()\n+                .writeAll();\n+\n+            byte[] actual = Files.readAllBytes(classes2.resolve(\"T.class\"));\n+\n+            if (!Arrays.equals(expected, actual)) {\n+                throw new AssertionError(\"Classfiles differ!\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/patterns\/StablePatternDesugaring.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,0 +210,16 @@\n+\n+    \/**\n+     * This tests has issues if you try adding privileges on OSX. The debugd process cannot\n+     * be killed if you do this (because it is a root process and the test is not), so the destroy()\n+     * call fails to do anything, and then waitFor() will time out. If you try to manually kill it with\n+     * a \"sudo kill\" command, that seems to work, but then leaves the LingeredApp it was\n+     * attached to in a stuck state for some unknown reason, causing the stopApp() call\n+     * to timeout. For that reason we don't run this test when privileges are needed. Note\n+     * it does appear to run fine as root, so we still allow it to run on OSX when privileges\n+     * are not required.\n+     *\/\n+    public static void validateSADebugDPrivileges() {\n+        if (needsPrivileges()) {\n+            throw new SkippedException(\"Cannot run this test on OSX if adding privileges is required.\");\n+        }\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/SA\/SATestUtils.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -28,0 +29,2 @@\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n@@ -35,0 +38,1 @@\n+import org.openjdk.jmh.annotations.Warmup;\n@@ -39,2 +43,5 @@\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(2)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.Throughput)\n@@ -53,0 +60,5 @@\n+    public int int1 = 1, int2 = 2, int42 = 42, int5 = 5;\n+    public long long1 = 1L, long2 = 2L, long747 = 747L, long13 = 13L;\n+    public float float1 = 1.0f, float2 = 2.0f, floatNegative99 = -99.0f, float7 = 7.0f, eFloat = 2.718f;\n+    public double double1 = 1.0d, double2 = 2.0d, double81 = 81.0d, doubleNegative12 = -12.0d, double4Dot1 = 4.1d;\n+\n@@ -63,3 +75,132 @@\n-    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n-    public int floorModIntIntPositive() {\n-        return Math.floorMod(dividend, divisor);\n+    public double  absDouble() {\n+        return  Math.abs(doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public float  absFloat() {\n+        return  Math.abs(floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public int  absExactInt() {\n+        return  Math.absExact(int2);\n+    }\n+\n+    @Benchmark\n+    public long  absExactLong() {\n+        return  Math.absExact(long2);\n+    }\n+\n+    @Benchmark\n+    public int  absInt() {\n+        return  Math.abs(int42);\n+    }\n+\n+    @Benchmark\n+    public long  absLong() {\n+        return  Math.abs(long13);\n+    }\n+\n+    @Benchmark\n+    public double  acosDouble() {\n+        return  Math.acos(double1);\n+    }\n+\n+    @Benchmark\n+    public int  addExactInt() {\n+        return  Math.addExact(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  addExactLong() {\n+        return  Math.addExact(long2, long13);\n+    }\n+\n+    @Benchmark\n+    public double  asinDouble() {\n+        return  Math.asin(double1);\n+    }\n+\n+    @Benchmark\n+    public double  atanDouble() {\n+        return  Math.atan(double1);\n+    }\n+\n+    @Benchmark\n+    public double  atan2Double() {\n+        return  Math.atan2(double1, double2);\n+    }\n+\n+    @Benchmark\n+    public double  cbrt() {\n+        return  Math.cbrt(double81);\n+    }\n+\n+    @Benchmark\n+    public double  ceilDouble() {\n+        return  Math.ceil(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  copySignDouble() {\n+        return  Math.copySign(double81, doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public float  copySignFloat() {\n+        return  Math.copySign(floatNegative99, float1);\n+    }\n+\n+    @Benchmark\n+    public double  cosDouble() {\n+        return  Math.cos(double1);\n+    }\n+\n+    @Benchmark\n+    public double  coshDouble() {\n+        return  Math.cosh(double2);\n+    }\n+\n+    @Benchmark\n+    public int  decrementExactInt() {\n+        return  Math.decrementExact(int42);\n+    }\n+\n+    @Benchmark\n+    public long  decrementExactLong() {\n+        return  Math.decrementExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  expDouble() {\n+        return  Math.exp(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  expm1() {\n+        return  Math.expm1(doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public double  floorDouble() {\n+        return  Math.floor(doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public int  floorDivIntInt() {\n+        return  Math.floorDiv(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  floorDivLongInt() {\n+        return  Math.floorDiv(long747, int42);\n+    }\n+\n+    @Benchmark\n+    public long  floorDivLongLong() {\n+        return  Math.floorDiv(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public int  floorModIntInt() {\n+        return  Math.floorMod(int42, int5);\n@@ -70,1 +211,1 @@\n-    public int floorModIntInt() {\n+    public int floorModIntIntMultiple() {\n@@ -77,0 +218,5 @@\n+    @Benchmark\n+    public int  floorModLongInt() {\n+        return  Math.floorMod(long747, int5);\n+    }\n+\n@@ -79,1 +225,1 @@\n-    public int floorModLongInt() {\n+    public int floorModLongIntMultiple() {\n@@ -86,0 +232,5 @@\n+    @Benchmark\n+    public long  floorModLongLong() {\n+        return  Math.floorMod(long747, long13);\n+    }\n+\n@@ -88,1 +239,1 @@\n-    public long floorModLongLong() {\n+    public long floorModLongLongMultiple() {\n@@ -95,0 +246,265 @@\n+    @Benchmark\n+    public double  fmaDouble() {\n+        return  Math.fma(double2, double81, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public float  fmaFloat() {\n+        return  Math.fma(float2, floatNegative99, float7);\n+    }\n+\n+    @Benchmark\n+    public int  getExponentDouble() {\n+        return  Math.getExponent(double81);\n+    }\n+\n+    @Benchmark\n+    public int  getExponentFloat() {\n+        return  Math.getExponent(float7);\n+    }\n+\n+    @Benchmark\n+    public double  hypotDouble() {\n+        return  Math.hypot(double2, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  IEEERemainderDouble() {\n+        return  Math.IEEEremainder(double81, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public int  incrementExactInt() {\n+        return  Math.incrementExact(int42);\n+    }\n+\n+    @Benchmark\n+    public long  incrementExactLong() {\n+        return  Math.incrementExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  logDouble() {\n+        return  Math.log(double81);\n+    }\n+\n+    @Benchmark\n+    public double  log10Double() {\n+        return  Math.log10(double81);\n+    }\n+\n+    @Benchmark\n+    public double  log1pDouble() {\n+        return  Math.log1p(double81);\n+    }\n+\n+    @Benchmark\n+    public int  maxInt() {\n+        return  Math.max(int1, int2);\n+    }\n+\n+    @Benchmark\n+    public long  maxLong() {\n+        return  Math.max(long1, long2);\n+    }\n+\n+    @Benchmark\n+    public float  maxFloat() {\n+        return  Math.max(float1, float2);\n+    }\n+\n+    @Benchmark\n+    public double  maxDouble() {\n+        return  Math.max(double1, doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public int  minInt() {\n+        return  Math.min(int1, int2);\n+    }\n+\n+    @Benchmark\n+    public long  minLong() {\n+        return  Math.min(long1, long2);\n+    }\n+\n+    @Benchmark\n+    public float  minFloat() {\n+        return  Math.min(float1, floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public double  minDouble() {\n+        return  Math.min(double4Dot1, double2);\n+    }\n+\n+    @Benchmark\n+    public int  multiplyExactInt() {\n+        return  Math.multiplyExact(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyExactLongInt() {\n+        return  Math.multiplyExact(long747, int42);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyExactLongLong() {\n+        return  Math.multiplyExact(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyFullIntInt() {\n+        return  Math.multiplyFull(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyHighLongLog() {\n+        return  Math.multiplyHigh(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public int  negateExactInt() {\n+        return  Math.negateExact(int42);\n+    }\n+\n+    @Benchmark\n+    public long  negateExactLong() {\n+        return  Math.negateExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  nextAfterDoubleDouble() {\n+        return  Math.nextAfter(double81, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public float  nextAfterFloatDouble() {\n+        return  Math.nextAfter(float7, doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public double  nextDownDouble() {\n+        return  Math.nextDown(float7);\n+    }\n+\n+    @Benchmark\n+    public float  nextDownFloat() {\n+        return  Math.nextDown(floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public double  nextUpDouble() {\n+        return  Math.nextUp(double81);\n+    }\n+\n+    @Benchmark\n+    public float  nextUpFloat() {\n+        return  Math.nextUp(float7);\n+    }\n+\n+    @Benchmark\n+    public double  powDouble() {\n+        return  Math.pow(double4Dot1, double2);\n+    }\n+\n+    @Benchmark\n+    public double  random() {\n+        return  Math.random();\n+    }\n+\n+    @Benchmark\n+    public double  rintDouble() {\n+        return  Math.rint(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public long  roundDouble() {\n+        return  Math.round( Math.PI);\n+    }\n+\n+    @Benchmark\n+    public int  roundFloat() {\n+        return  Math.round(eFloat);\n+    }\n+\n+    @Benchmark\n+    public double  scalbDoubleInt() {\n+        return  Math.scalb(double81, int2);\n+    }\n+\n+    @Benchmark\n+    public float  scalbFloatInt() {\n+        return  Math.scalb(float7, int2);\n+    }\n+\n+    @Benchmark\n+    public double  sigNumDouble() {\n+        return  Math.signum(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  signumFloat() {\n+        return  Math.signum(floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public double  sinDouble() {\n+        return  Math.sin(double1);\n+    }\n+\n+    @Benchmark\n+    public double  sinhDouble() {\n+        return  Math.sinh(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  sqrtDouble() {\n+        return  Math.sqrt(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  subtractExactIntInt() {\n+        return  Math.subtractExact(int42,int5);\n+    }\n+\n+    @Benchmark\n+    public double  subtractExactLongLong() {\n+        return  Math.subtractExact(long747,long13);\n+    }\n+\n+    @Benchmark\n+    public double  tanDouble() {\n+        return  Math.tan(double1);\n+    }\n+\n+    @Benchmark\n+    public double  tanhDouble() {\n+        return  Math.tanh(double1);\n+    }\n+\n+    @Benchmark\n+    public double  toDegreesDouble() {\n+        return  Math.toDegrees(double81);\n+    }\n+\n+    @Benchmark\n+    public double  toIntExactLong() {\n+        return  Math.toIntExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  toRadiansDouble() {\n+        return  Math.toRadians(double81);\n+    }\n+\n+    @Benchmark\n+    public double  ulpDouble() {\n+        return  Math.ulp(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  ulpFloat() {\n+        return  Math.ulp(float7);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/MathBench.java","additions":425,"deletions":9,"binary":false,"changes":434,"status":"modified"},{"patch":"@@ -0,0 +1,459 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(2)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@State(Scope.Thread)\n+public class StrictMathBench {\n+\n+    public int int1 = 1, int2 = 2, int42 = 42, int5 = 5;\n+    public long long1 = 1L, long2 = 2L, long747 = 747L, long13 = 13L;\n+    public float float1 = 1.0f, float2 = 2.0f, floatNegative99 = -99.0f, float7 = 7.0f, eFloat = 2.718f;\n+    public double double1 = 1.0d, double2 = 2.0d, double81 = 81.0d, doubleNegative12 = -12.0d, double4Dot1 = 4.1d;\n+\n+    @Benchmark\n+    public double  absDouble() {\n+        return  StrictMath.abs(doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public int  absExactInt() {\n+        return  StrictMath.absExact(int2);\n+    }\n+\n+    @Benchmark\n+    public long  absExactLong() {\n+        return  StrictMath.absExact(long2);\n+    }\n+\n+    @Benchmark\n+    public float  absFloat() {\n+        return  StrictMath.abs(floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public int  absInt() {\n+        return  StrictMath.abs(int42);\n+    }\n+\n+    @Benchmark\n+    public long  absLong() {\n+        return  StrictMath.abs(long13);\n+    }\n+\n+    @Benchmark\n+    public double  acosDouble() {\n+        return  StrictMath.acos(double1);\n+    }\n+\n+    @Benchmark\n+    public int  addExactInt() {\n+        return  StrictMath.addExact(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  addExactLong() {\n+        return  StrictMath.addExact(long2, long13);\n+    }\n+\n+    @Benchmark\n+    public double  asinDouble() {\n+        return  StrictMath.asin(double1);\n+    }\n+\n+    @Benchmark\n+    public double  atanDouble() {\n+        return  StrictMath.atan(double1);\n+    }\n+\n+    @Benchmark\n+    public double  atan2Double() {\n+        return  StrictMath.atan2(double1, double2);\n+    }\n+\n+    @Benchmark\n+    public double  cbrt() {\n+        return  StrictMath.cbrt(double81);\n+    }\n+\n+    @Benchmark\n+    public double  ceilDouble() {\n+        return  StrictMath.ceil(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  copySignDouble() {\n+        return  StrictMath.copySign(double81, doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public float  copySignFloat() {\n+        return  StrictMath.copySign(floatNegative99, float1);\n+    }\n+\n+    @Benchmark\n+    public double  cosDouble() {\n+        return  StrictMath.cos(double1);\n+    }\n+\n+    @Benchmark\n+    public double  coshDouble() {\n+        return  StrictMath.cosh(double2);\n+    }\n+\n+    @Benchmark\n+    public int  decrementExactInt() {\n+        return  StrictMath.decrementExact(int42);\n+    }\n+\n+    @Benchmark\n+    public long  decrementExactLong() {\n+        return  StrictMath.decrementExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  expDouble() {\n+        return  StrictMath.exp(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  expm1() {\n+        return  StrictMath.expm1(doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public double  floorDouble() {\n+        return  StrictMath.floor(doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public int  floorDivIntInt() {\n+        return  StrictMath.floorDiv(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  floorDivLongInt() {\n+        return  StrictMath.floorDiv(long747, int42);\n+    }\n+\n+    @Benchmark\n+    public long  floorDivLongLong() {\n+        return  StrictMath.floorDiv(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public int  floorModIntInt() {\n+        return  StrictMath.floorMod(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public int  floorModLongInt() {\n+        return  StrictMath.floorMod(long747, int5);\n+    }\n+\n+    @Benchmark\n+    public long  floorModLongLong() {\n+        return  StrictMath.floorMod(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public double  fmaDouble() {\n+        return  StrictMath.fma(double2, double81, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public float  fmaFloat() {\n+        return  StrictMath.fma(float2, floatNegative99, float7);\n+    }\n+\n+    @Benchmark\n+    public int  getExponentDouble() {\n+        return  StrictMath.getExponent(double81);\n+    }\n+\n+    @Benchmark\n+    public int  getExponentFloat() {\n+        return  StrictMath.getExponent(float7);\n+    }\n+\n+    @Benchmark\n+    public double  hypotDouble() {\n+        return  StrictMath.hypot(double2, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  IEEERemainderDouble() {\n+        return  StrictMath.IEEEremainder(double81, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public int  IncrementExactInt() {\n+        return  StrictMath.incrementExact(int42);\n+    }\n+\n+    @Benchmark\n+    public long  IncrementExactLong() {\n+        return  StrictMath.incrementExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  logDouble() {\n+        return  StrictMath.log(double81);\n+    }\n+\n+    @Benchmark\n+    public double  log10Double() {\n+        return  StrictMath.log10(double81);\n+    }\n+\n+    @Benchmark\n+    public double  log1pDouble() {\n+        return  StrictMath.log1p(double81);\n+    }\n+\n+    @Benchmark\n+    public int  maxInt() {\n+        return  StrictMath.max(int1, int2);\n+    }\n+\n+    @Benchmark\n+    public long  maxLong() {\n+        return  StrictMath.max(long1, long2);\n+    }\n+\n+    @Benchmark\n+    public float  maxFloat() {\n+        return  StrictMath.max(float1, float2);\n+    }\n+\n+    @Benchmark\n+    public double  maxDouble() {\n+        return  StrictMath.max(double1, doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public int  minInt() {\n+        return  StrictMath.min(int1, int2);\n+    }\n+\n+    @Benchmark\n+    public long  minLong() {\n+        return  StrictMath.min(long1, long2);\n+    }\n+\n+    @Benchmark\n+    public float  minFloat() {\n+        return  StrictMath.min(float1, floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public double  minDouble() {\n+        return  StrictMath.min(double4Dot1, double2);\n+    }\n+\n+    @Benchmark\n+    public int  multiplyExactInt() {\n+        return  StrictMath.multiplyExact(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyExactLongInt() {\n+        return  StrictMath.multiplyExact(long747, int42);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyExactLongLong() {\n+        return  StrictMath.multiplyExact(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyFullIntInt() {\n+        return  StrictMath.multiplyFull(int42, int5);\n+    }\n+\n+    @Benchmark\n+    public long  multiplyHighLongLog() {\n+        return  StrictMath.multiplyHigh(long747, long13);\n+    }\n+\n+    @Benchmark\n+    public int  negateExactInt() {\n+        return  StrictMath.negateExact(int42);\n+    }\n+\n+    @Benchmark\n+    public long  negateExactLong() {\n+        return  StrictMath.negateExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  nextAfterDoubleDouble() {\n+        return  StrictMath.nextAfter(double81, double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public float  nextAfterFloatDouble() {\n+        return  StrictMath.nextAfter(float7, doubleNegative12);\n+    }\n+\n+    @Benchmark\n+    public double  nextDownDouble() {\n+        return  StrictMath.nextDown(float7);\n+    }\n+\n+    @Benchmark\n+    public float  nextDownFloat() {\n+        return  StrictMath.nextDown(floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public double  nextUpDouble() {\n+        return  StrictMath.nextUp(double81);\n+    }\n+\n+    @Benchmark\n+    public float  nextUpFloat() {\n+        return  StrictMath.nextUp(float7);\n+    }\n+\n+    @Benchmark\n+    public double  powDouble() {\n+        return  StrictMath.pow(double4Dot1, double2);\n+    }\n+\n+    @Benchmark\n+    public double  random() {\n+        return  StrictMath.random();\n+    }\n+\n+    @Benchmark\n+    public double  rintDouble() {\n+        return  StrictMath.rint(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public long  roundDouble() {\n+        return  StrictMath.round( StrictMath.PI);\n+    }\n+\n+    @Benchmark\n+    public int  roundFloat() {\n+        return  StrictMath.round(eFloat);\n+    }\n+\n+    @Benchmark\n+    public double  scalbDoubleInt() {\n+        return  StrictMath.scalb(double81, int2);\n+    }\n+\n+    @Benchmark\n+    public float  scalbFloatInt() {\n+        return  StrictMath.scalb(float7, int2);\n+    }\n+\n+    @Benchmark\n+    public double  sigNumDouble() {\n+        return  StrictMath.signum(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  signumFloat() {\n+        return  StrictMath.signum(floatNegative99);\n+    }\n+\n+    @Benchmark\n+    public double  sinDouble() {\n+        return  StrictMath.sin(double1);\n+    }\n+\n+    @Benchmark\n+    public double  sinhDouble() {\n+        return  StrictMath.sinh(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  sqrtDouble() {\n+        return  StrictMath.sqrt(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  subtractExactIntInt() {\n+        return  StrictMath.subtractExact(int42,int5);\n+    }\n+\n+    @Benchmark\n+    public double  subtractExactLongLong() {\n+        return  StrictMath.subtractExact(long747,long13);\n+    }\n+\n+    @Benchmark\n+    public double  tanDouble() {\n+        return  StrictMath.tan(double1);\n+    }\n+\n+    @Benchmark\n+    public double  tanhDouble() {\n+        return  StrictMath.tanh(double1);\n+    }\n+\n+    @Benchmark\n+    public double  toDegreesDouble() {\n+        return  StrictMath.toDegrees(double81);\n+    }\n+\n+    @Benchmark\n+    public double  toIntExactLong() {\n+        return  StrictMath.toIntExact(long747);\n+    }\n+\n+    @Benchmark\n+    public double  toRadiansDouble() {\n+        return  StrictMath.toRadians(double81);\n+    }\n+\n+    @Benchmark\n+    public double  ulpDouble() {\n+        return  StrictMath.ulp(double4Dot1);\n+    }\n+\n+    @Benchmark\n+    public double  ulpFloat() {\n+        return  StrictMath.ulp(float7);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StrictMathBench.java","additions":459,"deletions":0,"binary":false,"changes":459,"status":"added"},{"patch":"@@ -263,1 +263,1 @@\n-        for (int kk = 0; kk < 3; kk++) {\n+        for (int kk = 0; kk < 5; kk++) {\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/InterfaceCalls.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}