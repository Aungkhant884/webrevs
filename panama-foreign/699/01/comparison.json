{"files":[{"patch":"@@ -44,2 +44,2 @@\n-  const GrowableArray<VMReg>& _input_registers;\n-  const GrowableArray<VMReg>& _output_registers;\n+  const GrowableArray<VMStorage>& _input_registers;\n+  const GrowableArray<VMStorage>& _output_registers;\n@@ -50,1 +50,1 @@\n-  int _framesize;\n+  int _frame_size_slots;\n@@ -58,2 +58,2 @@\n-                         const GrowableArray<VMReg>& input_registers,\n-                         const GrowableArray<VMReg>& output_registers,\n+                         const GrowableArray<VMStorage>& input_registers,\n+                         const GrowableArray<VMStorage>& output_registers,\n@@ -70,1 +70,1 @@\n-     _framesize(0),\n+     _frame_size_slots(0),\n@@ -81,1 +81,1 @@\n-    return (_framesize >> (LogBytesPerWord - LogBytesPerInt));\n+    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n@@ -95,2 +95,2 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n@@ -139,1 +139,1 @@\n-  Register shuffle_reg = r19;\n+  VMStorage shuffle_reg = VMS_R19;\n@@ -142,1 +142,1 @@\n-  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n+  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n@@ -157,1 +157,1 @@\n-  allocated_frame_size += arg_shuffle.out_arg_stack_slots() <<LogBytesPerInt;\n+  allocated_frame_size += arg_shuffle.out_arg_bytes();\n@@ -177,3 +177,2 @@\n-  _framesize = align_up(framesize\n-    + (allocated_frame_size >> LogBytesPerInt), 4);\n-  assert(is_even(_framesize\/2), \"sp not 16-byte aligned\");\n+  _frame_size_slots = align_up(framesize + (allocated_frame_size >> LogBytesPerInt), 4);\n+  assert(is_even(_frame_size_slots\/2), \"sp not 16-byte aligned\");\n@@ -187,1 +186,1 @@\n-  __ sub(sp, rfp, ((unsigned)_framesize-4) << LogBytesPerInt); \/\/ prolog\n+  __ sub(sp, rfp, ((unsigned)_frame_size_slots-4) << LogBytesPerInt); \/\/ prolog\n@@ -193,1 +192,1 @@\n-  OopMap* map = new OopMap(_framesize, 0);\n+  OopMap* map = new OopMap(_frame_size_slots, 0);\n@@ -202,1 +201,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), 0, _abi._shadow_space_bytes);\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes);\n@@ -233,3 +232,3 @@\n-      VMReg reg = _output_registers.at(i);\n-      if (reg->is_Register()) {\n-        __ str(reg->as_Register(), Address(tmp1, offset));\n+      VMStorage reg = _output_registers.at(i);\n+      if (reg.type() == RegType::INTEGER) {\n+        __ str(as_Register(reg), Address(tmp1, offset));\n@@ -237,2 +236,2 @@\n-      } else if(reg->is_FloatRegister()) {\n-        __ strd(reg->as_FloatRegister(), Address(tmp1, offset));\n+      } else if(reg.type() == RegType::VECTOR) {\n+        __ strd(as_FloatRegister(reg), Address(tmp1, offset));\n","filename":"src\/hotspot\/cpu\/aarch64\/downcallLinker_aarch64.cpp","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"prims\/vmstorage.inline.hpp\"\n@@ -45,3 +46,0 @@\n-static constexpr int INTEGER_TYPE = 0;\n-static constexpr int VECTOR_TYPE = 1;\n-\n@@ -51,1 +49,0 @@\n-  constexpr Register (*to_Register)(int) = as_Register;\n@@ -54,2 +51,2 @@\n-  parse_register_array(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, to_Register);\n-  parse_register_array(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_FloatRegister);\n+  parse_register_array(inputStorage, (int) RegType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, (int) RegType::VECTOR, abi._vector_argument_registers, as_FloatRegister);\n@@ -58,2 +55,2 @@\n-  parse_register_array(outputStorage, INTEGER_TYPE, abi._integer_return_registers, to_Register);\n-  parse_register_array(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_FloatRegister);\n+  parse_register_array(outputStorage, (int) RegType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, (int) RegType::VECTOR, abi._vector_return_registers, as_FloatRegister);\n@@ -62,2 +59,2 @@\n-  parse_register_array(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, to_Register);\n-  parse_register_array(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_FloatRegister);\n+  parse_register_array(volatileStorage, (int) RegType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, (int) RegType::VECTOR, abi._vector_additional_volatile_registers, as_FloatRegister);\n@@ -68,2 +65,2 @@\n-  abi._target_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop))->as_Register();\n-  abi._ret_buf_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop))->as_Register();\n+  abi._target_addr_reg = as_Register(parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop)));\n+  abi._ret_buf_addr_reg = as_Register(parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop)));\n@@ -74,17 +71,2 @@\n-enum class RegType {\n-  INTEGER = 0,\n-  VECTOR = 1,\n-  STACK = 3\n-};\n-\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  switch(static_cast<RegType>(type)) {\n-    case RegType::INTEGER: return ::as_Register(index)->as_VMReg();\n-    case RegType::VECTOR: return ::as_FloatRegister(index)->as_VMReg();\n-    case RegType::STACK: return VMRegImpl::stack2reg(index LP64_ONLY(* 2));\n-  }\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n-  if (reg->is_Register()) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n+  if (reg.type() == RegType::INTEGER) {\n@@ -92,1 +74,1 @@\n-  } else if (reg->is_FloatRegister()) {\n+  } else if (reg.type() == RegType::VECTOR) {\n@@ -98,5 +80,5 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n-  if (reg->is_Register()) {\n-    masm->spill(reg->as_Register(), true, offset);\n-  } else if (reg->is_FloatRegister()) {\n-    masm->spill(reg->as_FloatRegister(), masm->Q, offset);\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n+  if (reg.type() == RegType::INTEGER) {\n+    masm->spill(as_Register(reg), true, offset);\n+  } else if (reg.type() == RegType::VECTOR) {\n+    masm->spill(as_FloatRegister(reg), masm->Q, offset);\n@@ -108,5 +90,5 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n-  if (reg->is_Register()) {\n-    masm->unspill(reg->as_Register(), true, offset);\n-  } else if (reg->is_FloatRegister()) {\n-    masm->unspill(reg->as_FloatRegister(), masm->Q, offset);\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n+  if (reg.type() == RegType::INTEGER) {\n+    masm->unspill(as_Register(reg), true, offset);\n+  } else if (reg.type() == RegType::VECTOR) {\n+    masm->unspill(as_FloatRegister(reg), masm->Q, offset);\n@@ -118,17 +100,14 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n-  assert(in_stk_bias == 0 && out_stk_bias == 0, \"bias not implemented\");\n-  Register tmp_reg = tmp->as_Register();\n-  for (int i = 0; i < _moves.length(); i++) {\n-    Move move = _moves.at(i);\n-    BasicType arg_bt     = move.bt;\n-    VMRegPair from_vmreg = move.from;\n-    VMRegPair to_vmreg   = move.to;\n-\n-    masm->block_comment(err_msg(\"bt=%s\", null_safe_string(type2name(arg_bt))));\n-    switch (arg_bt) {\n-      case T_BOOLEAN:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_CHAR:\n-      case T_INT:\n-        masm->move32_64(from_vmreg, to_vmreg, tmp_reg);\n+constexpr int RFP_BIAS = 16; \/\/ skip old rfp and lr\n+\n+static void move_reg64(MacroAssembler* masm, int out_stk_bias,\n+                       Register from_reg, VMStorage to_reg) {\n+  switch (to_reg.type()) {\n+    case RegType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->mov(as_Register(to_reg), from_reg);\n+      break;\n+    case RegType::STACK:\n+      switch (to_reg.stack_size()) {\n+        \/\/ FIXME use correctly sized stores\n+        case 8: case 4: case 2: case 1:\n+          masm->str(from_reg, Address(sp, to_reg.offset() + out_stk_bias));\n@@ -136,0 +115,6 @@\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n@@ -137,2 +122,9 @@\n-      case T_FLOAT:\n-        masm->float_move(from_vmreg, to_vmreg, tmp_reg);\n+static void move_stack(MacroAssembler* masm, Register tmp_reg, int in_stk_bias, int out_stk_bias,\n+                       VMStorage from_reg, VMStorage to_reg) {\n+  switch (to_reg.type()) {\n+    case RegType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      switch (from_reg.stack_size()) {\n+        \/\/ FIXME use correctly sized loads\n+        case 8: case 4: case 2: case 1:\n+          masm->ldr(as_Register(to_reg), Address(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias));\n@@ -140,3 +132,23 @@\n-\n-      case T_DOUBLE:\n-        masm->double_move(from_vmreg, to_vmreg, tmp_reg);\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case RegType::VECTOR:\n+      assert(to_reg.segment_mask() == V128_MASK, \"only moves to v128 registers supported\");\n+      switch (from_reg.stack_size()) {\n+        case 8:\n+          masm->ldrd(as_FloatRegister(to_reg), Address(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias));\n+        break;\n+        case 4:\n+          masm->ldrs(as_FloatRegister(to_reg), Address(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias));\n+        break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case RegType::STACK:\n+      \/\/ We assume 8 bytes stack size when converting from VMReg (Java CC)\n+      \/\/assert(from_reg.stack_size() == to_reg.stack_size(), \"must be same\");\n+      switch (from_reg.stack_size()) {\n+        \/\/ FIXME use correctly sized loads & stores\n+        case 8: case 4: case 2: case 1:\n+          masm->ldr(tmp_reg, Address(rfp, RFP_BIAS + from_reg.offset() + in_stk_bias));\n+          masm->str(tmp_reg, Address(sp, to_reg.offset() + out_stk_bias));\n@@ -144,0 +156,6 @@\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n@@ -145,2 +163,14 @@\n-      case T_LONG :\n-        masm->long_move(from_vmreg, to_vmreg, tmp_reg);\n+static void move_v128(MacroAssembler* masm, int out_stk_bias,\n+                      FloatRegister from_reg, VMStorage to_reg) {\n+  switch (to_reg.type()) {\n+    case RegType::VECTOR:\n+      assert(to_reg.segment_mask() == V128_MASK, \"only moves to v128 registers supported\");\n+      masm->fmovd(as_FloatRegister(to_reg), from_reg);\n+      break;\n+    case RegType::STACK:\n+      switch(to_reg.stack_size()) {\n+        case 8:\n+          masm->strd(from_reg, Address(sp, to_reg.offset() + out_stk_bias));\n+        break;\n+        case 4:\n+          masm->strs(from_reg, Address(sp, to_reg.offset() + out_stk_bias));\n@@ -148,0 +178,6 @@\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n@@ -149,2 +185,20 @@\n-      default:\n-        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+  Register tmp_reg = as_Register(tmp);\n+  for (int i = 0; i < _moves.length(); i++) {\n+    Move move = _moves.at(i);\n+    VMStorage from_reg = move.from;\n+    VMStorage to_reg   = move.to;\n+\n+    switch (from_reg.type()) {\n+      case RegType::INTEGER:\n+        assert(from_reg.segment_mask() == REG64_MASK, \"only 64-bit register supported\");\n+        move_reg64(masm, out_stk_bias, as_Register(from_reg), to_reg);\n+        break;\n+      case RegType::VECTOR:\n+        assert(from_reg.segment_mask() == V128_MASK, \"only v128 register supported\");\n+        move_v128(masm, out_stk_bias, as_FloatRegister(from_reg), to_reg);\n+        break;\n+      case RegType::STACK:\n+        move_stack(masm, tmp_reg, in_stk_bias, out_stk_bias, from_reg, to_reg);\n+        break;\n+      default: ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":120,"deletions":66,"binary":false,"changes":186,"status":"modified"},{"patch":"@@ -132,3 +132,4 @@\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n-  int stack_slots = SharedRuntime::out_preserve_stack_slots() + arg_shuffle.out_arg_stack_slots();\n-  int out_arg_area = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n+  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, as_VMStorage(shuffle_reg));\n+  int preserved_bytes = SharedRuntime::out_preserve_stack_slots() * VMRegImpl::stack_slot_size;\n+  int stack_bytes = preserved_bytes + arg_shuffle.out_arg_bytes();\n+  int out_arg_area = align_up(stack_bytes , StackAlignmentInBytes);\n@@ -224,1 +225,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), abi._shadow_space_bytes, 0);\n+  arg_shuffle.generate(_masm, as_VMStorage(shuffle_reg), abi._shadow_space_bytes, 0);\n@@ -243,1 +244,1 @@\n-      VMReg j_expected_result_reg;\n+      VMStorage j_expected_result_reg;\n@@ -251,1 +252,1 @@\n-        j_expected_result_reg = r0->as_VMReg();\n+        j_expected_result_reg = VMS_R0;\n@@ -255,1 +256,1 @@\n-          j_expected_result_reg = v0->as_VMReg();\n+          j_expected_result_reg = VMS_V0;\n@@ -262,2 +263,1 @@\n-      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n-      \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n+      assert(call_regs._ret_regs.at(0) == j_expected_result_reg, \"unexpected result register\");\n@@ -271,3 +271,3 @@\n-      VMReg reg = call_regs._ret_regs.at(i);\n-      if (reg->is_Register()) {\n-        __ ldr(reg->as_Register(), Address(rscratch1, offset));\n+      VMStorage reg = call_regs._ret_regs.at(i);\n+      if (reg.type() == RegType::INTEGER) {\n+        __ ldr(as_Register(reg), Address(rscratch1, offset));\n@@ -275,2 +275,2 @@\n-      } else if (reg->is_FloatRegister()) {\n-        __ ldrd(reg->as_FloatRegister(), Address(rscratch1, offset));\n+      } else if (reg.type() == RegType::VECTOR) {\n+        __ ldrd(as_FloatRegister(reg), Address(rscratch1, offset));\n","filename":"src\/hotspot\/cpu\/aarch64\/upcallLinker_aarch64.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGE_AARCH64\n+#define SHARE_PRIMS_VMSTORAGE_AARCH64\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+#include \"prims\/vmstorageBase.inline.hpp\"\n+\n+\/\/ keep in sync with jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture\n+enum class RegType : int8_t {\n+  INTEGER = 0,\n+  VECTOR = 1,\n+  STACK = 2,\n+};\n+\n+constexpr inline RegType VMStorage::stack_type() {\n+  return RegType::STACK;\n+}\n+\n+constexpr uint16_t REG64_MASK = 0b0000000000000001;\n+constexpr uint16_t V128_MASK  = 0b0000000000000001;\n+\n+constexpr VMStorage VMS_R0 = VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, 0);\n+constexpr VMStorage VMS_R19 = VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, 19);\n+constexpr VMStorage VMS_V0 = VMStorage::reg_storage(RegType::VECTOR, V128_MASK, 0);\n+\n+inline Register as_Register(VMStorage vms) {\n+  assert(vms.type() == RegType::INTEGER, \"not the right type\");\n+  return ::as_Register(vms.index());\n+}\n+\n+inline FloatRegister as_FloatRegister(VMStorage vms) {\n+  assert(vms.type() == RegType::VECTOR, \"not the right type\");\n+  return ::as_FloatRegister(vms.index());\n+}\n+\n+inline VMStorage as_VMStorage(Register reg) {\n+  return VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, reg->encoding());\n+}\n+\n+inline VMStorage as_VMStorage(FloatRegister reg) {\n+  return VMStorage::reg_storage(RegType::VECTOR, V128_MASK, reg->encoding());\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  if (reg->is_Register()) {\n+    return as_VMStorage(reg->as_Register());\n+  } else if (reg->is_FloatRegister()) {\n+    return as_VMStorage(reg->as_FloatRegister());\n+  } else if (reg->is_stack()) {\n+    return VMStorage::stack_storage(reg);\n+  } else if (!reg->is_valid()) {\n+    return VMStorage::invalid();\n+  }\n+\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_AARCH64\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/aarch64\/vmstorage_aarch64.inline.hpp","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -32,2 +32,2 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n","filename":"src\/hotspot\/cpu\/arm\/downcallLinker_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -46,1 +41,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -50,1 +45,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -54,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n","filename":"src\/hotspot\/cpu\/arm\/foreignGlobals_arm.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGE_ARM\n+#define SHARE_PRIMS_VMSTORAGE_ARM\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+#include \"prims\/vmstorageBase.inline.hpp\"\n+\n+enum class RegType : int8_t {\n+  STACK = 0\n+};\n+\n+constexpr inline RegType VMStorage::stack_type() {\n+  return RegType::STACK;\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_ARM\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/arm\/vmstorage_arm.inline.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -33,2 +33,2 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n","filename":"src\/hotspot\/cpu\/ppc\/downcallLinker_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,6 +38,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -48,1 +43,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -52,1 +47,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -56,1 +51,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n","filename":"src\/hotspot\/cpu\/ppc\/foreignGlobals_ppc.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGE_PPC\n+#define SHARE_PRIMS_VMSTORAGE_PPC\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+#include \"prims\/vmstorageBase.inline.hpp\"\n+\n+enum class RegType : int8_t {\n+  STACK = 0\n+};\n+\n+constexpr inline RegType VMStorage::stack_type() {\n+  return RegType::STACK;\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_PPC\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/ppc\/vmstorage_ppc.inline.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -34,2 +34,2 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n","filename":"src\/hotspot\/cpu\/riscv\/downcallLinker_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,6 +38,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -48,1 +43,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -52,1 +47,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -56,1 +51,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n@@ -59,1 +54,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/foreignGlobals_riscv.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGE_RISCV\n+#define SHARE_PRIMS_VMSTORAGE_RISCV\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+#include \"prims\/vmstorageBase.inline.hpp\"\n+\n+enum class RegType : int8_t {\n+  STACK = 0\n+};\n+\n+constexpr inline RegType VMStorage::stack_type() {\n+  return RegType::STACK;\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_RISCV\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/vmstorage_riscv.inline.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -32,2 +32,2 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -46,1 +41,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -50,1 +45,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -54,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGE_S390\n+#define SHARE_PRIMS_VMSTORAGE_S390\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+#include \"prims\/vmstorageBase.inline.hpp\"\n+\n+enum class RegType : int8_t {\n+  STACK = 0\n+};\n+\n+constexpr inline RegType VMStorage::stack_type() {\n+  return RegType::STACK;\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_S390\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/s390\/vmstorage_s390.inline.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -31,2 +31,2 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_32.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-  const GrowableArray<VMReg>& _input_registers;\n-  const GrowableArray<VMReg>& _output_registers;\n+  const GrowableArray<VMStorage>& _input_registers;\n+  const GrowableArray<VMStorage>& _output_registers;\n@@ -49,1 +49,1 @@\n-  int _framesize;\n+  int _frame_size_slots;\n@@ -57,2 +57,2 @@\n-                         const GrowableArray<VMReg>& input_registers,\n-                         const GrowableArray<VMReg>& output_registers,\n+                         const GrowableArray<VMStorage>& input_registers,\n+                         const GrowableArray<VMStorage>& output_registers,\n@@ -69,1 +69,1 @@\n-     _framesize(0),\n+     _frame_size_slots(0),\n@@ -79,2 +79,2 @@\n-  int framesize() const {\n-    return (_framesize >> (LogBytesPerWord - LogBytesPerInt));\n+  int framesize() const { \/\/ frame size in 64-bit words\n+    return (_frame_size_slots >> (LogBytesPerWord - LogBytesPerInt));\n@@ -94,2 +94,2 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n@@ -135,1 +135,1 @@\n-  Register shufffle_reg = rbx;\n+  VMStorage shuffle_reg = VMS_RBX;\n@@ -138,1 +138,1 @@\n-  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shufffle_reg->as_VMReg());\n+  ArgumentShuffle arg_shuffle(_signature, _num_args, _signature, _num_args, &in_conv, &out_conv, shuffle_reg);\n@@ -154,1 +154,1 @@\n-  allocated_frame_size += arg_shuffle.out_arg_stack_slots() << LogBytesPerInt;\n+  allocated_frame_size += arg_shuffle.out_arg_bytes();\n@@ -176,3 +176,2 @@\n-  \/\/ _framesize is in 32-bit stack slots:\n-  _framesize += framesize_base + (allocated_frame_size >> LogBytesPerInt);\n-  assert(is_even(_framesize\/2), \"sp not 16-byte aligned\");\n+  _frame_size_slots += framesize_base + (allocated_frame_size >> LogBytesPerInt);\n+  assert(is_even(_frame_size_slots\/2), \"sp not 16-byte aligned\");\n@@ -194,1 +193,1 @@\n-  OopMap* map = new OopMap(_framesize, 0);\n+  OopMap* map = new OopMap(_frame_size_slots, 0);\n@@ -202,1 +201,1 @@\n-  arg_shuffle.generate(_masm, shufffle_reg->as_VMReg(), 0, _abi._shadow_space_bytes);\n+  arg_shuffle.generate(_masm, shuffle_reg, 0, _abi._shadow_space_bytes);\n@@ -235,3 +234,3 @@\n-      VMReg reg = _output_registers.at(i);\n-      if (reg->is_Register()) {\n-        __ movptr(Address(rscratch1, offset), reg->as_Register());\n+      VMStorage reg = _output_registers.at(i);\n+      if (reg.type() == RegType::INTEGER) {\n+        __ movptr(Address(rscratch1, offset), as_Register(reg));\n@@ -239,2 +238,2 @@\n-      } else if (reg->is_XMMRegister()) {\n-        __ movdqu(Address(rscratch1, offset), reg->as_XMMRegister());\n+      } else if (reg.type() == RegType::VECTOR) {\n+        __ movdqu(Address(rscratch1, offset), as_XMMRegister(reg));\n","filename":"src\/hotspot\/cpu\/x86\/downcallLinker_x86_64.cpp","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -46,1 +41,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -50,1 +45,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -54,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_32.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,4 +43,0 @@\n-static constexpr int INTEGER_TYPE = 0;\n-static constexpr int VECTOR_TYPE = 1;\n-static constexpr int X87_TYPE = 2;\n-\n@@ -52,2 +48,2 @@\n-  parse_register_array(inputStorage, INTEGER_TYPE, abi._integer_argument_registers, as_Register);\n-  parse_register_array(inputStorage, VECTOR_TYPE, abi._vector_argument_registers, as_XMMRegister);\n+  parse_register_array(inputStorage, (int) RegType::INTEGER, abi._integer_argument_registers, as_Register);\n+  parse_register_array(inputStorage, (int) RegType::VECTOR, abi._vector_argument_registers, as_XMMRegister);\n@@ -56,3 +52,3 @@\n-  parse_register_array(outputStorage, INTEGER_TYPE, abi._integer_return_registers, as_Register);\n-  parse_register_array(outputStorage, VECTOR_TYPE, abi._vector_return_registers, as_XMMRegister);\n-  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at(X87_TYPE));\n+  parse_register_array(outputStorage, (int) RegType::INTEGER, abi._integer_return_registers, as_Register);\n+  parse_register_array(outputStorage, (int) RegType::VECTOR, abi._vector_return_registers, as_XMMRegister);\n+  objArrayOop subarray = oop_cast<objArrayOop>(outputStorage->obj_at(((int) RegType::X87)));\n@@ -62,2 +58,2 @@\n-  parse_register_array(volatileStorage, INTEGER_TYPE, abi._integer_additional_volatile_registers, as_Register);\n-  parse_register_array(volatileStorage, VECTOR_TYPE, abi._vector_additional_volatile_registers, as_XMMRegister);\n+  parse_register_array(volatileStorage, (int) RegType::INTEGER, abi._integer_additional_volatile_registers, as_Register);\n+  parse_register_array(volatileStorage, (int) RegType::VECTOR, abi._vector_additional_volatile_registers, as_XMMRegister);\n@@ -68,2 +64,2 @@\n-  abi._target_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop))->as_Register();\n-  abi._ret_buf_addr_reg = parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop))->as_Register();\n+  abi._target_addr_reg = as_Register(parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::targetAddrStorage(abi_oop)));\n+  abi._ret_buf_addr_reg = as_Register(parse_vmstorage(jdk_internal_foreign_abi_ABIDescriptor::retBufAddrStorage(abi_oop)));\n@@ -74,19 +70,2 @@\n-enum class RegType {\n-  INTEGER = 0,\n-  VECTOR = 1,\n-  X87 = 2,\n-  STACK = 3\n-};\n-\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  switch(static_cast<RegType>(type)) {\n-    case RegType::INTEGER: return ::as_Register(index)->as_VMReg();\n-    case RegType::VECTOR: return ::as_XMMRegister(index)->as_VMReg();\n-    case RegType::STACK: return VMRegImpl::stack2reg(index LP64_ONLY(* 2)); \/\/ numbering on x64 goes per 64-bits\n-    case RegType::X87: break;\n-  }\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n-  if (reg->is_Register()) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n+  if (reg.type() == RegType::INTEGER) {\n@@ -94,1 +73,1 @@\n-  } else if (reg->is_XMMRegister()) {\n+  } else if (reg.type() == RegType::VECTOR) {\n@@ -100,5 +79,5 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n-  if (reg->is_Register()) {\n-    masm->movptr(Address(rsp, offset), reg->as_Register());\n-  } else if (reg->is_XMMRegister()) {\n-    masm->movdqu(Address(rsp, offset), reg->as_XMMRegister());\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n+  if (reg.type() == RegType::INTEGER) {\n+    masm->movptr(Address(rsp, offset), as_Register(reg));\n+  } else if (reg.type() == RegType::VECTOR) {\n+    masm->movdqu(Address(rsp, offset), as_XMMRegister(reg));\n@@ -110,5 +89,5 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n-  if (reg->is_Register()) {\n-    masm->movptr(reg->as_Register(), Address(rsp, offset));\n-  } else if (reg->is_XMMRegister()) {\n-    masm->movdqu(reg->as_XMMRegister(), Address(rsp, offset));\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n+  if (reg.type() == RegType::INTEGER) {\n+    masm->movptr(as_Register(reg), Address(rsp, offset));\n+  } else if (reg.type() == RegType::VECTOR) {\n+    masm->movdqu(as_XMMRegister(reg), Address(rsp, offset));\n@@ -120,2 +99,58 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n-  Register tmp_reg = tmp->as_Register();\n+constexpr int RBP_BIAS = 16; \/\/ skip old rbp and return address\n+\n+static void move_reg64(MacroAssembler* masm, int out_stk_bias,\n+                       Register from_reg, VMStorage to_reg) {\n+  switch (to_reg.type()) {\n+    case RegType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->movq(as_Register(to_reg), from_reg);\n+      break;\n+    case RegType::STACK:\n+      assert(to_reg.stack_size() == 8, \"only moves with 64-bit targets supported\");\n+      masm->movq(Address(rsp, to_reg.offset() + out_stk_bias), from_reg);\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+static void move_stack64(MacroAssembler* masm, Register tmp_reg, int in_stk_bias, int out_stk_bias,\n+                         int from_offset, VMStorage to_reg) {\n+  switch (to_reg.type()) {\n+    case RegType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->movq(as_Register(to_reg), Address(rbp, RBP_BIAS + from_offset + in_stk_bias));\n+      break;\n+    case RegType::VECTOR:\n+      assert(to_reg.segment_mask() == XMM_MASK, \"only moves to xmm registers supported\");\n+      masm->movdqu(as_XMMRegister(to_reg), Address(rbp, RBP_BIAS + from_offset + in_stk_bias));\n+      break;\n+    case RegType::STACK:\n+      assert(to_reg.stack_size() == 8, \"only moves with 64-bit targets supported\");\n+      masm->movq(tmp_reg, Address(rbp, RBP_BIAS + from_offset + in_stk_bias));\n+      masm->movq(Address(rsp, to_reg.offset() + out_stk_bias), tmp_reg);\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+static void move_xmm(MacroAssembler* masm, int out_stk_bias,\n+                     XMMRegister from_reg, VMStorage to_reg) {\n+  switch (to_reg.type()) {\n+    case RegType::INTEGER: \/\/ windows vargarg floats\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->movq(as_Register(to_reg), from_reg);\n+      break;\n+    case RegType::VECTOR:\n+      assert(to_reg.segment_mask() == XMM_MASK, \"only moves to xmm registers supported\");\n+      masm->movdqu(as_XMMRegister(to_reg), from_reg);\n+      break;\n+    case RegType::STACK:\n+      assert(to_reg.stack_size() == 8, \"only moves with 64-bit targets supported\");\n+      masm->movq(Address(rsp, to_reg.offset() + out_stk_bias), from_reg);\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n+  Register tmp_reg = as_Register(tmp);\n@@ -124,13 +159,2 @@\n-    BasicType arg_bt     = move.bt;\n-    VMRegPair from_vmreg = move.from;\n-    VMRegPair to_vmreg   = move.to;\n-\n-    masm->block_comment(err_msg(\"bt=%s\", null_safe_string(type2name(arg_bt))));\n-    switch (arg_bt) {\n-      case T_BOOLEAN:\n-      case T_BYTE:\n-      case T_SHORT:\n-      case T_CHAR:\n-      case T_INT:\n-        masm->move32_64(from_vmreg, to_vmreg, tmp_reg, in_stk_bias, out_stk_bias);\n-        break;\n+    VMStorage from_reg = move.from;\n+    VMStorage to_reg   = move.to;\n@@ -138,6 +162,4 @@\n-      case T_FLOAT:\n-        if (to_vmreg.first()->is_Register()) { \/\/ Windows vararg call\n-          masm->movq(to_vmreg.first()->as_Register(), from_vmreg.first()->as_XMMRegister());\n-        } else {\n-          masm->float_move(from_vmreg, to_vmreg, tmp_reg, in_stk_bias, out_stk_bias);\n-        }\n+    switch (from_reg.type()) {\n+      case RegType::INTEGER:\n+        assert(from_reg.segment_mask() == REG64_MASK, \"only 64-bit register supported\");\n+        move_reg64(masm, out_stk_bias, as_Register(from_reg), to_reg);\n@@ -145,7 +167,3 @@\n-\n-      case T_DOUBLE:\n-        if (to_vmreg.first()->is_Register()) { \/\/ Windows vararg call\n-          masm->movq(to_vmreg.first()->as_Register(), from_vmreg.first()->as_XMMRegister());\n-        } else {\n-          masm->double_move(from_vmreg, to_vmreg, tmp_reg, in_stk_bias, out_stk_bias);\n-        }\n+      case RegType::VECTOR:\n+        assert(from_reg.segment_mask() == XMM_MASK, \"only xmm register supported\");\n+        move_xmm(masm, out_stk_bias, as_XMMRegister(from_reg), to_reg);\n@@ -153,3 +171,3 @@\n-\n-      case T_LONG:\n-        masm->long_move(from_vmreg, to_vmreg, tmp_reg, in_stk_bias, out_stk_bias);\n+      case RegType::STACK:\n+        assert(from_reg.stack_size() == 8, \"only stack_size 8 supported\");\n+        move_stack64(masm, tmp_reg, in_stk_bias, out_stk_bias, from_reg.offset(), to_reg);\n@@ -157,3 +175,1 @@\n-\n-      default:\n-        fatal(\"found in upcall args: %s\", type2name(arg_bt));\n+      default: ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/x86\/foreignGlobals_x86_64.cpp","additions":93,"deletions":77,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  Register shuffle_reg = rbx;\n+  VMStorage shuffle_reg = VMS_RBX;\n@@ -181,3 +181,4 @@\n-  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg->as_VMReg());\n-  int stack_slots = SharedRuntime::out_preserve_stack_slots() + arg_shuffle.out_arg_stack_slots();\n-  int out_arg_area = align_up(stack_slots * VMRegImpl::stack_slot_size, StackAlignmentInBytes);\n+  ArgumentShuffle arg_shuffle(in_sig_bt, total_in_args, out_sig_bt, total_out_args, &in_conv, &out_conv, shuffle_reg);\n+  int preserved_bytes = SharedRuntime::out_preserve_stack_slots() * VMRegImpl::stack_slot_size;\n+  int stack_bytes = preserved_bytes + arg_shuffle.out_arg_bytes();\n+  int out_arg_area = align_up(stack_bytes , StackAlignmentInBytes);\n@@ -278,1 +279,1 @@\n-  arg_shuffle.generate(_masm, shuffle_reg->as_VMReg(), abi._shadow_space_bytes, 0);\n+  arg_shuffle.generate(_masm, shuffle_reg, abi._shadow_space_bytes, 0);\n@@ -296,1 +297,1 @@\n-      VMReg j_expected_result_reg;\n+      VMStorage j_expected_result_reg;\n@@ -304,1 +305,1 @@\n-        j_expected_result_reg = rax->as_VMReg();\n+        j_expected_result_reg = VMS_RAX;\n@@ -308,1 +309,1 @@\n-          j_expected_result_reg = xmm0->as_VMReg();\n+          j_expected_result_reg = VMS_XMM0;\n@@ -315,2 +316,1 @@\n-      assert(call_regs._ret_regs.at(0) == j_expected_result_reg,\n-        \"unexpected result register: %s != %s\", call_regs._ret_regs.at(0)->name(), j_expected_result_reg->name());\n+      assert(call_regs._ret_regs.at(0) == j_expected_result_reg, \"unexpected result register\");\n@@ -324,3 +324,3 @@\n-      VMReg reg = call_regs._ret_regs.at(i);\n-      if (reg->is_Register()) {\n-        __ movptr(reg->as_Register(), Address(rscratch1, offset));\n+      VMStorage reg = call_regs._ret_regs.at(i);\n+      if (reg.type() == RegType::INTEGER) {\n+        __ movptr(as_Register(reg), Address(rscratch1, offset));\n@@ -328,2 +328,2 @@\n-      } else if (reg->is_XMMRegister()) {\n-        __ movdqu(reg->as_XMMRegister(), Address(rscratch1, offset));\n+      } else if (reg.type() == RegType::VECTOR) {\n+        __ movdqu(as_XMMRegister(reg), Address(rscratch1, offset));\n","filename":"src\/hotspot\/cpu\/x86\/upcallLinker_x86_64.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGE_X86\n+#define SHARE_PRIMS_VMSTORAGE_X86\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+#include \"code\/vmreg.inline.hpp\"\n+#include \"prims\/vmstorageBase.inline.hpp\"\n+\n+\/\/ keep in sync with jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture\n+enum class RegType : int8_t {\n+  INTEGER = 0,\n+  VECTOR = 1,\n+  X87 = 2,\n+  STACK = 3,\n+  INVALID = -1\n+};\n+\n+\/\/ need to define this before constructing VMStorage (below)\n+constexpr inline RegType VMStorage::stack_type() {\n+  return RegType::STACK;\n+}\n+\n+constexpr uint16_t REG64_MASK = 0b0000000000001111;\n+constexpr uint16_t XMM_MASK   = 0b0000000000000001;\n+\n+constexpr VMStorage VMS_RAX = VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, 0);\n+constexpr VMStorage VMS_RBX = VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, 3);\n+constexpr VMStorage VMS_XMM0 = VMStorage::reg_storage(RegType::VECTOR, XMM_MASK, 0);\n+\n+inline Register as_Register(VMStorage vms) {\n+  assert(vms.type() == RegType::INTEGER, \"not the right type\");\n+  return ::as_Register(vms.index());\n+}\n+\n+inline XMMRegister as_XMMRegister(VMStorage vms) {\n+  assert(vms.type() == RegType::VECTOR, \"not the right type\");\n+  return ::as_XMMRegister(vms.index());\n+}\n+\n+inline VMReg as_VMReg(VMStorage vms) {\n+  switch (vms.type()) {\n+    case RegType::INTEGER: return as_Register(vms)->as_VMReg();\n+    case RegType::VECTOR:  return as_XMMRegister(vms)->as_VMReg();\n+    case RegType::STACK: {\n+      assert((vms.index() % VMRegImpl::stack_slot_size) == 0, \"can not represent as VMReg\");\n+      return VMRegImpl::stack2reg(vms.index() \/ VMRegImpl::stack_slot_size);\n+    }\n+    default: ShouldNotReachHere(); return VMRegImpl::Bad();\n+  }\n+}\n+\n+inline VMStorage as_VMStorage(Register reg) {\n+  return VMStorage::reg_storage(RegType::INTEGER, REG64_MASK, reg->encoding());\n+}\n+\n+inline VMStorage as_VMStorage(XMMRegister reg) {\n+  return VMStorage::reg_storage(RegType::VECTOR, XMM_MASK, reg->encoding());\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  if (reg->is_Register()) {\n+    return as_VMStorage(reg->as_Register());\n+  } else if (reg->is_XMMRegister()) {\n+    return as_VMStorage(reg->as_XMMRegister());\n+  } else if (reg->is_stack()) {\n+    return VMStorage::stack_storage(reg);\n+  } else if (!reg->is_valid()) {\n+    return VMStorage::invalid();\n+  }\n+\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_X86\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/x86\/vmstorage_x86.inline.hpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -31,2 +31,2 @@\n-                                                const GrowableArray<VMReg>& input_registers,\n-                                                const GrowableArray<VMReg>& output_registers,\n+                                                const GrowableArray<VMStorage>& input_registers,\n+                                                const GrowableArray<VMStorage>& output_registers,\n","filename":"src\/hotspot\/cpu\/zero\/downcallLinker_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,6 +36,1 @@\n-VMReg ForeignGlobals::vmstorage_to_vmreg(int type, int index) {\n-  Unimplemented();\n-  return VMRegImpl::Bad();\n-}\n-\n-int RegSpiller::pd_reg_size(VMReg reg) {\n+int RegSpiller::pd_reg_size(VMStorage reg) {\n@@ -46,1 +41,1 @@\n-void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -50,1 +45,1 @@\n-void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMReg reg) {\n+void RegSpiller::pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg) {\n@@ -54,1 +49,1 @@\n-void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+void ArgumentShuffle::pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n","filename":"src\/hotspot\/cpu\/zero\/foreignGlobals_zero.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGE_ZERO\n+#define SHARE_PRIMS_VMSTORAGE_ZERO\n+\n+#include <cstdint>\n+\n+#include \"asm\/register.hpp\"\n+#include \"prims\/vmstorageBase.inline.hpp\"\n+\n+enum class RegType : int8_t {\n+  STACK = 0\n+};\n+\n+constexpr inline RegType VMStorage::stack_type() {\n+  return RegType::STACK;\n+}\n+\n+inline VMStorage as_VMStorage(VMReg reg) {\n+  ShouldNotReachHere();\n+  return VMStorage::invalid();\n+}\n+\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE_ZERO\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/zero\/vmstorage_zero.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -4292,1 +4292,2 @@\n-int jdk_internal_foreign_abi_VMStorage::_index_offset;\n+int jdk_internal_foreign_abi_VMStorage::_indexOrOffset_offset;\n+int jdk_internal_foreign_abi_VMStorage::_segmentMaskOrSize_offset;\n@@ -4296,3 +4297,4 @@\n-  macro(_type_offset,      k, \"type\",      int_signature, false); \\\n-  macro(_index_offset,     k, \"index\",     int_signature, false); \\\n-  macro(_debugName_offset, k, \"debugName\", string_signature, false); \\\n+  macro(_type_offset,              k, \"type\",              byte_signature, false); \\\n+  macro(_indexOrOffset_offset,     k, \"indexOrOffset\",     int_signature, false); \\\n+  macro(_segmentMaskOrSize_offset, k, \"segmentMaskOrSize\", short_signature, false); \\\n+  macro(_debugName_offset,         k, \"debugName\",         string_signature, false); \\\n@@ -4315,2 +4317,2 @@\n-jint jdk_internal_foreign_abi_VMStorage::type(oop entry) {\n-  return entry->int_field(_type_offset);\n+jbyte jdk_internal_foreign_abi_VMStorage::type(oop entry) {\n+  return entry->byte_field(_type_offset);\n@@ -4319,2 +4321,6 @@\n-jint jdk_internal_foreign_abi_VMStorage::index(oop entry) {\n-  return entry->int_field(_index_offset);\n+jint jdk_internal_foreign_abi_VMStorage::index_or_offset(oop entry) {\n+  return entry->int_field(_indexOrOffset_offset);\n+}\n+\n+jshort jdk_internal_foreign_abi_VMStorage::segment_mask_or_size(oop entry) {\n+  return entry->short_field(_segmentMaskOrSize_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1176,1 +1176,2 @@\n-  static int _index_offset;\n+  static int _indexOrOffset_offset;\n+  static int _segmentMaskOrSize_offset;\n@@ -1185,3 +1186,4 @@\n-  static jint        type(oop entry);\n-  static jint        index(oop entry);\n-  static oop         debugName(oop entry);\n+  static jbyte  type(oop entry);\n+  static jint   index_or_offset(oop entry);\n+  static jshort segment_mask_or_size(oop entry);\n+  static oop    debugName(oop entry);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  int        _frame_size;                        \/\/ size of stack frame\n+  int        _frame_size;                        \/\/ size of stack frame in words (NOT slots. On x64 these are 64bit words)\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-                                         const GrowableArray<VMReg>& input_registers,\n-                                         const GrowableArray<VMReg>& output_registers,\n+                                         const GrowableArray<VMStorage>& input_registers,\n+                                         const GrowableArray<VMStorage>& output_registers,\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -52,4 +53,11 @@\n-VMReg ForeignGlobals::parse_vmstorage(oop storage) {\n-  jint index = jdk_internal_foreign_abi_VMStorage::index(storage);\n-  jint type = jdk_internal_foreign_abi_VMStorage::type(storage);\n-  return vmstorage_to_vmreg(type, index);\n+VMStorage ForeignGlobals::parse_vmstorage(oop storage) {\n+  jbyte type = jdk_internal_foreign_abi_VMStorage::type(storage);\n+  jshort segment_mask_or_size = jdk_internal_foreign_abi_VMStorage::segment_mask_or_size(storage);\n+  jint index_or_offset = jdk_internal_foreign_abi_VMStorage::index_or_offset(storage);\n+\n+  RegType rType = static_cast<RegType>(type);\n+  if (rType == VMStorage::stack_type()) {\n+    return VMStorage::stack_storage(segment_mask_or_size, index_or_offset);\n+  } else {\n+    return VMStorage::reg_storage(rType, segment_mask_or_size, index_or_offset);\n+  }\n@@ -58,1 +66,1 @@\n-int RegSpiller::compute_spill_area(const GrowableArray<VMReg>& regs) {\n+int RegSpiller::compute_spill_area(const GrowableArray<VMStorage>& regs) {\n@@ -70,1 +78,1 @@\n-    VMReg reg = _regs.at(i);\n+    VMStorage reg = _regs.at(i);\n@@ -84,13 +92,9 @@\n-    BasicType arg_bt     = move.bt;\n-    VMRegPair from_vmreg = move.from;\n-    VMRegPair to_vmreg   = move.to;\n-\n-    os->print(\"Move a %s from (\", null_safe_string(type2name(arg_bt)));\n-    from_vmreg.first()->print_on(os);\n-    os->print(\",\");\n-    from_vmreg.second()->print_on(os);\n-    os->print(\") to (\");\n-    to_vmreg.first()->print_on(os);\n-    os->print(\",\");\n-    to_vmreg.second()->print_on(os);\n-    os->print_cr(\")\");\n+    BasicType arg_bt   = move.bt;\n+    VMStorage from_reg = move.from;\n+    VMStorage to_reg   = move.to;\n+\n+    os->print(\"Move a %s from \", null_safe_string(type2name(arg_bt)));\n+    from_reg.print_on(os);\n+    os->print(\" to \");\n+    to_reg.print_on(os);\n+    os->print_cr(\"\");\n@@ -98,1 +102,1 @@\n-  os->print_cr(\"Stack argument slots: %d\", _out_arg_stack_slots);\n+  os->print_cr(\"Stack argument bytes: %d\", _out_arg_bytes);\n@@ -102,1 +106,1 @@\n-int NativeCallingConvention::calling_convention(BasicType* sig_bt, VMRegPair* out_regs, int num_args) const {\n+int NativeCallingConvention::calling_convention(const BasicType* sig_bt, VMStorage* out_regs, int num_args) const {\n@@ -104,1 +108,1 @@\n-  int stk_slots = 0;\n+  uint32_t max_stack_offset = 0;\n@@ -113,5 +117,4 @@\n-        assert(src_pos < _input_regs.length(), \"oob\");\n-        VMReg reg = _input_regs.at(src_pos++);\n-        out_regs[i].set1(reg);\n-        if (reg->is_stack())\n-          stk_slots += 2;\n+        VMStorage reg = _input_regs.at(src_pos++);\n+        out_regs[i] = reg;\n+        if (reg.is_stack())\n+          max_stack_offset = MAX2(max_stack_offset, reg.offset() + reg.stack_size());\n@@ -123,5 +126,4 @@\n-        assert(src_pos < _input_regs.length(), \"oob\");\n-        VMReg reg = _input_regs.at(src_pos++);\n-        out_regs[i].set2(reg);\n-        if (reg->is_stack())\n-          stk_slots += 2;\n+        VMStorage reg = _input_regs.at(src_pos++);\n+        out_regs[i] = reg;\n+        if (reg.is_stack())\n+          max_stack_offset = MAX2(max_stack_offset, reg.offset() + reg.stack_size());\n@@ -132,1 +134,1 @@\n-        out_regs[i].set_bad();\n+        out_regs[i] = VMStorage::invalid();\n@@ -139,1 +141,14 @@\n-  return stk_slots;\n+  return align_up(max_stack_offset, 8);\n+}\n+\n+int JavaCallingConvention::calling_convention(const BasicType* sig_bt, VMStorage* regs, int num_args) const {\n+  VMRegPair* vm_regs = NEW_RESOURCE_ARRAY(VMRegPair, num_args);\n+  int slots = SharedRuntime::java_calling_convention(sig_bt, vm_regs, num_args);\n+  for (int i = 0; i < num_args; i++) {\n+    VMRegPair pair = vm_regs[i];\n+    \/\/ note, we ignore second here. Signature should consist of register-size values. So there should be\n+    \/\/ no need for multi-register pairs.\n+    \/\/assert(!pair.first()->is_valid() || pair.is_single_reg(), \"must be: %s\");\n+    regs[i] = as_VMStorage(pair.first());\n+  }\n+  return slots << LogBytesPerInt;\n@@ -146,9 +161,11 @@\n-    VMRegPair      _src;\n-    VMRegPair      _dst;\n-    bool           _processed;\n-    MoveOperation* _next;\n-    MoveOperation* _prev;\n-    BasicType      _bt;\n-\n-    static int get_id(VMRegPair r) {\n-      return r.first()->value();\n+    VMStorage        _src;\n+    VMStorage        _dst;\n+    bool             _processed;\n+    MoveOperation*  _next;\n+    MoveOperation*  _prev;\n+    BasicType       _bt;\n+\n+    static int get_id(VMStorage r) {\n+      assert((r.index_or_offset() & 0xFF000000) == 0, \"index or offset too large\");\n+      \/\/ assuming mask and size doesn't matter for now\n+      return ((int) r.type()) | (r.index_or_offset() << 8);\n@@ -158,2 +175,2 @@\n-    MoveOperation(VMRegPair src, VMRegPair dst, BasicType bt)\n-      : _src(src), _dst(dst), _processed(false), _next(NULL), _prev(NULL), _bt(bt) {}\n+    MoveOperation(VMStorage src, VMStorage dst, BasicType bt):\n+      _src(src), _dst(dst), _processed(false), _next(NULL), _prev(NULL), _bt(bt) {}\n@@ -169,1 +186,1 @@\n-    void break_cycle(VMRegPair temp_register) {\n+    void break_cycle(VMStorage temp_register) {\n@@ -203,1 +220,1 @@\n-  const VMRegPair* _in_regs;\n+  const VMStorage* _in_regs;\n@@ -205,1 +222,1 @@\n-  const VMRegPair* _out_regs;\n+  const VMStorage* _out_regs;\n@@ -207,1 +224,1 @@\n-  VMRegPair _tmp_vmreg;\n+  VMStorage _tmp_vmreg;\n@@ -211,2 +228,3 @@\n-  ComputeMoveOrder(int total_in_args, const VMRegPair* in_regs, int total_out_args, VMRegPair* out_regs,\n-                   const BasicType* in_sig_bt, VMRegPair tmp_vmreg) :\n+ public:\n+  ComputeMoveOrder(int total_in_args, const VMStorage* in_regs, int total_out_args, VMStorage* out_regs,\n+                   const BasicType* in_sig_bt, VMStorage tmp_vmreg) :\n@@ -235,2 +253,2 @@\n-      VMRegPair in_reg = _in_regs[in_idx];\n-      VMRegPair out_reg = _out_regs[out_idx];\n+      VMStorage in_reg = _in_regs[in_idx];\n+      VMStorage out_reg = _out_regs[out_idx];\n@@ -238,1 +256,1 @@\n-      if (out_reg.first()->is_stack()) {\n+      if (out_reg.is_stack()) {\n@@ -244,1 +262,1 @@\n-      } else if (in_reg.first() == out_reg.first()\n+      } else if (in_reg == out_reg\n@@ -262,1 +280,1 @@\n-  void compute_store_order(VMRegPair temp_register) {\n+  void compute_store_order(VMStorage temp_register) {\n@@ -264,0 +282,1 @@\n+    \/\/ FIXME should be a map\n@@ -307,3 +326,3 @@\n-  static GrowableArray<Move> compute_move_order(int total_in_args, const VMRegPair* in_regs,\n-                                                int total_out_args, VMRegPair* out_regs,\n-                                                const BasicType* in_sig_bt, VMRegPair tmp_vmreg) {\n+  static GrowableArray<Move> compute_move_order(int total_in_args, const VMStorage* in_regs,\n+                                                int total_out_args, VMStorage* out_regs,\n+                                                const BasicType* in_sig_bt, VMStorage tmp_vmreg) {\n@@ -323,1 +342,1 @@\n-    VMReg shuffle_temp) {\n+    VMStorage shuffle_temp) {\n@@ -325,1 +344,1 @@\n-  VMRegPair* in_regs = NEW_RESOURCE_ARRAY(VMRegPair, num_in_args);\n+  VMStorage* in_regs = NEW_RESOURCE_ARRAY(VMStorage, num_in_args);\n@@ -328,5 +347,2 @@\n-  VMRegPair* out_regs = NEW_RESOURCE_ARRAY(VMRegPair, num_out_args);\n-  _out_arg_stack_slots = output_conv->calling_convention(out_sig_bt, out_regs, num_out_args);\n-\n-  VMRegPair tmp_vmreg;\n-  tmp_vmreg.set2(shuffle_temp);\n+  VMStorage* out_regs = NEW_RESOURCE_ARRAY(VMStorage, num_out_args);\n+  _out_arg_bytes = output_conv->calling_convention(out_sig_bt, out_regs, num_out_args);\n@@ -334,6 +350,0 @@\n-  \/\/ Compute a valid move order, using tmp_vmreg to break any cycles.\n-  \/\/ Note that ComputeMoveOrder ignores the upper half of our VMRegPairs.\n-  \/\/ We are not moving Java values here, only register-sized values,\n-  \/\/ so we shouldn't have to worry about the upper half any ways.\n-  \/\/ This should work fine on 32-bit as well, since we would only be\n-  \/\/ moving 32-bit sized values (i.e. low-level MH shouldn't take any double\/long).\n@@ -342,1 +352,1 @@\n-                                                in_sig_bt, tmp_vmreg);\n+                                                in_sig_bt, shuffle_temp);\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.cpp","additions":83,"deletions":73,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"prims\/vmstorage.inline.hpp\"\n@@ -37,1 +38,1 @@\n-  virtual int calling_convention(BasicType* sig_bt, VMRegPair* regs, int num_args) const = 0;\n+  virtual int calling_convention(const BasicType* sig_bt, VMStorage* regs, int num_args) const = 0;\n@@ -41,2 +42,2 @@\n-  GrowableArray<VMReg> _arg_regs;\n-  GrowableArray<VMReg> _ret_regs;\n+  GrowableArray<VMStorage> _arg_regs;\n+  GrowableArray<VMStorage> _ret_regs;\n@@ -48,0 +49,1 @@\n+\n@@ -50,2 +52,2 @@\n-  template<typename T, typename Func>\n-  static void parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter);\n+  template<typename T>\n+  static void parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, T (*converter)(int));\n@@ -56,2 +58,1 @@\n-  static VMReg vmstorage_to_vmreg(int type, int index);\n-  static VMReg parse_vmstorage(oop storage);\n+  static VMStorage parse_vmstorage(oop storage);\n@@ -60,2 +61,0 @@\n-\n-\n@@ -64,3 +63,1 @@\n-  int calling_convention(BasicType* sig_bt, VMRegPair* regs, int num_args) const override {\n-    return SharedRuntime::java_calling_convention(sig_bt, regs, num_args);\n-  }\n+  int calling_convention(const BasicType* sig_bt, VMStorage* regs, int num_args) const override;\n@@ -70,1 +67,1 @@\n-  GrowableArray<VMReg> _input_regs;\n+  GrowableArray<VMStorage> _input_regs;\n@@ -72,1 +69,1 @@\n-  NativeCallingConvention(const GrowableArray<VMReg>& input_regs)\n+  NativeCallingConvention(const GrowableArray<VMStorage>& input_regs)\n@@ -75,1 +72,1 @@\n-  int calling_convention(BasicType* sig_bt, VMRegPair* out_regs, int num_args) const override;\n+  int calling_convention(const BasicType* sig_bt, VMStorage* out_regs, int num_args) const override;\n@@ -79,1 +76,1 @@\n-  GrowableArray<VMReg> _regs;\n+  GrowableArray<VMStorage> _regs;\n@@ -82,1 +79,1 @@\n-  RegSpiller(const GrowableArray<VMReg>& regs) : _regs(regs), _spill_size_bytes(compute_spill_area(regs)) {\n+  RegSpiller(const GrowableArray<VMStorage>& regs) : _regs(regs), _spill_size_bytes(compute_spill_area(regs)) {\n@@ -90,1 +87,1 @@\n-  static int compute_spill_area(const GrowableArray<VMReg>& regs);\n+  static int compute_spill_area(const GrowableArray<VMStorage>& regs);\n@@ -93,3 +90,3 @@\n-  static int pd_reg_size(VMReg reg);\n-  static void pd_store_reg(MacroAssembler* masm, int offset, VMReg reg);\n-  static void pd_load_reg(MacroAssembler* masm, int offset, VMReg reg);\n+  static int pd_reg_size(VMStorage reg);\n+  static void pd_store_reg(MacroAssembler* masm, int offset, VMStorage reg);\n+  static void pd_load_reg(MacroAssembler* masm, int offset, VMStorage reg);\n@@ -100,2 +97,2 @@\n-  VMRegPair from;\n-  VMRegPair to;\n+  VMStorage from;\n+  VMStorage to;\n@@ -107,1 +104,1 @@\n-  int _out_arg_stack_slots;\n+  int _out_arg_bytes;\n@@ -113,1 +110,1 @@\n-    VMReg shuffle_temp);\n+    VMStorage shuffle_temp);\n@@ -115,2 +112,2 @@\n-  int out_arg_stack_slots() const { return _out_arg_stack_slots; }\n-  void generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const {\n+  int out_arg_bytes() const { return _out_arg_bytes; }\n+  void generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const {\n@@ -122,1 +119,1 @@\n-  void pd_generate(MacroAssembler* masm, VMReg tmp, int in_stk_bias, int out_stk_bias) const;\n+  void pd_generate(MacroAssembler* masm, VMStorage tmp, int in_stk_bias, int out_stk_bias) const;\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.hpp","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-template<typename T, typename Func>\n-void ForeignGlobals::parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, Func converter) {\n+template<typename T>\n+void ForeignGlobals::parse_register_array(objArrayOop jarray, int type_index, GrowableArray<T>& array, T (*converter)(int)) {\n@@ -40,1 +40,1 @@\n-    jint index = jdk_internal_foreign_abi_VMStorage::index(storage);\n+    jint index = jdk_internal_foreign_abi_VMStorage::index_or_offset(storage);\n","filename":"src\/hotspot\/share\/prims\/foreignGlobals.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  GrowableArray<VMReg> input_regs(pcount);\n+  GrowableArray<VMStorage> input_regs(pcount);\n@@ -68,1 +68,1 @@\n-  GrowableArray<VMReg> output_regs(outs);\n+  GrowableArray<VMStorage> output_regs(outs);\n","filename":"src\/hotspot\/share\/prims\/nativeEntryPoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"prims\/vmstorage.inline.hpp\"\n+\n+void VMStorage::print_on(outputStream* os) const {\n+  os->print(\"{type=%d, index=%d, %s=%d}\", static_cast<int8_t>(_type), _index_or_offset,\n+    is_stack() ? \"size\" : \"segment_mask\", _segment_mask_or_size);\n+}\n","filename":"src\/hotspot\/share\/prims\/vmstorage.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGE\n+#define SHARE_PRIMS_VMSTORAGE\n+\n+#include \"utilities\/macros.hpp\"\n+\n+#include CPU_HEADER_INLINE(vmstorage)\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGE\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/prims\/vmstorage.inline.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_PRIMS_VMSTORAGEBASE\n+#define SHARE_PRIMS_VMSTORAGEBASE\n+\n+\/\/ DO NOT INCLUDE THIS FILE. INCLUDE vmstorage.inline.hpp INSTEAD\n+\n+#include <cstdint>\n+\n+#include \"code\/vmreg.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+enum class RegType : int8_t; \/\/ defined in arch specific headers\n+\n+class VMStorage {\n+public:\n+  constexpr static RegType INVALID_TYPE = static_cast<RegType>(-1);\n+private:\n+  RegType _type;\n+  \/\/ 1 byte of padding\n+  uint16_t _segment_mask_or_size;\n+  uint32_t _index_or_offset; \/\/ stack offset in bytes for stack storage\n+\n+  friend bool operator==(const VMStorage& a, const VMStorage& b);\n+  constexpr VMStorage(RegType type, uint16_t segment_mask_or_size, uint32_t index_or_offset)\n+    : _type(type), _segment_mask_or_size(segment_mask_or_size), _index_or_offset(index_or_offset) {};\n+public:\n+  constexpr VMStorage() : _type(INVALID_TYPE), _segment_mask_or_size(0), _index_or_offset(0) {};\n+\n+  constexpr static VMStorage reg_storage(RegType type, uint16_t segment_mask, uint32_t index) {\n+    assert(type != stack_type(), \"can not be stack type\");\n+    assert(type != INVALID_TYPE, \"can not be invalid type\");\n+    VMStorage result(type, segment_mask, index);\n+    return result;\n+  }\n+\n+  constexpr static VMStorage stack_storage(uint16_t size, uint32_t offset) {\n+    VMStorage result(stack_type(), size, offset);\n+    return result;\n+  }\n+\n+  static VMStorage stack_storage(VMReg reg) {\n+    return stack_storage(BytesPerWord, checked_cast<uint16_t>(reg->reg2stack() * VMRegImpl::stack_slot_size));\n+  }\n+\n+  constexpr static VMStorage invalid() {\n+    VMStorage result;\n+    result._type = INVALID_TYPE;\n+    return result;\n+  }\n+\n+  constexpr inline static RegType stack_type();\n+\n+  RegType type()              const { return _type; }\n+  \/\/ type specific accessors to make calling code more readable\n+  uint16_t segment_mask()     const { assert(is_reg(), \"must be reg\");     return _segment_mask_or_size; }\n+  uint16_t stack_size()       const { assert(is_stack(), \"must be stack\"); return _segment_mask_or_size; }\n+  uint32_t index()            const { assert(is_reg(), \"must be reg\");     return _index_or_offset; }\n+  uint32_t offset()           const { assert(is_stack(), \"must be stack\"); return _index_or_offset; }\n+  uint32_t index_or_offset()  const { assert(is_valid(), \"must be valid\"); return _index_or_offset; }\n+\n+  bool is_valid() const { return _type != INVALID_TYPE; }\n+  bool is_reg() const { return is_valid() && !is_stack(); }\n+  bool is_stack() const { return _type == stack_type(); }\n+\n+  void print_on(outputStream* os) const;\n+};\n+\n+inline bool operator==(const VMStorage& a, const VMStorage& b) {\n+  return a._type == b._type\n+    && a._index_or_offset == b._index_or_offset\n+    && a._segment_mask_or_size == b._segment_mask_or_size;\n+}\n+\n+#endif \/\/ SHARE_PRIMS_VMSTORAGEBASE\n","filename":"src\/hotspot\/share\/prims\/vmstorageBase.inline.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-    int stackType();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/Architecture.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,2 +30,17 @@\n-    private final int type;\n-    private final int index;\n+    \/**\n+     * Type of storage. e.g. stack, or which register type (GP, FP, vector)\n+     *\/\n+    private final byte type;\n+\n+    \/**\n+     * The (on stack) size in bytes when type = stack, a register mask otherwise.\n+     * The register mask indicates which segments of a register are used.\n+     *\/\n+    private final short segmentMaskOrSize;\n+\n+    \/**\n+     * The index is either a register number within a type, or\n+     * a stack offset in bytes if type = stack.\n+     * (a particular platform might add a bias to this in generate code)\n+     *\/\n+    private final int indexOrOffset;\n@@ -35,1 +50,1 @@\n-    public VMStorage(int type, int index, String debugName) {\n+    private VMStorage(byte type, short segmentMaskOrSize, int indexOrOffset, String debugName) {\n@@ -37,1 +52,2 @@\n-        this.index = index;\n+        this.segmentMaskOrSize = segmentMaskOrSize;\n+        this.indexOrOffset = indexOrOffset;\n@@ -41,1 +57,9 @@\n-    public int type() {\n+    public static VMStorage stackStorage(byte type, short size, int byteOffset) {\n+        return new VMStorage(type, size, byteOffset, \"Stack@\" + byteOffset);\n+    }\n+\n+    public static VMStorage regStorage(byte type, short segmentMask, int index, String debugName) {\n+        return new VMStorage(type, segmentMask, index, debugName);\n+    }\n+\n+    public byte type() {\n@@ -45,2 +69,6 @@\n-    public int index() {\n-        return index;\n+    public short segmentMaskOrSize() {\n+        return segmentMaskOrSize;\n+    }\n+\n+    public int indexOrOffset() {\n+        return indexOrOffset;\n@@ -56,4 +84,5 @@\n-        if (o == null || getClass() != o.getClass()) return false;\n-        VMStorage vmStorage = (VMStorage) o;\n-        return type == vmStorage.type &&\n-                index == vmStorage.index;\n+        return (o instanceof VMStorage vmStorage)\n+            && type == vmStorage.type\n+            && segmentMaskOrSize == vmStorage.segmentMaskOrSize\n+            && indexOrOffset == vmStorage.indexOrOffset\n+            && Objects.equals(debugName, vmStorage.debugName);\n@@ -64,1 +93,1 @@\n-        return Objects.hash(type, index);\n+        return Objects.hash(type, segmentMaskOrSize, indexOrOffset, debugName);\n@@ -71,1 +100,2 @@\n-                \", index=\" + index +\n+                \", segmentMaskOrSize=\" + segmentMaskOrSize +\n+                \", indexOrOffset=\" + indexOrOffset +\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/VMStorage.java","additions":43,"deletions":13,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+    private static final short REG64_MASK = 0b0000_0000_0000_0001;\n+    private static final short V128_MASK = 0b0000_0000_0000_0001;\n+\n@@ -37,1 +40,0 @@\n-    private static final int STACK_SLOT_SIZE = 8;\n@@ -49,1 +51,1 @@\n-            case StorageClasses.STACK: return STACK_SLOT_SIZE;\n+            \/\/ STACK is deliberately omitted\n@@ -55,5 +57,0 @@\n-    @Override\n-    public int stackType() {\n-        return StorageClasses.STACK;\n-    }\n-\n@@ -61,3 +58,3 @@\n-        int INTEGER = 0;\n-        int VECTOR = 1;\n-        int STACK = 3;\n+        byte INTEGER = 0;\n+        byte VECTOR = 1;\n+        byte STACK = 2;\n@@ -66,32 +63,33 @@\n-    public static final VMStorage r0  = integerRegister(0);\n-    public static final VMStorage r1  = integerRegister(1);\n-    public static final VMStorage r2  = integerRegister(2);\n-    public static final VMStorage r3  = integerRegister(3);\n-    public static final VMStorage r4  = integerRegister(4);\n-    public static final VMStorage r5  = integerRegister(5);\n-    public static final VMStorage r6  = integerRegister(6);\n-    public static final VMStorage r7  = integerRegister(7);\n-    public static final VMStorage r8  = integerRegister(8);\n-    public static final VMStorage r9  = integerRegister(9);\n-    public static final VMStorage r10 = integerRegister(10);\n-    public static final VMStorage r11 = integerRegister(11);\n-    public static final VMStorage r12 = integerRegister(12);\n-    public static final VMStorage r13 = integerRegister(13);\n-    public static final VMStorage r14 = integerRegister(14);\n-    public static final VMStorage r15 = integerRegister(15);\n-    public static final VMStorage r16 = integerRegister(16);\n-    public static final VMStorage r17 = integerRegister(17);\n-    public static final VMStorage r18 = integerRegister(18);\n-    public static final VMStorage r19 = integerRegister(19);\n-    public static final VMStorage r20 = integerRegister(20);\n-    public static final VMStorage r21 = integerRegister(21);\n-    public static final VMStorage r22 = integerRegister(22);\n-    public static final VMStorage r23 = integerRegister(23);\n-    public static final VMStorage r24 = integerRegister(24);\n-    public static final VMStorage r25 = integerRegister(25);\n-    public static final VMStorage r26 = integerRegister(26);\n-    public static final VMStorage r27 = integerRegister(27);\n-    public static final VMStorage r28 = integerRegister(28);\n-    public static final VMStorage r29 = integerRegister(29);\n-    public static final VMStorage r30 = integerRegister(30);\n-    public static final VMStorage r31 = integerRegister(31);\n+    public static class Regs { \/\/ break circular dependency\n+        public static final VMStorage r0 = integerRegister(0);\n+        public static final VMStorage r1 = integerRegister(1);\n+        public static final VMStorage r2 = integerRegister(2);\n+        public static final VMStorage r3 = integerRegister(3);\n+        public static final VMStorage r4 = integerRegister(4);\n+        public static final VMStorage r5 = integerRegister(5);\n+        public static final VMStorage r6 = integerRegister(6);\n+        public static final VMStorage r7 = integerRegister(7);\n+        public static final VMStorage r8 = integerRegister(8);\n+        public static final VMStorage r9 = integerRegister(9);\n+        public static final VMStorage r10 = integerRegister(10);\n+        public static final VMStorage r11 = integerRegister(11);\n+        public static final VMStorage r12 = integerRegister(12);\n+        public static final VMStorage r13 = integerRegister(13);\n+        public static final VMStorage r14 = integerRegister(14);\n+        public static final VMStorage r15 = integerRegister(15);\n+        public static final VMStorage r16 = integerRegister(16);\n+        public static final VMStorage r17 = integerRegister(17);\n+        public static final VMStorage r18 = integerRegister(18);\n+        public static final VMStorage r19 = integerRegister(19);\n+        public static final VMStorage r20 = integerRegister(20);\n+        public static final VMStorage r21 = integerRegister(21);\n+        public static final VMStorage r22 = integerRegister(22);\n+        public static final VMStorage r23 = integerRegister(23);\n+        public static final VMStorage r24 = integerRegister(24);\n+        public static final VMStorage r25 = integerRegister(25);\n+        public static final VMStorage r26 = integerRegister(26);\n+        public static final VMStorage r27 = integerRegister(27);\n+        public static final VMStorage r28 = integerRegister(28);\n+        public static final VMStorage r29 = integerRegister(29);\n+        public static final VMStorage r30 = integerRegister(30);\n+        public static final VMStorage r31 = integerRegister(31);\n@@ -99,32 +97,33 @@\n-    public static final VMStorage v0  = vectorRegister(0);\n-    public static final VMStorage v1  = vectorRegister(1);\n-    public static final VMStorage v2  = vectorRegister(2);\n-    public static final VMStorage v3  = vectorRegister(3);\n-    public static final VMStorage v4  = vectorRegister(4);\n-    public static final VMStorage v5  = vectorRegister(5);\n-    public static final VMStorage v6  = vectorRegister(6);\n-    public static final VMStorage v7  = vectorRegister(7);\n-    public static final VMStorage v8  = vectorRegister(8);\n-    public static final VMStorage v9  = vectorRegister(9);\n-    public static final VMStorage v10 = vectorRegister(10);\n-    public static final VMStorage v11 = vectorRegister(11);\n-    public static final VMStorage v12 = vectorRegister(12);\n-    public static final VMStorage v13 = vectorRegister(13);\n-    public static final VMStorage v14 = vectorRegister(14);\n-    public static final VMStorage v15 = vectorRegister(15);\n-    public static final VMStorage v16 = vectorRegister(16);\n-    public static final VMStorage v17 = vectorRegister(17);\n-    public static final VMStorage v18 = vectorRegister(18);\n-    public static final VMStorage v19 = vectorRegister(19);\n-    public static final VMStorage v20 = vectorRegister(20);\n-    public static final VMStorage v21 = vectorRegister(21);\n-    public static final VMStorage v22 = vectorRegister(22);\n-    public static final VMStorage v23 = vectorRegister(23);\n-    public static final VMStorage v24 = vectorRegister(24);\n-    public static final VMStorage v25 = vectorRegister(25);\n-    public static final VMStorage v26 = vectorRegister(26);\n-    public static final VMStorage v27 = vectorRegister(27);\n-    public static final VMStorage v28 = vectorRegister(28);\n-    public static final VMStorage v29 = vectorRegister(29);\n-    public static final VMStorage v30 = vectorRegister(30);\n-    public static final VMStorage v31 = vectorRegister(31);\n+        public static final VMStorage v0 = vectorRegister(0);\n+        public static final VMStorage v1 = vectorRegister(1);\n+        public static final VMStorage v2 = vectorRegister(2);\n+        public static final VMStorage v3 = vectorRegister(3);\n+        public static final VMStorage v4 = vectorRegister(4);\n+        public static final VMStorage v5 = vectorRegister(5);\n+        public static final VMStorage v6 = vectorRegister(6);\n+        public static final VMStorage v7 = vectorRegister(7);\n+        public static final VMStorage v8 = vectorRegister(8);\n+        public static final VMStorage v9 = vectorRegister(9);\n+        public static final VMStorage v10 = vectorRegister(10);\n+        public static final VMStorage v11 = vectorRegister(11);\n+        public static final VMStorage v12 = vectorRegister(12);\n+        public static final VMStorage v13 = vectorRegister(13);\n+        public static final VMStorage v14 = vectorRegister(14);\n+        public static final VMStorage v15 = vectorRegister(15);\n+        public static final VMStorage v16 = vectorRegister(16);\n+        public static final VMStorage v17 = vectorRegister(17);\n+        public static final VMStorage v18 = vectorRegister(18);\n+        public static final VMStorage v19 = vectorRegister(19);\n+        public static final VMStorage v20 = vectorRegister(20);\n+        public static final VMStorage v21 = vectorRegister(21);\n+        public static final VMStorage v22 = vectorRegister(22);\n+        public static final VMStorage v23 = vectorRegister(23);\n+        public static final VMStorage v24 = vectorRegister(24);\n+        public static final VMStorage v25 = vectorRegister(25);\n+        public static final VMStorage v26 = vectorRegister(26);\n+        public static final VMStorage v27 = vectorRegister(27);\n+        public static final VMStorage v28 = vectorRegister(28);\n+        public static final VMStorage v29 = vectorRegister(29);\n+        public static final VMStorage v30 = vectorRegister(30);\n+        public static final VMStorage v31 = vectorRegister(31);\n+    }\n@@ -133,1 +132,1 @@\n-        return new VMStorage(StorageClasses.INTEGER, index, \"r\" + index);\n+        return VMStorage.regStorage(StorageClasses.INTEGER, REG64_MASK, index, \"r\" + index);\n@@ -137,1 +136,1 @@\n-        return new VMStorage(StorageClasses.VECTOR, index, \"v\" + index);\n+        return VMStorage.regStorage(StorageClasses.VECTOR, V128_MASK, index, \"v\" + index);\n@@ -140,2 +139,2 @@\n-    public static VMStorage stackStorage(int index) {\n-        return new VMStorage(StorageClasses.STACK, index, \"Stack@\" + index);\n+    public static VMStorage stackStorage(short size, int byteOffset) {\n+        return VMStorage.stackStorage(StorageClasses.STACK, size, byteOffset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Architecture.java","additions":77,"deletions":78,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n@@ -207,1 +208,2 @@\n-            stackOffset = alignedStackOffset;\n+            short encodedSize = (short) size;\n+            assert (encodedSize & 0xFFFF) == size;\n@@ -210,2 +212,2 @@\n-                stackStorage((int)(stackOffset \/ STACK_SLOT_SIZE));\n-            stackOffset += size;\n+                AArch64Architecture.stackStorage(encodedSize, (int)alignedStackOffset);\n+            stackOffset = alignedStackOffset + size;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.aarch64.AArch64Architecture;\n@@ -35,0 +36,11 @@\n+\n+    private static final short REG8_H_MASK = 0b0000_0000_0000_0010;\n+    private static final short REG8_L_MASK = 0b0000_0000_0000_0001;\n+    private static final short REG16_MASK = 0b0000_0000_0000_0011;\n+    private static final short REG32_MASK = 0b0000_0000_0000_0111;\n+    private static final short REG64_MASK = 0b0000_0000_0000_1111;\n+    private static final short XMM_MASK = 0b0000_0000_0000_0001;\n+    private static final short YMM_MASK = 0b0000_0000_0000_0011;\n+    private static final short ZMM_MASK = 0b0000_0000_0000_0111;\n+    private static final short STP_MASK = 0b0000_0000_0000_0001;\n+\n@@ -38,1 +50,0 @@\n-    private static final int STACK_SLOT_SIZE = 8;\n@@ -51,1 +62,1 @@\n-            case StorageClasses.STACK: return STACK_SLOT_SIZE;\n+            \/\/ STACK is deliberately omitted\n@@ -57,5 +68,0 @@\n-    @Override\n-    public int stackType() {\n-        return StorageClasses.STACK;\n-    }\n-\n@@ -63,4 +69,4 @@\n-        int INTEGER = 0;\n-        int VECTOR = 1;\n-        int X87 = 2;\n-        int STACK = 3;\n+        byte INTEGER = 0;\n+        byte VECTOR = 1;\n+        byte X87 = 2;\n+        byte STACK = 3;\n@@ -69,49 +75,51 @@\n-    public static final VMStorage rax = integerRegister(0, \"rax\");\n-    public static final VMStorage rcx = integerRegister(1, \"rcx\");\n-    public static final VMStorage rdx = integerRegister(2, \"rdx\");\n-    public static final VMStorage rbx = integerRegister(3, \"rbx\");\n-    public static final VMStorage rsp = integerRegister(4, \"rsp\");\n-    public static final VMStorage rbp = integerRegister(5, \"rbp\");\n-    public static final VMStorage rsi = integerRegister(6, \"rsi\");\n-    public static final VMStorage rdi = integerRegister(7, \"rdi\");\n-    public static final VMStorage r8 =  integerRegister(8, \"r8\");\n-    public static final VMStorage r9 =  integerRegister(9, \"r9\");\n-    public static final VMStorage r10 = integerRegister(10, \"r10\");\n-    public static final VMStorage r11 = integerRegister(11, \"r11\");\n-    public static final VMStorage r12 = integerRegister(12, \"r12\");\n-    public static final VMStorage r13 = integerRegister(13, \"r13\");\n-    public static final VMStorage r14 = integerRegister(14, \"r14\");\n-    public static final VMStorage r15 = integerRegister(15, \"r15\");\n-\n-    public static final VMStorage xmm0 =  vectorRegister(0, \"xmm0\");\n-    public static final VMStorage xmm1 =  vectorRegister(1, \"xmm1\");\n-    public static final VMStorage xmm2 =  vectorRegister(2, \"xmm2\");\n-    public static final VMStorage xmm3 =  vectorRegister(3, \"xmm3\");\n-    public static final VMStorage xmm4 =  vectorRegister(4, \"xmm4\");\n-    public static final VMStorage xmm5 =  vectorRegister(5, \"xmm5\");\n-    public static final VMStorage xmm6 =  vectorRegister(6, \"xmm6\");\n-    public static final VMStorage xmm7 =  vectorRegister(7, \"xmm7\");\n-    public static final VMStorage xmm8 =  vectorRegister(8, \"xmm8\");\n-    public static final VMStorage xmm9 =  vectorRegister(9, \"xmm9\");\n-    public static final VMStorage xmm10 = vectorRegister(10, \"xmm10\");\n-    public static final VMStorage xmm11 = vectorRegister(11, \"xmm11\");\n-    public static final VMStorage xmm12 = vectorRegister(12, \"xmm12\");\n-    public static final VMStorage xmm13 = vectorRegister(13, \"xmm13\");\n-    public static final VMStorage xmm14 = vectorRegister(14, \"xmm14\");\n-    public static final VMStorage xmm15 = vectorRegister(15, \"xmm15\");\n-    public static final VMStorage xmm16 = vectorRegister(16, \"xmm16\");\n-    public static final VMStorage xmm17 = vectorRegister(17, \"xmm17\");\n-    public static final VMStorage xmm18 = vectorRegister(18, \"xmm18\");\n-    public static final VMStorage xmm19 = vectorRegister(19, \"xmm19\");\n-    public static final VMStorage xmm20 = vectorRegister(20, \"xmm20\");\n-    public static final VMStorage xmm21 = vectorRegister(21, \"xmm21\");\n-    public static final VMStorage xmm22 = vectorRegister(22, \"xmm22\");\n-    public static final VMStorage xmm23 = vectorRegister(23, \"xmm23\");\n-    public static final VMStorage xmm24 = vectorRegister(24, \"xmm24\");\n-    public static final VMStorage xmm25 = vectorRegister(25, \"xmm25\");\n-    public static final VMStorage xmm26 = vectorRegister(26, \"xmm26\");\n-    public static final VMStorage xmm27 = vectorRegister(27, \"xmm27\");\n-    public static final VMStorage xmm28 = vectorRegister(28, \"xmm28\");\n-    public static final VMStorage xmm29 = vectorRegister(29, \"xmm29\");\n-    public static final VMStorage xmm30 = vectorRegister(30, \"xmm30\");\n-    public static final VMStorage xmm31 = vectorRegister(31, \"xmm31\");\n+    public static class Regs { \/\/ break circular dependency\n+        public static final VMStorage rax = integerRegister(0, \"rax\");\n+        public static final VMStorage rcx = integerRegister(1, \"rcx\");\n+        public static final VMStorage rdx = integerRegister(2, \"rdx\");\n+        public static final VMStorage rbx = integerRegister(3, \"rbx\");\n+        public static final VMStorage rsp = integerRegister(4, \"rsp\");\n+        public static final VMStorage rbp = integerRegister(5, \"rbp\");\n+        public static final VMStorage rsi = integerRegister(6, \"rsi\");\n+        public static final VMStorage rdi = integerRegister(7, \"rdi\");\n+        public static final VMStorage r8 = integerRegister(8, \"r8\");\n+        public static final VMStorage r9 = integerRegister(9, \"r9\");\n+        public static final VMStorage r10 = integerRegister(10, \"r10\");\n+        public static final VMStorage r11 = integerRegister(11, \"r11\");\n+        public static final VMStorage r12 = integerRegister(12, \"r12\");\n+        public static final VMStorage r13 = integerRegister(13, \"r13\");\n+        public static final VMStorage r14 = integerRegister(14, \"r14\");\n+        public static final VMStorage r15 = integerRegister(15, \"r15\");\n+\n+        public static final VMStorage xmm0 = vectorRegister(0, \"xmm0\");\n+        public static final VMStorage xmm1 = vectorRegister(1, \"xmm1\");\n+        public static final VMStorage xmm2 = vectorRegister(2, \"xmm2\");\n+        public static final VMStorage xmm3 = vectorRegister(3, \"xmm3\");\n+        public static final VMStorage xmm4 = vectorRegister(4, \"xmm4\");\n+        public static final VMStorage xmm5 = vectorRegister(5, \"xmm5\");\n+        public static final VMStorage xmm6 = vectorRegister(6, \"xmm6\");\n+        public static final VMStorage xmm7 = vectorRegister(7, \"xmm7\");\n+        public static final VMStorage xmm8 = vectorRegister(8, \"xmm8\");\n+        public static final VMStorage xmm9 = vectorRegister(9, \"xmm9\");\n+        public static final VMStorage xmm10 = vectorRegister(10, \"xmm10\");\n+        public static final VMStorage xmm11 = vectorRegister(11, \"xmm11\");\n+        public static final VMStorage xmm12 = vectorRegister(12, \"xmm12\");\n+        public static final VMStorage xmm13 = vectorRegister(13, \"xmm13\");\n+        public static final VMStorage xmm14 = vectorRegister(14, \"xmm14\");\n+        public static final VMStorage xmm15 = vectorRegister(15, \"xmm15\");\n+        public static final VMStorage xmm16 = vectorRegister(16, \"xmm16\");\n+        public static final VMStorage xmm17 = vectorRegister(17, \"xmm17\");\n+        public static final VMStorage xmm18 = vectorRegister(18, \"xmm18\");\n+        public static final VMStorage xmm19 = vectorRegister(19, \"xmm19\");\n+        public static final VMStorage xmm20 = vectorRegister(20, \"xmm20\");\n+        public static final VMStorage xmm21 = vectorRegister(21, \"xmm21\");\n+        public static final VMStorage xmm22 = vectorRegister(22, \"xmm22\");\n+        public static final VMStorage xmm23 = vectorRegister(23, \"xmm23\");\n+        public static final VMStorage xmm24 = vectorRegister(24, \"xmm24\");\n+        public static final VMStorage xmm25 = vectorRegister(25, \"xmm25\");\n+        public static final VMStorage xmm26 = vectorRegister(26, \"xmm26\");\n+        public static final VMStorage xmm27 = vectorRegister(27, \"xmm27\");\n+        public static final VMStorage xmm28 = vectorRegister(28, \"xmm28\");\n+        public static final VMStorage xmm29 = vectorRegister(29, \"xmm29\");\n+        public static final VMStorage xmm30 = vectorRegister(30, \"xmm30\");\n+        public static final VMStorage xmm31 = vectorRegister(31, \"xmm31\");\n+    }\n@@ -120,1 +128,1 @@\n-        return new VMStorage(StorageClasses.INTEGER, index, debugName);\n+        return VMStorage.regStorage(StorageClasses.INTEGER, REG64_MASK, index, debugName);\n@@ -124,1 +132,1 @@\n-        return new VMStorage(StorageClasses.VECTOR, index, debugName);\n+        return VMStorage.regStorage(StorageClasses.VECTOR, XMM_MASK, index, debugName);\n@@ -127,2 +135,2 @@\n-    public static VMStorage stackStorage(int index) {\n-        return new VMStorage(StorageClasses.STACK, index, \"Stack@\" + index);\n+    public static VMStorage stackStorage(short size, int byteOffset) {\n+        return VMStorage.stackStorage(StorageClasses.STACK, size, byteOffset);\n@@ -132,1 +140,1 @@\n-        return new VMStorage(StorageClasses.X87, index, \"X87(\" + index + \")\");\n+        return VMStorage.regStorage(StorageClasses.X87, STP_MASK, index, \"X87(\" + index + \")\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/X86_64Architecture.java","additions":73,"deletions":65,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.foreign.abi.x64.X86_64Architecture;\n@@ -52,0 +53,1 @@\n+import static jdk.internal.foreign.abi.x64.X86_64Architecture.Regs.*;\n@@ -60,3 +62,5 @@\n-    public static final int MAX_INTEGER_ARGUMENT_REGISTERS = 6;\n-    public static final int MAX_VECTOR_ARGUMENT_REGISTERS = 8;\n-    private static final ABIDescriptor CSysV = abiFor(\n+    private static final int STACK_SLOT_SIZE = 8;\n+    private static final int MAX_INTEGER_ARGUMENT_REGISTERS = 6;\n+    private static final int MAX_VECTOR_ARGUMENT_REGISTERS = 8;\n+\n+    private static final ABIDescriptor CSysV = X86_64Architecture.abiFor(\n@@ -170,2 +174,2 @@\n-            VMStorage storage = stackStorage((int)stackOffset);\n-            stackOffset++;\n+            VMStorage storage = X86_64Architecture.stackStorage((short) STACK_SLOT_SIZE, (int)stackOffset);\n+            stackOffset += STACK_SLOT_SIZE;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import static jdk.internal.foreign.abi.x64.X86_64Architecture.Regs.*;\n@@ -169,1 +170,1 @@\n-                VMStorage storage = X86_64Architecture.stackStorage((int) (stackOffset \/ STACK_SLOT_SIZE));\n+                VMStorage storage = X86_64Architecture.stackStorage((short) STACK_SLOT_SIZE, (int) stackOffset);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n@@ -56,0 +57,2 @@\n+    private static final short STACK_SLOT_SIZE = 8;\n+\n@@ -101,2 +104,2 @@\n-            { vmStore(stackStorage(0), int.class) },\n-            { vmStore(stackStorage(1), int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 8), int.class) },\n@@ -350,1 +353,1 @@\n-                vmStore(stackStorage(0), long.class),\n+                vmStore(stackStorage((short) 8, 0), long.class),\n@@ -352,1 +355,1 @@\n-                vmStore(stackStorage(1), int.class),\n+                vmStore(stackStorage((short) 4, 8), int.class),\n@@ -389,2 +392,2 @@\n-            { copy(struct), unboxAddress(), vmStore(stackStorage(0), long.class) },\n-            { vmStore(stackStorage(1), int.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage((short) 8, 0), long.class) },\n+            { vmStore(stackStorage((short) 4, 8), int.class) },\n@@ -435,2 +438,2 @@\n-            { vmStore(stackStorage(0), int.class) },\n-            { vmStore(stackStorage(1), float.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 8), float.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static jdk.internal.foreign.abi.x64.X86_64Architecture.Regs.*;\n@@ -57,0 +58,2 @@\n+    private static final short STACK_SLOT_SIZE = 8;\n+\n@@ -159,2 +162,2 @@\n-            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n-                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class)},\n+            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n+                    bufferLoad(8, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class)},\n@@ -189,2 +192,2 @@\n-            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n-                    bufferLoad(8, int.class), vmStore(stackStorage(1), int.class)},\n+            { dup(), bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n+                    bufferLoad(8, int.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class)},\n@@ -286,2 +289,2 @@\n-            { vmStore(stackStorage(0), long.class) },\n-            { vmStore(stackStorage(1), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class) },\n@@ -296,2 +299,2 @@\n-            { vmStore(stackStorage(2), float.class) },\n-            { vmStore(stackStorage(3), float.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 16), float.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 24), float.class) },\n@@ -349,2 +352,2 @@\n-            { vmStore(stackStorage(0), int.class) },\n-            { vmStore(stackStorage(1), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class) },\n@@ -427,1 +430,1 @@\n-                    bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                    bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n@@ -429,2 +432,2 @@\n-                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class),\n-                    bufferLoad(16, long.class), vmStore(stackStorage(2), long.class)\n+                    bufferLoad(8, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class),\n+                    bufferLoad(16, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 16), long.class)\n@@ -435,1 +438,1 @@\n-                    bufferLoad(0, long.class), vmStore(stackStorage(0), long.class),\n+                    bufferLoad(0, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class),\n@@ -437,1 +440,1 @@\n-                    bufferLoad(8, long.class), vmStore(stackStorage(1), long.class),\n+                    bufferLoad(8, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class),\n@@ -439,2 +442,2 @@\n-                    bufferLoad(16, long.class), vmStore(stackStorage(2), long.class),\n-                    bufferLoad(24, long.class), vmStore(stackStorage(3), long.class)\n+                    bufferLoad(16, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 16), long.class),\n+                    bufferLoad(24, long.class), vmStore(stackStorage(STACK_SLOT_SIZE, 24), long.class)\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestSysVCallArranger.java","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import static jdk.internal.foreign.abi.x64.X86_64Architecture.Regs.*;\n@@ -55,0 +56,2 @@\n+    private static final short STACK_SLOT_SIZE = 8;\n+\n@@ -135,4 +138,4 @@\n-            { vmStore(stackStorage(0), long.class) },\n-            { vmStore(stackStorage(1), long.class) },\n-            { vmStore(stackStorage(2), float.class) },\n-            { vmStore(stackStorage(3), float.class) }\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 16), float.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 24), float.class) }\n@@ -170,7 +173,7 @@\n-            { vmStore(stackStorage(0), int.class) },\n-            { vmStore(stackStorage(1), double.class) },\n-            { vmStore(stackStorage(2), double.class) },\n-            { vmStore(stackStorage(3), double.class) },\n-            { vmStore(stackStorage(4), int.class) },\n-            { vmStore(stackStorage(5), int.class) },\n-            { vmStore(stackStorage(6), int.class) }\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 16), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 24), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 32), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 40), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 48), int.class) }\n@@ -203,1 +206,1 @@\n-            { vmStore(stackStorage(0), double.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 0), double.class) },\n@@ -372,12 +375,12 @@\n-            { copy(struct), unboxAddress(), vmStore(stackStorage(0), long.class) },\n-            { vmStore(stackStorage(1), int.class) },\n-            { vmStore(stackStorage(2), double.class) },\n-            { unboxAddress(), vmStore(stackStorage(3), long.class) },\n-            { copy(struct), unboxAddress(), vmStore(stackStorage(4), long.class) },\n-            { vmStore(stackStorage(5), int.class) },\n-            { vmStore(stackStorage(6), double.class) },\n-            { unboxAddress(), vmStore(stackStorage(7), long.class) },\n-            { copy(struct), unboxAddress(), vmStore(stackStorage(8), long.class) },\n-            { vmStore(stackStorage(9), int.class) },\n-            { vmStore(stackStorage(10), double.class) },\n-            { unboxAddress(), vmStore(stackStorage(11), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 0), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 8), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 16), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 24), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 32), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 40), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 48), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 56), long.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 64), long.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 72), int.class) },\n+            { vmStore(stackStorage(STACK_SLOT_SIZE, 80), double.class) },\n+            { unboxAddress(), vmStore(stackStorage(STACK_SLOT_SIZE, 88), long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"}]}