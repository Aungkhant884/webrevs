{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,5 +63,0 @@\n-address ciNativeEntryPoint::entry_point() const {\n-  VM_ENTRY_MARK;\n-  return jdk_internal_invoke_NativeEntryPoint::addr(get_oop());\n-}\n-\n","filename":"src\/hotspot\/share\/ci\/ciNativeEntryPoint.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-  address        entry_point() const;\n","filename":"src\/hotspot\/share\/ci\/ciNativeEntryPoint.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -3819,1 +3819,0 @@\n-int jdk_internal_invoke_NativeEntryPoint::_addr_offset;\n@@ -3828,1 +3827,0 @@\n-  macro(_addr_offset,            k, \"addr\",           long_signature, false); \\\n@@ -3851,4 +3849,0 @@\n-address jdk_internal_invoke_NativeEntryPoint::addr(oop entry) {\n-  return (address)entry->long_field(_addr_offset);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1019,1 +1019,0 @@\n-  static int _addr_offset;  \/\/ type is jlong\n@@ -1033,1 +1032,0 @@\n-  static address    addr(oop entry);\n@@ -1049,1 +1047,0 @@\n-  static int addr_offset_in_bytes()            { return _addr_offset;            }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -421,2 +421,3 @@\n-  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, _input_not_const);\n-  assert(!_input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n+  bool input_not_const = true;\n+  CallGenerator* cg = for_method_handle_inline(jvms, _caller, method(), allow_inline, input_not_const);\n+  assert(!input_not_const, \"sanity\"); \/\/ shouldn't have been scheduled for inlining in the first place\n@@ -1061,0 +1062,1 @@\n+  address _call_addr;\n@@ -1063,2 +1065,2 @@\n-  NativeCallGenerator(ciMethod* m, ciNativeEntryPoint* nep)\n-   : CallGenerator(m), _nep(nep) {}\n+  NativeCallGenerator(ciMethod* m, address call_addr, ciNativeEntryPoint* nep)\n+   : CallGenerator(m), _call_addr(call_addr), _nep(nep) {}\n@@ -1072,1 +1074,1 @@\n-  Node* call = kit.make_native_call(tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n+  Node* call = kit.make_native_call(_call_addr, tf(), method()->arg_size(), _nep); \/\/ -fallback, - nep\n@@ -1076,1 +1078,0 @@\n-  address addr = _nep->entry_point();\n@@ -1078,1 +1079,1 @@\n-    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(addr));\n+    kit.C->log()->elem(\"l2n_intrinsification_success bci='%d' entry_point='\" INTPTR_FORMAT \"'\", jvms->bci(), p2i(_call_addr));\n@@ -1211,2 +1212,4 @@\n-      Node* nep = kit.argument(callee->arg_size() - 1);\n-      if (nep->Opcode() == Op_ConP) {\n+      Node* addr_n = kit.argument(1); \/\/ target address\n+      Node* nep_n = kit.argument(callee->arg_size() - 1); \/\/ NativeEntryPoint\n+      \/\/ This check needs to be kept in sync with the one in CallStaticJavaNode::Ideal\n+      if (addr_n->Opcode() == Op_ConL && nep_n->Opcode() == Op_ConP) {\n@@ -1214,3 +1217,5 @@\n-        const TypeOopPtr* oop_ptr = nep->bottom_type()->is_oopptr();\n-        ciNativeEntryPoint* nep = oop_ptr->const_oop()->as_native_entry_point();\n-        return new NativeCallGenerator(callee, nep);\n+        const TypeLong* addr_t = addr_n->bottom_type()->is_long();\n+        const TypeOopPtr* nep_t = nep_n->bottom_type()->is_oopptr();\n+        address addr = (address) addr_t->get_con();\n+        ciNativeEntryPoint* nep = nep_t->const_oop()->as_native_entry_point();\n+        return new NativeCallGenerator(callee, addr, nep);\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1063,0 +1063,6 @@\n+    } else if(iid == vmIntrinsics::_linkToNative) {\n+      if (in(TypeFunc::Parms + callee->arg_size() - 1)->Opcode() == Op_ConP \/* NEP *\/\n+          && in(TypeFunc::Parms + 1)->Opcode() == Op_ConL \/* address *\/) {\n+        phase->C->prepend_late_inline(cg);\n+        set_generator(NULL);\n+      }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -2580,2 +2580,7 @@\n-Node* GraphKit::make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n-  uint n_filtered_args = nargs - 2; \/\/ -fallback, -nep;\n+Node* GraphKit::make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep) {\n+  \/\/ Select just the actual call args to pass on\n+  \/\/ [MethodHandle fallback, long addr, HALF addr, ... args , NativeEntryPoint nep]\n+  \/\/                                             |          |\n+  \/\/                                             V          V\n+  \/\/                                             [ ... args ]\n+  uint n_filtered_args = nargs - 4; \/\/ -fallback, -addr (2), -nep;\n@@ -2591,1 +2596,1 @@\n-      uint vm_unfiltered_arg_pos = vm_arg_pos + 1; \/\/ +1 to skip fallback handle argument\n+      uint vm_unfiltered_arg_pos = vm_arg_pos + 3; \/\/ +3 to skip fallback handle argument and addr (2 since long)\n@@ -2627,1 +2632,0 @@\n-  address call_addr = nep->entry_point();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -805,1 +805,1 @@\n-  Node* make_native_call(const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n+  Node* make_native_call(address call_addr, const TypeFunc* call_type, uint nargs, ciNativeEntryPoint* nep);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,1 @@\n-            throw new IllegalArgumentException(\"Type of fallback must match\");\n+            throw new IllegalArgumentException(\"Type of fallback must match: \" + type + \" != \" + fallback.type());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/NativeMethodHandle.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,0 @@\n-    private final long addr;\n-\n@@ -52,1 +50,1 @@\n-    private NativeEntryPoint(long addr, int shadowSpace, long[] argMoves, long[] returnMoves,\n+    private NativeEntryPoint(int shadowSpace, long[] argMoves, long[] returnMoves,\n@@ -54,1 +52,0 @@\n-        this.addr = addr;\n@@ -63,1 +60,2 @@\n-    public static NativeEntryPoint make(long addr, String name, ABIDescriptorProxy abi, VMStorageProxy[] argMoves, VMStorageProxy[] returnMoves,\n+    public static NativeEntryPoint make(String name, ABIDescriptorProxy abi,\n+                                        VMStorageProxy[] argMoves, VMStorageProxy[] returnMoves,\n@@ -69,2 +67,2 @@\n-        return new NativeEntryPoint(\n-            addr, abi.shadowSpaceBytes(), encodeVMStorages(argMoves), encodeVMStorages(returnMoves), needTransition, methodType, name);\n+        return new NativeEntryPoint(abi.shadowSpaceBytes(), encodeVMStorages(argMoves), encodeVMStorages(returnMoves),\n+                needTransition, methodType, name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/invoke\/NativeEntryPoint.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -128,2 +129,2 @@\n-     * Obtain a foreign method handle, with given type, which can be used to call a\n-     * target foreign function at a given address and featuring a given function descriptor.\n+     * Obtain a foreign method handle, with the given type and featuring the given function descriptor,\n+     * which can be used to call a target foreign function at the given address.\n@@ -139,1 +140,21 @@\n-    MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function);\n+    default MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n+        Objects.requireNonNull(symbol);\n+        return MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n+    }\n+\n+    \/**\n+     * Obtain a foreign method handle, with the given type and featuring the given function descriptor,\n+     * which can be used to call a target foreign function at an address passed in as a leading argument.\n+     * <p>\n+     * For a given method type {@code (As...) -> R}, the returned method handle shall have the method type\n+     * {@code (Addressable, As...) -> R}, where {@code As...} are zero or more parameter types, and {@code R}\n+     * is the return type (which can be {@code void}).\n+     *\n+     * @see LibraryLookup#lookup(String)\n+     *\n+     * @param type     the method type.\n+     * @param function the function descriptor.\n+     * @return the downcall method handle.\n+     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     *\/\n+    MethodHandle downcallHandle(MethodType type, FunctionDescriptor function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.lang.invoke.MethodType;\n@@ -47,1 +46,0 @@\n-import static java.lang.invoke.MethodHandles.permuteArguments;\n@@ -262,21 +260,0 @@\n-    private static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {\n-        MethodType oldType = mh.type();\n-        Class<?> sourceType = oldType.parameterType(sourceIndex);\n-        Class<?> destType = oldType.parameterType(destIndex);\n-        if (sourceType != destType) {\n-            \/\/ TODO meet?\n-            throw new IllegalArgumentException(\"Parameter types differ: \" + sourceType + \" != \" + destType);\n-        }\n-        MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);\n-        int[] reorder = new int[oldType.parameterCount()];\n-        assert destIndex > sourceIndex;\n-        for (int i = 0, index = 0; i < reorder.length; i++) {\n-            if (i != destIndex) {\n-                reorder[i] = index++;\n-            } else {\n-                reorder[i] = sourceIndex;\n-            }\n-        }\n-        return permuteArguments(mh, newType, reorder);\n-    }\n-\n@@ -718,1 +695,1 @@\n-            return mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n+            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n@@ -787,1 +764,1 @@\n-            return mergeArguments(specializedHandle, allocatorPos, insertPos);\n+            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos);\n@@ -949,1 +926,1 @@\n-            return Binding.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n+            return SharedUtils.mergeArguments(specializedHandle, allocatorPos, insertPos + 1);\n@@ -1016,1 +993,1 @@\n-            return mergeArguments(specializedHandle, insertPos, insertPos + 1);\n+            return SharedUtils.mergeArguments(specializedHandle, insertPos, insertPos + 1);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":5,"deletions":28,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -82,0 +83,1 @@\n+    private static final MethodHandle MH_ADDR_TO_LONG;\n@@ -88,0 +90,2 @@\n+    private static final MethodHandle EMPTY_OBJECT_ARRAY_HANDLE = MethodHandles.constant(Object[].class, new Object[0]);\n+\n@@ -92,1 +96,1 @@\n-                    methodType(Object.class, Object[].class, Binding.VMStore[].class, Binding.VMLoad[].class));\n+                    methodType(Object.class, long.class, Object[].class, Binding.VMStore[].class, Binding.VMLoad[].class));\n@@ -94,1 +98,1 @@\n-                    methodType(Object.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n+                    methodType(Object.class, Addressable.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n@@ -101,0 +105,5 @@\n+            MethodHandle MH_Addressable_address = lookup.findVirtual(Addressable.class, \"address\",\n+                    methodType(MemoryAddress.class));\n+            MethodHandle MH_MemoryAddress_toRawLongValue = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n+                    methodType(long.class));\n+            MH_ADDR_TO_LONG = filterArguments(MH_MemoryAddress_toRawLongValue, 0, MH_Addressable_address);\n@@ -112,1 +121,0 @@\n-    private final Addressable addr;\n@@ -117,1 +125,1 @@\n-    public ProgrammableInvoker(ABIDescriptor abi, Addressable addr, CallingSequence callingSequence) {\n+    public ProgrammableInvoker(ABIDescriptor abi, CallingSequence callingSequence) {\n@@ -122,1 +130,0 @@\n-        this.addr = addr;\n@@ -146,0 +153,1 @@\n+        MethodType leafTypeWithAddress = leafType.insertParameterTypes(0, long.class);\n@@ -147,3 +155,4 @@\n-        MethodHandle handle = insertArguments(MH_INVOKE_MOVES.bindTo(this), 1, argMoves, retMoves)\n-                                            .asCollector(Object[].class, leafType.parameterCount())\n-                                            .asType(leafType);\n+        MethodHandle handle = insertArguments(MH_INVOKE_MOVES.bindTo(this), 2, argMoves, retMoves);\n+        MethodHandle collector = makeCollectorHandle(leafType);\n+        handle = collectArguments(handle, 1, collector);\n+        handle = handle.asType(leafTypeWithAddress);\n@@ -155,1 +164,0 @@\n-                addr.address().toRawLongValue(),\n@@ -161,1 +169,1 @@\n-                leafType\n+                leafTypeWithAddress\n@@ -166,0 +174,1 @@\n+        handle = filterArguments(handle, 0, MH_ADDR_TO_LONG);\n@@ -173,3 +182,4 @@\n-            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 1, handle, argIndexMap, retIndexMap);\n-            handle = handle.asCollector(Object[].class, callingSequence.methodType().parameterCount())\n-                                             .asType(callingSequence.methodType());\n+            handle = insertArguments(MH_INVOKE_INTERP_BINDINGS.bindTo(this), 2, handle, argIndexMap, retIndexMap);\n+            MethodHandle collectorInterp = makeCollectorHandle(callingSequence.methodType());\n+            handle = collectArguments(handle, 1, collectorInterp);\n+            handle = handle.asType(handle.type().changeReturnType(callingSequence.methodType().returnType()));\n@@ -181,0 +191,9 @@\n+    \/\/ Funnel from type to Object[]\n+    private static MethodHandle makeCollectorHandle(MethodType type) {\n+        return type.parameterCount() == 0\n+            ? EMPTY_OBJECT_ARRAY_HANDLE\n+            : identity(Object[].class)\n+                .asCollector(Object[].class, type.parameterCount())\n+                .asType(type.changeReturnType(Object[].class));\n+    }\n+\n@@ -205,1 +224,1 @@\n-        int argInsertPos = -1;\n+        int argInsertPos = 0; \/\/ +1 for addr\n@@ -208,1 +227,1 @@\n-            argAllocatorPos = 0;\n+            argAllocatorPos = 1;\n@@ -243,5 +262,10 @@\n-                  \/\/ (Throwable, NativeScope) -> void\n-                ? collectArguments(empty(methodType(void.class, Throwable.class)), 1, MH_CLOSE_SCOPE)\n-                  \/\/ (Throwable, V, NativeScope) -> V\n-                : collectArguments(dropArguments(identity(specializedHandle.type().returnType()), 0, Throwable.class),\n-                                   2, MH_CLOSE_SCOPE);\n+                  \/\/ (Throwable, Addressable, NativeScope) -> void\n+                ? collectArguments(empty(methodType(void.class, Throwable.class, Addressable.class)), 2, MH_CLOSE_SCOPE)\n+                  \/\/ (Throwable, V, Addressable, NativeScope) -> V\n+                : collectArguments( \/\/ (Throwable, V, Addressable, NativeScope) -> V\n+                    dropArguments( \/\/ (Throwable, V, Addressable) -> V\n+                        dropArguments( \/\/ (Throwable, V) -> V\n+                            identity(specializedHandle.type().returnType()), \/\/ (V) -> V\n+                            0, Throwable.class),\n+                        2, Addressable.class),\n+                                   3, MH_CLOSE_SCOPE);\n@@ -272,1 +296,1 @@\n-    Object invokeMoves(Object[] args, Binding.VMStore[] argBindings, Binding.VMLoad[] returnBindings) {\n+    Object invokeMoves(long addr, Object[] args, Binding.VMStore[] argBindings, Binding.VMLoad[] returnBindings) {\n@@ -279,1 +303,1 @@\n-            VH_LONG.set(argBuffer.asSlice(layout.arguments_next_pc), addr.address().toRawLongValue());\n+            VH_LONG.set(argBuffer.asSlice(layout.arguments_next_pc), addr);\n@@ -326,1 +350,1 @@\n-    Object invokeInterpBindings(Object[] args, MethodHandle leaf,\n+    Object invokeInterpBindings(Addressable address, Object[] args, MethodHandle leaf,\n@@ -334,1 +358,2 @@\n-            Object[] moves = new Object[leaf.type().parameterCount()];\n+            Object[] leafArgs = new Object[leaf.type().parameterCount()];\n+            leafArgs[0] = address; \/\/ addr\n@@ -339,1 +364,1 @@\n-                            moves[argIndexMap.get(storage)] = value;\n+                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip addr\n@@ -344,1 +369,1 @@\n-            Object o = leaf.invokeWithArguments(moves);\n+            Object o = leaf.invokeWithArguments(leafArgs);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":52,"deletions":27,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,3 +158,3 @@\n-            throw new IllegalArgumentException(\"return expected to be void for in memory returns\");\n-        if (handle.type().parameterType(0) != MemoryAddress.class)\n-            throw new IllegalArgumentException(\"MemoryAddress expected as first param\");\n+            throw new IllegalArgumentException(\"return expected to be void for in memory returns: \" + handle.type());\n+        if (handle.type().parameterType(1) != MemoryAddress.class)\n+            throw new IllegalArgumentException(\"MemoryAddress expected as second param: \" + handle.type());\n@@ -165,8 +165,4 @@\n-        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, MemoryAddress ...) MemorySegment\n-        handle = collectArguments(handle, 1, MH_BASEADDRESS); \/\/ (MemorySegment, MemorySegment ...) MemorySegment\n-        MethodType oldType = handle.type(); \/\/ (MemorySegment, MemorySegment, ...) MemorySegment\n-        MethodType newType = oldType.dropParameterTypes(0, 1); \/\/ (MemorySegment, ...) MemorySegment\n-        int[] reorder = IntStream.range(-1, newType.parameterCount()).toArray();\n-        reorder[0] = 0; \/\/ [0, 0, 1, 2, 3, ...]\n-        handle = permuteArguments(handle, newType, reorder); \/\/ (MemorySegment, ...) MemoryAddress\n-        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 0, cDesc.returnLayout().get())); \/\/ (...) MemoryAddress\n+        handle = collectArguments(ret, 1, handle); \/\/ (MemorySegment, Addressable, MemoryAddress, ...) MemorySegment\n+        handle = collectArguments(handle, 2, MH_BASEADDRESS); \/\/ (MemorySegment, Addressable, MemorySegment, ...) MemorySegment\n+        handle = mergeArguments(handle, 0, 2);  \/\/ (MemorySegment, Addressable, ...) MemorySegment\n+        handle = collectArguments(handle, 0, insertArguments(MH_ALLOC_BUFFER, 0, cDesc.returnLayout().get())); \/\/ (Addressable, ...) MemoryAddress\n@@ -289,0 +285,21 @@\n+    static MethodHandle mergeArguments(MethodHandle mh, int sourceIndex, int destIndex) {\n+        MethodType oldType = mh.type();\n+        Class<?> sourceType = oldType.parameterType(sourceIndex);\n+        Class<?> destType = oldType.parameterType(destIndex);\n+        if (sourceType != destType) {\n+            \/\/ TODO meet?\n+            throw new IllegalArgumentException(\"Parameter types differ: \" + sourceType + \" != \" + destType);\n+        }\n+        MethodType newType = oldType.dropParameterTypes(destIndex, destIndex + 1);\n+        int[] reorder = new int[oldType.parameterCount()];\n+        assert destIndex > sourceIndex;\n+        for (int i = 0, index = 0; i < reorder.length; i++) {\n+            if (i != destIndex) {\n+                reorder[i] = index++;\n+            } else {\n+                reorder[i] = sourceIndex;\n+            }\n+        }\n+        return permuteArguments(mh, newType, reorder);\n+    }\n+\n@@ -361,1 +378,1 @@\n-               handle = MethodHandles.filterArguments(handle, i, unboxer);\n+               handle = MethodHandles.filterArguments(handle, i + 1, unboxer); \/\/ +1 for leading address\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,1 @@\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n+    public MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n@@ -82,1 +81,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/AArch64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -132,1 +132,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(C, addr, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new ProgrammableInvoker(C, bindings.callingSequence).getBoundMethodHandle();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -129,1 +129,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(CSysV, addr, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new ProgrammableInvoker(CSysV, bindings.callingSequence).getBoundMethodHandle();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,2 +88,1 @@\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n+    public MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n@@ -93,1 +92,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,1 +127,1 @@\n-    public static MethodHandle arrangeDowncall(Addressable addr, MethodType mt, FunctionDescriptor cDesc) {\n+    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -130,1 +130,1 @@\n-        MethodHandle handle = new ProgrammableInvoker(CWindows, addr, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new ProgrammableInvoker(CWindows, bindings.callingSequence).getBoundMethodHandle();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,2 +89,1 @@\n-    public MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(symbol);\n+    public MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n@@ -94,1 +93,1 @@\n-        MethodHandle handle = CallArranger.arrangeDowncall(symbol, llMt, function);\n+        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,8 +57,2 @@\n-    private static MethodHandle linkIndentity(String name, Class<?> carrier, MemoryLayout layout, boolean trivial) {\n-        LibraryLookup.Symbol ma = lookup.lookup(name).orElseThrow();\n-        MethodType mt = methodType(carrier, carrier);\n-        FunctionDescriptor fd = FunctionDescriptor.of(layout, layout);\n-        if (trivial) {\n-            fd = fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true);\n-        }\n-        return abi.downcallHandle(ma, mt, fd);\n+    private interface RunnableX {\n+        void run() throws Throwable;\n@@ -74,8 +68,0 @@\n-    private interface RunnableX {\n-        void run() throws Throwable;\n-    }\n-\n-    private interface AddTest {\n-        void add(MethodHandle target, Object expectedResult, Object... args);\n-    }\n-\n@@ -85,0 +71,5 @@\n+\n+        interface AddTest {\n+            void add(MethodHandle target, Object expectedResult, Object... args);\n+        }\n+\n@@ -90,0 +81,14 @@\n+        interface AddIdentity {\n+            void add(String name, Class<?> carrier, MemoryLayout layout, Object arg);\n+        }\n+\n+        AddIdentity addIdentity = (name, carrier, layout, arg) -> {\n+            LibraryLookup.Symbol ma = lookup.lookup(name).orElseThrow();\n+            MethodType mt = methodType(carrier, carrier);\n+            FunctionDescriptor fd = FunctionDescriptor.of(layout, layout);\n+\n+            tests.add(abi.downcallHandle(ma, mt, fd), arg, arg);\n+            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), arg, arg);\n+            tests.add(abi.downcallHandle(mt, fd), arg, ma, arg);\n+        };\n+\n@@ -98,12 +103,6 @@\n-        tests.add(linkIndentity(\"identity_char\", byte.class, C_CHAR, false), (byte) 10, (byte) 10);\n-        tests.add(linkIndentity(\"identity_char\", byte.class, C_CHAR, true), (byte) 10, (byte) 10);\n-        tests.add(linkIndentity(\"identity_short\", short.class, C_SHORT, false), (short) 10, (short) 10);\n-        tests.add(linkIndentity(\"identity_short\", short.class, C_SHORT, true), (short) 10, (short) 10);\n-        tests.add(linkIndentity(\"identity_int\", int.class, C_INT, false), 10, 10);\n-        tests.add(linkIndentity(\"identity_int\", int.class, C_INT, true), 10, 10);\n-        tests.add(linkIndentity(\"identity_long\", long.class, C_LONG_LONG, false), 10L, 10L);\n-        tests.add(linkIndentity(\"identity_long\", long.class, C_LONG_LONG, true), 10L, 10L);\n-        tests.add(linkIndentity(\"identity_float\", float.class, C_FLOAT, false), 10F, 10F);\n-        tests.add(linkIndentity(\"identity_float\", float.class, C_FLOAT, true), 10F, 10F);\n-        tests.add(linkIndentity(\"identity_double\", double.class, C_DOUBLE, false), 10D, 10D);\n-        tests.add(linkIndentity(\"identity_double\", double.class, C_DOUBLE, true), 10D, 10D);\n+        addIdentity.add(\"identity_char\",   byte.class,   C_CHAR,   (byte) 10);\n+        addIdentity.add(\"identity_short\",  short.class,  C_SHORT, (short) 10);\n+        addIdentity.add(\"identity_int\",    int.class,    C_INT,           10);\n+        addIdentity.add(\"identity_long\",   long.class,   C_LONG_LONG,     10L);\n+        addIdentity.add(\"identity_float\",  float.class,  C_FLOAT,         10F);\n+        addIdentity.add(\"identity_double\", double.class, C_DOUBLE,        10D);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":28,"deletions":29,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+ * @run testng\/othervm\n+ *   -Dforeign.restricted=permit\n+ *   TestVirtualCalls\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import org.testng.annotations.*;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestVirtualCalls {\n+\n+    static final CLinker abi = CLinker.getInstance();\n+    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"Virtual\");\n+\n+    static final MethodHandle func;\n+    static final LibraryLookup.Symbol funcA;\n+    static final LibraryLookup.Symbol funcB;\n+    static final LibraryLookup.Symbol funcC;\n+\n+    static {\n+        func = abi.downcallHandle(\n+            MethodType.methodType(int.class),\n+            FunctionDescriptor.of(C_INT));\n+\n+        funcA = lookup.lookup(\"funcA\").orElseThrow();\n+        funcB = lookup.lookup(\"funcB\").orElseThrow();\n+        funcC = lookup.lookup(\"funcC\").orElseThrow();\n+    }\n+\n+    @Test\n+    public void testVirtualCalls() throws Throwable {\n+        assertEquals((int) func.invokeExact((Addressable) funcA), 1);\n+        assertEquals((int) func.invokeExact((Addressable) funcB), 2);\n+        assertEquals((int) func.invokeExact((Addressable) funcC), 3);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT int funcA() {\n+    return 1;\n+}\n+\n+EXPORT int funcB() {\n+    return 2;\n+}\n+\n+EXPORT int funcC() {\n+    return 3;\n+}\n","filename":"test\/jdk\/java\/foreign\/virtual\/libVirtual.c","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package org.openjdk.bench.jdk.incubator.foreign;\n-\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.LibraryLookup;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.CLinker;\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.concurrent.TimeUnit;\n-\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n-@State(org.openjdk.jmh.annotations.Scope.Thread)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n-public class CallOverhead {\n-\n-    static final CLinker abi = CLinker.getInstance();\n-\n-    static final MethodHandle func;\n-    static final MethodHandle identity;\n-    static final MethodHandle identity_struct;\n-    static final MethodHandle identity_memory_address;\n-    static final MethodHandle args5;\n-    static final MethodHandle args10;\n-    static final MethodHandle func_trivial;\n-    static final MethodHandle identity_trivial;\n-\n-    static final MemoryLayout POINT_LAYOUT = MemoryLayout.ofStruct(\n-            C_LONG_LONG, C_LONG_LONG\n-    );\n-\n-    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT);\n-\n-    static {\n-        System.loadLibrary(\"CallOverheadJNI\");\n-\n-        LibraryLookup ll = LibraryLookup.ofLibrary(\"CallOverhead\");\n-        {\n-            LibraryLookup.Symbol addr = ll.lookup(\"func\").get();\n-            MethodType mt = MethodType.methodType(void.class);\n-            FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n-            func = abi.downcallHandle(addr, mt, fd);\n-            func_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-        }\n-        {\n-            LibraryLookup.Symbol addr = ll.lookup(\"identity\").get();\n-            MethodType mt = MethodType.methodType(int.class, int.class);\n-            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n-            identity = abi.downcallHandle(addr, mt, fd);\n-            identity_trivial = abi.downcallHandle(addr, mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-        }\n-        identity_struct = abi.downcallHandle(ll.lookup(\"identity_struct\").get(),\n-                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n-                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n-        identity_memory_address = abi.downcallHandle(ll.lookup(\"identity_memory_address\").get(),\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_POINTER, C_POINTER));\n-        args5 = abi.downcallHandle(ll.lookup(\"args5\").get(),\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n-        args10 = abi.downcallHandle(ll.lookup(\"args10\").get(),\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n-                                                  double.class, long.class, double.class, long.class, double.class),\n-                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n-                                          C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n-    }\n-\n-    static native void blank();\n-    static native int identity(int x);\n-\n-    @Benchmark\n-    public void jni_blank() throws Throwable {\n-        blank();\n-    }\n-\n-    @Benchmark\n-    public void panama_blank() throws Throwable {\n-        func.invokeExact();\n-    }\n-\n-    @Benchmark\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n-    }\n-\n-    @Benchmark\n-    public int jni_identity() throws Throwable {\n-        return identity(10);\n-    }\n-\n-    @Benchmark\n-    public int panama_identity() throws Throwable {\n-        return (int) identity.invokeExact(10);\n-    }\n-\n-    @Benchmark\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n-    }\n-\n-    @Benchmark\n-    public MemorySegment panama_identity_struct() throws Throwable {\n-        return (MemorySegment) identity_struct.invokeExact(point);\n-    }\n-\n-    @Benchmark\n-    public MemoryAddress panama_identity_memory_address() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact(MemoryAddress.NULL);\n-    }\n-\n-    @Benchmark\n-    public void panama_args5() throws Throwable {\n-        args5.invokeExact(10L, 11D, 12L, 13D, 14L);\n-    }\n-\n-    @Benchmark\n-    public void panama_args10() throws Throwable {\n-        args10.invokeExact(10L, 11D, 12L, 13D, 14L,\n-                           15D, 16L, 17D, 18L, 19D);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverhead.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.jdk.incubator.foreign.CallOverheadHelper.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+public class CallOverheadConstant {\n+\n+    @Benchmark\n+    public void jni_blank() throws Throwable {\n+        blank();\n+    }\n+\n+    @Benchmark\n+    public void panama_blank() throws Throwable {\n+        func.invokeExact();\n+    }\n+\n+    @Benchmark\n+    public void panama_blank_trivial() throws Throwable {\n+        func_trivial.invokeExact();\n+    }\n+\n+    @Benchmark\n+    public int jni_identity() throws Throwable {\n+        return identity(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity() throws Throwable {\n+        return (int) identity.invokeExact(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity_trivial() throws Throwable {\n+        return (int) identity_trivial.invokeExact(10);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct() throws Throwable {\n+        return (MemorySegment) identity_struct.invokeExact(point);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact(MemoryAddress.NULL);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_01() throws Throwable {\n+        args1.invokeExact(10L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_02() throws Throwable {\n+        args2.invokeExact(10L, 11D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_03() throws Throwable {\n+        args3.invokeExact(10L, 11D, 12L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_04() throws Throwable {\n+        args4.invokeExact(10L, 11D, 12L, 13D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_05() throws Throwable {\n+        args5.invokeExact(10L, 11D, 12L, 13D, 14L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_10() throws Throwable {\n+        args10.invokeExact(10L, 11D, 12L, 13D, 14L,\n+                           15D, 16L, 17D, 18L, 19D);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadConstant.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.invoke.MethodHandles.insertArguments;\n+import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n+import static jdk.incubator.foreign.CLinker.C_POINTER;\n+\n+public class CallOverheadHelper {\n+\n+    static final CLinker abi = CLinker.getInstance();\n+\n+    static final MethodHandle func;\n+    static final MethodHandle func_v;\n+    static Addressable func_addr;\n+    static final MethodHandle identity;\n+    static final MethodHandle identity_v;\n+    static Addressable identity_addr;\n+    static final MethodHandle identity_struct;\n+    static final MethodHandle identity_struct_v;\n+    static Addressable identity_struct_addr;\n+    static final MethodHandle identity_memory_address;\n+    static final MethodHandle identity_memory_address_v;\n+    static Addressable identity_memory_address_addr;\n+    static final MethodHandle args1;\n+    static final MethodHandle args1_v;\n+    static Addressable args1_addr;\n+    static final MethodHandle args2;\n+    static final MethodHandle args2_v;\n+    static Addressable args2_addr;\n+    static final MethodHandle args3;\n+    static final MethodHandle args3_v;\n+    static Addressable args3_addr;\n+    static final MethodHandle args4;\n+    static final MethodHandle args4_v;\n+    static Addressable args4_addr;\n+    static final MethodHandle args5;\n+    static final MethodHandle args5_v;\n+    static Addressable args5_addr;\n+    static final MethodHandle args10;\n+    static final MethodHandle args10_v;\n+    static Addressable args10_addr;\n+    static final MethodHandle func_trivial;\n+    static final MethodHandle func_trivial_v;\n+    static final MethodHandle identity_trivial;\n+    static final MethodHandle identity_trivial_v;\n+\n+    static final MemoryLayout POINT_LAYOUT = MemoryLayout.ofStruct(\n+            C_LONG_LONG, C_LONG_LONG\n+    );\n+\n+    static final MemorySegment point = MemorySegment.allocateNative(POINT_LAYOUT);\n+\n+    static {\n+        System.loadLibrary(\"CallOverheadJNI\");\n+\n+        LibraryLookup ll = LibraryLookup.ofLibrary(\"CallOverhead\");\n+        {\n+            func_addr = ll.lookup(\"func\").orElseThrow();\n+            MethodType mt = MethodType.methodType(void.class);\n+            FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+            func_v = abi.downcallHandle(mt, fd);\n+            func = insertArguments(func_v, 0, func_addr);\n+            func_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n+        }\n+        {\n+            identity_addr = ll.lookup(\"identity\").orElseThrow();\n+            MethodType mt = MethodType.methodType(int.class, int.class);\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT);\n+            identity_v = abi.downcallHandle(mt, fd);\n+            identity = insertArguments(identity_v, 0, identity_addr);\n+            identity_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n+            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n+        }\n+        identity_struct_addr = ll.lookup(\"identity_struct\").orElseThrow();\n+        identity_struct_v = abi.downcallHandle(\n+                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n+                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT));\n+        identity_struct = insertArguments(identity_struct_v, 0, identity_struct_addr);\n+\n+        identity_memory_address_addr = ll.lookup(\"identity_memory_address\").orElseThrow();\n+        identity_memory_address_v = abi.downcallHandle(\n+                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER));\n+        identity_memory_address = insertArguments(identity_memory_address_v, 0, identity_memory_address_addr);\n+\n+        args1_addr = ll.lookup(\"args1\").orElseThrow();\n+        args1_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG));\n+        args1 = insertArguments(args1_v, 0, args1_addr);\n+\n+        args2_addr = ll.lookup(\"args2\").orElseThrow();\n+        args2_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE));\n+        args2 = insertArguments(args2_v, 0, args2_addr);\n+\n+        args3_addr = ll.lookup(\"args3\").orElseThrow();\n+        args3_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n+        args3 = insertArguments(args3_v, 0, args3_addr);\n+\n+        args4_addr = ll.lookup(\"args4\").orElseThrow();\n+        args4_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n+        args4 = insertArguments(args4_v, 0, args4_addr);\n+\n+        args5_addr = ll.lookup(\"args5\").orElseThrow();\n+        args5_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG));\n+        args5 = insertArguments(args5_v, 0, args5_addr);\n+\n+        args10_addr = ll.lookup(\"args10\").orElseThrow();\n+        args10_v = abi.downcallHandle(\n+                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n+                                                  double.class, long.class, double.class, long.class, double.class),\n+                FunctionDescriptor.ofVoid(C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG,\n+                                          C_DOUBLE, C_LONG_LONG, C_DOUBLE, C_LONG_LONG, C_DOUBLE));\n+        args10 = insertArguments(args10_v, 0, args10_addr);\n+    }\n+\n+    static native void blank();\n+    static native int identity(int x);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openjdk.bench.jdk.incubator.foreign.CallOverheadHelper.*;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"-Dforeign.restricted=permit\" })\n+public class CallOverheadVirtual {\n+\n+    @Benchmark\n+    public void jni_blank() throws Throwable {\n+        blank();\n+    }\n+\n+    @Benchmark\n+    public void panama_blank() throws Throwable {\n+        func_v.invokeExact(func_addr);\n+    }\n+\n+    @Benchmark\n+    public void panama_blank_trivial() throws Throwable {\n+        func_trivial_v.invokeExact(func_addr);\n+    }\n+\n+    @Benchmark\n+    public int jni_identity() throws Throwable {\n+        return identity(10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity() throws Throwable {\n+        return (int) identity_v.invokeExact(identity_addr, 10);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity_trivial() throws Throwable {\n+        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, point);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, MemoryAddress.NULL);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_01() throws Throwable {\n+        args1_v.invokeExact(args1_addr, 10L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_02() throws Throwable {\n+        args2_v.invokeExact(args2_addr, 10L, 11D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_03() throws Throwable {\n+        args3_v.invokeExact(args3_addr, 10L, 11D, 12L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_04() throws Throwable {\n+        args4_v.invokeExact(args4_addr, 10L, 11D, 12L, 13D);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_05() throws Throwable {\n+        args5_v.invokeExact(args5_addr, 10L, 11D, 12L, 13D, 14L);\n+    }\n+\n+    @Benchmark\n+    public void panama_args_10() throws Throwable {\n+        args10_v.invokeExact(args10_addr,\n+                           10L, 11D, 12L, 13D, 14L,\n+                           15D, 16L, 17D, 18L, 19D);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadVirtual.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,4 @@\n+EXPORT void args1(long long a0) {}\n+EXPORT void args2(long long a0, double a1) {}\n+EXPORT void args3(long long a0, double a1, long long a2) {}\n+EXPORT void args4(long long a0, double a1, long long a2, double a3) {}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverhead.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverhead_blank\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverheadHelper_blank\n@@ -36,1 +36,1 @@\n-JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverhead_identity\n+JNIEXPORT jint JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_CallOverheadHelper_identity\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverheadJNI.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}