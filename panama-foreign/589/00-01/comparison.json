{"files":[{"patch":"@@ -79,1 +79,1 @@\n- * Finally, downcall method handles feature a leading parameter of type {@link Addressable}, from which the\n+ * Finally, downcall method handles feature a leading parameter of type {@link NativeSymbol}, from which the\n@@ -154,1 +154,1 @@\n-     * which can be used to call a target foreign function at the given address.\n+     * which can be used to call a target foreign function at the address in the given native symbol.\n@@ -173,1 +173,1 @@\n-    default MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function) {\n+    default MethodHandle downcallHandle(NativeSymbol symbol, FunctionDescriptor function) {\n@@ -180,3 +180,3 @@\n-     * used to call a target foreign function at an address.\n-     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the address, of\n-     * type {@link Addressable}.\n+     * used to call a target foreign function at the address in a dynamically provided native symbol.\n+     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the foreign function\n+     * entry point, of type {@link NativeSymbol}.\n@@ -188,2 +188,2 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the target address passed to it is\n-     * {@link MemoryAddress#NULL}, or a {@link NullPointerException} if the target address is {@code null}.\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the native symbol passed to it is\n+     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if the native symbol is {@code null}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n@@ -8,0 +33,1 @@\n+import java.util.Objects;\n@@ -58,0 +84,3 @@\n+        Objects.requireNonNull(name);\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeSymbol.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -89,1 +90,1 @@\n-                    methodType(Object.class, Addressable.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n+                    methodType(Object.class, NativeSymbol.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n@@ -92,1 +93,1 @@\n-            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, Addressable.class));\n+            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, NativeSymbol.class));\n@@ -174,1 +175,1 @@\n-    private static long unboxTargetAddress(Addressable addr) {\n+    private static long unboxTargetAddress(NativeSymbol addr) {\n@@ -314,1 +315,1 @@\n-    Object invokeInterpBindings(Addressable address, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n+    Object invokeInterpBindings(NativeSymbol symbol, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n@@ -323,1 +324,1 @@\n-            leafArgs[0] = address; \/\/ addr\n+            leafArgs[0] = symbol; \/\/ symbol\n@@ -328,1 +329,1 @@\n-                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip addr\n+                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip symbol\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -389,1 +390,1 @@\n-        \/\/ downcalls get the leading Addressable\/SegmentAllocator param as well\n+        \/\/ downcalls get the leading NativeSymbol\/SegmentAllocator param as well\n@@ -391,2 +392,2 @@\n-            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(Addressable.class));\n-            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, Addressable, SegmentAllocator) -> V\/void\n+            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(NativeSymbol.class));\n+            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, NativeSymbol, SegmentAllocator) -> V\/void\n@@ -395,1 +396,1 @@\n-        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, Addressable?, BindingContext) -> V\/void\n+        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, NativeSymbol?, BindingContext) -> V\/void\n@@ -514,1 +515,1 @@\n-            if (ptype == Addressable.class) {\n+            if (ptype == Addressable.class || ptype == NativeSymbol.class) {\n@@ -527,1 +528,1 @@\n-                adapterType = adapterType.appendParameterTypes(Addressable.class);\n+                adapterType = adapterType.appendParameterTypes(i == 0 ? NativeSymbol.class : Addressable.class);\n@@ -538,1 +539,0 @@\n-            \/\/ acquire\/release target addressable\n@@ -567,1 +567,1 @@\n-    public static void checkSymbol(Addressable symbol) {\n+    public static void checkSymbol(NativeSymbol symbol) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-        return new NativeSymbolImpl(\"\", MemoryAddress.ofLong(entry), scope);\n+        return new NativeSymbolImpl(\"upcall:\" + Long.toHexString(entry), MemoryAddress.ofLong(entry), scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -450,2 +451,2 @@\n-    MethodHandle downcallHandle(CLinker abi, Addressable addr, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n-        MethodHandle mh = abi.downcallHandle(addr, descriptor);\n+    MethodHandle downcallHandle(CLinker abi, NativeSymbol symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n+        MethodHandle mh = abi.downcallHandle(symbol, descriptor);\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -110,2 +110,2 @@\n-    Object doCall(Addressable addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n-        MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n+    Object doCall(NativeSymbol symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+        MethodHandle mh = downcallHandle(abi, symbol, allocator, descriptor);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -43,1 +45,1 @@\n-    private static final MemoryAddress DUMMY_TARGET = MemoryAddress.ofLong(1);\n+    private static final NativeSymbol DUMMY_TARGET = NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -48,1 +50,1 @@\n-                MemoryAddress.NULL,\n+                NativeSymbol.ofAddress(\"nullAddress\", MemoryAddress.NULL, ResourceScope.globalScope()),\n@@ -56,1 +58,1 @@\n-        mh.invokeExact((Addressable) MemoryAddress.NULL);\n+        mh.invokeExact(NativeSymbol.ofAddress(\"null\", MemoryAddress.NULL, ResourceScope.globalScope()));\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,1 +105,2 @@\n-            ResourceScope.class\n+            ResourceScope.class,\n+            NativeSymbol.class\n@@ -190,0 +191,1 @@\n+        addDefaultMapping(NativeSymbol.class, NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope()));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -50,3 +51,3 @@\n-    static final Addressable funcA;\n-    static final Addressable funcB;\n-    static final Addressable funcC;\n+    static final NativeSymbol funcA;\n+    static final NativeSymbol funcB;\n+    static final NativeSymbol funcC;\n@@ -74,1 +75,1 @@\n-        int x = (int) func.invokeExact((Addressable) null);\n+        int x = (int) func.invokeExact((NativeSymbol) null);\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -28,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -31,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -46,1 +45,1 @@\n-    static Addressable func_addr;\n+    static NativeSymbol func_addr;\n@@ -49,1 +48,1 @@\n-    static Addressable identity_addr;\n+    static NativeSymbol identity_addr;\n@@ -52,1 +51,1 @@\n-    static Addressable identity_struct_addr;\n+    static NativeSymbol identity_struct_addr;\n@@ -55,1 +54,1 @@\n-    static Addressable identity_struct_3_addr;\n+    static NativeSymbol identity_struct_3_addr;\n@@ -58,1 +57,1 @@\n-    static Addressable identity_memory_address_addr;\n+    static NativeSymbol identity_memory_address_addr;\n@@ -61,1 +60,1 @@\n-    static Addressable identity_memory_address_3_addr;\n+    static NativeSymbol identity_memory_address_3_addr;\n@@ -64,1 +63,1 @@\n-    static Addressable args1_addr;\n+    static NativeSymbol args1_addr;\n@@ -67,1 +66,1 @@\n-    static Addressable args2_addr;\n+    static NativeSymbol args2_addr;\n@@ -70,1 +69,1 @@\n-    static Addressable args3_addr;\n+    static NativeSymbol args3_addr;\n@@ -73,1 +72,1 @@\n-    static Addressable args4_addr;\n+    static NativeSymbol args4_addr;\n@@ -76,1 +75,1 @@\n-    static Addressable args5_addr;\n+    static NativeSymbol args5_addr;\n@@ -79,1 +78,1 @@\n-    static Addressable args10_addr;\n+    static NativeSymbol args10_addr;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -59,2 +60,2 @@\n-    static final Addressable native_compar;\n-    static final Addressable panama_upcall_compar;\n+    static final NativeSymbol native_compar;\n+    static final NativeSymbol panama_upcall_compar;\n@@ -66,1 +67,1 @@\n-    static Addressable qsort_addr = abi.lookup(\"qsort\").get();\n+    static NativeSymbol qsort_addr = abi.lookup(\"qsort\").get();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,4 +60,4 @@\n-    static final Addressable cb_blank;\n-    static final Addressable cb_identity;\n-    static final Addressable cb_args5;\n-    static final Addressable cb_args10;\n+    static final NativeSymbol cb_blank;\n+    static final NativeSymbol cb_identity;\n+    static final NativeSymbol cb_args5;\n+    static final NativeSymbol cb_args10;\n@@ -86,1 +86,1 @@\n-                blank = linkFunc(name, mt, fd);\n+                blank = linkFunc(name, fd);\n@@ -94,1 +94,1 @@\n-                identity = linkFunc(name, mt, fd);\n+                identity = linkFunc(name, fd);\n@@ -104,1 +104,1 @@\n-                args5 = linkFunc(name, mt, fd);\n+                args5 = linkFunc(name, fd);\n@@ -116,1 +116,1 @@\n-                args10 = linkFunc(name, mt, fd);\n+                args10 = linkFunc(name, fd);\n@@ -124,1 +124,1 @@\n-    static MethodHandle linkFunc(String name, MethodType baseType, FunctionDescriptor baseDesc) {\n+    static MethodHandle linkFunc(String name, FunctionDescriptor baseDesc) {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}