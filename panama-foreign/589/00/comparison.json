{"files":[{"patch":"@@ -31,1 +31,1 @@\n- * {@link MemoryAddress}, {@link VaList} and {@link CLinker.UpcallStub}.\n+ * {@link MemoryAddress}, {@link VaList} and {@link NativeSymbol}.\n@@ -40,1 +40,1 @@\n-public sealed interface Addressable permits MemorySegment, MemoryAddress, CLinker.UpcallStub, VaList {\n+public sealed interface Addressable permits MemorySegment, MemoryAddress, NativeSymbol, VaList {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -71,1 +70,1 @@\n- * Arguments of type {@link MemorySegment}, {@link VaList} and {@link UpcallStub} passed by-reference to a downcall method handle\n+ * Arguments of type {@link MemorySegment}, {@link VaList} and {@link NativeSymbol} passed by-reference to a downcall method handle\n@@ -109,3 +108,3 @@\n- * Upcall stubs are modelled by instances of type {@link UpcallStub}; upcall stubs can be passed by reference to other\n- * downcall method handles (as {@link UpcallStub} implements the {@link Addressable} interface) and,\n- * when no longer required, they can be {@link ResourceScope#close() released}, via their {@linkplain UpcallStub#scope() scope}.\n+ * Upcall stubs are modelled by instances of type {@link NativeSymbol}; upcall stubs can be passed by reference to other\n+ * downcall method handles (as {@link NativeSymbol} implements the {@link Addressable} interface) and,\n+ * when no longer required, they can be {@link ResourceScope#close() released}, via their {@linkplain NativeSymbol#scope() scope}.\n@@ -149,1 +148,1 @@\n-    default Optional<MemoryAddress> lookup(String name) {\n+    default Optional<NativeSymbol> lookup(String name) {\n@@ -218,1 +217,1 @@\n-     * @return the native stub segment.\n+     * @return the native stub symbol.\n@@ -225,37 +224,1 @@\n-    UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n-\n-    \/**\n-     * An upcall stub is a pointer to a stub of code which can be passed to native functions to call a given <em>target<\/em> Java method handle.\n-     * Created by {@link #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}, an upcall stub can be passed by\n-     * reference to other downcall method handles, as this interface extends {@link Addressable}.\n-     * When no longer required, resources associated with an upcall stub can be {@link ResourceScope#close() released},\n-     * via its {@linkplain UpcallStub#scope() scope}.\n-     *\/\n-    sealed interface UpcallStub extends Addressable permits UpcallStubs.UpcallStubImpl {\n-        \/**\n-         * Obtains the function descriptor with which this upcall stub was {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) created}.\n-         * @return the function descriptor with which this upcall stub was {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) created}.\n-         *\/\n-        FunctionDescriptor descriptor();\n-\n-        \/**\n-         * Obtains the target Java method handle invoked by this upcall stub.\n-         * @return the target Java method handle invoked by this upcall stub.\n-         *\/\n-        MethodHandle target();\n-\n-        \/**\n-         * Returns the resource scope associated with this instance.\n-         * @return the resource scope associated with this instance.\n-         *\/\n-        ResourceScope scope();\n-\n-        \/**\n-         * Returns the memory address associated with this upcall stub.\n-         * @throws IllegalStateException if the scope associated with this upcall stub has been closed, or if access occurs from\n-         * a thread other than the thread owning that scope.\n-         * @return The memory address associated with this upcall stub.\n-         *\/\n-        @Override\n-        MemoryAddress address();\n-    }\n+    NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":7,"deletions":44,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.NativeSymbolImpl;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+\/**\n+ * A native symbol models a reference to a location (typically the entry point of a function) in a native library.\n+ * A native symbol has a name, and is associated with a scope, which governs the native symbol's lifecycle.\n+ * This is useful, since the library a native symbol refers to can be <em>unloaded<\/em>, thus invalidating the native symbol.\n+ * While native symbols are typically obtained using a {@link SymbolLookup#lookup(String) symbol lookup}, it is also possible to obtain an\n+ * <em>anonymous<\/em> native symbol, in the form of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub},\n+ * that is, a reference to a dynamically-generated native symbol which can be used to call back into Java code.\n+ *\/\n+sealed public interface NativeSymbol extends Addressable permits NativeSymbolImpl {\n+\n+    \/**\n+     * Returns the name of this symbol.\n+     * @return the name of this symbol.\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Returns the resource scope associated with this symbol.\n+     * @return the resource scope associated with this symbol.\n+     *\/\n+    ResourceScope scope();\n+\n+    \/**\n+     * Returns the memory address associated with this symbol.\n+     * @throws IllegalStateException if the scope associated with this symbol has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @return The memory address associated with this symbol.\n+     *\/\n+    @Override\n+    MemoryAddress address();\n+\n+    \/**\n+     * Creates a new symbol from given name, address and scope.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param name the symbol name.\n+     * @param address the symbol address.\n+     * @param scope the symbol scope.\n+     * @return A new symbol from given name, address and scope.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static NativeSymbol ofAddress(String name, MemoryAddress address, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return new NativeSymbolImpl(name, address, scope);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeSymbol.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-     * @return the symbol (if any).\n+     * @return the lookup symbol (if any).\n@@ -54,1 +54,1 @@\n-    Optional<MemoryAddress> lookup(String name);\n+    Optional<NativeSymbol> lookup(String name);\n@@ -79,1 +79,1 @@\n-            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(addr);\n+            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, ResourceScope.globalScope()));\n@@ -82,0 +82,1 @@\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n- * is made available by the {@link jdk.incubator.foreign.CLinker.UpcallStub} instance returned by that method.\n+ * is made available by the {@link jdk.incubator.foreign.NativeSymbol} instance returned by that method.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,13 @@\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+\n+public record NativeSymbolImpl(String name, MemoryAddress address, ResourceScope scope) implements NativeSymbol, Scoped {\n+    @Override\n+    public MemoryAddress address() {\n+        ((ResourceScopeImpl)scope).checkValidState();\n+        return address;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -73,1 +74,1 @@\n-            MemorySegment funcs = MemorySegment.ofAddressNative(fallbackLibLookup.lookup(\"funcs\").orElseThrow(),\n+            MemorySegment funcs = MemorySegment.ofAddressNative(fallbackLibLookup.lookup(\"funcs\").orElseThrow().address(),\n@@ -77,1 +78,1 @@\n-                .map(symbol -> funcs.getAtIndex(ADDRESS, symbol.ordinal()));\n+                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), ResourceScope.globalScope()));\n@@ -93,1 +94,2 @@\n-                        Optional.empty() : Optional.of(MemoryAddress.ofLong(addr));\n+                        Optional.empty() :\n+                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), ResourceScope.globalScope()));\n@@ -101,1 +103,1 @@\n-    public Optional<MemoryAddress> lookup(String name) {\n+    public Optional<NativeSymbol> lookup(String name) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n@@ -32,0 +30,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -35,1 +34,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -90,1 +88,1 @@\n-    public static CLinker.UpcallStub make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, ResourceScope scope) {\n+    public static NativeSymbol make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, ResourceScope scope) {\n@@ -136,1 +134,1 @@\n-        return new UpcallStubs.UpcallStubImpl(entryPoint, callingSequence.functionDesc(), target, scope);\n+        return UpcallStubs.makeUpcall(entryPoint, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n@@ -30,0 +28,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -31,1 +30,1 @@\n-import jdk.internal.foreign.Scoped;\n+import jdk.internal.foreign.NativeSymbolImpl;\n@@ -34,2 +33,0 @@\n-import java.lang.invoke.MethodHandle;\n-\n@@ -54,17 +51,8 @@\n-\n-    \/\/ where\n-    public record UpcallStubImpl(long entry, FunctionDescriptor descriptor, MethodHandle target, ResourceScope scope) implements Scoped, CLinker.UpcallStub {\n-        public UpcallStubImpl {\n-            ((ResourceScopeImpl)scope).addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n-                @Override\n-                public void cleanup() {\n-                    freeUpcallStub(entry);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        public MemoryAddress address() {\n-            ((ResourceScopeImpl)scope).checkValidStateSlow();\n-            return MemoryAddress.ofLong(entry);\n-        }\n+    static NativeSymbol makeUpcall(long entry, ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                freeUpcallStub(entry);\n+            }\n+        });\n+        return new NativeSymbolImpl(\"\", MemoryAddress.ofLong(entry), scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":10,"deletions":22,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -141,1 +141,1 @@\n-    public static CLinker.UpcallStub arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -37,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -75,1 +73,1 @@\n-    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -37,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -75,1 +73,1 @@\n-    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -136,1 +136,1 @@\n-    public static CLinker.UpcallStub arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -37,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -85,1 +83,1 @@\n-    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -136,1 +136,1 @@\n-    public static CLinker.UpcallStub arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -34,1 +34,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -36,1 +35,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -86,1 +84,1 @@\n-    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -34,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -46,1 +46,0 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -90,1 +89,1 @@\n-        CLinker.UpcallStub upcall;\n+        NativeSymbol upcall;\n@@ -137,1 +136,1 @@\n-            CLinker.UpcallStub upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n@@ -142,1 +141,1 @@\n-    CLinker.UpcallStub scopeChecker(ResourceScope scope) {\n+    NativeSymbol scopeChecker(ResourceScope scope) {\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-        final static MemoryAddress printfAddr = abi.lookup(\"printf\").get();\n+        final static NativeSymbol printfAddr = abi.lookup(\"printf\").get();\n@@ -282,1 +282,1 @@\n-                CLinker.UpcallStub qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, scope);\n+                NativeSymbol qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, scope);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -66,1 +67,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -93,1 +94,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -90,1 +91,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(name).get();\n+            NativeSymbol ma = LOOKUP.lookup(name).get();\n@@ -99,1 +100,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(\"empty\").get();\n+            NativeSymbol ma = LOOKUP.lookup(\"empty\").get();\n@@ -114,1 +115,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(\"identity_va\").get();\n+            NativeSymbol ma = LOOKUP.lookup(\"identity_va\").get();\n@@ -127,1 +128,1 @@\n-                MemoryAddress ma = LOOKUP.lookup(\"invoke_high_arity\" + i).get();\n+                NativeSymbol ma = LOOKUP.lookup(\"invoke_high_arity\" + i).get();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -165,0 +166,2 @@\n+        \/\/ native symbol\n+        ScopedOperation.of(scope -> NativeSymbol.ofAddress(\"\", MemoryAddress.NULL, scope), NativeSymbol::address, \"NativeSymbol::address\");\n@@ -194,0 +197,4 @@\n+        static <Z> void of(Function<ResourceScope, Z> factory, Consumer<Z> consumer, String name) {\n+            scopedOperations.add(new ScopedOperation<>(factory, consumer, name));\n+        }\n+\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        MemorySegment segment = MemorySegment.ofAddressNative(LOOKUP.lookup(\"c\").get(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddressNative(LOOKUP.lookup(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -96,1 +97,1 @@\n-    static CLinker.UpcallStub dummyStub;\n+    static NativeSymbol dummyStub;\n@@ -114,1 +115,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -133,1 +134,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -150,1 +151,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -161,1 +162,1 @@\n-            CLinker.UpcallStub callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n+            NativeSymbol callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n@@ -190,1 +191,1 @@\n-            MemoryAddress invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n@@ -217,1 +218,1 @@\n-    static CLinker.UpcallStub makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -106,1 +107,1 @@\n-            CLinker.UpcallStub upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -96,1 +97,1 @@\n-            CLinker.UpcallStub upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -67,1 +68,1 @@\n-    static final MemoryAddress VARARGS_ADDR =\n+    static final NativeSymbol VARARGS_ADDR =\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -70,1 +71,1 @@\n-            CLinker.UpcallStub stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -113,0 +112,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -151,1 +151,1 @@\n-            CLinker.UpcallStub stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -113,0 +112,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -150,1 +150,1 @@\n-            CLinker.UpcallStub stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-            CLinker.UpcallStub stub = abi.upcallStub(callback, desc, scope);\n+            NativeSymbol stub = abi.upcallStub(callback, desc, scope);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -131,1 +131,1 @@\n-    static CLinker.UpcallStub makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+    static NativeSymbol makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}