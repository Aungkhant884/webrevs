{"files":[{"patch":"@@ -31,1 +31,1 @@\n- * {@link MemoryAddress}, {@link VaList} and {@link CLinker.UpcallStub}.\n+ * {@link MemoryAddress}, {@link VaList} and {@link NativeSymbol}.\n@@ -40,1 +40,1 @@\n-public sealed interface Addressable permits MemorySegment, MemoryAddress, CLinker.UpcallStub, VaList {\n+public sealed interface Addressable permits MemorySegment, MemoryAddress, NativeSymbol, VaList {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -71,1 +70,1 @@\n- * Arguments of type {@link MemorySegment}, {@link VaList} and {@link UpcallStub} passed by-reference to a downcall method handle\n+ * Arguments of type {@link MemorySegment}, {@link VaList} and {@link NativeSymbol} passed by-reference to a downcall method handle\n@@ -80,1 +79,1 @@\n- * Finally, downcall method handles feature a leading parameter of type {@link Addressable}, from which the\n+ * Finally, downcall method handles feature a leading parameter of type {@link NativeSymbol}, from which the\n@@ -109,3 +108,3 @@\n- * Upcall stubs are modelled by instances of type {@link UpcallStub}; upcall stubs can be passed by reference to other\n- * downcall method handles (as {@link UpcallStub} implements the {@link Addressable} interface) and,\n- * when no longer required, they can be {@link ResourceScope#close() released}, via their {@linkplain UpcallStub#scope() scope}.\n+ * Upcall stubs are modelled by instances of type {@link NativeSymbol}; upcall stubs can be passed by reference to other\n+ * downcall method handles (as {@link NativeSymbol} implements the {@link Addressable} interface) and,\n+ * when no longer required, they can be {@link ResourceScope#close() released}, via their {@linkplain NativeSymbol#scope() scope}.\n@@ -149,1 +148,1 @@\n-    default Optional<MemoryAddress> lookup(String name) {\n+    default Optional<NativeSymbol> lookup(String name) {\n@@ -155,1 +154,1 @@\n-     * which can be used to call a target foreign function at the given address.\n+     * which can be used to call a target foreign function at the address in the given native symbol.\n@@ -174,1 +173,1 @@\n-    default MethodHandle downcallHandle(Addressable symbol, FunctionDescriptor function) {\n+    default MethodHandle downcallHandle(NativeSymbol symbol, FunctionDescriptor function) {\n@@ -181,3 +180,3 @@\n-     * used to call a target foreign function at an address.\n-     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the address, of\n-     * type {@link Addressable}.\n+     * used to call a target foreign function at the address in a dynamically provided native symbol.\n+     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the foreign function\n+     * entry point, of type {@link NativeSymbol}.\n@@ -189,2 +188,2 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the target address passed to it is\n-     * {@link MemoryAddress#NULL}, or a {@link NullPointerException} if the target address is {@code null}.\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the native symbol passed to it is\n+     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if the native symbol is {@code null}.\n@@ -218,1 +217,1 @@\n-     * @return the native stub segment.\n+     * @return the native stub symbol.\n@@ -225,37 +224,1 @@\n-    UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n-\n-    \/**\n-     * An upcall stub is a pointer to a stub of code which can be passed to native functions to call a given <em>target<\/em> Java method handle.\n-     * Created by {@link #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}, an upcall stub can be passed by\n-     * reference to other downcall method handles, as this interface extends {@link Addressable}.\n-     * When no longer required, resources associated with an upcall stub can be {@link ResourceScope#close() released},\n-     * via its {@linkplain UpcallStub#scope() scope}.\n-     *\/\n-    sealed interface UpcallStub extends Addressable permits UpcallStubs.UpcallStubImpl {\n-        \/**\n-         * Obtains the function descriptor with which this upcall stub was {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) created}.\n-         * @return the function descriptor with which this upcall stub was {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) created}.\n-         *\/\n-        FunctionDescriptor descriptor();\n-\n-        \/**\n-         * Obtains the target Java method handle invoked by this upcall stub.\n-         * @return the target Java method handle invoked by this upcall stub.\n-         *\/\n-        MethodHandle target();\n-\n-        \/**\n-         * Returns the resource scope associated with this instance.\n-         * @return the resource scope associated with this instance.\n-         *\/\n-        ResourceScope scope();\n-\n-        \/**\n-         * Returns the memory address associated with this upcall stub.\n-         * @throws IllegalStateException if the scope associated with this upcall stub has been closed, or if access occurs from\n-         * a thread other than the thread owning that scope.\n-         * @return The memory address associated with this upcall stub.\n-         *\/\n-        @Override\n-        MemoryAddress address();\n-    }\n+    NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":15,"deletions":52,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.NativeSymbolImpl;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Objects;\n+\n+\/**\n+ * A native symbol models a reference to a location (typically the entry point of a function) in a native library.\n+ * A native symbol has a name, and is associated with a scope, which governs the native symbol's lifecycle.\n+ * This is useful, since the library a native symbol refers to can be <em>unloaded<\/em>, thus invalidating the native symbol.\n+ * While native symbols are typically obtained using a {@link SymbolLookup#lookup(String) symbol lookup}, it is also possible to obtain an\n+ * <em>anonymous<\/em> native symbol, in the form of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub},\n+ * that is, a reference to a dynamically-generated native symbol which can be used to call back into Java code.\n+ *\/\n+sealed public interface NativeSymbol extends Addressable permits NativeSymbolImpl {\n+\n+    \/**\n+     * Returns the name of this symbol.\n+     * @return the name of this symbol.\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Returns the resource scope associated with this symbol.\n+     * @return the resource scope associated with this symbol.\n+     *\/\n+    ResourceScope scope();\n+\n+    \/**\n+     * Returns the memory address associated with this symbol.\n+     * @throws IllegalStateException if the scope associated with this symbol has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @return The memory address associated with this symbol.\n+     *\/\n+    @Override\n+    MemoryAddress address();\n+\n+    \/**\n+     * Creates a new symbol from given name, address and scope.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param name the symbol name.\n+     * @param address the symbol address.\n+     * @param scope the symbol scope.\n+     * @return A new symbol from given name, address and scope.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static NativeSymbol ofAddress(String name, MemoryAddress address, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(name);\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n+        return new NativeSymbolImpl(name, address, scope);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeSymbol.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-     * @return the symbol (if any).\n+     * @return the lookup symbol (if any).\n@@ -54,1 +54,1 @@\n-    Optional<MemoryAddress> lookup(String name);\n+    Optional<NativeSymbol> lookup(String name);\n@@ -79,1 +79,1 @@\n-            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(addr);\n+            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, ResourceScope.globalScope()));\n@@ -82,0 +82,1 @@\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n- * is made available by the {@link jdk.incubator.foreign.CLinker.UpcallStub} instance returned by that method.\n+ * is made available by the {@link jdk.incubator.foreign.NativeSymbol} instance returned by that method.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+\n+public record NativeSymbolImpl(String name, MemoryAddress address, ResourceScope scope) implements NativeSymbol, Scoped {\n+    @Override\n+    public MemoryAddress address() {\n+        ((ResourceScopeImpl)scope).checkValidState();\n+        return address;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -73,1 +74,1 @@\n-            MemorySegment funcs = MemorySegment.ofAddressNative(fallbackLibLookup.lookup(\"funcs\").orElseThrow(),\n+            MemorySegment funcs = MemorySegment.ofAddressNative(fallbackLibLookup.lookup(\"funcs\").orElseThrow().address(),\n@@ -77,1 +78,1 @@\n-                .map(symbol -> funcs.getAtIndex(ADDRESS, symbol.ordinal()));\n+                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), ResourceScope.globalScope()));\n@@ -93,1 +94,2 @@\n-                        Optional.empty() : Optional.of(MemoryAddress.ofLong(addr));\n+                        Optional.empty() :\n+                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), ResourceScope.globalScope()));\n@@ -101,1 +103,1 @@\n-    public Optional<MemoryAddress> lookup(String name) {\n+    public Optional<NativeSymbol> lookup(String name) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -89,1 +90,1 @@\n-                    methodType(Object.class, Addressable.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n+                    methodType(Object.class, NativeSymbol.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n@@ -92,1 +93,1 @@\n-            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, Addressable.class));\n+            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, NativeSymbol.class));\n@@ -174,1 +175,1 @@\n-    private static long unboxTargetAddress(Addressable addr) {\n+    private static long unboxTargetAddress(NativeSymbol addr) {\n@@ -314,1 +315,1 @@\n-    Object invokeInterpBindings(Addressable address, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n+    Object invokeInterpBindings(NativeSymbol symbol, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n@@ -323,1 +324,1 @@\n-            leafArgs[0] = address; \/\/ addr\n+            leafArgs[0] = symbol; \/\/ symbol\n@@ -328,1 +329,1 @@\n-                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip addr\n+                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip symbol\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n@@ -32,0 +30,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -35,1 +34,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -90,1 +88,1 @@\n-    public static CLinker.UpcallStub make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, ResourceScope scope) {\n+    public static NativeSymbol make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, ResourceScope scope) {\n@@ -136,1 +134,1 @@\n-        return new UpcallStubs.UpcallStubImpl(entryPoint, callingSequence.functionDesc(), target, scope);\n+        return UpcallStubs.makeUpcall(entryPoint, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -389,1 +390,1 @@\n-        \/\/ downcalls get the leading Addressable\/SegmentAllocator param as well\n+        \/\/ downcalls get the leading NativeSymbol\/SegmentAllocator param as well\n@@ -391,2 +392,2 @@\n-            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(Addressable.class));\n-            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, Addressable, SegmentAllocator) -> V\/void\n+            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(NativeSymbol.class));\n+            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, NativeSymbol, SegmentAllocator) -> V\/void\n@@ -395,1 +396,1 @@\n-        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, Addressable?, BindingContext) -> V\/void\n+        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, NativeSymbol?, BindingContext) -> V\/void\n@@ -514,1 +515,1 @@\n-            if (ptype == Addressable.class) {\n+            if (ptype == Addressable.class || ptype == NativeSymbol.class) {\n@@ -527,1 +528,1 @@\n-                adapterType = adapterType.appendParameterTypes(Addressable.class);\n+                adapterType = adapterType.appendParameterTypes(i == 0 ? NativeSymbol.class : Addressable.class);\n@@ -538,1 +539,0 @@\n-            \/\/ acquire\/release target addressable\n@@ -567,1 +567,1 @@\n-    public static void checkSymbol(Addressable symbol) {\n+    public static void checkSymbol(NativeSymbol symbol) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n@@ -30,0 +28,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -31,1 +30,1 @@\n-import jdk.internal.foreign.Scoped;\n+import jdk.internal.foreign.NativeSymbolImpl;\n@@ -34,2 +33,0 @@\n-import java.lang.invoke.MethodHandle;\n-\n@@ -54,17 +51,8 @@\n-\n-    \/\/ where\n-    public record UpcallStubImpl(long entry, FunctionDescriptor descriptor, MethodHandle target, ResourceScope scope) implements Scoped, CLinker.UpcallStub {\n-        public UpcallStubImpl {\n-            ((ResourceScopeImpl)scope).addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n-                @Override\n-                public void cleanup() {\n-                    freeUpcallStub(entry);\n-                }\n-            });\n-        }\n-\n-        @Override\n-        public MemoryAddress address() {\n-            ((ResourceScopeImpl)scope).checkValidStateSlow();\n-            return MemoryAddress.ofLong(entry);\n-        }\n+    static NativeSymbol makeUpcall(long entry, ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                freeUpcallStub(entry);\n+            }\n+        });\n+        return new NativeSymbolImpl(\"upcall:\" + Long.toHexString(entry), MemoryAddress.ofLong(entry), scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":10,"deletions":22,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -141,1 +141,1 @@\n-    public static CLinker.UpcallStub arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -37,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -75,1 +73,1 @@\n-    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -37,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -75,1 +73,1 @@\n-    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -136,1 +136,1 @@\n-    public static CLinker.UpcallStub arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -35,1 +35,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -37,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -85,1 +83,1 @@\n-    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -136,1 +136,1 @@\n-    public static CLinker.UpcallStub arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -34,1 +34,0 @@\n-import jdk.internal.foreign.ResourceScopeImpl;\n@@ -36,1 +35,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -86,1 +84,1 @@\n-    public final UpcallStub upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -450,2 +451,2 @@\n-    MethodHandle downcallHandle(CLinker abi, Addressable addr, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n-        MethodHandle mh = abi.downcallHandle(addr, descriptor);\n+    MethodHandle downcallHandle(CLinker abi, NativeSymbol symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n+        MethodHandle mh = abi.downcallHandle(symbol, descriptor);\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -34,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -46,1 +46,0 @@\n-import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -90,1 +89,1 @@\n-        CLinker.UpcallStub upcall;\n+        NativeSymbol upcall;\n@@ -137,1 +136,1 @@\n-            CLinker.UpcallStub upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n@@ -142,1 +141,1 @@\n-    CLinker.UpcallStub scopeChecker(ResourceScope scope) {\n+    NativeSymbol scopeChecker(ResourceScope scope) {\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -183,1 +183,1 @@\n-        final static MemoryAddress printfAddr = abi.lookup(\"printf\").get();\n+        final static NativeSymbol printfAddr = abi.lookup(\"printf\").get();\n@@ -282,1 +282,1 @@\n-                CLinker.UpcallStub qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, scope);\n+                NativeSymbol qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, scope);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -66,1 +67,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -93,1 +94,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -109,2 +110,2 @@\n-    Object doCall(Addressable addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n-        MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n+    Object doCall(NativeSymbol symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+        MethodHandle mh = downcallHandle(abi, symbol, allocator, descriptor);\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -43,1 +45,1 @@\n-    private static final MemoryAddress DUMMY_TARGET = MemoryAddress.ofLong(1);\n+    private static final NativeSymbol DUMMY_TARGET = NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -90,1 +91,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(name).get();\n+            NativeSymbol ma = LOOKUP.lookup(name).get();\n@@ -99,1 +100,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(\"empty\").get();\n+            NativeSymbol ma = LOOKUP.lookup(\"empty\").get();\n@@ -114,1 +115,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(\"identity_va\").get();\n+            NativeSymbol ma = LOOKUP.lookup(\"identity_va\").get();\n@@ -127,1 +128,1 @@\n-                MemoryAddress ma = LOOKUP.lookup(\"invoke_high_arity\" + i).get();\n+                NativeSymbol ma = LOOKUP.lookup(\"invoke_high_arity\" + i).get();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -48,1 +50,1 @@\n-                MemoryAddress.NULL,\n+                NativeSymbol.ofAddress(\"nullAddress\", MemoryAddress.NULL, ResourceScope.globalScope()),\n@@ -56,1 +58,1 @@\n-        mh.invokeExact((Addressable) MemoryAddress.NULL);\n+        mh.invokeExact(NativeSymbol.ofAddress(\"null\", MemoryAddress.NULL, ResourceScope.globalScope()));\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,1 +105,2 @@\n-            ResourceScope.class\n+            ResourceScope.class,\n+            NativeSymbol.class\n@@ -190,0 +191,1 @@\n+        addDefaultMapping(NativeSymbol.class, NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope()));\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -165,0 +166,2 @@\n+        \/\/ native symbol\n+        ScopedOperation.of(scope -> NativeSymbol.ofAddress(\"\", MemoryAddress.NULL, scope), NativeSymbol::address, \"NativeSymbol::address\");\n@@ -194,0 +197,4 @@\n+        static <Z> void of(Function<ResourceScope, Z> factory, Consumer<Z> consumer, String name) {\n+            scopedOperations.add(new ScopedOperation<>(factory, consumer, name));\n+        }\n+\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-        MemorySegment segment = MemorySegment.ofAddressNative(LOOKUP.lookup(\"c\").get(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddressNative(LOOKUP.lookup(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -96,1 +97,1 @@\n-    static CLinker.UpcallStub dummyStub;\n+    static NativeSymbol dummyStub;\n@@ -114,1 +115,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -133,1 +134,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -150,1 +151,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -161,1 +162,1 @@\n-            CLinker.UpcallStub callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n+            NativeSymbol callback = abi.upcallStub(mh, callbackDesc, scope.scope());\n@@ -190,1 +191,1 @@\n-            MemoryAddress invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n@@ -217,1 +218,1 @@\n-    static CLinker.UpcallStub makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -106,1 +107,1 @@\n-            CLinker.UpcallStub upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -96,1 +97,1 @@\n-            CLinker.UpcallStub upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -67,1 +68,1 @@\n-    static final MemoryAddress VARARGS_ADDR =\n+    static final NativeSymbol VARARGS_ADDR =\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -70,1 +71,1 @@\n-            CLinker.UpcallStub stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -113,0 +112,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -151,1 +151,1 @@\n-            CLinker.UpcallStub stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -113,0 +112,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -150,1 +150,1 @@\n-            CLinker.UpcallStub stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-            CLinker.UpcallStub stub = abi.upcallStub(callback, desc, scope);\n+            NativeSymbol stub = abi.upcallStub(callback, desc, scope);\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -50,3 +51,3 @@\n-    static final Addressable funcA;\n-    static final Addressable funcB;\n-    static final Addressable funcC;\n+    static final NativeSymbol funcA;\n+    static final NativeSymbol funcB;\n+    static final NativeSymbol funcC;\n@@ -74,1 +75,1 @@\n-        int x = (int) func.invokeExact((Addressable) null);\n+        int x = (int) func.invokeExact((NativeSymbol) null);\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -28,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -31,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -46,1 +45,1 @@\n-    static Addressable func_addr;\n+    static NativeSymbol func_addr;\n@@ -49,1 +48,1 @@\n-    static Addressable identity_addr;\n+    static NativeSymbol identity_addr;\n@@ -52,1 +51,1 @@\n-    static Addressable identity_struct_addr;\n+    static NativeSymbol identity_struct_addr;\n@@ -55,1 +54,1 @@\n-    static Addressable identity_struct_3_addr;\n+    static NativeSymbol identity_struct_3_addr;\n@@ -58,1 +57,1 @@\n-    static Addressable identity_memory_address_addr;\n+    static NativeSymbol identity_memory_address_addr;\n@@ -61,1 +60,1 @@\n-    static Addressable identity_memory_address_3_addr;\n+    static NativeSymbol identity_memory_address_3_addr;\n@@ -64,1 +63,1 @@\n-    static Addressable args1_addr;\n+    static NativeSymbol args1_addr;\n@@ -67,1 +66,1 @@\n-    static Addressable args2_addr;\n+    static NativeSymbol args2_addr;\n@@ -70,1 +69,1 @@\n-    static Addressable args3_addr;\n+    static NativeSymbol args3_addr;\n@@ -73,1 +72,1 @@\n-    static Addressable args4_addr;\n+    static NativeSymbol args4_addr;\n@@ -76,1 +75,1 @@\n-    static Addressable args5_addr;\n+    static NativeSymbol args5_addr;\n@@ -79,1 +78,1 @@\n-    static Addressable args10_addr;\n+    static NativeSymbol args10_addr;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -59,2 +60,2 @@\n-    static final Addressable native_compar;\n-    static final Addressable panama_upcall_compar;\n+    static final NativeSymbol native_compar;\n+    static final NativeSymbol panama_upcall_compar;\n@@ -66,1 +67,1 @@\n-    static Addressable qsort_addr = abi.lookup(\"qsort\").get();\n+    static NativeSymbol qsort_addr = abi.lookup(\"qsort\").get();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -60,4 +60,4 @@\n-    static final Addressable cb_blank;\n-    static final Addressable cb_identity;\n-    static final Addressable cb_args5;\n-    static final Addressable cb_args10;\n+    static final NativeSymbol cb_blank;\n+    static final NativeSymbol cb_identity;\n+    static final NativeSymbol cb_args5;\n+    static final NativeSymbol cb_args10;\n@@ -86,1 +86,1 @@\n-                blank = linkFunc(name, mt, fd);\n+                blank = linkFunc(name, fd);\n@@ -94,1 +94,1 @@\n-                identity = linkFunc(name, mt, fd);\n+                identity = linkFunc(name, fd);\n@@ -104,1 +104,1 @@\n-                args5 = linkFunc(name, mt, fd);\n+                args5 = linkFunc(name, fd);\n@@ -116,1 +116,1 @@\n-                args10 = linkFunc(name, mt, fd);\n+                args10 = linkFunc(name, fd);\n@@ -124,1 +124,1 @@\n-    static MethodHandle linkFunc(String name, MethodType baseType, FunctionDescriptor baseDesc) {\n+    static MethodHandle linkFunc(String name, FunctionDescriptor baseDesc) {\n@@ -131,1 +131,1 @@\n-    static CLinker.UpcallStub makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+    static NativeSymbol makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"}]}