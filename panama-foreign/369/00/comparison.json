{"files":[{"patch":"@@ -639,1 +639,0 @@\n-    ExceptionHandlingMark ehm(thread);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -229,2 +229,0 @@\n-  \/* support for Panama *\/                                                                                      \\\n-  do_klass(ScopedAccessError_klass,                     jdk_internal_misc_ScopedMemoryAccess_Scope_ScopedAccessError) \\\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,0 @@\n-  template(jdk_internal_misc_ScopedMemoryAccess_Scope_ScopedAccessError, \"jdk\/internal\/misc\/ScopedMemoryAccess$Scope$ScopedAccessError\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -379,1 +379,0 @@\n-    ExceptionHandlingMark ehm(thread);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1423,1 +1423,0 @@\n-    ExceptionHandlingMark ehm(thread);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+  jboolean _found;\n+\n@@ -56,1 +58,2 @@\n-    , _exception(exception) {}\n+    , _exception(exception)\n+    , _found(false) {}\n@@ -102,3 +105,1 @@\n-              if (!jt->is_exception_handling()) {\n-                jt->install_async_exception(JNIHandles::resolve(_exception));\n-              }\n+              _found = true;\n@@ -129,1 +130,1 @@\n-JVM_ENTRY(void, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception)) {\n+JVM_ENTRY(jboolean, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception)) {\n@@ -132,0 +133,1 @@\n+  return !cl._found;\n@@ -146,1 +148,1 @@\n-    {CC \"closeScope0\",   CC \"(\" SCOPE SCOPED_ERR \")V\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+    {CC \"closeScope0\",   CC \"(\" SCOPE SCOPED_ERR \")Z\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -70,4 +70,1 @@\n-   JVM_ENTRY(static result_type, header) \\\n-   if (JavaThread::thread_from_jni_environment(env)->has_async_exception()) { \\\n-     return (result_type)0; \\\n-   } else\n+  JVM_ENTRY(static result_type, header)\n@@ -1054,0 +1051,1 @@\n+\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -163,4 +163,1 @@\n-  UnrollBlock* result = fetch_unroll_info_helper(thread, exec_mode);\n-  thread->check_and_handle_async_exceptions(true);\n-\n-  return result;\n+  return fetch_unroll_info_helper(thread, exec_mode);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1705,1 +1705,0 @@\n-  _is_exception_handling = false;\n@@ -2410,1 +2409,1 @@\n-void JavaThread::install_async_exception(oop java_throwable)  {\n+void JavaThread::send_thread_stop(oop java_throwable)  {\n@@ -2450,1 +2449,0 @@\n-}\n@@ -2452,2 +2450,1 @@\n-void JavaThread::send_thread_stop(oop java_throwable) {\n-  this->install_async_exception(java_throwable);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1207,1 +1207,0 @@\n-  bool             _is_exception_handling;\n@@ -1473,2 +1472,0 @@\n-  void install_async_exception(oop throwable);\n-\n@@ -1574,3 +1571,0 @@\n-  bool is_exception_handling() const             { return _is_exception_handling; }\n-  void set_is_exception_handling(bool val)       { _is_exception_handling = val; }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -76,1 +76,0 @@\n-       _pending_exception->klass() != SystemDictionary::ScopedAccessError_klass() &&\n@@ -526,10 +525,0 @@\n-\/\/ Implementation of ExceptionHandlingMark\n-\n-ExceptionHandlingMark::ExceptionHandlingMark(JavaThread* jt) : _jt(jt) {\n-  jt->set_is_exception_handling(true);\n-}\n-\n-ExceptionHandlingMark::~ExceptionHandlingMark() {\n-  _jt->set_is_exception_handling(false);\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-class JavaThread;\n@@ -342,9 +341,0 @@\n-class ExceptionHandlingMark {\n-private:\n-  JavaThread* _jt;\n-\n-public:\n-  ExceptionHandlingMark(JavaThread* jt);\n-  ~ExceptionHandlingMark();\n-};\n-\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-    public void closeScope(Scope scope) {\n-        closeScope0(scope, Scope.ScopedAccessError.INSTANCE);\n+    public boolean closeScope(Scope scope) {\n+        return closeScope0(scope, Scope.ScopedAccessError.INSTANCE);\n@@ -83,1 +83,1 @@\n-    native void closeScope0(Scope scope, Scope.ScopedAccessError exception);\n+    native boolean closeScope0(Scope scope, Scope.ScopedAccessError exception);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,0 +191,7 @@\n+ * <p>\n+ * When using shared segments, clients should make sure that no other thread is accessing the segment while\n+ * the segment is being closed. If one or more threads attempts to access a segment concurrently while the\n+ * segment is being closed, an exception might occur on both the accessing and the closing threads. Clients should\n+ * refrain from attempting to close a segment repeatedly (e.g. keep calling {@link #close()} until no exception is thrown);\n+ * such exceptions should instead be seen as an indication that the client code is lacking appropriate synchronization between the threads\n+ * accessing\/closing the segment.\n@@ -390,1 +397,2 @@\n-     * thread owning this segment.\n+     * thread owning this segment, or if this segment is shared and the segment is concurrently accessed while this method is\n+     * called.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -89,10 +89,0 @@\n-    protected boolean closed; \/\/ = false\n-    private static final VarHandle CLOSED;\n-\n-    static {\n-        try {\n-            CLOSED = MethodHandles.lookup().findVarHandle(MemoryScope.class, \"closed\", boolean.class);\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n@@ -183,3 +173,1 @@\n-    final boolean isAlive() {\n-        return !((boolean)CLOSED.getVolatile(this));\n-    }\n+    public abstract boolean isAlive();\n@@ -199,12 +187,0 @@\n-    \/**\n-     * Checks that this scope is still alive (see {@link #isAlive()}), by performing\n-     * a quick, plain access. As such, this method should be used with care.\n-     * @throws ScopedAccessError if this scope is already closed.\n-     *\/\n-    @ForceInline\n-    private static void checkAliveRaw(MemoryScope scope) {\n-        if (scope.closed) {\n-            throw ScopedAccessError.INSTANCE;\n-        }\n-    }\n-\n@@ -219,0 +195,1 @@\n+        private boolean closed; \/\/ = false\n@@ -231,1 +208,8 @@\n-            checkAliveRaw(this);\n+            if (closed) {\n+                throw ScopedAccessError.INSTANCE;\n+            }\n+        }\n+\n+        @Override\n+        public boolean isAlive() {\n+            return !closed;\n@@ -267,0 +251,16 @@\n+        final static int ALIVE = 0;\n+        final static int CLOSING = 1;\n+        final static int CLOSED = 2;\n+\n+        int state = ALIVE;\n+\n+        private static final VarHandle STATE;\n+\n+        static {\n+            try {\n+                STATE = MethodHandles.lookup().findVarHandle(SharedScope.class, \"state\", int.class);\n+            } catch (Throwable ex) {\n+                throw new ExceptionInInitializerError(ex);\n+            }\n+        }\n+\n@@ -278,1 +278,3 @@\n-            MemoryScope.checkAliveRaw(this);\n+            if (state != ALIVE) {\n+                throw ScopedAccessError.INSTANCE;\n+            }\n@@ -282,1 +284,1 @@\n-            if (!CLOSED.compareAndSet(this, false, true)) {\n+            if (!STATE.compareAndSet(this, ALIVE, CLOSING)) {\n@@ -285,1 +287,10 @@\n-            SCOPED_MEMORY_ACCESS.closeScope(this);\n+            boolean success = SCOPED_MEMORY_ACCESS.closeScope(this);\n+            STATE.setVolatile(this, success ? CLOSED : ALIVE);\n+            if (!success) {\n+                throw new IllegalStateException(\"Cannot close while another thread is accessing the segment\");\n+            }\n+        }\n+\n+        @Override\n+        public boolean isAlive() {\n+            return (int)STATE.getVolatile(this) != CLOSED;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":40,"deletions":29,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    static final int ITERATIONS = 10;\n+    static final int ITERATIONS = 5;\n@@ -57,0 +57,1 @@\n+    static final int MAX_THREAD_SPIN_WAIT_MILLIS = 200;\n@@ -75,2 +76,1 @@\n-    static class SegmentAccessor implements Runnable {\n-\n+    static abstract class AbstractSegmentAccessor implements Runnable {\n@@ -79,1 +79,1 @@\n-        SegmentAccessor(MemorySegment segment) {\n+        AbstractSegmentAccessor(MemorySegment segment) {\n@@ -84,7 +84,7 @@\n-        public void run() {\n-            try {\n-                while (true) {\n-                    int sum = 0;\n-                    for (int i = 0; i < segment.byteSize(); i++) {\n-                        sum += MemoryAccess.getByteAtIndex(segment, i);\n-                    }\n+        public final void run() {\n+            outer: while (segment.isAlive()) {\n+                try {\n+                    doAccess();\n+                } catch (IllegalStateException ex) {\n+                    backoff();\n+                    continue outer;\n@@ -92,2 +92,10 @@\n-            } catch (IllegalStateException ex) {\n-                \/\/ do nothing\n+            }\n+        }\n+\n+        abstract void doAccess();\n+\n+        private void backoff() {\n+            try {\n+                Thread.sleep(ThreadLocalRandom.current().nextInt(MAX_THREAD_SPIN_WAIT_MILLIS));\n+            } catch (InterruptedException ex) {\n+                throw new AssertionError(ex);\n@@ -98,1 +106,2 @@\n-    static class SegmentCopyAccessor implements Runnable {\n+    static abstract class AbstractBufferAccessor extends AbstractSegmentAccessor {\n+        final ByteBuffer bb;\n@@ -100,1 +109,5 @@\n-        final MemorySegment segment;\n+        AbstractBufferAccessor(MemorySegment segment) {\n+            super(segment);\n+            this.bb = segment.asByteBuffer();\n+        }\n+    }\n@@ -102,2 +115,4 @@\n-        SegmentCopyAccessor(MemorySegment segment) {\n-            this.segment = segment;\n+    static class SegmentAccessor extends AbstractSegmentAccessor {\n+\n+        SegmentAccessor(MemorySegment segment) {\n+            super(segment);\n@@ -107,12 +122,4 @@\n-        public void run() {\n-            try {\n-                long split = segment.byteSize() \/ 2;\n-                MemorySegment first = segment.asSlice(0, split);\n-                MemorySegment second = segment.asSlice(split);\n-                while (true) {\n-                    for (int i = 0; i < segment.byteSize(); i++) {\n-                        first.copyFrom(second);\n-                    }\n-                }\n-            } catch (IllegalStateException ex) {\n-                \/\/ do nothing\n+        void doAccess() {\n+            int sum = 0;\n+            for (int i = 0; i < segment.byteSize(); i++) {\n+                sum += MemoryAccess.getByteAtIndex(segment, i);\n@@ -123,1 +130,3 @@\n-    static class SegmentFillAccessor implements Runnable {\n+    static class SegmentCopyAccessor extends AbstractSegmentAccessor {\n+\n+        MemorySegment first, second;\n@@ -125,1 +134,15 @@\n-        final MemorySegment segment;\n+\n+        SegmentCopyAccessor(MemorySegment segment) {\n+            super(segment);\n+            long split = segment.byteSize() \/ 2;\n+            first = segment.asSlice(0, split);\n+            second = segment.asSlice(split);\n+        }\n+\n+        @Override\n+        public void doAccess() {\n+            first.copyFrom(second);\n+        }\n+    }\n+\n+    static class SegmentFillAccessor extends AbstractSegmentAccessor {\n@@ -128,1 +151,1 @@\n-            this.segment = segment;\n+            super(segment);\n@@ -132,6 +155,2 @@\n-        public void run() {\n-            try {\n-                segment.fill((byte)ThreadLocalRandom.current().nextInt(10));\n-            } catch (IllegalStateException ex) {\n-                \/\/ do nothing\n-            }\n+        public void doAccess() {\n+            segment.fill((byte) ThreadLocalRandom.current().nextInt(10));\n@@ -141,1 +160,1 @@\n-    static class SegmentMismatchAccessor implements Runnable {\n+    static class SegmentMismatchAccessor extends AbstractSegmentAccessor {\n@@ -143,1 +162,0 @@\n-        final MemorySegment segment;\n@@ -147,1 +165,1 @@\n-            this.segment = segment;\n+            super(segment);\n@@ -154,9 +172,2 @@\n-        public void run() {\n-            try {\n-                long l = 0;\n-                while (true) {\n-                    l += segment.mismatch(copy);\n-                }\n-            } catch (IllegalStateException ex) {\n-                \/\/ do nothing\n-            }\n+        public void doAccess() {\n+            segment.mismatch(copy);\n@@ -166,3 +177,1 @@\n-    static class BufferAccessor implements Runnable {\n-\n-        final ByteBuffer bb;\n+    static class BufferAccessor extends AbstractBufferAccessor {\n@@ -171,1 +180,1 @@\n-            this.bb = segment.asByteBuffer();\n+            super(segment);\n@@ -175,10 +184,4 @@\n-        public void run() {\n-            try {\n-                while (true) {\n-                    int sum = 0;\n-                    for (int i = 0; i < bb.capacity(); i++) {\n-                        sum += bb.get(i);\n-                    }\n-                }\n-            } catch (IllegalStateException ex) {\n-                \/\/ do nothing\n+        public void doAccess() {\n+            int sum = 0;\n+            for (int i = 0; i < bb.capacity(); i++) {\n+                sum += bb.get(i);\n@@ -189,1 +192,1 @@\n-    static class BufferHandleAccessor implements Runnable {\n+    static class BufferHandleAccessor extends AbstractBufferAccessor {\n@@ -193,2 +196,0 @@\n-        final ByteBuffer bb;\n-\n@@ -196,1 +197,1 @@\n-            this.bb = segment.asByteBuffer();\n+            super(segment);\n@@ -200,10 +201,4 @@\n-        public void run() {\n-            try {\n-                while (true) {\n-                    int sum = 0;\n-                    for (int i = 0; i < bb.capacity() \/ 2; i++) {\n-                        sum += (short)handle.get(bb, i);\n-                    }\n-                }\n-            } catch (IllegalStateException ex) {\n-                \/\/ do nothing\n+        public void doAccess() {\n+            int sum = 0;\n+            for (int i = 0; i < bb.capacity() \/ 2; i++) {\n+                sum += (short) handle.get(bb, i);\n@@ -225,1 +220,8 @@\n-            segment.close();\n+            while (true) {\n+                try {\n+                    segment.close();\n+                    break;\n+                } catch (IllegalStateException ex) {\n+                    Thread.onSpinWait();\n+                }\n+            }\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":81,"deletions":79,"binary":false,"changes":160,"status":"modified"}]}