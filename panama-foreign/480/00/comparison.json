{"files":[{"patch":"@@ -31,1 +31,1 @@\n- * {@link MemoryAddress}, {@link LibraryLookup.Symbol} and {@link CLinker.VaList}.\n+ * {@link MemoryAddress} and {@link CLinker.VaList}.\n@@ -35,1 +35,1 @@\n- * explicitly permitted types, such as {@link MemorySegment}, {@link MemoryAddress}, {@link LibraryLookup.Symbol}\n+ * explicitly permitted types, such as {@link MemorySegment}, {@link MemoryAddress}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,11 +40,3 @@\n- * All symbol instances (see {@link LibraryLookup.Symbol}) generated by a given library lookup object contain a strong reference\n- * to said lookup object, therefore preventing library unloading; in turn method handle instances obtained from\n- * {@link CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor)}) also maintain a strong reference\n- * to the addressable parameter used for their construction. This means that there is always a strong reachability chain\n- * from a native method handle to a lookup object (the one that was used to lookup the native library symbol the method handle\n- * refers to); this is useful to prevent situations where a native library is unloaded in the middle of a native call.\n- * <p><a id = \"var-symbols\"><\/a><\/p>\n- * In cases where a client wants to create a memory segment out of a lookup symbol, the client might want to attach the\n- * lookup symbol to the newly created segment, so that the symbol will be kept reachable as long as the memory segment\n- * is reachable; this can be achieved by creating the segment using the {@link MemoryAddress#asSegmentRestricted(long, ResourceScope)}.\n- * restricted segment factory, as follows:\n+ * All instances generated by a given library lookup object contain a strong reference to said lookup object,\n+ * therefore preventing library unloading. For {@link #lookup(String, MemoryLayout) memory segments} obtained from a library lookup object,\n+ * this means that clients can safely dereference memory associated with lookup symbols, as follows:\n@@ -52,3 +44,3 @@\n-LibraryLookup defaultLookup = LibraryLookup.defaultLookup();\n-LibraryLookup.Symbol errno = defaultLookup.lookup(\"errno\");\n-MemorySegment errnoSegment = errno.address().asSegmentRestricted(4, ResourceScope.ofShared(errno, Cleaner.create()));\n+ * LibraryLookup defaultLookup = LibraryLookup.defaultLookup();\n+ * MemorySegment errnoSegment = defaultLookup.lookup(\"errno\", MemoryLayouts.JAVA_INT).get();\n+ * int errno = MemoryAccess.getInt(errnoSegment);\n@@ -57,0 +49,7 @@\n+ * For {@link #lookup(String) memory addresses} obtained from a library lookup object,\n+ * since {@link CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor) native method handles}\n+ * also maintain a strong reference to the addressable parameter used for their construction, there is\n+ * always a strong reachability chain from a native method handle to a lookup object (the one that was used to lookup\n+ * the native library symbol the method handle refers to). This is useful to prevent situations where a native library\n+ * is unloaded in the middle of a native call.\n+ * <p>\n@@ -66,9 +65,3 @@\n-     * A symbol retrieved during a library lookup. A lookup symbol has a <em>name<\/em> and can be projected\n-     * into a memory address (see {@link #name()} and {@link #address()}, respectively).\n-     *\n-     * @apiNote In the future, if the Java language permits, {@link Symbol}\n-     * may become a {@code sealed} interface, which would prohibit subclassing except by\n-     * explicitly permitted types.\n-     *\n-     * @implSpec\n-     * Implementations of this interface are immutable, thread-safe and <a href=\"{@docRoot}\/java.base\/java\/lang\/doc-files\/ValueBased.html\">value-based<\/a>.\n+     * Looks up a symbol with given name in this library. The returned memory address maintains a strong reference to this lookup object.\n+     * @param name the symbol name. This method can be useful to lookup function symbols in a foreign library.\n+     * @return the memory address associated with the library symbol (if any).\n@@ -76,16 +69,1 @@\n-    interface Symbol extends Addressable {\n-        \/**\n-         * The name of this lookup symbol.\n-         * @return the name of this lookup symbol.\n-         *\/\n-        String name();\n-\n-        \/**\n-         * The memory address of this lookup symbol. If the memory associated with this symbol needs to be dereferenced,\n-         * clients can obtain a segment from this symbol's address using the {@link MemoryAddress#asSegmentRestricted(long, Runnable, ResourceScope)},\n-         * and making sure that the created segment maintains a <a href=\"LibraryLookup.html#var-symbols\">strong reference<\/a> to this symbol, to prevent library unloading.\n-         * @return the memory address of this lookup symbol.\n-         *\/\n-        @Override\n-        MemoryAddress address();\n-    }\n+    Optional<MemoryAddress> lookup(String name);\n@@ -94,1 +72,3 @@\n-     * Looks up a symbol with given name in this library. The returned symbol maintains a strong reference to this lookup object.\n+     * Looks up a symbol with given name in this library. The returned memory segment has a size that matches that of\n+     * the specified layout, and maintains a strong reference to this lookup object. This method can be useful\n+     * to lookup global variable symbols in a foreign library.\n@@ -96,1 +76,4 @@\n-     * @return the library symbol (if any).\n+     * @param layout the layout to be associated with the library symbol.\n+     * @return the memory segment associated with the library symbol (if any).\n+     * @throws IllegalArgumentException if the address associated with the lookup symbol do not match the\n+     * {@link MemoryLayout#byteAlignment() alignment constraints} in {@code layout}.\n@@ -98,1 +81,1 @@\n-    Optional<Symbol> lookup(String name);\n+    Optional<MemorySegment> lookup(String name, MemoryLayout layout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":25,"deletions":42,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -106,1 +108,1 @@\n-        final ResourceScope scope;\n+        final MemorySegment librarySegment;\n@@ -110,1 +112,1 @@\n-            this.scope = scope;\n+            this.librarySegment = MemoryAddress.NULL.asSegmentRestricted(Long.MAX_VALUE, scope);\n@@ -114,1 +116,1 @@\n-        public Optional<Symbol> lookup(String name) {\n+        public Optional<MemoryAddress> lookup(String name) {\n@@ -118,11 +120,17 @@\n-                return Optional.of(new Symbol() { \/\/ inner class - retains a link to the scope\n-                    @Override\n-                    public String name() {\n-                        return name;\n-                    }\n-\n-                    @Override\n-                    public MemoryAddress address() {\n-                        return addr;\n-                    }\n-                });\n+                return Optional.of(librarySegment.asSlice(addr).address());\n+            } catch (NoSuchMethodException ex) {\n+                return Optional.empty();\n+            }\n+        }\n+\n+        @Override\n+        public Optional<MemorySegment> lookup(String name, MemoryLayout layout) {\n+            try {\n+                Objects.requireNonNull(name);\n+                Objects.requireNonNull(layout);\n+                MemoryAddress addr = MemoryAddress.ofLong(library.lookup(name));\n+                if (addr.toRawLongValue() % layout.byteAlignment() != 0) {\n+                    throw new IllegalArgumentException(\"Bad layout alignment constraints: \" + layout.byteAlignment());\n+                }\n+                return Optional.of(librarySegment.asSlice(addr)\n+                        .asSlice(0L, layout.byteSize()));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-        final static LibraryLookup.Symbol printfAddr = lookup.lookup(\"printf\").get();\n+        final static MemoryAddress printfAddr = lookup.lookup(\"printf\").get();\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -60,1 +61,1 @@\n-        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n+        MemoryAddress addr = lib.lookup(fName).get();\n@@ -87,1 +88,1 @@\n-        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n+        MemoryAddress addr = lib.lookup(fName).get();\n@@ -110,1 +111,1 @@\n-    Object doCall(LibraryLookup.Symbol addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+    Object doCall(MemoryAddress addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -86,1 +87,1 @@\n-            LibraryLookup.Symbol ma = lookup.lookup(name).orElseThrow();\n+            MemoryAddress ma = lookup.lookup(name).orElseThrow();\n@@ -96,1 +97,1 @@\n-            LibraryLookup.Symbol ma = lookup.lookup(\"empty\").orElseThrow();\n+            MemoryAddress ma = lookup.lookup(\"empty\").orElseThrow();\n@@ -111,1 +112,1 @@\n-            LibraryLookup.Symbol ma = lookup.lookup(\"identity_va\").orElseThrow();\n+            MemoryAddress ma = lookup.lookup(\"identity_va\").orElseThrow();\n@@ -126,1 +127,1 @@\n-                LibraryLookup.Symbol ma = lookup.lookup(\"invoke_high_arity\" + i).orElseThrow();\n+                MemoryAddress ma = lookup.lookup(\"invoke_high_arity\" + i).orElseThrow();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.MemoryAccess;\n@@ -33,0 +34,3 @@\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -69,1 +73,1 @@\n-        LibraryLookup.Symbol symbol = null;\n+        MemoryAddress symbol = null;\n@@ -72,1 +76,0 @@\n-        assertEquals(symbol.name(), \"f\");\n@@ -81,1 +84,1 @@\n-        LibraryLookup.Symbol symbol = null;\n+        MemoryAddress symbol = null;\n@@ -90,0 +93,16 @@\n+    @Test\n+    public void testVariableSymbolLookup() throws Throwable {\n+        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n+        MemorySegment segment = lookup.lookup(\"c\", MemoryLayouts.JAVA_INT).get();\n+        assertEquals(MemoryAccess.getInt(segment), 42);\n+        lookup = null;\n+        segment = null;\n+        waitUnload();\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBarVariableSymbolLookup() throws Throwable {\n+        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n+        lookup.lookup(\"c\", MemoryLayouts.JAVA_INT.withBitAlignment(1 << 16)).get();\n+    }\n+\n@@ -92,1 +111,1 @@\n-        List<LibraryLookup.Symbol> symbols = new ArrayList<>();\n+        List<MemoryAddress> symbols = new ArrayList<>();\n@@ -96,1 +115,1 @@\n-            LibraryLookup.Symbol symbol = lookup.lookup(\"f\").get();\n+            MemoryAddress symbol = lookup.lookup(\"f\").get();\n@@ -154,1 +173,1 @@\n-        public static LibraryLookup.Symbol symbol;\n+        public static MemoryAddress symbol;\n","filename":"test\/jdk\/java\/foreign\/TestLibraryLookup.java","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n+        MemoryAddress addr = lib.lookup(fName).get();\n@@ -109,1 +109,1 @@\n-        LibraryLookup.Symbol addr = lib.lookup(fName).get();\n+        MemoryAddress addr = lib.lookup(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    static final LibraryLookup.Symbol varargsAddr = LibraryLookup.ofLibrary(\"VarArgs\")\n+    static final MemoryAddress varargsAddr = LibraryLookup.ofLibrary(\"VarArgs\")\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ EXPORT int c = 42;\n","filename":"test\/jdk\/java\/foreign\/libLookupTest.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -51,3 +52,3 @@\n-    static final LibraryLookup.Symbol funcA;\n-    static final LibraryLookup.Symbol funcB;\n-    static final LibraryLookup.Symbol funcC;\n+    static final MemoryAddress funcA;\n+    static final MemoryAddress funcB;\n+    static final MemoryAddress funcC;\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}