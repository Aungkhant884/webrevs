{"files":[{"patch":"@@ -30,0 +30,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -42,0 +44,1 @@\n+    private int asyncReleaseCount = 0;\n@@ -44,0 +47,10 @@\n+    static final VarHandle ASYNC_RELEASE_COUNT;\n+\n+    static {\n+        try {\n+            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedScope.class, \"asyncReleaseCount\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n@@ -77,1 +90,12 @@\n-        lockCount--;\n+        if (Thread.currentThread() == owner) {\n+            lockCount--;\n+        } else {\n+            \/\/ It is possible to end up here in two cases: this scope was the ancestor of some other confined scope\n+            \/\/ which is implicitly released (in which case the release call comes from the cleaner thread). Or,\n+            \/\/ this scope might be the ancestor of a shared scope, which means the release call can come from any\n+            \/\/ thread.\n+            int value;\n+            do {\n+                value = (int)ASYNC_RELEASE_COUNT.getVolatile(this);\n+            } while (!ASYNC_RELEASE_COUNT.compareAndSet(this, value, value + 1));\n+        }\n@@ -82,1 +106,1 @@\n-        if (lockCount == 0) {\n+        if (lockCount == 0 || lockCount - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Set;\n@@ -273,0 +274,58 @@\n+    @Test\n+    public void testConfinedScopeWithImplicitDependency() {\n+        ResourceScope root = ResourceScope.newConfinedScope();\n+        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            ResourceScope.newConfinedScope(Cleaner.create()).keepAlive(root);\n+        }\n+        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: cleanup action\n+        \/\/ might be called from another thread (the Cleaner thread), so that the confined scope lock count is updated racily.\n+        \/\/ If that happens, the loop below never terminates.\n+        while (true) {\n+            try {\n+                root.close();\n+                break; \/\/ success!\n+            } catch (IllegalStateException ex) {\n+                kickGC();\n+                for (int i = 0 ; i < N_THREADS ; i++) {  \/\/ add more races from current thread\n+                    try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                        scope.keepAlive(root);\n+                        \/\/ dummy\n+                    }\n+                }\n+                \/\/ try again\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testConfinedScopeWithSharedDependency() {\n+        ResourceScope root = ResourceScope.newConfinedScope();\n+        List<Thread> threads = new ArrayList<>();\n+        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            ResourceScope scope = ResourceScope.newSharedScope(); \/\/ create scope inside same thread!\n+            scope.keepAlive(root);\n+            Thread t = new Thread(scope::close); \/\/ close from another thread!\n+            threads.add(t);\n+            t.start();\n+        }\n+        for (int i = 0 ; i < N_THREADS ; i++) { \/\/ add more races from current thread\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                scope.keepAlive(root);\n+                \/\/ dummy\n+            }\n+        }\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                \/\/ ok\n+            }\n+        });\n+        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: releases of\n+        \/\/ the confined scope happen in different threads, so that the confined scope lock count is updated racily.\n+        \/\/ If that happens, the following close will blow up.\n+        root.close();\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"modified"}]}