{"files":[{"patch":"@@ -38,0 +38,1 @@\n+include gensrc\/GensrcScopedMemoryAccess.gmk\n","filename":"make\/modules\/java.base\/Gensrc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,155 @@\n+#\n+# Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+GENSRC_SCOPED_MEMORY_ACCESS :=\n+\n+\n+SCOPED_MEMORY_ACCESS_GENSRC_DIR := $(SUPPORT_OUTPUTDIR)\/gensrc\/java.base\/jdk\/internal\/misc\n+SCOPED_MEMORY_ACCESS_SRC_DIR := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\n+\n+SCOPED_MEMORY_ACCESS_TEMPLATE := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template\n+SCOPED_MEMORY_ACCESS_BIN_TEMPLATE := $(TOPDIR)\/src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template\n+DEST := $(SCOPED_MEMORY_ACCESS_GENSRC_DIR)\/ScopedMemoryAccess.java\n+\n+################################################################################\n+# Setup a rule for generating the ScopedMemoryAccess java class\n+# Param 1 - Variable declaration prefix\n+# Param 2 - Type with first letter capitalized\n+define GenerateScopedOp\n+\n+  $1_Type := $2\n+\n+  ifeq ($$($1_Type), Byte)\n+    $1_type := byte\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+\n+    $1_ARGS += -Kbyte\n+  endif\n+\n+  ifeq ($$($1_Type), Short)\n+    $1_type := short\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+    $1_ARGS += -KUnaligned\n+  endif\n+\n+  ifeq ($$($1_Type), Char)\n+    $1_type := char\n+    $1_BoxType := Character\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+    $1_ARGS += -KUnaligned\n+  endif\n+\n+  ifeq ($$($1_Type), Int)\n+    $1_type := int\n+    $1_BoxType := Integer\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+\n+    $1_ARGS += -KCAS\n+    $1_ARGS += -KAtomicAdd\n+    $1_ARGS += -KBitwise\n+    $1_ARGS += -KUnaligned\n+  endif\n+\n+  ifeq ($$($1_Type), Long)\n+    $1_type := long\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := $$($1_type)\n+    $1_RawType := $$($1_Type)\n+    $1_RawBoxType := $$($1_BoxType)\n+\n+    $1_ARGS += -KCAS\n+    $1_ARGS += -KAtomicAdd\n+    $1_ARGS += -KBitwise\n+    $1_ARGS += -KUnaligned\n+  endif\n+\n+  ifeq ($$($1_Type), Float)\n+    $1_type := float\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := int\n+    $1_RawType := Int\n+    $1_RawBoxType := Integer\n+\n+    $1_ARGS += -KCAS\n+    $1_ARGS += -KfloatingPoint\n+  endif\n+\n+  ifeq ($$($1_Type), Double)\n+    $1_type := double\n+    $1_BoxType := $$($1_Type)\n+\n+    $1_rawType := long\n+    $1_RawType := Long\n+    $1_RawBoxType := Long\n+\n+    $1_ARGS += -KCAS\n+    $1_ARGS += -KfloatingPoint\n+  endif\n+\n+  ifneq ($$(findstring $$($1_Type), Byte Short Char Int Long Float Double), )\n+    $1_ARGS += -KAtomicAdd\n+  endif\n+\n+  ifneq ($$(findstring $$($1_Type), Boolean Byte Short Char Int Long), )\n+    $1_ARGS += -KBitwise\n+  endif\n+\n+  ifneq ($$(findstring $$($1_Type), Byte Short Char), )\n+    $1_ARGS += -KShorterThanInt\n+  endif\n+endef\n+\n+################################################################################\n+# Setup a rule for generating the ScopedMemoryAccess java class\n+\n+SCOPE_MEMORY_ACCESS_TYPES := Byte Short Char Int Long Float Double\n+$(foreach t, $(SCOPE_MEMORY_ACCESS_TYPES), \\\n+  $(eval $(call GenerateScopedOp,BIN_$t,$t)))\n+\t\n+$(DEST): $(BUILD_TOOLS_JDK) $(SCOPED_MEMORY_ACCESS_TEMPLATE) $(SCOPED_MEMORY_ACCESS_BIN_TEMPLATE)\n+\t$(MKDIR) -p $(SCOPED_MEMORY_ACCESS_GENSRC_DIR)\n+\t$(CP) $(SCOPED_MEMORY_ACCESS_TEMPLATE) $(DEST)\n+\t$(foreach t, $(SCOPE_MEMORY_ACCESS_TYPES), \\\n+\t\t$(TOOL_SPP) -nel -K$(BIN_$t_type) -Dtype=$(BIN_$t_type) -DType=$(BIN_$t_Type) $(BIN_$t_ARGS) \\\n+\t\t-i$(SCOPED_MEMORY_ACCESS_BIN_TEMPLATE) -o$(DEST) ;)\n+\t$(PRINTF) \"}\\n\" >> $(DEST)\n+\t\n+TARGETS += $(DEST)\n\\ No newline at end of file\n","filename":"make\/modules\/java.base\/gensrc\/GensrcScopedMemoryAccess.gmk","additions":155,"deletions":0,"binary":false,"changes":155,"status":"added"},{"patch":"@@ -1081,0 +1081,1 @@\n+    _method_Scoped,\n@@ -2104,0 +2105,5 @@\n+    case vmSymbols::VM_SYMBOL_ENUM_NAME(jdk_internal_misc_Scoped_signature): {\n+      if (_location != _in_method)  break;  \/\/ only allow for methods\n+\/\/      if (!privileged)              break;  \/\/ only allow in privileged code\n+      return _method_Scoped;\n+    }\n@@ -2161,0 +2167,2 @@\n+  if (has_annotation(_method_Scoped))\n+    m->set_scoped(true);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -289,0 +289,2 @@\n+  template(jdk_internal_vm_annotation_Critical_signature,    \"Ljdk\/internal\/vm\/annotation\/Critical;\") \\\n+  template(jdk_internal_misc_Scoped_signature,    \"Ljdk\/internal\/misc\/ScopedMemoryAccess$Scoped;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-    _reserved_stack_access = 1 << 7\n+    _reserved_stack_access = 1 << 7,\n+    _scoped                = 1 << 8\n@@ -903,0 +904,8 @@\n+  bool is_scoped() const {\n+    return (_flags & _scoped) != 0;\n+  }\n+\n+  void set_scoped(bool x) {\n+    _flags = x ? (_flags | _scoped) : (_flags & ~_scoped);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"prims\/scopedMemoryAccess.hpp\"\n@@ -142,0 +143,1 @@\n+  { CC\"Java_jdk_internal_misc_ScopedMemoryAccess_registerNatives\", NULL, FN_PTR(JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods) },\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+#include \"precompiled.hpp\"\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/vframe.inline.hpp\"\n+#include \"runtime\/deoptimization.hpp\"\n+#include \"prims\/stackwalk.hpp\"\n+\n+\n+class CloseScopedMemoryFindOopClosure : public OopClosure {\n+  oop _deopt;\n+  bool _found;\n+\n+public:\n+  CloseScopedMemoryFindOopClosure(jobject deopt) :\n+      _deopt(JNIHandles::resolve(deopt)),\n+      _found(false) {}\n+\n+  template <typename T>\n+  void do_oop_work(T* p) {\n+    if (_found) {\n+      return;\n+    }\n+    if (RawAccess<>::oop_load(p) == _deopt) {\n+      _found = true;\n+    }\n+  }\n+\n+  virtual void do_oop(oop* p) {\n+    do_oop_work(p);\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    do_oop_work(p);\n+  }\n+\n+  bool found() {\n+    return _found;\n+  }\n+};\n+\n+class CloseScopedMemoryClosure : public HandshakeClosure {\n+  jobject _deopt;\n+  jobject _exception;\n+\n+public:\n+  CloseScopedMemoryClosure(jobject deopt, jobject exception)\n+    : HandshakeClosure(\"CloseScopedMemory\")\n+    , _deopt(deopt)\n+    , _exception(exception) {}\n+\n+  void do_thread(Thread* thread) {\n+\n+    JavaThread* jt = (JavaThread*)thread;\n+\n+    if (!jt->has_last_Java_frame()) {\n+      return;\n+    }\n+\n+    frame last_frame = jt->last_frame();\n+    RegisterMap register_map(jt, true);\n+\n+    if (last_frame.is_safepoint_blob_frame()) {\n+      last_frame = last_frame.sender(&register_map);\n+    }\n+\n+    ResourceMark rm;\n+    if (_deopt != NULL && last_frame.is_compiled_frame() && last_frame.can_be_deoptimized()) {\n+      CloseScopedMemoryFindOopClosure cl(_deopt);\n+      CompiledMethod* cm = last_frame.cb()->as_compiled_method();\n+\n+      \/\/FIXME: this doesn't work if reachability fences are violated by C2\n+      \/\/ last_frame.oops_do(&cl, NULL, &register_map);\n+\n+      \/\/ if (cl.found()) {\n+      \/\/   \/\/ Found the deopt oop in a compiled method; deoptimize.\n+      \/\/   Deoptimization::deoptimize(jt, last_frame);\n+      \/\/ }\n+\n+      \/\/ so... we unconditionally deoptimize, for now\n+      Deoptimization::deoptimize(jt, last_frame);\n+    }\n+\n+    const int max_critical_stack_depth = 5;\n+    int depth = 0;\n+    vframeStream stream(jt);\n+    for (; !stream.at_end(); stream.next()) {\n+      Method* m = stream.method();\n+      if (m->is_scoped()) {\n+        StackValueCollection* locals = stream.asJavaVFrame()->locals();\n+        for (int i = 0; i < locals->size(); i++) {\n+          StackValue* var = locals->at(i);\n+          if (var->type() == T_OBJECT) {\n+            if (var->get_obj() == JNIHandles::resolve(_deopt)) {\n+              assert(depth < max_critical_stack_depth, \"can't have more than %d critical frames\", max_critical_stack_depth);\n+              jt->send_thread_stop(JNIHandles::resolve(_exception));\n+              return;\n+            }\n+          }\n+        }\n+        break;\n+      }\n+      depth++;\n+#ifndef ASSERT\n+      if (depth >= max_critical_stack_depth) {\n+        break;\n+      }\n+#endif\n+    }\n+  }\n+};\n+\n+\/*\n+ * This function issues a global handshake operation with all\n+ * Java threads. This is useful for implementing asymmetric\n+ * dekker synchronization schemes, where expensive synchronization\n+ * in performance sensitive common paths, may be shifted to\n+ * a less common slow path instead.\n+ * Top frames containg obj will be deoptimized.\n+ *\/\n+JVM_ENTRY(void, ScopedMemoryAccess_closeScope(JNIEnv *env, jobject receiver, jobject deopt, jobject exception)) {\n+  CloseScopedMemoryClosure cl(deopt, exception);\n+  Handshake::execute(&cl);\n+} JVM_END\n+\n+\/\/\/ JVM_RegisterUnsafeMethods\n+\n+#define LANG \"Ljdk\/internal\/misc\/\"\n+\n+#define MEMACCESS \"ScopedMemoryAccess\"\n+#define SCOPE LANG MEMACCESS \"$Scope;\"\n+#define SCOPED_EXC LANG MEMACCESS \"$Scope$ScopedAccessException;\"\n+\n+#define CC (char*)  \/*cast a literal from (const char*)*\/\n+#define FN_PTR(f) CAST_FROM_FN_PTR(void*, &f)\n+\n+static JNINativeMethod jdk_internal_misc_ScopedMemoryAccess_methods[] = {\n+    {CC \"closeScope0\",   CC \"(\" SCOPE SCOPED_EXC \")V\",           FN_PTR(ScopedMemoryAccess_closeScope)},\n+};\n+\n+#undef CC\n+#undef FN_PTR\n+\n+#undef LANG\n+#undef MEMACCESS\n+#undef SCOPE\n+#undef SCOPED_EXC\n+\n+\/\/ This function is exported, used by NativeLookup.\n+\n+JVM_ENTRY(void, JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods(JNIEnv *env, jclass scopedMemoryAccessClass)) {\n+  ThreadToNativeFromVM ttnfv(thread);\n+\n+  int ok = env->RegisterNatives(scopedMemoryAccessClass, jdk_internal_misc_ScopedMemoryAccess_methods, sizeof(jdk_internal_misc_ScopedMemoryAccess_methods)\/sizeof(JNINativeMethod));\n+  \/\/printf(\"closeScope(%s%s)V\\n\", SCOPE, SCOPED_EXC);\n+  guarantee(ok == 0, \"register jdk.internal.misc.ScopedMemoryAccess natives\");\n+} JVM_END\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.cpp","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+#ifndef SHARE_PRIMS_SCOPED_MEMORY_ACCESS_HPP\n+#define SHARE_PRIMS_SCOPED_MEMORY_ACCESS_HPP\n+\n+#include \"jni.h\"\n+\n+extern \"C\" {\n+  void JNICALL JVM_RegisterJDKInternalMiscScopedMemoryAccessMethods(JNIEnv *env, jobject rec, jobject scope, jthrowable exception);\n+}\n+\n+#endif \/\/ SHARE_PRIMS_SCOPED_MEMORY_ACCESS_HPP\n","filename":"src\/hotspot\/share\/prims\/scopedMemoryAccess.hpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -69,1 +69,4 @@\n-  JVM_ENTRY(static result_type, header)\n+   JVM_ENTRY(static result_type, header) \\\n+   if (JavaThread::thread_from_jni_environment(env)->has_async_exception()) { \\\n+     return (result_type)0; \\\n+   } else\n@@ -1056,1 +1059,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.ScopedMemoryAccess.Scope;\n@@ -47,0 +49,2 @@\n+    \n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -569,3 +573,0 @@\n-            if (segmentProxy != null) {\n-                segmentProxy.checkValidState();\n-            }\n@@ -575,0 +576,6 @@\n+        static Scope scope(ByteBuffer bb) {\n+            MemorySegmentProxy segmentProxy = NIO_ACCESS.bufferSegment(bb);\n+            return segmentProxy != null ?\n+                    segmentProxy.scope() : null;\n+        }\n+\n@@ -595,1 +602,1 @@\n-            $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(\n+            $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(scope(bb),\n@@ -601,1 +608,1 @@\n-            return UNSAFE.get$Type$Unaligned(\n+            return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(scope(bb),\n@@ -613,1 +620,1 @@\n-            UNSAFE.put$RawType$Unaligned(\n+            SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(scope(bb),\n@@ -619,1 +626,1 @@\n-            UNSAFE.put$Type$Unaligned(\n+            SCOPED_MEMORY_ACCESS.put$Type$Unaligned(scope(bb),\n@@ -632,1 +639,1 @@\n-                              UNSAFE.get$RawType$Volatile(\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb),\n@@ -641,1 +648,1 @@\n-            UNSAFE.put$RawType$Volatile(\n+            SCOPED_MEMORY_ACCESS.put$RawType$Volatile(scope(bb),\n@@ -652,1 +659,1 @@\n-                              UNSAFE.get$RawType$Acquire(\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Acquire(scope(bb),\n@@ -661,1 +668,1 @@\n-            UNSAFE.put$RawType$Release(\n+            SCOPED_MEMORY_ACCESS.put$RawType$Release(scope(bb),\n@@ -672,1 +679,1 @@\n-                              UNSAFE.get$RawType$Opaque(\n+                              SCOPED_MEMORY_ACCESS.get$RawType$Opaque(scope(bb),\n@@ -681,1 +688,1 @@\n-            UNSAFE.put$RawType$Opaque(\n+            SCOPED_MEMORY_ACCESS.put$RawType$Opaque(scope(bb),\n@@ -693,1 +700,1 @@\n-            return UNSAFE.compareAndSetReference(\n+            return SCOPED_MEMORY_ACCESS.compareAndSetReference(scope(bb),\n@@ -698,1 +705,1 @@\n-            return UNSAFE.compareAndSet$RawType$(\n+            return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(scope(bb),\n@@ -710,1 +717,1 @@\n-                              UNSAFE.compareAndExchange$RawType$(\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(scope(bb),\n@@ -721,1 +728,1 @@\n-                              UNSAFE.compareAndExchange$RawType$Acquire(\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(scope(bb),\n@@ -732,1 +739,1 @@\n-                              UNSAFE.compareAndExchange$RawType$Release(\n+                              SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(scope(bb),\n@@ -742,1 +749,1 @@\n-            return UNSAFE.weakCompareAndSet$RawType$Plain(\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(scope(bb),\n@@ -752,1 +759,1 @@\n-            return UNSAFE.weakCompareAndSet$RawType$(\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(scope(bb),\n@@ -762,1 +769,1 @@\n-            return UNSAFE.weakCompareAndSet$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(scope(bb),\n@@ -772,1 +779,1 @@\n-            return UNSAFE.weakCompareAndSet$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(scope(bb),\n@@ -784,1 +791,1 @@\n-                              UNSAFE.getAndSetReference(\n+                              SCOPED_MEMORY_ACCESS.getAndSetReference(scope(bb),\n@@ -790,1 +797,1 @@\n-                              UNSAFE.getAndSet$RawType$(\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$(scope(bb),\n@@ -802,1 +809,1 @@\n-                              UNSAFE.getAndSet$RawType$Acquire(\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(scope(bb),\n@@ -813,1 +820,1 @@\n-                              UNSAFE.getAndSet$RawType$Release(\n+                              SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(scope(bb),\n@@ -826,1 +833,1 @@\n-                return UNSAFE.getAndAdd$RawType$(\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(scope(bb),\n@@ -840,1 +847,1 @@\n-                return UNSAFE.getAndAdd$RawType$Acquire(\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(scope(bb),\n@@ -854,1 +861,1 @@\n-                return UNSAFE.getAndAdd$RawType$Release(\n+                return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(scope(bb),\n@@ -869,1 +876,1 @@\n-                nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n@@ -883,1 +890,1 @@\n-                return UNSAFE.getAndBitwiseOr$RawType$(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(scope(bb),\n@@ -897,1 +904,1 @@\n-                return UNSAFE.getAndBitwiseOr$RawType$Release(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(scope(bb),\n@@ -911,1 +918,1 @@\n-                return UNSAFE.getAndBitwiseOr$RawType$Acquire(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(scope(bb),\n@@ -926,1 +933,1 @@\n-                nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n@@ -938,1 +945,1 @@\n-                return UNSAFE.getAndBitwiseAnd$RawType$(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(scope(bb),\n@@ -952,1 +959,1 @@\n-                return UNSAFE.getAndBitwiseAnd$RawType$Release(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(scope(bb),\n@@ -966,1 +973,1 @@\n-                return UNSAFE.getAndBitwiseAnd$RawType$Acquire(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(scope(bb),\n@@ -981,1 +988,1 @@\n-                nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n@@ -994,1 +1001,1 @@\n-                return UNSAFE.getAndBitwiseXor$RawType$(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(scope(bb),\n@@ -1008,1 +1015,1 @@\n-                return UNSAFE.getAndBitwiseXor$RawType$Release(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(scope(bb),\n@@ -1022,1 +1029,1 @@\n-                return UNSAFE.getAndBitwiseXor$RawType$Acquire(\n+                return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(scope(bb),\n@@ -1037,1 +1044,1 @@\n-                nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+                nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(scope(bb), base, offset);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleByteArrayView.java.template","additions":49,"deletions":42,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -30,0 +31,2 @@\n+import java.lang.ref.Reference;\n+\n@@ -39,0 +42,2 @@\n+    \n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -117,1 +122,1 @@\n-        $rawType$ rawValue = UNSAFE.get$RawType$Unaligned(\n+        $rawType$ rawValue = SCOPED_MEMORY_ACCESS.get$RawType$Unaligned(bb.scope(),\n@@ -124,1 +129,1 @@\n-        return UNSAFE.get$Type$(\n+        return SCOPED_MEMORY_ACCESS.get$Type$(bb.scope(),\n@@ -128,1 +133,1 @@\n-        return UNSAFE.get$Type$Unaligned(\n+        return SCOPED_MEMORY_ACCESS.get$Type$Unaligned(bb.scope(),\n@@ -141,1 +146,1 @@\n-        UNSAFE.put$RawType$Unaligned(\n+        SCOPED_MEMORY_ACCESS.put$RawType$Unaligned(bb.scope(),\n@@ -148,1 +153,1 @@\n-        UNSAFE.put$Type$(\n+        SCOPED_MEMORY_ACCESS.put$Type$(bb.scope(),\n@@ -153,1 +158,1 @@\n-        UNSAFE.put$Type$Unaligned(\n+        SCOPED_MEMORY_ACCESS.put$Type$Unaligned(bb.scope(),\n@@ -167,1 +172,1 @@\n-                          UNSAFE.get$RawType$Volatile(\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),\n@@ -176,1 +181,1 @@\n-        UNSAFE.put$RawType$Volatile(\n+        SCOPED_MEMORY_ACCESS.put$RawType$Volatile(bb.scope(),\n@@ -187,1 +192,1 @@\n-                          UNSAFE.get$RawType$Acquire(\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Acquire(bb.scope(),\n@@ -196,1 +201,1 @@\n-        UNSAFE.put$RawType$Release(\n+        SCOPED_MEMORY_ACCESS.put$RawType$Release(bb.scope(),\n@@ -207,1 +212,1 @@\n-                          UNSAFE.get$RawType$Opaque(\n+                          SCOPED_MEMORY_ACCESS.get$RawType$Opaque(bb.scope(),\n@@ -216,1 +221,1 @@\n-        UNSAFE.put$RawType$Opaque(\n+        SCOPED_MEMORY_ACCESS.put$RawType$Opaque(bb.scope(),\n@@ -227,1 +232,1 @@\n-        return UNSAFE.compareAndSet$RawType$(\n+        return SCOPED_MEMORY_ACCESS.compareAndSet$RawType$(bb.scope(),\n@@ -238,1 +243,1 @@\n-                          UNSAFE.compareAndExchange$RawType$(\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$(bb.scope(),\n@@ -249,1 +254,1 @@\n-                          UNSAFE.compareAndExchange$RawType$Acquire(\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Acquire(bb.scope(),\n@@ -260,1 +265,1 @@\n-                          UNSAFE.compareAndExchange$RawType$Release(\n+                          SCOPED_MEMORY_ACCESS.compareAndExchange$RawType$Release(bb.scope(),\n@@ -270,1 +275,1 @@\n-        return UNSAFE.weakCompareAndSet$RawType$Plain(\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Plain(bb.scope(),\n@@ -280,1 +285,1 @@\n-        return UNSAFE.weakCompareAndSet$RawType$(\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),\n@@ -290,1 +295,1 @@\n-        return UNSAFE.weakCompareAndSet$RawType$Acquire(\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Acquire(bb.scope(),\n@@ -300,1 +305,1 @@\n-        return UNSAFE.weakCompareAndSet$RawType$Release(\n+        return SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$Release(bb.scope(),\n@@ -311,1 +316,1 @@\n-                          UNSAFE.getAndSet$RawType$(\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$(bb.scope(),\n@@ -322,1 +327,1 @@\n-                          UNSAFE.getAndSet$RawType$Acquire(\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Acquire(bb.scope(),\n@@ -333,1 +338,1 @@\n-                          UNSAFE.getAndSet$RawType$Release(\n+                          SCOPED_MEMORY_ACCESS.getAndSet$RawType$Release(bb.scope(),\n@@ -346,1 +351,1 @@\n-            return UNSAFE.getAndAdd$RawType$(\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$(bb.scope(),\n@@ -360,1 +365,1 @@\n-            return UNSAFE.getAndAdd$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Acquire(bb.scope(),\n@@ -374,1 +379,1 @@\n-            return UNSAFE.getAndAdd$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.getAndAdd$RawType$Release(bb.scope(),\n@@ -388,1 +393,1 @@\n-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n@@ -390,1 +395,1 @@\n-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n@@ -402,1 +407,1 @@\n-            return UNSAFE.getAndBitwiseOr$RawType$(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$(bb.scope(),\n@@ -416,1 +421,1 @@\n-            return UNSAFE.getAndBitwiseOr$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Release(bb.scope(),\n@@ -430,1 +435,1 @@\n-            return UNSAFE.getAndBitwiseOr$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseOr$RawType$Acquire(bb.scope(),\n@@ -444,1 +449,1 @@\n-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n@@ -446,1 +451,1 @@\n-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n@@ -456,1 +461,1 @@\n-            return UNSAFE.getAndBitwiseAnd$RawType$(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$(bb.scope(),\n@@ -470,1 +475,1 @@\n-            return UNSAFE.getAndBitwiseAnd$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Release(bb.scope(),\n@@ -484,1 +489,1 @@\n-            return UNSAFE.getAndBitwiseAnd$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseAnd$RawType$Acquire(bb.scope(),\n@@ -498,1 +503,1 @@\n-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n@@ -500,1 +505,1 @@\n-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n@@ -511,1 +516,1 @@\n-            return UNSAFE.getAndBitwiseXor$RawType$(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$(bb.scope(),\n@@ -525,1 +530,1 @@\n-            return UNSAFE.getAndBitwiseXor$RawType$Release(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Release(bb.scope(),\n@@ -539,1 +544,1 @@\n-            return UNSAFE.getAndBitwiseXor$RawType$Acquire(\n+            return SCOPED_MEMORY_ACCESS.getAndBitwiseXor$RawType$Acquire(bb.scope(),\n@@ -553,1 +558,1 @@\n-            nativeExpectedValue = UNSAFE.get$RawType$Volatile(base, offset);\n+            nativeExpectedValue = SCOPED_MEMORY_ACCESS.get$RawType$Volatile(bb.scope(),base, offset);\n@@ -555,1 +560,1 @@\n-        } while (!UNSAFE.weakCompareAndSet$RawType$(base, offset,\n+        } while (!SCOPED_MEMORY_ACCESS.weakCompareAndSet$RawType$(bb.scope(),base, offset,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleMemoryAccess.java.template","additions":48,"deletions":43,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -196,0 +197,2 @@\n+    static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -757,1 +760,1 @@\n-    final void checkSegment() {\n+    final ScopedMemoryAccess.Scope scope() {\n@@ -759,1 +762,10 @@\n-            segment.checkValidState();\n+            return segment.scope();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    final void checkScope() {\n+        ScopedMemoryAccess.Scope scope = scope();\n+        if (scope != null) {\n+            scope.checkValidState();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -34,0 +35,2 @@\n+    final static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n+\n@@ -39,1 +42,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -63,1 +66,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -83,1 +86,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -103,1 +106,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -122,1 +125,1 @@\n-                i = ArraysSupport.vectorizedMismatch(\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -161,1 +164,1 @@\n-            i = ArraysSupport.vectorizedMismatch(\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n@@ -179,1 +182,1 @@\n-                i = ArraysSupport.vectorizedMismatch(\n+                i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(a.scope(), b.scope(),\n","filename":"src\/java.base\/share\/classes\/java\/nio\/BufferMismatch.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -133,2 +133,1 @@\n-        checkSegment();\n-        $memtype$ x = UNSAFE.get$Memtype$Unaligned(bb.hb, byteOffset(nextGetIndex()),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), bb.hb, byteOffset(nextGetIndex()),\n@@ -140,2 +139,1 @@\n-        checkSegment();\n-        $memtype$ x = UNSAFE.get$Memtype$Unaligned(bb.hb, byteOffset(checkIndex(i)),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), bb.hb, byteOffset(checkIndex(i)),\n@@ -148,1 +146,1 @@\n-        $memtype$ x = UNSAFE.get$Memtype$Unaligned(bb.hb, byteOffset(i),\n+        $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(null, bb.hb, byteOffset(i),\n@@ -158,1 +156,0 @@\n-        checkSegment();\n@@ -160,1 +157,1 @@\n-        UNSAFE.put$Memtype$Unaligned(bb.hb, byteOffset(nextPutIndex()), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), bb.hb, byteOffset(nextPutIndex()), y,\n@@ -170,1 +167,0 @@\n-        checkSegment();\n@@ -172,1 +168,1 @@\n-        UNSAFE.put$Memtype$Unaligned(bb.hb, byteOffset(checkIndex(i)), y,\n+        SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), bb.hb, byteOffset(checkIndex(i)), y,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/ByteBufferAs-X-Buffer.java.template","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,2 +36,1 @@\n-            checkSegment();\n-            $memtype$ x = UNSAFE.get$Memtype$Unaligned(null, a, bigEndian);\n+            $memtype$ x = SCOPED_MEMORY_ACCESS.get$Memtype$Unaligned(scope(), null, a, bigEndian);\n@@ -65,1 +64,0 @@\n-            checkSegment();\n@@ -67,1 +65,1 @@\n-            UNSAFE.put$Memtype$Unaligned(null, a, y, bigEndian);\n+            SCOPED_MEMORY_ACCESS.put$Memtype$Unaligned(scope(), null, a, y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer-bin.java.template","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -276,2 +276,1 @@\n-            checkSegment();\n-            return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(nextGetIndex()))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(scope(), null, ix(nextGetIndex()))));\n@@ -285,2 +284,1 @@\n-            checkSegment();\n-            return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(checkIndex(i)))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(scope(), null, ix(checkIndex(i)))));\n@@ -295,1 +293,1 @@\n-            return $fromBits$($swap$(UNSAFE.get$Swaptype$(ix(i))));\n+            return $fromBits$($swap$(SCOPED_MEMORY_ACCESS.get$Swaptype$(null, null, ix(i))));\n@@ -304,1 +302,0 @@\n-        checkSegment();\n@@ -318,1 +315,1 @@\n-                    UNSAFE.copySwapMemory(null,\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, null,\n@@ -326,1 +323,1 @@\n-                    UNSAFE.copyMemory(null,\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n@@ -346,1 +343,0 @@\n-        checkSegment();\n@@ -355,1 +351,1 @@\n-                    UNSAFE.copySwapMemory(null,\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, null,\n@@ -363,1 +359,1 @@\n-                    UNSAFE.copyMemory(null,\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null,\n@@ -384,2 +380,1 @@\n-            checkSegment();\n-            UNSAFE.put$Swaptype$(ix(nextPutIndex()), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(scope(), null, ix(nextPutIndex()), $swap$($toBits$(x)));\n@@ -398,2 +393,1 @@\n-            checkSegment();\n-            UNSAFE.put$Swaptype$(ix(checkIndex(i)), $swap$($toBits$(x)));\n+            SCOPED_MEMORY_ACCESS.put$Swaptype$(scope(), null, ix(checkIndex(i)), $swap$($toBits$(x)));\n@@ -411,1 +405,0 @@\n-        checkSegment();\n@@ -421,1 +414,0 @@\n-        checkSegment();\n@@ -435,1 +427,1 @@\n-                    UNSAFE.copySwapMemory(src,\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, src,\n@@ -443,1 +435,1 @@\n-                    UNSAFE.copyMemory(src,\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, src,\n@@ -463,1 +455,0 @@\n-        checkSegment();\n@@ -473,1 +464,1 @@\n-                    UNSAFE.copySwapMemory(src,\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), null, src,\n@@ -481,1 +472,1 @@\n-                    UNSAFE.copyMemory(src,\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, src,\n@@ -505,1 +496,1 @@\n-            UNSAFE.copyMemory(ix(pos), ix(0), (long)rem << $LG_BYTES_PER_VALUE$);\n+            SCOPED_MEMORY_ACCESS.copyMemory(scope(), null, null, ix(pos), null, ix(0), (long)rem << $LG_BYTES_PER_VALUE$);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-        checkSegment();\n@@ -170,1 +169,0 @@\n-        checkSegment();\n@@ -181,1 +179,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -192,1 +190,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -211,1 +209,0 @@\n-        checkSegment();\n@@ -221,1 +218,0 @@\n-        checkSegment();\n@@ -231,1 +227,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -246,1 +242,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -256,1 +252,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -269,1 +265,1 @@\n-        checkSegment();\n+        checkScope();\n@@ -321,2 +317,1 @@\n-        checkSegment();\n-        return UNSAFE.getCharUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -326,1 +321,1 @@\n-        return UNSAFE.getCharUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -333,2 +328,1 @@\n-        checkSegment();\n-        UNSAFE.putCharUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -343,2 +337,1 @@\n-        checkSegment();\n-        UNSAFE.putCharUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putCharUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -376,2 +369,1 @@\n-        checkSegment();\n-        return UNSAFE.getShortUnaligned(hb, byteOffset(nextGetIndex(2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(nextGetIndex(2)), bigEndian);\n@@ -381,2 +373,1 @@\n-        checkSegment();\n-        return UNSAFE.getShortUnaligned(hb, byteOffset(checkIndex(i, 2)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), bigEndian);\n@@ -389,2 +380,1 @@\n-        checkSegment();\n-        UNSAFE.putShortUnaligned(hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(nextPutIndex(2)), x, bigEndian);\n@@ -399,2 +389,1 @@\n-        checkSegment();\n-        UNSAFE.putShortUnaligned(hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putShortUnaligned(scope(), hb, byteOffset(checkIndex(i, 2)), x, bigEndian);\n@@ -432,2 +421,1 @@\n-        checkSegment();\n-        return UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -437,2 +425,1 @@\n-        checkSegment();\n-        return UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -445,2 +432,1 @@\n-        checkSegment();\n-        UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), x, bigEndian);\n@@ -455,2 +441,1 @@\n-        checkSegment();\n-        UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), x, bigEndian);\n@@ -488,2 +473,1 @@\n-        checkSegment();\n-        return UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -493,2 +477,1 @@\n-        checkSegment();\n-        return UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        return SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -501,2 +484,1 @@\n-        checkSegment();\n-        UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), x, bigEndian);\n@@ -511,2 +493,1 @@\n-        checkSegment();\n-        UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), x, bigEndian);\n@@ -544,2 +525,1 @@\n-        checkSegment();\n-        int x = UNSAFE.getIntUnaligned(hb, byteOffset(nextGetIndex(4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(nextGetIndex(4)), bigEndian);\n@@ -550,2 +530,1 @@\n-        checkSegment();\n-        int x = UNSAFE.getIntUnaligned(hb, byteOffset(checkIndex(i, 4)), bigEndian);\n+        int x = SCOPED_MEMORY_ACCESS.getIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), bigEndian);\n@@ -559,1 +538,0 @@\n-        checkSegment();\n@@ -561,1 +539,1 @@\n-        UNSAFE.putIntUnaligned(hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(nextPutIndex(4)), y, bigEndian);\n@@ -570,1 +548,0 @@\n-        checkSegment();\n@@ -572,1 +549,1 @@\n-        UNSAFE.putIntUnaligned(hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putIntUnaligned(scope(), hb, byteOffset(checkIndex(i, 4)), y, bigEndian);\n@@ -604,2 +581,1 @@\n-        checkSegment();\n-        long x = UNSAFE.getLongUnaligned(hb, byteOffset(nextGetIndex(8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(nextGetIndex(8)), bigEndian);\n@@ -610,2 +586,1 @@\n-        checkSegment();\n-        long x = UNSAFE.getLongUnaligned(hb, byteOffset(checkIndex(i, 8)), bigEndian);\n+        long x = SCOPED_MEMORY_ACCESS.getLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), bigEndian);\n@@ -619,1 +594,0 @@\n-        checkSegment();\n@@ -621,1 +595,1 @@\n-        UNSAFE.putLongUnaligned(hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(nextPutIndex(8)), y, bigEndian);\n@@ -630,1 +604,0 @@\n-        checkSegment();\n@@ -632,1 +605,1 @@\n-        UNSAFE.putLongUnaligned(hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n+        SCOPED_MEMORY_ACCESS.putLongUnaligned(scope(), hb, byteOffset(checkIndex(i, 8)), y, bigEndian);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":30,"deletions":57,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -978,1 +978,1 @@\n-                    UNSAFE.copyMemory(srcBase,\n+                    SCOPED_MEMORY_ACCESS.copyMemory(scope(), src.scope(), srcBase,\n@@ -990,1 +990,1 @@\n-                    UNSAFE.copySwapMemory(srcBase,\n+                    SCOPED_MEMORY_ACCESS.copySwapMemory(scope(), src.scope(), srcBase,\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n+\n@@ -34,2 +36,0 @@\n-    void checkValidState();\n-\n@@ -37,2 +37,3 @@\n-     * Check that memory access is within spatial and temporal bounds.\n-     * @throws IllegalStateException if underlying segment has been closed already.\n+     * Check that memory access is within spatial bounds and that access is compatible with segment access modes.\n+     * @throws UnsupportedOperationException if underlying segment has incompatible access modes (e.g. attempting to write\n+     * a read-only segment).\n@@ -45,0 +46,1 @@\n+    ScopedMemoryAccess.Scope scope();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/foreign\/MemorySegmentProxy.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3850,0 +3850,1 @@\n+    private native void synchronizeThreads0(Object deopt, Throwable exception);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,698 @@\n+    @ForceInline\n+    public $type$ get$Type$(Scope scope, Object base, long offset) {\n+        try {\n+            return get$Type$Internal(scope, base, offset);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$Internal(Scope scope, Object base, long offset) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+#if[Unaligned]\n+    @ForceInline\n+    public $type$ get$Type$Unaligned(Scope scope, Object base, long offset, boolean be) {\n+        try {\n+            return get$Type$UnalignedInternal(scope, base, offset, be);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$UnalignedInternal(Scope scope, Object base, long offset, boolean be) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$Unaligned(base, offset, be);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Unaligned(Scope scope, Object base, long offset, $type$ value, boolean be) {\n+        try {\n+            put$Type$UnalignedInternal(scope, base, offset, value, be);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$UnalignedInternal(Scope scope, Object base, long offset, $type$ value, boolean be) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$Unaligned(base, offset, value, be);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#end[Unaligned]\n+\n+    @ForceInline\n+    public $type$ get$Type$Volatile(Scope scope, Object base, long offset) {\n+        try {\n+            return get$Type$VolatileInternal(scope, base, offset);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$VolatileInternal(Scope scope, Object base, long offset) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$Volatile(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Volatile(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$VolatileInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$VolatileInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$Volatile(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ get$Type$Acquire(Scope scope, Object base, long offset) {\n+        try {\n+            return get$Type$AcquireInternal(scope, base, offset);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$AcquireInternal(Scope scope, Object base, long offset) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$Acquire(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void put$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ get$Type$Opaque(Scope scope, Object base, long offset) {\n+        try {\n+            return get$Type$OpaqueInternal(scope, base, offset);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ get$Type$OpaqueInternal(Scope scope, Object base, long offset) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.get$Type$Opaque(base, offset);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+    @ForceInline\n+    public void put$Type$Opaque(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            put$Type$OpaqueInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void put$Type$OpaqueInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.put$Type$Opaque(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#if[CAS]\n+    @ForceInline\n+    public boolean compareAndSet$Type$(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return compareAndSet$Type$Internal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean compareAndSet$Type$Internal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.compareAndSet$Type$(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ compareAndExchange$Type$(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return compareAndExchange$Type$Internal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ compareAndExchange$Type$Internal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.compareAndExchange$Type$(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ compareAndExchange$Type$Acquire(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return compareAndExchange$Type$AcquireInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ compareAndExchange$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.compareAndExchange$Type$Acquire(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ compareAndExchange$Type$Release(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return compareAndExchange$Type$ReleaseInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ compareAndExchange$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.compareAndExchange$Type$Release(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean weakCompareAndSet$Type$Plain(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return weakCompareAndSet$Type$PlainInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean weakCompareAndSet$Type$PlainInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.weakCompareAndSet$Type$Plain(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean weakCompareAndSet$Type$(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return weakCompareAndSet$Type$Internal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean weakCompareAndSet$Type$Internal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.weakCompareAndSet$Type$(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean weakCompareAndSet$Type$Acquire(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return weakCompareAndSet$Type$AcquireInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean weakCompareAndSet$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.weakCompareAndSet$Type$Acquire(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public boolean weakCompareAndSet$Type$Release(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            return weakCompareAndSet$Type$ReleaseInternal(scope, base, offset, expected, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private boolean weakCompareAndSet$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ expected, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.weakCompareAndSet$Type$Release(base, offset, expected, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndSet$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndSet$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndSet$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndSet$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndSet$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndSet$Type$AcquireInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndSet$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndSet$Type$Acquire(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndSet$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndSet$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndSet$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndSet$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#end[CAS]\n+\n+#if[AtomicAdd]\n+    @ForceInline\n+    public $type$ getAndAdd$Type$(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            return getAndAdd$Type$Internal(scope, base, offset, delta);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndAdd$Type$Internal(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndAdd$Type$(base, offset, delta);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndAdd$Type$Acquire(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            return getAndAdd$Type$AcquireInternal(scope, base, offset, delta);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndAdd$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndAdd$Type$Acquire(base, offset, delta);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndAdd$Type$Release(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            return getAndAdd$Type$ReleaseInternal(scope, base, offset, delta);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndAdd$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ delta) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndAdd$Type$Release(base, offset, delta);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#end[AtomicAdd]\n+\n+#if[Bitwise]\n+    @ForceInline\n+    public $type$ getAndBitwiseOr$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseOr$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseOr$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseOr$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseOr$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseOr$Type$AcquireInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseOr$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseOr$Type$Acquire(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseOr$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseOr$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseOr$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseOr$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseAnd$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseAnd$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseAnd$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseAnd$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseAnd$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseAnd$Type$AcquireInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseAnd$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseAnd$Type$Acquire(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseAnd$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseAnd$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseAnd$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseAnd$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseXor$Type$(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseXor$Type$Internal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseXor$Type$Internal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseXor$Type$(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseXor$Type$Acquire(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseXor$Type$AcquireInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseXor$Type$AcquireInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseXor$Type$Acquire(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public $type$ getAndBitwiseXor$Type$Release(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            return getAndBitwiseXor$Type$ReleaseInternal(scope, base, offset, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private $type$ getAndBitwiseXor$Type$ReleaseInternal(Scope scope, Object base, long offset, $type$ value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            return UNSAFE.getAndBitwiseXor$Type$Release(base, offset, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+#end[Bitwise]\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess-bin.java.template","additions":698,"deletions":0,"binary":false,"changes":698,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.misc;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.ref.Reference;\n+\n+import jdk.internal.util.ArraysSupport;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\n+\/**\n+ * This class defines low-level methods to access on-heap and off-heap memory. The methods in this class\n+ * can be thought of as thin wrappers around methods provided in the {@link Unsafe} class. All the methods in this\n+ * class, accept one or more {@link Scope} parameter, which is used to validate as to whether access to memory\n+ * can be performed in a safe fashion - more specifically, to ensure that the memory being accessed has not\n+ * already been released (which would result in a hard VM crash).\n+ * <p>\n+ * Accessing and releasing memory from a single thread is not problematic - after all, a given thread cannot,\n+ * at the same time, access the a memory region <em>and<\/em> free it. But ensuring correctness of memory access\n+ * when multiple threads are involved is much trickier, as there can be cases where a thread is accessing\n+ * a memory region while another thread is releasing it.\n+ * <p>\n+ * This class provides tools to manages races when multiple threads are accessing and\/or releasing the same memory\n+ * region concurrently. More specifically, when a thread wants to release a memory region, it should call the\n+ * {@link #closeScope(jdk.internal.misc.ScopedMemoryAccess.Scope)} method provided by this class. This method initiates\n+ * a thread-local handshakes with all the other VM threads, which are then stopped one by one. If any thread is found\n+ * accessing memory that is associated to the very scope object being closed, that thread execution is asynchronously\n+ * interrupted with a {@link Scope.ScopedAccessException}.\n+ * <p>\n+ * This synchronization strategy relies on the idea that accessing memory is atomic with respect to checking the\n+ * validity of the scope associated with that memory region - that is, a thread that wants to perform memory access will be\n+ * suspended either <em>before<\/em> a scope check or <em>after<\/em> the memory access. To ensure this atomicity,\n+ * all methods in this class are marked with the special {@link Scoped} annotation, which is recognized by the VM,\n+ * and used during the thread-local handshake to detect (and stop) threads performing potentially problematic memory access\n+ * operations. Additionally, to make sure that the scope object(s) of the memory being accessed is always\n+ * reachable during an access operation, all the methods in this class add reachability fences around the underlying\n+ * unsafe access.\n+ * <p>\n+ * This form of synchronization allows APIs to use plain memory access without any other form of synchronization\n+ * which might be deemed to expensive; in other words, this approach prioritizes the performance of memory access over\n+ * that of releasing a shared memory resource.\n+ *\/\n+public class ScopedMemoryAccess {\n+\n+    private static Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    private static native void registerNatives();\n+    static {\n+        registerNatives();\n+    }\n+\n+    public void closeScope(Scope scope) {\n+        closeScope0(scope, Scope.ScopedAccessException.INSTANCE);\n+    }\n+\n+    native void closeScope0(Scope scope, Scope.ScopedAccessException exception);\n+\n+    private ScopedMemoryAccess() {}\n+\n+    private static final ScopedMemoryAccess theScopedMemoryAccess = new ScopedMemoryAccess();\n+\n+    public static ScopedMemoryAccess getScopedMemoryAccess() {\n+        return theScopedMemoryAccess;\n+    }\n+\n+    \/**\n+     * Scope interface used during scoped memory access operations. A scope can be thought of as an object\n+     * which embodies the temporal checks associated with a given memory region.\n+     *\/\n+    public interface Scope {\n+        void checkValidState();\n+\n+        \/**\n+         * Exception thrown when memory access fails because the memory has already been released.\n+         * Note: for performance reasons, this exception is never created by client; instead a shared instance\n+         * is thrown (sometimes, this instance can be thrown asynchronosuly inside VM code). For this reason,\n+         * it is important for clients to always catch this exception and throw a regular exception instead\n+         * (which contains full stack information).\n+         *\/\n+        final class ScopedAccessException extends RuntimeException {\n+            private ScopedAccessException() { }\n+            static final long serialVersionUID = 1L;\n+\n+            public static final ScopedAccessException INSTANCE = new ScopedAccessException();\n+        }\n+    }\n+\n+    @Target({ElementType.METHOD, ElementType.CONSTRUCTOR})\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface Scoped { }\n+\n+    \/\/ bulk ops\n+\n+    @ForceInline\n+    public void copyMemory(Scope srcScope, Scope dstScope,\n+                                   Object srcBase, long srcOffset,\n+                                   Object destBase, long destOffset,\n+                                   long bytes) {\n+          try {\n+              copyMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes);\n+          } catch (Scope.ScopedAccessException ex) {\n+              throw new IllegalStateException(\"This segment is already closed\");\n+          }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void copyMemoryInternal(Scope srcScope, Scope dstScope,\n+                               Object srcBase, long srcOffset,\n+                               Object destBase, long destOffset,\n+                               long bytes) {\n+        try {\n+            if (srcScope != null) {\n+                srcScope.checkValidState();\n+            }\n+            if (dstScope != null) {\n+                dstScope.checkValidState();\n+            }\n+            UNSAFE.copyMemory(srcBase, srcOffset, destBase, destOffset, bytes);\n+        } finally {\n+            Reference.reachabilityFence(srcScope);\n+            Reference.reachabilityFence(dstScope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void copySwapMemory(Scope srcScope, Scope dstScope,\n+                                   Object srcBase, long srcOffset,\n+                                   Object destBase, long destOffset,\n+                                   long bytes, long elemSize) {\n+          try {\n+              copySwapMemoryInternal(srcScope, dstScope, srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n+          } catch (Scope.ScopedAccessException ex) {\n+              throw new IllegalStateException(\"This segment is already closed\");\n+          }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void copySwapMemoryInternal(Scope srcScope, Scope dstScope,\n+                               Object srcBase, long srcOffset,\n+                               Object destBase, long destOffset,\n+                               long bytes, long elemSize) {\n+        try {\n+            if (srcScope != null) {\n+                srcScope.checkValidState();\n+            }\n+            if (dstScope != null) {\n+                dstScope.checkValidState();\n+            }\n+            UNSAFE.copySwapMemory(srcBase, srcOffset, destBase, destOffset, bytes, elemSize);\n+        } finally {\n+            Reference.reachabilityFence(srcScope);\n+            Reference.reachabilityFence(dstScope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public void setMemory(Scope scope, Object o, long offset, long bytes, byte value) {\n+        try {\n+            setMemoryInternal(scope, o, offset, bytes, value);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private void setMemoryInternal(Scope scope, Object o, long offset, long bytes, byte value) {\n+        try {\n+            if (scope != null) {\n+                scope.checkValidState();\n+            }\n+            UNSAFE.setMemory(o, offset, bytes, value);\n+        } finally {\n+            Reference.reachabilityFence(scope);\n+        }\n+    }\n+\n+    @ForceInline\n+    public int vectorizedMismatch(Scope aScope, Scope bScope,\n+                                             Object a, long aOffset,\n+                                             Object b, long bOffset,\n+                                             int length,\n+                                             int log2ArrayIndexScale) {\n+        try {\n+            return vectorizedMismatchInternal(aScope, bScope, a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n+        } catch (Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n+    @ForceInline @Scoped\n+    private int vectorizedMismatchInternal(Scope aScope, Scope bScope,\n+                                             Object a, long aOffset,\n+                                             Object b, long bOffset,\n+                                             int length,\n+                                             int log2ArrayIndexScale) {\n+        try {\n+            if (aScope != null) {\n+                aScope.checkValidState();\n+            }\n+            if (bScope != null) {\n+                bScope.checkValidState();\n+            }\n+            return ArraysSupport.vectorizedMismatch(a, aOffset, b, bOffset, length, log2ArrayIndexScale);\n+        } finally {\n+            Reference.reachabilityFence(aScope);\n+            Reference.reachabilityFence(bScope);\n+        }\n+    }\n+    \/\/ typed-ops here\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -163,31 +163,0 @@\n-    \/**\n-     * Mismatch over long lengths.\n-     *\/\n-    public static long vectorizedMismatchLargeForBytes(Object a, long aOffset,\n-                                                       Object b, long bOffset,\n-                                                       long length) {\n-        long off = 0;\n-        long remaining = length;\n-        int i, size;\n-        boolean lastSubRange = false;\n-        while (remaining > 7 && !lastSubRange) {\n-            if (remaining > Integer.MAX_VALUE) {\n-                size = Integer.MAX_VALUE;\n-            } else {\n-                size = (int) remaining;\n-                lastSubRange = true;\n-            }\n-            i = vectorizedMismatch(\n-                    a, aOffset + off,\n-                    b, bOffset + off,\n-                    size, LOG2_ARRAY_BYTE_INDEX_SCALE);\n-            if (i >= 0)\n-                return off + i;\n-\n-            i = size - ~i;\n-            off += i;\n-            remaining -= i;\n-        }\n-        return ~remaining;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ArraysSupport.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n- * {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n+ * {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. The set of access modes supported by a segment alters the\n@@ -153,2 +153,4 @@\n- * to obtain a {@link Spliterator} from a segment, which can be used to slice the segment and allow multiple thread to\n- * work in parallel on disjoint segment slices (this assumes that the access mode {@link #ACQUIRE} is set).\n+ * to derive a <em>shared<\/em> segment from a confined one. This can be done again, by calling {@link #withOwnerThread(Thread)},\n+ * and passing a {@code null} owner segment (this assumes that the access mode {@link #SHARE} of the original segment is set).\n+ * For instance, a client might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the\n+ * segment and allow multiple thread to work in parallel on disjoint segment slices.\n@@ -157,1 +159,0 @@\n-MemorySegment segment = ...\n@@ -159,4 +160,6 @@\n-VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n-int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)\n-                       .mapToInt(s -> (int)VH_int.get(s.address()))\n-                       .sum();\n+try (MemorySegment segment = MemorySegment.allocateNative(SEQUENCE_LAYOUT).withOwnerThread(null)) {\n+    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n+    int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)\n+                           .mapToInt(s -> (int)VH_int.get(s.address()))\n+                           .sum();\n+}\n@@ -164,0 +167,2 @@\n+ * Once shared, a segment can be claimed back by a given thread (see {@link #withOwnerThread(Thread)}); in fact, many threads\n+ * can attempt to gain ownership of the same segment, concurrently, and only one of them is guaranteed to succeed.\n@@ -197,1 +202,1 @@\n-     * be processed in parallel by multiple threads (if the access mode {@link #ACQUIRE} is set).\n+     * be processed in parallel by multiple threads (if the access mode {@link #SHARE} is set).\n@@ -223,0 +228,3 @@\n+     *<p>If {@code newOwner} is {@code != null}, then the resulting segment will\n+     * be a confined segment, whose owner thread is {@code newOwner}. Otherwise, the resulting segment will be\n+     * a shared segment, and will be accessible concurrently from multiple threads.\n@@ -228,3 +236,3 @@\n-     * @param newOwner the new owner thread.\n-     * @return a new memory segment backed by the same underlying memory region as this segment,\n-     *      owned by {@code newOwner}.\n+     * @param newOwner the new owner thread (can be {@code null}).\n+     * @return a new memory segment backed by the same underlying memory region as this segment; the new segment can\n+     * be either a confined segment ({@code newOwner != null}) or a shared segment ({@code newOwner == null}).\n@@ -232,1 +240,1 @@\n-     * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different\n+     * thread owning this segment.\n@@ -234,3 +242,3 @@\n-     * @throws NullPointerException if {@code newOwner == null}\n-     * @throws IllegalArgumentException if the segment is already a confined segment owner by {@code newOnwer}.\n-     * @throws UnsupportedOperationException if this segment does not support the {@link #HANDOFF} access mode.\n+     * @throws IllegalArgumentException if the segment is already a confined segment owner by {@code newOnwer}\n+     * @throws UnsupportedOperationException if {@code newOwner != null} and this segment does not support the {@link #HANDOFF} access mode,\n+     * or if {@code newOwner == null} and this segment does not support the {@link #SHARE} access mode.\n@@ -248,1 +256,1 @@\n-     * {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n+     * {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}. It is generally not possible to go from a segment with stricter access modes\n@@ -268,1 +276,1 @@\n-     * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #ACQUIRE} and {@link #HANDOFF}.\n+     * {@link #READ}, {@link #WRITE}, {@link #CLOSE}, {@link #SHARE} and {@link #HANDOFF}.\n@@ -317,1 +325,1 @@\n-     * thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different\n+     * thread owning this segment.\n@@ -788,1 +796,1 @@\n-     * Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator\n+     * Share access mode; this segment support sharing with threads other than the owner thread (see {@link #withOwnerThread(Thread)}}).\n@@ -793,1 +801,1 @@\n-    int ACQUIRE = CLOSE << 1;\n+    int SHARE = CLOSE << 1;\n@@ -801,1 +809,1 @@\n-    int HANDOFF = ACQUIRE << 1;\n+    int HANDOFF = SHARE << 1;\n@@ -808,1 +816,1 @@\n-    int ALL_ACCESS = READ | WRITE | CLOSE | ACQUIRE | HANDOFF;\n+    int ALL_ACCESS = READ | WRITE | CLOSE | SHARE | HANDOFF;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":31,"deletions":23,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -65,0 +66,1 @@\n+    private static final ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -129,1 +131,1 @@\n-        UNSAFE.setMemory(base(), min(), length, value);\n+        SCOPED_MEMORY_ACCESS.setMemory(scope, base(), min(), length, value);\n@@ -138,1 +140,1 @@\n-        UNSAFE.copyMemory(\n+        SCOPED_MEMORY_ACCESS.copyMemory(scope, that.scope,\n@@ -155,0 +157,1 @@\n+            checkValidState();\n@@ -163,1 +166,1 @@\n-            i = ArraysSupport.vectorizedMismatchLargeForBytes(\n+            i = vectorizedMismatchLargeForBytes(scope, that.scope,\n@@ -182,0 +185,32 @@\n+    \/**\n+     * Mismatch over long lengths.\n+     *\/\n+    private static long vectorizedMismatchLargeForBytes(MemoryScope aScope, MemoryScope bScope,\n+                                                       Object a, long aOffset,\n+                                                       Object b, long bOffset,\n+                                                       long length) {\n+        long off = 0;\n+        long remaining = length;\n+        int i, size;\n+        boolean lastSubRange = false;\n+        while (remaining > 7 && !lastSubRange) {\n+            if (remaining > Integer.MAX_VALUE) {\n+                size = Integer.MAX_VALUE;\n+            } else {\n+                size = (int) remaining;\n+                lastSubRange = true;\n+            }\n+            i = SCOPED_MEMORY_ACCESS.vectorizedMismatch(aScope, bScope,\n+                    a, aOffset + off,\n+                    b, bOffset + off,\n+                    size, ArraysSupport.LOG2_ARRAY_BYTE_INDEX_SCALE);\n+            if (i >= 0)\n+                return off + i;\n+\n+            i = size - ~i;\n+            off += i;\n+            remaining -= i;\n+        }\n+        return ~remaining;\n+    }\n+\n@@ -246,3 +281,3 @@\n-        Objects.requireNonNull(newOwner);\n-        if (!isSet(HANDOFF)) {\n-            throw unsupportedAccessMode(HANDOFF);\n+        int expectedMode = newOwner != null ? HANDOFF : SHARE;\n+        if (!isSet(expectedMode)) {\n+            throw unsupportedAccessMode(expectedMode);\n@@ -250,9 +285,8 @@\n-        if (scope.ownerThread() == newOwner) {\n-            throw new IllegalArgumentException(\"Segment already owned by thread: \" + newOwner);\n-        } else {\n-            try {\n-                return dup(0L, length, mask, scope.dup(newOwner));\n-            } finally {\n-                \/\/flush read\/writes to segment memory before returning the new segment\n-                VarHandle.fullFence();\n-            }\n+        try {\n+            return dup(0L, length, mask,\n+                    expectedMode == HANDOFF ?\n+                            scope.confineTo(newOwner) :\n+                            scope.share());\n+        } finally {\n+            \/\/flush read\/writes to segment memory before returning the new segment\n+            VarHandle.fullFence();\n@@ -274,7 +308,0 @@\n-    final AbstractMemorySegmentImpl acquire() {\n-        if (Thread.currentThread() != ownerThread() && !isSet(ACQUIRE)) {\n-            throw unsupportedAccessMode(ACQUIRE);\n-        }\n-        return dup(0, length, mask, scope.acquire());\n-    }\n-\n@@ -331,1 +358,0 @@\n-        scope.checkValidState();\n@@ -340,0 +366,13 @@\n+    private void checkAccessAndScope(long offset, long length, boolean readOnly) {\n+        checkValidState();\n+        checkAccess(offset, length, readOnly);\n+    }\n+\n+    private void checkValidState() {\n+        try {\n+            scope.checkValidState();\n+        } catch (ScopedMemoryAccess.Scope.ScopedAccessException ex) {\n+            throw new IllegalStateException(\"This segment is already closed\");\n+        }\n+    }\n+\n@@ -350,5 +389,0 @@\n-    @Override\n-    public final void checkValidState() {\n-        scope.checkValidState();\n-    }\n-\n@@ -384,0 +418,5 @@\n+    @Override\n+    public MemoryScope scope() {\n+        return scope;\n+    }\n+\n@@ -408,1 +447,1 @@\n-        if ((mode & ACQUIRE) != 0) {\n+        if ((mode & SHARE) != 0) {\n@@ -459,1 +498,1 @@\n-                AbstractMemorySegmentImpl acquired = segment.acquire();\n+                AbstractMemorySegmentImpl acquired = segment;\n@@ -463,1 +502,0 @@\n-                    acquired.closeNoCheck();\n@@ -479,1 +517,1 @@\n-                AbstractMemorySegmentImpl acquired = segment.acquire();\n+                AbstractMemorySegmentImpl acquired = segment;\n@@ -494,1 +532,0 @@\n-                    acquired.closeNoCheck();\n@@ -535,1 +572,1 @@\n-            bufferScope = MemoryScope.create(bb, null);\n+            bufferScope = MemoryScope.createConfined(bb, null);\n@@ -551,1 +588,1 @@\n-        0, 0, MemoryScope.createUnchecked(null, null, null)\n+        0, 0, MemoryScope.createShared(null, null)\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":72,"deletions":35,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-        MemoryScope scope = MemoryScope.create(null, null);\n+        MemoryScope scope = MemoryScope.createConfined(null, null);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-            MemoryScope scope = MemoryScope.create(null, unmapperProxy::unmap);\n+            MemoryScope scope = MemoryScope.createConfined(null, unmapperProxy::unmap);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.misc.ScopedMemoryAccess;\n@@ -33,3 +34,0 @@\n-import java.util.Objects;\n-import java.util.concurrent.atomic.LongAdder;\n-import java.util.concurrent.locks.StampedLock;\n@@ -39,18 +37,10 @@\n- * as thread confinement.\n- * A scope has a liveness bit, which is updated when the scope is closed\n- * (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}).\n- * A scope may also have an associated \"owner\" thread that confines some operations to\n- * associated owner thread such as {@link #close()} or {@link #dup(Thread)}.\n- * Furthermore, a scope is either root scope ({@link #create(Object, Runnable) created}\n- * when memory segment is allocated) or child scope ({@link #acquire() acquired} from root scope).\n- * When a child scope is acquired from another child scope, it is actually acquired from\n- * the root scope. There is only a single level of children. All child scopes are peers.\n- * A child scope can be {@link #close() closed} at any time, but root scope can only\n- * be closed after all its children have been closed, at which time any associated\n- * cleanup action is executed (the associated memory segment is freed).\n- * Besides thread-confined checked scopes, {@linkplain #createUnchecked(Thread, Object, Runnable)}\n- * method may be used passing {@code null} as the \"owner\" thread to create a\n- * scope that doesn't check for thread-confinement while its temporal bounds are\n- * enforced reliably only under condition that thread that closes the scope is also\n- * the single thread performing the checked access or there is an external synchronization\n- * in place that prevents concurrent access and closing of the scope.\n+ * as thread confinement. A scope has a liveness bit, which is updated when the scope is closed\n+ * (this operation is triggered by {@link AbstractMemorySegmentImpl#close()}). This bit is consulted prior\n+ * to memory access (see {@link #checkValidState()}).\n+ * There are two kinds of memory scope: confined memory scope and shared memory scope.\n+ * A confined memory scope has an associated owner thread that confines some operations to\n+ * associated owner thread such as {@link #close()} or {@link #checkValidState()}.\n+ * Shared scopes do not feature an owner thread - meaning their operations can be called, in a racy\n+ * manner, by multiple threads. To guarantee temporal safety in the presence of concurrent thread,\n+ * shared scopes use a more sophisticated synchronization mechanism, which guarantees that no concurrent\n+ * access is possible when a scope is being closed (see {@link jdk.internal.misc.ScopedMemoryAccess}.\n@@ -58,1 +48,17 @@\n-abstract class MemoryScope {\n+abstract class MemoryScope implements ScopedMemoryAccess.Scope {\n+\n+    private MemoryScope(Object ref, Runnable cleanupAction) {\n+        this.ref = ref;\n+        this.cleanupAction = cleanupAction;\n+    }\n+\n+    \/**\n+     * Creates a confined memory scope with given attachment and cleanup action. The returned scope\n+     * is assumed to be confined on the current thread.\n+     * @param ref           an optional reference to an instance that needs to be kept reachable\n+     * @param cleanupAction an optional cleanup action to be executed when returned scope is closed\n+     * @return a confined memory scope\n+     *\/\n+    static MemoryScope createConfined(Object ref, Runnable cleanupAction) {\n+        return createConfined(Thread.currentThread(), ref, cleanupAction);\n+    }\n@@ -61,8 +67,1 @@\n-     * Creates a root MemoryScope with given ref, cleanupAction and current\n-     * thread as the \"owner\" thread.\n-     * This method may be called in any thread.\n-     * The returned instance may be published unsafely to and used in any thread,\n-     * but methods that explicitly state that they may only be called in \"owner\" thread,\n-     * must strictly be called in the thread that created the scope\n-     * or else IllegalStateException is thrown.\n-     *\n+     * Creates a confined memory scope with given attachment, cleanup action and owner thread.\n@@ -71,1 +70,1 @@\n-     * @return a root MemoryScope\n+     * @return a confined memory scope\n@@ -73,2 +72,2 @@\n-    static MemoryScope create(Object ref, Runnable cleanupAction) {\n-        return new Root(Thread.currentThread(), ref, cleanupAction);\n+    static MemoryScope createConfined(Thread owner, Object ref, Runnable cleanupAction) {\n+        return new ConfinedScope(owner, ref, cleanupAction);\n@@ -78,11 +77,1 @@\n-     * Creates a root MemoryScope with given ref, cleanupAction and \"owner\" thread.\n-     * This method may be called in any thread.\n-     * The returned instance may be published unsafely to and used in any thread,\n-     * but methods that explicitly state that they may only be called in \"owner\" thread,\n-     * must strictly be called in given owner thread or else IllegalStateException is thrown.\n-     * If given owner thread is null, the returned MemoryScope is unchecked, meaning\n-     * that all methods may be called in any thread and that {@link #checkValidState()}\n-     * does not check for temporal bounds.\n-     *\n-     * @param owner         the desired owner thread. If {@code owner == null},\n-     *                      the returned scope is <em>not<\/em> thread-confined and not checked.\n+     * Creates a shared memory scope with given attachment and cleanup action.\n@@ -91,1 +80,1 @@\n-     * @return a root MemoryScope\n+     * @return a shared memory scope\n@@ -93,2 +82,2 @@\n-    static MemoryScope createUnchecked(Thread owner, Object ref, Runnable cleanupAction) {\n-        return new Root(owner, ref, cleanupAction);\n+    static MemoryScope createShared(Object ref, Runnable cleanupAction) {\n+        return new SharedScope(ref, cleanupAction);\n@@ -97,2 +86,3 @@\n-    private final Thread owner;\n-    private boolean closed; \/\/ = false\n+    protected Object ref;\n+    protected Runnable cleanupAction;\n+    protected boolean closed; \/\/ = false\n@@ -109,4 +99,0 @@\n-    private MemoryScope(Thread owner) {\n-        this.owner = owner;\n-    }\n-\n@@ -114,10 +100,3 @@\n-     * Acquires a child scope (or peer scope if this is a child) with current\n-     * thread as the \"owner\" thread.\n-     * This method may be called in any thread.\n-     * The returned instance may be published unsafely to and used in any thread,\n-     * but methods that explicitly state that they may only be called in \"owner\" thread,\n-     * must strictly be called in the thread that acquired the scope\n-     * or else IllegalStateException is thrown.\n-     *\n-     * @return a child (or peer) scope\n-     * @throws IllegalStateException if root scope is already closed\n+     * Closes this scope, executing any cleanup action (where provided).\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread.\n@@ -125,1 +104,9 @@\n-    abstract MemoryScope acquire();\n+    final void close() {\n+        checkValidState();\n+        justClose();\n+        if (cleanupAction != null) {\n+            cleanupAction.run();\n+        }\n+    }\n+\n+    abstract void justClose();\n@@ -128,4 +115,3 @@\n-     * Closes this scope, executing any cleanup action if this is the root scope.\n-     * This method may only be called in the \"owner\" thread of this scope unless the\n-     * scope is a root scope with no owner thread - i.e. is not checked.\n-     *\n+     * Duplicates this scope with given new \"owner\" thread and {@link #close() closes} it.\n+     * @param newOwner new owner thread of the returned memory scope\n+     * @return a new confined scope, which is a duplicate of this scope, but with a new owner thread.\n@@ -133,3 +119,1 @@\n-     *                               a root scope and there is\/are still active child\n-     *                               scope(s) or if this method is called outside of\n-     *                               owner thread in checked scope\n+     * a confined scope and this method is called outside of the owner thread.\n@@ -137,1 +121,5 @@\n-    abstract void close();\n+    MemoryScope confineTo(Thread newOwner) {\n+        checkValidState();\n+        justClose();\n+        return new ConfinedScope(newOwner, ref, cleanupAction);\n+    }\n@@ -141,13 +129,1 @@\n-     * If this is a root scope, a new root scope is returned; this root scope is closed, but\n-     * without executing the cleanup action, which is instead transferred to the duped scope.\n-     * If this is a child scope, a new child scope is returned.\n-     * This method may only be called in the \"owner\" thread of this scope unless the\n-     * scope is a root scope with no owner thread - i.e. is not checked.\n-     * The returned instance may be published unsafely to and used in any thread,\n-     * but methods that explicitly state that they may only be called in \"owner\" thread,\n-     * must strictly be called in given new \"owner\" thread\n-     * or else IllegalStateException is thrown.\n-     *\n-     * @param newOwner new owner thread of the returned MemoryScope\n-     * @return a duplicate of this scope\n-     * @throws NullPointerException  if given owner thread is null\n+     * @return a new shared scope, which is a duplicate of this scope.\n@@ -155,3 +131,2 @@\n-     *                               a root scope and there is\/are still active child\n-     *                               scope(s) or if this method is called outside of\n-     *                               owner thread in checked scope\n+     * a confined scope and this method is called outside of the owner thread,\n+     * or if this is already a shared scope.\n@@ -159,1 +134,5 @@\n-    abstract MemoryScope dup(Thread newOwner);\n+    MemoryScope share() {\n+        checkValidState();\n+        justClose();\n+        return new SharedScope(ref, cleanupAction);\n+    }\n@@ -163,2 +142,1 @@\n-     *\n-     * @return owner thread (or null for unchecked scope)\n+     * @return owner thread (or null for a shared scope)\n@@ -166,3 +144,1 @@\n-    final Thread ownerThread() {\n-        return owner;\n-    }\n+    abstract Thread ownerThread();\n@@ -171,2 +147,1 @@\n-     * This method may be called in any thread.\n-     *\n+     * Returns true, if this scope is still alive. This method may be called in any thread.\n@@ -180,7 +155,3 @@\n-     * Checks that this scope is still alive and that this method is executed\n-     * in the \"owner\" thread of this scope or this scope is unchecked (not associated\n-     * with owner thread).\n-     *\n-     * @throws IllegalStateException if this scope is already closed or this\n-     *                               method is executed outside owning thread\n-     *                               in checked scope\n+     * Checks that this scope is still alive (see {@link #isAlive()}).\n+     * @throws IllegalStateException if this scope is already closed or if this is\n+     * a confined scope and this method is called outside of the owner thread.\n@@ -188,6 +159,5 @@\n-    @ForceInline\n-    final void checkValidState() {\n-        if (owner != null && owner != Thread.currentThread()) {\n-            throw new IllegalStateException(\"Attempted access outside owning thread\");\n-        }\n-        checkAliveConfined(this);\n+    public abstract void checkValidState();\n+\n+    @Override\n+    protected Object clone() throws CloneNotSupportedException {\n+        throw new CloneNotSupportedException();\n@@ -197,3 +167,3 @@\n-     * Checks that this scope is still alive.\n-     *\n-     * @throws IllegalStateException if this scope is already closed\n+     * Checks that this scope is still alive (see {@link #isAlive()}), by performing\n+     * a quick, plain access. As such, this method should be used with care.\n+     * @throws ScopedAccessException if this scope is already closed.\n@@ -202,1 +172,1 @@\n-    private static void checkAliveConfined(MemoryScope scope) {\n+    private static void checkAliveRaw(MemoryScope scope) {\n@@ -204,1 +174,1 @@\n-            throw new IllegalStateException(\"This segment is already closed\");\n+            throw ScopedAccessException.INSTANCE;\n@@ -208,5 +178,9 @@\n-    private static final class Root extends MemoryScope {\n-        private final StampedLock lock = new StampedLock();\n-        private final LongAdder acquired = new LongAdder();\n-        private final Object ref;\n-        private final Runnable cleanupAction;\n+    \/**\n+     * A confined scope, which features an owner thread. The liveness check features an additional\n+     * confinement check - that is, calling any operation on this scope from a thread other than the\n+     * owner thread will result in an exception. Because of this restriction, checking the liveness bit\n+     * can be performed in plain mode (see {@link #checkAliveRaw(MemoryScope)}).\n+     *\/\n+    static class ConfinedScope extends MemoryScope {\n+\n+        final Thread owner;\n@@ -214,4 +188,3 @@\n-        private Root(Thread owner, Object ref, Runnable cleanupAction) {\n-            super(owner);\n-            this.ref = ref;\n-            this.cleanupAction = cleanupAction;\n+        public ConfinedScope(Thread owner, Object ref, Runnable cleanupAction) {\n+            super(ref, cleanupAction);\n+            this.owner = owner;\n@@ -220,24 +193,4 @@\n-        @Override\n-        MemoryScope acquire() {\n-            \/\/ try to optimistically acquire the lock\n-            long stamp = lock.tryOptimisticRead();\n-            try {\n-                for (; ; stamp = lock.readLock()) {\n-                    if (stamp == 0L)\n-                        continue;\n-                    checkAliveConfined(this); \/\/ plain read is enough here (either successful optimistic read, or full read lock)\n-\n-                    \/\/ increment acquires\n-                    acquired.increment();\n-                    \/\/ did a call to close() occur since we acquired the lock?\n-                    if (lock.validate(stamp)) {\n-                        \/\/ no, just return the acquired scope\n-                        return new Child(Thread.currentThread());\n-                    } else {\n-                        \/\/ yes, just back off and retry (close might have failed, after all)\n-                        acquired.decrement();\n-                    }\n-                }\n-            } finally {\n-                if (StampedLock.isReadLockStamp(stamp))\n-                    lock.unlockRead(stamp);\n+        @ForceInline\n+        public final void checkValidState() {\n+            if (owner != Thread.currentThread()) {\n+                throw new IllegalStateException(\"Attempted access outside owning thread\");\n@@ -245,0 +198,1 @@\n+            checkAliveRaw(this);\n@@ -247,7 +201,3 @@\n-        @Override\n-        MemoryScope dup(Thread newOwner) {\n-            Objects.requireNonNull(newOwner, \"newOwner\");\n-            \/\/ pre-allocate duped scope so we don't get OOME later and be left with this scope closed\n-            var duped = new Root(newOwner, ref, cleanupAction);\n-            justClose();\n-            return duped;\n+        void justClose() {\n+            checkValidState();\n+            closed = true;\n@@ -257,4 +207,3 @@\n-        void close() {\n-            justClose();\n-            if (cleanupAction != null) {\n-                cleanupAction.run();\n+        MemoryScope confineTo(Thread newOwner) {\n+            if (newOwner == owner) {\n+                throw new IllegalArgumentException(\"Segment already owned by thread: \" + newOwner);\n@@ -262,0 +211,1 @@\n+            return super.confineTo(newOwner);\n@@ -264,16 +214,3 @@\n-        @ForceInline\n-        private void justClose() {\n-            \/\/ enter critical section - no acquires are possible past this point\n-            long stamp = lock.writeLock();\n-            try {\n-                checkValidState(); \/\/ plain read is enough here (full write lock)\n-                \/\/ check for absence of active acquired children\n-                if (acquired.sum() > 0) {\n-                    throw new IllegalStateException(\"Cannot close this scope as it has active acquired children\");\n-                }\n-                \/\/ now that we made sure there's no active acquired children, we can mark scope as closed\n-                CLOSED.set(this, true); \/\/ plain write is enough here (full write lock)\n-            } finally {\n-                \/\/ leave critical section\n-                lock.unlockWrite(stamp);\n-            }\n+        @Override\n+        Thread ownerThread() {\n+            return owner;\n@@ -281,0 +218,1 @@\n+    }\n@@ -282,1 +220,11 @@\n-        private final class Child extends MemoryScope {\n+    \/**\n+     * A shared scope, which can be shared across multiple threads. Closing a shared scope has to ensure that\n+     * (i) only one thread can successfully close a scope (e.g. in a close vs. close race) and that\n+     * (ii) no other thread is accessing the memory associated with this scope while the segment is being\n+     * closed. To ensure the former condition, a CAS is performed on the liveness bit. Ensuring the latter\n+     * is trickier, and require a complex synchronization protocol (see {@link jdk.internal.misc.ScopedMemoryAccess}).\n+     * Because of it is the job of the closing thread to make sure that no concurrent access is possible,\n+     * checking the liveness bit can be performed in plain mode (see {@link #checkAliveRaw(MemoryScope)}),\n+     * as in the confined case.\n+     *\/\n+    static class SharedScope extends MemoryScope {\n@@ -284,3 +232,1 @@\n-            private Child(Thread owner) {\n-                super(owner);\n-            }\n+        static ScopedMemoryAccess SCOPED_MEMORY_ACCESS = ScopedMemoryAccess.getScopedMemoryAccess();\n@@ -288,4 +234,3 @@\n-            @Override\n-            MemoryScope acquire() {\n-                return Root.this.acquire();\n-            }\n+        SharedScope(Object ref, Runnable cleanupAction) {\n+            super(ref, cleanupAction);\n+        }\n@@ -293,8 +238,14 @@\n-            @Override\n-            MemoryScope dup(Thread newOwner) {\n-                checkValidState(); \/\/ child scope is always checked\n-                \/\/ pre-allocate duped scope so we don't get OOME later and be left with this scope closed\n-                var duped = new Child(newOwner);\n-                CLOSED.setVolatile(this, true);\n-                return duped;\n-            }\n+        @Override\n+        MemoryScope share() {\n+            throw new IllegalStateException(\"Already shared\");\n+        }\n+\n+        @Override\n+        Thread ownerThread() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void checkValidState() {\n+            MemoryScope.checkAliveRaw(this);\n+        }\n@@ -302,7 +253,3 @@\n-            @Override\n-            void close() {\n-                checkValidState(); \/\/ child scope is always checked\n-                CLOSED.set(this, true);\n-                \/\/ following acts as a volatile write after plain write above so\n-                \/\/ plain write gets flushed too (which is important for isAliveThreadSafe())\n-                Root.this.acquired.decrement();\n+        void justClose() {\n+            if (!CLOSED.compareAndSet(this, false, true)) {\n+                throw new IllegalStateException(\"Already closed\");\n@@ -310,0 +257,1 @@\n+            SCOPED_MEMORY_ACCESS.closeScope(this);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryScope.java","additions":146,"deletions":198,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -100,1 +102,1 @@\n-        MemoryScope scope = MemoryScope.create(null, () -> {\n+        MemoryScope scope = MemoryScope.createConfined(null, () -> {\n@@ -114,1 +116,3 @@\n-        MemoryScope scope = MemoryScope.createUnchecked(owner, attachment, cleanup);\n+        MemoryScope scope = owner == null ?\n+                MemoryScope.createShared(attachment, cleanup) :\n+                MemoryScope.createConfined(owner, attachment, cleanup);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -312,2 +312,3 @@\n-            if (!e.getKey().getName().contains(\"get\") &&\n-                            !e.getKey().getName().contains(\"put\")) {\n+            if ((!e.getKey().getName().contains(\"get\") &&\n+                            !e.getKey().getName().contains(\"put\"))\n+                            || e.getValue().length > 2) { \/\/ skip bulk ops\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,204 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @modules jdk.incubator.foreign java.base\/jdk.internal.vm.annotation java.base\/jdk.internal.misc\n+ * @run testng\/othervm TestHandshake\n+ * @run testng\/othervm -Xint TestHandshake\n+ * @run testng\/othervm -XX:TieredStopAtLevel=1 TestHandshake\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.function.Function;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class TestHandshake {\n+\n+    static final int ITERATIONS = 5;\n+\n+    @Test(dataProvider = \"accessors\")\n+    public void testHandshake(Function<MemorySegment, Runnable> accessorFactory) throws InterruptedException {\n+        for (int it = 0 ; it < ITERATIONS ; it++) {\n+            MemorySegment segment = MemorySegment.allocateNative(1_000_000).withOwnerThread(null);\n+            System.err.println(\"ITERATION \" + it);\n+            List<Thread> accessors = new ArrayList<>();\n+            for (int i = 0; i < ThreadLocalRandom.current().nextInt(Runtime.getRuntime().availableProcessors()); i++) {\n+                Thread access = new Thread(accessorFactory.apply(segment));\n+                access.start();\n+                accessors.add(access);\n+            }\n+            Thread t2 = new Thread(new Handshaker(segment));\n+            t2.start();\n+            t2.join();\n+            accessors.forEach(t -> {\n+                try {\n+                    t.join();\n+                } catch (InterruptedException ex) {\n+                    \/\/ do nothing\n+                }\n+            });\n+            assertTrue(!segment.isAlive());\n+        }\n+    }\n+\n+    static class SegmentAccessor implements Runnable {\n+\n+        final MemorySegment segment;\n+\n+        SegmentAccessor(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                while (true) {\n+                    int sum = 0;\n+                    for (int i = 0; i < segment.byteSize(); i++) {\n+                        sum += MemoryAccess.getByteAtIndex(segment, i);\n+                    }\n+                }\n+            } catch (IllegalStateException ex) {\n+                \/\/ do nothing\n+            }\n+        }\n+    }\n+\n+    static class SegmentCopyAccessor implements Runnable {\n+\n+        final MemorySegment segment;\n+\n+        SegmentCopyAccessor(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                long split = segment.byteSize() \/ 2;\n+                MemorySegment first = segment.asSlice(0, split);\n+                MemorySegment second = segment.asSlice(split);\n+                while (true) {\n+                    for (int i = 0; i < segment.byteSize(); i++) {\n+                        first.copyFrom(second);\n+                    }\n+                }\n+            } catch (IllegalStateException ex) {\n+                \/\/ do nothing\n+            }\n+        }\n+    }\n+\n+    static class BufferAccessor implements Runnable {\n+\n+        final ByteBuffer bb;\n+\n+        BufferAccessor(MemorySegment segment) {\n+            this.bb = segment.asByteBuffer();\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                while (true) {\n+                    int sum = 0;\n+                    for (int i = 0; i < bb.capacity(); i++) {\n+                        sum += bb.get(i);\n+                    }\n+                }\n+            } catch (IllegalStateException ex) {\n+                \/\/ do nothing\n+            }\n+        }\n+    }\n+\n+    static class BufferHandleAccessor implements Runnable {\n+\n+        static VarHandle handle = MethodHandles.byteBufferViewVarHandle(short[].class, ByteOrder.nativeOrder());\n+\n+        final ByteBuffer bb;\n+\n+        public BufferHandleAccessor(MemorySegment segment) {\n+            this.bb = segment.asByteBuffer();\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                while (true) {\n+                    int sum = 0;\n+                    for (int i = 0; i < bb.capacity() \/ 2; i++) {\n+                        sum += (short)handle.get(bb, i);\n+                    }\n+                }\n+            } catch (IllegalStateException ex) {\n+                \/\/ do nothing\n+            }\n+        }\n+    };\n+\n+    static class Handshaker implements Runnable {\n+\n+        final MemorySegment segment;\n+\n+        Handshaker(MemorySegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                Thread.sleep(ThreadLocalRandom.current().nextInt(2000));\n+                long prev = System.currentTimeMillis();\n+                segment.close();\n+                long delay = System.currentTimeMillis() - prev;\n+                System.out.println(\"Segment closed - delay (ms): \" + delay);\n+            } catch (InterruptedException ex) {\n+                \/\/ do nothing\n+            }\n+        }\n+    }\n+\n+    @DataProvider\n+    static Object[][] accessors() {\n+        return new Object[][] {\n+                { (Function<MemorySegment, Runnable>)SegmentAccessor::new },\n+                { (Function<MemorySegment, Runnable>)SegmentCopyAccessor::new },\n+                { (Function<MemorySegment, Runnable>)BufferAccessor::new },\n+                { (Function<MemorySegment, Runnable>)BufferHandleAccessor::new }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":204,"deletions":0,"binary":false,"changes":204,"status":"added"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -43,1 +42,0 @@\n-import java.util.Spliterator;\n@@ -77,3 +75,0 @@\n-                    if (member.method.getName().equals(\"acquire\")) {\n-                        ((MemorySegment)o).close();\n-                    }\n@@ -315,0 +310,1 @@\n+                \"share\",\n@@ -380,1 +376,1 @@\n-        ACQUIRE(MemorySegment.ACQUIRE) {\n+        SHARE(MemorySegment.SHARE) {\n@@ -383,21 +379,1 @@\n-                Spliterator<MemorySegment> spliterator =\n-                        MemorySegment.spliterator(segment, MemoryLayout.ofSequence(segment.byteSize(), MemoryLayouts.JAVA_BYTE));\n-                AtomicReference<RuntimeException> exception = new AtomicReference<>();\n-                Runnable action = () -> {\n-                    try {\n-                        spliterator.tryAdvance(s -> { });\n-                    } catch (RuntimeException e) {\n-                        exception.set(e);\n-                    }\n-                };\n-                Thread thread = new Thread(action);\n-                thread.start();\n-                try {\n-                    thread.join();\n-                } catch (InterruptedException ex) {\n-                    throw new AssertionError(ex);\n-                }\n-                RuntimeException e = exception.get();\n-                if (e != null) {\n-                    throw e;\n-                }\n+                segment.withOwnerThread(null);\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-        try (MemorySegment s = MemorySegment.allocateNative(layout)) {\n+        try (MemorySegment s = MemorySegment.allocateNative(layout).withOwnerThread(null)) {\n@@ -148,3 +148,3 @@\n-    @Test(expectedExceptions=IllegalStateException.class)\n-    public void testBadCloseWithPendingAcquire() {\n-        withAcquired(MemorySegment::close);\n+    @Test(expectedExceptions=IllegalArgumentException.class)\n+    public void testBadHandoffSameThread() {\n+        MemorySegment.ofArray(new int[4]).withOwnerThread(Thread.currentThread());\n@@ -153,6 +153,4 @@\n-    @Test(expectedExceptions=IllegalStateException.class)\n-    public void testBadCloseWithPendingAcquireBuffer() {\n-        withAcquired(segment -> {\n-            segment = MemorySegment.ofByteBuffer(segment.asByteBuffer()); \/\/ original segment is lost\n-            segment.close(); \/\/ this should still fail\n-        });\n+    @Test(expectedExceptions=UnsupportedOperationException.class)\n+    public void testBadHandoffNoAccess() {\n+        MemorySegment.ofArray(new int[4])\n+            .withAccessModes(MemorySegment.CLOSE).withOwnerThread(new Thread());\n@@ -162,15 +160,4 @@\n-    public void testBadHandoffWithPendingAcquire() {\n-        withAcquired(segment -> segment.withOwnerThread(new Thread()));\n-    }\n-\n-    @Test(expectedExceptions=IllegalStateException.class)\n-    public void testBadHandoffWithPendingAcquireBuffer() {\n-        withAcquired(segment -> {\n-            segment = MemorySegment.ofByteBuffer(segment.asByteBuffer()); \/\/ original segment is lost\n-            segment.withOwnerThread(new Thread()); \/\/ this should still fail\n-        });\n-    }\n-\n-    @Test(expectedExceptions=IllegalArgumentException.class)\n-    public void testBadHandoffSameThread() {\n-        MemorySegment.ofArray(new int[4]).withOwnerThread(Thread.currentThread());\n+    public void testBadShareAlreadyShared() {\n+        MemorySegment.ofArray(new int[4])\n+                .withOwnerThread(null)\n+                .withOwnerThread(null);\n@@ -179,3 +166,4 @@\n-    @Test(expectedExceptions=NullPointerException.class)\n-    public void testBadHandoffNullThread() {\n-        MemorySegment.ofArray(new int[4]).withOwnerThread(null);\n+    @Test(expectedExceptions=UnsupportedOperationException.class)\n+    public void testBadShareNoAccess() {\n+        MemorySegment.ofArray(new int[4])\n+                .withAccessModes(MemorySegment.CLOSE).withOwnerThread(null);\n@@ -186,1 +174,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(16);\n+        MemorySegment segment = MemorySegment.allocateNative(16).withOwnerThread(null);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":17,"deletions":29,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -64,1 +63,1 @@\n-        MemorySegment segment = MemorySegment.allocateNative(layout);\n+        MemorySegment segment = MemorySegment.allocateNative(layout).withOwnerThread(null);\n@@ -218,2 +217,2 @@\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE), layout), READ|WRITE|ACQUIRE,\n-            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE|ACQUIRE|HANDOFF), layout), READ|WRITE|ACQUIRE|HANDOFF\n+            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE| SHARE), layout), READ|WRITE| SHARE,\n+            () -> spliterator(mallocSegment.withAccessModes(READ|WRITE| SHARE |HANDOFF), layout), READ|WRITE| SHARE |HANDOFF\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -81,0 +81,9 @@\n+    @Benchmark\n+    public void segment_loop_shared() {\n+        MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE).withOwnerThread(null);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+        segment.close();\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(3)\n+public class LoopOverNonConstantShared {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+    static final int ALLOC_SIZE = ELEM_SIZE * CARRIER_SIZE;\n+\n+    static final VarHandle VH_int = MemoryLayout.ofSequence(JAVA_INT).varHandle(int.class, sequenceElement());\n+    MemorySegment segment;\n+    long unsafe_addr;\n+\n+    ByteBuffer byteBuffer;\n+\n+    @Setup\n+    public void setup() {\n+        unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(unsafe_addr + (i * CARRIER_SIZE) , i);\n+        }\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE)\n+                .withOwnerThread(null);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+        byteBuffer = ByteBuffer.allocateDirect(ALLOC_SIZE).order(ByteOrder.nativeOrder());\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            byteBuffer.putInt(i * CARRIER_SIZE , i);\n+        }\n+    }\n+\n+    @TearDown\n+    public void tearDown() {\n+        segment.close();\n+        unsafe.invokeCleaner(byteBuffer);\n+        unsafe.freeMemory(unsafe_addr);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int unsafe_get() {\n+        return unsafe.getInt(unsafe_addr);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int segment_get() {\n+        return (int) VH_int.get(segment, 0L);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int BB_get() {\n+        return byteBuffer.getInt(0);\n+    }\n+\n+    @Benchmark\n+    public int unsafe_loop() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += unsafe.getInt(unsafe_addr + (i * CARRIER_SIZE));\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_static() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += MemoryAccess.getIntAtIndex(segment, i);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int.get(segment, (long) i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_slice() {\n+        int sum = 0;\n+        MemorySegment base = segment.asSlice(0, segment.byteSize());\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int.get(base, (long) i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_readonly() {\n+        int sum = 0;\n+        MemorySegment base = segment.withAccessModes(MemorySegment.READ);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int.get(base, (long) i);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int BB_loop() {\n+        int sum = 0;\n+        ByteBuffer bb = byteBuffer;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += bb.getInt(i * CARRIER_SIZE);\n+        }\n+        return sum;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -88,1 +88,2 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE);\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE)\n+                .withOwnerThread(null);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}