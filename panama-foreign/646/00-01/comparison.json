{"files":[{"patch":"@@ -221,0 +221,8 @@\n+\n+        \/**\n+         * Returns a Function type that has the given parameter names.\n+         *\n+         * @param paramNames parameter names for this function type.\n+         * @return new Function type with the given parameter names.\n+         *\/\n+        Function withParameterNames(List<String> paramNames);\n@@ -473,13 +481,1 @@\n-        return new TypeImpl.FunctionImpl(varargs, Stream.of(arguments).collect(Collectors.toList()), returnType, Optional.empty());\n-    }\n-\n-    \/**\n-     * Creates a new function type with given parameter types and return type.\n-     * @param varargs is this function type variable-arity?\n-     * @param returnType the function type return type.\n-     * @param arguments the function type formal parameter types.\n-     * @param paramNames the function type formal parameter names. It can be null.\n-     * @return a new function type with given parameter types and return type.\n-     *\/\n-    static Type.Function function(boolean varargs, Type returnType, List<Type> arguments, List<String> paramNames) {\n-        return new TypeImpl.FunctionImpl(varargs, arguments, returnType, Optional.ofNullable(paramNames));\n+        return new TypeImpl.FunctionImpl(varargs, Stream.of(arguments).collect(Collectors.toList()), returnType, null);\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/incubator\/jextract\/Type.java","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -251,6 +251,1 @@\n-        List<Declaration.Variable> params = c.children().\n-             filter(ch -> ch.kind() == CursorKind.ParmDecl).\n-             map(this::createTree).\n-             map(Declaration.Variable.class::cast).\n-             collect(Collectors.toList());\n-        Type cursorType = toType(c, params);\n+        Type cursorType = toType(c);\n@@ -265,0 +260,31 @@\n+        Type.Function funcType = null;\n+        boolean isFuncPtrType = false;\n+        if (canonicalType instanceof Type.Function) {\n+            funcType = (Type.Function)canonicalType;\n+        } else if (canonicalType instanceof Type.Delegated &&\n+                ((Type.Delegated)canonicalType).kind() == Type.Delegated.Kind.POINTER) {\n+            Type pointeeType = null;\n+            try {\n+                pointeeType = ((Type.Delegated)canonicalType).type();\n+            } catch (NullPointerException npe) {\n+                \/\/ exception thrown for unresolved pointee type. Ignore if we hit that case.\n+            }\n+            if (pointeeType instanceof Type.Function) {\n+                funcType = (Type.Function)pointeeType;\n+                isFuncPtrType = true;\n+            }\n+        }\n+        if (funcType != null) {\n+            List<String> params = c.children().\n+                filter(ch -> ch.kind() == CursorKind.ParmDecl).\n+                map(this::createTree).\n+                map(Declaration.Variable.class::cast).\n+                map(Declaration::name).\n+                collect(Collectors.toList());\n+            if (!params.isEmpty()) {\n+                canonicalType = funcType.withParameterNames(params);\n+                if (isFuncPtrType) {\n+                    canonicalType = new TypeImpl.PointerImpl(canonicalType);\n+                }\n+            }\n+        }\n@@ -295,4 +321,0 @@\n-    private Type toType(Cursor c, List<Declaration.Variable> params) {\n-        return typeMaker.makeType(c.type(), params == null || params.isEmpty()? null : params);\n-    }\n-\n@@ -300,1 +322,1 @@\n-        return toType(c, null);\n+        return typeMaker.makeType(c.type());\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TreeMaker.java","additions":33,"deletions":11,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -246,2 +246,1 @@\n-        public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype,\n-                Optional<List<String>> paramNames) {\n+        public FunctionImpl(boolean varargs, List<Type> argtypes, Type restype, List<String> paramNames) {\n@@ -252,1 +251,1 @@\n-            this.paramNames = Objects.requireNonNull(paramNames);\n+            this.paramNames = Optional.ofNullable(paramNames);\n@@ -256,1 +255,1 @@\n-            this(varargs, argtypes, restype, Optional.empty());\n+            this(varargs, argtypes, restype, null);\n@@ -279,0 +278,6 @@\n+        @Override\n+        public Type.Function withParameterNames(List<String> paramNames) {\n+            Objects.requireNonNull(paramNames);\n+            return new FunctionImpl(varargs, argtypes, restype, paramNames);\n+        }\n+\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeImpl.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -104,4 +104,0 @@\n-        return makeType(t, null);\n-    }\n-\n-    Type makeType(jdk.internal.clang.Type t, List<Declaration.Variable> params) {\n@@ -112,1 +108,1 @@\n-        rv = makeTypeInternal(t, params);\n+        rv = makeTypeInternal(t);\n@@ -127,1 +123,1 @@\n-    Type makeTypeInternal(jdk.internal.clang.Type t, List<Declaration.Variable> params) {\n+    Type makeTypeInternal(jdk.internal.clang.Type t) {\n@@ -197,5 +193,1 @@\n-                List<String> paramNames = null;\n-                if (params != null) {\n-                    paramNames = params.stream().map(Declaration::name).collect(Collectors.toList());\n-                }\n-                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args, paramNames);\n+                return Type.function(t.isVariadic(), lowerFunctionType(t.resultType()), args.toArray(new Type[0]));\n@@ -211,1 +203,1 @@\n-                    return new TypeImpl.PointerImpl(makeType(t.getPointeeType(), params));\n+                    return new TypeImpl.PointerImpl(makeType(t.getPointeeType()));\n@@ -217,1 +209,1 @@\n-                Type __type = makeType(t.canonicalType(), params);\n+                Type __type = makeType(t.canonicalType());\n","filename":"src\/jdk.incubator.jextract\/share\/classes\/jdk\/internal\/jextract\/impl\/TypeMaker.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"}]}