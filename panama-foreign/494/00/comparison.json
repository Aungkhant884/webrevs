{"files":[{"patch":"@@ -45,0 +45,1 @@\n+import java.util.stream.Stream;\n@@ -124,1 +125,1 @@\n- * <h2>Spliterator support<\/h2>\n+ * <h2>Stream support<\/h2>\n@@ -126,3 +127,4 @@\n- * A client might obtain a {@link Spliterator} from a segment, which can then be used to slice the segment and allow multiple\n- * threads to work in parallel on disjoint segment slices (to do this, the segment has to be associated with a shared scope).\n- * The following code can be used to sum all int values in a memory segment in parallel:\n+ * A client might obtain a {@link Stream} from a segment, which can then be used to slice the segment (according to a given\n+ * element layout) and even allow multiple threads to work in parallel on disjoint segment slices\n+ * (to do this, the segment has to be associated with a shared scope). The following code can be used to sum all int\n+ * values in a memory segment in parallel:\n@@ -135,1 +137,1 @@\n-    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n+    int sum = segment.parallelStream(MemoryLayouts.JAVA_INT)\n@@ -164,5 +166,5 @@\n-     * The returned spliterator splits this segment according to the specified sequence layout; that is,\n-     * if the supplied layout is a sequence layout whose element count is {@code N}, then calling {@link Spliterator#trySplit()}\n-     * will result in a spliterator serving approximatively {@code N\/2} elements (depending on whether N is even or not).\n-     * As such, splitting is possible as long as {@code N >= 2}. The spliterator returns segments that feature the same\n-     * scope as the given segment.\n+     * The returned spliterator splits this segment according to the specified element layout; that is,\n+     * if the supplied layout has size N, then calling {@link Spliterator#trySplit()} will result in a spliterator serving\n+     * approximately {@code S\/N\/2} elements (depending on whether N is even or not), where {@code S} is the size of\n+     * this segment. As such, splitting is possible as long as {@code S\/N >= 2}. The spliterator returns segments that feature the same\n+     * scope as this given segment.\n@@ -173,1 +175,1 @@\n-     * @param layout the layout to be used for splitting.\n+     * @param elementLayout the layout to be used for splitting.\n@@ -175,2 +177,1 @@\n-     * @throws IllegalStateException if the segment is not <em>alive<\/em>, or if access occurs from a thread other than the\n-     * thread owning this segment\n+     * @throws IllegalArgumentException if this segment size is not a multiple of the size of {@code elementLayout}.\n@@ -178,1 +179,27 @@\n-    Spliterator<MemorySegment> spliterator(SequenceLayout layout);\n+    Spliterator<MemorySegment> spliterator(MemoryLayout elementLayout);\n+\n+    \/**\n+     * Returns a sequential {@code Stream} over disjoint slices (whose size matches that of the specified layout)\n+     * in this segment. Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    StreamSupport.stream(segment.spliterator(), false);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param elementLayout the layout to be used for splitting.\n+     * @return a sequential {@code Stream} over disjoint slices in this segment.\n+     * @throws IllegalArgumentException if this segment size is not a multiple of the size of {@code elementLayout}.\n+     *\/\n+    Stream<MemorySegment> stream(MemoryLayout elementLayout);\n+\n+    \/**\n+     * Returns a parallel {@code Stream} over disjoint slices (whose size matches that of the specified layout)\n+     * in this segment. Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    StreamSupport.stream(segment.spliterator(), true);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param elementLayout the layout to be used for splitting.\n+     * @return a parallel {@code Stream} over disjoint slices in this segment.\n+     * @throws IllegalArgumentException if this segment size is not a multiple of the size of {@code elementLayout}.\n+     *\/\n+    Stream<MemorySegment> parallelStream(MemoryLayout elementLayout);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":41,"deletions":14,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -117,5 +119,4 @@\n-    public Spliterator<MemorySegment> spliterator(SequenceLayout sequenceLayout) {\n-        Objects.requireNonNull(sequenceLayout);\n-        checkValidState();\n-        if (sequenceLayout.byteSize() != byteSize()) {\n-            throw new IllegalArgumentException();\n+    public Spliterator<MemorySegment> spliterator(MemoryLayout elementLayout) {\n+        Objects.requireNonNull(elementLayout);\n+        if (byteSize() % elementLayout.byteSize() != 0) {\n+            throw new IllegalArgumentException(\"Segment size is no a multiple of layout size\");\n@@ -123,1 +124,1 @@\n-        return new SegmentSplitter(sequenceLayout.elementLayout().byteSize(), sequenceLayout.elementCount().getAsLong(),\n+        return new SegmentSplitter(elementLayout.byteSize(), byteSize() \/ elementLayout.byteSize(),\n@@ -127,0 +128,10 @@\n+    @Override\n+    public Stream<MemorySegment> stream(MemoryLayout elementLayout) {\n+        return StreamSupport.stream(spliterator(elementLayout), false);\n+    }\n+\n+    @Override\n+    public Stream<MemorySegment> parallelStream(MemoryLayout elementLayout) {\n+        return StreamSupport.stream(spliterator(elementLayout), true);\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-            spliterators.add(s.spliterator(layout));\n+            spliterators.add(s.spliterator(layout.elementLayout()));\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-            long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout), threshold).invoke();\n+            long parallelCounted = new SumSegmentCounted(null, segment.spliterator(layout.elementLayout()), threshold).invoke();\n@@ -74,1 +74,1 @@\n-            long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout), threshold).invoke();\n+            long parallelRecursive = new SumSegmentRecursive(segment.spliterator(layout.elementLayout()), threshold).invoke();\n@@ -77,1 +77,1 @@\n-            long streamParallel = StreamSupport.stream(segment.spliterator(layout), true)\n+            long streamParallel = segment.parallelStream(layout.elementLayout())\n@@ -96,1 +96,1 @@\n-        segment.spliterator(layout)\n+        segment.spliterator(layout.elementLayout())\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    final static SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(ELEM_SIZE, MemoryLayouts.JAVA_INT);\n+    final static MemoryLayout ELEM_LAYOUT = MemoryLayouts.JAVA_INT;\n@@ -73,1 +73,1 @@\n-    final static SequenceLayout SEQUENCE_LAYOUT_BULK = SEQUENCE_LAYOUT.reshape(-1, BULK_FACTOR);\n+    final static SequenceLayout ELEM_LAYOUT_BULK = MemoryLayout.sequenceLayout(BULK_FACTOR, ELEM_LAYOUT);\n@@ -118,1 +118,1 @@\n-        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT), SEGMENT_TO_INT).invoke();\n+        return new SumSegment(segment.spliterator(ELEM_LAYOUT), SEGMENT_TO_INT).invoke();\n@@ -123,1 +123,1 @@\n-        return new SumSegment(segment.spliterator(SEQUENCE_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();\n+        return new SumSegment(segment.spliterator(ELEM_LAYOUT_BULK), SEGMENT_TO_INT_BULK).invoke();\n@@ -128,2 +128,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n-                .mapToInt(SEGMENT_TO_INT).sum();\n+        return segment.parallelStream(ELEM_LAYOUT).mapToInt(SEGMENT_TO_INT).sum();\n@@ -134,2 +133,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)\n-                .mapToInt(SEGMENT_TO_INT_BULK).sum();\n+        return segment.parallelStream(ELEM_LAYOUT_BULK).mapToInt(SEGMENT_TO_INT_BULK).sum();\n@@ -151,1 +149,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), false)\n+        return segment.stream(ELEM_LAYOUT)\n@@ -158,1 +156,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n+        return segment.parallelStream(ELEM_LAYOUT)\n@@ -165,1 +163,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), false)\n+        return segment.stream(ELEM_LAYOUT_BULK)\n@@ -172,1 +170,1 @@\n-        return StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT_BULK), true)\n+        return segment.parallelStream(ELEM_LAYOUT_BULK)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"}]}