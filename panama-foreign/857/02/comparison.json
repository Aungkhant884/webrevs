{"files":[{"patch":"@@ -28,0 +28,4 @@\n+import jdk.internal.util.ArraysSupport;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n@@ -29,0 +33,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -31,0 +36,1 @@\n+import java.util.Objects;\n@@ -32,0 +38,1 @@\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n@@ -33,1 +40,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -35,0 +41,1 @@\n+import static java.lang.foreign.ValueLayout.JAVA_SHORT;\n@@ -40,0 +47,18 @@\n+\n+    \/\/ Maximum segment byte size for which a trivial method will be invoked.\n+    private static final long MAX_TRIVIAL_SIZE = 1024L;\n+    private static final MethodHandle STRNLEN_TRIVIAL;\n+    private static final MethodHandle STRNLEN;\n+    private static final boolean SIZE_T_IS_INT;\n+\n+    static {\n+        var size_t = Objects.requireNonNull(Linker.nativeLinker().canonicalLayouts().get(\"size_t\"));\n+        Linker linker = Linker.nativeLinker();\n+        var strnlen = linker.defaultLookup().find(\"strnlen\").orElseThrow();\n+        var description = FunctionDescriptor.of(size_t, ADDRESS, size_t);\n+\n+        STRNLEN_TRIVIAL = linker.downcallHandle(strnlen, description, Linker.Option.isTrivial());\n+        STRNLEN = linker.downcallHandle(strnlen, description);\n+        SIZE_T_IS_INT = (size_t.byteSize() == Integer.BYTES);\n+    }\n+\n@@ -58,1 +83,1 @@\n-        long len = strlen_byte(segment, offset);\n+        long len = native_strlen_byte(segment, offset);\n@@ -96,1 +121,69 @@\n-    private static int strlen_byte(MemorySegment segment, long start) {\n+    private static int native_strlen_byte(MemorySegment segment, long start) {\n+        if (start > 0) {\n+            segment = segment.asSlice(start);\n+        }\n+        long segmentSize = segment.byteSize();\n+        final long len;\n+        if (SIZE_T_IS_INT) {\n+            if (segmentSize < MAX_TRIVIAL_SIZE) {\n+                len = strnlen_int_trivial(segment, segmentSize);\n+            } else if (segmentSize < Integer.MAX_VALUE * 2L) { \/\/ size_t is unsigned\n+                len = strnlen_int(segment, segmentSize);\n+            } else {\n+                \/\/ There is no way to express the max size in the native method using an int so, revert\n+                \/\/ to a Java method. It is possible to use a reduction of several STRNLEN invocations\n+                \/\/ in a future optimization.\n+                len = strlen_byte(segment);\n+            }\n+        } else {\n+            len = segmentSize < MAX_TRIVIAL_SIZE\n+                    ? strnlen_long_trivial(segment, segmentSize)\n+                    : strnlen_long(segment, segmentSize);\n+        }\n+        if (len > ArraysSupport.SOFT_MAX_ARRAY_LENGTH) {\n+            throw newIaeStringTooLarge();\n+        }\n+        return (int)len;\n+    }\n+\n+    static long strnlen_int_trivial(MemorySegment segment, long size) {\n+        try {\n+            return Integer.toUnsignedLong((int)STRNLEN_TRIVIAL.invokeExact(segment, (int)size));\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    static long strnlen_int(MemorySegment segment, long size) {\n+        try {\n+            return Integer.toUnsignedLong((int)STRNLEN.invokeExact(segment, (int)size));\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    static long strnlen_long_trivial(MemorySegment segment, long size) {\n+        try {\n+            return (long)STRNLEN_TRIVIAL.invokeExact(segment, size);\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    static long strnlen_long(MemorySegment segment, long size) {\n+        try {\n+            return (long)STRNLEN.invokeExact(segment, size);\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw new IllegalArgumentException(e);\n+        }\n+    }\n+\n+    private static int strlen_byte(MemorySegment segment) {\n@@ -98,2 +191,2 @@\n-        for (int offset = 0; offset >= 0; offset++) {\n-            byte curr = segment.get(JAVA_BYTE, start + offset);\n+        for (int offset = 0; offset >= 0; offset += 2) {\n+            short curr = segment.get(JAVA_SHORT, offset);\n@@ -104,1 +197,1 @@\n-        throw new IllegalArgumentException(\"String too large\");\n+        throw newIaeStringTooLarge();\n@@ -115,1 +208,1 @@\n-        throw new IllegalArgumentException(\"String too large\");\n+        throw newIaeStringTooLarge();\n@@ -126,1 +219,1 @@\n-        throw new IllegalArgumentException(\"String too large\");\n+        throw newIaeStringTooLarge();\n@@ -156,0 +249,5 @@\n+\n+    private static IllegalArgumentException newIaeStringTooLarge() {\n+        return new IllegalArgumentException(\"String too large\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/StringSupport.java","additions":106,"deletions":8,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n@@ -26,0 +28,3 @@\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+import java.lang.foreign.MemoryLayout;\n@@ -27,0 +32,2 @@\n+import java.lang.foreign.ValueLayout;\n+import java.lang.invoke.MethodHandle;\n@@ -28,0 +35,1 @@\n+import java.nio.channels.FileChannel;\n@@ -30,0 +38,8 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.function.Consumer;\n+import java.util.function.UnaryOperator;\n@@ -32,0 +48,3 @@\n+\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n@@ -42,1 +61,1 @@\n-    public void testStrings(String testString) throws ReflectiveOperationException {\n+    public void testStrings(String testString) {\n@@ -73,0 +92,177 @@\n+    @Test(dataProvider = \"strings\")\n+    public void unboundedSegment(String testString) {\n+        testModifyingSegment(testString,\n+                standardCharsets(),\n+                s -> s.reinterpret(Long.MAX_VALUE),\n+                UnaryOperator.identity());\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void unalignedSegmentSingleByte(String testString) {\n+        testModifyingSegment(testString,\n+                singleByteCharsets(),\n+                s -> s.byteSize() > 1 ? s.asSlice(1) : s,\n+                s -> s.length() > 0 ? s.substring(1) : s);\n+    }\n+\n+    @Test(dataProvider = \"strings\")\n+    public void expandedSegment(String testString) {\n+        try (var arena = Arena.ofConfined()) {\n+            for (int i = 0; i < Long.BYTES; i++) {\n+                int extra = i;\n+                testModifyingSegment(testString,\n+                        \/\/ Single byte charsets\n+                        standardCharsets(),\n+                        s -> {\n+                            var s2 = arena.allocate(s.byteSize() + extra);\n+                            MemorySegment.copy(s, 0, s2, 0, s.byteSize());\n+                            return s2;\n+                        },\n+                        UnaryOperator.identity());\n+            }\n+        }\n+    }\n+\n+    public void testModifyingSegment(String testString,\n+                                     List<Charset> charsets,\n+                                     UnaryOperator<MemorySegment> segmentMapper,\n+                                     UnaryOperator<String> stringMapper) {\n+        for (var charset : charsets) {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment text = arena.allocateFrom(testString, charset);\n+                text = segmentMapper.apply(text);\n+                String roundTrip = text.getString(0, charset);\n+                String expected = stringMapper.apply(testString);\n+                if (charset.newEncoder().canEncode(testString)) {\n+                    assertEquals(roundTrip, expected);\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test()\n+    public void testPeculiarContentSingleByte() {\n+        Random random = new Random(42);\n+        for (int len = 7; len < 71; len++) {\n+            try (var arena = Arena.ofConfined()) {\n+                var segment = arena.allocate(len, 4);\n+                var arr = new byte[len];\n+                random.nextBytes(arr);\n+                segment.copyFrom(MemorySegment.ofArray(arr));\n+                int terminatorIndex = random.nextInt(len);\n+                segment.set(ValueLayout.JAVA_BYTE, terminatorIndex, (byte) 0);\n+                for (Charset charset : singleByteCharsets()) {\n+                    var s = segment.getString(0, charset);\n+                    var ref = referenceImpl(segment, 0, charset);\n+                    assertEquals(s, ref);\n+                }\n+            }\n+        }\n+    }\n+\n+\n+    @Test(dataProvider = \"strings\")\n+    public void testOffset(String testString) {\n+        if (testString.length() < 3 || !containsOnlyRegularCharacters(testString)) {\n+            return;\n+        }\n+        for(var charset:singleByteCharsets()) {\n+            try (Arena arena = Arena.ofConfined()) {\n+                MemorySegment inSegment = arena.allocateFrom(testString, charset);\n+                for (int i = 0; i < 3; i++) {\n+                    String actual = inSegment.getString(i, charset);\n+                    assertEquals(actual, testString.substring(i));\n+                }\n+            }\n+        }\n+    }\n+\n+    @Test()\n+    public void testJumboSegment() {\n+        testWithJumboSegment(\"testJumboSegment\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            String big = segment.getString(100);\n+        });\n+    }\n+\n+    @Test()\n+    public void testStringLargerThanMaxInt() {\n+        testWithJumboSegment(\"testStringLargerThanMaxInt\", segment -> {\n+            segment.fill((byte) 1);\n+            segment.set(JAVA_BYTE, Integer.MAX_VALUE + 10L, (byte) 0);\n+            assertThrows(IllegalArgumentException.class, () -> {\n+                segment.getString(0);\n+            });\n+        });\n+    }\n+\n+    private static void testWithJumboSegment(String testName, Consumer<MemorySegment> tester) {\n+        Path path = Paths.get(\"mapped_file\");\n+        try {\n+            \/\/ Relly try to make sure the file is deleted after use\n+            path.toFile().deleteOnExit();\n+            deleteIfExistsOrThrow(path);\n+            try (RandomAccessFile raf = new RandomAccessFile(path.toFile(), \"rw\")) {\n+                FileChannel fc = raf.getChannel();\n+                try (Arena arena = Arena.ofConfined()) {\n+                    var segment = fc.map(FileChannel.MapMode.READ_WRITE, 0L, (long) Integer.MAX_VALUE + 100, arena);\n+                    tester.accept(segment);\n+                }\n+            }\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n+        } catch (OutOfMemoryError oome) {\n+           \/\/ Unfortunately, we run out of memory and cannot run this test in this configuration\n+            System.out.println(\"Skipping test because of insufficient memory: \" + testName);\n+        } finally {\n+            deleteIfExistsOrThrow(path);\n+        }\n+    }\n+\n+    private static void deleteIfExistsOrThrow(Path file) {\n+        try {\n+            Files.deleteIfExists(file);\n+        } catch (IOException ioe) {\n+            throw new AssertionError(\"Unable to delete mapped file: \" + file);\n+        }\n+    }\n+\n+    private static final MemoryLayout CHAR_POINTER = ADDRESS\n+            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));\n+    private static final Linker LINKER = Linker.nativeLinker();\n+    private static final MethodHandle STRCAT = LINKER.downcallHandle(\n+            LINKER.defaultLookup().find(\"strcat\").orElseThrow(),\n+            FunctionDescriptor.of(CHAR_POINTER, CHAR_POINTER, CHAR_POINTER));\n+\n+    @Test(dataProvider = \"strings\")\n+    public void nativeSegFromNativeCall(String testString) {\n+        String addition = \"123\";\n+        try (var arena = Arena.ofConfined()) {\n+            try {\n+                MemorySegment concatenation = (MemorySegment) STRCAT.invokeExact(arena.allocateFrom(testString), arena.allocateFrom(addition));\n+                var actual = concatenation.getString(0);\n+                assertEquals(actual, testString + addition);\n+            } catch (Throwable t) {\n+                throw new AssertionError(t);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void segmentationFault() {\n+        for (int i = 1; i < 18; i++) {\n+            var size = 1 << i;\n+            try (var arena = Arena.ofConfined()) {\n+                var seg = arena.allocate(size, size);\n+                seg.fill((byte)1);\n+                try {\n+                    var s = seg.getString(0);\n+                    System.out.println(\"s.length() = \" + s.length());\n+                } catch (IndexOutOfBoundsException e) {\n+                    \/\/ we will end up here if strlen finds a zero outside the MS\n+                }\n+            }\n+        }\n+    }\n+\n@@ -75,8 +271,18 @@\n-        return new Object[][] {\n-            { \"testing\" },\n-            { \"\" },\n-            { \"X\" },\n-            { \"12345\" },\n-            { \"yen \\u00A5\" },\n-            { \"snowman \\u26C4\" },\n-            { \"rainbow \\uD83C\\uDF08\" }\n+        return new Object[][]{\n+                {\"testing\"},\n+                {\"\"},\n+                {\"X\"},\n+                {\"12345\"},\n+                {\"yen \\u00A5\"},\n+                {\"snowman \\u26C4\"},\n+                {\"rainbow \\uD83C\\uDF08\"},\n+                {\"0\"},\n+                {\"01\"},\n+                {\"012\"},\n+                {\"0123\"},\n+                {\"01234\"},\n+                {\"012345\"},\n+                {\"0123456\"},\n+                {\"01234567\"},\n+                {\"012345678\"},\n+                {\"0123456789\"}\n@@ -86,1 +292,6 @@\n-    boolean isStandard(Charset charset) throws ReflectiveOperationException {\n+    public static boolean containsOnlyRegularCharacters(String s) {\n+        return s.chars()\n+                .allMatch(c -> Character.isLetterOrDigit((char) c));\n+    }\n+\n+    boolean isStandard(Charset charset) {\n@@ -88,2 +299,6 @@\n-            if (standardCharset.get(null) == charset) {\n-                return true;\n+            try {\n+                if (standardCharset.get(null) == charset) {\n+                    return true;\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                throw new AssertionError(e);\n@@ -94,0 +309,32 @@\n+\n+    List<Charset> standardCharsets() {\n+        return Charset.availableCharsets().values().stream()\n+                .filter(this::isStandard)\n+                .toList();\n+    }\n+\n+    List<Charset> singleByteCharsets() {\n+        return Arrays.asList(StandardCharsets.UTF_8, StandardCharsets.ISO_8859_1, StandardCharsets.US_ASCII);\n+    }\n+\n+\n+    static String referenceImpl(MemorySegment segment, long offset, Charset charset) {\n+        long len = strlen_byte(segment, offset);\n+        byte[] bytes = new byte[(int) len];\n+        MemorySegment.copy(segment, JAVA_BYTE, offset, bytes, 0, (int) len);\n+        return new String(bytes, charset);\n+    }\n+\n+\n+    \/\/ Reference implementation\n+    private static int strlen_byte(MemorySegment segment, long start) {\n+        \/\/ iterate until overflow (String can only hold a byte[], whose length can be expressed as an int)\n+        for (int offset = 0; offset >= 0; offset++) {\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n+            if (curr == 0) {\n+                return offset;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"String too large\");\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":259,"deletions":12,"binary":false,"changes":271,"status":"modified"}]}