{"files":[{"patch":"@@ -73,70 +73,50 @@\n-        \/\/ TODO: Replace with \"patterns in switch statement\" once this becomes available.\n-\n-        if (layout instanceof ValueLayout.OfBoolean ofBoolean) {\n-            action.accept(renderValueLayout(state, ofBoolean, renderer.apply(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfByte ofByte) {\n-            action.accept(renderValueLayout(state, ofByte, renderer.apply(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfShort ofShort) {\n-            action.accept(renderValueLayout(state, ofShort, renderer.apply(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfInt ofInt) {\n-            action.accept(renderValueLayout(state, ofInt, renderer.apply(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfLong ofLong) {\n-            action.accept(renderValueLayout(state, ofLong, renderer.apply(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfFloat ofFloat) {\n-            action.accept(renderValueLayout(state, ofFloat, renderer.apply(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfDouble ofDouble) {\n-            action.accept(renderValueLayout(state, ofDouble, renderer.apply(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n-            return;\n-        }\n-        if (layout instanceof ValueLayout.OfChar ofChar) {\n-            action.accept(renderValueLayout(state, ofChar, renderer.apply(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n-            return;\n-        }\n-        if (layout instanceof AddressLayout ofAddress) {\n-            action.accept(renderValueLayout(state, ofAddress, renderer.apply(ofAddress, segment.get(ofAddress, state.indexAndAdd(ofAddress))), suffix));\n-            return;\n-        }\n-        if (layout instanceof PaddingLayout paddingLayout) {\n-            action.accept(state.indentSpaces() + paddingLayout.byteSize() + \" padding bytes\");\n-            state.indexAndAdd(paddingLayout);\n-            return;\n-        }\n-        if (layout instanceof GroupLayout groupLayout) {\n-\n-            \/* Strictly, we should provide all permutations of unions.\n-             * So, if we have a union U =  (A|B),(C|D) then we should present:\n-             * (A,C), (A,D), (B,C) and (B,D)\n-             *\/\n-\n-            final var separator = groupLayout instanceof StructLayout\n-                    ? \",\"  \/\/ Struct separator\n-                    : \"|\"; \/\/ Union separator\n-\n-            action.accept(indentedLabel(state, groupLayout) + \" {\");\n-            state.incrementIndent();\n-            final var members = groupLayout.memberLayouts();\n-            final long initialIndex = state.index();\n-            long maxIndex = initialIndex;\n-            for (int i = 0; i < members.size(); i++) {\n-                if (groupLayout instanceof UnionLayout) {\n-                    \/\/ If it is a union, we need to reset the index for each member\n-                    state.index(initialIndex);\n-                    \/\/ We record the max index used for any union member so we can leave off from there\n-                    maxIndex = Math.max(maxIndex, state.index());\n-                }\n-                toString0(segment, members.get(i), renderer, action, state, (i != (members.size() - 1)) ? separator : \"\");\n-                if (groupLayout instanceof UnionLayout) {\n-                    \/\/ This is the best we can do.\n-                    state.index(maxIndex);\n+        switch (layout) {\n+            case ValueLayout.OfBoolean ofBoolean ->\n+                    action.accept(renderValueLayout(state, ofBoolean, renderer.apply(ofBoolean, segment.get(ofBoolean, state.indexAndAdd(ofBoolean))), suffix));\n+            case ValueLayout.OfByte ofByte ->\n+                    action.accept(renderValueLayout(state, ofByte, renderer.apply(ofByte, segment.get(ofByte, state.indexAndAdd(ofByte))), suffix));\n+            case ValueLayout.OfShort ofShort ->\n+                    action.accept(renderValueLayout(state, ofShort, renderer.apply(ofShort, segment.get(ofShort, state.indexAndAdd(ofShort))), suffix));\n+            case ValueLayout.OfChar ofChar ->\n+                    action.accept(renderValueLayout(state, ofChar, renderer.apply(ofChar, segment.get(ofChar, state.indexAndAdd(ofChar))), suffix));\n+            case ValueLayout.OfInt ofInt ->\n+                    action.accept(renderValueLayout(state, ofInt, renderer.apply(ofInt, segment.get(ofInt, state.indexAndAdd(ofInt))), suffix));\n+            case ValueLayout.OfLong ofLong ->\n+                    action.accept(renderValueLayout(state, ofLong, renderer.apply(ofLong, segment.get(ofLong, state.indexAndAdd(ofLong))), suffix));\n+            case ValueLayout.OfFloat ofFloat ->\n+                    action.accept(renderValueLayout(state, ofFloat, renderer.apply(ofFloat, segment.get(ofFloat, state.indexAndAdd(ofFloat))), suffix));\n+            case ValueLayout.OfDouble ofDouble ->\n+                    action.accept(renderValueLayout(state, ofDouble, renderer.apply(ofDouble, segment.get(ofDouble, state.indexAndAdd(ofDouble))), suffix));\n+            case AddressLayout addressLayout ->\n+                    action.accept(renderValueLayout(state, addressLayout, renderer.apply(addressLayout, segment.get(addressLayout, state.indexAndAdd(addressLayout))), suffix));\n+            case PaddingLayout paddingLayout -> {\n+                action.accept(state.indentSpaces() + paddingLayout.byteSize() + \" padding bytes\");\n+                state.indexAndAdd(paddingLayout);\n+            }\n+            case GroupLayout groupLayout -> {\n+                \/* Strictly, we should provide all permutations of unions.\n+                 * So, if we have a union U =  (A|B),(C|D) then we should present:\n+                 * (A,C), (A,D), (B,C) and (B,D)\n+                 *\/\n+\n+                final var separator = groupLayout instanceof StructLayout\n+                        ? \",\"  \/\/ Struct separator\n+                        : \"|\"; \/\/ Union separator\n+\n+                action.accept(indentedLabel(state, groupLayout) + \" {\");\n+                state.incrementIndent();\n+                final var members = groupLayout.memberLayouts();\n+                final long initialIndex = state.index();\n+                long maxIndex = initialIndex;\n+                for (int i = 0; i < members.size(); i++) {\n+                    if (groupLayout instanceof UnionLayout) {\n+                        \/\/ If it is a union, we need to reset the index for each member\n+                        state.index(initialIndex);\n+                        \/\/ We record the max index used for any union member so we can leave off from there\n+                        maxIndex = Math.max(maxIndex, state.index());\n+                    }\n+                    toString0(segment, members.get(i), renderer, action, state, (i != (members.size() - 1)) ? separator : \"\");\n+                    if (groupLayout instanceof UnionLayout) {\n+                        \/\/ This is the best we can do.\n+                        state.index(maxIndex);\n+                    }\n@@ -144,0 +124,2 @@\n+                state.decrementIndent();\n+                action.accept(state.indentSpaces() + \"}\" + suffix);\n@@ -145,10 +127,9 @@\n-            state.decrementIndent();\n-            action.accept(state.indentSpaces() + \"}\" + suffix);\n-            return;\n-        }\n-        if (layout instanceof SequenceLayout sequenceLayout) {\n-            action.accept(indentedLabel(state, sequenceLayout) + \" [\");\n-            state.incrementIndent();\n-            final long elementCount = sequenceLayout.elementCount();\n-            for (long i = 0; i < elementCount; i++) {\n-                toString0(segment, sequenceLayout.elementLayout(), renderer, action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n+            case SequenceLayout sequenceLayout -> {\n+                action.accept(indentedLabel(state, sequenceLayout) + \" [\");\n+                state.incrementIndent();\n+                final long elementCount = sequenceLayout.elementCount();\n+                for (long i = 0; i < elementCount; i++) {\n+                    toString0(segment, sequenceLayout.elementLayout(), renderer, action, state, (i != (elementCount - 1L)) ? \",\" : \"\");\n+                }\n+                state.decrementIndent();\n+                action.accept(state.indentSpaces() + \"]\" + suffix);\n@@ -156,3 +137,0 @@\n-            state.decrementIndent();\n-            action.accept(state.indentSpaces() + \"]\" + suffix);\n-            return;\n@@ -160,2 +138,0 @@\n-        action.accept(state.indentSpaces() + \"Unknown layout: \" + layout + \" at index \" + state.index());\n-        state.indexAndAdd(layout);\n@@ -230,30 +206,14 @@\n-            \/\/ TODO: Replace with \"patterns in switch statement\" once this becomes available.\n-\n-            if (layout instanceof ValueLayout.OfBoolean ofBoolean && o instanceof Boolean b) {\n-                return Boolean.toString(b);\n-            }\n-            if (layout instanceof ValueLayout.OfByte ofByte && o instanceof Byte b) {\n-                return Byte.toString(b);\n-            }\n-            if (layout instanceof ValueLayout.OfShort ofShort && o instanceof Short s) {\n-                return Short.toString(s);\n-            }\n-            if (layout instanceof ValueLayout.OfInt ofInt && o instanceof Integer i) {\n-                return Integer.toString(i);\n-            }\n-            if (layout instanceof ValueLayout.OfLong ofLong && o instanceof Long l) {\n-                return Long.toString(l);\n-            }\n-            if (layout instanceof ValueLayout.OfFloat ofFloat && o instanceof Float f) {\n-                return Float.toString(f);\n-            }\n-            if (layout instanceof ValueLayout.OfDouble ofDouble && o instanceof Double d) {\n-                return Double.toString(d);\n-            }\n-            if (layout instanceof ValueLayout.OfChar ofChar && o instanceof Character c) {\n-                return Character.toString(c);\n-            }\n-            if (layout instanceof AddressLayout ofAddress && o instanceof MemorySegment m) {\n-                return String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", m.address());\n-            }\n-            throw new UnsupportedOperationException(\"layout \" + layout + \" for \" + o.getClass().getName() + \" not supported\");\n+            return switch (layout) {\n+                case ValueLayout.OfBoolean __ when o instanceof Boolean b -> Boolean.toString(b);\n+                case ValueLayout.OfByte __ when o instanceof Byte b -> Byte.toString(b);\n+                case ValueLayout.OfShort __ when o instanceof Short s -> Short.toString(s);\n+                case ValueLayout.OfChar __ when o instanceof Character c -> Character.toString(c);\n+                case ValueLayout.OfInt __ when o instanceof Integer i -> Integer.toString(i);\n+                case ValueLayout.OfLong __ when o instanceof Long l -> Long.toString(l);\n+                case ValueLayout.OfFloat __ when o instanceof Float f -> Float.toString(f);\n+                case ValueLayout.OfDouble __ when o instanceof Double d -> Double.toString(d);\n+                case AddressLayout __ when o instanceof MemorySegment m ->\n+                        String.format(\"0x%0\" + (ValueLayout.ADDRESS.byteSize() * 2) + \"X\", m.address());\n+                default ->\n+                        throw new UnsupportedOperationException(\"layout \" + layout + \" for \" + o.getClass().getName() + \" not supported\");\n+            };\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemoryInspectionUtil.java","additions":75,"deletions":115,"binary":false,"changes":190,"status":"modified"}]}