{"files":[{"patch":"@@ -119,5 +119,12 @@\n-                long comp = Blocker.begin(blocking);\n-                try {\n-                    numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n-                } finally {\n-                    Blocker.end(comp);\n+                if (Poller.useRecursivePoll() && Thread.currentThread().isVirtual()) {\n+                    if (timeout != 0) {\n+                        Poller.poll(epfd, Net.POLLIN, TimeUnit.MILLISECONDS.toNanos(timeout), this::isOpen);\n+                    }\n+                    numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, 0);\n+                } else {\n+                    long comp = Blocker.begin();\n+                    try {\n+                        numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                    } finally {\n+                        Blocker.end(comp);\n+                    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+    private static final boolean USE_RECURSIVE_POLL;\n@@ -391,0 +392,6 @@\n+        s = GetPropertyAction.privilegedGetProperty(\"jdk.useRecursivePoll\");\n+        if (s == null) {\n+            USE_RECURSIVE_POLL = provider.useRecursivePoll();\n+        } else {\n+            USE_RECURSIVE_POLL = \"\".equals(s) || Boolean.parseBoolean(s);\n+        }\n@@ -469,0 +476,4 @@\n+\n+    static boolean useRecursivePoll() {\n+        return USE_RECURSIVE_POLL;\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/Poller.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+    boolean useRecursivePoll() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/PollerProvider.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -70,0 +71,3 @@\n+    private final ReentrantLock selectorLock = new ReentrantLock();\n+    private final ReentrantLock publicSelectedKeysLock = new ReentrantLock();\n+\n@@ -122,1 +126,2 @@\n-        synchronized (this) {\n+        selectorLock.lock();\n+        try {\n@@ -127,0 +132,1 @@\n+            publicSelectedKeysLock.lock();\n@@ -128,3 +134,1 @@\n-                synchronized (publicSelectedKeys) {\n-                    return doSelect(action, timeout);\n-                }\n+                return doSelect(action, timeout);\n@@ -132,0 +136,1 @@\n+                publicSelectedKeysLock.unlock();\n@@ -134,0 +139,2 @@\n+        } finally {\n+            selectorLock.unlock();\n@@ -184,1 +191,2 @@\n-        synchronized (this) {\n+        selectorLock.lock();\n+        try {\n@@ -186,1 +194,2 @@\n-            synchronized (publicSelectedKeys) {\n+            publicSelectedKeysLock.lock();\n+            try {\n@@ -199,0 +208,2 @@\n+            } finally {\n+                publicSelectedKeysLock.unlock();\n@@ -200,0 +211,2 @@\n+        } finally {\n+            selectorLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SelectorImpl.java","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic tests for virtual threads doing blocking Selector select\n+ * @requires (os.family == \"linux\")\n+ * @compile --enable-preview --add-exports=java.base\/sun.nio.ch=ALL-UNNAMED  -source ${jdk.version} Selectors.java\n+ * @run testng\/othervm\/timeout=300 --enable-preview --add-exports=java.base\/sun.nio.ch=ALL-UNNAMED  Selectors\n+ * @run testng\/othervm\/timeout=300 --enable-preview --add-exports=java.base\/sun.nio.ch=ALL-UNNAMED -Djdk.useRecursivePoll=true Selectors\n+ * @run testng\/othervm\/timeout=300 --enable-preview --add-exports=java.base\/sun.nio.ch=ALL-UNNAMED -Djdk.useRecursivePoll=true -Djdk.useDirectRegister Selectors\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.spi.SelectorProvider;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicReference;\n+import sun.nio.ch.Poller;\n+import static org.testng.Assert.*;\n+\n+\n+public class Selectors {\n+    @Test\n+    public void testSelectorMounted() throws Exception {\n+        var selectorThread =  Thread.ofVirtual().start(() -> {\n+            try {\n+                Selector selector = Selector.open();\n+                selector.select();\n+            } catch (Exception ignored) {\n+            }\n+        });\n+        Thread.sleep(200);\n+        assertEquals(selectorThread.getState(),\n+                (Boolean.parseBoolean(System.getProperty(\"jdk.useRecursivePoll\"))? Thread.State.WAITING : Thread.State.RUNNABLE));\n+        selectorThread.interrupt();\n+        selectorThread.join();\n+    }\n+\n+    @Test\n+    public void testSelectorWakeup() throws Exception {\n+        var selectorSet = new CountDownLatch(1);\n+        var wakened = new CountDownLatch(1);\n+        var selector = new AtomicReference<Selector>();\n+        var selectorThread =  Thread.ofVirtual().start(() -> {\n+            try {\n+                selector.set(Selector.open());\n+                selectorSet.countDown();\n+                selector.get().select();\n+                wakened.countDown();\n+            } catch (Exception ignored) {\n+            }\n+        });\n+        selectorSet.await();\n+        selector.get().wakeup();\n+        wakened.await();\n+        selectorThread.join();\n+    }\n+\n+    @Test\n+    public void testSelectorInterrupt() throws Exception {\n+        var wakened = new CountDownLatch(1);\n+        var selector = new AtomicReference<Selector>();\n+        var exception = new AtomicReference<Exception>();\n+        var selectorThread =  Thread.ofVirtual().start(() -> {\n+            try {\n+                selector.set(Selector.open());\n+                selector.get().select();\n+                assertTrue(Thread.currentThread().isInterrupted());\n+                wakened.countDown();\n+            } catch (Exception e) {\n+                exception.set(e);\n+            }\n+        });\n+        Thread.sleep(100);  \/\/ give time for thread to block\n+        selectorThread.interrupt();\n+        wakened.await();\n+        assertTrue(exception.get() == null);\n+        selectorThread.join();\n+    }\n+\n+    @Test\n+    public void testSelectNow() throws Exception {\n+        var selector = Selector.open();\n+        var p = SelectorProvider.provider().openPipe();\n+        var sink = p.sink();\n+        var source = p.source();\n+        source.configureBlocking(false);\n+        sink.configureBlocking(false);\n+        var selectResult = new AtomicReference<Integer>();\n+        var exception = new AtomicReference<Exception>();\n+\n+        \/\/ selectNow return expected result\n+        Thread.ofVirtual().start(() -> {\n+            try {\n+                selectResult.set(selector.selectNow());\n+            } catch (Exception e) {\n+                exception.set(e);\n+            }\n+        }).join();\n+\n+        assertTrue(exception.get() == null);\n+        assertTrue(selectResult.get() == 0);\n+\n+        var readKey = source.register(selector, SelectionKey.OP_READ);\n+        var writeBuffer = ByteBuffer.allocateDirect(128);\n+        writeBuffer.put(\"helloworld\".getBytes());\n+        sink.write(writeBuffer);\n+\n+        Thread.ofVirtual().start(() -> {\n+            try {\n+                selectResult.set(selector.selectNow());\n+            } catch (Exception e) {\n+                exception.set(e);\n+            }\n+        }).join();\n+\n+        assertTrue(exception.get() == null);\n+        assertTrue(selectResult.get() == 1);\n+    }\n+\n+    @Test\n+    public void testSelectWithTimeout() throws Exception {\n+        \/\/ timed select wakeup eventually\n+        var exception = new AtomicReference<Exception>();\n+        Thread.ofVirtual().start(() -> {\n+            try {\n+                Selector.open().select(1000);\n+            } catch (Exception e) {\n+                exception.set(e);\n+            }\n+        }).join();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/Selectors.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -34,0 +34,6 @@\n+ * @run main\/othervm\/timeout=600\n+ *     --enable-preview\n+ *     -Dsun.net.client.defaultConnectTimeout=5000\n+ *     -Dsun.net.client.defaultReadTimeout=5000\n+ *     -Djdk.useRecursivePoll=true\n+ *     HttpALot\n","filename":"test\/jdk\/java\/net\/vthread\/HttpALot.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run main RegisterDuringSelect\n+ * @run main\/othervm --add-opens=java.base\/sun.nio.ch=ALL-UNNAMED --add-opens=java.base\/java.util.concurrent.locks=ALL-UNNAMED  RegisterDuringSelect\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/RegisterDuringSelect.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run main SelectAndClose\n+ * @run main\/othervm --add-opens=java.base\/sun.nio.ch=ALL-UNNAMED --add-opens=java.base\/java.util.concurrent.locks=ALL-UNNAMED SelectAndClose\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/SelectAndClose.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng SelectWithConsumer\n+ * @run testng\/othervm --add-opens=java.base\/sun.nio.ch=ALL-UNNAMED --add-opens=java.base\/java.util.concurrent.locks=ALL-UNNAMED SelectWithConsumer\n@@ -521,3 +521,2 @@\n-                assertTrue(Thread.holdsLock(sel));\n-                assertFalse(Thread.holdsLock(sel.keys()));\n-                assertTrue(Thread.holdsLock(sel.selectedKeys()));\n+                assertTrue(SelectorUtils.mightHoldKeysLock(Thread.currentThread(), sel));\n+                assertTrue(SelectorUtils.mightHoldSelectorLock(Thread.currentThread(), sel));\n@@ -529,3 +528,2 @@\n-                assertTrue(Thread.holdsLock(sel));\n-                assertFalse(Thread.holdsLock(sel.keys()));\n-                assertTrue(Thread.holdsLock(sel.selectedKeys()));\n+                assertTrue(SelectorUtils.mightHoldKeysLock(Thread.currentThread(), sel));\n+                assertTrue(SelectorUtils.mightHoldSelectorLock(Thread.currentThread(), sel));\n@@ -537,3 +535,2 @@\n-                assertTrue(Thread.holdsLock(sel));\n-                assertFalse(Thread.holdsLock(sel.keys()));\n-                assertTrue(Thread.holdsLock(sel.selectedKeys()));\n+                assertTrue(SelectorUtils.mightHoldKeysLock(Thread.currentThread(), sel));\n+                assertTrue(SelectorUtils.mightHoldSelectorLock(Thread.currentThread(), sel));\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/SelectWithConsumer.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n@@ -28,0 +30,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -31,16 +34,25 @@\n-    \/**\n-     * tell if the monitor of an Object is held by a Thread.\n-     * @param t    the Thread to hold the monitor of the selected-key set\n-     * @param lock the Object\n-     * @return\n-     *\/\n-    public static boolean mightHoldLock(Thread t, Object lock) {\n-        long tid = t.getId();\n-        int hash = System.identityHashCode(lock);\n-        ThreadInfo ti = ManagementFactory.getThreadMXBean().\n-                getThreadInfo(new long[]{ tid} , true, false, 100)[0];\n-        if (ti != null) {\n-            for (MonitorInfo mi : ti.getLockedMonitors()) {\n-                if (mi.getIdentityHashCode() == hash)\n-                    return true;\n-            }\n+    private static Field SELECTOR_LOCK;\n+    private static Field SELECTOR_SELECTEDKEY_LOCK;\n+    private static Method OWNER;\n+\n+    static {\n+        try {\n+            SELECTOR_LOCK = Class.forName(\"sun.nio.ch.SelectorImpl\").getDeclaredField(\"selectorLock\");\n+            SELECTOR_LOCK.setAccessible(true);\n+            SELECTOR_SELECTEDKEY_LOCK = Class.forName(\"sun.nio.ch.SelectorImpl\").getDeclaredField(\"publicSelectedKeys\");\n+            SELECTOR_SELECTEDKEY_LOCK.setAccessible(true);\n+            OWNER = ReentrantLock.class.getDeclaredMethod(\"getOwner\");\n+            OWNER.setAccessible(true);\n+        } catch (Exception e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public static boolean mightHoldSelectorLock(Thread t, Object selector) {\n+        try {\n+            ReentrantLock lock = (ReentrantLock) SELECTOR_LOCK.get(selector);\n+            if (lock == null)\n+                return false;\n+            return OWNER.invoke(lock) == t;\n+        } catch (Exception e) {\n+            return false;\n@@ -48,1 +60,0 @@\n-        return false;\n@@ -51,0 +62,12 @@\n+    public static boolean mightHoldKeysLock(Thread t, Object selector) {\n+        try {\n+            ReentrantLock lock = (ReentrantLock) SELECTOR_LOCK.get(selector);\n+            if (lock == null)\n+                return false;\n+            return OWNER.invoke(lock) == t;\n+        } catch (Exception e) {\n+            return false;\n+        }\n+    }\n+\n+\n@@ -60,1 +83,1 @@\n-        while (!mightHoldLock(t, sel.selectedKeys())) {\n+        while (!mightHoldSelectorLock(t, sel)) {\n","filename":"test\/jdk\/java\/nio\/channels\/Selector\/SelectorUtils.java","additions":41,"deletions":18,"binary":false,"changes":59,"status":"modified"}]}