{"files":[{"patch":"@@ -309,1 +309,1 @@\n-    final ThreadFlock flock;\n+    private final ThreadFlock flock;\n@@ -323,3 +323,3 @@\n-    int forkRound;         \/\/ incremented when the first subtask is forked after join\n-    int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n-    int lastJoinCompleted; \/\/ set to the current fork round when join completes\n+    private int forkRound;         \/\/ incremented when the first subtask is forked after join\n+    private int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n+    private int lastJoinCompleted; \/\/ set to the current fork round when join completes\n@@ -1391,1 +1391,1 @@\n-            private static final long serialVersionUID = -4311199705453810913L;\n+            private static final long serialVersionUID = -5575676091114831713L;\n@@ -1393,7 +1393,2 @@\n-            private UncheckedTimeoutException(TimeoutException cause) {\n-                super(cause);\n-            }\n-\n-            @Override\n-            public TimeoutException getCause() {\n-                return (TimeoutException) super.getCause();\n+            private UncheckedTimeoutException() {\n+                super();\n@@ -1405,1 +1400,1 @@\n-            private boolean finished;\n+            private int taken;\n@@ -1413,12 +1408,3 @@\n-                for(;;) {\n-                    if (!queue.isEmpty()) {\n-                        PlainSubtask<?> subtaskOrStop = queue.remove();\n-                        if (subtaskOrStop == PlainSubtask.STOP) {\n-                            return false;\n-                        }\n-                        @SuppressWarnings(\"unchecked\")\n-                        PlainSubtask<T> subtask = (PlainSubtask<T>) subtaskOrStop;\n-                        action.accept(subtask);\n-                        return true;\n-                    }\n-                    if (finished) {\n+                PlainSubtask<?> subtaskOrStop = queue.poll();\n+                if (subtaskOrStop == null) {\n+                    if (forkCount == taken) {  \/\/ volatile read\n@@ -1431,1 +1417,4 @@\n-                            finished = flock.awaitAll(timeout);\n+                            subtaskOrStop = queue.poll(timeout.toMillis(), TimeUnit.MILLISECONDS);\n+                            if (subtaskOrStop == null) {\n+                                throw new UncheckedTimeoutException();\n+                            }\n@@ -1433,1 +1422,1 @@\n-                            finished = flock.awaitAll();\n+                            subtaskOrStop = queue.take();\n@@ -1435,2 +1424,0 @@\n-                    } catch (TimeoutException e) {\n-                        throw new UncheckedTimeoutException(e);\n@@ -1442,0 +1429,8 @@\n+                if (subtaskOrStop == PlainSubtask.STOP) {\n+                    return false;\n+                }\n+                @SuppressWarnings(\"unchecked\")\n+                PlainSubtask<T> subtask = (PlainSubtask<T>) subtaskOrStop;\n+                action.accept(subtask);\n+                taken++;\n+                return true;\n@@ -1460,1 +1455,11 @@\n-        private final ConcurrentLinkedQueue<PlainSubtask<?>> queue = new ConcurrentLinkedQueue<>();\n+        private static final VarHandle FORK_COUNT;\n+        static {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            try {\n+                FORK_COUNT = lookup.findVarHandle(Streamable.class, \"forkCount\", int.class);\n+            } catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+        private final LinkedTransferQueue<PlainSubtask<?>> queue = new LinkedTransferQueue<>();\n+        private volatile int forkCount;\n@@ -1492,0 +1497,6 @@\n+        @Override\n+        public <U extends T> Subtask<U> fork(Callable<? extends U> task) {\n+            int dummy = (int) FORK_COUNT.getAndAdd(this, 1);\n+            return super.fork(task);\n+        }\n+\n@@ -1499,2 +1510,1 @@\n-            queue.add(newTask);\n-            flock.wakeup();\n+            queue.offer(newTask);\n@@ -1506,1 +1516,1 @@\n-                queue.add(PlainSubtask.STOP);\n+                queue.offer(PlainSubtask.STOP);\n@@ -1572,1 +1582,1 @@\n-                throw e.getCause();\n+                throw new TimeoutException();\n@@ -1580,5 +1590,6 @@\n-            lastJoinAttempted = forkRound;\n-            ensureOpen();  \/\/ throws ISE if closed\n-            SubTaskSpliterator spliterator = new SubTaskSpliterator(deadline);\n-            Stream<Subtask<T>> stream = StreamSupport.stream(spliterator, false);\n-            U result= mapper.apply(stream);\n+            int open = ensureOpen();  \/\/ throws ISE if closed\n+            if (open == SHUTDOWN) {\n+                throw new IllegalStateException();\n+            }\n+            Stream<Subtask<T>> stream = StreamSupport.stream(new SubTaskSpliterator(deadline), false);\n+            U result = mapper.apply(stream);\n@@ -1590,1 +1601,1 @@\n-            lastJoinCompleted = forkRound;\n+            super.join();  \/\/ update the forkRound\n@@ -1596,2 +1607,1 @@\n-            super.join();\n-            return this;\n+            throw new UnsupportedOperationException();\n@@ -1604,2 +1614,1 @@\n-            super.joinUntil(deadline);\n-            return this;\n+            throw new UnsupportedOperationException();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":53,"deletions":44,"binary":false,"changes":97,"status":"modified"}]}