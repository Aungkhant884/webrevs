{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.ArrayDeque;\n@@ -35,0 +36,2 @@\n+import java.util.Spliterator;\n+import java.util.concurrent.locks.Condition;\n@@ -36,0 +39,1 @@\n+import java.util.function.Consumer;\n@@ -38,0 +42,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -304,1 +310,1 @@\n-    private final ThreadFlock flock;\n+    final ThreadFlock flock;\n@@ -328,1 +334,1 @@\n-    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl {\n+    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl, Streamable.PlainSubTask {\n@@ -446,1 +452,1 @@\n-    private int ensureOpen() {\n+    int ensureOpen() {\n@@ -456,1 +462,1 @@\n-    private void ensureOwner() {\n+    void ensureOwner() {\n@@ -897,2 +903,5 @@\n-            \/\/ nothing to do if task scope is shutdown\n-            if (scope.isShutdown())\n+            \/\/ nothing to do if task scope is shutdown, apart if it's a Streamable\n+            if (scope.isShutdown()) {\n+                if (scope instanceof StructuredTaskScope.Streamable<?>) {\n+                    scope.handleComplete(this);\n+                }\n@@ -900,0 +909,1 @@\n+            }\n@@ -1329,0 +1339,210 @@\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n+     * complete {@linkplain Subtask.State#SUCCESS successfully}. Once captured, it\n+     * {@linkplain #shutdown() shuts down} the task scope to interrupt unfinished threads\n+     * and wakeup the task scope owner. The policy implemented by this class is intended\n+     * for cases where the result of any subtask will do (\"invoke any\") and where the\n+     * results of other unfinished subtasks are no longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @apiNote This class implements a policy to shut down the task scope when a subtask\n+     * completes successfully. There shouldn't be any need to directly shut down the task\n+     * scope with the {@link #shutdown() shutdown} method.\n+     *\n+     * @param <T> the result type\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public static final class Streamable<T> extends StructuredTaskScope<T> {\n+        private record PlainSubTask<T>(State state, T result, Throwable exception) implements Subtask<T> {\n+            @Override\n+            public Callable<? extends T> task() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public T get() {\n+                if (state != State.SUCCESS) {\n+                    throw new IllegalStateException();\n+                }\n+                return result;\n+            }\n+\n+            @Override\n+            public T result() {\n+                return get();\n+            }\n+\n+            @Override\n+            public Throwable exception() {\n+                if (state != State.FAILED) {\n+                    throw new IllegalStateException();\n+                }\n+                return exception;\n+            }\n+        }\n+\n+        private final class SubTaskSpliterator implements Spliterator<Subtask<T>> {\n+            private int taskCount;\n+\n+            private SubTaskSpliterator(int taskCount) {\n+                this.taskCount = taskCount;\n+            }\n+\n+            @Override\n+            public boolean tryAdvance(Consumer<? super Subtask<T>> action) {\n+                for(;;) {\n+                    if (taskCount == 0) {\n+                        return false;\n+                    }\n+                    Subtask<T> subtask;\n+                    queueLock.lock();\n+                    try {\n+                        while(queue.isEmpty()) {\n+                            try {\n+                                queueCondition.await();\n+                            } catch (InterruptedException e) {\n+                                Thread.currentThread().interrupt();\n+                                taskCount = 0;\n+                                return false;\n+                            }\n+                        }\n+                        subtask = queue.removeFirst();\n+                    } finally {\n+                        queueLock.unlock();\n+                    }\n+                    taskCount--;\n+                    if (subtask.state() == Subtask.State.UNAVAILABLE) {\n+                        continue;\n+                    }\n+                    action.accept(subtask);\n+                    return taskCount != 0;\n+                }\n+            }\n+\n+            @Override\n+            public Spliterator<Subtask<T>> trySplit() {\n+                return null;\n+            }\n+\n+            @Override\n+            public long estimateSize() {\n+                return Long.MAX_VALUE;\n+            }\n+\n+            @Override\n+            public int characteristics() {\n+                return CONCURRENT | DISTINCT | NONNULL;\n+            }\n+        }\n+\n+        private final ArrayDeque<PlainSubTask<T>> queue = new ArrayDeque<>();\n+        private final ReentrantLock queueLock = new ReentrantLock();\n+        private final Condition queueCondition = queueLock.newCondition();\n+        private int taskCounter;  \/\/ only the owner thread can mutate this field\n+\n+        \/**\n+         * Constructs a new {@code Streamable} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n+         *\n+         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+         * value} bindings for inheritance by threads started in the task scope. The\n+         * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+         * details how parent-child relations are established implicitly for the purpose\n+         * of inheritance of scoped value bindings.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public Streamable(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code Streamable} that creates virtual threads.\n+         *\n+         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n+         * a name of {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public Streamable() {\n+            this(null, Thread.ofVirtual().factory());\n+        }\n+\n+        @Override\n+        public <U extends T> Subtask<U> fork(Callable<? extends U> task) {\n+            ensureOwner();\n+            Subtask<U> subtask = super.fork(task);\n+            taskCounter++;\n+            return subtask;\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<? extends T> subtask) {\n+            PlainSubTask<T> newTask = switch (subtask.state()) {\n+                case FAILED -> new PlainSubTask<>(Subtask.State.FAILED, null, subtask.exception());\n+                case SUCCESS -> new PlainSubTask<>(Subtask.State.SUCCESS, subtask.get(), null);\n+                case UNAVAILABLE -> new PlainSubTask<>(Subtask.State.UNAVAILABLE, null, null);  \/\/ scope is shutdown\n+            };\n+            queueLock.lock();\n+            try {\n+                queue.add(newTask);\n+                queueCondition.signal();\n+            } finally {\n+                queueLock.unlock();\n+            }\n+        }\n+\n+        \/**\n+         *\n+         * TODO\n+         *\n+         * @param mapper a function that takes a stream and return a value\n+         * @return the value returned by the mapper function\n+         * @param <U> the type of the return value\n+         * @throws InterruptedException if an IO exception occurs\n+         *\/\n+        public <U> U joinWhen(Function<? super Stream<Subtask<T>>, ? extends U> mapper) throws InterruptedException {\n+            Objects.requireNonNull(mapper, \"mapper is null\");\n+            ensureOwner();\n+            int open = ensureOpen();\n+            if (open != OPEN) {\n+                throw new IllegalStateException(\"Task scope is shutdown\");\n+            }\n+\n+            flock.shutdown();\n+\n+            int taskCount = taskCounter;\n+            Stream<Subtask<T>> stream = StreamSupport.stream(new SubTaskSpliterator(taskCount), false);\n+            U result = mapper.apply(stream);\n+\n+            super.shutdown();\n+            super.join();\n+\n+            if (Thread.interrupted()) {\n+                throw new InterruptedException();\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public void shutdown() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Streamable<T> join() throws InterruptedException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Streamable<T> joinUntil(Instant deadline)\n+                throws InterruptedException, TimeoutException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":226,"deletions":6,"binary":false,"changes":232,"status":"modified"}]}