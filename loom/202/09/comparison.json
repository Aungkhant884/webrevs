{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import java.io.Serial;\n@@ -35,0 +36,1 @@\n+import java.util.Spliterator;\n@@ -36,0 +38,1 @@\n+import java.util.function.Consumer;\n@@ -38,0 +41,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -328,1 +333,1 @@\n-    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl {\n+    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl, Streamable.PlainSubtask {\n@@ -446,1 +451,1 @@\n-    private int ensureOpen() {\n+    int ensureOpen() {\n@@ -456,1 +461,1 @@\n-    private void ensureOwner() {\n+    void ensureOwner() {\n@@ -1329,0 +1334,283 @@\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n+     * complete {@linkplain Subtask.State#SUCCESS successfully}. Once captured, it\n+     * {@linkplain #shutdown() shuts down} the task scope to interrupt unfinished threads\n+     * and wakeup the task scope owner. The policy implemented by this class is intended\n+     * for cases where the result of any subtask will do (\"invoke any\") and where the\n+     * results of other unfinished subtasks are no longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @apiNote This class implements a policy to shut down the task scope when a subtask\n+     * completes successfully. There shouldn't be any need to directly shut down the task\n+     * scope with the {@link #shutdown() shutdown} method.\n+     *\n+     * @param <T> the result type\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public static final class Streamable<T> extends StructuredTaskScope<T> {\n+        private record PlainSubtask<T>(State state, T result, Throwable exception) implements Subtask<T> {\n+            private final static PlainSubtask<?> STOP = new PlainSubtask<>(null, null, null);\n+\n+            @Override\n+            public Callable<? extends T> task() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public T get() {\n+                if (state != State.SUCCESS) {\n+                    throw new IllegalStateException();\n+                }\n+                return result;\n+            }\n+\n+            @Override\n+            public T result() {\n+                return get();\n+            }\n+\n+            @Override\n+            public Throwable exception() {\n+                if (state != State.FAILED) {\n+                    throw new IllegalStateException();\n+                }\n+                return exception;\n+            }\n+        }\n+\n+        \/**\n+         * Used to tunnel a TimeoutException from {@link SubTaskSpliterator#tryAdvance(Consumer)}\n+         * to {@link #joinUntilWhile(Instant, Function)}.\n+         *\/\n+        private static final class UncheckedTimeoutException extends RuntimeException {\n+            @Serial\n+            private static final long serialVersionUID = -5575676091114831713L;\n+\n+            private UncheckedTimeoutException() {\n+                super();\n+            }\n+        }\n+\n+        private final class SubTaskSpliterator implements Spliterator<Subtask<T>> {\n+            private final Instant deadline;\n+            private int taken;\n+\n+            private SubTaskSpliterator(Instant deadline) {\n+                this.deadline = deadline;\n+            }\n+\n+            @Override\n+            public boolean tryAdvance(Consumer<? super Subtask<T>> action) {\n+                PlainSubtask<?> subtaskOrStop = queue.poll();\n+                if (subtaskOrStop == null) {\n+                    if (forkCount == taken) {  \/\/ volatile read\n+                        return false;\n+                    }\n+                    try {\n+                        \/\/ wait for all threads, wakeup, interrupt, or timeout\n+                        if (deadline != null) {\n+                            Duration timeout = Duration.between(Instant.now(), deadline);\n+                            subtaskOrStop = queue.poll(timeout.toMillis(), TimeUnit.MILLISECONDS);\n+                            if (subtaskOrStop == null) {\n+                                throw new UncheckedTimeoutException();\n+                            }\n+                        } else {\n+                            subtaskOrStop = queue.take();\n+                        }\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();\n+                        return false;\n+                    }\n+                }\n+                if (subtaskOrStop == PlainSubtask.STOP) {\n+                    return false;\n+                }\n+                @SuppressWarnings(\"unchecked\")\n+                PlainSubtask<T> subtask = (PlainSubtask<T>) subtaskOrStop;\n+                action.accept(subtask);\n+                taken++;\n+                return true;\n+            }\n+\n+            @Override\n+            public Spliterator<Subtask<T>> trySplit() {\n+                return null;\n+            }\n+\n+            @Override\n+            public long estimateSize() {\n+                return Long.MAX_VALUE;\n+            }\n+\n+            @Override\n+            public int characteristics() {\n+                return CONCURRENT | DISTINCT | NONNULL;\n+            }\n+        }\n+\n+        private static final VarHandle FORK_COUNT;\n+        static {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            try {\n+                FORK_COUNT = lookup.findVarHandle(Streamable.class, \"forkCount\", int.class);\n+            } catch (ReflectiveOperationException e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+        private final LinkedTransferQueue<PlainSubtask<?>> queue = new LinkedTransferQueue<>();\n+        private volatile int forkCount;\n+\n+        \/**\n+         * Constructs a new {@code Streamable} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n+         *\n+         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+         * value} bindings for inheritance by threads started in the task scope. The\n+         * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+         * details how parent-child relations are established implicitly for the purpose\n+         * of inheritance of scoped value bindings.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public Streamable(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code Streamable} that creates virtual threads.\n+         *\n+         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n+         * a name of {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public Streamable() {\n+            this(null, Thread.ofVirtual().factory());\n+        }\n+\n+        @Override\n+        public <U extends T> Subtask<U> fork(Callable<? extends U> task) {\n+            int dummy = (int) FORK_COUNT.getAndAdd(this, 1);\n+            return super.fork(task);\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<? extends T> subtask) {\n+            PlainSubtask<T> newTask = switch (subtask.state()) {\n+                case FAILED -> new PlainSubtask<>(Subtask.State.FAILED, null, subtask.exception());\n+                case SUCCESS -> new PlainSubtask<>(Subtask.State.SUCCESS, subtask.get(), null);\n+                case UNAVAILABLE -> throw new AssertionError();\n+            };\n+            queue.offer(newTask);\n+        }\n+\n+        @Override\n+        public void shutdown() {\n+            if (ensureOpen() == OPEN) {\n+                queue.offer(PlainSubtask.STOP);\n+            }\n+            super.shutdown();\n+        }\n+\n+        \/**\n+         * Wait for each subtask in this task scope to finish, push it into the stream,\n+         * until either the stream final operation ends, there is no more subtasks or\n+         * the scope is shutdown.\n+         *\n+         * <p> This method waits for each subtask by waiting for each thread {@linkplain\n+         * #fork(Callable) started} in this task scope to finish its execution.\n+         * It stops waiting when the stream is short-circuited, all threads finish,\n+         * the task scope is {@linkplain #shutdown() shut down}, or the current thread is\n+         * {@linkplain Thread#interrupt() interrupted}.\n+         *\n+         * <p> This method may only be invoked by the task scope owner.\n+         *\n+         * @param mapper a function that takes a stream and return a value\n+         * @param <U>    the type of the return value\n+         * @return the value returned by the mapper function\n+         * @throws IllegalStateException if this task scope is closed\n+         * @throws WrongThreadException  if the current thread is not the task scope owner\n+         * @throws InterruptedException  if interrupted while waiting\n+         *\/\n+        public <U> U joinWhile(Function<? super Stream<Subtask<T>>, ? extends U> mapper) throws InterruptedException {\n+            Objects.requireNonNull(mapper, \"mapper is null\");\n+\n+            try {\n+                return implJoinWhile(null, mapper);\n+            } catch (UncheckedTimeoutException e) {\n+                throw new InternalError();\n+            }\n+        }\n+\n+        \/**\n+         * Wait for each subtask in this task scope to finish, push it into the stream,\n+         * until either the stream final operation ends, there is no more subtasks,\n+         * the scope is shutdown up to a given deadline.\n+         *\n+         * <p> This method waits for each subtask by waiting for each thread {@linkplain\n+         * #fork(Callable) started} in this task scope to finish its execution.\n+         * It stops waiting when the stream is short-circuited, all threads finish,\n+         * the task scope is {@linkplain #shutdown() shut down}, the deadline is\n+         * reached or the current thread is {@linkplain Thread#interrupt() interrupted}.\n+         *\n+         * <p> This method may only be invoked by the task scope owner.\n+         *\n+         * @param deadline the deadline\n+         * @param mapper   a function that takes a stream and return a value\n+         * @param <U>      the type of the return value\n+         * @return the value returned by the mapper function\n+         * @throws IllegalStateException if this task scope is closed\n+         * @throws WrongThreadException  if the current thread is not the task scope owner\n+         * @throws InterruptedException  if interrupted while waiting\n+         * @throws TimeoutException      if the deadline is reached while waiting\n+         *\/\n+        public <U> U joinUntilWhile(Instant deadline, Function<? super Stream<Subtask<T>>, ? extends U> mapper)\n+                throws InterruptedException, TimeoutException\n+        {\n+            Objects.requireNonNull(deadline, \"deadline is null\");\n+            Objects.requireNonNull(mapper, \"mapper is null\");\n+\n+            try {\n+                return implJoinWhile(deadline, mapper);\n+            } catch (UncheckedTimeoutException e) {\n+                throw new TimeoutException();\n+            }\n+        }\n+\n+        private <U> U implJoinWhile(Instant deadline, Function<? super Stream<Subtask<T>>, ? extends U> mapper)\n+                throws InterruptedException, UncheckedTimeoutException\n+        {\n+            ensureOwner();\n+            int open = ensureOpen();  \/\/ throws ISE if closed\n+            if (open == SHUTDOWN) {\n+                throw new IllegalStateException();\n+            }\n+            Stream<Subtask<T>> stream = StreamSupport.stream(new SubTaskSpliterator(deadline), false);\n+            U result = mapper.apply(stream);\n+            if (Thread.interrupted()) {\n+                throw new InterruptedException();\n+            }\n+            super.shutdown();\n+            queue.clear();\n+            super.join();  \/\/ update the forkRound\n+            return result;\n+        }\n+\n+        @Override\n+        public Streamable<T> join() throws InterruptedException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Streamable<T> joinUntil(Instant deadline)\n+                throws InterruptedException, TimeoutException\n+        {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":291,"deletions":3,"binary":false,"changes":294,"status":"modified"}]}