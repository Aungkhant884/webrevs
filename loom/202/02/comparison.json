{"files":[{"patch":"@@ -35,0 +35,1 @@\n+import java.util.Spliterator;\n@@ -36,0 +37,1 @@\n+import java.util.function.Consumer;\n@@ -38,0 +40,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -304,1 +308,1 @@\n-    private final ThreadFlock flock;\n+    final ThreadFlock flock;\n@@ -318,3 +322,3 @@\n-    private int forkRound;         \/\/ incremented when the first subtask is forked after join\n-    private int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n-    private int lastJoinCompleted; \/\/ set to the current fork round when join completes\n+    int forkRound;         \/\/ incremented when the first subtask is forked after join\n+    int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n+    int lastJoinCompleted; \/\/ set to the current fork round when join completes\n@@ -328,1 +332,1 @@\n-    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl {\n+    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl, Streamable.PlainSubTask {\n@@ -446,1 +450,1 @@\n-    private int ensureOpen() {\n+    int ensureOpen() {\n@@ -456,1 +460,1 @@\n-    private void ensureOwner() {\n+    void ensureOwner() {\n@@ -897,2 +901,2 @@\n-            \/\/ nothing to do if task scope is shutdown\n-            if (scope.isShutdown())\n+            \/\/ nothing to do if task scope is shutdown, apart if it's a Streamable\n+            if (scope.isShutdown()) {\n@@ -900,0 +904,1 @@\n+            }\n@@ -1329,0 +1334,186 @@\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n+     * complete {@linkplain Subtask.State#SUCCESS successfully}. Once captured, it\n+     * {@linkplain #shutdown() shuts down} the task scope to interrupt unfinished threads\n+     * and wakeup the task scope owner. The policy implemented by this class is intended\n+     * for cases where the result of any subtask will do (\"invoke any\") and where the\n+     * results of other unfinished subtasks are no longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @apiNote This class implements a policy to shut down the task scope when a subtask\n+     * completes successfully. There shouldn't be any need to directly shut down the task\n+     * scope with the {@link #shutdown() shutdown} method.\n+     *\n+     * @param <T> the result type\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public static final class Streamable<T> extends StructuredTaskScope<T> {\n+        private record PlainSubTask<T>(State state, T result, Throwable exception) implements Subtask<T> {\n+            @Override\n+            public Callable<? extends T> task() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public T get() {\n+                if (state != State.SUCCESS) {\n+                    throw new IllegalStateException();\n+                }\n+                return result;\n+            }\n+\n+            @Override\n+            public T result() {\n+                return get();\n+            }\n+\n+            @Override\n+            public Throwable exception() {\n+                if (state != State.FAILED) {\n+                    throw new IllegalStateException();\n+                }\n+                return exception;\n+            }\n+        }\n+\n+        private final class SubTaskSpliterator implements Spliterator<Subtask<T>> {\n+            private boolean finished;\n+\n+            @Override\n+            public boolean tryAdvance(Consumer<? super Subtask<T>> action) {\n+                for(;;) {\n+                    if (isShutdown()) {\n+                        return false;\n+                    }\n+                    if (queue.isEmpty()) {\n+                        if (finished) {\n+                            return false;\n+                        }\n+                        try {\n+                            finished = flock.awaitAll();\n+                        } catch (InterruptedException e) {\n+                            Thread.currentThread().interrupt();\n+                            finished = true;\n+                            return false;\n+                        }\n+                    }\n+                    if (queue.isEmpty()) {\n+                      continue;  \/\/ awaken by shutdown or finished\n+                    }\n+                    Subtask<T> subtask = queue.remove();\n+                    if (subtask.state() == Subtask.State.UNAVAILABLE) {\n+                        continue;\n+                    }\n+                    action.accept(subtask);\n+                    return true;\n+                }\n+            }\n+\n+            @Override\n+            public Spliterator<Subtask<T>> trySplit() {\n+                return null;\n+            }\n+\n+            @Override\n+            public long estimateSize() {\n+                return Long.MAX_VALUE;\n+            }\n+\n+            @Override\n+            public int characteristics() {\n+                return CONCURRENT | DISTINCT | NONNULL;\n+            }\n+        }\n+\n+        private final ConcurrentLinkedQueue<PlainSubTask<T>> queue = new ConcurrentLinkedQueue<>();\n+\n+        \/**\n+         * Constructs a new {@code Streamable} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n+         *\n+         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+         * value} bindings for inheritance by threads started in the task scope. The\n+         * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+         * details how parent-child relations are established implicitly for the purpose\n+         * of inheritance of scoped value bindings.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public Streamable(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code Streamable} that creates virtual threads.\n+         *\n+         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n+         * a name of {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public Streamable() {\n+            this(null, Thread.ofVirtual().factory());\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<? extends T> subtask) {\n+            PlainSubTask<T> newTask = switch (subtask.state()) {\n+                case FAILED -> new PlainSubTask<>(Subtask.State.FAILED, null, subtask.exception());\n+                case SUCCESS -> new PlainSubTask<>(Subtask.State.SUCCESS, subtask.get(), null);\n+                case UNAVAILABLE -> throw new AssertionError();\n+            };\n+            queue.add(newTask);\n+            flock.wakeup();\n+        }\n+\n+        \/**\n+         *\n+         * TODO\n+         *\n+         * @param mapper a function that takes a stream and return a value\n+         * @return the value returned by the mapper function\n+         * @param <U> the type of the return value\n+         * @throws InterruptedException if an IO exception occurs\n+         *\/\n+        public <U> U joinWhen(Function<? super Stream<Subtask<T>>, ? extends U> mapper) throws InterruptedException {\n+            Objects.requireNonNull(mapper, \"mapper is null\");\n+\n+            ensureOwner();\n+            lastJoinAttempted = forkRound;\n+            ensureOpen();  \/\/ throws ISE if closed\n+\n+            Stream<Subtask<T>> stream = StreamSupport.stream(new SubTaskSpliterator(), false);\n+            U result = mapper.apply(stream);\n+\n+            lastJoinCompleted = forkRound;\n+\n+            super.shutdown();\n+\n+            if (Thread.interrupted()) {\n+                throw new InterruptedException();\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public void shutdown() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Streamable<T> join() throws InterruptedException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Streamable<T> joinUntil(Instant deadline)\n+                throws InterruptedException, TimeoutException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":200,"deletions":9,"binary":false,"changes":209,"status":"modified"}]}