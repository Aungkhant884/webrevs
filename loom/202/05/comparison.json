{"files":[{"patch":"@@ -27,0 +27,1 @@\n+import java.io.Serial;\n@@ -35,0 +36,1 @@\n+import java.util.Spliterator;\n@@ -36,0 +38,1 @@\n+import java.util.function.Consumer;\n@@ -38,0 +41,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -304,1 +309,1 @@\n-    private final ThreadFlock flock;\n+    final ThreadFlock flock;\n@@ -318,3 +323,3 @@\n-    private int forkRound;         \/\/ incremented when the first subtask is forked after join\n-    private int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n-    private int lastJoinCompleted; \/\/ set to the current fork round when join completes\n+    int forkRound;         \/\/ incremented when the first subtask is forked after join\n+    int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n+    int lastJoinCompleted; \/\/ set to the current fork round when join completes\n@@ -328,1 +333,1 @@\n-    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl {\n+    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl, Streamable.PlainSubTask {\n@@ -446,1 +451,1 @@\n-    private int ensureOpen() {\n+    int ensureOpen() {\n@@ -456,1 +461,1 @@\n-    private void ensureOwner() {\n+    void ensureOwner() {\n@@ -1329,0 +1334,267 @@\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n+     * complete {@linkplain Subtask.State#SUCCESS successfully}. Once captured, it\n+     * {@linkplain #shutdown() shuts down} the task scope to interrupt unfinished threads\n+     * and wakeup the task scope owner. The policy implemented by this class is intended\n+     * for cases where the result of any subtask will do (\"invoke any\") and where the\n+     * results of other unfinished subtasks are no longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @apiNote This class implements a policy to shut down the task scope when a subtask\n+     * completes successfully. There shouldn't be any need to directly shut down the task\n+     * scope with the {@link #shutdown() shutdown} method.\n+     *\n+     * @param <T> the result type\n+     * @since 22\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public static final class Streamable<T> extends StructuredTaskScope<T> {\n+        private record PlainSubTask<T>(State state, T result, Throwable exception) implements Subtask<T> {\n+            @Override\n+            public Callable<? extends T> task() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public T get() {\n+                if (state != State.SUCCESS) {\n+                    throw new IllegalStateException();\n+                }\n+                return result;\n+            }\n+\n+            @Override\n+            public T result() {\n+                return get();\n+            }\n+\n+            @Override\n+            public Throwable exception() {\n+                if (state != State.FAILED) {\n+                    throw new IllegalStateException();\n+                }\n+                return exception;\n+            }\n+        }\n+\n+        \/**\n+         * Used to tunnel a TimeoutException from {@link SubTaskSpliterator#tryAdvance(Consumer)}\n+         * to {@link #joinUntilWhile(Instant, Function)}.\n+         *\/\n+        private static final class UncheckedTimeoutException extends RuntimeException {\n+            @Serial\n+            private static final long serialVersionUID = -4311199705453810913L;\n+\n+            private UncheckedTimeoutException(TimeoutException cause) {\n+                super(cause);\n+            }\n+\n+            @Override\n+            public TimeoutException getCause() {\n+                return (TimeoutException) super.getCause();\n+            }\n+        }\n+\n+        private final class SubTaskSpliterator implements Spliterator<Subtask<T>> {\n+            private final Instant deadline;\n+            private boolean finished;\n+\n+            private SubTaskSpliterator(Instant deadline) {\n+                this.deadline = deadline;\n+            }\n+\n+            @Override\n+            public boolean tryAdvance(Consumer<? super Subtask<T>> action) {\n+                for(;;) {\n+                    if (isShutdown()) {\n+                        return false;\n+                    }\n+                    if (queue.isEmpty()) {\n+                        if (finished) {\n+                            return false;\n+                        }\n+                        try {\n+                            \/\/ wait for all threads, wakeup, interrupt, or timeout\n+                            if (deadline != null) {\n+                                Duration timeout = Duration.between(Instant.now(), deadline);\n+                                finished = flock.awaitAll(timeout);\n+                            } else {\n+                                finished = flock.awaitAll();\n+                            }\n+                        } catch(TimeoutException e) {\n+                            throw new UncheckedTimeoutException(e);\n+                        } catch (InterruptedException e) {\n+                            Thread.currentThread().interrupt();\n+                            finished = true;\n+                            return false;\n+                        }\n+                    }\n+                    if (queue.isEmpty()) {\n+                      continue;  \/\/ awaken by shutdown or finished\n+                    }\n+                    Subtask<T> subtask = queue.remove();\n+                    if (subtask.state() == Subtask.State.UNAVAILABLE) {\n+                        continue;\n+                    }\n+                    action.accept(subtask);\n+                    return true;\n+                }\n+            }\n+\n+            @Override\n+            public Spliterator<Subtask<T>> trySplit() {\n+                return null;\n+            }\n+\n+            @Override\n+            public long estimateSize() {\n+                return Long.MAX_VALUE;\n+            }\n+\n+            @Override\n+            public int characteristics() {\n+                return CONCURRENT | DISTINCT | NONNULL;\n+            }\n+        }\n+\n+        private final ConcurrentLinkedQueue<PlainSubTask<T>> queue = new ConcurrentLinkedQueue<>();\n+\n+        \/**\n+         * Constructs a new {@code Streamable} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n+         *\n+         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+         * value} bindings for inheritance by threads started in the task scope. The\n+         * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+         * details how parent-child relations are established implicitly for the purpose\n+         * of inheritance of scoped value bindings.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public Streamable(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code Streamable} that creates virtual threads.\n+         *\n+         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n+         * a name of {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public Streamable() {\n+            this(null, Thread.ofVirtual().factory());\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<? extends T> subtask) {\n+            PlainSubTask<T> newTask = switch (subtask.state()) {\n+                case FAILED -> new PlainSubTask<>(Subtask.State.FAILED, null, subtask.exception());\n+                case SUCCESS -> new PlainSubTask<>(Subtask.State.SUCCESS, subtask.get(), null);\n+                case UNAVAILABLE -> throw new AssertionError();\n+            };\n+            queue.add(newTask);\n+            flock.wakeup();\n+        }\n+\n+        \/**\n+         * Wait for each subtask in this task scope to finish, push it into the stream,\n+         * until either the stream final operation ends, there is no more subtasks or\n+         * the scope is shutdown.\n+         *\n+         * <p> This method waits for each subtask by waiting for each thread {@linkplain\n+         * #fork(Callable) started} in this task scope to finish its execution.\n+         * It stops waiting when the stream is short-circuited, all threads finish,\n+         * the task scope is {@linkplain #shutdown() shut down}, or the current thread is\n+         * {@linkplain Thread#interrupt() interrupted}.\n+         *\n+         * <p> This method may only be invoked by the task scope owner.\n+         *\n+         * @param mapper a function that takes a stream and return a value\n+         * @param <U>    the type of the return value\n+         * @return the value returned by the mapper function\n+         * @throws IllegalStateException if this task scope is closed\n+         * @throws WrongThreadException  if the current thread is not the task scope owner\n+         * @throws InterruptedException  if interrupted while waiting\n+         *\/\n+        public <U> U joinWhile(Function<? super Stream<Subtask<T>>, ? extends U> mapper) throws InterruptedException {\n+            Objects.requireNonNull(mapper, \"mapper is null\");\n+\n+            try {\n+                return implJoinWhile(null, mapper);\n+            } catch (UncheckedTimeoutException e) {\n+                throw new InternalError();\n+            }\n+        }\n+\n+        \/**\n+         * Wait for each subtask in this task scope to finish, push it into the stream,\n+         * until either the stream final operation ends, there is no more subtasks,\n+         * the scope is shutdown up to a given deadline.\n+         *\n+         * <p> This method waits for each subtask by waiting for each thread {@linkplain\n+         * #fork(Callable) started} in this task scope to finish its execution.\n+         * It stops waiting when the stream is short-circuited, all threads finish,\n+         * the task scope is {@linkplain #shutdown() shut down}, the deadline is\n+         * reached or the current thread is {@linkplain Thread#interrupt() interrupted}.\n+         *\n+         * <p> This method may only be invoked by the task scope owner.\n+         *\n+         * @param deadline the deadline\n+         * @param mapper   a function that takes a stream and return a value\n+         * @param <U>      the type of the return value\n+         * @return the value returned by the mapper function\n+         * @throws IllegalStateException if this task scope is closed\n+         * @throws WrongThreadException  if the current thread is not the task scope owner\n+         * @throws InterruptedException  if interrupted while waiting\n+         * @throws TimeoutException      if the deadline is reached while waiting\n+         *\/\n+        public <U> U joinUntilWhile(Instant deadline, Function<? super Stream<Subtask<T>>, ? extends U> mapper)\n+                throws InterruptedException, TimeoutException\n+        {\n+            Objects.requireNonNull(deadline, \"deadline is null\");\n+            Objects.requireNonNull(mapper, \"mapper is null\");\n+\n+            try {\n+                return implJoinWhile(deadline, mapper);\n+            } catch (UncheckedTimeoutException e) {\n+                throw e.getCause();\n+            }\n+        }\n+\n+        private <U> U implJoinWhile(Instant deadline, Function<? super Stream<Subtask<T>>, ? extends U> mapper)\n+                throws InterruptedException, UncheckedTimeoutException\n+        {\n+            ensureOwner();\n+            lastJoinAttempted = forkRound;\n+            ensureOpen();  \/\/ throws ISE if closed\n+            Stream<Subtask<T>> stream = StreamSupport.stream(new SubTaskSpliterator(deadline), false);\n+            U result= mapper.apply(stream);\n+            lastJoinCompleted = forkRound;\n+            super.shutdown();\n+            if (Thread.interrupted()) {\n+                throw new InterruptedException();\n+            }\n+            return result;\n+        }\n+\n+        @Override\n+        public Streamable<T> join() throws InterruptedException {\n+            super.join();\n+            return this;\n+        }\n+\n+        @Override\n+        public Streamable<T> joinUntil(Instant deadline)\n+                throws InterruptedException, TimeoutException\n+        {\n+            super.joinUntil(deadline);\n+            return this;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":279,"deletions":7,"binary":false,"changes":286,"status":"modified"}]}