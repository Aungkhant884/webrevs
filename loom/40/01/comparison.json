{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -2272,2 +2272,2 @@\n-    if (carrier_thread == (oop)NULL) {\n-      return (oop)NULL;\n+    if (carrier_thread == NULL) {\n+      return NULL;\n@@ -2283,2 +2283,0 @@\n-    Handle _result;\n-    Handle _exception;\n@@ -2286,4 +2284,12 @@\n-\n-    GetStackTraceClosure(Handle java_thread, Handle result, Handle exception) : \n-      HandshakeClosure(\"GetStackTraceClosure\"), \n-      _java_thread(java_thread), _result(result), _exception(exception), _depth(0) {}\n+    GrowableArray<Method*>* _methods;\n+    GrowableArray<int>*     _bcis;\n+    GrowableArray<oop>*     _continuations;\n+\n+    GetStackTraceClosure(Handle java_thread) :\n+      HandshakeClosure(\"GetStackTraceClosure\"), _java_thread(java_thread), _depth(0) {\n+      \/\/ Pick some initial length\n+      int init_length = MaxJavaStackTraceDepth\/2;\n+      _methods = new GrowableArray<Method*>(init_length);\n+      _bcis = new GrowableArray<int>(init_length);\n+      _continuations = new GrowableArray<oop>(init_length);\n+    }\n@@ -2295,17 +2301,2 @@\n-    void do_thread(Thread* thread) {\n-      Thread* THREAD = Thread::current();\n-\n-      do_thread0(thread);\n-\n-      if (THREAD == thread) { \/\/ we're running in the target thread\n-        if (THREAD->has_pending_exception()) {\n-          *_exception.raw_value() = THREAD->pending_exception();\n-          THREAD->clear_pending_exception();\n-        }\n-      }\n-    }\n-\n-    void do_thread0(Thread* th) {\n-      assert (th->is_Java_thread(), \"\");\n-      JavaThread* thread = (JavaThread*)th;\n-      JavaThread* THREAD = (JavaThread*)Thread::current();\n+    void do_thread(Thread* th) {\n+      JavaThread* thread = th->as_Java_thread();\n@@ -2316,1 +2307,0 @@\n-      ResourceMark rm(THREAD);\n@@ -2319,0 +2309,1 @@\n+      oop vthread_scope = java_lang_VirtualThread::vthread_scope();\n@@ -2321,1 +2312,2 @@\n-        if (thread->last_continuation(java_lang_VirtualThread::vthread_scope())->cont_oop() != java_lang_VirtualThread::continuation(_java_thread())) {\n+        if (thread->last_continuation(vthread_scope)->cont_oop() !=\n+              java_lang_VirtualThread::continuation(_java_thread())) {\n@@ -2325,2 +2317,1 @@\n-        if (thread->last_continuation(java_lang_VirtualThread::vthread_scope()) != NULL)\n-          carrier = true;\n+        carrier = (thread->last_continuation(vthread_scope) != NULL);\n@@ -2328,1 +2319,1 @@\n-      \n+\n@@ -2332,3 +2323,0 @@\n-      HandleMark hm(THREAD);\n-      BacktraceBuilder bt(CHECK);\n-\n@@ -2336,3 +2324,9 @@\n-      for (vframeStream vfst(thread, false, false, carrier); !vfst.at_end() && (max_depth == 0 || max_depth != total_count); vfst.next()) {\n-        if (skip_hidden && (vfst.method()->is_hidden() || vfst.method()->is_continuation_enter_intrinsic())) continue;\n-        bt.push(vfst.method(), vfst.bci(), contScopeName(vfst.continuation()), CHECK);\n+      for (vframeStream vfst(thread, false, false, carrier);\n+           !vfst.at_end() && (max_depth == 0 || max_depth != total_count);\n+           vfst.next()) {\n+\n+        if (skip_hidden && (vfst.method()->is_hidden() ||\n+                            vfst.method()->is_continuation_enter_intrinsic())) continue;\n+        _methods->push(vfst.method());\n+        _bcis->push(vfst.bci());\n+        _continuations->push(contScopeName(vfst.continuation()));\n@@ -2343,1 +2337,0 @@\n-      *_result.raw_value() = bt.backtrace();\n@@ -2347,1 +2340,1 @@\n-      return cont != (oop)NULL ? java_lang_ContinuationScope::name(Continuation::continuation_scope(cont)) : (oop)NULL;\n+      return cont == NULL ? NULL : java_lang_ContinuationScope::name(Continuation::continuation_scope(cont));\n@@ -2351,6 +2344,4 @@\n-  \/\/ handhsake with target\n-  Handle backtrace(THREAD, java_thread); \/\/ we need to allocate a handle with an arbitrary non-null oop\n-  *backtrace.raw_value() = (oop)NULL;\n-  Handle exception(THREAD, java_thread); \/\/ we need to allocate a handle with an arbitrary non-null oop\n-  *exception.raw_value() = (oop)NULL;\n-  GetStackTraceClosure gstc(Handle(THREAD, java_thread), backtrace, exception);\n+  \/\/ Handshake with target\n+  ResourceMark rm(THREAD);\n+  HandleMark   hm(THREAD);\n+  GetStackTraceClosure gstc(Handle(THREAD, java_thread));\n@@ -2359,2 +2350,3 @@\n-  if (exception() != (oop)NULL) {\n-    THROW_OOP_(exception(), (oop)NULL);\n+  \/\/ Stop if no stack trace is found.\n+  if (gstc._depth == 0) {\n+    return NULL;\n@@ -2362,2 +2354,6 @@\n-  if (backtrace() == (oop)NULL) {\n-    return (oop)NULL;\n+\n+  \/\/ Convert the continuations into handles before allocation.\n+  assert(gstc._depth == gstc._continuations->length(), \"should be the same\");\n+  GrowableArray<Handle>* cont_handles = new GrowableArray<Handle>(gstc._depth);\n+  for (int i = 0; i < gstc._depth; i++) {\n+    cont_handles->push(Handle(THREAD, gstc._continuations->at(i)));\n@@ -2366,1 +2362,1 @@\n-  \/\/ convert to StackTraceElement array\n+  \/\/ Convert to StackTraceElement array\n@@ -2371,2 +2367,7 @@\n-  for (int i=0; i < gstc._depth; i++) {\n-    oop element = k->allocate_instance(CHECK_NULL);\n+\n+  for (int i = 0; i < gstc._depth; i++) {\n+    methodHandle method(THREAD, gstc._methods->at(i));\n+    oop element = java_lang_StackTraceElement::create(method,\n+                                                      gstc._bcis->at(i),\n+                                                      cont_handles->at(i),\n+                                                      CHECK_NULL);\n@@ -2375,1 +2376,0 @@\n-  java_lang_Throwable::get_stack_trace_elements(gstc._depth, backtrace, trace, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"}]}