{"files":[{"patch":"@@ -2099,0 +2099,2 @@\n+int java_lang_Thread::_noninheritableScopeLocalBindings_offset;\n+int java_lang_Thread::_inheritableScopeLocalBindings_offset;\n@@ -2111,0 +2113,2 @@\n+  macro(_noninheritableScopeLocalBindings_offset, k, \"noninheritableScopeLocalBindings\", scopeLocalSnapshot_name, false); \\\n+  macro(_inheritableScopeLocalBindings_offset,    k, \"inheritableScopeLocalBindings\", scopeLocalSnapshot_name, false); \\\n@@ -2141,0 +2145,5 @@\n+void java_lang_Thread::clear_scopeLocalBindings(oop java_thread) {\n+  java_thread->obj_field_put(_noninheritableScopeLocalBindings_offset, NULL);\n+  java_thread->obj_field_put(_inheritableScopeLocalBindings_offset, NULL);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -387,0 +387,2 @@\n+  static int _noninheritableScopeLocalBindings_offset;\n+  static int _inheritableScopeLocalBindings_offset;\n@@ -436,0 +438,3 @@\n+  \/\/ Clear all scope local bindings on error\n+  static void clear_scopeLocalBindings(oop java_thread);\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+  template(scopeLocalSnapshot_name,                   \"Ljava\/lang\/ScopeLocal$Snapshot;\")          \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"logging\/log.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3112,2 +3112,2 @@\n-  return _gvn.transform(make_load(NULL, p, p->bottom_type()->is_ptr(),\n-                                  T_ADDRESS, MemNode::unordered));\n+  return _gvn.transform(LoadNode::make(_gvn, NULL, immutable_memory(), p, p->bottom_type()->is_ptr(),\n+        TypeRawPtr::NOTNULL, T_ADDRESS, MemNode::unordered));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -421,0 +421,5 @@\n+    \/\/ FIXME: This very crudely destroys all ScopeLocal bindings. This\n+    \/\/ is better than a bound value escaping, but far from ideal.\n+    oop java_thread = current->threadObj();\n+    current->set_scopeLocalCache(NULL);\n+    java_lang_Thread::clear_scopeLocalBindings(java_thread);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1826,0 +1826,6 @@\n+      \/\/ Clear any scope-local bindings on ThreadDeath\n+      set_scopeLocalCache(NULL);\n+      oop threadOop = threadObj();\n+      assert(threadOop != NULL, \"must be\");\n+      java_lang_Thread::clear_scopeLocalBindings(threadOop);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.function.Function;\n@@ -36,0 +37,2 @@\n+import static jdk.internal.javac.PreviewFeature.Feature.SCOPE_LOCALS;\n+\n@@ -39,1 +42,1 @@\n- * <p> A scoped variable differs from a normal variable in that it is dynamically\n+ * <p> A scope-local variable differs from a normal variable in that it is dynamically\n@@ -41,4 +44,4 @@\n- * to a transitive callee without using an explicit parameter. A scoped variable\n- * does not have a default\/initial value, it is bound, meaning it gets a value,\n- * when executing an operation specified to {@link #runWithBinding(Object, Runnable)}\n- * or {@link #callWithBinding(Object, Callable)}. Code executed by the operation\n+ * to a transitive callee without using an explicit parameter. A scope-local variable\n+ * does not have a default\/initial value: it is bound, meaning it gets a value,\n+ * when executing an operation specified to {@link #where(ScopeLocal, Object)}.\n+ * Code executed by the operation\n@@ -83,1 +86,1 @@\n- *   CREDENTIALS.runWithBinding(creds, () -> {\n+ *   ScopeLocal.where(CREDENTIALS, creds).run(creds, () -> {\n@@ -98,0 +101,1 @@\n+@jdk.internal.javac.PreviewFeature(feature=SCOPE_LOCALS)\n@@ -107,1 +111,1 @@\n-    public int hashCode() { return hash; }\n+    public final int hashCode() { return hash; }\n@@ -110,1 +114,1 @@\n-     * Represents a snapshot of inheritable scoped variables.\n+     * An immutable map from {@code ScopeLocal} to values.\n@@ -120,2 +124,0 @@\n-        final ScopeLocal<?> key;\n-        final Object value;\n@@ -123,0 +125,2 @@\n+        final SingleBinding bindings;\n+        final short primaryBits;\n@@ -126,4 +130,1 @@\n-        Snapshot(ScopeLocal<?> key, Object value, Snapshot prev) {\n-            key.type.cast(value);\n-            this.key = key;\n-            this.value = value;\n+        Snapshot(SingleBinding bindings, Snapshot prev, short primaryBits) {\n@@ -131,0 +132,2 @@\n+            this.bindings = bindings;\n+            this.primaryBits = primaryBits;\n@@ -133,2 +136,14 @@\n-        final Object get() {\n-            return value;\n+        Object find(ScopeLocal<?> key) {\n+            for (Snapshot b = this; b != null; b = b.prev) {\n+                if (((1 << Cache.primaryIndex(key)) & b.primaryBits) != 0) {\n+                    for (SingleBinding binding = b.bindings;\n+                         binding != null;\n+                         binding = binding.prev) {\n+                        if (binding.getKey() == key) {\n+                            Object value = binding.get();\n+                            return value;\n+                        }\n+                    }\n+                }\n+            }\n+            return NIL;\n@@ -136,0 +151,1 @@\n+    }\n@@ -137,2 +153,17 @@\n-        final ScopeLocal<?> getKey() {\n-            return key;\n+    \/**\n+     * An immutable map from a set of ScopeLocals to their bound values.\n+     * When map() or call() is invoked, the ScopeLocals bound in this set\n+     * are bound, such that calling the get() method returns the associated\n+     * value.\n+     *\/\n+    public static final class Carrier {\n+        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n+        \/\/ hits that slot in the cache\n+        final short primaryBits, secondaryBits;\n+        final SingleBinding inheritables, nonInheritables;\n+\n+       Carrier(SingleBinding inheritables, SingleBinding nonInheritables, short primaryBits, short secondaryBits) {\n+            this.inheritables = inheritables;\n+            this.nonInheritables = nonInheritables;\n+            this.primaryBits = primaryBits;\n+            this.secondaryBits = secondaryBits;\n@@ -141,2 +172,45 @@\n-        Object find(ScopeLocal<?> key) {\n-            for (Snapshot b = this; b != null; b = b.prev) {\n+        \/**\n+         * Add a binding to this map, returning a new Carrier instance.\n+         *\/\n+        private static final <T> Carrier where(ScopeLocal<T> key, T value,\n+                                           SingleBinding inheritables, SingleBinding nonInheritables,\n+                                           short primaryBits, short secondaryBits) {\n+            if (key.isInheritable) {\n+                inheritables = new SingleBinding(key, value, inheritables);\n+            } else {\n+                nonInheritables = new SingleBinding(key, value, nonInheritables);\n+            }\n+            primaryBits |= (short)(1 << Cache.primaryIndex(key));\n+            secondaryBits |= (short)(1 << Cache.secondaryIndex(key));\n+            return new Carrier(inheritables, nonInheritables, primaryBits, secondaryBits);\n+        }\n+\n+        \/**\n+         * Return a new map, which consists of the contents of this map plus a\n+         * new binding of key and value.\n+         * @param key   The ScopeLocal to bind a value to\n+         * @param value The new value\n+         * @param <T>   The type of the ScopeLocal\n+         * @return TBD\n+         *\/\n+        public final <T> Carrier where(ScopeLocal<T> key, T value) {\n+            return where(key, value, inheritables, nonInheritables, primaryBits, secondaryBits);\n+        }\n+\n+        \/*\n+         * Return a new set consisting of a single binding.\n+         *\/\n+        static final <T> Carrier of(ScopeLocal<T> key, T value) {\n+            return where(key, value, null, null, (short)0, (short)0);\n+        }\n+\n+        \/**\n+         * Search for the value of a binding in this set\n+         * @param key the ScopeLocal to find\n+         * @param <T> the type of the ScopeLocal\n+         * @return the value\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public final <T> T get(ScopeLocal<T> key) {\n+            for (SingleBinding b = key.isInheritable ? inheritables : nonInheritables;\n+                 b != null; b = b.prev) {\n@@ -145,1 +219,1 @@\n-                    return value;\n+                    return (T)value;\n@@ -148,1 +222,1 @@\n-            return NIL;\n+            throw new NoSuchElementException();\n@@ -150,0 +224,1 @@\n+\n@@ -151,1 +226,4 @@\n-         * Runs an operation with this snapshot of inheritable scoped variables.\n+         * Runs a value-returning operation with this some ScopeLocals bound to values.\n+         * Code executed by the operation can use the {@link #get()} method to\n+         * get the value of the variables. The variables revert to their previous values or\n+         * becomes {@linkplain #isBound() unbound} when the operation completes.\n@@ -153,1 +231,4 @@\n-         * @param op the operation to run\n+         * @param op    the operation to run\n+         * @param <R>   the type of the result of the function\n+         * @return the result\n+         * @throws Exception if the operation completes with an exception\n@@ -155,4 +236,5 @@\n-        public void runWithSnapshot(Runnable op) {\n-            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-            var cache = Thread.scopeLocalCache();\n-            Cache.invalidate();\n+        public final <R> R call(Callable<R> op) throws Exception {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(primaryBits | secondaryBits);\n+            var inheritables = addScopeLocalBindings(this.inheritables, primaryBits,true);\n+            var nonInheritables = addScopeLocalBindings(this.nonInheritables, primaryBits,false);\n@@ -160,2 +242,1 @@\n-                Thread.currentThread().inheritableScopeLocalBindings = this;\n-                op.run();\n+                return op.call();\n@@ -163,2 +244,4 @@\n-                Thread.currentThread().inheritableScopeLocalBindings = prev;\n-                Thread.setScopeLocalCache(cache);\n+                Thread currentThread = Thread.currentThread();\n+                currentThread.noninheritableScopeLocalBindings = nonInheritables;\n+                currentThread.inheritableScopeLocalBindings = inheritables;\n+                Cache.invalidate(primaryBits | secondaryBits);\n@@ -169,2 +252,3 @@\n-         * Runs a value-returning operation with this snapshot of inheritable\n-         * scoped variables.\n+         * Runs a value-returning operation with this some ScopeLocals bound to values.\n+         * If the operation terminates with an exception {@code e}, apply {@code handler}\n+         * to {@code e} and return the result.\n@@ -173,0 +257,1 @@\n+         * @param handler a function to be applied if the operation completes with an exception\n@@ -175,1 +260,0 @@\n-         * @throws Exception if the operation completes with an exception\n@@ -177,4 +261,2 @@\n-        public <R> R callWithSnapshot(Callable<R> op) throws Exception {\n-            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-            var cache = Thread.scopeLocalCache();\n-            Cache.invalidate();\n+        public final <R> R callOrElse(Callable<R> op,\n+                                      Function<? super Exception, ? extends R> handler) {\n@@ -182,2 +264,21 @@\n-                Thread.currentThread().inheritableScopeLocalBindings = this;\n-                return op.call();\n+                return call(op);\n+            } catch (Exception e) {\n+                return handler.apply(e);\n+            }\n+        }\n+\n+        \/**\n+         * Runs an operation with some ScopeLocals bound to our values.\n+         * Code executed by the operation can use the {@link #get()} method to\n+         * get the value of the variables. The variables revert to their previous values or\n+         * becomes {@linkplain #isBound() unbound} when the operation completes.\n+         *\n+         * @param op    the operation to run\n+         *\/\n+        public final void run(Runnable op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(primaryBits | secondaryBits);\n+            var inheritables = addScopeLocalBindings(this.inheritables, primaryBits,true);\n+            var nonInheritables = addScopeLocalBindings(this.nonInheritables, primaryBits,false);\n+            try {\n+                op.run();\n@@ -185,2 +286,15 @@\n-                Thread.currentThread().inheritableScopeLocalBindings = prev;\n-                Thread.setScopeLocalCache(cache);\n+                Thread currentThread = Thread.currentThread();\n+                currentThread.noninheritableScopeLocalBindings = nonInheritables;\n+                currentThread.inheritableScopeLocalBindings = inheritables;\n+                Cache.invalidate(primaryBits | secondaryBits);\n+            }\n+        }\n+\n+        \/*\n+         * Add a list of bindings to the current Thread's set of bound values.\n+         *\/\n+        private final static Snapshot addScopeLocalBindings(SingleBinding bindings, short primaryBits, boolean isInheritable) {\n+            Snapshot prev = getScopeLocalBindings(isInheritable);\n+            if (bindings != null) {\n+                var b = new Snapshot(bindings, prev, primaryBits);\n+                ScopeLocal.setScopeLocalBindings(b, isInheritable);\n@@ -188,0 +302,94 @@\n+            return prev;\n+        }\n+    }\n+\n+    \/**\n+     * Creates a binding for a ScopeLocal instance.\n+     * That {@link Carrier} may be used later to invoke a {@link Callable} or\n+     * {@link Runnable} instance. More bindings may be added to the {@link Carrier}\n+     * by the {@link Carrier#where(ScopeLocal, Object)} method.\n+     *\n+     * @param key the ScopeLocal to bind\n+     * @param value The value to bind it to\n+     * @param <T> the type of the ScopeLocal\n+     * @return A Carrier instance that contains one binding, that of key and value\n+     *\/\n+    public static <T> Carrier where(ScopeLocal<T> key, T value) {\n+        \/\/ This could be made more efficient by not creating the Carrier instance.\n+        return Carrier.of(key, value);\n+    }\n+\n+    \/**\n+     * Creates a binding for a ScopeLocal instance and runs a value-returning\n+     * operation with that bound ScopeLocal.\n+     * @param key the ScopeLocal to bind\n+     * @param value The value to bind it to\n+     * @param <T> the type of the ScopeLocal\n+     * @param <U> the type of the Result\n+     * @param op the operation to call\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public static <T, U> U where(ScopeLocal<T> key, T value, Callable<U> op) throws Exception {\n+        \/\/ This could be made more efficient by not creating the Carrier instance.\n+        return where(key, value).call(op);\n+    }\n+\n+    \/**\n+     * Creates a binding for a ScopeLocal instance and runs an\n+     * operation with that bound ScopeLocal.\n+     * @param key the ScopeLocal to bind\n+     * @param value The value to bind it to\n+     * @param <T> the type of the ScopeLocal\n+     * @param op the operation to run\n+     *\/\n+    public static <T> void where(ScopeLocal<T> key, T value, Runnable op) {\n+        where(key, value).run(op);\n+    }\n+\n+    \/**\n+     * Runs a value-returning operation with a snapshot of inheritable\n+     * scoped variables.\n+     *\n+     * @param op the operation to run\n+     * @param s the Snapshot. May be null.\n+     * @param <R> the type of the result of the function\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public static <R> R callWithSnapshot(Callable<R> op, Snapshot s) throws Exception {\n+        var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+        if (prev == s) {\n+            return op.call();\n+        }\n+        var cache = Thread.scopeLocalCache();\n+        Cache.invalidate();\n+        try {\n+            Thread.currentThread().inheritableScopeLocalBindings = s;\n+            return op.call();\n+        } finally {\n+            Thread.currentThread().inheritableScopeLocalBindings = prev;\n+            Thread.setScopeLocalCache(cache);\n+        }\n+    }\n+\n+    \/**\n+     * Runs an operation with this snapshot of inheritable scoped variables.\n+     *\n+     * @param op the operation to run\n+     * @param s the Snapshot. May be null.\n+     *\/\n+    public static void runWithSnapshot(Runnable op, Snapshot s) {\n+        var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+        if (prev == s) {\n+            op.run();\n+            return;\n+        }\n+        var cache = Thread.scopeLocalCache();\n+        Cache.invalidate();\n+        try {\n+            Thread.currentThread().inheritableScopeLocalBindings = s;\n+            op.run();\n+        } finally {\n+            Thread.currentThread().inheritableScopeLocalBindings = prev;\n+            Thread.setScopeLocalCache(cache);\n@@ -221,5 +429,23 @@\n-    private Snapshot scopeLocalBindings() {\n-        Thread currentThread = Thread.currentThread();\n-        return isInheritable\n-                ? currentThread.inheritableScopeLocalBindings\n-                : currentThread.noninheritableScopeLocalBindings;\n+    \/**\n+     * Returns the value of the variable.\n+     * @return the value of the variable\n+     * @throws NoSuchElementException if the variable is not bound (exception is TBD)\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = Thread.scopeLocalCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.TABLE_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.TABLE_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n@@ -228,6 +454,8 @@\n-    private void setScopeLocalBindings(Snapshot bindings) {\n-        Thread currentThread = Thread.currentThread();\n-        if (isInheritable) {\n-            currentThread.inheritableScopeLocalBindings = bindings;\n-        } else {\n-            currentThread.noninheritableScopeLocalBindings = bindings;\n+    @SuppressWarnings(\"unchecked\")\n+    private T slowGet() {\n+        var bindings = scopeLocalBindings();\n+        if (bindings == null)\n+            throw new NoSuchElementException();\n+        var value =  bindings.find(this);\n+        if (value == Snapshot.NIL) {\n+            throw new NoSuchElementException();\n@@ -235,0 +463,2 @@\n+        Cache.put(this, value);\n+        return (T)value;\n@@ -300,11 +530,5 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private T slowGet() {\n-        var bindings = scopeLocalBindings();\n-        if (bindings != null) {\n-            for (var b = bindings; b != null; b = b.prev) {\n-                if (b.getKey() == this) {\n-                    return (T) b.get();\n-                }\n-            }\n-        }\n-        throw new NoSuchElementException();\n+    private static Snapshot getScopeLocalBindings(boolean isInheritable) {\n+        Thread currentThread = Thread.currentThread();\n+        return isInheritable\n+                ? currentThread.inheritableScopeLocalBindings\n+                : currentThread.noninheritableScopeLocalBindings;\n@@ -313,21 +537,6 @@\n-    \/**\n-     * Returns the value of the variable.\n-     * @return the value of the variable\n-     * @throws NoSuchElementException if the variable is not bound (exception is TBD)\n-     *\/\n-    @ForceInline\n-    @SuppressWarnings(\"unchecked\")\n-    public T get() {\n-        Object[] objects;\n-        if ((objects = Thread.scopeLocalCache()) != null) {\n-            \/\/ This code should perhaps be in class Cache. We do it\n-            \/\/ here because the generated code is small and fast and\n-            \/\/ we really want it to be inlined in the caller.\n-            int n = (hash & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n+    private static void setScopeLocalBindings(Snapshot bindings, boolean isInheritable) {\n+        Thread currentThread = Thread.currentThread();\n+        if (isInheritable) {\n+            currentThread.inheritableScopeLocalBindings = bindings;\n+        } else {\n+            currentThread.noninheritableScopeLocalBindings = bindings;\n@@ -335,1 +544,0 @@\n-        return slowGet();\n@@ -338,21 +546,19 @@\n-    \/**\n-     * Runs an operation with this variable bound to the given value. Code\n-     * executed by the operation can use the {@link #get()} method to get the\n-     * value of the variable. The variable reverts to its previous value or\n-     * becomes {@linkplain #isBound() unbound} when the operation completes.\n-     *\n-     * @param value the value for the variable, can be null\n-     * @param op the operation to run\n-     *\/\n-    public void runWithBinding(T value, Runnable op) {\n-        Objects.requireNonNull(op);\n-        Snapshot top = scopeLocalBindings();\n-        Cache.update(this, value);\n-        try {\n-            setScopeLocalBindings(new Snapshot(this, value, top));\n-            op.run();\n-        } finally {\n-            \/\/ assert(top == Thread.currentThread().scopeLocalBindings.prev);\n-            setScopeLocalBindings(top);\n-            Cache.remove(this);\n-        }\n+    private Snapshot scopeLocalBindings() {\n+        return getScopeLocalBindings(isInheritable);\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes are\n+    \/\/ different.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while ((x & Cache.TABLE_MASK)\n+                == ((x >>> Cache.INDEX_BITS) & Cache.TABLE_MASK));\n+        return (nextKey = x);\n@@ -362,4 +568,2 @@\n-     * Runs a value-returning operation with this variable bound to the given\n-     * value. Code executed by the operation can use the {@link #get()} method to\n-     * get the value of the variable. The variable reverts to its previous value or\n-     * becomes {@linkplain #isBound() unbound} when the operation completes.\n+     * Returns a \"snapshot\" of the inheritable scoped variables that are currently\n+     * bound.\n@@ -367,5 +571,4 @@\n-     * @param value the value for the variable, can be null\n-     * @param op the operation to run\n-     * @param <R> the type of the result of the function\n-     * @return the result\n-     * @throws Exception if the operation completes with an exception\n+     * <p>This snapshot may be capured at any time. It is inteneded to be used\n+     * in circumstances where values may be shared by sub-tasks.\n+     *\n+     * @return a \"snapshot\" of the currently-bound inheritable scoped variables. May be null.\n@@ -373,10 +576,23 @@\n-    public <R> R callWithBinding(T value, Callable<R> op) throws Exception {\n-        Objects.requireNonNull(op);\n-        Snapshot top = scopeLocalBindings();\n-        Cache.update(this, value);\n-        try {\n-            setScopeLocalBindings(new Snapshot(this, value, top));\n-            return op.call();\n-        } finally {\n-            setScopeLocalBindings(top);\n-            Cache.remove(this);\n+    public static Snapshot snapshot() {\n+        return Thread.currentThread().inheritableScopeLocalBindings;\n+    }\n+\n+    \/\/ An immutable object that represents the binding of a single value\n+    \/\/ to a single key.\n+    static final class SingleBinding {\n+        final ScopeLocal<?> key;\n+        final Object value;\n+        final SingleBinding prev;\n+\n+        SingleBinding(ScopeLocal<?> key, Object value, SingleBinding prev) {\n+            this.value = key.type.cast(value);\n+            this.key = key;\n+            this.prev = prev;\n+        }\n+\n+        final Object get() {\n+            return value;\n+        }\n+\n+        final ScopeLocal<?> getKey() {\n+            return key;\n@@ -387,1 +603,1 @@\n-    \/\/ is called, we record the result of the lookup in this per-thread cache\n+    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n@@ -394,0 +610,8 @@\n+        static final int primaryIndex(ScopeLocal<?> key) {\n+            return key.hash & TABLE_MASK;\n+        }\n+\n+        static final int secondaryIndex(ScopeLocal<?> key) {\n+            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        }\n+\n@@ -395,2 +619,4 @@\n-            if (Thread.scopeLocalCache() == null) {\n-                Thread.setScopeLocalCache(new Object[TABLE_SIZE * 2]);\n+            Object[] theCache = Thread.scopeLocalCache();\n+            if (theCache == null) {\n+                theCache = new Object[TABLE_SIZE * 2];\n+                Thread.setScopeLocalCache(theCache);\n@@ -398,1 +624,9 @@\n-            int victim = chooseVictim(Thread.currentCarrierThread(), key.hashCode());\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            Thread thread = Thread.currentThread();\n+            int k1 = primaryIndex(key);\n+            int k2 = secondaryIndex(key);\n+            int tmp = chooseVictim(thread);\n+            int victim = tmp == 0 ? k1 : k2;\n+            int other = tmp == 0 ? k2 : k1;\n@@ -400,0 +634,3 @@\n+            if (getKey(theCache, other) == key) {\n+                setKey(theCache, other, null);\n+            }\n@@ -405,1 +642,0 @@\n-\n@@ -420,1 +656,0 @@\n-\n@@ -437,2 +672,1 @@\n-        private static Object getKey(Object[] objs, long hash) {\n-            int n = (int) (hash & TABLE_MASK);\n+        private static Object getKey(Object[] objs, int n) {\n@@ -442,2 +676,1 @@\n-        private static void setKey(Object[] objs, long hash, Object key) {\n-            int n = (int) (hash & TABLE_MASK);\n+        private static void setKey(Object[] objs, int n, Object key) {\n@@ -447,6 +680,3 @@\n-        private static int chooseVictim(Thread thread, int hash) {\n-            \/\/ Update the cache to replace one entry with the value we just looked up.\n-            \/\/ Each value can be in one of two possible places in the cache.\n-            \/\/ Pick a victim at (pseudo-)random.\n-            int k1 = hash & TABLE_MASK;\n-            int k2 = (hash >> INDEX_BITS) & TABLE_MASK;\n+        \/\/ Return either 0 or 1, at pseudo-random. This chooses either the\n+        \/\/ primary or secondary cache slot.\n+        private static int chooseVictim(Thread thread) {\n@@ -455,1 +685,1 @@\n-            return (tmp & 1) == 0 ? k1 : k2;\n+            return tmp & 1;\n@@ -461,18 +691,0 @@\n-    }\n-\n-    private static int nextKey = 0xf0f0_f0f0;\n-\n-    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n-    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n-    \/\/ and the next n bits as cache indexes, so we make sure that those indexes are\n-    \/\/ different.\n-    private static synchronized int generateKey() {\n-        int x = nextKey;\n-        do {\n-            x ^= x >>> 12;\n-            x ^= x << 9;\n-            x ^= x >>> 23;\n-        } while ((x & Cache.TABLE_MASK)\n-                == ((x >>> Cache.INDEX_BITS) & Cache.TABLE_MASK));\n-        return (nextKey = x);\n-    }\n@@ -480,11 +692,13 @@\n-    \/**\n-     * Returns a \"snapshot\" of the inheritable scoped variables that are currently\n-     * bound.\n-     *\n-     * <p>This snapshot may be capured at any time. It is inteneded to be used\n-     * in circumstances where values may be shared by sub-tasks.\n-     *\n-     * @return a \"snapshot\" of the currently-bound inheritable scoped variables. May be null.\n-     *\/\n-    public static Snapshot snapshot() {\n-        return Thread.currentThread().inheritableScopeLocalBindings;\n+        \/\/ Null a set of cache entries, indicated by the 1-bits given\n+        static void invalidate(int toClearBits) {\n+            assert(toClearBits == (short)toClearBits);\n+            Object[] objects;\n+            if ((objects = Thread.scopeLocalCache()) != null) {\n+                for (short bits = (short)toClearBits;\n+                     bits != 0; ) {\n+                    int index = Integer.numberOfTrailingZeros(bits);\n+                    setKey(objects, index, null);\n+                    bits &= ~1 << index;\n+                }\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopeLocal.java","additions":387,"deletions":173,"binary":false,"changes":560,"status":"modified"},{"patch":"@@ -489,2 +489,2 @@\n-            if (snapshot != null) {\n-                snapshot.runWithSnapshot(() -> tryFire(ASYNC));\n+            if (snapshot != ScopeLocal.snapshot()) {\n+                ScopeLocal.runWithSnapshot(() -> tryFire(ASYNC), snapshot);\n@@ -496,5 +496,1 @@\n-            if (snapshot != null) {\n-                snapshot.runWithSnapshot(() -> tryFire(ASYNC));\n-            } else {\n-                tryFire(ASYNC);\n-            }\n+            run();\n@@ -503,1 +499,2 @@\n-        public final Void getRawResult()       { return null; }\n+\n+    public final Void getRawResult()       { return null; }\n@@ -1836,2 +1833,2 @@\n-            if (snapshot != null) {\n-                snapshot.runWithSnapshot(this::doRun);\n+            if (snapshot != ScopeLocal.snapshot()) {\n+                ScopeLocal.runWithSnapshot(this::doRun, snapshot);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -756,2 +756,2 @@\n-        if (snapshot != null) {\n-            snapshot.runWithSnapshot(this::compute);\n+        if (snapshot != ScopeLocal.snapshot()) {\n+            ScopeLocal.runWithSnapshot(this::compute, snapshot);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CountedCompleter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -307,0 +307,6 @@\n+        \/\/ Ideally we should also clear the Thread's ScopedCache, but it is\n+        \/\/ in the VM-internal JavaThread structure. This method is called so\n+        \/\/ early in the lifetime of a ForkJoinPool thread that we don't expect\n+        \/\/ any ScopeLocals to have yet been bound by this thread, so the\n+        \/\/ ScopedCache should be empty at this point.\n+        U.putReference(thread, INHERITABLESCOPELOCALBINDINGS, null);\n@@ -389,1 +395,3 @@\n-        = U.objectFieldOffset(Thread.class, \"inheritableThreadLocals\");\n+            = U.objectFieldOffset(Thread.class, \"inheritableThreadLocals\");\n+    private static final long INHERITABLESCOPELOCALBINDINGS\n+            = U.objectFieldOffset(Thread.class, \"inheritableScopeLocalBindings\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+        SCOPE_LOCALS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n- * @run testng Basic\n+ * @compile --enable-preview -source ${jdk.version} Basic.java\n+ * @run testng\/othervm --enable-preview Basic\n@@ -61,1 +62,1 @@\n-        name.runWithBinding(\"fred\", () -> {\n+        ScopeLocal.where(name, \"fred\", () -> {\n@@ -72,1 +73,1 @@\n-        name.runWithBinding(\"fred\", () -> {\n+        ScopeLocal.where(name, \"fred\", () -> {\n@@ -83,1 +84,1 @@\n-        name.runWithBinding(\"fred\", () -> {\n+        ScopeLocal.where(name, \"fred\", () -> {\n@@ -92,1 +93,1 @@\n-        name.runWithBinding(\"fred\", () -> {\n+        ScopeLocal.where(name, \"fred\", () -> {\n@@ -96,1 +97,1 @@\n-            name.runWithBinding(\"joe\", () -> {\n+            ScopeLocal.where(name, \"joe\", () -> {\n@@ -113,1 +114,1 @@\n-        name.runWithBinding(null, () -> {\n+        ScopeLocal.where(name, null, () -> {\n@@ -122,1 +123,1 @@\n-        name.runWithBinding(\"fred\", () -> {\n+        ScopeLocal.where(name, \"fred\", () -> {\n@@ -126,1 +127,1 @@\n-            name.runWithBinding(null, () -> {\n+            ScopeLocal.where(name, null, () -> {\n@@ -143,1 +144,1 @@\n-        name.runWithBinding(\"fred\", () -> {\n+        ScopeLocal.where(name, \"fred\", () -> {\n@@ -152,1 +153,1 @@\n-        name.runWithBinding(\"fred\", () -> {\n+        ScopeLocal.where(name, \"fred\", () -> {\n@@ -156,1 +157,1 @@\n-            name.runWithBinding(\"joe\", () -> {\n+            ScopeLocal.where(name, \"joe\", () -> {\n@@ -173,1 +174,1 @@\n-        name.runWithBinding(null, () -> {\n+        ScopeLocal.where(name, null, () -> {\n@@ -182,1 +183,1 @@\n-        name.runWithBinding(\"fred\", () -> {\n+        ScopeLocal.where(name, \"fred\", () -> {\n@@ -186,1 +187,1 @@\n-            name.runWithBinding(null, () -> {\n+            ScopeLocal.where(name, null, () -> {\n@@ -204,1 +205,1 @@\n-        name.runWithBinding(\"fred\", null);\n+        ScopeLocal.where(name, \"fred\", (Runnable)null);\n@@ -212,1 +213,1 @@\n-        int result = name.callWithBinding(\"fred\", () -> {\n+        int result = ScopeLocal.where(name, \"fred\", () -> {\n@@ -224,1 +225,1 @@\n-        int result1 = name.callWithBinding(\"fred\", () -> {\n+        int result1 = ScopeLocal.where(name, \"fred\", () -> {\n@@ -230,1 +231,1 @@\n-            int result2 = name.callWithBinding(\"joe\", () -> {\n+            int result2 = ScopeLocal.where(name, \"joe\", () -> {\n@@ -248,1 +249,1 @@\n-        int result = name.callWithBinding(null, () -> {\n+        int result = ScopeLocal.where(name, null, () -> {\n@@ -259,1 +260,1 @@\n-        int result1 = name.callWithBinding(\"fred\", () -> {\n+        int result1 = ScopeLocal.where(name, \"fred\", () -> {\n@@ -265,1 +266,1 @@\n-            int result2 = name.callWithBinding(null, () -> {\n+            int result2 = ScopeLocal.where(name, null, () -> {\n@@ -282,1 +283,1 @@\n-        int result = name.callWithBinding(\"fred\", () -> {\n+        int result = ScopeLocal.where(name, \"fred\", () -> {\n@@ -294,1 +295,1 @@\n-        int result1 = name.callWithBinding(\"fred\", () -> {\n+        int result1 = ScopeLocal.where(name, \"fred\", () -> {\n@@ -300,1 +301,1 @@\n-            int result2 = name.callWithBinding(\"joe\", () -> {\n+            int result2 = ScopeLocal.where(name, \"joe\", () -> {\n@@ -318,1 +319,1 @@\n-        int result = name.callWithBinding(null, () -> {\n+        int result = ScopeLocal.where(name, null, () -> {\n@@ -329,1 +330,1 @@\n-        int result1 = name.callWithBinding(\"fred\", () -> {\n+        int result1 = ScopeLocal.where(name, \"fred\", () -> {\n@@ -335,1 +336,1 @@\n-            int result2 = name.callWithBinding(null, () -> {\n+            int result2 = ScopeLocal.where(name, null, () -> {\n@@ -353,1 +354,1 @@\n-        name.callWithBinding(\"fred\", null);\n+        ScopeLocal.where(name, \"fred\", (Callable)null);\n@@ -361,1 +362,1 @@\n-        name.callWithBinding(\"fred\", () -> {\n+        ScopeLocal.where(name, \"fred\", () -> {\n@@ -365,1 +366,1 @@\n-            name.runWithBinding(\"joe\", thread::start);\n+            ScopeLocal.where(name, \"joe\", thread::start);\n@@ -378,1 +379,1 @@\n-        var snapshot = name.callWithBinding(\"aristotle\", () -> ScopeLocal.snapshot());\n+        var snapshot = ScopeLocal.where(name, \"aristotle\", () -> ScopeLocal.snapshot());\n@@ -381,1 +382,1 @@\n-        occupation.callWithBinding(\"undertaker\", () -> {\n+        ScopeLocal.where(occupation, \"undertaker\", () -> {\n@@ -396,1 +397,1 @@\n-        var snapshot = name.callWithBinding(\"aristotle\", () -> ScopeLocal.snapshot());\n+        var snapshot = ScopeLocal.where(name, \"aristotle\", () -> ScopeLocal.snapshot());\n@@ -399,1 +400,1 @@\n-        occupation.callWithBinding(\"undertaker\", () -> {\n+        ScopeLocal.where(occupation, \"undertaker\", () -> {\n@@ -406,1 +407,1 @@\n-        name.callWithBinding(\"joe\", () -> {\n+        ScopeLocal.where(name, \"joe\", () -> {\n@@ -414,1 +415,1 @@\n-            return snapshot == null ? c.call() : snapshot.callWithSnapshot(c);\n+            return ScopeLocal.callWithSnapshot(c, snapshot);\n","filename":"test\/jdk\/java\/lang\/ScopeLocal\/Basic.java","additions":38,"deletions":37,"binary":false,"changes":75,"status":"modified"}]}