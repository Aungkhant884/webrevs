{"files":[{"patch":"@@ -35,1 +35,3 @@\n-  static CodeBlob* cb = CodeCache::find_blob(entry_pc());\n+  static CodeBlob* cb = CodeCache::find_blob_fast(entry_pc());\n+  assert(cb != nullptr, \"\");\n+  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationEntry_aarch64.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+    \/\/ If the caller.is_empty(), i.e. we're freezing into an empty chunk, then we set\n+    \/\/ the chunk's argsize in finalize_freeze and make room for it above the unextended_sp\n@@ -108,0 +110,2 @@\n+      \/\/ If the caller is interpreted, our stackargs are not supposed to overlap with it\n+      \/\/ so we make more room by moving sp down by argsize\n@@ -177,0 +181,3 @@\n+    \/\/ If we're the bottom-most frame frozen in this freeze, the caller might have stayed frozen in the chunk,\n+    \/\/ and its oop-containing fp fixed. We've now just overwritten it, so we must patch it back to its value\n+    \/\/ as read from the chunk.\n@@ -213,0 +220,1 @@\n+    int padding = 0;\n@@ -216,0 +224,1 @@\n+      padding++;\n@@ -222,1 +231,2 @@\n-    \/\/ it's set again later in derelativize_interpreted_frame_metadata, but we need to set the locals now so that we'll have the frame's bottom\n+    \/\/ it's set again later in set_interpreter_frame_bottom, but we need to set the locals now so that\n+    \/\/ we could call ContinuationHelper::InterpretedFrame::frame_bottom\n@@ -224,2 +234,3 @@\n-    assert((int)offset == locals + frame::sender_sp_offset - 1, \"\");\n-    *(intptr_t**)f.addr_at(frame::interpreter_frame_locals_offset) = fp + offset;\n+    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n+    \/\/ derelativize locals\n+    *(intptr_t**)f.addr_at(frame::interpreter_frame_locals_offset) = fp + padding + offset;\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -162,0 +162,6 @@\n+    if (Continuation::is_return_barrier_entry(sender_pc)) {\n+      \/\/ If our sender_pc is the return barrier, then our \"real\" sender is the continuation entry\n+      frame s = Continuation::continuation_bottom_sender(thread, *this, sender_sp);\n+      sender_sp = s.sp();\n+      sender_pc = s.pc();\n+    }\n@@ -450,1 +456,1 @@\n-      Continuation::fix_continuation_bottom_sender(map->thread(), *this, &sender_pc, &unextended_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-      Continuation::fix_continuation_bottom_sender(map->thread(), *this, &sender_pc, &l_sender_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, l_sender_sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6532,0 +6532,1 @@\n+    \/\/ We've succeeded, set sp to the ContinuationEntry\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,3 @@\n-  static CodeBlob* cb = CodeCache::find_blob(entry_pc());\n+  static CodeBlob* cb = CodeCache::find_blob_fast(entry_pc());\n+  assert(cb != nullptr, \"\");\n+  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n","filename":"src\/hotspot\/cpu\/x86\/continuationEntry_x86.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+    \/\/ If the caller.is_empty(), i.e. we're freezing into an empty chunk, then we set\n+    \/\/ the chunk's argsize in finalize_freeze and make room for it above the unextended_sp\n@@ -86,1 +88,1 @@\n-    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ?  ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n+    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n@@ -105,0 +107,2 @@\n+      \/\/ If the caller is interpreted, our stackargs are not supposed to overlap with it\n+      \/\/ so we make more room by moving sp down by argsize\n@@ -175,0 +179,3 @@\n+    \/\/ If we're the bottom-most frame frozen in this freeze, the caller might have stayed frozen in the chunk,\n+    \/\/ and its oop-containing fp fixed. We've now just overwritten it, so we must patch it back to its value\n+    \/\/ as read from the chunk.\n@@ -215,1 +222,2 @@\n-    \/\/ it's set again later in derelativize_interpreted_frame_metadata, but we need to set the locals now so that we'll have the frame's bottom\n+    \/\/ it's set again later in set_interpreter_frame_bottom, but we need to set the locals now so that\n+    \/\/ we could call ContinuationHelper::InterpretedFrame::frame_bottom\n@@ -217,1 +225,2 @@\n-    assert((int)offset == locals + frame::sender_sp_offset - 1, \"\");\n+    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n+    \/\/ derelativize locals\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -154,1 +154,4 @@\n-      Continuation::fix_continuation_bottom_sender(thread, *this, &sender_pc, &sender_sp);\n+      \/\/ If our sender_pc is the return barrier, then our \"real\" sender is the continuation entry\n+      frame s = Continuation::continuation_bottom_sender(thread, *this, sender_sp);\n+      sender_sp = s.sp();\n+      sender_pc = s.pc();\n@@ -470,1 +473,1 @@\n-      Continuation::fix_continuation_bottom_sender(map->thread(), *this, &sender_pc, &unextended_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-      Continuation::fix_continuation_bottom_sender(map->thread(), *this, &sender_pc, &sender_sp);\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1458,4 +1458,1 @@\n-  __ push(rbp);\n-  if (PreserveFramePointer) {\n-    __ mov(rbp, rsp);\n-  }\n+  __ enter();\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -361,3 +361,0 @@\n-  if (f.is_done()) {\n-    return;\n-  }\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+  \/\/ FLAG_HAS_INTERPRETED_FRAMES actually means \"thaw slow because of some content-based chunk condition\"\n+  \/\/ It is set whenever we freeze slow, but generally signifies there might be interpreted\/deoptimized\/stub frames\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,4 @@\n-  return sp() >= stack_size() - argsize();\n+  assert(sp() <= stack_size(), \"\");\n+  assert((sp() == stack_size()) == (sp() >= stack_size() - argsize()),\n+    \"sp: %d size: %d argsize: %d\", sp(), stack_size(), argsize());\n+  return sp() == stack_size();\n@@ -154,2 +157,5 @@\n-inline bool stackChunkOopDesc::has_mixed_frames() const            { return is_flag(FLAG_HAS_INTERPRETED_FRAMES); }\n-inline void stackChunkOopDesc::set_has_mixed_frames(bool value)    { set_flag(FLAG_HAS_INTERPRETED_FRAMES, value); }\n+inline bool stackChunkOopDesc::has_mixed_frames() const { return is_flag(FLAG_HAS_INTERPRETED_FRAMES); }\n+inline void stackChunkOopDesc::set_has_mixed_frames(bool value) {\n+  assert((flags() & ~FLAG_HAS_INTERPRETED_FRAMES) == 0, \"other flags should not be set\");\n+  set_flag(FLAG_HAS_INTERPRETED_FRAMES, value);\n+}\n@@ -310,2 +316,2 @@\n-  assert(to >= start_address(), \"\");\n-  assert(to + size <= end_address(), \"\");\n+  assert(to >= start_address(), \"Chunk underflow\");\n+  assert(to + size <= end_address(), \"Chunk overflow\");\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -283,17 +283,13 @@\n-bool Continuation::fix_continuation_bottom_sender(JavaThread* thread, const frame& callee,\n-                                                  address* sender_pc, intptr_t** sender_sp) {\n-  if (thread != nullptr && is_return_barrier_entry(*sender_pc)) {\n-    ContinuationEntry* ce = get_continuation_entry_for_sp(thread,\n-          callee.is_interpreted_frame() ? callee.interpreter_frame_last_sp() : callee.unextended_sp());\n-    assert(ce != nullptr, \"callee.unextended_sp(): \" INTPTR_FORMAT, p2i(callee.unextended_sp()));\n-\n-    log_develop_debug(continuations)(\"fix_continuation_bottom_sender: \"\n-                                  \"[\" JLONG_FORMAT \"] [%d]\", java_tid(thread), thread->osthread()->thread_id());\n-    log_develop_trace(continuations)(\"sender_pc: \" INTPTR_FORMAT \" -> \" INTPTR_FORMAT, p2i(*sender_pc), p2i(ce->entry_pc()));\n-    log_develop_trace(continuations)(\"sender_sp: \" INTPTR_FORMAT \" -> \" INTPTR_FORMAT, p2i(*sender_sp), p2i(ce->entry_sp()));\n-\n-    *sender_pc = ce->entry_pc();\n-    *sender_sp = ce->entry_sp();\n-    \/\/ We DO NOT fix FP. It could contain an oop that has changed on the stack, and its location should be OK anyway\n-\n-    return true;\n+frame Continuation::continuation_bottom_sender(JavaThread* thread, const frame& callee, intptr_t* sender_sp) {\n+  assert (thread != nullptr, \"\");\n+  ContinuationEntry* ce = get_continuation_entry_for_sp(thread,\n+        callee.is_interpreted_frame() ? callee.interpreter_frame_last_sp() : callee.unextended_sp());\n+  assert(ce != nullptr, \"callee.unextended_sp(): \" INTPTR_FORMAT, p2i(callee.unextended_sp()));\n+\n+  log_develop_debug(continuations)(\"continuation_bottom_sender: [\" JLONG_FORMAT \"] [%d] callee: \" INTPTR_FORMAT\n+    \" sender_sp: \" INTPTR_FORMAT,\n+    java_tid(thread), thread->osthread()->thread_id(), p2i(callee.sp()), p2i(sender_sp));\n+\n+  frame entry = ce->to_frame();\n+  if (callee.is_interpreted_frame()) {\n+    entry.set_sp(sender_sp); \/\/ sp != unextended_sp\n@@ -301,1 +297,1 @@\n-  return false;\n+  return entry;\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-  static bool fix_continuation_bottom_sender(JavaThread* thread, const frame& callee, address* sender_pc, intptr_t** sender_sp);\n+  static frame continuation_bottom_sender(JavaThread* thread, const frame& callee, intptr_t* sender_sp);\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,0 +107,1 @@\n+    assert(cb != nullptr, \"sp: \" INTPTR_FORMAT \" pc: \" INTPTR_FORMAT, p2i(sp), p2i(pc));\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -175,0 +175,12 @@\n+#define assert_pfl(p, ...) \\\n+do {                                           \\\n+  if (!(p)) {                                  \\\n+    JavaThread* t = JavaThread::active();      \\\n+    if (t->has_last_Java_frame()) {            \\\n+      tty->print_cr(\"assert(\" #p \") failed:\"); \\\n+      t->print_frame_layout();                 \\\n+    }                                          \\\n+  }                                            \\\n+  vmassert(p, __VA_ARGS__);                    \\\n+} while(0)\n+\n@@ -177,0 +189,1 @@\n+#define assert_pfl(p, ...)\n@@ -337,1 +350,1 @@\n-  bool _barriers;\n+  bool _barriers; \/\/ only set when we allocate a chunk\n@@ -419,0 +432,8 @@\n+\n+#ifdef ASSERT\n+  bool is_empty(stackChunkOop chunk) {\n+    \/\/ during freeze, the chunk is in an intermediate state (after setting the chunk's argsize but before setting its\n+    \/\/ ultimate sp) so we use this instead of stackChunkOopDesc::is_empty\n+    return chunk->sp() >= chunk->stack_size() - chunk->argsize();\n+  }\n+#endif\n@@ -443,1 +464,0 @@\n-  _bottom_address = _cont.entrySP() - _cont.argsize();\n@@ -448,0 +468,1 @@\n+  _bottom_address = _cont.entrySP() - _cont.argsize();\n@@ -463,1 +484,2 @@\n-  assert(StubRoutines::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n+  static const int doYield_stub_frame_size = frame::metadata_words;\n+  assert(StubRoutines::cont_doYield_stub()->frame_size() == doYield_stub_frame_size, \"\");\n@@ -466,1 +488,1 @@\n-  _cont_stack_top    = frame_sp + frame::metadata_words; \/\/ we add metadata_words to skip the doYield stub frame\n+  _cont_stack_top    = frame_sp + doYield_stub_frame_size; \/\/ we don't freeze the doYield stub frame\n@@ -540,0 +562,1 @@\n+\n@@ -541,0 +564,5 @@\n+\n+  \/\/ argsize can be nonzero if we have a caller, but the caller could be in a non-empty parent chunk,\n+  \/\/ so we subtract it only if we overlap with the caller, i.e. the current chunk isn't empty.\n+  \/\/ Consider leaving the chunk's argsize set when emptying it and removing the following branch,\n+  \/\/ although that would require changing stackChunkOopDesc::is_empty\n@@ -545,1 +573,2 @@\n-  bool available = chunk_sp - frame::metadata_words >= total_size_needed;\n+  int chunk_free_room = chunk_sp - frame::metadata_words;\n+  bool available = chunk_free_room >= total_size_needed;\n@@ -707,1 +736,1 @@\n-  frame caller;\n+  frame caller; \/\/ the frozen caller in the chunk\n@@ -789,1 +818,5 @@\n-  if (FKind::frame_bottom(f) >= _bottom_address - 1) { \/\/ sometimes there's space after enterSpecial\n+  assert(FKind::frame_bottom(f) <= _bottom_address, \"\");\n+\n+  \/\/ We don't use FKind::frame_bottom(f) == _bottom_address because on x64 there's sometimes an extra word between\n+  \/\/ enterSpecial and an interpreted frame\n+  if (FKind::frame_bottom(f) >= _bottom_address - 1) {\n@@ -805,1 +838,1 @@\n-    f.print_on(&ls);\n+    f.print_value_on(&ls, nullptr);\n@@ -849,0 +882,2 @@\n+      StackChunkFrameStream<ChunkFrames::Mixed> last(chunk);\n+      unextended_sp = chunk->to_offset(StackChunkFrameStream<ChunkFrames::Mixed>(chunk).unextended_sp());\n@@ -850,5 +885,0 @@\n-      unextended_sp = chunk->sp();\n-      if (top_interpreted) {\n-        StackChunkFrameStream<ChunkFrames::Mixed> last(chunk);\n-        unextended_sp += last.unextended_sp() - last.sp(); \/\/ can be negative (-1), often with lambda forms\n-      }\n@@ -870,2 +900,4 @@\n-    \/\/ _barriers can be set to true by an allocation in freeze_fast, in which case the chunk is available\n-  assert(!_barriers || (unextended_sp >= _freeze_size && chunk->is_empty()),\n+  \/\/ _barriers can be set to true by an allocation in freeze_fast, in which case the chunk is available\n+  bool allocated_old_in_freeze_fast = _barriers;\n+  assert(!allocated_old_in_freeze_fast || (unextended_sp >= _freeze_size && chunk->is_empty()),\n+    \"Chunk allocated in freeze_fast is of insufficient size \"\n@@ -873,0 +905,1 @@\n+  assert(!allocated_old_in_freeze_fast || (!UseZGC && !UseG1GC), \"Unexpected allocation\");\n@@ -875,2 +908,2 @@\n-  if (unextended_sp < _freeze_size || chunk->is_gc_mode() || (!_barriers && chunk->requires_barriers())) {\n-    \/\/ ALLOCATION\n+  if (unextended_sp < _freeze_size || chunk->is_gc_mode() || (!allocated_old_in_freeze_fast && chunk->requires_barriers())) {\n+    \/\/ ALLOCATE NEW CHUNK\n@@ -903,1 +936,1 @@\n-    assert(chunk->is_empty(), \"\");\n+    assert(is_empty(chunk), \"\");\n@@ -905,0 +938,1 @@\n+    \/\/ REUSE EXISTING CHUNK\n@@ -914,0 +948,2 @@\n+  assert(!chunk->is_gc_mode(), \"\");\n+  assert(!chunk->has_bitmap(), \"\");\n@@ -917,1 +953,1 @@\n-  assert(!_barriers || chunk->is_empty(), \"\");\n+  assert(!_barriers || is_empty(chunk), \"\");\n@@ -919,3 +955,2 @@\n-  assert(!chunk->has_bitmap(), \"\");\n-  assert(!chunk->is_empty() || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).is_done(), \"\");\n-  assert(!chunk->is_empty() || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame().is_empty(), \"\");\n+  assert(!is_empty(chunk) || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).is_done(), \"\");\n+  assert(!is_empty(chunk) || StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame().is_empty(), \"\");\n@@ -936,0 +971,1 @@\n+  \/\/ The topmost existing frame in the chunk; or an empty frame if the chunk is empty\n@@ -962,0 +998,2 @@\n+    \/\/ If we're the bottom frame, we need to replace the return barrier with the real\n+    \/\/ caller's pc.\n@@ -963,1 +1001,1 @@\n-    assert((last_pc == nullptr) == _cont.tail()->is_empty(), \"\");\n+    assert((last_pc == nullptr) == is_empty(_cont.tail()), \"\");\n@@ -1003,1 +1041,2 @@\n-  intptr_t* const frame_sp = ContinuationHelper::InterpretedFrame::frame_top(f, callee_argsize, callee_interpreted);\n+  \/\/ The frame's top never includes the stack arguments to the callee\n+  intptr_t* const frame_top = ContinuationHelper::InterpretedFrame::frame_top(f, callee_argsize, callee_interpreted);\n@@ -1007,1 +1046,1 @@\n-  const int fsize = f.fp() + frame::metadata_words + locals - frame_sp;\n+  const int fsize = f.fp() + frame::metadata_words + locals - frame_top;\n@@ -1009,1 +1048,1 @@\n-  DEBUG_ONLY(verify_frame_top(f, frame_sp));\n+  DEBUG_ONLY(verify_frame_top(f, frame_top));\n@@ -1024,0 +1063,1 @@\n+  assert(!caller.is_empty() || bottom, \"\");\n@@ -1030,2 +1070,2 @@\n-  intptr_t* heap_sp = ContinuationHelper::InterpretedFrame::frame_top(hf, callee_argsize, callee_interpreted);\n-  assert(ContinuationHelper::InterpretedFrame::frame_bottom(hf) == heap_sp + fsize, \"\");\n+  intptr_t* heap_top = ContinuationHelper::InterpretedFrame::frame_top(hf, callee_argsize, callee_interpreted);\n+  assert(ContinuationHelper::InterpretedFrame::frame_bottom(hf) == heap_top + fsize, \"\");\n@@ -1036,2 +1076,2 @@\n-  copy_to_chunk(frame_sp, heap_sp, fsize - locals); \/\/ copy rest\n-  assert(!bottom || !caller.is_interpreted_frame() || (heap_sp + fsize) == (caller.unextended_sp() + argsize), \"\");\n+  copy_to_chunk(frame_top, heap_top, fsize - locals); \/\/ copy rest\n+  assert(!bottom || !caller.is_interpreted_frame() || (heap_top + fsize) == (caller.unextended_sp() + argsize), \"\");\n@@ -1054,1 +1094,2 @@\n-  intptr_t* const frame_sp = ContinuationHelper::CompiledFrame::frame_top(f, callee_argsize, callee_interpreted);\n+  \/\/ The frame's top never includes the stack arguments to the callee\n+  intptr_t* const frame_top = ContinuationHelper::CompiledFrame::frame_top(f, callee_argsize, callee_interpreted);\n@@ -1056,1 +1097,1 @@\n-  const int fsize = ContinuationHelper::CompiledFrame::frame_bottom(f) + argsize - frame_sp;\n+  const int fsize = ContinuationHelper::CompiledFrame::frame_bottom(f) + argsize - frame_top;\n@@ -1071,0 +1112,1 @@\n+  assert(!caller.is_empty() || bottom, \"\");\n@@ -1076,1 +1118,1 @@\n-  intptr_t* heap_sp = ContinuationHelper::CompiledFrame::frame_top(hf, callee_argsize, callee_interpreted);\n+  intptr_t* heap_top = ContinuationHelper::CompiledFrame::frame_top(hf, callee_argsize, callee_interpreted);\n@@ -1078,2 +1120,2 @@\n-  copy_to_chunk(frame_sp, heap_sp, fsize);\n-  assert(!bottom || !caller.is_compiled_frame() || (heap_sp + fsize) == (caller.unextended_sp() + argsize), \"\");\n+  copy_to_chunk(frame_top, heap_top, fsize);\n+  assert(!bottom || !caller.is_compiled_frame() || (heap_top + fsize) == (caller.unextended_sp() + argsize), \"\");\n@@ -1095,1 +1137,1 @@\n-  intptr_t* const frame_sp = ContinuationHelper::StubFrame::frame_top(f, 0, 0);\n+  intptr_t* const frame_top = ContinuationHelper::StubFrame::frame_top(f, 0, 0);\n@@ -1099,1 +1141,1 @@\n-    f.cb()->name(), _freeze_size, fsize, p2i(frame_sp), p2i(frame_sp+fsize));\n+    f.cb()->name(), _freeze_size, fsize, p2i(frame_top), p2i(frame_top+fsize));\n@@ -1127,2 +1169,2 @@\n-  intptr_t* heap_sp = ContinuationHelper::StubFrame::frame_top(hf, 0, 0);\n-  copy_to_chunk(frame_sp, heap_sp, fsize);\n+  intptr_t* heap_top = ContinuationHelper::StubFrame::frame_top(hf, 0, 0);\n+  copy_to_chunk(frame_top, heap_top, fsize);\n@@ -1153,0 +1195,2 @@\n+  \/\/ At this point the chunk is consistent\n+\n@@ -1155,1 +1199,1 @@\n-    \/\/ ParallelGC can allocate objects directly into the old generation.\n+    \/\/ Serial and Parallel GC can allocate objects directly into the old generation.\n@@ -1162,0 +1206,1 @@\n+    \/\/ For objects in the old generation we must maintain the remembered set\n@@ -1184,1 +1229,1 @@\n-  if ((address)&t < t->stack_overflow_state()->stack_overflow_limit()) {\n+  if (os::current_stack_pointer() < t->stack_overflow_state()->stack_overflow_limit()) {\n@@ -1319,0 +1364,2 @@\n+  \/\/ This is done for the sake of the enterSpecial frame\n+  StackWatermarkSet::after_unwind(thread);\n@@ -1381,1 +1428,0 @@\n-    StackWatermarkSet::after_unwind(current);\n@@ -1397,1 +1443,0 @@\n-    StackWatermarkSet::after_unwind(current);\n@@ -1464,1 +1509,1 @@\n-  return size + 200;\n+  return size;\n@@ -1519,1 +1564,1 @@\n-  intptr_t* _top_unextended_sp;\n+  intptr_t* _top_unextended_sp_before_thaw;\n@@ -1531,1 +1576,1 @@\n-    DEBUG_ONLY(_top_unextended_sp = nullptr;)\n+    DEBUG_ONLY(_top_unextended_sp_before_thaw = nullptr;)\n@@ -1617,3 +1662,1 @@\n-    \/\/ \/\/ possibly adds a one-word padding between entrySP and the bottom-most frame's stack args\n-    \/\/ \/\/ The only possible source of misalignment is stack-passed arguments because all compiled\n-    \/\/ \/\/ frames are 16-byte aligned.\n+    \/\/ The only possible source of misalignment is stack-passed arguments b\/c compiled frames are 16-byte aligned.\n@@ -1621,0 +1664,2 @@\n+    \/\/ We're at most one alignment word away from entrySP\n+    assert(_base - 1 <= top() + total_size() + frame::metadata_words, \"missed entry frame\");\n@@ -1622,0 +1667,1 @@\n+\n@@ -1633,18 +1679,0 @@\n-\n-  void patch_return(bool is_last, address entry_pc) {\n-    log_develop_trace(continuations)(\"thaw_fast patching -- sp: \" INTPTR_FORMAT, p2i(sp()));\n-    address pc = !is_last ? StubRoutines::cont_returnBarrier() : entry_pc;\n-    *(address*)(bottom_sp() - frame::sender_sp_ret_address_offset()) = pc;\n-    \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n-\n-    DEBUG_ONLY(address pc2 = *(address*)(bottom_sp() - frame::sender_sp_ret_address_offset());)\n-    assert(is_last ? CodeCache::find_blob(pc2)->as_compiled_method()->method()->is_continuation_enter_intrinsic()\n-                  : pc2 == StubRoutines::cont_returnBarrier(), \"is_last: %d\", is_last);\n-  }\n-  void verify() {\n-    \/\/ We assert we have not overwritten the entry frame, but that we're at most\n-    \/\/ one alignment word away from it.\n-    assert(top() + total_size() <= _base, \"overwritten entry frame\");\n-    assert(_base - 1 <= top() + total_size(), \"missed entry frame\");\n-    assert(argsize() != 0 || top() + total_size() == _base, \"missed entry frame\");\n-  }\n@@ -1689,3 +1717,0 @@\n-  assert(to + size <= _cont.entrySP(), \"\");\n-  _cont.tail()->copy_from_chunk_to_stack(from, to, size);\n-  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n@@ -1694,0 +1719,3 @@\n+  assert(to + size <= _cont.entrySP(), \"overwrote past thawing space\");\n+  _cont.tail()->copy_from_chunk_to_stack(from, to, size);\n+  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n@@ -1751,3 +1779,0 @@\n-  \/\/ Verify that all sizes and addresses are correct before copying\n-  rs.verify();\n-\n@@ -1763,1 +1788,1 @@\n-  rs.patch_return(is_last, _cont.entryPC());\n+  patch_return(rs.bottom_sp(), is_last);\n@@ -1791,1 +1816,1 @@\n-  return _barriers | _cont.tail()->is_gc_mode();\n+  return _barriers || _cont.tail()->is_gc_mode();\n@@ -1812,1 +1837,0 @@\n-  bool last_interpreted = chunk->has_mixed_frames() && Interpreter::contains(chunk->pc());\n@@ -1815,1 +1839,1 @@\n-  _top_unextended_sp = _stream.unextended_sp();\n+  _top_unextended_sp_before_thaw = _stream.unextended_sp();\n@@ -1827,0 +1851,1 @@\n+    \/\/ TODO ZGC: this is where we'd want to restore color to the oops\n@@ -1831,1 +1856,1 @@\n-  frame caller;\n+  frame caller; \/\/ the thawed caller on the stack\n@@ -1903,2 +1928,2 @@\n-  int delta = _stream.unextended_sp() - _top_unextended_sp;\n-  chunk->set_max_thawing_size(chunk->max_thawing_size() - delta);\n+  int total_thawed = _stream.unextended_sp() - _top_unextended_sp_before_thaw;\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() - total_thawed);\n@@ -1939,1 +1964,1 @@\n-    ContinuationHelper::Frame::patch_pc(caller, _cont.is_empty() ? caller.raw_pc()\n+    ContinuationHelper::Frame::patch_pc(caller, _cont.is_empty() ? caller.pc()\n@@ -1955,0 +1980,1 @@\n+  \/\/ or they will keep objects that are otherwise unreachable alive\n@@ -1972,1 +1998,1 @@\n-  _align_size += frame::align_wiggle; \/\/ remove the added alignment room for internal interpreted frame alignment om AArch64\n+  _align_size += frame::align_wiggle; \/\/ possible added alignment for internal interpreted frame alignment om AArch64\n@@ -1983,4 +2009,2 @@\n-  assert(!bottom || frame_sp + fsize >= _cont.entrySP() - 2, \"\");\n-  assert(!bottom || frame_sp + fsize <= _cont.entrySP(), \"\");\n-\n-  assert(ContinuationHelper::InterpretedFrame::frame_bottom(f) == frame_sp + fsize, \"\");\n+  assert(ContinuationHelper::InterpretedFrame::frame_bottom(f) >= frame_sp + fsize\n+    && ContinuationHelper::InterpretedFrame::frame_bottom(f) <= frame_sp + fsize + 1, \"\"); \/\/ internal alignment on aarch64\n@@ -2050,0 +2074,2 @@\n+  \/\/ If we're the bottom-most thawed frame, we're writing to within one word from entrySP\n+  \/\/ (we might have one padding word for alignment)\n@@ -2057,4 +2083,0 @@\n-  if (f.cb()->is_nmethod()) {\n-    f.cb()->as_nmethod()->run_nmethod_entry_barrier();\n-  }\n-\n@@ -2072,1 +2094,1 @@\n-    f.deoptimize(nullptr); \/\/ we're assuming there are no monitors; this doesn't revoke biased locks\n+    f.deoptimize(nullptr); \/\/ the null thread simply avoids the assertion in deoptimize which we're not set up for\n@@ -2220,0 +2242,1 @@\n+  \/\/ All the frames have been thawed so we know they don't hold any monitors\n@@ -2222,2 +2245,0 @@\n-  verify_continuation(cont.continuation());\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":114,"deletions":93,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -2019,1 +2019,1 @@\n-  product(intx, ExtentLocalCacheSize, 16,                                    \\\n+  product(intx, ExtentLocalCacheSize, 16,                                   \\\n@@ -2022,1 +2022,1 @@\n-           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)           \\\n+           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)          \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+  DEBUG_ONLY(intptr_t* sp_before = thread->last_Java_sp();)\n@@ -143,0 +144,1 @@\n+  assert(sp_before == thread->last_Java_sp(), \"Anchor has changed\");\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -326,3 +326,3 @@\n-    \/\/ @Test\n-    public void testPinnedNative() {\n-        \/\/ pinning due to native method\n+    @Test\n+    public void testPinnedCriticalSection() {\n+        \/\/ pinning due to critical section\n@@ -332,1 +332,1 @@\n-            nativeFoo(1);\n+            csFoo(1);\n@@ -341,1 +341,1 @@\n-        assertEquals(res.get(), Continuation.Pinned.NATIVE);\n+        assertEquals(res.get(), Continuation.Pinned.CRITICAL_SECTION);\n@@ -344,1 +344,5 @@\n-    static double nativeFoo(int a) {\n+    static double csFoo(int a) {\n+        long x = 8;\n+        String s = \"yyy\";\n+        String r;\n+        Continuation.pin();\n@@ -346,17 +350,0 @@\n-            long x = 8;\n-            String s = \"yyy\";\n-            return Bar.x; \/\/ load the class\n-        } catch (Exception e) {\n-            throw new AssertionError(e);\n-        }\n-    }\n-\n-    \/\/ use a class initializer to have a native method on the stack\n-    class Bar {\n-        static {\n-            nativeBar(5);\n-        }\n-\n-        static String nativeBar(long b) {\n-            double x = 9.99;\n-            String s = \"zzz\";\n@@ -364,5 +351,3 @@\n-            boolean res = Continuation.yield(FOO);\n-            assert res == false;\n-\n-            long r = b+1;\n-            return \"\" + r;\n+            r = bar2(a + 1);\n+        } finally {\n+            Continuation.unpin();\n@@ -370,2 +355,1 @@\n-\n-        static int x = 5;\n+        return Integer.parseInt(r)+1;\n@@ -375,2 +359,2 @@\n-    public void testPinnedCriticalSection() {\n-        \/\/ pinning due to critical section\n+    public void testPinnedNative() {\n+        \/\/ pinning due to native method\n@@ -380,1 +364,1 @@\n-            csFoo(1);\n+            nativeFoo(1);\n@@ -389,1 +373,1 @@\n-        assertEquals(res.get(), Continuation.Pinned.CRITICAL_SECTION);\n+        assertEquals(res.get(), Continuation.Pinned.NATIVE);\n@@ -392,5 +376,1 @@\n-    static double csFoo(int a) {\n-        long x = 8;\n-        String s = \"yyy\";\n-        String r;\n-        Continuation.pin();\n+    static double nativeFoo(int a) {\n@@ -398,4 +378,5 @@\n-            assert Continuation.isPinned(FOO);\n-            r = bar2(a + 1);\n-        } finally {\n-            Continuation.unpin();\n+            int x = 8;\n+            String s = \"yyy\";\n+            return nativeBar(x);\n+        } catch (Exception e) {\n+            throw new AssertionError(e);\n@@ -403,1 +384,16 @@\n-        return Integer.parseInt(r)+1;\n+    }\n+\n+    static int nativeBaz(int b) {\n+        double x = 9.99;\n+        String s = \"zzz\";\n+        assert Continuation.isPinned(FOO);\n+        boolean res = Continuation.yield(FOO);\n+        assert res == false;\n+\n+        return b+1;\n+    }\n+\n+    private static native int nativeBar(int x);\n+\n+    static {\n+        System.loadLibrary(\"BasicJNI\");\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Basic.java","additions":40,"deletions":44,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key randomness\n@@ -68,1 +69,1 @@\n-    static final boolean RANDOM  = false;\n+    static final boolean RANDOM  = true;\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/Fuzz.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -19,0 +19,2 @@\n+YIELD, CALL_C_MANY, LOOP, YIELD, CALL_C_PIN, LOOP, CALL_C_INT, YIELD, CALL_C_PIN, LOOP, CALL_C_MANY, LOOP, YIELD, YIELD, CALL_C_DBL, LOOP, CALL_C_MANY, CALL_C_INT, CALL_C_MANY, LOOP, YIELD, CALL_C_CTCH, CALL_C_MANY, CALL_C_INT, CALL_C_CTCH, CALL_C_CTCH, CALL_C_INT, CALL_C_DBL, LOOP, CALL_C_CTCH, CALL_C_INT, CALL_C_MANY, CALL_C_MANY, YIELD, YIELD, CALL_C_MANY, CALL_C_CTCH, CALL_C_CTCH, CALL_C_DBL, CALL_C_CTCH, YIELD, CALL_C_CTCH, YIELD, CALL_C_INT, YIELD, YIELD, CALL_C_CTCH\n+CALL_I_DBL, CALL_I_CTCH, CALL_I_CTCH, CALL_I_DBL, CALL_I_INT, CALL_I_DBL, CALL_I_DBL, CALL_I_DBL, CALL_I_DBL, LOOP, CALL_I_CTCH, CALL_I_MANY, CALL_C_DBL, CALL_I_DBL, YIELD, CALL_C_DBL, CALL_C_CTCH, CALL_I_INT, CALL_I_MANY, CALL_I_INT, CALL_C_DBL, CALL_I_DBL, CALL_C_INT, CALL_C_MANY, CALL_I_MANY, CALL_C_INT, LOOP, LOOP, CALL_C_DBL, LOOP, LOOP, CALL_I_CTCH, LOOP, CALL_I_CTCH, CALL_I_CTCH, YIELD, LOOP, CALL_I_INT, CALL_I_INT, YIELD, CALL_I_CTCH, CALL_C_CTCH, CALL_I_MANY, CALL_I_CTCH, CALL_I_CTCH\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/fuzz.dat","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+JNIEXPORT jint JNICALL\n+Java_Basic_nativeBar(JNIEnv* env, jclass klass, jint x) {\n+    jmethodID nativeBaz = (*env)->GetStaticMethodID(env, klass, \"nativeBaz\", \"(I)I\");\n+    jint r = (*env)->CallStaticIntMethod(env, klass, nativeBaz, x+1);\n+    return r + 1;\n+}\n","filename":"test\/jdk\/jdk\/internal\/vm\/Continuation\/libBasicJNI.c","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"}]}