{"files":[{"patch":"@@ -104,3 +104,6 @@\n-    metadata_words = sender_sp_offset, \/\/ size, in words, of frame metadata (e.g. pc and link)\n-    frame_alignment = 16, \/\/ in bytes\n-    align_wiggle = 1 \/\/ size, in words, of maximum shift in frame position due to alignment\n+    \/\/ size, in words, of frame metadata (e.g. pc and link)\n+    metadata_words                                   = sender_sp_offset,\n+    \/\/ in bytes\n+    frame_alignment                                  = 16,\n+    \/\/ size, in words, of frame metadata (e.g. pc and link)\n+    align_wiggle                                     =  1\n@@ -154,2 +157,2 @@\n-\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool on_heap); \/\/ used for fast frame construction by continuations\n+  \/\/ used for fast frame construction by continuations\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool on_heap);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    address base_location = location(base_reg, (intptr_t*)NULL);\n+    address base_location = location(base_reg, nullptr);\n@@ -46,1 +46,1 @@\n-    return location(base_reg->next(slot_idx), (intptr_t*)NULL);\n+    return location(base_reg->next(slot_idx), nullptr);\n","filename":"src\/hotspot\/cpu\/aarch64\/registerMap_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -523,0 +523,1 @@\n+\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -226,1 +226,1 @@\n-  oop* result_adr = (oop*) map->location(R0->as_VMReg(), (intptr_t*) NULL);\n+  oop* result_adr = (oop*) map->location(R0->as_VMReg(), nullptr);\n@@ -232,1 +232,1 @@\n-  oop* result_adr = (oop*) map->location(R0->as_VMReg(), (intptr_t*) NULL);\n+  oop* result_adr = (oop*) map->location(R0->as_VMReg(), nullptr);\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    return location(base_reg->next(slot_idx), (intptr_t*) NULL);\n+    return location(base_reg->next(slot_idx), nullptr);\n","filename":"src\/hotspot\/cpu\/arm\/registerMap_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-  return *((oop*)map->location(R3->as_VMReg(), (intptr_t*) NULL));\n+  return *((oop*)map->location(R3->as_VMReg(), nullptr));\n@@ -218,1 +218,1 @@\n-  *((oop*)map->location(R3->as_VMReg(), (intptr_t*) NULL)) = obj;\n+  *((oop*)map->location(R3->as_VMReg(), nullptr)) = obj;\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    return location(base_reg->next(slot_idx), (intptr_t*)NULL);\n+    return location(base_reg->next(slot_idx), nullptr);\n","filename":"src\/hotspot\/cpu\/ppc\/registerMap_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -635,0 +635,1 @@\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -278,1 +278,1 @@\n-  return *((oop*) map->location(Z_R2->as_VMReg(), (intptr_t*) NULL));  \/\/ R2 is return register.\n+  return *((oop*) map->location(Z_R2->as_VMReg(), nullptr));  \/\/ R2 is return register.\n@@ -282,1 +282,1 @@\n-  *((oop*) map->location(Z_R2->as_VMReg(), (intptr_t*) NULL)) = obj;  \/\/ R2 is return register.\n+  *((oop*) map->location(Z_R2->as_VMReg(), nullptr)) = obj;  \/\/ R2 is return register.\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    return location(base_reg->next(slot_idx), (intptr_t*) NULL);\n+    return location(base_reg->next(slot_idx), nullptr);\n","filename":"src\/hotspot\/cpu\/s390\/registerMap_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -632,0 +632,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -100,3 +100,6 @@\n-    metadata_words = sender_sp_offset, \/\/ size, in words, of frame metadata (e.g. pc and link)\n-    frame_alignment = 16, \/\/ compiled frame alignment, in bytes\n-    align_wiggle = 1 \/\/ size, in words, of maximum shift in frame position due to alignment\n+    \/\/ size, in words, of frame metadata (e.g. pc and link)\n+    metadata_words                                   = sender_sp_offset,\n+    \/\/ compiled frame alignment, in bytes\n+    frame_alignment                                  = 16,\n+    \/\/ size, in words, of maximum shift in frame position due to alignment\n+    align_wiggle                                     =  1\n@@ -146,2 +149,2 @@\n-\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool relative); \/\/ used for heap frame construction by continuations\n+  \/\/ used for heap frame construction by continuations\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool relative);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1287,0 +1287,1 @@\n+\n@@ -1357,0 +1358,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    address base_location = location(base_reg, (intptr_t*)NULL);\n+    address base_location = location(base_reg, nullptr);\n@@ -66,1 +66,1 @@\n-  return location(base_reg->next(slot_idx), (intptr_t*)NULL);\n+  return location(base_reg->next(slot_idx), nullptr);\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  code_size1 = 20000 LP64_ONLY(+10000),         \/\/ simply increase if too small (assembler will crash if too small)\n+  code_size1 = 20000 LP64_ONLY(+10000),                    \/\/ simply increase if too small (assembler will crash if too small)\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -6348,1 +6348,1 @@\n-        assert(vlen == 8, \"sanity\");\n+        assert (vlen == 8, \"sanity\");\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -417,0 +417,1 @@\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    return location(base_reg->next(slot_idx), (intptr_t*) NULL);\n+    return location(base_reg->next(slot_idx), nullptr);\n","filename":"src\/hotspot\/cpu\/zero\/registerMap_zero.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2757,1 +2757,0 @@\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1042,1 +1042,0 @@\n-  static inline oop unknown_referent(oop ref);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,4 +152,0 @@\n-oop java_lang_ref_Reference::unknown_referent(oop ref) {\n-  return ref->obj_field_access<ON_UNKNOWN_OOP_REF>(_referent_offset);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1085,3 +1085,2 @@\n-      \/\/ Initiate a concurrent start.  A concurrent start must be a\n-      \/\/ young only GC, so the collector state must be updated to\n-      \/\/ reflect this.\n+      \/\/ Initiate a concurrent start.  A concurrent start must be a young only\n+      \/\/ GC, so the collector state must be updated to reflect this.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/continuationGCSupport.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -158,2 +158,2 @@\n-oop Generation::promote(oop old, size_t obj_size) {\n-  assert(obj_size == old->size(), \"bad obj_size passed in\");\n+oop Generation::promote(oop obj, size_t obj_size) {\n+  assert(obj_size == obj->size(), \"bad obj_size passed in\");\n@@ -167,0 +167,1 @@\n+  \/\/ Allocate new object.\n@@ -175,2 +176,0 @@\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), result, obj_size);\n-  oop obj = cast_to_oop<HeapWord*>(result);\n@@ -178,3 +177,8 @@\n-  \/\/ Transform object.\n-  ContinuationGCSupport::transform_stack_chunk(obj);\n-  return obj;\n+  \/\/ Copy to new location.\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(obj), result, obj_size);\n+  oop new_obj = cast_to_oop<HeapWord*>(result);\n+\n+  \/\/ Transform object if it is a stack chunk.\n+  ContinuationGCSupport::transform_stack_chunk(new_obj);\n+\n+  return new_obj;\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -430,2 +430,2 @@\n-\/\/ Does the minimal amount of initialization needed for a TLAB allocation\n-\/\/ We don't need to do a full initialization, as such an allocation need not be immeidately walkable\n+\/\/ Does the minimal amount of initialization needed for a TLAB allocation.\n+\/\/ We don't need to do a full initialization, as such an allocation need not be immediately walkable.\n@@ -441,5 +441,2 @@\n-  \/\/ const size_t hs = oopDesc::header_size();\n-  \/\/ Copy::fill_to_aligned_words(mem + hs, vmClasses::StackChunk_klass()->size_helper() - hs);\n-\n-  \/\/ we zero the oop fields so that the object is walkable immediately in case it is humongous\n-  \/\/ we do this first, and so we don't care about whether they're narrow or wide\n+  \/\/ We zero the oop fields so that the object is walkable immediately in case it is humongous.\n+  \/\/ we do this first, and so we don't care about whether they're narrow or wide.\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -181,2 +181,0 @@\n-  \/\/ This operation is only valid when resurrection is blocked.\n-  assert(ZResurrection::is_blocked(), \"Invalid phase\");\n@@ -189,2 +187,0 @@\n-  \/\/ This operation is only valid when resurrection is blocked.\n-  assert(ZResurrection::is_blocked(), \"Invalid phase\");\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -333,0 +333,2 @@\n+  \/\/ This operation is only valid when resurrection is blocked.\n+  assert(ZResurrection::is_blocked(), \"Invalid phase\");\n@@ -338,0 +340,2 @@\n+  \/\/ This operation is only valid when resurrection is blocked.\n+  assert(ZResurrection::is_blocked(), \"Invalid phase\");\n@@ -343,0 +347,2 @@\n+  \/\/ This operation is only valid when resurrection is blocked.\n+  assert(ZResurrection::is_blocked(), \"Invalid phase\");\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -60,0 +60,3 @@\n+\n+\n+  \/\/ Class redefinition support\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -207,0 +207,1 @@\n+  \/\/ Don't follow this metadata when verifying oops\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -272,1 +272,0 @@\n-  \/\/ Called for each code blob, but at most once per unique blob.\n@@ -274,0 +273,1 @@\n+  \/\/ Called for each code blob, but at most once per unique blob.\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"code\/nmethod.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"code\/nmethod.hpp\"\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -444,0 +444,1 @@\n+      \/\/ mirror - java.lang.Class\n@@ -446,0 +447,1 @@\n+      \/\/ stack chunk\n@@ -448,1 +450,1 @@\n-      \/\/ class loader\n+      \/\/ class loader - java.lang.ClassLoader\n@@ -455,0 +457,1 @@\n+    \/\/ java.lang.ref.Reference\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-const int TwoWordAlignmentMask  = (1 << (LogBytesPerWord+1)) - 1;\n-\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1324,1 +1324,2 @@\n-    mh->_i2i_entry = mh->get_i2c_entry(); \/\/ this is the entry used when we're in interpreter-only mode; see InterpreterMacroAssembler::jump_from_interpreted\n+    \/\/ this is the entry used when we're in interpreter-only mode; see InterpreterMacroAssembler::jump_from_interpreted\n+    mh->_i2i_entry = mh->get_i2c_entry();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-  oop obj = cast_to_oop(this);\n+  oop obj = const_cast<oopDesc*>(this);\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -346,1 +346,0 @@\n-      \/\/ omap->set_value( r);\n","filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-    _chunk = stackChunkHandle(Thread::current(), NULL, true);\n+    _chunk = stackChunkHandle(Thread::current()->handle_area()->allocate_null_handle(), true \/* dummy *\/);\n@@ -91,1 +91,1 @@\n-  _chunk = stackChunkHandle(Thread::current(), NULL, true);\n+  _chunk = stackChunkHandle(Thread::current()->handle_area()->allocate_null_handle(), true \/* dummy *\/);\n@@ -111,1 +111,1 @@\n-  _chunk = map->_chunk; \/\/ stackChunkHandle(Thread::current(), map->_chunk(), map->_chunk.not_null()); \/\/\n+  _chunk = map->_chunk;\n@@ -171,1 +171,1 @@\n-    intptr_t* src = (intptr_t*) location(r, (intptr_t*)NULL);\n+    intptr_t* src = (intptr_t*) location(r, nullptr);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,5 @@\n+#define assert_handle_mark_nesting()                                                     \\\n+  assert(_handle_mark_nesting > 1, \"memory leak: allocating handle outside HandleMark\"); \\\n+  assert(_no_handle_mark_nesting == 0, \"allocating handle inside NoHandleMark\");         \\\n+\n+\n@@ -35,3 +40,2 @@\n-  assert(_handle_mark_nesting > 1, \"memory leak: allocating handle outside HandleMark\");\n-  assert(_no_handle_mark_nesting == 0, \"allocating handle inside NoHandleMark\");\n-  assert(oopDesc::is_oop_or_null(obj), \"not an oop: \" INTPTR_FORMAT, p2i(obj));\n+  assert_handle_mark_nesting();\n+  assert(oopDesc::is_oop(obj), \"not an oop: \" INTPTR_FORMAT, p2i(obj));\n@@ -40,0 +44,5 @@\n+\n+oop* HandleArea::allocate_null_handle() {\n+  assert_handle_mark_nesting();\n+  return real_allocate_handle(NULL);\n+}\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  inline Handle(Thread* thread, oop obj, bool allocNull = false);\n+  inline Handle(Thread* thread, oop obj);\n@@ -116,3 +116,4 @@\n-    type##Handle ()                              : Handle()                 {} \\\n-    inline type##Handle (Thread* thread, type##Oop obj, bool allocNull = false); \\\n-    \\\n+    type##Handle ()                              : Handle() {} \\\n+    inline type##Handle (Thread* thread, type##Oop obj); \\\n+    type##Handle (oop *handle, bool dummy)       : Handle(handle, dummy) {} \\\n+                                                 \\\n@@ -206,0 +207,1 @@\n+  oop* allocate_null_handle();\n@@ -208,0 +210,1 @@\n+  oop* allocate_null_handle()   { return allocate_handle(nullptr); }\n","filename":"src\/hotspot\/share\/runtime\/handles.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-inline Handle::Handle(Thread* thread, oop obj, bool allocNull) {\n+inline Handle::Handle(Thread* thread, oop obj) {\n@@ -39,1 +39,1 @@\n-  if (obj == NULL && !allocNull) {\n+  if (obj == NULL) {\n@@ -55,3 +55,3 @@\n-#define DEF_HANDLE_CONSTR(type, is_a)                   \\\n-inline type##Handle::type##Handle (Thread* thread, type##Oop obj, bool allocNull) : Handle(thread, (oop)obj, allocNull) { \\\n-  assert(is_null() || (allocNull && obj == NULL) || ((oop)obj)->is_a(), \"illegal type\");                \\\n+#define DEF_HANDLE_CONSTR(type, is_a)                                                          \\\n+inline type##Handle::type##Handle (Thread* thread, type##Oop obj) : Handle(thread, (oop)obj) { \\\n+  assert(is_null() || ((oop)obj)->is_a(), \"illegal type\");                                     \\\n","filename":"src\/hotspot\/share\/runtime\/handles.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-      return location(base_reg, (intptr_t*)NULL);\n+      return location(base_reg, nullptr);\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1170,1 +1170,1 @@\n-    assert(oopDesc::is_oop_or_null(receiver()), \"\"); \/\/ if (receiver() != NULL) oopDesc::verify(receiver()); \/\/\n+    assert(oopDesc::is_oop_or_null(receiver()), \"\");\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -452,1 +452,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1019,1 +1019,0 @@\n-  _keepalive_cleanup(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<WeakHandle>(16, mtInternal)),\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"oops\/weakHandle.hpp\"\n@@ -739,1 +738,0 @@\n-  GrowableArray<WeakHandle>* _keepalive_cleanup;\n@@ -1294,3 +1292,0 @@\n-  void set_keepalive_cleanup(GrowableArray<WeakHandle>* lst) { _keepalive_cleanup = lst; }\n-  GrowableArray<WeakHandle>* keepalive_cleanup() const { return _keepalive_cleanup; }\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,0 +57,14 @@\n+static oop* allocate_handle(Handle reg_map_chunk) {\n+  if (reg_map_chunk() != nullptr) {\n+    return Thread::current()->handle_area()->allocate_handle(reg_map_chunk());\n+  }\n+\n+  if (reg_map_chunk.not_null()) {\n+    \/\/ NULL oop but the handle was still allocated, keep using an allocated handle.\n+    return Thread::current()->handle_area()->allocate_null_handle();\n+  }\n+\n+  \/\/ NULL oop and NULL handle, keep using an unallocated handle.\n+  return NULL;\n+}\n+\n@@ -59,1 +73,1 @@\n-  _chunk(Thread::current(), reg_map->stack_chunk()(), reg_map->stack_chunk().not_null()) {\n+  _chunk(allocate_handle(reg_map->stack_chunk()), true \/* dummy *\/) {\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"}]}