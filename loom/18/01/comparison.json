{"files":[{"patch":"@@ -436,1 +436,0 @@\n-        Scoped.Cache.clearCache();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Continuation.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import jdk.internal.vm.annotation.Stable;\n-\n-\/**\n- * TBD\n- * A Lifetime is a Thing.\n- *\/\n-public class Lifetime {\n-    \/\/ v1:\n-    @Stable final Lifetime parent;\n-    @Stable ScopedMap scopedMap;\n-\n-    \/\/ v2:\n-    @Stable final Thread thread;\n-    private int depth;\n-\n-    @Stable final int index;\n-\n-    enum Version { V1, V2 }\n-\n-    static final Version version = Version.V2;\n-\n-    static private int counter;\n-\n-    private Lifetime(Lifetime parent, Thread thread, int depth) {\n-        this.parent = parent;\n-        this.thread = thread;\n-        this.depth = depth;\n-        synchronized (Lifetime.class){\n-            index = counter++;\n-        }\n-    }\n-\n-    \/\/ v1:\n-    private Lifetime(Lifetime parent) {\n-        this(parent, null, 0);\n-    }\n-\n-    \/\/ v2:\n-    Lifetime(Thread thread, int depth) {\n-        this(null, thread, depth);\n-    }\n-    int depth() {\n-        return depth;\n-    }\n-\n-    \/**\n-     * TBD\n-     * @return Lifetime\n-     *\/\n-    static public Lifetime start() {\n-        if (version == Version.V1) {\n-            var t = Thread.currentThread();\n-            var lt = new Lifetime(t.currentLifetime());\n-            t.pushLifetime(lt);\n-            return lt;\n-        } else {\n-            return Thread.currentThread().pushLifetime();\n-        }\n-    }\n-\n-    \/**\n-     * TBD\n-     *\/\n-    public void close() {\n-        if (Lifetime.version == Lifetime.Version.V1) {\n-            Thread.currentThread().popLifetime(this);\n-        } else {\n-            thread.popLifetime(this);\n-            this.depth = Integer.MAX_VALUE;\n-        }\n-    }\n-\n-    final ScopedMap scopedMap() {\n-        var map = scopedMapOrNull();\n-        if (map == null) {\n-            map = scopedMap = new ScopedMap();\n-        }\n-        return map;\n-    }\n-\n-    final ScopedMap scopedMapOrNull() {\n-        if (version == Version.V1) {\n-            return scopedMap;\n-        } else {\n-            return thread.scopedMap();\n-        }\n-    }\n-\n-    public String toString() {\n-        return \"parent: \" + parent + \" index: \" + index;\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Lifetime.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-\/**\n- * TBD\n- *\/\n-public class LifetimeError extends Error {\n-    static final long serialVersionUID = 1234L;\n-\n-    \/**\n-     * TBD\n-     * @param s String\n-     *\/\n-    public LifetimeError(String s) {\n-        super(s);\n-    }\n-\n-    \/**\n-     * TBD\n-     *\/\n-    public LifetimeError() {\n-        super();\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LifetimeError.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -1,201 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n-import static java.lang.ScopedMap.NULL_PLACEHOLDER;\n-\n-\/**\n- * This class extends {@code ThreadLocal} to provide inheritance of\n- * values from parent thread to child thread: when a thread is started\n- * by a bounded construct such as an ExecutorService or a parallel\n- * stream, the thread executing the task is passed a reference to the\n- * parent's set of LightweightThreadLocals. While the thread is\n- * running the parent thread's set of LightweightThreadLocals is\n- * immutable: any attempt to modify it returns a LifetimeError. The\n- * child thread has its own set of LightweightThreadLocals.\n- *\n- *\/\n-\n-public class LightweightThreadLocal<T> extends ThreadLocal<T> {\n-\n-    @Stable\n-    private final int hash = Scoped.generateKey();\n-\n-    @Stable\n-    private final Class<T> theType;\n-\n-    \/**\n-     * TBD\n-     *\n-     * @return TBD\n-     *\/\n-    final Class<T> getType() {\n-        return theType;\n-    }\n-\n-    @ForceInline\n-    @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-    private static final Object getObject(int hash, LightweightThreadLocal<?> key) {\n-        Object[] objects;\n-        if (Scoped.USE_CACHE && (objects = Thread.scopedCache()) != null) {\n-            \/\/ This code should perhaps be in class Cache. We do it\n-            \/\/ here because the generated code is small and fast and\n-            \/\/ we really want it to be inlined in the caller.\n-            int n = (hash & Scoped.Cache.TABLE_MASK) * 2;\n-            if (objects[n] == key) {\n-                return objects[n + 1];\n-            }\n-            n = ((hash >>> Scoped.Cache.INDEX_BITS) & Scoped.Cache.TABLE_MASK) * 2;\n-            if (objects[n] == key) {\n-                return objects[n + 1];\n-            }\n-        }\n-        return key.slowGet(Thread.currentThread());\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-    public T get() {\n-        return (T)getObject(hashCode(), this);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return hash;\n-    }\n-\n-    \/**\n-     * Removes the current thread's value for this thread-local\n-     * variable.\n-     *\n-     * @since 1.5\n-     *\/\n-    public void remove() {\n-    var map = Thread.currentThread().scopedMap();\n-        map.remove(hashCode(), this);\n-        Scoped.Cache.remove(this);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-    private T slowGet(Thread thread) {\n-        Lifetime currentLifetime = thread.currentLifetime();\n-\n-        var value = NULL_PLACEHOLDER;\n-\n-        if (Lifetime.version == Lifetime.Version.V1) {\n-            for (Lifetime aLifetime = currentLifetime;\n-                 aLifetime != null;\n-                 aLifetime = aLifetime.parent) {\n-                var map = aLifetime.scopedMapOrNull();\n-                if (map == null) continue;\n-                value = map.get(hashCode(), this);\n-                if (value != NULL_PLACEHOLDER) break;\n-            }\n-        } else {\n-            for (var t = thread; t != null; t = t.parentThread) {\n-                var map = t.scopedMapOrNull();\n-                if (map == null) continue;\n-                value = map.get(hashCode(), this);\n-                if (value != NULL_PLACEHOLDER) break;\n-            }\n-        }\n-\n-        if (value == NULL_PLACEHOLDER)\n-            value = initialValue();\n-\n-        if (Scoped.USE_CACHE) {\n-            Scoped.Cache.put(thread, this, value);\n-        }\n-\n-        return (T) value;\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @param t     TBD\n-     * @param chain TBD\n-     * @return TBD\n-     *\/\n-    @Override\n-    @SuppressWarnings(value = {\"unchecked\", \"rawtypes\"})\n-    \/\/ one map has entries for all types <T>\n-    public void set(T t) {\n-        if (t != null && ! theType.isInstance(t))\n-            throw new ClassCastException(ScopedBinding.cannotBindMsg(t, theType));\n-        var map = Thread.currentThread().scopedMap();\n-        map.put(hashCode(), this, t);\n-\n-        Scoped.Cache.update(this, t);\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @param t     TBD\n-     * @param chain TBD\n-     * @return TBD\n-     *\/\n-    @SuppressWarnings(value = {\"unchecked\", \"rawtypes\"})\n-    \/\/ one map has entries for all types <T>\n-    public ScopedBinding bind(T t) {\n-        if (t != null && ! theType.isInstance(t))\n-            throw new ClassCastException(ScopedBinding.cannotBindMsg(t, theType));\n-        var lifetime = Lifetime.start();\n-        var map = Thread.currentThread().scopedMap();\n-        Object previousMapping = map.put(hashCode(), this, t);\n-\n-        var b = new ScopedBinding(this, t, previousMapping, lifetime);\n-\n-        Scoped.Cache.update(this, t);\n-\n-        return b;\n-    }\n-\n-    \/**\n-     * Creates an inheritable thread local variable.\n-     *\/\n-    private LightweightThreadLocal() {\n-        theType = null;\n-    }\n-\n-    LightweightThreadLocal(Class<T> klass) {\n-        theType = klass;\n-    }\n-\n-    final void release(Object prev) {\n-        var map = Thread.currentThread().scopedMap();\n-        if (prev != NULL_PLACEHOLDER) {\n-            map.put(hashCode(), this, prev);\n-        } else {\n-            map.remove(hashCode(), this);\n-        }\n-        Scoped.Cache.remove(this);\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/LightweightThreadLocal.java","additions":0,"deletions":201,"binary":false,"changes":201,"status":"deleted"},{"patch":"@@ -1,528 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Red Hat, Inc. and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.FieldVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-import jdk.internal.vm.annotation.ForceInline;\n-import sun.security.action.GetPropertyAction;\n-\n-import static jdk.internal.misc.UnsafeConstants.SCOPED_CACHE_SHIFT;\n-import static jdk.internal.org.objectweb.asm.Opcodes.*;\n-import static java.lang.ScopedMap.NULL_PLACEHOLDER;\n-\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.lang.reflect.Field;\n-import java.security.ProtectionDomain;\n-import java.util.Arrays;\n-\n-\/**\n- * TBD\n- *\/\n-public abstract class Scoped<T> {\n-\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n-    static final boolean USE_CACHE = Cache.INDEX_BITS > 0;\n-\n-    private static final boolean DEBUG;\n-    static {\n-        String debug = GetPropertyAction.privilegedGetProperty(\"java.lang.Scoped.DEBUG\");\n-        DEBUG = \"true\".equals(debug);\n-    }\n-\n-    private static int nextKey = 0xf0f0_f0f0;\n-\n-    \/**\n-     * TBD\n-     *\/\n-    protected Scoped() {}\n-\n-    @ForceInline\n-    @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-    static final Object getObject(int hash, Scoped<?> key) {\n-        Object[] objects;\n-        if (USE_CACHE && (objects = Thread.scopedCache()) != null) {\n-            \/\/ This code should perhaps be in class Cache. We do it\n-            \/\/ here because the generated code is small and fast and\n-            \/\/ we really want it to be inlined in the caller.\n-            int n = (hash & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == key) {\n-                return objects[n + 1];\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == key) {\n-                return objects[n + 1];\n-            }\n-        }\n-        return key.slowGet(Thread.currentThread());\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @param t     TBD\n-     * @param chain TBD\n-     * @return TBD\n-     *\/\n-    @SuppressWarnings(value = {\"unchecked\", \"rawtypes\"})\n-    \/\/ one map has entries for all types <T>\n-    public ScopedBinding bind(T t) {\n-        if (t != null && ! getType().isInstance(t))\n-            throw new ClassCastException(ScopedBinding.cannotBindMsg(t, getType()));\n-        var lifetime = Lifetime.start();\n-        var map = Thread.currentThread().scopedMap();\n-        Object previousMapping = map.put(hashCode(), this, t);\n-\n-        var b = new ScopedBinding(this, t, previousMapping, lifetime);\n-\n-        Cache.update(this, t);\n-\n-        return b;\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @param <T>   TBD\n-     * @param klass TBD\n-     * @return TBD\n-     *\/\n-    @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-    @CallerSensitive\n-    public static <T> Scoped<T> forType(Class<T> klass) {\n-        Class<?> caller = Reflection.getCallerClass();\n-        return (Scoped<T>) writeClass(klass, generateKey(), caller, Scoped.class);\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @param <T>   TBD\n-     * @param klass TBD\n-     * @return TBD\n-     *\/\n-    @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-    @CallerSensitive\n-    public static <T> Scoped<T> finalForType(Class<T> klass) {\n-        Class<?> caller = Reflection.getCallerClass();\n-        return (Scoped<T>) writeClass(klass, generateKey(), caller, ScopedFinal.class);\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @return TBD\n-     *\/\n-    public abstract T get();\n-\n-    abstract Class<?> getType();\n-\n-    final void release(Object prev) {\n-        var map = Thread.currentThread().scopedMap();\n-        if (prev != NULL_PLACEHOLDER) {\n-            map.put(hashCode(), this, prev);\n-        } else {\n-            map.remove(hashCode(), this);\n-        }\n-        Cache.remove(this);\n-    }\n-\n-    static final void release(Object key, Object prev) {\n-        var map = Thread.currentThread().scopedMap();\n-        if (prev != NULL_PLACEHOLDER) {\n-            map.put(key.hashCode(), key, prev);\n-        } else {\n-            map.remove(key.hashCode(), key);\n-        }\n-        Cache.remove(key);\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @return TBD\n-     *\/\n-    public boolean isBound() {\n-        var hash = hashCode();\n-        Object[] objects;\n-        if (USE_CACHE && (objects = Thread.scopedCache()) != null) {\n-            int n = (hash & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == this) {\n-                return true;\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == this) {\n-                return true;\n-            }\n-        }\n-\n-        var value = Thread.currentThread().scopedMap().get(hashCode(), this);\n-\n-        if (value == NULL_PLACEHOLDER)\n-            return false;\n-\n-        return true;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-    private T slowGet(Thread thread) {\n-        Lifetime currentLifetime = thread.currentLifetime();\n-\n-        var value = NULL_PLACEHOLDER;\n-\n-        if (Lifetime.version == Lifetime.Version.V1) {\n-            for (Lifetime aLifetime = currentLifetime;\n-                 aLifetime != null;\n-                 aLifetime = aLifetime.parent) {\n-                var map = aLifetime.scopedMapOrNull();\n-                if (map == null) continue;\n-                value = map.get(hashCode(), this);\n-                if (value != NULL_PLACEHOLDER) break;\n-            }\n-        } else {\n-            for (var t = thread; t != null; t = t.parentThread) {\n-                var map = t.scopedMapOrNull();\n-                if (map == null) continue;\n-                value = map.get(hashCode(), this);\n-                if (value != NULL_PLACEHOLDER) break;\n-            }\n-        }\n-\n-        if (value == NULL_PLACEHOLDER)\n-            throw new UnboundScopedException(\"Scoped<\" + getType().getName() + \"> is not bound\");\n-\n-        if (USE_CACHE) {\n-            Cache.put(thread, this, value);\n-        }\n-\n-        return (T) value;\n-    }\n-\n-    static int generateKey() {\n-        for (;;) {\n-            int x = ThreadLocal.nextHashCode();\n-            \/\/ Make sure the primary and secondary hash indexes used\n-            \/\/ by ScopedCache are different.\n-            if (USE_CACHE &&\n-                 ((x & Cache.TABLE_MASK)\n-                  == ((x >>> Cache.INDEX_BITS) & Cache.TABLE_MASK)))\n-                continue;\n-            return x;\n-        }\n-    }\n-\n-    private static long sequenceNumber = 0;\n-\n-    @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-    private static Scoped<?> writeClass(Class<?> klass, int hashKey, Class<?> caller,\n-                                        Class<?> superClass) {\n-        long seq;\n-        synchronized (Scoped.class) {\n-            seq = sequenceNumber++;\n-        }\n-        String superClassName = superClass.getName().replace(\".\", \"\/\");\n-        String className = superClassName + \"$\" + seq;\n-\n-        ClassWriter cw = new ClassWriter(0);\n-        cw.visit(V11, ACC_PUBLIC | ACC_SUPER | ACC_FINAL, className, null, superClassName, null);\n-\n-        {\n-            FieldVisitor fv = cw.visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, \"boundClass\",\n-                                            \"Ljava\/lang\/Class;\", null, null);\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PRIVATE, \"<init>\", \"()V\", null, null);\n-\n-            mv.visitCode();\n-            mv.visitIntInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESPECIAL, superClassName, \"<init>\", \"()V\", false);\n-            mv.visitInsn(RETURN);\n-            mv.visitMaxs(1, 1);\n-            mv.visitEnd();\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"hashCode\", \"()I\", null, null);\n-\n-            mv.visitCode();\n-            mv.visitLdcInsn(hashKey);\n-            mv.visitInsn(IRETURN);\n-            mv.visitMaxs(2, 1);\n-            mv.visitEnd();\n-\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_FINAL, \"getType\", \"()Ljava\/lang\/Class;\",\n-                    null, null);\n-\n-            mv.visitCode();\n-            mv.visitFieldInsn(GETSTATIC, className, \"boundClass\", \"Ljava\/lang\/Class;\");\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(2, 1);\n-            mv.visitEnd();\n-\n-        }\n-        {\n-            MethodVisitor mv = cw.visitMethod(ACC_PUBLIC | ACC_FINAL, \"get\",\n-                    \/\/ \"()\" + klass.descriptorString(),\n-                    \"()Ljava\/lang\/Object;\",\n-                    null, null);\n-\n-            mv.visitCode();\n-            mv.visitLdcInsn(hashKey);\n-            mv.visitIntInsn(ALOAD, 0);\n-            mv.visitMethodInsn(INVOKESTATIC, \"java\/lang\/Scoped\", \"getObject\", \"(ILjava\/lang\/Scoped;)Ljava\/lang\/Object;\", false);\n-            \/\/ mv.visitTypeInsn(CHECKCAST, klass.getName().replace('.', '\/'));\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(3, 1);\n-            mv.visitEnd();\n-        }\n-        cw.visitEnd();\n-\n-        byte[] bytes = cw.toByteArray();\n-\n-        if (DEBUG) {\n-            try {\n-                FileOutputStream out = new FileOutputStream(\"\/tmp\/sample\/\"\n-                        + className.replace('.', '\/') + \".class\");\n-                out.write(bytes);\n-                out.close();\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-\n-        ClassLoader cl = caller.getClass().getClassLoader();\n-        ProtectionDomain pd = (cl != null) ? Scoped.class.getProtectionDomain() : null;\n-        Class<?> c = SharedSecrets.getJavaLangAccess().defineClass(cl, className, bytes,\n-                pd, \"Scoped_forType\");\n-\n-        try {\n-            Field f = c.getDeclaredField(\"boundClass\");\n-            Object base = UNSAFE.staticFieldBase(f);\n-            long offset = UNSAFE.staticFieldOffset(f);\n-            UNSAFE.putReference(base, offset, klass);\n-\n-            Scoped<?> singleton = (Scoped<?>) UNSAFE.allocateInstance(c);\n-            if (singleton.getType() != klass) {\n-                throw new Error(\"wrong class in Scoped\");\n-            }\n-            return singleton;\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static class Cache {\n-\n-        static final boolean CACHE_LIFETIMES =\n-            \"true\".equals(GetPropertyAction.privilegedGetProperty(\"java.lang.Lifetime.USE_CACHE\"));\n-\n-        static final int INDEX_BITS = SCOPED_CACHE_SHIFT;\n-\n-        static final int TABLE_SIZE = 1 << INDEX_BITS;\n-\n-        static final int TABLE_MASK = TABLE_SIZE - 1;\n-\n-        static boolean isActive(Lifetime lt) {\n-            if (! CACHE_LIFETIMES)  return false;\n-            Object[] objects = Thread.scopedCache();\n-            if (objects == null)  return false;\n-            int n = TABLE_SIZE;\n-            return (objects[n] == lt || objects[n+1] == lt);\n-        }\n-\n-        static void setActive(Lifetime lt) {\n-            if (! CACHE_LIFETIMES)  return;\n-            Object[] objects = Thread.scopedCache();\n-            if (objects == null) {\n-                objects = createCache();\n-            }\n-            int slot = TABLE_SIZE + (chooseVictim(Thread.currentCarrierThread()) & 1);\n-            objects[slot] = lt;\n-        }\n-\n-        static void clearActive() {\n-            if (! CACHE_LIFETIMES)  return;\n-            Object[] objects = Thread.scopedCache();\n-            if (objects != null) {\n-                int n = TABLE_SIZE;\n-                objects[n] = objects[n + 1] = null;\n-            }\n-        }\n-\n-        \/\/ An alternative cache for lifetimes which uses two fields in Thread\n-        \/\/ instead of utilizing the scoped cache. Looks like it should work\n-        \/\/ well but performs spectacularly badly on a buffer copying test.\n-\n-        \/\/ static boolean isActive(Lifetime lt) {\n-        \/\/     if (! CACHE_LIFETIMES)  return false;\n-        \/\/     Thread t = Thread.currentCarrierThread();\n-        \/\/     return (t.lt0 == lt || t.lt1 == lt);\n-        \/\/ }\n-\n-        \/\/ static void setActive(Lifetime lt) {\n-        \/\/     if (! CACHE_LIFETIMES)  return;\n-        \/\/     Thread t = Thread.currentCarrierThread();\n-        \/\/     int slot = TABLE_SIZE + (chooseVictim(t) & 1);\n-        \/\/     if (slot == 0) {\n-        \/\/         t.lt0 = lt;\n-        \/\/     } else {\n-        \/\/         t.lt1 = lt;\n-        \/\/     }\n-        \/\/ }\n-\n-        \/\/ static void clearActive() {\n-        \/\/     if (! CACHE_LIFETIMES)  return;\n-        \/\/     Thread t = Thread.currentCarrierThread();\n-        \/\/     t.lt0 = t.lt1 = null;\n-        \/\/ }\n-\n-        static Object[] createCache() {\n-            Object[] objects = new Object[TABLE_SIZE * 2 + 2];\n-            Thread.setScopedCache(objects);  \/\/ 2 extra slots for lifetimes\n-            return objects;\n-        }\n-\n-        static void put(Thread t, Object key, Object value) {\n-            if (Thread.scopedCache() == null) {\n-                createCache();\n-            }\n-            setKeyAndObjectAt(chooseVictim(t, key.hashCode()), key, value);\n-        }\n-\n-        static final void update(Object key, Object value) {\n-            Object[] objects;\n-            if (USE_CACHE && (objects = Thread.scopedCache()) != null) {\n-\n-                int k1 = key.hashCode() & TABLE_MASK;\n-                if (getKey(objects, k1) == key) {\n-                    setKeyAndObjectAt(k1, key, value);\n-                }\n-                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n-                if (getKey(objects, k2) == key) {\n-                    setKeyAndObjectAt(k2, key, value);\n-                }\n-            }\n-        }\n-\n-        static final void remove(Object key) {\n-            Object[] objects;\n-            if (USE_CACHE && (objects = Thread.scopedCache()) != null) {\n-\n-                int k1 = key.hashCode() & TABLE_MASK;\n-                if (getKey(objects, k1) == key) {\n-                    setKeyAndObjectAt(k1, null, null);\n-                }\n-                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n-                if (getKey(objects, k2) == key) {\n-                    setKeyAndObjectAt(k2, null, null);\n-                }\n-            }\n-        }\n-\n-        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n-            Thread.scopedCache()[n * 2] = key;\n-            Thread.scopedCache()[n * 2 + 1] = value;\n-        }\n-\n-        private static Object getKey(Object[] objs, long hash) {\n-            int n = (int) (hash & TABLE_MASK);\n-            return objs[n * 2];\n-        }\n-\n-        private static void setKey(Object[] objs, long hash, Object key) {\n-            int n = (int) (hash & TABLE_MASK);\n-            objs[n * 2] = key;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-        final Object getKey(int n) {\n-            return Thread.scopedCache()[n * 2];\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-        private static Object getObject(int n) {\n-            return Thread.scopedCache()[n * 2 + 1];\n-        }\n-\n-        private static int chooseVictim(Thread thread, int hash) {\n-            \/\/ Update the cache to replace one entry with the value we just looked up.\n-            \/\/ Each value can be in one of two possible places in the cache.\n-            \/\/ Pick a victim at (pseudo-)random.\n-            int k1 = hash & TABLE_MASK;\n-            int k2 = (hash >> INDEX_BITS) & TABLE_MASK;\n-            int tmp = thread.victims;\n-            thread.victims = (tmp << 31) | (tmp >>> 1);\n-            return (chooseVictim(thread) & 1) == 0 ? k1 : k2;\n-        }\n-\n-        private static int chooseVictim(Thread thread) {\n-            \/\/ Update the cache to replace one entry with the value we just looked up.\n-            \/\/ Each value can be in one of two possible places in the cache.\n-            \/\/ Pick a victim at (pseudo-)random.\n-            int tmp = thread.victims;\n-            thread.victims = (tmp << 31) | (tmp >>> 1);\n-            return tmp & TABLE_MASK;\n-        }\n-\n-        static void clearCache() {\n-            \/\/ We need to do this when we yield a Continuation.\n-            if (! USE_CACHE) return;\n-            Object[] objects = Thread.scopedCache();\n-            if (objects != null) {\n-                Arrays.fill(objects, null);\n-            }\n-        }\n-    }\n-\n-\n-}\n-\n-abstract class ScopedFinal<T> extends Scoped<T> {\n-    \/**\n-     * TBD\n-     *\n-     * @param t     TBD\n-     * @param chain TBD\n-     * @return TBD\n-     *\/\n-    @SuppressWarnings(value = {\"unchecked\", \"rawtypes\"})\n-    \/\/ one map has entries for all types <T>\n-    public ScopedBinding bind(T t) {\n-        if (isBound()) {\n-            throw new ScopedAlreadyBoundException(\"Scoped<\" + getType().getName()\n-                                                  + \"> is already bound\");\n-        }\n-        return super.bind(t);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Scoped.java","additions":0,"deletions":528,"binary":false,"changes":528,"status":"deleted"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import java.io.*;\n-import jdk.internal.misc.UnsafeConstants;\n-\n-\/**\n- * TBD\n- *\/\n-public final class ScopedBinding\n-    implements AutoCloseable {\n-\n-    final Object referent;\n-    final Lifetime lifetime;\n-\n-    final Object prev;\n-\n-    static String cannotBindMsg(Object obj, Class<?> klass) {\n-        return \"Cannot bind \" + obj.getClass().getName() + \" to \" + klass.getName();\n-    }\n-\n-    \/**\n-     * TBD\n-     * @param v TBD\n-     * @param t TBD\n-     * @param prev TBD\n-     *\/\n-    ScopedBinding(Scoped<?> v, Object t, Object prev, Lifetime lifetime) {\n-        if (t != null && !v.getType().isInstance(t))\n-            throw new ClassCastException(cannotBindMsg(t, v.getType()));\n-        this.lifetime = lifetime;\n-        this.prev = prev;\n-        this.referent = v;\n-    }\n-\n-    \/**\n-     * TBD\n-     * @param v TBD\n-     * @param t TBD\n-     * @param prev TBD\n-     *\/\n-    ScopedBinding(LightweightThreadLocal<?> v, Object t, Object prev, Lifetime lifetime) {\n-        if (t != null && !v.getType().isInstance(t))\n-            throw new ClassCastException(cannotBindMsg(t, v.getType()));\n-        this.lifetime = lifetime;\n-        this.prev = prev;\n-        this.referent = v;\n-    }\n-\n-    \/**\n-     * TBD\n-     *\/\n-    public final void close() {\n-        Scoped.release(this.referent, prev);\n-        lifetime.close();\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedBinding.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-class ScopedMap {\n-\n-    Object[] tab = new Object[16];\n-\n-    int size;\n-\n-    static final Object NULL_PLACEHOLDER = new Object();\n-\n-    private static final int MAXIMUM_CAPACITY = 1 << 29;\n-\n-    \/**\n-     * Circularly traverses table of size len.\n-     *\/\n-    private static int nextKeyIndex(int i, int len) {\n-        return (i + 2 < len ? i + 2 : 0);\n-    }\n-\n-    private static int hash(Object key, int len) {\n-        return hash(key.hashCode(), len);\n-    }\n-\n-    private static int hash(long k, int len) {\n-        k <<= 1;\n-        return (int)k & (len - 1);\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public Object get(long k, Object key) {\n-        int len = tab.length;\n-        int i = hash(k, len);\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == key)\n-                return tab[i + 1];\n-            if (item == null)\n-                return NULL_PLACEHOLDER;;\n-            i = nextKeyIndex(i, len);\n-        }\n-    }\n-\n-    @SuppressWarnings(value = {\"unchecked\", \"rawtypes\"})  \/\/ one map has entries for all types <T>\n-    public Object put(long k, Object key, Object value) {\n-        checkInUse();\n-\n-        retryAfterResize: for (;;) {\n-            final int len = tab.length;\n-            int i = hash(k, len);\n-\n-            for (Object item; (item = tab[i]) != null;\n-                 i = nextKeyIndex(i, len)) {\n-                if (item == key) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    Object oldValue = tab[i + 1];\n-                    tab[i + 1] = value;\n-                    return oldValue;\n-                }\n-            }\n-\n-            final int s = size + 1;\n-            \/\/ Use optimized form of 3 * s.\n-            \/\/ Next capacity is len, 2 * current capacity.\n-            if (s + (s << 1) > len && resize(len))\n-                continue retryAfterResize;\n-\n-            tab[i] = key;\n-            tab[i + 1] = value;\n-            size = s;\n-            return NULL_PLACEHOLDER;\n-        }\n-    }\n-\n-    private void checkInUse() {\n-        if (Thread.currentThread().observers() != 0) {\n-            throw new LifetimeError();\n-        }\n-    }\n-\n-    Object remove(long k, Object key) {\n-        checkInUse();\n-        int len = tab.length;\n-        int i = hash(k, len);\n-\n-        while (true) {\n-            Object item = tab[i];\n-            if (item == key) {\n-                size--;\n-                Object oldValue = tab[i + 1];\n-                tab[i] = null;\n-                tab[i + 1] = null;\n-                closeDeletion(i);\n-                return oldValue;\n-            }\n-            if (item == null)\n-                throw new RuntimeException(\"not bound\");\n-            i = nextKeyIndex(i, len);\n-        }\n-    }\n-\n-    private void closeDeletion(int d) {\n-        \/\/ Adapted from Knuth Section 6.4 Algorithm R\n-        int len = tab.length;\n-\n-        \/\/ Look for items to swap into newly vacated slot\n-        \/\/ starting at index immediately following deletion,\n-        \/\/ and continuing until a null slot is seen, indicating\n-        \/\/ the end of a run of possibly-colliding keys.\n-        Object item;\n-        for (int i = nextKeyIndex(d, len); (item = tab[i]) != null;\n-             i = nextKeyIndex(i, len) ) {\n-            \/\/ The following test triggers if the item at slot i (which\n-            \/\/ hashes to be at slot r) should take the spot vacated by d.\n-            \/\/ If so, we swap it in, and then continue with d now at the\n-            \/\/ newly vacated i.  This process will terminate when we hit\n-            \/\/ the null slot at the end of this run.\n-            \/\/ The test is messy because we are using a circular table.\n-            int r = hash(tab[i], len);\n-            if ((i < r && (r <= d || d <= i)) || (r <= d && d <= i)) {\n-                tab[d] = item;\n-                tab[d + 1] = tab[i + 1];\n-                tab[i] = null;\n-                tab[i + 1] = null;\n-                d = i;\n-            }\n-        }\n-    }\n-\n-\n-    private boolean resize(int newCapacity) {\n-        assert (newCapacity & -newCapacity) == newCapacity; \/\/ power of 2\n-        int newLength = newCapacity * 2;\n-\n-        final Object[] oldTable = tab;\n-        int oldLength = oldTable.length;\n-        if (oldLength == 2 * MAXIMUM_CAPACITY) { \/\/ can't expand any further\n-            if (size == MAXIMUM_CAPACITY - 1)\n-                throw new IllegalStateException(\"Capacity exhausted.\");\n-            return false;\n-        }\n-        if (oldLength >= newLength)\n-            return false;\n-\n-        Object[] newTable = new Object[newLength];\n-\n-        for (int j = 0; j < oldLength; j += 2) {\n-            Object key = oldTable[j];\n-            if (key != null) {\n-                Object value = oldTable[j+1];\n-                oldTable[j] = null;\n-                oldTable[j + 1] = null;\n-                int i = hash(key, newLength);\n-                while (newTable[i] != null)\n-                    i = nextKeyIndex(i, newLength);\n-                newTable[i] = key;\n-                newTable[i + 1] = value;\n-            }\n-        }\n-        tab = newTable;\n-        return true;\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedMap.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -2334,12 +2334,0 @@\n-\n-            public void unsafeSetLifetime(Thread thread, Lifetime lt) {\n-                thread.unsafeSetLifetime(lt);\n-            }\n-\n-            public void addObserver(Thread thread) {\n-                    thread.parentThread.addObserver();\n-            }\n-\n-            public void removeObserver(Thread thread) {\n-                thread.parentThread.removeObserver();\n-            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-\/**\n- * TBD\n- * A TemporalResource is a Thing.\n- *\/\n-public abstract class TemporalResource implements AutoCloseable {\n-    private final Lifetime lt;\n-\n-   \/**\n-     * TBD\n-     *\/\n-    protected TemporalResource() { lt = Lifetime.start(); }\n-\n-   \/**\n-     * TBD\n-     *\/\n-    protected void checkAccess() {\n-        if (lt == null || Scoped.Cache.isActive(lt)) return;\n-        if (!Thread.currentThread().isActive(lt))\n-            throw new LifetimeError();\n-    }\n-\n-   \/**\n-     * TBD\n-     *\/\n-     public void close() { lt.close(); }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/TemporalResource.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -271,26 +271,0 @@\n-    \/\/ A simple (not very) random string of bits to use when evicting\n-    \/\/ cache entries.\n-    int victims\n-        = 0b1100_1001_0000_1111_1101_1010_1010_0010;\n-\n-    \/\/ V2:\n-    private ScopedMap scopedMap;\n-    private int observers = 0;\n-\n-    final ScopedMap scopedMap() {\n-        if (Lifetime.version == Lifetime.Version.V1) {\n-            return currentLifetime().scopedMap();\n-        } else {\n-            if (this.scopedMap == null) {\n-                this.scopedMap = new ScopedMap();\n-            }\n-            return this.scopedMap;\n-        }\n-    }\n-\n-    final ScopedMap scopedMapOrNull () {\n-        return this.scopedMap;\n-    }\n-\n-    \/\/ end Scoped support\n-\n@@ -3086,135 +3060,0 @@\n-    Thread parentThread;\n-    Lifetime lifetime; \/\/ the current innermost lifetime (or null)\n-    int depth;\n-    int parentDepth;\n-\n-    \/**\n-     * TBD\n-     *\n-     * @return Lifetime\n-     *\/\n-    public Lifetime currentLifetime() {\n-        return lifetime;\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @param lt a Lifetime\n-     *\/\n-    \/\/ V1:\n-    public void pushLifetime(Lifetime lt) {\n-        assert lt.parent == this.lifetime;\n-        this.lifetime = lt;\n-    }\n-\n-    \/\/ V2:\n-    Lifetime pushLifetime() {\n-        assert this == Thread.currentThread();\n-        var newDepth = ++depth;\n-        return new Lifetime(this, newDepth);\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @param lt a Lifetime\n-     *\/\n-    public void popLifetime(Lifetime lt) {\n-        if (Lifetime.version == Lifetime.Version.V1) {\n-            if (this.lifetime != lt)\n-                throw new LifetimeError(\"lt: [\" + lt + \"] this: [\" + this.currentLifetime() + \"]\");\n-            this.lifetime = lt.parent;\n-        } else {\n-            assert lt.thread == this;\n-            if (this != Thread.currentThread()) throw new LifetimeError();\n-            if (lt.depth() != this.depth) throw new LifetimeError();\n-            assert depth > parentDepth;\n-            depth--;\n-        }\n-        Scoped.Cache.clearActive();\n-    }\n-\n-    \/**\n-     * TBD\n-     *\n-     * @param lt a Lifetime\n-     * @return Previous lifetime\n-     *\/\n-    Lifetime unsafeSetLifetime(Lifetime lt) {\n-        if (Lifetime.version == Lifetime.Version.V1) {\n-            var old = this.lifetime;\n-            this.lifetime = lt;\n-            return old;\n-        } else {\n-            assert (!isAlive() && lt.thread == Thread.currentThread())\n-                    || this == Thread.currentThread(); \/\/ this ensures that depth does not concurrently change here\n-            assert depth == parentDepth;\n-\n-            var old = new Lifetime(parentThread, parentDepth);\n-            lt.thread.addObserver();\n-            this.parentThread = lt.thread;\n-            this.parentDepth = lt.depth();\n-            this.depth = parentDepth;\n-            this.lifetime = lt;\n-            return old;\n-        }\n-    }\n-\n-    boolean isActive(Lifetime lt) {\n-        if (lt == null || Scoped.Cache.isActive(lt)) return true;\n-        if (Lifetime.version == Lifetime.Version.V1) {\n-            for (var x = this.lifetime; x != null; x = x.parent) {\n-                if (x == lt) {\n-                    Scoped.Cache.setActive(lt);\n-                    return true;\n-                }\n-            }\n-            return false;\n-        } else {\n-            assert this == Thread.currentThread();\n-\n-            \/\/ the thread that closes the lifetime must be the thread that owns it\n-            \/\/ and the thread that sets this thread's parent must be that thread\n-            \/\/ so either we're on the right thread and we'll see depth = MAX_VALUE due to mem ordering,\n-            \/\/ or we're on a wrong thread, in which case the parent search will fail; either way, this will fail.\n-            if (lt.thread == this) {\n-                boolean result = lt.depth() <= this.depth;\n-                if (Scoped.Cache.CACHE_LIFETIMES) {\n-                    if (result) {\n-                        Scoped.Cache.setActive(lt);\n-                    }\n-                }\n-                return result;\n-            }\n-            for (Thread t = this; t != null; t = t.parentThread) {\n-                if (Scoped.Cache.CACHE_LIFETIMES) {\n-                    if (lt.thread == t.parentThread) {\n-                        boolean result = lt.depth() <= t.parentDepth;\n-                        if (result) {\n-                            Scoped.Cache.setActive(lt);\n-                        }\n-                        return result;\n-                    }\n-                } else {\n-                    if (lt.thread == t.parentThread) return lt.depth() <= t.parentDepth;\n-                }\n-            }\n-            return false;\n-        }\n-    }\n-\n-    synchronized void addObserver() {\n-        observers++;\n-        assert(observers > 0);\n-    }\n-\n-    synchronized void removeObserver() {\n-        assert(observers > 0);\n-        observers--;\n-    }\n-\n-    synchronized int observers() {\n-        return observers;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -346,12 +346,0 @@\n-\n-    \/**\n-     * TBD\n-     *\n-     * @param <T>   TBD\n-     * @param klass TBD\n-     * @return TBD\n-     *\/\n-    public static <T> LightweightThreadLocal<T> forType(Class<T> klass) {\n-        return new LightweightThreadLocal<T>(klass);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadLocal.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Red Hat, Inc. and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-\/**\n- * TBD\n- *\/\n-public class UnboundScopedException extends RuntimeException {\n-    @java.io.Serial\n-        static final long serialVersionUID = 5971360953913194977L;\n-\n-    \/**\n-     * Constructs a new exception with the specified detail message.\n-     * @param   message   the detail message. The detail message is saved for\n-     *          later retrieval by the {@link #getMessage()} method.\n-     *\/\n-    public UnboundScopedException(String message) {\n-        super(message);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/UnboundScopedException.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -59,1 +59,0 @@\n-    \/\/private final Lifetime lifetime = Lifetime.start();   \/\/ experimental\n@@ -173,1 +172,0 @@\n-        \/\/JLA.unsafeSetLifetime(thread, lifetime);  \/\/ experimental\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadExecutor.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-    \n+\n@@ -337,1 +337,1 @@\n-    \n+\n@@ -395,19 +395,0 @@\n-\n-    \/**\n-     * Set the lifetime of a thread to lt.\n-     * @param thread\n-     * @param lt\n-     *\/\n-    void unsafeSetLifetime(Thread thread, Lifetime lt);\n-\n-    \/**\n-     * Add an observer to the parent thread.\n-     * @param thread\n-     *\/\n-    void addObserver(Thread thread);\n-\n-    \/**\n-     * Remove an observer from the parent thread.\n-     * @param thread\n-     *\/\n-    void removeObserver(Thread thread);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":2,"deletions":21,"binary":false,"changes":23,"status":"modified"}]}