{"files":[{"patch":"@@ -596,0 +596,3 @@\n+  # Allow preview features in microbenchmarks\n+  $1_JMH_JVM_ARGS += --enable-preview\n+\n","filename":"make\/RunTests.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -97,2 +97,2 @@\n-    JAVAC_FLAGS := --add-exports java.base\/sun.security.util=ALL-UNNAMED, \\\n-    JAVA_FLAGS := --add-modules jdk.unsupported --limit-modules java.management, \\\n+    JAVAC_FLAGS := --add-exports java.base\/sun.security.util=ALL-UNNAMED --enable-preview, \\\n+    JAVA_FLAGS := --add-modules jdk.unsupported --limit-modules java.management --enable-preview, \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -151,0 +151,110 @@\n+\n+        \/**\n+         * Runs an operation with this snapshot of inheritable scoped variables.\n+         *\n+         * @param op the operation to run\n+         * @param s the Snapshot. May be null.\n+         *\/\n+        public void run(Runnable op) {\n+            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+            if (prev == this) {\n+                op.run();\n+                return;\n+            }\n+            var cache = Thread.scopeLocalCache();\n+            Cache.invalidate();\n+            try {\n+                Thread.currentThread().inheritableScopeLocalBindings = this;\n+                op.run();\n+            } finally {\n+                Thread.currentThread().inheritableScopeLocalBindings = prev;\n+                Thread.setScopeLocalCache(cache);\n+            }\n+        }\n+\n+        \/**\n+         * Runs a value-returning operation with a snapshot of inheritable\n+         * scoped variables.\n+         *\n+         * @param op the operation to run\n+         * @param s the Snapshot. May be null.\n+         * @param <R> the type of the result of the function\n+         * @return the result\n+         * @throws Exception if the operation completes with an exception\n+         *\/\n+        public <R> R call(Callable<R> op) throws Exception {\n+            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+            if (prev == this) {\n+                return op.call();\n+            }\n+            var cache = Thread.scopeLocalCache();\n+            Cache.invalidate();\n+            try {\n+                Thread.currentThread().inheritableScopeLocalBindings = this;\n+                return op.call();\n+            } finally {\n+                Thread.currentThread().inheritableScopeLocalBindings = prev;\n+                Thread.setScopeLocalCache(cache);\n+            }\n+        }\n+    }\n+\n+    private static final class EmptySnapshot extends Snapshot {\n+        private EmptySnapshot() {\n+            super(null, null, (short)0);\n+        }\n+\n+        static final Snapshot SINGLETON = new EmptySnapshot();\n+\n+        static final Snapshot getInstance() {\n+            return SINGLETON;\n+        }\n+\n+        \/**\n+         * Runs a value-returning operation with a snapshot of inheritable\n+         * scoped variables.\n+         *\n+         * @param op the operation to run\n+         * @param s the Snapshot. May be null.\n+         * @param <R> the type of the result of the function\n+         * @return the result\n+         * @throws Exception if the operation completes with an exception\n+         *\/\n+        public final <R> R call(Callable<R> op) throws Exception {\n+            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+            if (prev == null) {\n+                return op.call();\n+            }\n+            var cache = Thread.scopeLocalCache();\n+            Cache.invalidate();\n+            try {\n+                Thread.currentThread().inheritableScopeLocalBindings = null;\n+                return op.call();\n+            } finally {\n+                Thread.currentThread().inheritableScopeLocalBindings = prev;\n+                Thread.setScopeLocalCache(cache);\n+            }\n+        }\n+\n+        \/**\n+         * Runs an operation with this snapshot of inheritable scoped variables.\n+         *\n+         * @param op the operation to run\n+         * @param s the Snapshot. May be null.\n+         *\/\n+        public final void run(Runnable op) {\n+            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+            if (prev == null) {\n+                op.run();\n+                return;\n+            }\n+            var cache = Thread.scopeLocalCache();\n+            Cache.invalidate();\n+            try {\n+                Thread.currentThread().inheritableScopeLocalBindings = null;\n+                op.run();\n+            } finally {\n+                Thread.currentThread().inheritableScopeLocalBindings = prev;\n+                Thread.setScopeLocalCache(cache);\n+            }\n+        }\n@@ -361,13 +471,1 @@\n-        var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-        if (prev == s) {\n-            return op.call();\n-        }\n-        var cache = Thread.scopeLocalCache();\n-        Cache.invalidate();\n-        try {\n-            Thread.currentThread().inheritableScopeLocalBindings = s;\n-            return op.call();\n-        } finally {\n-            Thread.currentThread().inheritableScopeLocalBindings = prev;\n-            Thread.setScopeLocalCache(cache);\n-        }\n+        return s.call(op);\n@@ -383,14 +481,1 @@\n-        var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-        if (prev == s) {\n-            op.run();\n-            return;\n-        }\n-        var cache = Thread.scopeLocalCache();\n-        Cache.invalidate();\n-        try {\n-            Thread.currentThread().inheritableScopeLocalBindings = s;\n-            op.run();\n-        } finally {\n-            Thread.currentThread().inheritableScopeLocalBindings = prev;\n-            Thread.setScopeLocalCache(cache);\n-        }\n+        s.run(op);\n@@ -574,1 +659,1 @@\n-     * @return a \"snapshot\" of the currently-bound inheritable scoped variables. May be null.\n+     * @return a \"snapshot\" of the currently-bound inheritable scoped variables.\n@@ -577,1 +662,10 @@\n-        return Thread.currentThread().inheritableScopeLocalBindings;\n+        Thread thread = Thread.currentThread();\n+        var bindings = thread.inheritableScopeLocalBindings;\n+        if (bindings == null) {\n+            \/\/ A one-time per thread event. Maybe we should more\n+            \/\/ simply pre-initialize the bindings to an instance of\n+            \/\/ EmptySnapshot at thread creation time.\n+            return (thread.inheritableScopeLocalBindings = EmptySnapshot.getInstance());\n+        } else {\n+            return bindings;\n+        }\n@@ -706,1 +800,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopeLocal.java","additions":124,"deletions":30,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.misc.Unsafe;\n@@ -109,0 +110,5 @@\n+    \/\/ Unsafe mechanics\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+    private static final long NONINHERITABLESCOPELOCALBINDINGS\n+            = U.objectFieldOffset(Thread.class, \"noninheritableScopeLocalBindings\");\n+\n@@ -112,1 +118,5 @@\n-        return super.newThread(task);\n+        var newThread = super.newThread(task);\n+        \/\/ Question: should this inheritance be gated by Thread.NO_INHERIT_SCOPE_LOCALS ?\n+        U.putReference(newThread, NONINHERITABLESCOPELOCALBINDINGS,\n+                U.getReference(Thread.currentThread(), NONINHERITABLESCOPELOCALBINDINGS));\n+        return newThread;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredThreadExecutor.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static org.openjdk.bench.java.lang.ScopeLocalsData.*;\n+\n+\/**\n+ * Tests java.lang.ScopeLocal\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations=4, time=1)\n+@Measurement(iterations=10, time=1)\n+@Threads(1)\n+@Fork(value = 1,\n+        jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.java.lang.ScopeLocalsExecutorService\", \"-Djmh.executor=CUSTOM\", \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class ScopeLocals {\n+\n+    \/\/ Test 1: make sure ScopeLocal.get() is hoisted out of loops.\n+\n+    @Benchmark\n+    public void thousandAdds_ScopeLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopeLocalsData.sl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    @Benchmark\n+    public void thousandAdds_ThreadLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopeLocalsData.tl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ Test 2: stress the ScopeLocal cache.\n+    \/\/ The idea here is to use a bunch of bound values cyclically, which\n+    \/\/ stresses the ScopeLocal cache.\n+\n+    int combine(int n, int i1, int i2, int i3, int i4, int i5, int i6) {\n+        return n + ((i1 ^ i2 >>> 6) + (i3 << 7) + i4 - i5 | i6);\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ScopeLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ThreadLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Test 3: The cost of bind, then get\n+    \/\/ This is the worst case for ScopeLocals because we have to create\n+    \/\/ a binding, link it in, then search the current bindings. In addition, we\n+    \/\/ create a cache entry for the bound value, then we immediately have to\n+    \/\/ destroy it.\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ScopeLocal() throws Exception {\n+        return ScopeLocal.where(sl1, 42, sl1::get);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(42);\n+            return tl1.get();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ This has no exact equivalent in ScopeLocal, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(42);\n+        return tl1.get();\n+    }\n+\n+    \/\/ Test 4: The cost of binding, but not using the any result\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ScopeLocal() throws Exception {\n+        return ScopeLocal.where(sl1, 42, this::getClass);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(42);\n+            return this.getClass();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ Simply set a ThreadLocal so that the caller can see it\n+    \/\/ This has no exact equivalent in ScopeLocal, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(42);\n+    }\n+\n+    \/\/ This is the closest I can think of to setNoRemove_ThreadLocal in that it\n+    \/\/ returns a value in a ScopeLocal container. The container must already\n+    \/\/ be bound to an AtomicReference for this to work.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ScopeLocal() throws Exception {\n+        sl_atomicRef.get().setPlain(42);\n+    }\n+\n+    \/\/ Test 5: A simple counter\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ScopeLocal() {\n+        sl_atomicInt.get().setPlain(\n+                sl_atomicInt.get().getPlain() + 1);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ThreadLocal() {\n+        \/\/ Very slow\n+        \/\/ tl1.set(tl1.get() + 1);\n+        var ctr = tl_atomicInt.get();\n+        ctr.setPlain(ctr.getPlain() + 1);\n+    }\n+\n+    \/\/ Test 6: Measure the cost of Snapshotting\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public ScopeLocal.Snapshot getSnapshot_ScopeLocal() {\n+        return ScopeLocal.snapshot();\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void runWithSnapshot_ScopeLocal() {\n+        aSnapshot.run(() -> { });\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object\n+    callWithSnapshot_ScopeLocal() throws Exception{\n+        return aSnapshot.call(() -> getClass());\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object callandGetWithSnapshot_ScopeLocal() throws Exception{\n+        return aSnapshot.call(sl1::get);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopeLocals.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+@SuppressWarnings(\"preview\")\n+public class ScopeLocalsData {\n+\n+    static final ScopeLocal<Integer> sl1 = ScopeLocal.forType(Integer.class);\n+    static final ThreadLocal<Integer> tl1 = new ThreadLocal<>();\n+\n+    static final ScopeLocal<Integer> sl2 = ScopeLocal.forType(Integer.class);\n+    static final ScopeLocal<Integer> sl3 = ScopeLocal.forType(Integer.class);\n+    static final ScopeLocal<Integer> sl4 = ScopeLocal.forType(Integer.class);\n+    static final ScopeLocal<Integer> sl5 = ScopeLocal.forType(Integer.class);\n+    static final ScopeLocal<Integer> sl6 = ScopeLocal.forType(Integer.class);\n+    static final ScopeLocal<AtomicInteger> sl_atomicInt = ScopeLocal.forType(AtomicInteger.class);\n+\n+    static final ScopeLocal<AtomicReference<Integer>> sl_atomicRef = ScopeLocal.forType(AtomicReference.class);\n+\n+    static final ThreadLocal<Integer> tl2 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl3 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl4 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl5 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl6 = new ThreadLocal<>();\n+    static final ThreadLocal<AtomicInteger> tl_atomicInt = new ThreadLocal<>();\n+\n+    static final ScopeLocal.Snapshot aSnapshot;\n+\n+    static {\n+        try {\n+            aSnapshot = ScopeLocal.where(sl1, 99,\n+                    () -> ScopeLocal.snapshot());\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    public static void run(Runnable action) {\n+        try {\n+            tl1.set(42); tl2.set(2); tl3.set(3); tl4.set(4); tl5.set(5); tl6.set(6);\n+            tl_atomicInt.set(new AtomicInteger());\n+            ScopeLocal.where(sl1, 42).where(sl2, 2).where(sl3, 3)\n+                    .where(sl4, 4).where(sl5, 5).where(sl6, 6)\n+                    .where(sl_atomicInt, new AtomicInteger())\n+                    .where(sl_atomicRef, new AtomicReference<>())\n+                    .run(action);\n+        } finally {\n+            tl1.remove(); tl2.remove(); tl3.remove(); tl4.remove(); tl5.remove(); tl6.remove();\n+            tl_atomicInt.remove();\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopeLocalsData.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.*;\n+\n+public class ScopeLocalsExecutorService extends ThreadPoolExecutor {\n+    public ScopeLocalsExecutorService(int corePoolSize, String prefix) {\n+        super(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),\n+              new AThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n+    }\n+}\n+\n+class AThreadFactory implements ThreadFactory {\n+    public Thread newThread(Runnable action) {\n+        return new Thread() {\n+            public void run() {\n+                ScopeLocalsData.run(action);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopeLocalsExecutorService.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}