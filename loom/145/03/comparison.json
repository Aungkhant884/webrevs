{"files":[{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_CONTINUATIONENTRY_AARCH64_INLINE_HPP\n+#define CPU_AARCH64_CONTINUATIONENTRY_AARCH64_INLINE_HPP\n+\n+#include \"runtime\/continuationEntry.hpp\"\n+\n+#include \"code\/codeCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+inline frame ContinuationEntry::to_frame() const {\n+  static CodeBlob* cb = CodeCache::find_blob(entry_pc());\n+  return frame(entry_sp(), entry_sp(), entry_fp(), entry_pc(), cb);\n+}\n+\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n+  return (intptr_t*)((address)this + size());\n+}\n+\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+  intptr_t** fp = (intptr_t**)(bottom_sender_sp() - frame::sender_sp_offset);\n+  frame::update_map_with_saved_link(map, fp);\n+}\n+\n+\n+#endif \/\/  CPU_AARCH64_CONTINUATIONENTRY_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationEntry_aarch64.inline.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef CPU_AARCH64_CONTINUATION_FREEZE_THAW_AARCH64_INLINE_HPP\n-#define CPU_AARCH64_CONTINUATION_FREEZE_THAW_AARCH64_INLINE_HPP\n+#ifndef CPU_AARCH64_CONTINUATIONFREEZETHAW_AARCH64_INLINE_HPP\n+#define CPU_AARCH64_CONTINUATIONFREEZETHAW_AARCH64_INLINE_HPP\n@@ -33,0 +33,12 @@\n+\n+inline void patch_callee_link(const frame& f, intptr_t* fp) {\n+  DEBUG_ONLY(intptr_t* orig = *ContinuationHelper::Frame::callee_link_address(f));\n+  *ContinuationHelper::Frame::callee_link_address(f) = fp;\n+}\n+\n+inline void patch_callee_link_relative(const frame& f, intptr_t* fp) {\n+  intptr_t* la = (intptr_t*)ContinuationHelper::Frame::callee_link_address(f);\n+  intptr_t new_value = fp - la;\n+  *la = new_value;\n+}\n+\n@@ -278,1 +290,1 @@\n-#endif \/\/ CPU_AARCH64_CONTINUATION_FREEZE_THAW_AARCH64_INLINE_HPP\n+#endif \/\/ CPU_AARCH64_CONTINUATIONFREEZETHAW_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationFreezeThaw_aarch64.inline.hpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n@@ -42,11 +43,0 @@\n-static void patch_callee_link(const frame& f, intptr_t* fp) {\n-  DEBUG_ONLY(intptr_t* orig = *ContinuationHelper::Frame::callee_link_address(f));\n-  *ContinuationHelper::Frame::callee_link_address(f) = fp;\n-}\n-\n-static void patch_callee_link_relative(const frame& f, intptr_t* fp) {\n-  intptr_t* la = (intptr_t*)ContinuationHelper::Frame::callee_link_address(f);\n-  intptr_t new_value = fp - la;\n-  *la = new_value;\n-}\n-\n@@ -73,9 +63,0 @@\n-intptr_t* ContinuationEntry::entry_fp() const {\n-  return (intptr_t*)((address)this + size());\n-}\n-\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n-  intptr_t** fp = (intptr_t**)(bottom_sender_sp() - frame::sender_sp_offset);\n-  frame::update_map_with_saved_link(map, fp);\n-}\n-\n@@ -90,5 +71,0 @@\n-frame ContinuationEntry::to_frame() const {\n-  static CodeBlob* cb = CodeCache::find_blob(entry_pc());\n-  return frame(entry_sp(), entry_sp(), entry_fp(), entry_pc(), cb);\n-}\n-\n@@ -96,1 +72,1 @@\n-void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* entry) {\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* entry) {\n@@ -101,1 +77,1 @@\n-void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n@@ -120,1 +96,1 @@\n-address* ContinuationHelper::Frame::return_pc_address(const frame& f) {\n+inline address* ContinuationHelper::Frame::return_pc_address(const frame& f) {\n@@ -124,1 +100,1 @@\n-address* ContinuationHelper::InterpretedFrame::return_pc_address(const frame& f) {\n+inline address* ContinuationHelper::InterpretedFrame::return_pc_address(const frame& f) {\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":5,"deletions":29,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_CONTINUATIONENTRY_ARM_INLINE_HPP\n+#define CPU_ARM_CONTINUATIONENTRY_ARM_INLINE_HPP\n+\n+\n+#include \"runtime\/continuationEntry.hpp\"\n+\n+\/\/ TODO: Implement\n+\n+inline frame ContinuationEntry::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_ARM_CONTINUATIONENTRY_ARM_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/arm\/continuationEntry_arm.inline.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"","filename":"src\/hotspot\/cpu\/arm\/continuationFreezeThaw_arm.inline.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/arm\/continuation_arm.inline.hpp","status":"renamed"},{"patch":"@@ -30,4 +30,0 @@\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n@@ -36,14 +32,0 @@\n-frame ContinuationEntry::to_frame() const {\n-  Unimplemented();\n-  return frame();\n-}\n-\n-intptr_t* ContinuationEntry::entry_fp() const {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n-  Unimplemented();\n-}\n-\n@@ -79,1 +61,1 @@\n-void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n@@ -84,1 +66,1 @@\n-void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n","filename":"src\/hotspot\/cpu\/arm\/continuationHelper_arm.inline.hpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_CONTINUATIONENTRY_PPC_INLINE_HPP\n+#define CPU_PPC_CONTINUATIONENTRY_PPC_INLINE_HPP\n+\n+#include \"runtime\/continuationEntry.hpp\"\n+\n+\/\/ TODO: Implement\n+\n+inline frame ContinuationEntry::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_PPC_CONTINUATIONENTRY_PPC_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/continuationEntry_ppc.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"","filename":"src\/hotspot\/cpu\/ppc\/continuationFreezeThaw_ppc.inline.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/ppc\/continuation_ppc.inline.hpp","status":"renamed"},{"patch":"@@ -30,20 +30,0 @@\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/ TODO: Implement\n-\n-frame ContinuationEntry::to_frame() const {\n-  Unimplemented();\n-  return frame();\n-}\n-\n-intptr_t* ContinuationEntry::entry_fp() const {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n-  Unimplemented();\n-}\n-\n@@ -80,1 +60,1 @@\n-void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n@@ -85,1 +65,1 @@\n-void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_CONTINUATIONENTRY_S390_INLINE_HPP\n+#define CPU_S390_CONTINUATIONENTRY_S390_INLINE_HPP\n+\n+#include \"runtime\/continuationEntry.hpp\"\n+\n+\/\/ TODO: Implement\n+\n+inline frame ContinuationEntry::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_S390_CONTINUATIONENTRY_S390_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/s390\/continuationEntry_s390.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"","filename":"src\/hotspot\/cpu\/s390\/continuationFreezeThaw_s390.inline.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/s390\/continuation_s390.inline.hpp","status":"renamed"},{"patch":"@@ -30,4 +30,0 @@\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n@@ -36,14 +32,0 @@\n-frame ContinuationEntry::to_frame() const {\n-  Unimplemented();\n-  return frame();\n-}\n-\n-intptr_t* ContinuationEntry::entry_fp() const {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n-  Unimplemented();\n-}\n-\n@@ -79,1 +61,1 @@\n-void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n@@ -84,1 +66,1 @@\n-void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n","filename":"src\/hotspot\/cpu\/s390\/continuationHelper_s390.inline.hpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_CONTINUATIONENTRY_X86_INLINE_HPP\n+#define CPU_X86_CONTINUATIONENTRY_X86_INLINE_HPP\n+\n+#include \"runtime\/continuationEntry.hpp\"\n+\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+inline frame ContinuationEntry::to_frame() const {\n+  static CodeBlob* cb = CodeCache::find_blob(entry_pc());\n+  return frame(entry_sp(), entry_sp(), entry_fp(), entry_pc(), cb);\n+}\n+\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n+  return (intptr_t*)((address)this + size());\n+}\n+\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+  intptr_t** fp = (intptr_t**)(bottom_sender_sp() - frame::sender_sp_offset);\n+  frame::update_map_with_saved_link(map, fp);\n+}\n+\n+#endif \/\/ CPU_X86_CONTINUATIONENTRY_X86_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/x86\/continuationEntry_x86.inline.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -25,2 +25,2 @@\n-#ifndef CPU_X86_CONTINUATION_FREEZE_THAW_X86_INLINE_HPP\n-#define CPU_X86_CONTINUATION_FREEZE_THAW_X86_INLINE_HPP\n+#ifndef CPU_X86_CONTINUATIONFREEZETHAW_X86_INLINE_HPP\n+#define CPU_X86_CONTINUATIONFREEZETHAW_X86_INLINE_HPP\n@@ -33,1 +33,1 @@\n-static void patch_callee_link(const frame& f, intptr_t* fp) {\n+inline void patch_callee_link(const frame& f, intptr_t* fp) {\n@@ -37,1 +37,1 @@\n-static void patch_callee_link_relative(const frame& f, intptr_t* fp) {\n+inline void patch_callee_link_relative(const frame& f, intptr_t* fp) {\n@@ -43,5 +43,0 @@\n-frame ContinuationEntry::to_frame() const {\n-  static CodeBlob* cb = CodeCache::find_blob(entry_pc());\n-  return frame(entry_sp(), entry_sp(), entry_fp(), entry_pc(), cb);\n-}\n-\n@@ -285,1 +280,1 @@\n-#endif \/\/ CPU_X86_CONTINUATION_FREEZE_THAW_X86_INLINE_HPP\n+#endif \/\/ CPU_X86_CONTINUATIONFREEZE_THAW_X86_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/x86\/continuationFreezeThaw_x86.inline.hpp","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n@@ -62,9 +63,0 @@\n-intptr_t* ContinuationEntry::entry_fp() const {\n-  return (intptr_t*)((address)this + size());\n-}\n-\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n-  intptr_t** fp = (intptr_t**)(bottom_sender_sp() - frame::sender_sp_offset);\n-  frame::update_map_with_saved_link(map, fp);\n-}\n-\n@@ -79,1 +71,1 @@\n-void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* entry) {\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* entry) {\n@@ -84,1 +76,1 @@\n-void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n@@ -103,1 +95,1 @@\n-address* ContinuationHelper::Frame::return_pc_address(const frame& f) {\n+inline address* ContinuationHelper::Frame::return_pc_address(const frame& f) {\n@@ -107,1 +99,1 @@\n-address* ContinuationHelper::InterpretedFrame::return_pc_address(const frame& f) {\n+inline address* ContinuationHelper::InterpretedFrame::return_pc_address(const frame& f) {\n","filename":"src\/hotspot\/cpu\/x86\/continuationHelper_x86.inline.hpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_CONTINUATIONENTRY_ZERO_INLINE_HPP\n+#define CPU_ZERO_CONTINUATIONENTRY_ZERO_INLINE_HPP\n+\n+#include \"runtime\/continuationEntry.hpp\"\n+\n+\/\/ TODO: Implement\n+\n+inline frame ContinuationEntry::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_ZERO_CONTINUATIONENTRY_ZERO_INLINE_HPP\n+\n","filename":"src\/hotspot\/cpu\/zero\/continuationEntry_zero.inline.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"","filename":"src\/hotspot\/cpu\/zero\/continuationFreezeThaw_zero.inline.hpp","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/hotspot\/cpu\/zero\/continuation_zero.inline.hpp","status":"renamed"},{"patch":"@@ -30,20 +30,0 @@\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-\/\/ TODO: Implement\n-\n-frame ContinuationEntry::to_frame() const {\n-  Unimplemented();\n-  return frame();\n-}\n-\n-intptr_t* ContinuationEntry::entry_fp() const {\n-  Unimplemented();\n-  return nullptr;\n-}\n-\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n-  Unimplemented();\n-}\n-\n@@ -79,1 +59,1 @@\n-void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n@@ -84,1 +64,1 @@\n-void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n","filename":"src\/hotspot\/cpu\/zero\/continuationHelper_zero.inline.hpp","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+  return 0;\n@@ -151,0 +152,1 @@\n+  return 0;\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/share\/prims\/stackwalk.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,2 +26,4 @@\n-#include \"runtime\/continuation.inline.hpp\"\n-#include \"runtime\/continuationHelper.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/continuationHelper.inline.hpp\"\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n@@ -403,36 +405,0 @@\n-\n-bool ContinuationEntry::assert_entry_frame_laid_out(JavaThread* thread) {\n-  assert(thread->has_last_Java_frame(), \"Wrong place to use this assertion\");\n-\n-  ContinuationEntry* entry = thread->last_continuation();\n-  assert(entry != nullptr, \"\");\n-\n-  intptr_t* unextended_sp = entry->entry_sp();\n-  intptr_t* sp;\n-  if (entry->argsize() > 0) {\n-    sp = entry->bottom_sender_sp();\n-  } else {\n-    sp = unextended_sp;\n-    bool interpreted_bottom = false;\n-    RegisterMap map(thread, false, false, false);\n-    frame f;\n-    for (f = thread->last_frame();\n-         !f.is_first_frame() && f.sp() <= unextended_sp && !Continuation::is_continuation_enterSpecial(f);\n-         f = f.sender(&map)) {\n-      interpreted_bottom = f.is_interpreted_frame();\n-    }\n-    assert(Continuation::is_continuation_enterSpecial(f), \"\");\n-    sp = interpreted_bottom ? f.sp() : entry->bottom_sender_sp();\n-  }\n-\n-  assert(sp != nullptr, \"\");\n-  assert(sp <= entry->entry_sp(), \"\");\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n-\n-  if (pc != StubRoutines::cont_returnBarrier()) {\n-    CodeBlob* cb = pc != nullptr ? CodeCache::find_blob(pc) : nullptr;\n-    assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n-  }\n-\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":4,"deletions":38,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"oops\/access.hpp\"\n@@ -127,117 +126,0 @@\n-\/\/ Metadata stored in the continuation entry frame\n-class ContinuationEntry {\n-public:\n-#ifdef ASSERT\n-  int cookie;\n-  static ByteSize cookie_offset() { return byte_offset_of(ContinuationEntry, cookie); }\n-  void verify_cookie() { assert(this->cookie == 0x1234, \"\"); }\n-#endif\n-\n-public:\n-  static int return_pc_offset; \/\/ friend gen_continuation_enter\n-  static void set_enter_nmethod(nmethod* nm); \/\/ friend SharedRuntime::generate_native_wrapper\n-\n-private:\n-  static nmethod* continuation_enter;\n-  static address return_pc;\n-\n-private:\n-  ContinuationEntry* _parent;\n-  oopDesc* _cont;\n-  oopDesc* _chunk;\n-  int _flags;\n-  int _argsize;\n-  intptr_t* _parent_cont_fastpath;\n-  int _parent_held_monitor_count;\n-  uint _pin_count;\n-\n-public:\n-  static ByteSize parent_offset()   { return byte_offset_of(ContinuationEntry, _parent); }\n-  static ByteSize cont_offset()     { return byte_offset_of(ContinuationEntry, _cont); }\n-  static ByteSize chunk_offset()    { return byte_offset_of(ContinuationEntry, _chunk); }\n-  static ByteSize flags_offset()    { return byte_offset_of(ContinuationEntry, _flags); }\n-  static ByteSize argsize_offset()  { return byte_offset_of(ContinuationEntry, _argsize); }\n-  static ByteSize pin_count_offset(){ return byte_offset_of(ContinuationEntry, _pin_count); }\n-  static ByteSize parent_cont_fastpath_offset()      { return byte_offset_of(ContinuationEntry, _parent_cont_fastpath); }\n-  static ByteSize parent_held_monitor_count_offset() { return byte_offset_of(ContinuationEntry, _parent_held_monitor_count); }\n-\n-  static void setup_oopmap(OopMap* map) {\n-    map->set_oop(VMRegImpl::stack2reg(in_bytes(cont_offset())  \/ VMRegImpl::stack_slot_size));\n-    map->set_oop(VMRegImpl::stack2reg(in_bytes(chunk_offset()) \/ VMRegImpl::stack_slot_size));\n-  }\n-\n-public:\n-  static size_t size() { return align_up((int)sizeof(ContinuationEntry), 2*wordSize); }\n-\n-  ContinuationEntry* parent() const { return _parent; }\n-\n-  static address entry_pc() { return return_pc; }\n-  intptr_t* entry_sp() const { return (intptr_t*)this; }\n-  intptr_t* entry_fp() const;\n-\n-  int argsize() const { return _argsize; }\n-  void set_argsize(int value) { _argsize = value; }\n-\n-  bool is_pinned() { return _pin_count > 0; }\n-  bool pin() {\n-    if (_pin_count == UINT_MAX) return false;\n-    _pin_count++;\n-    return true;\n-  }\n-  bool unpin() {\n-    if (_pin_count == 0) return false;\n-    _pin_count--;\n-    return true;\n-  }\n-\n-  intptr_t* parent_cont_fastpath() const { return _parent_cont_fastpath; }\n-  void set_parent_cont_fastpath(intptr_t* x) { _parent_cont_fastpath = x; }\n-\n-  static ContinuationEntry* from_frame(const frame& f);\n-  frame to_frame() const;\n-  void update_register_map(RegisterMap* map) const;\n-  void flush_stack_processing(JavaThread* thread) const;\n-\n-  intptr_t* bottom_sender_sp() const {\n-    intptr_t* sp = entry_sp() - argsize();\n-#ifdef _LP64\n-    sp = align_down(sp, frame::frame_alignment);\n-#endif\n-    return sp;\n-  }\n-\n-  oop cont_oop() const {\n-    oop snapshot = _cont;\n-    return NativeAccess<>::oop_load(&snapshot);\n-  }\n-\n-  oop scope()     const { return Continuation::continuation_scope(cont_oop()); }\n-\n-  oop cont_raw()  const { return _cont; }\n-  oop chunk_raw() const { return _chunk; }\n-\n-  bool is_virtual_thread() const { return _flags != 0; }\n-\n-  static oop cont_oop_or_null(const ContinuationEntry* ce) {\n-    return ce == nullptr ? nullptr : ce->cont_oop();\n-  }\n-\n-#ifndef PRODUCT\n-  void describe(FrameValues& values, int frame_no) const {\n-    address usp = (address)this;\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_offset())),    \"parent\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::cont_offset())),      \"continuation\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::flags_offset())),     \"flags\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::chunk_offset())),     \"chunk\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::argsize_offset())),   \"argsize\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::pin_count_offset())), \"pin_count\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_cont_fastpath_offset())),      \"parent fastpath\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_held_monitor_count_offset())), \"parent held monitor count\");\n-  }\n-#endif\n-\n-#ifdef ASSERT\n-  static bool assert_entry_frame_laid_out(JavaThread* thread);\n-#endif\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":0,"deletions":118,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -1,238 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"jfr\/jfrEvents.hpp\"\n-#include \"runtime\/continuation.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/thread.hpp\"\n-\n-#define CONT_JFR false \/\/ emit low-level JFR events that count slow\/fast path for continuation peformance debugging only\n-#if CONT_JFR\n-  #define CONT_JFR_ONLY(code) code\n-#else\n-  #define CONT_JFR_ONLY(code)\n-#endif\n-\n-\/\/ Intermediary to the jdk.internal.vm.Continuation objects and ContinuationEntry\n-\/\/ This object is created when we begin a operation for a continuation, and is destroyed when the operation completes.\n-\/\/ Contents are read from the Java object at the entry points of this module, and written at exit or calls into Java\n-\/\/ It also serves as a custom NoSafepointVerifier\n-class ContinuationWrapper : public StackObj {\n-private:\n-  JavaThread* const  _thread;   \/\/ Thread being frozen\/thawed\n-  ContinuationEntry* _entry;\n-  \/\/ These oops are managed by SafepointOp\n-  oop                _continuation;  \/\/ jdk.internal.vm.Continuation instance\n-  stackChunkOop      _tail;\n-\n-#if CONT_JFR \/\/ Profiling data for the JFR event\n-  short _e_size;\n-  short _e_num_interpreted_frames;\n-#endif\n-\n-  ContinuationWrapper(const ContinuationWrapper& cont); \/\/ no copy constructor\n-\n-private:\n-  DEBUG_ONLY(Thread* _current_thread;)\n-  friend class SafepointOp;\n-\n-  void disallow_safepoint() {\n-    #ifdef ASSERT\n-      assert(_continuation != nullptr, \"\");\n-      _current_thread = Thread::current();\n-      if (_current_thread->is_Java_thread()) {\n-        JavaThread::cast(_current_thread)->inc_no_safepoint_count();\n-      }\n-    #endif\n-  }\n-\n-  void allow_safepoint() {\n-    #ifdef ASSERT\n-      \/\/ we could have already allowed safepoints in done\n-      if (_continuation != nullptr && _current_thread->is_Java_thread()) {\n-        JavaThread::cast(_current_thread)->dec_no_safepoint_count();\n-      }\n-    #endif\n-  }\n-\n-public:\n-  void done() {\n-    allow_safepoint(); \/\/ must be done first\n-    _continuation = nullptr;\n-    _tail = (stackChunkOop)badOop;\n-  }\n-\n-  class SafepointOp : public StackObj {\n-    ContinuationWrapper& _cont;\n-    Handle _conth;\n-  public:\n-    SafepointOp(Thread* current, ContinuationWrapper& cont)\n-      : _cont(cont), _conth(current, cont._continuation) {\n-      _cont.allow_safepoint();\n-    }\n-    ~SafepointOp() { \/\/ reload oops\n-      _cont._continuation = _conth();\n-      if (_cont._tail != nullptr) {\n-        _cont._tail = jdk_internal_vm_Continuation::tail(_cont._continuation);\n-      }\n-      _cont.disallow_safepoint();\n-    }\n-  };\n-\n-public:\n-  ~ContinuationWrapper() { allow_safepoint(); }\n-\n-  inline ContinuationWrapper(JavaThread* thread, oop continuation);\n-  inline ContinuationWrapper(oop continuation);\n-  inline ContinuationWrapper(const RegisterMap* map);\n-\n-  JavaThread* thread() const         { return _thread; }\n-  oop continuation()                 { return _continuation; }\n-  stackChunkOop tail() const         { return _tail; }\n-  void set_tail(stackChunkOop chunk) { _tail = chunk; }\n-\n-  oop parent()                   { return jdk_internal_vm_Continuation::parent(_continuation); }\n-  bool is_preempted()            { return jdk_internal_vm_Continuation::is_preempted(_continuation); }\n-  void set_preempted(bool value) { jdk_internal_vm_Continuation::set_preempted(_continuation, value); }\n-  void read()                    { _tail  = jdk_internal_vm_Continuation::tail(_continuation); }\n-  void write() {\n-    assert(oopDesc::is_oop(_continuation), \"bad oop\");\n-    assert(oopDesc::is_oop_or_null(_tail), \"bad oop\");\n-    jdk_internal_vm_Continuation::set_tail(_continuation, _tail);\n-  }\n-\n-  NOT_PRODUCT(intptr_t hash()    { return Thread::current()->is_Java_thread() ? _continuation->identity_hash() : -1; })\n-\n-  ContinuationEntry* entry() const { return _entry; }\n-  bool is_mounted()   const { return _entry != nullptr; }\n-  intptr_t* entrySP() const { return _entry->entry_sp(); }\n-  intptr_t* entryFP() const { return _entry->entry_fp(); }\n-  address   entryPC() const { return _entry->entry_pc(); }\n-  int argsize()       const { assert(_entry->argsize() >= 0, \"\"); return _entry->argsize(); }\n-  void set_argsize(int value) { _entry->set_argsize(value); }\n-\n-  bool is_empty() const { return last_nonempty_chunk() == nullptr; }\n-  inline const frame last_frame();\n-\n-  stackChunkOop last_nonempty_chunk() const { return nonempty_chunk(_tail); }\n-  inline stackChunkOop nonempty_chunk(stackChunkOop chunk) const;\n-  inline stackChunkOop find_chunk_by_address(void* p) const;\n-\n-#if CONT_JFR\n-  inline void record_interpreted_frame() { _e_num_interpreted_frames++; }\n-  inline void record_size_copied(int size) { _e_size += size << LogBytesPerWord; }\n-  template<typename Event> void post_jfr_event(Event *e, JavaThread* jt);\n-#endif\n-\n-#ifdef ASSERT\n-  inline bool is_entry_frame(const frame& f);\n-  bool chunk_invariant(outputStream* st);\n-#endif\n-};\n-\n-ContinuationWrapper::ContinuationWrapper(JavaThread* thread, oop continuation)\n-  : _thread(thread), _entry(thread->last_continuation()), _continuation(continuation)\n-#if CONT_JFR\n-  , _e_size(0), _e_num_interpreted_frames(0)\n-#endif\n-  {\n-  assert(oopDesc::is_oop(_continuation),\n-         \"Invalid continuation object: \" INTPTR_FORMAT, p2i((void*)_continuation));\n-  assert(_continuation == _entry->cont_oop(), \"cont: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \"\n-         INTPTR_FORMAT, p2i((oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n-  disallow_safepoint();\n-  read();\n-}\n-\n-ContinuationWrapper::ContinuationWrapper(oop continuation)\n-  : _thread(nullptr), _entry(nullptr), _continuation(continuation)\n-#if CONT_JFR\n-  , _e_size(0), _e_num_interpreted_frames(0)\n-#endif\n-  {\n-  assert(oopDesc::is_oop(_continuation),\n-         \"Invalid continuation object: \" INTPTR_FORMAT, p2i((void*)_continuation));\n-  disallow_safepoint();\n-  read();\n-}\n-\n-ContinuationWrapper::ContinuationWrapper(const RegisterMap* map)\n-  : _thread(map->thread()),\n-    _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())),\n-    _continuation(map->stack_chunk()->cont())\n-#if CONT_JFR\n-  , _e_size(0), _e_num_interpreted_frames(0)\n-#endif\n-  {\n-  assert(oopDesc::is_oop(_continuation),\"Invalid cont: \" INTPTR_FORMAT, p2i((void*)_continuation));\n-  assert(_entry == nullptr || _continuation == _entry->cont_oop(),\n-    \"cont: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \" INTPTR_FORMAT,\n-    p2i( (oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n-  disallow_safepoint();\n-  read();\n-}\n-\n-const frame ContinuationWrapper::last_frame() {\n-  stackChunkOop chunk = last_nonempty_chunk();\n-  if (chunk == nullptr) {\n-    return frame();\n-  }\n-  return StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame();\n-}\n-\n-inline stackChunkOop ContinuationWrapper::nonempty_chunk(stackChunkOop chunk) const {\n-  while (chunk != nullptr && chunk->is_empty()) {\n-    chunk = chunk->parent();\n-  }\n-  return chunk;\n-}\n-\n-stackChunkOop ContinuationWrapper::find_chunk_by_address(void* p) const {\n-  for (stackChunkOop chunk = tail(); chunk != nullptr; chunk = chunk->parent()) {\n-    if (chunk->is_in_chunk(p)) {\n-      assert(chunk->is_usable_in_chunk(p), \"\");\n-      return chunk;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-#if CONT_JFR\n-template<typename Event> void ContinuationWrapper::post_jfr_event(Event* e, JavaThread* jt) {\n-  if (e->should_commit()) {\n-    log_develop_trace(continuations)(\"JFR event: iframes: %d size: %d\", _e_num_interpreted_frames, _e_size);\n-    e->set_carrierThread(JFR_JVM_THREAD_ID(jt));\n-    e->set_contClass(_continuation->klass());\n-    e->set_numIFrames(_e_num_interpreted_frames);\n-    e->set_size(_e_size);\n-    e->commit();\n-  }\n-}\n-#endif\n-\n-#ifdef ASSERT\n-inline bool ContinuationWrapper::is_entry_frame(const frame& f) {\n-  return f.sp() == entrySP();\n-}\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/continuation.inline.hpp","additions":0,"deletions":238,"binary":false,"changes":238,"status":"deleted"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+int ContinuationEntry::return_pc_offset = 0;\n+nmethod* ContinuationEntry::continuation_enter = nullptr;\n+address ContinuationEntry::return_pc = nullptr;\n+\n+void ContinuationEntry::set_enter_nmethod(nmethod* nm) {\n+  assert(return_pc_offset != 0, \"\");\n+  continuation_enter = nm;\n+  return_pc = nm->code_begin() + return_pc_offset;\n+}\n+\n+ContinuationEntry* ContinuationEntry::from_frame(const frame& f) {\n+  assert(Continuation::is_continuation_enterSpecial(f), \"\");\n+  return (ContinuationEntry*)f.unextended_sp();\n+}\n+\n+NOINLINE static void flush_stack_processing(JavaThread* thread, intptr_t* sp) {\n+  log_develop_trace(continuations)(\"flush_stack_processing\");\n+  for (StackFrameStream fst(thread, true, true); fst.current()->sp() <= sp; fst.next()) {\n+    ;\n+  }\n+}\n+\n+inline void maybe_flush_stack_processing(JavaThread* thread, intptr_t* sp) {\n+  StackWatermark* sw;\n+  uintptr_t watermark;\n+  if ((sw = StackWatermarkSet::get(thread, StackWatermarkKind::gc)) != nullptr\n+        && (watermark = sw->watermark()) != 0\n+        && watermark <= (uintptr_t)sp) {\n+    flush_stack_processing(thread, sp);\n+  }\n+}\n+\n+void ContinuationEntry::flush_stack_processing(JavaThread* thread) const {\n+  maybe_flush_stack_processing(thread, (intptr_t*)((uintptr_t)entry_sp() + ContinuationEntry::size()));\n+}\n+\n+void ContinuationEntry::setup_oopmap(OopMap* map) {\n+  map->set_oop(VMRegImpl::stack2reg(in_bytes(cont_offset())  \/ VMRegImpl::stack_slot_size));\n+  map->set_oop(VMRegImpl::stack2reg(in_bytes(chunk_offset()) \/ VMRegImpl::stack_slot_size));\n+}\n+\n+#ifdef ASSERT\n+bool ContinuationEntry::assert_entry_frame_laid_out(JavaThread* thread) {\n+  assert(thread->has_last_Java_frame(), \"Wrong place to use this assertion\");\n+\n+  ContinuationEntry* entry = thread->last_continuation();\n+  assert(entry != nullptr, \"\");\n+\n+  intptr_t* unextended_sp = entry->entry_sp();\n+  intptr_t* sp;\n+  if (entry->argsize() > 0) {\n+    sp = entry->bottom_sender_sp();\n+  } else {\n+    sp = unextended_sp;\n+    bool interpreted_bottom = false;\n+    RegisterMap map(thread, false, false, false);\n+    frame f;\n+    for (f = thread->last_frame();\n+         !f.is_first_frame() && f.sp() <= unextended_sp && !Continuation::is_continuation_enterSpecial(f);\n+         f = f.sender(&map)) {\n+      interpreted_bottom = f.is_interpreted_frame();\n+    }\n+    assert(Continuation::is_continuation_enterSpecial(f), \"\");\n+    sp = interpreted_bottom ? f.sp() : entry->bottom_sender_sp();\n+  }\n+\n+  assert(sp != nullptr, \"\");\n+  assert(sp <= entry->entry_sp(), \"\");\n+  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+\n+  if (pc != StubRoutines::cont_returnBarrier()) {\n+    CodeBlob* cb = pc != nullptr ? CodeCache::find_blob(pc) : nullptr;\n+    assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+  }\n+\n+  return true;\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_RUNTIME_CONTINUATIONENTRY_HPP\n+#define SHARE_VM_RUNTIME_CONTINUATIONENTRY_HPP\n+\n+#include \"oops\/oop.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"utilities\/sizes.hpp\"\n+\n+class nmethod;\n+class RegisterMap;\n+class OopMap;\n+class JavaThread;\n+\n+\/\/ Metadata stored in the continuation entry frame\n+class ContinuationEntry {\n+public:\n+#ifdef ASSERT\n+  int cookie;\n+  static ByteSize cookie_offset() { return byte_offset_of(ContinuationEntry, cookie); }\n+  void verify_cookie() { assert(this->cookie == 0x1234, \"\"); }\n+#endif\n+\n+public:\n+  static int return_pc_offset; \/\/ friend gen_continuation_enter\n+  static void set_enter_nmethod(nmethod* nm); \/\/ friend SharedRuntime::generate_native_wrapper\n+\n+private:\n+  static nmethod* continuation_enter;\n+  static address return_pc;\n+\n+private:\n+  ContinuationEntry* _parent;\n+  oopDesc* _cont;\n+  oopDesc* _chunk;\n+  int _flags;\n+  int _argsize;\n+  intptr_t* _parent_cont_fastpath;\n+  int _parent_held_monitor_count;\n+  uint _pin_count;\n+\n+public:\n+  static ByteSize parent_offset()   { return byte_offset_of(ContinuationEntry, _parent); }\n+  static ByteSize cont_offset()     { return byte_offset_of(ContinuationEntry, _cont); }\n+  static ByteSize chunk_offset()    { return byte_offset_of(ContinuationEntry, _chunk); }\n+  static ByteSize flags_offset()    { return byte_offset_of(ContinuationEntry, _flags); }\n+  static ByteSize argsize_offset()  { return byte_offset_of(ContinuationEntry, _argsize); }\n+  static ByteSize pin_count_offset(){ return byte_offset_of(ContinuationEntry, _pin_count); }\n+  static ByteSize parent_cont_fastpath_offset()      { return byte_offset_of(ContinuationEntry, _parent_cont_fastpath); }\n+  static ByteSize parent_held_monitor_count_offset() { return byte_offset_of(ContinuationEntry, _parent_held_monitor_count); }\n+\n+  static void setup_oopmap(OopMap* map);\n+\n+public:\n+  static size_t size() { return align_up((int)sizeof(ContinuationEntry), 2*wordSize); }\n+\n+  ContinuationEntry* parent() const { return _parent; }\n+\n+  static address entry_pc() { return return_pc; }\n+  intptr_t* entry_sp() const { return (intptr_t*)this; }\n+  intptr_t* entry_fp() const;\n+\n+  int argsize() const { return _argsize; }\n+  void set_argsize(int value) { _argsize = value; }\n+\n+  bool is_pinned() { return _pin_count > 0; }\n+  bool pin() {\n+    if (_pin_count == UINT_MAX) return false;\n+    _pin_count++;\n+    return true;\n+  }\n+  bool unpin() {\n+    if (_pin_count == 0) return false;\n+    _pin_count--;\n+    return true;\n+  }\n+\n+  intptr_t* parent_cont_fastpath() const { return _parent_cont_fastpath; }\n+  void set_parent_cont_fastpath(intptr_t* x) { _parent_cont_fastpath = x; }\n+\n+  static ContinuationEntry* from_frame(const frame& f);\n+  frame to_frame() const;\n+  void update_register_map(RegisterMap* map) const;\n+  void flush_stack_processing(JavaThread* thread) const;\n+\n+  intptr_t* bottom_sender_sp() const {\n+    intptr_t* sp = entry_sp() - argsize();\n+#ifdef _LP64\n+    sp = align_down(sp, frame::frame_alignment);\n+#endif\n+    return sp;\n+  }\n+\n+  inline oop cont_oop() const;\n+\n+  oop scope()     const { return Continuation::continuation_scope(cont_oop()); }\n+\n+  oop cont_raw()  const { return _cont; }\n+  oop chunk_raw() const { return _chunk; }\n+\n+  bool is_virtual_thread() const { return _flags != 0; }\n+\n+  static oop cont_oop_or_null(const ContinuationEntry* ce) {\n+    return ce == nullptr ? nullptr : ce->cont_oop();\n+  }\n+\n+#ifndef PRODUCT\n+  void describe(FrameValues& values, int frame_no) const {\n+    address usp = (address)this;\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_offset())),    \"parent\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::cont_offset())),      \"continuation\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::flags_offset())),     \"flags\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::chunk_offset())),     \"chunk\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::argsize_offset())),   \"argsize\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::pin_count_offset())), \"pin_count\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_cont_fastpath_offset())),      \"parent fastpath\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_held_monitor_count_offset())), \"parent held monitor count\");\n+  }\n+#endif\n+\n+#ifdef ASSERT\n+  static bool assert_entry_frame_laid_out(JavaThread* thread);\n+#endif\n+};\n+\n+#endif \/\/ SHARE_VM_RUNTIME_CONTINUATIONENTRY_HPP\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_RUNTIME_CONTINUATIONENTRY_INLINE_HPP\n+#define SHARE_VM_RUNTIME_CONTINUATIONENTRY_INLINE_HPP\n+\n+#include \"runtime\/continuationEntry.hpp\"\n+\n+#include \"oops\/access.hpp\"\n+\n+#include CPU_HEADER_INLINE(continuationEntry)\n+\n+inline oop ContinuationEntry::cont_oop() const {\n+  oop snapshot = _cont;\n+  return NativeAccess<>::oop_load(&snapshot);\n+}\n+\n+\n+#endif \/\/ SHARE_VM_RUNTIME_CONTINUATIONENTRY_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.inline.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-#include \"runtime\/continuation.inline.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n@@ -49,0 +49,1 @@\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n@@ -64,0 +65,30 @@\n+#define CONT_JFR false \/\/ emit low-level JFR events that count slow\/fast path for continuation peformance debugging only\n+#if CONT_JFR\n+  #define CONT_JFR_ONLY(code) code\n+#else\n+  #define CONT_JFR_ONLY(code)\n+#endif\n+\n+#if CONT_JFR\n+class FreezeThawJfrInfo : public StackObj {\n+  short _e_size;\n+  short _e_num_interpreted_frames;\n+ public:\n+\n+  FreezeThawJfrInfo() : _e_size(0), _e_num_interpreted_frames(0) {}\n+  inline void record_interpreted_frame() { _e_num_interpreted_frames++; }\n+  inline void record_size_copied(int size) { _e_size += size << LogBytesPerWord; }\n+  template<typename Event> void post_jfr_event(Event *e, oop continuation, JavaThread* jt);\n+};\n+\n+template<typename Event> void FreezeThawJfrInfo::post_jfr_event(Event* e, oop continuation, JavaThread* jt) {\n+  if (e->should_commit()) {\n+    log_develop_trace(continuations)(\"JFR event: iframes: %d size: %d\", _e_num_interpreted_frames, _e_size);\n+    e->set_carrierThread(JFR_JVM_THREAD_ID(jt));\n+    e->set_contClass(continuation->klass());\n+    e->set_numIFrames(_e_num_interpreted_frames);\n+    e->set_size(_e_size);\n+    e->commit();\n+  }\n+}\n+#endif \/\/ CONT_JFR\n@@ -299,21 +330,0 @@\n-NOINLINE static void flush_stack_processing(JavaThread* thread, intptr_t* sp) {\n-  log_develop_trace(continuations)(\"flush_stack_processing\");\n-  for (StackFrameStream fst(thread, true, true); fst.current()->sp() <= sp; fst.next()) {\n-    ;\n-  }\n-}\n-\n-inline void maybe_flush_stack_processing(JavaThread* thread, intptr_t* sp) {\n-  StackWatermark* sw;\n-  uintptr_t watermark;\n-  if ((sw = StackWatermarkSet::get(thread, StackWatermarkKind::gc)) != nullptr\n-        && (watermark = sw->watermark()) != 0\n-        && watermark <= (uintptr_t)sp) {\n-    flush_stack_processing(thread, sp);\n-  }\n-}\n-\n-inline void maybe_flush_stack_processing(JavaThread* thread, const ContinuationEntry* entry) {\n-  maybe_flush_stack_processing(thread, (intptr_t*)((uintptr_t)entry->entry_sp() + ContinuationEntry::size()));\n-}\n-\n@@ -326,0 +336,1 @@\n+  CONT_JFR_ONLY(FreezeThawJfrInfo _jfr_info;)\n@@ -344,0 +355,1 @@\n+  CONT_JFR_ONLY(FreezeThawJfrInfo& jfr_info() { return _jfr_info; })\n@@ -444,1 +456,1 @@\n-  CONT_JFR_ONLY(_cont.record_size_copied(size);)\n+  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n@@ -459,1 +471,1 @@\n-  maybe_flush_stack_processing(_thread, entry);\n+  entry->flush_stack_processing(_thread);\n@@ -539,0 +551,1 @@\n+  CONT_JFR_ONLY(bool chunk_is_allocated = false;)\n@@ -596,0 +609,1 @@\n+    DEBUG_ONLY(CONT_JFR_ONLY(chunk_is_allocated = true;))\n@@ -656,2 +670,2 @@\n-    DEBUG_ONLY(e.set_allocate(allocated);)\n-    e.set_size(size << LogBytesPerWord);\n+    DEBUG_ONLY(e.set_allocate(chunk_is_allocated);)\n+    e.set_size(cont_size << LogBytesPerWord);\n@@ -1025,1 +1039,1 @@\n-  CONT_JFR_ONLY(_cont.record_interpreted_frame();)\n+  CONT_JFR_ONLY(_jfr_info.record_interpreted_frame();)\n@@ -1392,1 +1406,1 @@\n-    CONT_JFR_ONLY(cont.post_jfr_event(&event, current);)\n+    CONT_JFR_ONLY(fr.jfr_info().post_jfr_event(&event, oopCont, current);)\n@@ -1407,1 +1421,1 @@\n-    CONT_JFR_ONLY(cont.post_jfr_event(&event, current);)\n+    CONT_JFR_ONLY(fr.jfr_info().post_jfr_event(&event, oopCont, current);)\n@@ -1524,0 +1538,1 @@\n+  CONT_JFR_ONLY(FreezeThawJfrInfo _jfr_info;)\n@@ -1585,0 +1600,3 @@\n+\n+ public:\n+  CONT_JFR_ONLY(FreezeThawJfrInfo& jfr_info() { return _jfr_info; })\n@@ -1728,1 +1746,1 @@\n-    e.set_size(size << LogBytesPerWord);\n+    e.set_size(thaw_size << LogBytesPerWord);\n@@ -1749,1 +1767,1 @@\n-  CONT_JFR_ONLY(_cont.record_size_copied(size);)\n+  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n@@ -1966,1 +1984,1 @@\n-  CONT_JFR_ONLY(_cont.record_interpreted_frame();)\n+  CONT_JFR_ONLY(_jfr_info.record_interpreted_frame();)\n@@ -2206,1 +2224,1 @@\n-  CONT_JFR_ONLY(cont.post_jfr_event(&event, thread);)\n+  CONT_JFR_ONLY(thw.jfr_info().post_jfr_event(&event, cont.continuation(), thread);)\n@@ -2346,23 +2364,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-int ContinuationEntry::return_pc_offset = 0;\n-nmethod* ContinuationEntry::continuation_enter = nullptr;\n-address ContinuationEntry::return_pc = nullptr;\n-\n-void ContinuationEntry::set_enter_nmethod(nmethod* nm) {\n-  assert(return_pc_offset != 0, \"\");\n-  continuation_enter = nm;\n-  return_pc = nm->code_begin() + return_pc_offset;\n-}\n-\n-ContinuationEntry* ContinuationEntry::from_frame(const frame& f) {\n-  assert(Continuation::is_continuation_enterSpecial(f), \"\");\n-  return (ContinuationEntry*)f.unextended_sp();\n-}\n-\n-void ContinuationEntry::flush_stack_processing(JavaThread* thread) const {\n-  maybe_flush_stack_processing(thread, this);\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -2370,19 +2365,0 @@\n-bool ContinuationWrapper::chunk_invariant(outputStream* st) {\n-  \/\/ only the topmost chunk can be empty\n-  if (_tail == nullptr) {\n-    return true;\n-  }\n-\n-  int i = 1;\n-  for (stackChunkOop chunk = _tail->parent(); chunk != nullptr; chunk = chunk->parent()) {\n-    if (chunk->is_empty()) {\n-      assert(chunk != _tail, \"\");\n-      st->print_cr(\"i: %d\", i);\n-      chunk->print_on(true, st);\n-      return false;\n-    }\n-    i++;\n-  }\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":51,"deletions":75,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class ContinuationEntry;\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-Method* ContinuationHelper::Frame::frame_method(const frame& f) {\n+inline Method* ContinuationHelper::Frame::frame_method(const frame& f) {\n@@ -91,1 +91,1 @@\n-address ContinuationHelper::InterpretedFrame::return_pc(const frame& f) {\n+inline address ContinuationHelper::InterpretedFrame::return_pc(const frame& f) {\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/support\/jfrThreadId.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/stackChunkOop.inline.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/continuationHelper.inline.hpp\"\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n+#include \"runtime\/stackChunkFrameStream.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+ContinuationWrapper::ContinuationWrapper(const RegisterMap* map)\n+  : _thread(map->thread()),\n+    _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())),\n+    _continuation(map->stack_chunk()->cont())\n+  {\n+  assert(oopDesc::is_oop(_continuation),\"Invalid cont: \" INTPTR_FORMAT, p2i((void*)_continuation));\n+  assert(_entry == nullptr || _continuation == _entry->cont_oop(),\n+    \"cont: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \" INTPTR_FORMAT,\n+    p2i( (oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n+  disallow_safepoint();\n+  read();\n+}\n+\n+const frame ContinuationWrapper::last_frame() {\n+  stackChunkOop chunk = last_nonempty_chunk();\n+  if (chunk == nullptr) {\n+    return frame();\n+  }\n+  return StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame();\n+}\n+\n+stackChunkOop ContinuationWrapper::find_chunk_by_address(void* p) const {\n+  for (stackChunkOop chunk = tail(); chunk != nullptr; chunk = chunk->parent()) {\n+    if (chunk->is_in_chunk(p)) {\n+      assert(chunk->is_usable_in_chunk(p), \"\");\n+      return chunk;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+#ifndef PRODUCT\n+intptr_t ContinuationWrapper::hash() {\n+  return Thread::current()->is_Java_thread() ? _continuation->identity_hash() : -1;\n+}\n+#endif\n+\n+#ifdef ASSERT\n+bool ContinuationWrapper::is_entry_frame(const frame& f) {\n+  return f.sp() == entrySP();\n+}\n+\n+bool ContinuationWrapper::chunk_invariant(outputStream* st) {\n+  \/\/ only the topmost chunk can be empty\n+  if (_tail == nullptr) {\n+    return true;\n+  }\n+\n+  int i = 1;\n+  for (stackChunkOop chunk = _tail->parent(); chunk != nullptr; chunk = chunk->parent()) {\n+    if (chunk->is_empty()) {\n+      assert(chunk != _tail, \"\");\n+      st->print_cr(\"i: %d\", i);\n+      chunk->print_on(true, st);\n+      return false;\n+    }\n+    i++;\n+  }\n+  return true;\n+}\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_RUNTIME_CONTINUATIONWRAPPER_INLINE_HPP\n+#define SHARE_VM_RUNTIME_CONTINUATIONWRAPPER_INLINE_HPP\n+\n+\/\/ There is no continuationWrapper.hpp file\n+\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/stackChunkOop.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Intermediary to the jdk.internal.vm.Continuation objects and ContinuationEntry\n+\/\/ This object is created when we begin a operation for a continuation, and is destroyed when the operation completes.\n+\/\/ Contents are read from the Java object at the entry points of this module, and written at exit or calls into Java\n+\/\/ It also serves as a custom NoSafepointVerifier\n+class ContinuationWrapper : public StackObj {\n+private:\n+  JavaThread* const  _thread;   \/\/ Thread being frozen\/thawed\n+  ContinuationEntry* _entry;\n+  \/\/ These oops are managed by SafepointOp\n+  oop                _continuation;  \/\/ jdk.internal.vm.Continuation instance\n+  stackChunkOop      _tail;\n+\n+  ContinuationWrapper(const ContinuationWrapper& cont); \/\/ no copy constructor\n+\n+private:\n+  DEBUG_ONLY(Thread* _current_thread;)\n+  friend class SafepointOp;\n+\n+  void disallow_safepoint() {\n+    #ifdef ASSERT\n+      assert(_continuation != nullptr, \"\");\n+      _current_thread = Thread::current();\n+      if (_current_thread->is_Java_thread()) {\n+        JavaThread::cast(_current_thread)->inc_no_safepoint_count();\n+      }\n+    #endif\n+  }\n+\n+  void allow_safepoint() {\n+    #ifdef ASSERT\n+      \/\/ we could have already allowed safepoints in done\n+      if (_continuation != nullptr && _current_thread->is_Java_thread()) {\n+        JavaThread::cast(_current_thread)->dec_no_safepoint_count();\n+      }\n+    #endif\n+  }\n+\n+public:\n+  void done() {\n+    allow_safepoint(); \/\/ must be done first\n+    _continuation = nullptr;\n+    _tail = (stackChunkOop)badOop;\n+  }\n+\n+  class SafepointOp : public StackObj {\n+    ContinuationWrapper& _cont;\n+    Handle _conth;\n+  public:\n+    SafepointOp(Thread* current, ContinuationWrapper& cont)\n+      : _cont(cont), _conth(current, cont._continuation) {\n+      _cont.allow_safepoint();\n+    }\n+    inline ~SafepointOp() { \/\/ reload oops\n+      _cont._continuation = _conth();\n+      if (_cont._tail != nullptr) {\n+        _cont._tail = jdk_internal_vm_Continuation::tail(_cont._continuation);\n+       }\n+       _cont.disallow_safepoint();\n+    }\n+  };\n+\n+public:\n+  ~ContinuationWrapper() { allow_safepoint(); }\n+\n+  ContinuationWrapper(JavaThread* thread, oop continuation);\n+  ContinuationWrapper(oop continuation);\n+  ContinuationWrapper(const RegisterMap* map);\n+\n+  JavaThread* thread() const         { return _thread; }\n+  oop continuation()                 { return _continuation; }\n+  stackChunkOop tail() const         { return _tail; }\n+  void set_tail(stackChunkOop chunk) { _tail = chunk; }\n+\n+  inline oop parent();\n+  inline bool is_preempted();\n+  inline void set_preempted(bool value);\n+  inline void read();\n+  inline void write();\n+\n+  NOT_PRODUCT(intptr_t hash();)\n+\n+  ContinuationEntry* entry() const { return _entry; }\n+  bool is_mounted()   const { return _entry != nullptr; }\n+  intptr_t* entrySP() const { return _entry->entry_sp(); }\n+  intptr_t* entryFP() const { return _entry->entry_fp(); }\n+  address   entryPC() const { return _entry->entry_pc(); }\n+  int argsize()       const { assert(_entry->argsize() >= 0, \"\"); return _entry->argsize(); }\n+  void set_argsize(int value) { _entry->set_argsize(value); }\n+\n+  bool is_empty() const { return last_nonempty_chunk() == nullptr; }\n+  const frame last_frame();\n+\n+  stackChunkOop last_nonempty_chunk() const { return nonempty_chunk(_tail); }\n+  inline stackChunkOop nonempty_chunk(stackChunkOop chunk) const;\n+  stackChunkOop find_chunk_by_address(void* p) const;\n+\n+#ifdef ASSERT\n+  bool is_entry_frame(const frame& f);\n+  bool chunk_invariant(outputStream* st);\n+#endif\n+};\n+\n+inline ContinuationWrapper::ContinuationWrapper(JavaThread* thread, oop continuation)\n+  : _thread(thread), _entry(thread->last_continuation()), _continuation(continuation)\n+  {\n+  assert(oopDesc::is_oop(_continuation),\n+         \"Invalid continuation object: \" INTPTR_FORMAT, p2i((void*)_continuation));\n+  assert(_continuation == _entry->cont_oop(), \"cont: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \"\n+         INTPTR_FORMAT, p2i((oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n+  disallow_safepoint();\n+  read();\n+}\n+\n+inline ContinuationWrapper::ContinuationWrapper(oop continuation)\n+  : _thread(nullptr), _entry(nullptr), _continuation(continuation)\n+  {\n+  assert(oopDesc::is_oop(_continuation),\n+         \"Invalid continuation object: \" INTPTR_FORMAT, p2i((void*)_continuation));\n+  disallow_safepoint();\n+  read();\n+}\n+\n+inline oop ContinuationWrapper::parent() {\n+  return jdk_internal_vm_Continuation::parent(_continuation);\n+}\n+\n+inline bool ContinuationWrapper::is_preempted() {\n+  return jdk_internal_vm_Continuation::is_preempted(_continuation);\n+}\n+\n+inline void ContinuationWrapper::set_preempted(bool value) {\n+  jdk_internal_vm_Continuation::set_preempted(_continuation, value);\n+}\n+\n+inline void ContinuationWrapper::read() {\n+  _tail  = jdk_internal_vm_Continuation::tail(_continuation);\n+}\n+\n+inline void ContinuationWrapper::write() {\n+  assert(oopDesc::is_oop(_continuation), \"bad oop\");\n+  assert(oopDesc::is_oop_or_null(_tail), \"bad oop\");\n+  jdk_internal_vm_Continuation::set_tail(_continuation, _tail);\n+}\n+\n+inline stackChunkOop ContinuationWrapper::nonempty_chunk(stackChunkOop chunk) const {\n+  while (chunk != nullptr && chunk->is_empty()) {\n+    chunk = chunk->parent();\n+  }\n+  return chunk;\n+}\n+\n+#endif \/\/ SHARE_VM_RUNTIME_CONTINUATIONWRAPPER_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/continuationHelper.inline.hpp\"\n@@ -2491,0 +2493,5 @@\n+oop JavaThread::get_continuation() const {\n+  assert(threadObj() != nullptr, \"must be set\");\n+  return java_lang_Thread::continuation(threadObj());\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1189,0 +1189,1 @@\n+  oop get_continuation() const;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+class ContinuationEntry;\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}