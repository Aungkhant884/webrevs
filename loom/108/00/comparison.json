{"files":[{"patch":"@@ -28,4 +28,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-\n@@ -35,197 +31,0 @@\n-#ifdef ASSERT\n-template <chunk_frames frame_kind>\n-inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n-  assert (!is_done(), \"\");\n-  intptr_t* p = (intptr_t*)p0;\n-  int argsize = is_compiled() ? (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n-  int frame_size = _cb->frame_size() + argsize;\n-  return p == sp() - frame::sender_sp_offset || ((p - unextended_sp()) >= 0 && (p - unextended_sp()) < frame_size);\n-}\n-#endif\n-\n-template <chunk_frames frame_kind>\n-inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n-  if (is_done()) {\n-    return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n-  } else {\n-    return frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n-  }\n-}\n-\n-template <chunk_frames frame_kind>\n-inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n-  assert (!is_done(), \"\");\n-  return *(address*)(_sp - 1);\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n-  intptr_t* fp_addr = _sp - frame::sender_sp_offset;\n-  return (frame_kind == chunk_frames::MIXED && is_interpreted())\n-    ? fp_addr + *fp_addr \/\/ derelativize\n-    : *(intptr_t**)fp_addr;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n-  intptr_t* fp = this->fp();\n-  assert (fp != nullptr, \"\");\n-  return fp + fp[offset];\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  return derelativize(frame::interpreter_frame_last_sp_offset);\n-}\n-\n-\/\/ template <chunk_frames_kind frame_kind>\n-\/\/ inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame_caller() const {\n-\/\/   assert (frame_kind == chunk_frames::MIXED, \"\");\n-\/\/   intptr_t* callee_fp = sp() - frame::sender_sp_offset;\n-\/\/   intptr_t* unextended_sp = callee_fp + callee_fp[frame::interpreter_frame_sender_sp_offset];\n-\/\/   assert (unextended_sp > callee_fp && unextended_sp >= sp(), \"callee_fp: %p (%d) offset: %ld\", callee_fp, _chunk->to_offset(callee_fp), callee_fp[frame::interpreter_frame_sender_sp_offset]);\n-\/\/   return unextended_sp;\n-\/\/ }\n-\n-template <chunk_frames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  if (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) {\n-    _unextended_sp = _end;\n-    _sp = _end;\n-  } else {\n-    intptr_t* fp = this->fp();\n-    _unextended_sp = fp + fp[frame::interpreter_frame_sender_sp_offset];\n-    _sp = fp + frame::sender_sp_offset;\n-  }\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  \/\/ InterpreterOopMap mask;\n-  \/\/ to_frame().interpreted_frame_oop_map(&mask);\n-  \/\/ intptr_t* top = derelativize(frame::interpreter_frame_initial_sp_offset) - mask.expression_stack_size();\n-\n-  intptr_t* top = unextended_sp(); \/\/ later subtract argsize if callee is interpreted\n-  intptr_t* bottom = derelativize(frame::interpreter_frame_locals_offset) + 1; \/\/ the sender's unextended sp: derelativize(frame::interpreter_frame_sender_sp_offset);\n-  return (int)(bottom - top);\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  int diff = (int)(derelativize(frame::interpreter_frame_locals_offset) - derelativize(frame::interpreter_frame_sender_sp_offset) + 1);\n-  return diff;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  ResourceMark rm;\n-  InterpreterOopMap mask;\n-  frame f = to_frame();\n-  f.interpreted_frame_oop_map(&mask);\n-  return  mask.num_oops()\n-        + 1 \/\/ for the mirror oop\n-        + ((intptr_t*)f.interpreter_frame_monitor_begin()\n-            - (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n-}\n-\n-inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n-  if (fr.is_interpreted_frame()) fr.set_offset_fp(relativize_address(fr.fp()));\n-}\n-\n-inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n-  if (fr.is_interpreted_frame()) fr.set_fp(derelativize_address(fr.offset_fp()));\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n-  if (map->update_map()) {\n-    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)(intptr_t)frame::sender_sp_offset\n-                                                          : (intptr_t**)(_sp - frame::sender_sp_offset));\n-  }\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n-  if (map->update_map()) {\n-    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)(intptr_t)frame::sender_sp_offset\n-                                                          : (intptr_t**)(_sp - frame::sender_sp_offset));\n-  }\n-}\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n-\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n-class SmallRegisterMap {\n-public:\n-  static constexpr SmallRegisterMap* instance = nullptr;\n-private:\n-  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n-                                     DEBUG_ONLY({ assert (r == rfp->as_VMReg() || r == rfp->as_VMReg()->next(), \"Reg: %s\", r->name()); })\n-public:\n-  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n-  \/\/ Consider enhancing SmallRegisterMap to support those cases\n-  const RegisterMap* as_RegisterMap() const { return nullptr; }\n-  RegisterMap* as_RegisterMap() { return nullptr; }\n-\n-  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n-    map->clear();\n-    map->set_include_argument_oops(this->include_argument_oops());\n-    frame::update_map_with_saved_link(map, (intptr_t**)sp - frame::sender_sp_offset);\n-    return map;\n-  }\n-\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-  #ifdef ASSERT\n-    for(int i = 0; i < RegisterMap::reg_count; i++) {\n-      VMReg r = VMRegImpl::as_VMReg(i);\n-      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_rfp(r);\n-    }\n-  #endif\n-  }\n-\n-  inline address location(VMReg reg, intptr_t* sp) const {\n-    assert_is_rfp(reg);\n-    return (address)(sp - frame::sender_sp_offset);\n-  }\n-\n-  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n-\n-  JavaThread* thread() const {\n-  #ifndef ASSERT\n-    guarantee (false, \"unreachable\");\n-  #endif\n-    return nullptr;\n-  }\n-\n-  bool update_map()    const { return false; }\n-  bool walk_cont()     const { return false; }\n-  bool include_argument_oops() const { return false; }\n-  void set_include_argument_oops(bool f)  {}\n-  bool in_cont()       const { return false; }\n-  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n-\n-#ifdef ASSERT\n-  bool should_skip_missing() const  { return false; }\n-  VMReg find_register_spilled_here(void* p, intptr_t* sp) { return rfp->as_VMReg(); }\n-  void print() const { print_on(tty); }\n-  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n-#endif\n-};\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/instanceStackChunkKlass_aarch64.inline.hpp","additions":0,"deletions":201,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_SMALLREGISTERMAP_AARCH64_INLINE_HPP\n+#define CPU_AARCH64_SMALLREGISTERMAP_AARCH64_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n+                                     DEBUG_ONLY({ assert (r == rfp->as_VMReg() || r == rfp->as_VMReg()->next(), \"Reg: %s\", r->name()); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    map->clear();\n+    map->set_include_argument_oops(this->include_argument_oops());\n+    frame::update_map_with_saved_link(map, (intptr_t**)sp - frame::sender_sp_offset);\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+  #ifdef ASSERT\n+    for(int i = 0; i < RegisterMap::reg_count; i++) {\n+      VMReg r = VMRegImpl::as_VMReg(i);\n+      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_rfp(r);\n+    }\n+  #endif\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    assert_is_rfp(reg);\n+    return (address)(sp - frame::sender_sp_offset);\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"unreachable\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) { return rfp->as_VMReg(); }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_AARCH64_SMALLREGISTERMAP_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/smallRegisterMap_aarch64.inline.hpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_STACKCHUNKFRAMESTREAM_AARCH64_INLINE_HPP\n+#define CPU_AARCH64_STACKCHUNKFRAMESTREAM_AARCH64_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+#ifdef ASSERT\n+template <chunk_frames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n+  assert (!is_done(), \"\");\n+  intptr_t* p = (intptr_t*)p0;\n+  int argsize = is_compiled() ? (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n+  int frame_size = _cb->frame_size() + argsize;\n+  return p == sp() - frame::sender_sp_offset || ((p - unextended_sp()) >= 0 && (p - unextended_sp()) < frame_size);\n+}\n+#endif\n+\n+template <chunk_frames frame_kind>\n+inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n+  if (is_done()) {\n+    return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n+  } else {\n+    return frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n+  }\n+}\n+\n+template <chunk_frames frame_kind>\n+inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n+  assert (!is_done(), \"\");\n+  return *(address*)(_sp - 1);\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n+  intptr_t* fp_addr = _sp - frame::sender_sp_offset;\n+  return (frame_kind == chunk_frames::MIXED && is_interpreted())\n+    ? fp_addr + *fp_addr \/\/ derelativize\n+    : *(intptr_t**)fp_addr;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n+  intptr_t* fp = this->fp();\n+  assert (fp != nullptr, \"\");\n+  return fp + fp[offset];\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  return derelativize(frame::interpreter_frame_last_sp_offset);\n+}\n+\n+\/\/ template <chunk_frames_kind frame_kind>\n+\/\/ inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame_caller() const {\n+\/\/   assert (frame_kind == chunk_frames::MIXED, \"\");\n+\/\/   intptr_t* callee_fp = sp() - frame::sender_sp_offset;\n+\/\/   intptr_t* unextended_sp = callee_fp + callee_fp[frame::interpreter_frame_sender_sp_offset];\n+\/\/   assert (unextended_sp > callee_fp && unextended_sp >= sp(), \"callee_fp: %p (%d) offset: %ld\", callee_fp, _chunk->to_offset(callee_fp), callee_fp[frame::interpreter_frame_sender_sp_offset]);\n+\/\/   return unextended_sp;\n+\/\/ }\n+\n+template <chunk_frames frame_kind>\n+intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  if (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) {\n+    _unextended_sp = _end;\n+    _sp = _end;\n+  } else {\n+    intptr_t* fp = this->fp();\n+    _unextended_sp = fp + fp[frame::interpreter_frame_sender_sp_offset];\n+    _sp = fp + frame::sender_sp_offset;\n+  }\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  \/\/ InterpreterOopMap mask;\n+  \/\/ to_frame().interpreted_frame_oop_map(&mask);\n+  \/\/ intptr_t* top = derelativize(frame::interpreter_frame_initial_sp_offset) - mask.expression_stack_size();\n+\n+  intptr_t* top = unextended_sp(); \/\/ later subtract argsize if callee is interpreted\n+  intptr_t* bottom = derelativize(frame::interpreter_frame_locals_offset) + 1; \/\/ the sender's unextended sp: derelativize(frame::interpreter_frame_sender_sp_offset);\n+  return (int)(bottom - top);\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  int diff = (int)(derelativize(frame::interpreter_frame_locals_offset) - derelativize(frame::interpreter_frame_sender_sp_offset) + 1);\n+  return diff;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  ResourceMark rm;\n+  InterpreterOopMap mask;\n+  frame f = to_frame();\n+  f.interpreted_frame_oop_map(&mask);\n+  return  mask.num_oops()\n+        + 1 \/\/ for the mirror oop\n+        + ((intptr_t*)f.interpreter_frame_monitor_begin()\n+            - (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n+  if (map->update_map()) {\n+    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)(intptr_t)frame::sender_sp_offset\n+                                                          : (intptr_t**)(_sp - frame::sender_sp_offset));\n+  }\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n+  if (map->update_map()) {\n+    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)(intptr_t)frame::sender_sp_offset\n+                                                          : (intptr_t**)(_sp - frame::sender_sp_offset));\n+  }\n+}\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+#endif \/\/ CPU_AARCH64_STACKCHUNKFRAMESTREAM_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkFrameStream_aarch64.inline.hpp","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_AARCH64_STACKCHUNKOOP_AARCH64_INLINE_HPP\n+#define CPU_AARCH64_STACKCHUNKOOP_AARCH64_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_offset_fp(relativize_address(fr.fp()));\n+  }\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_fp(derelativize_address(fr.offset_fp()));\n+  }\n+}\n+\n+#endif \/\/ CPU_AARCH64_STACKCHUNKOOP_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/stackChunkOop_aarch64.inline.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -28,4 +28,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-\n@@ -42,147 +38,0 @@\n-#ifdef ASSERT\n-template <chunk_frames frame_kind>\n-inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n-  Unimplemented();\n-  return true;\n-}\n-#endif\n-\n-template <chunk_frames frame_kind>\n-inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n-  Unimplemented();\n-  return frame();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n-  Unimplemented();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n-  Unimplemented();\n-}\n-\n-inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n-  Unimplemented();\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n-  Unimplemented();\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n-  Unimplemented();\n-}\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n-\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n-class SmallRegisterMap {\n-public:\n-  static constexpr SmallRegisterMap* instance = nullptr;\n-private:\n-  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n-                                     DEBUG_ONLY({ Unimplemented(); })\n-public:\n-  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n-  \/\/ Consider enhancing SmallRegisterMap to support those cases\n-  const RegisterMap* as_RegisterMap() const { return nullptr; }\n-  RegisterMap* as_RegisterMap() { return nullptr; }\n-\n-  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n-    Unimplemented();\n-    return map;\n-  }\n-\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n-  inline address location(VMReg reg, intptr_t* sp) const {\n-    Unimplemented();\n-    return NULL;\n-  }\n-\n-  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n-\n-  JavaThread* thread() const {\n-  #ifndef ASSERT\n-    guarantee (false, \"\");\n-  #endif\n-    return nullptr;\n-  }\n-\n-  bool update_map()    const { return false; }\n-  bool walk_cont()     const { return false; }\n-  bool include_argument_oops() const { return false; }\n-  void set_include_argument_oops(bool f)  {}\n-  bool in_cont()       const { return false; }\n-  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n-\n-#ifdef ASSERT\n-  bool should_skip_missing() const  { return false; }\n-  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n-    Unimplemented();\n-    return NULL;\n-  }\n-  void print() const { print_on(tty); }\n-  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n-#endif\n-};\n-\n","filename":"src\/hotspot\/cpu\/arm\/instanceStackChunkKlass_arm.inline.hpp","additions":0,"deletions":151,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_SMALLREGISTERMAP_ARM_INLINE_HPP\n+#define CPU_ARM_SMALLREGISTERMAP_ARM_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_ARM_SMALLREGISTERMAP_ARM_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/arm\/smallRegisterMap_arm.inline.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_STACKCHUNKFRAMESTREAM_ARM_INLINE_HPP\n+#define CPU_ARM_STACKCHUNKFRAMESTREAM_ARM_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+#ifdef ASSERT\n+template <chunk_frames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <chunk_frames frame_kind>\n+inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+#endif \/\/ CPU_ARM_STACKCHUNKFRAMESTREAM_ARM_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/arm\/stackChunkFrameStream_arm.inline.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_STACKCHUNKOOP_ARM_INLINE_HPP\n+#define CPU_ARM_STACKCHUNKOOP_ARM_INLINE_HPP\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_ARM_STACKCHUNKOOP_ARM_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/arm\/stackChunkOop_arm.inline.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -42,147 +42,0 @@\n-#ifdef ASSERT\n-template <chunk_frames frame_kind>\n-inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n-  Unimplemented();\n-  return true;\n-}\n-#endif\n-\n-template <chunk_frames frame_kind>\n-inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n-  Unimplemented();\n-  return frame();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n-  Unimplemented();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n-  Unimplemented();\n-}\n-\n-inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n-  Unimplemented();\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n-  Unimplemented();\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n-  Unimplemented();\n-}\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n-\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n-class SmallRegisterMap {\n-public:\n-  static constexpr SmallRegisterMap* instance = nullptr;\n-private:\n-  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n-                                     DEBUG_ONLY({ Unimplemented(); })\n-public:\n-  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n-  \/\/ Consider enhancing SmallRegisterMap to support those cases\n-  const RegisterMap* as_RegisterMap() const { return nullptr; }\n-  RegisterMap* as_RegisterMap() { return nullptr; }\n-\n-  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n-    Unimplemented();\n-    return map;\n-  }\n-\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n-  inline address location(VMReg reg, intptr_t* sp) const {\n-    Unimplemented();\n-    return NULL;\n-  }\n-\n-  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n-\n-  JavaThread* thread() const {\n-  #ifndef ASSERT\n-    guarantee (false, \"\");\n-  #endif\n-    return nullptr;\n-  }\n-\n-  bool update_map()    const { return false; }\n-  bool walk_cont()     const { return false; }\n-  bool include_argument_oops() const { return false; }\n-  void set_include_argument_oops(bool f)  {}\n-  bool in_cont()       const { return false; }\n-  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n-\n-#ifdef ASSERT\n-  bool should_skip_missing() const  { return false; }\n-  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n-    Unimplemented();\n-    return NULL;\n-  }\n-  void print() const { print_on(tty); }\n-  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n-#endif\n-};\n-\n","filename":"src\/hotspot\/cpu\/ppc\/instanceStackChunkKlass_ppc.inline.hpp","additions":0,"deletions":147,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_SMALLREGISTERMAP_PPC_INLINE_HPP\n+#define CPU_PPC_SMALLREGISTERMAP_PPC_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_PPC_SMALLREGISTERMAP_PPC_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/smallRegisterMap_ppc.inline.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_STACKCHUNKFRAMESTREAM_PPC_INLINE_HPP\n+#define CPU_PPC_STACKCHUNKFRAMESTREAM_PPC_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+#ifdef ASSERT\n+template <chunk_frames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <chunk_frames frame_kind>\n+inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+#endif \/\/ CPU_PPC_STACKCHUNKFRAMESTREAM_PPC_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkFrameStream_ppc.inline.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_STACKCHUNKOOP_PPC_INLINE_HPP\n+#define CPU_PPC_STACKCHUNKOOP_PPC_INLINE_HPP\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_PPC_STACKCHUNKOOP_PPC_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/stackChunkOop_ppc.inline.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -28,4 +28,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-\n@@ -42,147 +38,0 @@\n-#ifdef ASSERT\n-template <chunk_frames frame_kind>\n-inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n-  Unimplemented();\n-  return true;\n-}\n-#endif\n-\n-template <chunk_frames frame_kind>\n-inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n-  Unimplemented();\n-  return frame();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n-  Unimplemented();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n-  Unimplemented();\n-}\n-\n-inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n-  Unimplemented();\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n-  Unimplemented();\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n-  Unimplemented();\n-}\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n-\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n-class SmallRegisterMap {\n-public:\n-  static constexpr SmallRegisterMap* instance = nullptr;\n-private:\n-  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n-                                     DEBUG_ONLY({ Unimplemented(); })\n-public:\n-  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n-  \/\/ Consider enhancing SmallRegisterMap to support those cases\n-  const RegisterMap* as_RegisterMap() const { return nullptr; }\n-  RegisterMap* as_RegisterMap() { return nullptr; }\n-\n-  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n-    Unimplemented();\n-    return map;\n-  }\n-\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n-  inline address location(VMReg reg, intptr_t* sp) const {\n-    Unimplemented();\n-    return NULL;\n-  }\n-\n-  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n-\n-  JavaThread* thread() const {\n-  #ifndef ASSERT\n-    guarantee (false, \"\");\n-  #endif\n-    return nullptr;\n-  }\n-\n-  bool update_map()    const { return false; }\n-  bool walk_cont()     const { return false; }\n-  bool include_argument_oops() const { return false; }\n-  void set_include_argument_oops(bool f)  {}\n-  bool in_cont()       const { return false; }\n-  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n-\n-#ifdef ASSERT\n-  bool should_skip_missing() const  { return false; }\n-  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n-    Unimplemented();\n-    return NULL;\n-  }\n-  void print() const { print_on(tty); }\n-  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n-#endif\n-};\n-\n","filename":"src\/hotspot\/cpu\/s390\/instanceStackChunkKlass_s390.inline.hpp","additions":0,"deletions":151,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_SMALLREGISTERMAP_S390_INLINE_HPP\n+#define CPU_S390_SMALLREGISTERMAP_S390_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_S390_SMALLREGISTERMAP_S390_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/s390\/smallRegisterMap_s390.inline.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_STACKCHUNKFRAMESTREAM_S390_INLINE_HPP\n+#define CPU_S390_STACKCHUNKFRAMESTREAM_S390_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+#ifdef ASSERT\n+template <chunk_frames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <chunk_frames frame_kind>\n+inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+#endif \/\/ CPU_S390_STACKCHUNKFRAMESTREAM_S390_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/s390\/stackChunkFrameStream_s390.inline.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_STACKCHUNKOOP_S390_INLINE_HPP\n+#define CPU_S390_STACKCHUNKOOP_S390_INLINE_HPP\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_S390_STACKCHUNKOOP_S390_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/s390\/stackChunkOop_s390.inline.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -28,4 +28,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-\n@@ -35,197 +31,0 @@\n-#ifdef ASSERT\n-template <chunk_frames frame_kind>\n-inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n-  assert (!is_done(), \"\");\n-  intptr_t* p = (intptr_t*)p0;\n-  int argsize = is_compiled() ? (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n-  int frame_size = _cb->frame_size() + argsize;\n-  return p == sp() - frame::sender_sp_offset || ((p - unextended_sp()) >= 0 && (p - unextended_sp()) < frame_size);\n-}\n-#endif\n-\n-template <chunk_frames frame_kind>\n-inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n-  if (is_done()) {\n-    return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n-  } else {\n-    return frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n-  }\n-}\n-\n-template <chunk_frames frame_kind>\n-inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n-  assert (!is_done(), \"\");\n-  return *(address*)(_sp - 1);\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n-  intptr_t* fp_addr = _sp - frame::sender_sp_offset;\n-  return (frame_kind == chunk_frames::MIXED && is_interpreted())\n-    ? fp_addr + *fp_addr \/\/ derelativize\n-    : *(intptr_t**)fp_addr;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n-  intptr_t* fp = this->fp();\n-  assert (fp != nullptr, \"\");\n-  return fp + fp[offset];\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  return derelativize(frame::interpreter_frame_last_sp_offset);\n-}\n-\n-\/\/ template <chunk_frames frame_kind>\n-\/\/ inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame_caller() const {\n-\/\/   assert (frame_kind == chunk_frames::MIXED, \"\");\n-\/\/   intptr_t* callee_fp = sp() - frame::sender_sp_offset;\n-\/\/   intptr_t* unextended_sp = callee_fp + callee_fp[frame::interpreter_frame_sender_sp_offset];\n-\/\/   assert (unextended_sp > callee_fp && unextended_sp >= sp(), \"callee_fp: %p (%d) offset: %ld\", callee_fp, _chunk->to_offset(callee_fp), callee_fp[frame::interpreter_frame_sender_sp_offset]);\n-\/\/   return unextended_sp;\n-\/\/ }\n-\n-template <chunk_frames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  if (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) {\n-    _unextended_sp = _end;\n-    _sp = _end;\n-  } else {\n-    intptr_t* fp = this->fp();\n-    _unextended_sp = fp + fp[frame::interpreter_frame_sender_sp_offset];\n-    _sp = fp + frame::sender_sp_offset;\n-  }\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  \/\/ InterpreterOopMap mask;\n-  \/\/ to_frame().interpreted_frame_oop_map(&mask);\n-  \/\/ intptr_t* top = derelativize(frame::interpreter_frame_initial_sp_offset) - mask.expression_stack_size();\n-\n-  intptr_t* top = unextended_sp(); \/\/ later subtract argsize if callee is interpreted\n-  intptr_t* bottom = derelativize(frame::interpreter_frame_locals_offset) + 1; \/\/ the sender's unextended sp: derelativize(frame::interpreter_frame_sender_sp_offset);\n-  return (int)(bottom - top);\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  int diff = (int)(derelativize(frame::interpreter_frame_locals_offset) - derelativize(frame::interpreter_frame_sender_sp_offset) + 1);\n-  return diff;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n-  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n-  ResourceMark rm;\n-  InterpreterOopMap mask;\n-  frame f = to_frame();\n-  f.interpreted_frame_oop_map(&mask);\n-  return  mask.num_oops()\n-        + 1 \/\/ for the mirror oop\n-        + ((intptr_t*)f.interpreter_frame_monitor_begin()\n-            - (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n-}\n-\n-inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n-  if (fr.is_interpreted_frame()) fr.set_offset_fp(relativize_address(fr.fp()));\n-}\n-\n-inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n-  if (fr.is_interpreted_frame()) fr.set_fp(derelativize_address(fr.offset_fp()));\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n-  if (map->update_map()) {\n-    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)(intptr_t)frame::sender_sp_offset\n-                                                          : (intptr_t**)(_sp - frame::sender_sp_offset));\n-  }\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n-  if (map->update_map()) {\n-    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)(intptr_t)frame::sender_sp_offset\n-                                                          : (intptr_t**)(_sp - frame::sender_sp_offset));\n-  }\n-}\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n-\n-\/\/ Java frames don't have callee saved registers (except for rbp), so we can use a smaller RegisterMap\n-class SmallRegisterMap {\n-public:\n-  static constexpr SmallRegisterMap* instance = nullptr;\n-private:\n-  static void assert_is_rbp(VMReg r) NOT_DEBUG_RETURN\n-                                     DEBUG_ONLY({ assert (r == rbp->as_VMReg() || r == rbp->as_VMReg()->next(), \"Reg: %s\", r->name()); })\n-public:\n-  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n-  \/\/ Consider enhancing SmallRegisterMap to support those cases\n-  const RegisterMap* as_RegisterMap() const { return nullptr; }\n-  RegisterMap* as_RegisterMap() { return nullptr; }\n-\n-  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n-    map->clear();\n-    map->set_include_argument_oops(this->include_argument_oops());\n-    frame::update_map_with_saved_link(map, (intptr_t**)sp - frame::sender_sp_offset);\n-    return map;\n-  }\n-\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-  #ifdef ASSERT\n-    for(int i = 0; i < RegisterMap::reg_count; i++) {\n-      VMReg r = VMRegImpl::as_VMReg(i);\n-      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_rbp(r);\n-    }\n-  #endif\n-  }\n-\n-  inline address location(VMReg reg, intptr_t* sp) const {\n-    assert_is_rbp(reg);\n-    return (address)(sp - frame::sender_sp_offset);\n-  }\n-\n-  inline void set_location(VMReg reg, address loc) { assert_is_rbp(reg); }\n-\n-  JavaThread* thread() const {\n-  #ifndef ASSERT\n-    guarantee (false, \"unreachable\");\n-  #endif\n-    return nullptr;\n-  }\n-\n-  bool update_map()    const { return false; }\n-  bool walk_cont()     const { return false; }\n-  bool include_argument_oops() const { return false; }\n-  void set_include_argument_oops(bool f)  {}\n-  bool in_cont()       const { return false; }\n-  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n-\n-#ifdef ASSERT\n-  bool should_skip_missing() const  { return false; }\n-  VMReg find_register_spilled_here(void* p, intptr_t* sp) { return rbp->as_VMReg(); }\n-  void print() const { print_on(tty); }\n-  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n-#endif\n-};\n-\n","filename":"src\/hotspot\/cpu\/x86\/instanceStackChunkKlass_x86.inline.hpp","additions":0,"deletions":201,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_SMALLREGISTERMAP_X86_INLINE_HPP\n+#define CPU_X86_SMALLREGISTERMAP_X86_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+\/\/ Java frames don't have callee saved registers (except for rbp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rbp(VMReg r) NOT_DEBUG_RETURN\n+                                     DEBUG_ONLY({ assert (r == rbp->as_VMReg() || r == rbp->as_VMReg()->next(), \"Reg: %s\", r->name()); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    map->clear();\n+    map->set_include_argument_oops(this->include_argument_oops());\n+    frame::update_map_with_saved_link(map, (intptr_t**)sp - frame::sender_sp_offset);\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+  #ifdef ASSERT\n+    for(int i = 0; i < RegisterMap::reg_count; i++) {\n+      VMReg r = VMRegImpl::as_VMReg(i);\n+      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_rbp(r);\n+    }\n+  #endif\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    assert_is_rbp(reg);\n+    return (address)(sp - frame::sender_sp_offset);\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rbp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"unreachable\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) { return rbp->as_VMReg(); }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_X86_SMALLREGISTERMAP_X86_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/x86\/smallRegisterMap_x86.inline.hpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_STACKCHUNKFRAMESTREAM_X86_INLINE_HPP\n+#define CPU_X86_STACKCHUNKFRAMESTREAM_X86_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+#ifdef ASSERT\n+template <chunk_frames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n+  assert (!is_done(), \"\");\n+  intptr_t* p = (intptr_t*)p0;\n+  int argsize = is_compiled() ? (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n+  int frame_size = _cb->frame_size() + argsize;\n+  return p == sp() - frame::sender_sp_offset || ((p - unextended_sp()) >= 0 && (p - unextended_sp()) < frame_size);\n+}\n+#endif\n+\n+template <chunk_frames frame_kind>\n+inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n+  if (is_done()) {\n+    return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n+  } else {\n+    return frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n+  }\n+}\n+\n+template <chunk_frames frame_kind>\n+inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n+  assert (!is_done(), \"\");\n+  return *(address*)(_sp - 1);\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n+  intptr_t* fp_addr = _sp - frame::sender_sp_offset;\n+  return (frame_kind == chunk_frames::MIXED && is_interpreted())\n+    ? fp_addr + *fp_addr \/\/ derelativize\n+    : *(intptr_t**)fp_addr;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n+  intptr_t* fp = this->fp();\n+  assert (fp != nullptr, \"\");\n+  return fp + fp[offset];\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  return derelativize(frame::interpreter_frame_last_sp_offset);\n+}\n+\n+\/\/ template <chunk_frames frame_kind>\n+\/\/ inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame_caller() const {\n+\/\/   assert (frame_kind == chunk_frames::MIXED, \"\");\n+\/\/   intptr_t* callee_fp = sp() - frame::sender_sp_offset;\n+\/\/   intptr_t* unextended_sp = callee_fp + callee_fp[frame::interpreter_frame_sender_sp_offset];\n+\/\/   assert (unextended_sp > callee_fp && unextended_sp >= sp(), \"callee_fp: %p (%d) offset: %ld\", callee_fp, _chunk->to_offset(callee_fp), callee_fp[frame::interpreter_frame_sender_sp_offset]);\n+\/\/   return unextended_sp;\n+\/\/ }\n+\n+template <chunk_frames frame_kind>\n+intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  if (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) {\n+    _unextended_sp = _end;\n+    _sp = _end;\n+  } else {\n+    intptr_t* fp = this->fp();\n+    _unextended_sp = fp + fp[frame::interpreter_frame_sender_sp_offset];\n+    _sp = fp + frame::sender_sp_offset;\n+  }\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  \/\/ InterpreterOopMap mask;\n+  \/\/ to_frame().interpreted_frame_oop_map(&mask);\n+  \/\/ intptr_t* top = derelativize(frame::interpreter_frame_initial_sp_offset) - mask.expression_stack_size();\n+\n+  intptr_t* top = unextended_sp(); \/\/ later subtract argsize if callee is interpreted\n+  intptr_t* bottom = derelativize(frame::interpreter_frame_locals_offset) + 1; \/\/ the sender's unextended sp: derelativize(frame::interpreter_frame_sender_sp_offset);\n+  return (int)(bottom - top);\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  int diff = (int)(derelativize(frame::interpreter_frame_locals_offset) - derelativize(frame::interpreter_frame_sender_sp_offset) + 1);\n+  return diff;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+  assert (frame_kind == chunk_frames::MIXED && is_interpreted(), \"\");\n+  ResourceMark rm;\n+  InterpreterOopMap mask;\n+  frame f = to_frame();\n+  f.interpreted_frame_oop_map(&mask);\n+  return  mask.num_oops()\n+        + 1 \/\/ for the mirror oop\n+        + ((intptr_t*)f.interpreter_frame_monitor_begin()\n+            - (intptr_t*)f.interpreter_frame_monitor_end())\/BasicObjectLock::size();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n+  if (map->update_map()) {\n+    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)(intptr_t)frame::sender_sp_offset\n+                                                          : (intptr_t**)(_sp - frame::sender_sp_offset));\n+  }\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n+  if (map->update_map()) {\n+    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)(intptr_t)frame::sender_sp_offset\n+                                                          : (intptr_t**)(_sp - frame::sender_sp_offset));\n+  }\n+}\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+#endif \/\/ CPU_X86_STACKCHUNKFRAMESTREAM_X86_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkFrameStream_x86.inline.hpp","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_X86_STACKCHUNKOOP_X86_INLINE_HPP\n+#define CPU_X86_STACKCHUNKOOP_X86_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_offset_fp(relativize_address(fr.fp()));\n+  }\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_fp(derelativize_address(fr.offset_fp()));\n+  }\n+}\n+\n+#endif \/\/ CPU_X86_STACKCHUNKOOP_X86_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/x86\/stackChunkOop_x86.inline.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -28,4 +28,0 @@\n-#include \"interpreter\/oopMapCache.hpp\"\n-#include \"runtime\/frame.inline.hpp\"\n-#include \"runtime\/registerMap.hpp\"\n-\n@@ -42,147 +38,0 @@\n-#ifdef ASSERT\n-template <chunk_frames frame_kind>\n-inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n-  Unimplemented();\n-  return true;\n-}\n-#endif\n-\n-template <chunk_frames frame_kind>\n-inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n-  Unimplemented();\n-  return frame();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n-  Unimplemented();\n-  return NULL;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n-  Unimplemented();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n-  Unimplemented();\n-}\n-\n-inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n-  Unimplemented();\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n-  Unimplemented();\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n-  Unimplemented();\n-}\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n-\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n-class SmallRegisterMap {\n-public:\n-  static constexpr SmallRegisterMap* instance = nullptr;\n-private:\n-  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n-                                     DEBUG_ONLY({ Unimplemented(); })\n-public:\n-  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n-  \/\/ Consider enhancing SmallRegisterMap to support those cases\n-  const RegisterMap* as_RegisterMap() const { return nullptr; }\n-  RegisterMap* as_RegisterMap() { return nullptr; }\n-\n-  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n-    Unimplemented();\n-    return map;\n-  }\n-\n-  SmallRegisterMap() {}\n-\n-  SmallRegisterMap(const RegisterMap* map) {\n-    Unimplemented();\n-  }\n-\n-  inline address location(VMReg reg, intptr_t* sp) const {\n-    Unimplemented();\n-    return NULL;\n-  }\n-\n-  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n-\n-  JavaThread* thread() const {\n-  #ifndef ASSERT\n-    guarantee (false, \"\");\n-  #endif\n-    return nullptr;\n-  }\n-\n-  bool update_map()    const { return false; }\n-  bool walk_cont()     const { return false; }\n-  bool include_argument_oops() const { return false; }\n-  void set_include_argument_oops(bool f)  {}\n-  bool in_cont()       const { return false; }\n-  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n-\n-#ifdef ASSERT\n-  bool should_skip_missing() const  { return false; }\n-  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n-    Unimplemented();\n-    return NULL;\n-  }\n-  void print() const { print_on(tty); }\n-  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n-#endif\n-};\n-\n","filename":"src\/hotspot\/cpu\/zero\/instanceStackChunkKlass_zero.inline.hpp","additions":0,"deletions":151,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_SMALLREGISTERMAP_ZERO_INLINE_HPP\n+#define CPU_ZERO_SMALLREGISTERMAP_ZERO_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_ZERO_SMALLREGISTERMAP_ZERO_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/zero\/smallRegisterMap_zero.inline.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_STACKCHUNKFRAMESTREAM_ZERO_INLINE_HPP\n+#define CPU_ZERO_STACKCHUNKFRAMESTREAM_ZERO_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+#ifdef ASSERT\n+template <chunk_frames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <chunk_frames frame_kind>\n+inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+#endif \/\/ CPU_ZERO_STACKCHUNKFRAMESTREAM_ZERO_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/zero\/stackChunkFrameStream_zero.inline.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_STACKCHUNKOOP_ZERO_INLINE_HPP\n+#define CPU_ZERO_STACKCHUNKOOP_ZERO_INLINE_HPP\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_ZERO_STACKCHUNKOOP_ZERO_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/zero\/stackChunkOop_zero.inline.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -38,3 +38,0 @@\n-  \/\/ Loom support\n-  static constexpr bool is_concurrent_gc() { return false; }\n-\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonBarrierSet.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -95,3 +95,0 @@\n-  \/\/ Loom support\n-  static constexpr bool is_concurrent_gc() { return false; }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableBarrierSet.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,3 +53,0 @@\n-  \/\/ Loom support\n-  static constexpr bool is_concurrent_gc() { return true; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,3 +38,0 @@\n-  \/\/ Loom support\n-  static constexpr bool is_concurrent_gc() { return true; }\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -202,17 +202,0 @@\n-template <typename Receiver, typename Base, typename BitMapClosureType>\n-static typename EnableIf<IsSame<Receiver, Base>::value, bool>::type\n-call_do_bit(bool (Receiver::*)(BitMap::idx_t), bool (Base::*)(BitMap::idx_t), BitMapClosureType* closure, BitMap::idx_t index) {\n-  return closure->do_bit(index);\n-}\n-\n-template <typename Receiver, typename Base, typename BitMapClosureType>\n-static typename EnableIf<!IsSame<Receiver, Base>::value, bool>::type\n-call_do_bit(bool (Receiver::*)(BitMap::idx_t), bool (Base::*)(BitMap::idx_t), BitMapClosureType* closure, BitMap::idx_t index) {\n-  return closure->BitMapClosureType::do_bit(index);\n-}\n-\n-template <typename BitMapClosureType>\n-inline bool Devirtualizer::do_bit(BitMapClosureType* closure, BitMap::idx_t index) {\n-  return call_do_bit(&BitMapClosureType::do_bit, &BitMapClosure::do_bit, closure, index);\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/iterator.inline.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -51,1 +51,3 @@\n-#include \"utilities\/bitMap.hpp\"\n+#include \"runtime\/smallRegisterMap.inline.hpp\"\n+#include \"runtime\/stackChunkFrameStream.inline.hpp\"\n+#include \"utilities\/bitMap.inline.hpp\"\n@@ -74,4 +76,4 @@\n-   const jint lh = Klass::instance_layout_helper(size_helper(), true);\n-   set_layout_helper(lh);\n-   assert(layout_helper_is_instance(layout_helper()), \"\");\n-   assert(layout_helper_needs_slow_path(layout_helper()), \"\");\n+  const jint lh = Klass::instance_layout_helper(size_helper(), true);\n+  set_layout_helper(lh);\n+  assert(layout_helper_is_instance(layout_helper()), \"\");\n+  assert(layout_helper_needs_slow_path(layout_helper()), \"\");\n@@ -85,6 +87,2 @@\n-template <int x> NOINLINE static bool verify_chunk(stackChunkOop c) { return c->verify(); }\n-\n-template <InstanceStackChunkKlass::copy_type overlap>\n-size_t InstanceStackChunkKlass::copy(oop obj, HeapWord* to_addr, size_t word_size) {\n-  assert(obj->is_stackChunk(), \"\");\n-  stackChunkOop chunk = (stackChunkOop)obj;\n+size_t InstanceStackChunkKlass::copy(oop obj, HeapWord* to_addr, size_t word_size, bool disjoint) {\n+  assert(obj->is_stackChunk(), \"Wrong object type\");\n@@ -93,2 +91,0 @@\n-  overlap == copy_type::DISJOINT ? Copy::aligned_disjoint_words(from_addr, to_addr, word_size)\n-                                 : Copy::aligned_conjoint_words(from_addr, to_addr, word_size);\n@@ -96,2 +92,2 @@\n-  stackChunkOop to_chunk = (stackChunkOop) cast_to_oop(to_addr);\n-  assert(!to_chunk->has_bitmap() || to_chunk->is_gc_mode(), \"\");\n+  disjoint ? Copy::aligned_disjoint_words(from_addr, to_addr, word_size)\n+           : Copy::aligned_conjoint_words(from_addr, to_addr, word_size);\n@@ -99,0 +95,2 @@\n+  \/\/ Build bitmap\n+  stackChunkOop to_chunk = (stackChunkOop) cast_to_oop(to_addr);\n@@ -101,0 +99,2 @@\n+  } else {\n+    assert(to_chunk->is_gc_mode(), \"Should be set when bitmaps were built\");\n@@ -106,2 +106,3 @@\n-template size_t InstanceStackChunkKlass::copy<InstanceStackChunkKlass::copy_type::CONJOINT>(oop obj, HeapWord* to_addr, size_t word_size);\n-template size_t InstanceStackChunkKlass::copy<InstanceStackChunkKlass::copy_type::DISJOINT>(oop obj, HeapWord* to_addr, size_t word_size);\n+void InstanceStackChunkKlass::copy_disjoint(oop obj, HeapWord* to, size_t word_size) {\n+  copy(obj, to, word_size, true \/* disjoint *\/);\n+}\n@@ -109,7 +110,2 @@\n-template <chunk_frames frame_kind>\n-int InstanceStackChunkKlass::count_frames(stackChunkOop chunk) {\n-  int frames = 0;\n-  for (StackChunkFrameStream<frame_kind> f(chunk); !f.is_done(); f.next(SmallRegisterMap::instance)) {\n-    frames++;\n-  }\n-  return frames;\n+void InstanceStackChunkKlass::copy_conjoint(oop obj, HeapWord* to, size_t word_size) {\n+  copy(obj, to, word_size, false \/* disjoint *\/);\n@@ -124,1 +120,0 @@\n-\n@@ -212,1 +207,0 @@\n-\n@@ -287,1 +281,1 @@\n-  chunk->iterate_stack(&frame_closure);\n+  iterate_stack(chunk, &frame_closure);\n@@ -320,1 +314,1 @@\n-  chunk->iterate_stack(&closure);\n+  iterate_stack(chunk, &closure);\n@@ -334,1 +328,0 @@\n-\n@@ -394,1 +387,1 @@\n-  chunk->iterate_stack(&closure);\n+  iterate_stack(chunk, &closure);\n@@ -422,1 +415,1 @@\n-  chunk->iterate_stack(&closure);\n+  iterate_stack(chunk, &closure);\n@@ -525,1 +518,1 @@\n-    chunk->iterate_stack(&closure);\n+    iterate_stack(chunk, &closure);\n@@ -528,1 +521,1 @@\n-    chunk->iterate_stack(&closure);\n+    iterate_stack(chunk, &closure);\n@@ -755,1 +748,1 @@\n-  chunk->iterate_stack(&closure);\n+  iterate_stack(chunk, &closure);\n@@ -902,1 +895,1 @@\n-    c->iterate_stack(&closure);\n+    iterate_stack(c, &closure);\n@@ -908,1 +901,1 @@\n-    c->iterate_stack(&describe);\n+    iterate_stack(c, &describe);\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":29,"deletions":36,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/stackChunkFrameStream.hpp\"\n@@ -34,1 +35,0 @@\n-class frame;\n@@ -36,0 +36,1 @@\n+class frame;\n@@ -40,2 +41,0 @@\n-template <chunk_frames = chunk_frames::MIXED> class StackChunkFrameStream;\n-\n@@ -102,3 +101,0 @@\n-private:\n-  enum class copy_type { CONJOINT, DISJOINT };\n-\n@@ -111,1 +107,1 @@\n-  friend class stackChunkOopDesc;\n+  \/\/friend class stackChunkOopDesc;\n@@ -113,4 +109,1 @@\n-  template <chunk_frames frames> friend class StackChunkFrameStream;\n-  friend class FixChunkIterateStackClosure;\n-  friend class MarkMethodsStackClosure;\n-  friend class OopOopIterateStackClosure;\n+  \/\/friend class OopOopIterateStackClosure;\n@@ -126,2 +119,0 @@\n-  static inline int metadata_words(); \/\/ size, in words, of frame metadata (e.g. pc and link)\n-  static inline int align_wiggle();   \/\/ size, in words, of maximum shift in frame position due to alignment\n@@ -139,0 +130,1 @@\n+\n@@ -143,0 +135,5 @@\n+  \/\/ size of frame metadata (e.g. pc and link) - in words\n+  static inline int metadata_words();\n+  \/\/ size of maximum shift in frame position due to alignment - in words\n+  static inline int align_wiggle();\n+\n@@ -146,3 +143,2 @@\n-  virtual void copy_disjoint(oop obj, HeapWord* to, size_t word_size) override { copy<copy_type::DISJOINT> (obj, to, word_size); }\n-  virtual void copy_conjoint(oop obj, HeapWord* to, size_t word_size) override { copy<copy_type::CONJOINT>(obj, to, word_size); }\n-\n+  virtual void copy_disjoint(oop obj, HeapWord* to, size_t word_size) override;\n+  virtual void copy_conjoint(oop obj, HeapWord* to, size_t word_size) override;\n@@ -154,1 +150,0 @@\n-  static inline void assert_mixed_correct(stackChunkOop chunk, chunk_frames frame_kind) PRODUCT_RETURN;\n@@ -163,3 +158,0 @@\n-  static HeapWord* start_of_stack(oop obj) { return (HeapWord*)(cast_from_oop<intptr_t>(obj) + offset_of_stack()); }\n-  static inline HeapWord* start_of_bitmap(oop obj);\n-\n@@ -173,4 +165,0 @@\n-\n-  template<chunk_frames frames = chunk_frames::MIXED>\n-  static int count_frames(stackChunkOop chunk);\n-\n@@ -213,1 +201,1 @@\n-  template<copy_type disjoint> size_t copy(oop obj, HeapWord* to, size_t word_size);\n+  size_t copy(oop obj, HeapWord* to, size_t word_size, bool disjoint);\n@@ -232,0 +220,3 @@\n+  template <class StackChunkFrameClosureType>\n+  static inline void iterate_stack(stackChunkOop obj, StackChunkFrameClosureType* closure);\n+\n@@ -242,97 +233,0 @@\n-\n-  template <copy_alignment alignment> inline static void copy_from_stack_to_chunk(void* from, void* to, size_t size);\n-  template <copy_alignment alignment> inline static void copy_from_chunk_to_stack(void* from, void* to, size_t size);\n-};\n-\n-template <chunk_frames frame_kind>\n-class StackChunkFrameStream : public StackObj {\n-private:\n-  intptr_t* _end;\n-  intptr_t* _sp;\n-  intptr_t* _unextended_sp; \/\/ used only when mixed\n-  CodeBlob* _cb;\n-  mutable const ImmutableOopMap* _oopmap;\n-\n-#ifndef PRODUCT\n-  stackChunkOop _chunk;\n-  int _index;\n-#endif\n-\n-#ifdef ASSERT\n-  int _has_stub;\n-#endif\n-\n-public:\n-  StackChunkFrameStream() { NOT_PRODUCT(_chunk = nullptr; _index = -1;) DEBUG_ONLY(_has_stub = false;) }\n-  inline StackChunkFrameStream(stackChunkOop chunk, bool gc = false);\n-  inline StackChunkFrameStream(stackChunkOop chunk, const frame& f);\n-\n-  bool is_done() const { return _sp >= _end; }\n-  bool is_last() const { return next_sp() >= _end; }\n-\n-  intptr_t* end() { return _end; }\n-  void set_end(intptr_t* end) { _end = end; }\n-\n-  \/\/ Query\n-  intptr_t* end() const { return _end; }\n-\n-  intptr_t*        sp() const  { return _sp; }\n-  inline address   pc() const  { return get_pc(); }\n-  inline intptr_t* fp() const;\n-  inline intptr_t* unextended_sp() const { return frame_kind == chunk_frames::MIXED ? _unextended_sp : _sp; }\n-  NOT_PRODUCT(int index() { return _index; })\n-  inline address orig_pc() const;\n-\n-  inline bool is_interpreted() const;\n-  inline bool is_stub() const;\n-  inline bool is_compiled() const;\n-  CodeBlob* cb() const { return _cb; }\n-  const ImmutableOopMap* oopmap() const { if (_oopmap == NULL) get_oopmap(); return _oopmap; }\n-  inline int frame_size() const;\n-  inline int stack_argsize() const;\n-  inline int num_oops() const;\n-\n-  inline void initialize_register_map(RegisterMap* map);\n-  template <typename RegisterMapT> inline void next(RegisterMapT* map);\n-\n-  template <typename RegisterMapT> inline void update_reg_map(RegisterMapT* map);\n-\n-  void handle_deopted() const;\n-\n-  inline int to_offset(stackChunkOop chunk) const { assert(!is_done(), \"\"); return _sp - chunk->start_address(); }\n-\n-  inline frame to_frame() const;\n-\n-#ifdef ASSERT\n-  bool is_in_frame(void* p) const;\n-  bool is_deoptimized() const;\n-  template <typename RegisterMapT> bool is_in_oops(void* p, const RegisterMapT* map) const;\n-#endif\n-\n-  void print_on(outputStream* st) const PRODUCT_RETURN;\n-\n- private:\n-  inline address get_pc() const;\n-  inline void get_cb();\n-\n-  inline intptr_t* next_sp() const;\n-  inline int interpreter_frame_size() const;\n-  inline int interpreter_frame_num_oops() const;\n-  inline int interpreter_frame_stack_argsize() const;\n-  inline void next_for_interpreter_frame();\n-  inline intptr_t* next_sp_for_interpreter_frame() const;\n-  inline intptr_t* unextended_sp_for_interpreter_frame() const;\n-  inline intptr_t* derelativize(int offset) const;\n-  inline void get_oopmap() const;\n-  inline void get_oopmap(address pc, int oopmap_slot) const;\n-\n-  template <typename RegisterMapT> inline void update_reg_map_pd(RegisterMapT* map);\n-\n-  template <typename RegisterMapT>\n-  inline void* reg_to_loc(VMReg reg, const RegisterMapT* map) const;\n-\n-public:\n-  template <class OopClosureType, class RegisterMapT>\n-  inline void iterate_oops(OopClosureType* closure, const RegisterMapT* map) const;\n-  template <class DerivedOopClosureType, class RegisterMapT>\n-  inline void iterate_derived_pointers(DerivedOopClosureType* closure, const RegisterMapT* map) const;\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.hpp","additions":16,"deletions":122,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+#include \"runtime\/smallRegisterMap.inline.hpp\"\n+#include \"runtime\/stackChunkFrameStream.inline.hpp\"\n@@ -52,4 +54,0 @@\n-#ifdef ASSERT\n-extern \"C\" bool dbg_is_safe(const void* p, intptr_t errvalue);\n-#endif\n-\n@@ -58,356 +56,0 @@\n-inline void copy_from_stack_to_chunk(intptr_t* from, intptr_t* to, int size);\n-inline void copy_from_chunk_to_stack(intptr_t* from, intptr_t* to, int size);\n-\n-template <copy_alignment alignment>\n-inline void InstanceStackChunkKlass::copy_from_stack_to_chunk(void* from, void* to, size_t size) {\n-  memcpy(to, from, size << LogBytesPerWord);\n-}\n-\n-template <copy_alignment alignment>\n-inline void InstanceStackChunkKlass::copy_from_chunk_to_stack(void* from, void* to, size_t size) {\n-  memcpy(to, from, size << LogBytesPerWord);\n-}\n-\n-template <chunk_frames frame_kind>\n-StackChunkFrameStream<frame_kind>::StackChunkFrameStream(stackChunkOop chunk, bool gc) DEBUG_ONLY(: _chunk(chunk)) {\n-  assert (chunk->is_stackChunk(), \"\");\n-  assert (frame_kind == chunk_frames::MIXED || !chunk->has_mixed_frames(), \"\");\n-\n-  DEBUG_ONLY(_index = 0;)\n-  _end = chunk->bottom_address();\n-  _sp = chunk->start_address() + chunk->sp();\n-  assert (_sp <= chunk->end_address() + InstanceStackChunkKlass::metadata_words(), \"\");\n-\n-  get_cb();\n-\n-  if (frame_kind == chunk_frames::MIXED) {\n-    _unextended_sp = (!is_done() && is_interpreted()) ? unextended_sp_for_interpreter_frame() : _sp;\n-    assert (_unextended_sp >= _sp - InstanceStackChunkKlass::metadata_words(), \"\");\n-  }\n-  DEBUG_ONLY(else _unextended_sp = nullptr;)\n-\n-  if (is_stub()) {\n-    get_oopmap(pc(), 0);\n-    DEBUG_ONLY(_has_stub = true);\n-  } DEBUG_ONLY(else _has_stub = false;)\n-}\n-\n-template <chunk_frames frame_kind>\n-StackChunkFrameStream<frame_kind>::StackChunkFrameStream(stackChunkOop chunk, const frame& f)\n-  DEBUG_ONLY(: _chunk(chunk)) {\n-  assert (chunk->is_stackChunk(), \"\");\n-  assert (frame_kind == chunk_frames::MIXED || !chunk->has_mixed_frames(), \"\");\n-  \/\/ assert (!is_empty(), \"\"); -- allowed to be empty\n-\n-  DEBUG_ONLY(_index = 0;)\n-\n-  _end = chunk->bottom_address();\n-\n-  assert (chunk->is_in_chunk(f.sp()), \"\");\n-  _sp = f.sp();\n-  if (frame_kind == chunk_frames::MIXED) {\n-    _unextended_sp = f.unextended_sp();\n-    assert (_unextended_sp >= _sp - InstanceStackChunkKlass::metadata_words(), \"\");\n-  }\n-  DEBUG_ONLY(else _unextended_sp = nullptr;)\n-  assert (_sp >= chunk->start_address() && _sp <= chunk->end_address() + InstanceStackChunkKlass::metadata_words(), \"\");\n-\n-  if (f.cb() != nullptr) {\n-    _oopmap = nullptr;\n-    _cb = f.cb();\n-  } else {\n-    get_cb();\n-  }\n-\n-  if (is_stub()) {\n-    get_oopmap(pc(), 0);\n-    DEBUG_ONLY(_has_stub = true);\n-  } DEBUG_ONLY(else _has_stub = false;)\n-}\n-\n-template <chunk_frames frame_kind>\n-inline bool StackChunkFrameStream<frame_kind>::is_stub() const {\n-  return cb() != nullptr && (_cb->is_safepoint_stub() || _cb->is_runtime_stub());\n-}\n-\n-template <chunk_frames frame_kind>\n-inline bool StackChunkFrameStream<frame_kind>::is_compiled() const {\n-  return cb() != nullptr && _cb->is_compiled();\n-}\n-\n-template <>\n-inline bool StackChunkFrameStream<chunk_frames::MIXED>::is_interpreted() const {\n-  return !is_done() && Interpreter::contains(pc());\n-}\n-\n-template <>\n-inline bool StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::is_interpreted() const {\n-  return false;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::frame_size() const {\n-  return is_interpreted() ? interpreter_frame_size()\n-                          : cb()->frame_size() + stack_argsize();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::stack_argsize() const {\n-  if (is_interpreted()) {\n-    return interpreter_frame_stack_argsize();\n-  }\n-  if (is_stub()) {\n-    return 0;\n-  }\n-  guarantee (cb() != nullptr, \"\");\n-  guarantee (cb()->is_compiled(), \"\");\n-  guarantee (cb()->as_compiled_method()->method() != nullptr, \"\");\n-  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n-}\n-\n-template <chunk_frames frame_kind>\n-inline int StackChunkFrameStream<frame_kind>::num_oops() const {\n-  return is_interpreted() ? interpreter_frame_num_oops() : oopmap()->num_oops();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::initialize_register_map(RegisterMap* map) {\n-  update_reg_map_pd(map);\n-}\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::next(RegisterMapT* map) {\n-  update_reg_map(map);\n-  bool safepoint = is_stub();\n-  if (frame_kind == chunk_frames::MIXED) {\n-    if (is_interpreted()) {\n-      next_for_interpreter_frame();\n-    } else {\n-      _sp = _unextended_sp + cb()->frame_size();\n-      if (_sp >= _end - InstanceStackChunkKlass::metadata_words()) {\n-        _sp = _end;\n-      }\n-      _unextended_sp = is_interpreted() ? unextended_sp_for_interpreter_frame() : _sp;\n-    }\n-    assert (_unextended_sp >= _sp - InstanceStackChunkKlass::metadata_words(), \"\");\n-  } else {\n-    _sp += cb()->frame_size();\n-  }\n-  assert (!is_interpreted() || _unextended_sp == unextended_sp_for_interpreter_frame(), \"\");\n-\n-  get_cb();\n-  update_reg_map_pd(map);\n-  if (safepoint && cb() != nullptr) {\n-    \/\/ there's no post-call nop and no fast oopmap lookup\n-    _oopmap = cb()->oop_map_for_return_address(pc());\n-  }\n-  DEBUG_ONLY(_index++;)\n-}\n-\n-template <chunk_frames frame_kind>\n-inline intptr_t* StackChunkFrameStream<frame_kind>::next_sp() const {\n-  return is_interpreted() ? next_sp_for_interpreter_frame() : unextended_sp() + cb()->frame_size();\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::get_cb() {\n-  _oopmap = nullptr;\n-  if (is_done() || is_interpreted()) {\n-    _cb = nullptr;\n-    return;\n-  }\n-\n-  assert (pc() != nullptr && dbg_is_safe(pc(), -1), \"\");\n-\n-  _cb = CodeCache::find_blob_fast(pc());\n-\n-  assert (_cb != nullptr, \"\");\n-  assert (is_interpreted() || ((is_stub() || is_compiled()) && _cb->frame_size() > 0), \"\");\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::get_oopmap() const {\n-  if (is_interpreted()) {\n-    return;\n-  }\n-  assert (is_compiled(), \"\");\n-  get_oopmap(pc(), CodeCache::find_oopmap_slot_fast(pc()));\n-}\n-\n-template <chunk_frames frame_kind>\n-inline void StackChunkFrameStream<frame_kind>::get_oopmap(address pc, int oopmap_slot) const {\n-  assert (cb() != nullptr, \"\");\n-  assert (!is_compiled() || !cb()->as_compiled_method()->is_deopt_pc(pc), \"\");\n-  if (oopmap_slot >= 0) {\n-    assert (oopmap_slot >= 0, \"\");\n-    assert (cb()->oop_map_for_slot(oopmap_slot, pc) != nullptr, \"\");\n-    assert (cb()->oop_map_for_slot(oopmap_slot, pc) == cb()->oop_map_for_return_address(pc), \"\");\n-\n-    _oopmap = cb()->oop_map_for_slot(oopmap_slot, pc);\n-  } else {\n-    _oopmap = cb()->oop_map_for_return_address(pc);\n-  }\n-  assert (_oopmap != nullptr, \"\");\n-}\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-inline void* StackChunkFrameStream<frame_kind>::reg_to_loc(VMReg reg, const RegisterMapT* map) const {\n-  assert (!is_done(), \"\");\n-  return reg->is_reg() ? (void*)map->location(reg, sp()) \/\/ see frame::update_map_with_saved_link(&map, link_addr);\n-                       : (void*)((address)unextended_sp() + (reg->reg2stack() * VMRegImpl::stack_slot_size));\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map(RegisterMap* map) {\n-  assert (!map->in_cont() || map->stack_chunk() == _chunk, \"\");\n-  if (map->update_map() && is_stub()) {\n-    frame f = to_frame();\n-    oopmap()->update_register_map(&f, map); \/\/ we have callee-save registers in this case\n-  }\n-}\n-\n-template<>\n-template<>\n-inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map(RegisterMap* map) {\n-  assert (map->in_cont() && map->stack_chunk()() == _chunk, \"\");\n-  if (map->update_map()) {\n-    frame f = to_frame();\n-    oopmap()->update_register_map(&f, map); \/\/ we have callee-save registers in this case\n-  }\n-}\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::update_reg_map(RegisterMapT* map) {}\n-\n-template <chunk_frames frame_kind>\n-inline address StackChunkFrameStream<frame_kind>::orig_pc() const {\n-  address pc1 = pc();\n-  if (is_interpreted() || is_stub()) {\n-    return pc1;\n-  }\n-  CompiledMethod* cm = cb()->as_compiled_method();\n-  if (cm->is_deopt_pc(pc1)) {\n-    pc1 = *(address*)((address)unextended_sp() + cm->orig_pc_offset());\n-  }\n-\n-  assert (pc1 != nullptr && !cm->is_deopt_pc(pc1), \"\");\n-  assert (_cb == CodeCache::find_blob_fast(pc1), \"\");\n-\n-  return pc1;\n-}\n-\n-#ifdef ASSERT\n-template <chunk_frames frame_kind>\n-bool StackChunkFrameStream<frame_kind>::is_deoptimized() const {\n-  address pc1 = pc();\n-  return is_compiled() && CodeCache::find_oopmap_slot_fast(pc1) < 0 && cb()->as_compiled_method()->is_deopt_pc(pc1);\n-}\n-#endif\n-\n-template<chunk_frames frame_kind>\n-void StackChunkFrameStream<frame_kind>::handle_deopted() const {\n-  assert (!is_done(), \"\");\n-\n-  if (_oopmap != nullptr) {\n-    return;\n-  }\n-  if (is_interpreted()) {\n-    return;\n-  }\n-  assert (is_compiled(), \"\");\n-\n-  address pc1 = pc();\n-  int oopmap_slot = CodeCache::find_oopmap_slot_fast(pc1);\n-  if (UNLIKELY(oopmap_slot < 0)) { \/\/ we could have marked frames for deoptimization in thaw_chunk\n-    if (cb()->as_compiled_method()->is_deopt_pc(pc1)) {\n-      pc1 = orig_pc();\n-      oopmap_slot = CodeCache::find_oopmap_slot_fast(pc1);\n-    }\n-  }\n-  get_oopmap(pc1, oopmap_slot);\n-}\n-\n-template <chunk_frames frame_kind>\n-template <class OopClosureType, class RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::iterate_oops(OopClosureType* closure, const RegisterMapT* map) const {\n-  if (is_interpreted()) {\n-    frame f = to_frame();\n-    f.oops_interpreted_do(closure, nullptr, true);\n-  } else {\n-    DEBUG_ONLY(int oops = 0;)\n-    for (OopMapStream oms(oopmap()); !oms.is_done(); oms.next()) {\n-      OopMapValue omv = oms.current();\n-      if (omv.type() != OopMapValue::oop_value && omv.type() != OopMapValue::narrowoop_value) {\n-        continue;\n-      }\n-\n-      assert (UseCompressedOops || omv.type() == OopMapValue::oop_value, \"\");\n-      DEBUG_ONLY(oops++;)\n-\n-      void* p = reg_to_loc(omv.reg(), map);\n-      assert (p != nullptr, \"\");\n-      assert ((_has_stub && _index == 1) || is_in_frame(p), \"\");\n-\n-      log_develop_trace(jvmcont)(\"StackChunkFrameStream::iterate_oops narrow: %d reg: %s p: \" INTPTR_FORMAT \" sp offset: \" INTPTR_FORMAT,\n-          omv.type() == OopMapValue::narrowoop_value, omv.reg()->name(), p2i(p), (intptr_t*)p - sp());\n-          omv.type() == OopMapValue::narrowoop_value ? Devirtualizer::do_oop(closure, (narrowOop*)p) : Devirtualizer::do_oop(closure, (oop*)p);\n-    }\n-    assert (oops == oopmap()->num_oops(), \"oops: %d oopmap->num_oops(): %d\", oops, oopmap()->num_oops());\n-  }\n-}\n-\n-template <chunk_frames frame_kind>\n-template <class DerivedOopClosureType, class RegisterMapT>\n-inline void StackChunkFrameStream<frame_kind>::iterate_derived_pointers(DerivedOopClosureType* closure, const RegisterMapT* map) const {\n-  if (is_interpreted()) {\n-    return;\n-  }\n-\n-  for (OopMapStream oms(oopmap()); !oms.is_done(); oms.next()) {\n-    OopMapValue omv = oms.current();\n-    if (omv.type() != OopMapValue::derived_oop_value) {\n-      continue;\n-    }\n-\n-    \/\/ see OopMapDo<OopMapFnT, DerivedOopFnT, ValueFilterT>::walk_derived_pointers1\n-    intptr_t* derived_loc = (intptr_t*)reg_to_loc(omv.reg(), map);\n-    intptr_t* base_loc    = (intptr_t*)reg_to_loc(omv.content_reg(), map);\n-\n-    assert ((_has_stub && _index == 1) || is_in_frame(base_loc), \"\");\n-    assert ((_has_stub && _index == 1) || is_in_frame(derived_loc), \"\");\n-    assert (derived_loc != base_loc, \"Base and derived in same location\");\n-    assert (is_in_oops(base_loc, map), \"not found: \" INTPTR_FORMAT, p2i(base_loc));\n-    assert (!is_in_oops(derived_loc, map), \"found: \" INTPTR_FORMAT, p2i(derived_loc));\n-\n-    Devirtualizer::do_derived_oop(closure, (oop*)base_loc, (derived_pointer*)derived_loc);\n-  }\n-  OrderAccess::storestore(); \/\/ to preserve that we set the offset *before* fixing the base oop\n-}\n-\n-#ifdef ASSERT\n-\n-template <chunk_frames frame_kind>\n-template <typename RegisterMapT>\n-bool StackChunkFrameStream<frame_kind>::is_in_oops(void* p, const RegisterMapT* map) const {\n-  for (OopMapStream oms(oopmap()); !oms.is_done(); oms.next()) {\n-    if (oms.current().type() != OopMapValue::oop_value) {\n-      continue;\n-    }\n-    if (reg_to_loc(oms.current().reg(), map) == p) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-#endif\n-\n-#ifdef ASSERT\n-void InstanceStackChunkKlass::assert_mixed_correct(stackChunkOop chunk, chunk_frames frame_kind) {\n-  assert (!chunk->has_mixed_frames() || frame_kind == chunk_frames::MIXED, \"\");\n-}\n-#endif\n-\n@@ -418,4 +60,0 @@\n-inline HeapWord* InstanceStackChunkKlass::start_of_bitmap(oop obj) {\n-  return start_of_stack(obj) + jdk_internal_vm_StackChunk::size(obj);\n-}\n-\n@@ -534,1 +172,1 @@\n-class StackChunkOopIterateBitmapClosure : public BitMapClosure {\n+class StackChunkOopIterateBitmapClosure {\n@@ -541,1 +179,1 @@\n-  bool do_bit(BitMap::idx_t index) override {\n+  bool do_bit(BitMap::idx_t index) {\n@@ -565,0 +203,6 @@\n+template <class StackChunkFrameClosureType>\n+inline void InstanceStackChunkKlass::iterate_stack(stackChunkOop obj, StackChunkFrameClosureType* closure) {\n+  obj->has_mixed_frames() ? iterate_stack<chunk_frames::MIXED>(obj, closure)\n+                          : iterate_stack<chunk_frames::COMPILED_ONLY>(obj, closure);\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":10,"deletions":366,"binary":false,"changes":376,"status":"modified"},{"patch":"@@ -34,6 +34,2 @@\n-\n-#ifdef ASSERT\n-bool stackChunkOopDesc::verify(size_t* out_size, int* out_oops, int* out_frames, int* out_interpreted_frames) {\n-  return InstanceStackChunkKlass::verify(this, out_size, out_oops, out_frames, out_interpreted_frames);\n-}\n-#endif\n+#include \"runtime\/smallRegisterMap.inline.hpp\"\n+#include \"runtime\/stackChunkFrameStream.inline.hpp\"\n@@ -142,0 +138,6 @@\n+\n+#ifdef ASSERT\n+bool stackChunkOopDesc::verify(size_t* out_size, int* out_oops, int* out_frames, int* out_interpreted_frames) {\n+  return InstanceStackChunkKlass::verify(this, out_size, out_oops, out_frames, out_interpreted_frames);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-enum chunk_frames { COMPILED_ONLY, MIXED };\n-enum copy_alignment { WORD_ALIGNED, DWORD_ALIGNED };\n-\n@@ -59,2 +56,0 @@\n-  inline void set_parent_raw(oop value);\n-  template<typename P>\n@@ -62,0 +57,3 @@\n+  template<typename P>\n+  inline void set_parent_raw(oop value);\n+\n@@ -63,0 +61,1 @@\n+\n@@ -65,0 +64,1 @@\n+\n@@ -67,0 +67,1 @@\n+\n@@ -69,0 +70,1 @@\n+\n@@ -71,0 +73,1 @@\n+\n@@ -80,1 +83,0 @@\n-  inline bool is_empty() const;\n@@ -82,0 +84,3 @@\n+\n+  inline HeapWord* start_of_stack() const;\n+\n@@ -86,0 +91,2 @@\n+\n+\n@@ -88,0 +95,2 @@\n+\n+  inline bool is_empty() const;\n@@ -90,0 +99,1 @@\n+\n@@ -94,0 +104,1 @@\n+\n@@ -96,1 +107,1 @@\n-  inline bool has_thaw_slowpath_condition() const;\n+\n@@ -99,0 +110,1 @@\n+\n@@ -101,0 +113,3 @@\n+\n+  inline bool has_thaw_slowpath_condition() const;\n+\n@@ -103,0 +118,3 @@\n+  inline frame relativize(frame fr) const;\n+  inline frame derelativize(frame fr) const;\n+\n@@ -110,6 +128,0 @@\n-  bool verify(size_t* out_size = NULL, int* out_oops = NULL,\n-              int* out_frames = NULL, int* out_interpreted_frames = NULL) NOT_DEBUG({ return true; });\n-\n-  template <class StackChunkFrameClosureType>\n-  inline void iterate_stack(StackChunkFrameClosureType* closure);\n-\n@@ -136,2 +148,2 @@\n-  template <copy_alignment alignment> inline void copy_from_stack_to_chunk(intptr_t* from, intptr_t* to, int size);\n-  template <copy_alignment alignment> inline void copy_from_chunk_to_stack(intptr_t* from, intptr_t* to, int size);\n+  inline void copy_from_stack_to_chunk(intptr_t* from, intptr_t* to, int size);\n+  inline void copy_from_chunk_to_stack(intptr_t* from, intptr_t* to, int size);\n@@ -142,2 +154,2 @@\n-  inline frame relativize(frame fr) const;\n-  inline frame derelativize(frame fr) const;\n+  bool verify(size_t* out_size = NULL, int* out_oops = NULL,\n+              int* out_frames = NULL, int* out_interpreted_frames = NULL) NOT_DEBUG({ return true; });\n@@ -146,2 +158,0 @@\n-  template <chunk_frames frames, class StackChunkFrameClosureType>\n-  inline void iterate_stack(StackChunkFrameClosureType* closure);\n@@ -150,2 +160,0 @@\n-  inline void relativize_frame(frame& fr) const;\n-  inline void derelativize_frame(frame& fr) const;\n@@ -155,0 +163,3 @@\n+  inline void relativize_frame(frame& fr) const;\n+  inline void derelativize_frame(frame& fr) const;\n+\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":32,"deletions":21,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include CPU_HEADER_INLINE(stackChunkOop)\n@@ -40,0 +41,2 @@\n+template<typename P>\n+inline bool stackChunkOopDesc::is_parent_null() const               { return jdk_internal_vm_StackChunk::is_parent_null<P>(as_oop()); }\n@@ -41,17 +44,23 @@\n-template<typename P> inline void stackChunkOopDesc::set_parent_raw(oop value) { jdk_internal_vm_StackChunk::set_parent_raw<P>(this, value); }\n-template<typename P> inline bool stackChunkOopDesc::is_parent_null() const    { return jdk_internal_vm_StackChunk::is_parent_null<P>(as_oop()); }\n-inline int stackChunkOopDesc::stack_size() const         { return jdk_internal_vm_StackChunk::size(as_oop()); }\n-inline int stackChunkOopDesc::sp() const                 { return jdk_internal_vm_StackChunk::sp(as_oop()); }\n-inline void stackChunkOopDesc::set_sp(int value)         { jdk_internal_vm_StackChunk::set_sp(this, value); }\n-inline address stackChunkOopDesc::pc() const             { return (address)jdk_internal_vm_StackChunk::pc(as_oop()); }\n-inline void stackChunkOopDesc::set_pc(address value)     { jdk_internal_vm_StackChunk::set_pc(this, (intptr_t)value); }\n-inline int stackChunkOopDesc::argsize() const            { return jdk_internal_vm_StackChunk::argsize(as_oop()); }\n-inline void stackChunkOopDesc::set_argsize(int value)    { jdk_internal_vm_StackChunk::set_argsize(as_oop(), value); }\n-inline uint8_t stackChunkOopDesc::flags() const          { return jdk_internal_vm_StackChunk::flags(as_oop()); }\n-inline void stackChunkOopDesc::set_flags(uint8_t value)  { jdk_internal_vm_StackChunk::set_flags(this, value); }\n-inline int stackChunkOopDesc::max_size() const           { return jdk_internal_vm_StackChunk::maxSize(as_oop()); }\n-inline void stackChunkOopDesc::set_max_size(int value)   { jdk_internal_vm_StackChunk::set_maxSize(this, (jint)value); }\n-inline void stackChunkOopDesc::set_cont(oop value) { jdk_internal_vm_StackChunk::set_cont(this, value); }\n-template<typename P> inline void stackChunkOopDesc::set_cont_raw(oop value)   { jdk_internal_vm_StackChunk::set_cont_raw<P>(this, value); }\n-inline oop stackChunkOopDesc::cont() const  { return UseCompressedOops ? cont<narrowOop>() : cont<oop>(); \/* jdk_internal_vm_StackChunk::cont(as_oop()); *\/ }\n-template<typename P> inline oop stackChunkOopDesc::cont() const {\n+template<typename P>\n+inline void stackChunkOopDesc::set_parent_raw(oop value)            { jdk_internal_vm_StackChunk::set_parent_raw<P>(this, value); }\n+\n+inline int stackChunkOopDesc::stack_size() const        { return jdk_internal_vm_StackChunk::size(as_oop()); }\n+\n+inline int stackChunkOopDesc::sp() const                { return jdk_internal_vm_StackChunk::sp(as_oop()); }\n+inline void stackChunkOopDesc::set_sp(int value)        { jdk_internal_vm_StackChunk::set_sp(this, value); }\n+\n+inline address stackChunkOopDesc::pc() const            { return (address)jdk_internal_vm_StackChunk::pc(as_oop()); }\n+inline void stackChunkOopDesc::set_pc(address value)    { jdk_internal_vm_StackChunk::set_pc(this, (intptr_t)value); }\n+\n+inline int stackChunkOopDesc::argsize() const           { return jdk_internal_vm_StackChunk::argsize(as_oop()); }\n+inline void stackChunkOopDesc::set_argsize(int value)   { jdk_internal_vm_StackChunk::set_argsize(as_oop(), value); }\n+\n+inline uint8_t stackChunkOopDesc::flags() const         { return jdk_internal_vm_StackChunk::flags(as_oop()); }\n+inline void stackChunkOopDesc::set_flags(uint8_t value) { jdk_internal_vm_StackChunk::set_flags(this, value); }\n+\n+inline int stackChunkOopDesc::max_size() const          { return jdk_internal_vm_StackChunk::maxSize(as_oop()); }\n+inline void stackChunkOopDesc::set_max_size(int value)  { jdk_internal_vm_StackChunk::set_maxSize(this, (jint)value); }\n+\n+inline oop stackChunkOopDesc::cont() const              { return UseCompressedOops ? cont<narrowOop>() : cont<oop>(); \/* jdk_internal_vm_StackChunk::cont(as_oop()); *\/ }\n+template<typename P>\n+inline oop stackChunkOopDesc::cont() const              {\n@@ -62,0 +71,3 @@\n+inline void stackChunkOopDesc::set_cont(oop value)      { jdk_internal_vm_StackChunk::set_cont(this, value); }\n+template<typename P>\n+inline void stackChunkOopDesc::set_cont_raw(oop value)  {  jdk_internal_vm_StackChunk::set_cont_raw<P>(this, value); }\n@@ -65,1 +77,5 @@\n-inline intptr_t* stackChunkOopDesc::start_address() const { return (intptr_t*)InstanceStackChunkKlass::start_of_stack(as_oop()); }\n+inline HeapWord* stackChunkOopDesc::start_of_stack() const {\n+   return (HeapWord*)(cast_from_oop<intptr_t>(as_oop()) + InstanceStackChunkKlass::offset_of_stack());\n+}\n+\n+inline intptr_t* stackChunkOopDesc::start_address() const { return (intptr_t*)start_of_stack(); }\n@@ -120,4 +136,0 @@\n-inline bool stackChunkOopDesc::requires_barriers() {\n-  return Universe::heap()->requires_barriers(this);\n-}\n-\n@@ -126,0 +138,1 @@\n+\n@@ -128,0 +141,1 @@\n+\n@@ -130,0 +144,1 @@\n+\n@@ -132,3 +147,2 @@\n-inline intptr_t* stackChunkOopDesc::relative_base() const {\n-  \/\/ we relativize with respect to end rather than start because GC might compact the chunk\n-  return end_address() + InstanceStackChunkKlass::metadata_words();\n+inline bool stackChunkOopDesc::requires_barriers() {\n+  return Universe::heap()->requires_barriers(this);\n@@ -137,6 +151,16 @@\n-inline intptr_t* stackChunkOopDesc::derelativize_address(int offset) const {\n-  intptr_t* base = relative_base();\n-  intptr_t* p = base - offset;\n-  \/\/ tty->print_cr(\">>> derelativize_address: %d -> %p (base: %p)\", offset, p, base);\n-  assert(start_address() <= p && p <= base, \"\");\n-  return p;\n+inline frame stackChunkOopDesc::relativize(frame fr)   const { relativize_frame(fr);   return fr; }\n+inline frame stackChunkOopDesc::derelativize(frame fr) const { derelativize_frame(fr); return fr; }\n+\n+inline BitMapView stackChunkOopDesc::bitmap() const {\n+  int stack_sz = stack_size();\n+\n+  \/\/ The bitmap is located after the stack\n+  HeapWord* bitmap_addr = start_of_stack() + stack_sz;\n+  size_t bitmap_size = InstanceStackChunkKlass::bitmap_size(stack_sz);\n+  size_t bitmap_size_in_bits = bitmap_size << LogBitsPerWord;\n+\n+  BitMapView bitmap((BitMap::bm_word_t*)bitmap_addr, bitmap_size_in_bits);\n+\n+  DEBUG_ONLY(bitmap.verify_range(bit_index_for(start_address()), bit_index_for(end_address()));)\n+\n+  return bitmap;\n@@ -145,7 +169,2 @@\n-inline int stackChunkOopDesc::relativize_address(intptr_t* p) const {\n-  intptr_t* base = relative_base();\n-  intptr_t offset = base - p;\n-  \/\/ tty->print_cr(\">>> relativize_address: %p -> %ld (base: %p)\", p, offset, base);\n-  assert(start_address() <= p && p <= base, \"\");\n-  assert(0 <= offset && offset <= std::numeric_limits<int>::max(), \"\");\n-  return offset;\n+inline BitMap::idx_t stackChunkOopDesc::bit_offset() const {\n+  return InstanceStackChunkKlass::bit_offset(stack_size());\n@@ -154,4 +173,2 @@\n-inline void stackChunkOopDesc::relativize_frame(frame& fr) const {\n-  fr.set_offset_sp(relativize_address(fr.sp()));\n-  fr.set_offset_unextended_sp(relativize_address(fr.unextended_sp()));\n-  relativize_frame_pd(fr);\n+inline BitMap::idx_t stackChunkOopDesc::bit_index_for(intptr_t* p) const {\n+  return UseCompressedOops ? bit_index_for((narrowOop*)p) : bit_index_for((oop*)p);\n@@ -160,4 +177,3 @@\n-inline void stackChunkOopDesc::derelativize_frame(frame& fr) const {\n-  fr.set_sp(derelativize_address(fr.offset_sp()));\n-  fr.set_unextended_sp(derelativize_address(fr.offset_unextended_sp()));\n-  derelativize_frame_pd(fr);\n+template <typename OopT>\n+inline BitMap::idx_t stackChunkOopDesc::bit_index_for(OopT* p) const {\n+  return bit_offset() + (p - (OopT*)start_address());\n@@ -166,2 +182,12 @@\n-inline frame stackChunkOopDesc::relativize(frame fr)   const { relativize_frame(fr);   return fr; }\n-inline frame stackChunkOopDesc::derelativize(frame fr) const { derelativize_frame(fr); return fr; }\n+inline intptr_t* stackChunkOopDesc::address_for_bit(BitMap::idx_t index) const {\n+  return UseCompressedOops ? (intptr_t*)address_for_bit<narrowOop>(index) : (intptr_t*)address_for_bit<oop>(index);\n+}\n+\n+template <typename OopT>\n+inline OopT* stackChunkOopDesc::address_for_bit(BitMap::idx_t index) const {\n+  return (OopT*)start_address() + (index - bit_offset());\n+}\n+\n+inline MemRegion stackChunkOopDesc::range() {\n+  return MemRegion((HeapWord*)this, size());\n+}\n@@ -179,0 +205,5 @@\n+inline address stackChunkOopDesc::usp_offset_to_location(const frame& fr, const int usp_offset_in_bytes) const {\n+  assert(fr.is_compiled_frame(), \"\");\n+  return (address)derelativize_address(fr.offset_unextended_sp()) + usp_offset_in_bytes;\n+}\n+\n@@ -189,5 +220,0 @@\n-inline address stackChunkOopDesc::usp_offset_to_location(const frame& fr, const int usp_offset_in_bytes) const {\n-  assert(fr.is_compiled_frame(), \"\");\n-  return (address)derelativize_address(fr.offset_unextended_sp()) + usp_offset_in_bytes;\n-}\n-\n@@ -214,1 +240,0 @@\n-template <copy_alignment alignment>\n@@ -225,1 +250,1 @@\n-  InstanceStackChunkKlass::copy_from_stack_to_chunk<alignment>(from, to, size);\n+  memcpy(to, from, size << LogBytesPerWord);\n@@ -228,1 +253,0 @@\n-template <copy_alignment alignment>\n@@ -239,21 +263,1 @@\n-  InstanceStackChunkKlass::copy_from_chunk_to_stack<alignment>(from, to, size);\n-}\n-\n-inline BitMapView stackChunkOopDesc::bitmap() const {\n-  assert(has_bitmap(), \"\");\n-  size_t size_in_bits = InstanceStackChunkKlass::bitmap_size(stack_size()) << LogBitsPerWord;\n-#ifdef ASSERT\n-  BitMapView bm((BitMap::bm_word_t*)InstanceStackChunkKlass::start_of_bitmap(as_oop()), size_in_bits);\n-  assert(bm.size() == size_in_bits, \"bm.size(): %zu size_in_bits: %zu\", bm.size(), size_in_bits);\n-  assert(bm.size_in_words() == (size_t)InstanceStackChunkKlass::bitmap_size(stack_size()), \"\");\n-  bm.verify_range(bit_index_for(start_address()), bit_index_for(end_address()));\n-#endif\n-  return BitMapView((BitMap::bm_word_t*)InstanceStackChunkKlass::start_of_bitmap(as_oop()), size_in_bits);\n-}\n-\n-inline BitMap::idx_t stackChunkOopDesc::bit_offset() const {\n-  return InstanceStackChunkKlass::bit_offset(stack_size());\n-}\n-\n-inline BitMap::idx_t stackChunkOopDesc::bit_index_for(intptr_t* p) const {\n-  return UseCompressedOops ? bit_index_for((narrowOop*)p) : bit_index_for((oop*)p);\n+  memcpy(to, from, size << LogBytesPerWord);\n@@ -262,3 +266,3 @@\n-template <typename OopT>\n-inline BitMap::idx_t stackChunkOopDesc::bit_index_for(OopT* p) const {\n-  return bit_offset() + (p - (OopT*)start_address());\n+inline intptr_t* stackChunkOopDesc::relative_base() const {\n+  \/\/ we relativize with respect to end rather than start because GC might compact the chunk\n+  return end_address() + InstanceStackChunkKlass::metadata_words();\n@@ -267,2 +271,6 @@\n-inline intptr_t* stackChunkOopDesc::address_for_bit(BitMap::idx_t index) const {\n-  return UseCompressedOops ? (intptr_t*)address_for_bit<narrowOop>(index) : (intptr_t*)address_for_bit<oop>(index);\n+inline intptr_t* stackChunkOopDesc::derelativize_address(int offset) const {\n+  intptr_t* base = relative_base();\n+  intptr_t* p = base - offset;\n+  \/\/ tty->print_cr(\">>> derelativize_address: %d -> %p (base: %p)\", offset, p, base);\n+  assert(start_address() <= p && p <= base, \"\");\n+  return p;\n@@ -271,3 +279,7 @@\n-template <typename OopT>\n-inline OopT* stackChunkOopDesc::address_for_bit(BitMap::idx_t index) const {\n-  return (OopT*)start_address() + (index - bit_offset());\n+inline int stackChunkOopDesc::relativize_address(intptr_t* p) const {\n+  intptr_t* base = relative_base();\n+  intptr_t offset = base - p;\n+  \/\/ tty->print_cr(\">>> relativize_address: %p -> %ld (base: %p)\", p, offset, base);\n+  assert(start_address() <= p && p <= base, \"\");\n+  assert(0 <= offset && offset <= std::numeric_limits<int>::max(), \"\");\n+  return offset;\n@@ -276,4 +288,4 @@\n-template <class StackChunkFrameClosureType>\n-inline void stackChunkOopDesc::iterate_stack(StackChunkFrameClosureType* closure) {\n-  has_mixed_frames() ? InstanceStackChunkKlass::iterate_stack<chunk_frames::MIXED>(this, closure)\n-                     : InstanceStackChunkKlass::iterate_stack<chunk_frames::COMPILED_ONLY>(this, closure);\n+inline void stackChunkOopDesc::relativize_frame(frame& fr) const {\n+  fr.set_offset_sp(relativize_address(fr.sp()));\n+  fr.set_offset_unextended_sp(relativize_address(fr.unextended_sp()));\n+  relativize_frame_pd(fr);\n@@ -282,2 +294,4 @@\n-inline MemRegion stackChunkOopDesc::range() {\n-  return MemRegion((HeapWord*)this, size());\n+inline void stackChunkOopDesc::derelativize_frame(frame& fr) const {\n+  fr.set_sp(derelativize_address(fr.offset_sp()));\n+  fr.set_unextended_sp(derelativize_address(fr.offset_unextended_sp()));\n+  derelativize_frame_pd(fr);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":105,"deletions":91,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-#include \"oops\/stackChunkOop.hpp\"\n+#include \"oops\/stackChunkOop.inline.hpp\"\n@@ -64,0 +64,2 @@\n+#include \"runtime\/smallRegisterMap.inline.hpp\"\n+#include \"runtime\/stackChunkFrameStream.inline.hpp\"\n@@ -83,0 +85,2 @@\n+enum class copy_alignment { WORD_ALIGNED, DWORD_ALIGNED };\n+\n@@ -1071,1 +1075,1 @@\n-    chunk->copy_from_stack_to_chunk<aligned>(from, to, size);\n+    chunk->copy_from_stack_to_chunk(from, to, size);\n@@ -2416,1 +2420,1 @@\n-    _cont.tail()->template copy_from_chunk_to_stack<aligned>(from, to, size);\n+    _cont.tail()->copy_from_chunk_to_stack(from, to, size);\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"runtime\/stackValue.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/stackChunkOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-#include \"runtime\/stackValue.hpp\"\n+#include \"runtime\/stackValue.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame_helpers.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SMALLREGISTERMAP_HPP\n+#define SHARE_RUNTIME_SMALLREGISTERMAP_HPP\n+\n+#include \"utilities\/macros.hpp\"\n+\n+#include CPU_HEADER_INLINE(smallRegisterMap)\n+\n+#endif \/\/ SHARE_RUNTIME_SMALLREGISTERMAP_HPP\n","filename":"src\/hotspot\/share\/runtime\/smallRegisterMap.inline.hpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_STACKCHUNKFRAMESTREAM_HPP\n+#define SHARE_RUNTIME_STACKCHUNKFRAMESTREAM_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class CodeBlob;\n+class ImmutableOopMap;\n+class VMRegImpl;\n+typedef VMRegImpl* VMReg;\n+\n+enum chunk_frames { COMPILED_ONLY, MIXED };\n+\n+template <chunk_frames frame_kind>\n+class StackChunkFrameStream : public StackObj {\n+private:\n+  intptr_t* _end;\n+  intptr_t* _sp;\n+  intptr_t* _unextended_sp; \/\/ used only when mixed\n+  CodeBlob* _cb;\n+  mutable const ImmutableOopMap* _oopmap;\n+\n+#ifndef PRODUCT\n+  stackChunkOop _chunk;\n+  int _index;\n+#endif\n+\n+#ifdef ASSERT\n+  int _has_stub;\n+#endif\n+\n+public:\n+  StackChunkFrameStream() { NOT_PRODUCT(_chunk = nullptr; _index = -1;) DEBUG_ONLY(_has_stub = false;) }\n+  inline StackChunkFrameStream(stackChunkOop chunk, bool gc = false);\n+  inline StackChunkFrameStream(stackChunkOop chunk, const frame& f);\n+\n+  bool is_done() const { return _sp >= _end; }\n+  bool is_last() const { return next_sp() >= _end; }\n+\n+  intptr_t* end() { return _end; }\n+  void set_end(intptr_t* end) { _end = end; }\n+\n+  \/\/ Query\n+  intptr_t* end() const { return _end; }\n+\n+  intptr_t*        sp() const  { return _sp; }\n+  inline address   pc() const  { return get_pc(); }\n+  inline intptr_t* fp() const;\n+  inline intptr_t* unextended_sp() const { return frame_kind == chunk_frames::MIXED ? _unextended_sp : _sp; }\n+  NOT_PRODUCT(int index() { return _index; })\n+  inline address orig_pc() const;\n+\n+  inline bool is_interpreted() const;\n+  inline bool is_stub() const;\n+  inline bool is_compiled() const;\n+  CodeBlob* cb() const { return _cb; }\n+  const ImmutableOopMap* oopmap() const { if (_oopmap == NULL) get_oopmap(); return _oopmap; }\n+  inline int frame_size() const;\n+  inline int stack_argsize() const;\n+  inline int num_oops() const;\n+\n+  inline void initialize_register_map(RegisterMap* map);\n+  template <typename RegisterMapT> inline void next(RegisterMapT* map);\n+\n+  template <typename RegisterMapT> inline void update_reg_map(RegisterMapT* map);\n+\n+  void handle_deopted() const;\n+\n+  inline int to_offset(stackChunkOop chunk) const { assert(!is_done(), \"\"); return _sp - chunk->start_address(); }\n+\n+  inline frame to_frame() const;\n+\n+#ifdef ASSERT\n+  bool is_in_frame(void* p) const;\n+  bool is_deoptimized() const;\n+  template <typename RegisterMapT> bool is_in_oops(void* p, const RegisterMapT* map) const;\n+#endif\n+\n+  void print_on(outputStream* st) const PRODUCT_RETURN;\n+\n+ private:\n+  inline address get_pc() const;\n+  inline void get_cb();\n+\n+  inline intptr_t* next_sp() const;\n+  inline int interpreter_frame_size() const;\n+  inline int interpreter_frame_num_oops() const;\n+  inline int interpreter_frame_stack_argsize() const;\n+  inline void next_for_interpreter_frame();\n+  inline intptr_t* next_sp_for_interpreter_frame() const;\n+  inline intptr_t* unextended_sp_for_interpreter_frame() const;\n+  inline intptr_t* derelativize(int offset) const;\n+  inline void get_oopmap() const;\n+  inline void get_oopmap(address pc, int oopmap_slot) const;\n+\n+  template <typename RegisterMapT> inline void update_reg_map_pd(RegisterMapT* map);\n+\n+  template <typename RegisterMapT>\n+  inline void* reg_to_loc(VMReg reg, const RegisterMapT* map) const;\n+\n+public:\n+  template <class OopClosureType, class RegisterMapT>\n+  inline void iterate_oops(OopClosureType* closure, const RegisterMapT* map) const;\n+  template <class DerivedOopClosureType, class RegisterMapT>\n+  inline void iterate_derived_pointers(DerivedOopClosureType* closure, const RegisterMapT* map) const;\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_STACKCHUNKFRAMESTREAM_HPP\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.hpp","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,383 @@\n+\/* Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_STACKCHUNKFRAMESTREAM_INLINE_HPP\n+#define SHARE_OOPS_STACKCHUNKFRAMESTREAM_INLINE_HPP\n+\n+#include \"runtime\/stackChunkFrameStream.hpp\"\n+\n+#include \"compiler\/oopMap.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"oops\/stackChunkOop.inline.hpp\"\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include CPU_HEADER_INLINE(stackChunkFrameStream)\n+\n+#ifdef ASSERT\n+extern \"C\" bool dbg_is_safe(const void* p, intptr_t errvalue);\n+#endif\n+\n+template <chunk_frames frame_kind>\n+StackChunkFrameStream<frame_kind>::StackChunkFrameStream(stackChunkOop chunk, bool gc) DEBUG_ONLY(: _chunk(chunk)) {\n+  assert(chunk->is_stackChunk_noinline(), \"\");\n+  assert(frame_kind == chunk_frames::MIXED || !chunk->has_mixed_frames(), \"\");\n+\n+  DEBUG_ONLY(_index = 0;)\n+  _end = chunk->bottom_address();\n+  _sp = chunk->start_address() + chunk->sp();\n+  assert(_sp <= chunk->end_address() + InstanceStackChunkKlass::metadata_words(), \"\");\n+\n+  get_cb();\n+\n+  if (frame_kind == chunk_frames::MIXED) {\n+    _unextended_sp = (!is_done() && is_interpreted()) ? unextended_sp_for_interpreter_frame() : _sp;\n+    assert(_unextended_sp >= _sp - InstanceStackChunkKlass::metadata_words(), \"\");\n+  }\n+  DEBUG_ONLY(else _unextended_sp = nullptr;)\n+\n+  if (is_stub()) {\n+    get_oopmap(pc(), 0);\n+    DEBUG_ONLY(_has_stub = true);\n+  } DEBUG_ONLY(else _has_stub = false;)\n+}\n+\n+template <chunk_frames frame_kind>\n+StackChunkFrameStream<frame_kind>::StackChunkFrameStream(stackChunkOop chunk, const frame& f)\n+  DEBUG_ONLY(: _chunk(chunk)) {\n+  assert(chunk->is_stackChunk_noinline(), \"\");\n+  assert(frame_kind == chunk_frames::MIXED || !chunk->has_mixed_frames(), \"\");\n+  \/\/ assert (!is_empty(), \"\"); -- allowed to be empty\n+\n+  DEBUG_ONLY(_index = 0;)\n+\n+  _end = chunk->bottom_address();\n+\n+  assert(chunk->is_in_chunk(f.sp()), \"\");\n+  _sp = f.sp();\n+  if (frame_kind == chunk_frames::MIXED) {\n+    _unextended_sp = f.unextended_sp();\n+    assert(_unextended_sp >= _sp - InstanceStackChunkKlass::metadata_words(), \"\");\n+  }\n+  DEBUG_ONLY(else _unextended_sp = nullptr;)\n+  assert(_sp >= chunk->start_address() && _sp <= chunk->end_address() + InstanceStackChunkKlass::metadata_words(), \"\");\n+\n+  if (f.cb() != nullptr) {\n+    _oopmap = nullptr;\n+    _cb = f.cb();\n+  } else {\n+    get_cb();\n+  }\n+\n+  if (is_stub()) {\n+    get_oopmap(pc(), 0);\n+    DEBUG_ONLY(_has_stub = true);\n+  } DEBUG_ONLY(else _has_stub = false;)\n+}\n+\n+template <chunk_frames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_stub() const {\n+  return cb() != nullptr && (_cb->is_safepoint_stub() || _cb->is_runtime_stub());\n+}\n+\n+template <chunk_frames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_compiled() const {\n+  return cb() != nullptr && _cb->is_compiled();\n+}\n+\n+template <>\n+inline bool StackChunkFrameStream<chunk_frames::MIXED>::is_interpreted() const {\n+  return !is_done() && Interpreter::contains(pc());\n+}\n+\n+template <>\n+inline bool StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::is_interpreted() const {\n+  return false;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::frame_size() const {\n+  return is_interpreted() ? interpreter_frame_size()\n+                          : cb()->frame_size() + stack_argsize();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::stack_argsize() const {\n+  if (is_interpreted()) {\n+    return interpreter_frame_stack_argsize();\n+  }\n+  if (is_stub()) {\n+    return 0;\n+  }\n+  guarantee(cb() != nullptr, \"\");\n+  guarantee(cb()->is_compiled(), \"\");\n+  guarantee(cb()->as_compiled_method()->method() != nullptr, \"\");\n+  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+}\n+\n+template <chunk_frames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::num_oops() const {\n+  return is_interpreted() ? interpreter_frame_num_oops() : oopmap()->num_oops();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::initialize_register_map(RegisterMap* map) {\n+  update_reg_map_pd(map);\n+}\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::next(RegisterMapT* map) {\n+  update_reg_map(map);\n+  bool safepoint = is_stub();\n+  if (frame_kind == chunk_frames::MIXED) {\n+    if (is_interpreted()) {\n+      next_for_interpreter_frame();\n+    } else {\n+      _sp = _unextended_sp + cb()->frame_size();\n+      if (_sp >= _end - InstanceStackChunkKlass::metadata_words()) {\n+        _sp = _end;\n+      }\n+      _unextended_sp = is_interpreted() ? unextended_sp_for_interpreter_frame() : _sp;\n+    }\n+    assert(_unextended_sp >= _sp - InstanceStackChunkKlass::metadata_words(), \"\");\n+  } else {\n+    _sp += cb()->frame_size();\n+  }\n+  assert(!is_interpreted() || _unextended_sp == unextended_sp_for_interpreter_frame(), \"\");\n+\n+  get_cb();\n+  update_reg_map_pd(map);\n+  if (safepoint && cb() != nullptr) {\n+    \/\/ there's no post-call nop and no fast oopmap lookup\n+    _oopmap = cb()->oop_map_for_return_address(pc());\n+  }\n+  DEBUG_ONLY(_index++;)\n+}\n+\n+template <chunk_frames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::next_sp() const {\n+  return is_interpreted() ? next_sp_for_interpreter_frame() : unextended_sp() + cb()->frame_size();\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::get_cb() {\n+  _oopmap = nullptr;\n+  if (is_done() || is_interpreted()) {\n+    _cb = nullptr;\n+    return;\n+  }\n+\n+  assert(pc() != nullptr && dbg_is_safe(pc(), -1), \"\");\n+\n+  _cb = CodeCache::find_blob_fast(pc());\n+\n+  assert(_cb != nullptr, \"\");\n+  assert(is_interpreted() || ((is_stub() || is_compiled()) && _cb->frame_size() > 0), \"\");\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::get_oopmap() const {\n+  if (is_interpreted()) {\n+    return;\n+  }\n+  assert(is_compiled(), \"\");\n+  get_oopmap(pc(), CodeCache::find_oopmap_slot_fast(pc()));\n+}\n+\n+template <chunk_frames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::get_oopmap(address pc, int oopmap_slot) const {\n+  assert(cb() != nullptr, \"\");\n+  assert(!is_compiled() || !cb()->as_compiled_method()->is_deopt_pc(pc), \"\");\n+  if (oopmap_slot >= 0) {\n+    assert(oopmap_slot >= 0, \"\");\n+    assert(cb()->oop_map_for_slot(oopmap_slot, pc) != nullptr, \"\");\n+    assert(cb()->oop_map_for_slot(oopmap_slot, pc) == cb()->oop_map_for_return_address(pc), \"\");\n+\n+    _oopmap = cb()->oop_map_for_slot(oopmap_slot, pc);\n+  } else {\n+    _oopmap = cb()->oop_map_for_return_address(pc);\n+  }\n+  assert(_oopmap != nullptr, \"\");\n+}\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+inline void* StackChunkFrameStream<frame_kind>::reg_to_loc(VMReg reg, const RegisterMapT* map) const {\n+  assert(!is_done(), \"\");\n+  return reg->is_reg() ? (void*)map->location(reg, sp()) \/\/ see frame::update_map_with_saved_link(&map, link_addr);\n+                       : (void*)((address)unextended_sp() + (reg->reg2stack() * VMRegImpl::stack_slot_size));\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::MIXED>::update_reg_map(RegisterMap* map) {\n+  assert(!map->in_cont() || map->stack_chunk() == _chunk, \"\");\n+  if (map->update_map() && is_stub()) {\n+    frame f = to_frame();\n+    oopmap()->update_register_map(&f, map); \/\/ we have callee-save registers in this case\n+  }\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<chunk_frames::COMPILED_ONLY>::update_reg_map(RegisterMap* map) {\n+  assert(map->in_cont() && map->stack_chunk()() == _chunk, \"\");\n+  if (map->update_map()) {\n+    frame f = to_frame();\n+    oopmap()->update_register_map(&f, map); \/\/ we have callee-save registers in this case\n+  }\n+}\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::update_reg_map(RegisterMapT* map) {}\n+\n+template <chunk_frames frame_kind>\n+inline address StackChunkFrameStream<frame_kind>::orig_pc() const {\n+  address pc1 = pc();\n+  if (is_interpreted() || is_stub()) {\n+    return pc1;\n+  }\n+  CompiledMethod* cm = cb()->as_compiled_method();\n+  if (cm->is_deopt_pc(pc1)) {\n+    pc1 = *(address*)((address)unextended_sp() + cm->orig_pc_offset());\n+  }\n+\n+  assert(pc1 != nullptr && !cm->is_deopt_pc(pc1), \"\");\n+  assert(_cb == CodeCache::find_blob_fast(pc1), \"\");\n+\n+  return pc1;\n+}\n+\n+#ifdef ASSERT\n+template <chunk_frames frame_kind>\n+bool StackChunkFrameStream<frame_kind>::is_deoptimized() const {\n+  address pc1 = pc();\n+  return is_compiled() && CodeCache::find_oopmap_slot_fast(pc1) < 0 && cb()->as_compiled_method()->is_deopt_pc(pc1);\n+}\n+#endif\n+\n+template<chunk_frames frame_kind>\n+void StackChunkFrameStream<frame_kind>::handle_deopted() const {\n+  assert(!is_done(), \"\");\n+\n+  if (_oopmap != nullptr) {\n+    return;\n+  }\n+  if (is_interpreted()) {\n+    return;\n+  }\n+  assert(is_compiled(), \"\");\n+\n+  address pc1 = pc();\n+  int oopmap_slot = CodeCache::find_oopmap_slot_fast(pc1);\n+  if (UNLIKELY(oopmap_slot < 0)) { \/\/ we could have marked frames for deoptimization in thaw_chunk\n+    if (cb()->as_compiled_method()->is_deopt_pc(pc1)) {\n+      pc1 = orig_pc();\n+      oopmap_slot = CodeCache::find_oopmap_slot_fast(pc1);\n+    }\n+  }\n+  get_oopmap(pc1, oopmap_slot);\n+}\n+\n+template <chunk_frames frame_kind>\n+template <class OopClosureType, class RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::iterate_oops(OopClosureType* closure, const RegisterMapT* map) const {\n+  if (is_interpreted()) {\n+    frame f = to_frame();\n+    f.oops_interpreted_do(closure, nullptr, true);\n+  } else {\n+    DEBUG_ONLY(int oops = 0;)\n+    for (OopMapStream oms(oopmap()); !oms.is_done(); oms.next()) {\n+      OopMapValue omv = oms.current();\n+      if (omv.type() != OopMapValue::oop_value && omv.type() != OopMapValue::narrowoop_value) {\n+        continue;\n+      }\n+\n+      assert(UseCompressedOops || omv.type() == OopMapValue::oop_value, \"\");\n+      DEBUG_ONLY(oops++;)\n+\n+      void* p = reg_to_loc(omv.reg(), map);\n+      assert(p != nullptr, \"\");\n+      assert((_has_stub && _index == 1) || is_in_frame(p), \"\");\n+\n+      log_develop_trace(jvmcont)(\"StackChunkFrameStream::iterate_oops narrow: %d reg: %s p: \" INTPTR_FORMAT \" sp offset: \" INTPTR_FORMAT,\n+          omv.type() == OopMapValue::narrowoop_value, omv.reg()->name(), p2i(p), (intptr_t*)p - sp());\n+          omv.type() == OopMapValue::narrowoop_value ? Devirtualizer::do_oop(closure, (narrowOop*)p) : Devirtualizer::do_oop(closure, (oop*)p);\n+    }\n+    assert(oops == oopmap()->num_oops(), \"oops: %d oopmap->num_oops(): %d\", oops, oopmap()->num_oops());\n+  }\n+}\n+\n+template <chunk_frames frame_kind>\n+template <class DerivedOopClosureType, class RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::iterate_derived_pointers(DerivedOopClosureType* closure, const RegisterMapT* map) const {\n+  if (is_interpreted()) {\n+    return;\n+  }\n+\n+  for (OopMapStream oms(oopmap()); !oms.is_done(); oms.next()) {\n+    OopMapValue omv = oms.current();\n+    if (omv.type() != OopMapValue::derived_oop_value) {\n+      continue;\n+    }\n+\n+    \/\/ see OopMapDo<OopMapFnT, DerivedOopFnT, ValueFilterT>::walk_derived_pointers1\n+    intptr_t* derived_loc = (intptr_t*)reg_to_loc(omv.reg(), map);\n+    intptr_t* base_loc    = (intptr_t*)reg_to_loc(omv.content_reg(), map);\n+\n+    assert((_has_stub && _index == 1) || is_in_frame(base_loc), \"\");\n+    assert((_has_stub && _index == 1) || is_in_frame(derived_loc), \"\");\n+    assert(derived_loc != base_loc, \"Base and derived in same location\");\n+    assert(is_in_oops(base_loc, map), \"not found: \" INTPTR_FORMAT, p2i(base_loc));\n+    assert(!is_in_oops(derived_loc, map), \"found: \" INTPTR_FORMAT, p2i(derived_loc));\n+\n+    Devirtualizer::do_derived_oop(closure, (oop*)base_loc, (derived_pointer*)derived_loc);\n+  }\n+  OrderAccess::storestore(); \/\/ to preserve that we set the offset *before* fixing the base oop\n+}\n+\n+#ifdef ASSERT\n+\n+template <chunk_frames frame_kind>\n+template <typename RegisterMapT>\n+bool StackChunkFrameStream<frame_kind>::is_in_oops(void* p, const RegisterMapT* map) const {\n+  for (OopMapStream oms(oopmap()); !oms.is_done(); oms.next()) {\n+    if (oms.current().type() != OopMapValue::oop_value) {\n+      continue;\n+    }\n+    if (reg_to_loc(oms.current().reg(), map) == p) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+#endif\n+\n+#endif \/\/ SHARE_OOPS_STACKCHUNKFRAMESTREAM_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/stackChunkFrameStream.inline.hpp","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -41,0 +41,2 @@\n+class RegisterMap;\n+class SmallRegisterMap;\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"code\/debugInfo.hpp\"\n@@ -30,1 +29,0 @@\n-#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n@@ -35,0 +33,1 @@\n+class ScopeValue;\n@@ -114,3 +113,1 @@\n-  static StackValue* create_stack_value(const frame* fr, const RegisterMapT* reg_map, ScopeValue* sv) {\n-    return create_stack_value(sv, stack_value_address(fr, reg_map, sv), reg_map);\n-  }\n+  static StackValue* create_stack_value(const frame* fr, const RegisterMapT* reg_map, ScopeValue* sv);\n@@ -119,26 +116,1 @@\n-  static address stack_value_address(const frame* fr, const RegisterMapT* reg_map, ScopeValue* sv) {\n-    if (!sv->is_location())\n-      return NULL;\n-    Location loc = ((LocationValue *)sv)->location();\n-    if (loc.type() == Location::invalid)\n-      return NULL;\n-\n-    address value_addr;\n-    if (!reg_map->in_cont()) {\n-      value_addr = loc.is_register()\n-          \/\/ Value was in a callee-save register\n-          ? reg_map->location(VMRegImpl::as_VMReg(loc.register_number()), fr->sp())\n-          \/\/ Else value was directly saved on the stack. The frame's original stack pointer,\n-          \/\/ before any extension by its callee (due to Compiler1 linkage on SPARC), must be used.\n-          : ((address)fr->unextended_sp()) + loc.stack_offset();\n-\n-      assert(value_addr == NULL || reg_map->thread() == NULL || reg_map->thread()->is_in_usable_stack(value_addr), INTPTR_FORMAT, p2i(value_addr));\n-    } else {\n-      value_addr = loc.is_register()\n-          ? reg_map->as_RegisterMap()->stack_chunk()->reg_to_location(*fr, reg_map->as_RegisterMap(), VMRegImpl::as_VMReg(loc.register_number()))\n-          : reg_map->as_RegisterMap()->stack_chunk()->usp_offset_to_location(*fr, loc.stack_offset());\n-\n-      assert(value_addr == NULL || Continuation::is_in_usable_stack(value_addr, reg_map->as_RegisterMap()) || (reg_map->thread() != NULL && reg_map->thread()->is_in_usable_stack(value_addr)), INTPTR_FORMAT, p2i(value_addr));\n-    }\n-    return value_addr;\n-  }\n+  static address stack_value_address(const frame* fr, const RegisterMapT* reg_map, ScopeValue* sv);\n@@ -152,3 +124,3 @@\n-private:\n-  template<typename RegisterMapT>\n-  static StackValue* create_stack_value(ScopeValue* sv, address value_addr, const RegisterMapT* reg_map);\n+ private:\n+   template<typename RegisterMapT>\n+   static StackValue* create_stack_value(ScopeValue* sv, address value_addr, const RegisterMapT* reg_map);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.hpp","additions":6,"deletions":34,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_STACKVALUE_INLINE_HPP\n+#define SHARE_RUNTIME_STACKVALUE_INLINE_HPP\n+\n+#include \"runtime\/stackValue.hpp\"\n+\n+#include \"code\/debugInfo.hpp\"\n+#include \"code\/location.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+template<typename RegisterMapT>\n+StackValue* StackValue::create_stack_value(const frame* fr, const RegisterMapT* reg_map, ScopeValue* sv) {\n+  return create_stack_value(sv, stack_value_address(fr, reg_map, sv), reg_map);\n+}\n+\n+template<typename RegisterMapT>\n+address StackValue::stack_value_address(const frame* fr, const RegisterMapT* reg_map, ScopeValue* sv) {\n+  if (!sv->is_location()) {\n+    return NULL;\n+  }\n+  Location loc = ((LocationValue *)sv)->location();\n+  if (loc.type() == Location::invalid) {\n+    return NULL;\n+  }\n+\n+  if (!reg_map->in_cont()) {\n+    address value_addr = loc.is_register()\n+      \/\/ Value was in a callee-save register\n+      ? reg_map->location(VMRegImpl::as_VMReg(loc.register_number()), fr->sp())\n+      \/\/ Else value was directly saved on the stack. The frame's original stack pointer,\n+      \/\/ before any extension by its callee (due to Compiler1 linkage on SPARC), must be used.\n+      : ((address)fr->unextended_sp()) + loc.stack_offset();\n+\n+    assert(value_addr == NULL || reg_map->thread() == NULL || reg_map->thread()->is_in_usable_stack(value_addr), INTPTR_FORMAT, p2i(value_addr));\n+    return value_addr;\n+  }\n+\n+  address value_addr = loc.is_register()\n+    ? reg_map->as_RegisterMap()->stack_chunk()->reg_to_location(*fr, reg_map->as_RegisterMap(), VMRegImpl::as_VMReg(loc.register_number()))\n+    : reg_map->as_RegisterMap()->stack_chunk()->usp_offset_to_location(*fr, loc.stack_offset());\n+\n+  assert(value_addr == NULL || Continuation::is_in_usable_stack(value_addr, reg_map->as_RegisterMap()) || (reg_map->thread() != NULL && reg_map->thread()->is_in_usable_stack(value_addr)), INTPTR_FORMAT, p2i(value_addr));\n+  return value_addr;\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_STACKVALUE_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/stackValue.inline.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -85,1 +85,0 @@\n-  oop                continuation() const { return stack_chunk() != NULL ? stack_chunk()->cont() : (oop)NULL; }\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/stackChunkOop.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/stackValue.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"memory\/iterator.inline.hpp\"\n@@ -247,1 +246,1 @@\n-template <class BitMapClosureType>\n+template <typename BitMapClosureType>\n@@ -253,1 +252,1 @@\n-    } else if (!Devirtualizer::do_bit(cl, index)) {\n+    } else if (!cl->do_bit(index)) {\n@@ -259,1 +258,1 @@\n-template <class BitMapClosureType>\n+template <typename BitMapClosureType>\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}