{"files":[{"patch":"@@ -2068,2 +2068,1 @@\n-int java_lang_Thread::_noninheritableScopeLocalBindings_offset;\n-int java_lang_Thread::_inheritableScopeLocalBindings_offset;\n+int java_lang_Thread::_scopeLocalBindings_offset;\n@@ -2081,2 +2080,1 @@\n-  macro(_noninheritableScopeLocalBindings_offset, k, \"noninheritableScopeLocalBindings\", scopeLocalSnapshot_name, false); \\\n-  macro(_inheritableScopeLocalBindings_offset,    k, \"inheritableScopeLocalBindings\", scopeLocalSnapshot_name, false); \\\n+  macro(_scopeLocalBindings_offset, k, \"scopeLocalBindings\", scopeLocalSnapshot_name, false);\n@@ -2116,2 +2114,1 @@\n-  java_thread->obj_field_put(_noninheritableScopeLocalBindings_offset, NULL);\n-  java_thread->obj_field_put(_inheritableScopeLocalBindings_offset, NULL);\n+  java_thread->obj_field_put(_scopeLocalBindings_offset, NULL);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -424,2 +424,1 @@\n-  static int _noninheritableScopeLocalBindings_offset;\n-  static int _inheritableScopeLocalBindings_offset;\n+  static int _scopeLocalBindings_offset;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * Represents a scoped variable.\n+ * Represents a scoped value.\n@@ -42,1 +42,1 @@\n- * <p> A scope-local variable differs from a normal variable in that it is dynamically\n+ * <p> A scope-local value (hereinafter called a scope local) differs from a normal variable in that it is dynamically\n@@ -44,1 +44,1 @@\n- * to a transitive callee without using an explicit parameter. A scope-local variable\n+ * to a transitive callee without using an explicit parameter. A scope-local value\n@@ -48,1 +48,1 @@\n- * uses the {@link #get()} method to get the value of the variable. The variable reverts\n+ * uses the {@link #get()} method to get the value of the scope local. The scope local reverts\n@@ -51,1 +51,1 @@\n- * <p> Access to the value of a scoped variable is controlled by the accessibility\n+ * <p> Access to the value of a scope local is controlled by the accessibility\n@@ -56,1 +56,1 @@\n- * <p> ScopeLocal variables support nested bindings. If a scoped variable has a value\n+ * <p> Scope locals  support nested bindings. If a scope local has a value\n@@ -59,1 +59,1 @@\n- * value of the variable. The variable reverts to its previous value when the\n+ * value of the scope local. The scope local reverts to its previous value when the\n@@ -62,14 +62,0 @@\n- * <p> An <em>inheritable scoped variable<\/em> is created with the {@link\n- * #inheritableForType(Class)} method and provides inheritance of values from\n- * parent thread to child thread that is arranged when the child thread is\n- * created. Unlike {@link InheritableThreadLocal}, inheritable scoped variable\n- * are not copied into the child thread, instead the child thread will access\n- * the same variable as the parent thread. The value of inheritable scoped\n- * variables should be immutable to avoid needing synchronization to coordinate\n- * access.\n- *\n- * <p> As an advanced feature, the {@link #snapshot()} method is defined to obtain\n- * a {@link Snapshot} of the inheritable scoped variables that are currently bound.\n- * This can be used to support cases where inheritance needs to be done at times\n- * other than thread creation.\n- *\n@@ -80,1 +66,1 @@\n- * The following example uses a scoped variable to make credentials available to callees.\n+ * The following example uses a scope local to make credentials available to callees.\n@@ -98,1 +84,1 @@\n- * @param <T> the variable type\n+ * @param <T> the scope local's type\n@@ -103,1 +89,0 @@\n-    private final @Stable Class<? super T> type;\n@@ -106,5 +91,0 @@\n-    \/\/ Is this scope-local value inheritable? We could handle this by\n-    \/\/ making ScopeLocal an abstract base class and scopeLocalBindings() a\n-    \/\/ virtual method, but that seems a little excessive.\n-    private final @Stable boolean isInheritable;\n-\n@@ -120,1 +100,0 @@\n-     * @see ScopeLocal#snapshot()\n@@ -123,1 +102,1 @@\n-    public static class Snapshot {\n+    static class Snapshot {\n@@ -125,1 +104,1 @@\n-        final SingleBinding bindings;\n+        final Carrier bindings;\n@@ -130,1 +109,1 @@\n-        Snapshot(SingleBinding bindings, Snapshot prev, short primaryBits) {\n+        Snapshot(Carrier bindings, Snapshot prev, short primaryBits) {\n@@ -139,1 +118,1 @@\n-                    for (SingleBinding binding = b.bindings;\n+                    for (Carrier binding = b.bindings;\n@@ -151,47 +130,0 @@\n-\n-        \/**\n-         * Runs an operation with this snapshot of inheritable scoped variables.\n-         *\n-         * @param op the operation to run\n-         *\/\n-        public void run(Runnable op) {\n-            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-            if (prev == this) {\n-                op.run();\n-                return;\n-            }\n-            var cache = Thread.scopeLocalCache();\n-            Cache.invalidate();\n-            try {\n-                Thread.currentThread().inheritableScopeLocalBindings = this;\n-                op.run();\n-            } finally {\n-                Thread.currentThread().inheritableScopeLocalBindings = prev;\n-                Thread.setScopeLocalCache(cache);\n-            }\n-        }\n-\n-        \/**\n-         * Runs a value-returning operation with a snapshot of inheritable\n-         * scoped variables.\n-         *\n-         * @param op the operation to run\n-         * @param <R> the type of the result of the function\n-         * @return the result\n-         * @throws Exception if the operation completes with an exception\n-         *\/\n-        public <R> R call(Callable<R> op) throws Exception {\n-            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-            if (prev == this) {\n-                return op.call();\n-            }\n-            var cache = Thread.scopeLocalCache();\n-            Cache.invalidate();\n-            try {\n-                Thread.currentThread().inheritableScopeLocalBindings = this;\n-                return op.call();\n-            } finally {\n-                Thread.currentThread().inheritableScopeLocalBindings = prev;\n-                Thread.setScopeLocalCache(cache);\n-            }\n-        }\n@@ -200,1 +132,1 @@\n-    private static final class EmptySnapshot extends Snapshot {\n+     static final class EmptySnapshot extends Snapshot {\n@@ -205,1 +137,1 @@\n-        static final Snapshot SINGLETON = new EmptySnapshot();\n+        private static final Snapshot SINGLETON = new EmptySnapshot();\n@@ -210,49 +142,0 @@\n-\n-        \/**\n-         * Runs a value-returning operation with a snapshot of inheritable\n-         * scoped variables.\n-         *\n-         * @param op the operation to run\n-         * @param s the Snapshot. May be null.\n-         * @param <R> the type of the result of the function\n-         * @return the result\n-         * @throws Exception if the operation completes with an exception\n-         *\/\n-        public final <R> R call(Callable<R> op) throws Exception {\n-            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-            if (prev == null) {\n-                return op.call();\n-            }\n-            var cache = Thread.scopeLocalCache();\n-            Cache.invalidate();\n-            try {\n-                Thread.currentThread().inheritableScopeLocalBindings = null;\n-                return op.call();\n-            } finally {\n-                Thread.currentThread().inheritableScopeLocalBindings = prev;\n-                Thread.setScopeLocalCache(cache);\n-            }\n-        }\n-\n-        \/**\n-         * Runs an operation with this snapshot of inheritable scoped variables.\n-         *\n-         * @param op the operation to run\n-         * @param s the Snapshot. May be null.\n-         *\/\n-        public final void run(Runnable op) {\n-            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-            if (prev == null) {\n-                op.run();\n-                return;\n-            }\n-            var cache = Thread.scopeLocalCache();\n-            Cache.invalidate();\n-            try {\n-                Thread.currentThread().inheritableScopeLocalBindings = null;\n-                op.run();\n-            } finally {\n-                Thread.currentThread().inheritableScopeLocalBindings = prev;\n-                Thread.setScopeLocalCache(cache);\n-            }\n-        }\n@@ -271,1 +154,3 @@\n-        final SingleBinding inheritables, nonInheritables;\n+        final ScopeLocal<?> key;\n+        final Object value;\n+        final Carrier prev;\n@@ -273,3 +158,4 @@\n-       Carrier(SingleBinding inheritables, SingleBinding nonInheritables, short primaryBits, short secondaryBits) {\n-            this.inheritables = inheritables;\n-            this.nonInheritables = nonInheritables;\n+        Carrier(ScopeLocal<?> key, Object value, Carrier prev, short primaryBits, short secondaryBits) {\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n@@ -284,7 +170,2 @@\n-                                           SingleBinding inheritables, SingleBinding nonInheritables,\n-                                           short primaryBits, short secondaryBits) {\n-            if (key.isInheritable) {\n-                inheritables = new SingleBinding(key, value, inheritables);\n-            } else {\n-                nonInheritables = new SingleBinding(key, value, nonInheritables);\n-            }\n+                                               Carrier prev,\n+                                               short primaryBits, short secondaryBits) {\n@@ -293,1 +174,1 @@\n-            return new Carrier(inheritables, nonInheritables, primaryBits, secondaryBits);\n+            return new Carrier(key, value, prev, primaryBits, secondaryBits);\n@@ -305,1 +186,1 @@\n-            return where(key, value, inheritables, nonInheritables, primaryBits, secondaryBits);\n+            return where(key, value, this, primaryBits, secondaryBits);\n@@ -312,1 +193,9 @@\n-            return where(key, value, null, null, (short)0, (short)0);\n+            return where(key, value, null, (short)0, (short)0);\n+        }\n+\n+        final Object get() {\n+            return value;\n+        }\n+\n+        final ScopeLocal<?> getKey() {\n+            return key;\n@@ -320,0 +209,2 @@\n+         * @throws NoSuchElementException if key is not bound to any value\n+         *\n@@ -323,1 +214,1 @@\n-            for (SingleBinding b = key.isInheritable ? inheritables : nonInheritables;\n+            for (Carrier b = this;\n@@ -336,1 +227,1 @@\n-         * get the value of the variables. The variables revert to their previous values or\n+         * get the value of the scope local. The scope locals revert to their previous values or\n@@ -347,2 +238,1 @@\n-            var inheritables = addScopeLocalBindings(this.inheritables, primaryBits,true);\n-            var nonInheritables = addScopeLocalBindings(this.nonInheritables, primaryBits,false);\n+            var prevBindings = addScopeLocalBindings(this, primaryBits);\n@@ -353,2 +243,1 @@\n-                currentThread.noninheritableScopeLocalBindings = nonInheritables;\n-                currentThread.inheritableScopeLocalBindings = inheritables;\n+                currentThread.scopeLocalBindings = prevBindings;\n@@ -381,1 +270,1 @@\n-         * get the value of the variables. The variables revert to their previous values or\n+         * get the value of the scope local. The scope locals revert to their previous values or\n@@ -389,2 +278,1 @@\n-            var inheritables = addScopeLocalBindings(this.inheritables, primaryBits,true);\n-            var nonInheritables = addScopeLocalBindings(this.nonInheritables, primaryBits,false);\n+            var prevBindings = addScopeLocalBindings(this, primaryBits);\n@@ -395,2 +283,1 @@\n-                currentThread.noninheritableScopeLocalBindings = nonInheritables;\n-                currentThread.inheritableScopeLocalBindings = inheritables;\n+                currentThread.scopeLocalBindings = prevBindings;\n@@ -404,6 +291,4 @@\n-        private final static Snapshot addScopeLocalBindings(SingleBinding bindings, short primaryBits, boolean isInheritable) {\n-            Snapshot prev = getScopeLocalBindings(isInheritable);\n-            if (bindings != null) {\n-                var b = new Snapshot(bindings, prev, primaryBits);\n-                ScopeLocal.setScopeLocalBindings(b, isInheritable);\n-            }\n+        private final static Snapshot addScopeLocalBindings(Carrier bindings, short primaryBits) {\n+            Snapshot prev = getScopeLocalBindings();\n+            var b = new Snapshot(bindings, prev, primaryBits);\n+            ScopeLocal.setScopeLocalBindings(b);\n@@ -426,1 +311,0 @@\n-        \/\/ This could be made more efficient by not creating the Carrier instance.\n@@ -442,2 +326,0 @@\n-        \/\/ This could be made more efficient by not creating the Carrier instance,\n-        \/\/ but there isn't much in it.\n@@ -456,2 +338,0 @@\n-        \/\/ This could be made more efficient by not creating the Carrier instance,\n-        \/\/ but there isn't much in it.\n@@ -461,3 +341,1 @@\n-    private ScopeLocal(Class<? super T> type, boolean isInheritable) {\n-        this.type = Objects.requireNonNull(type);\n-        this.isInheritable = isInheritable;\n+    private ScopeLocal() {\n@@ -468,13 +346,1 @@\n-     * Creates a scoped variable to hold a value with the given type.\n-     *\n-     * @param <T> the type of the scoped variable's value.\n-     * @param <U> a supertype of {@code T}. It should either be {@code T} itself or, if T is a parameterized type, its generic type.\n-     * @param type The {@code Class} instance {@code T.class}\n-     * @return a scope variable\n-     *\/\n-    public static <U,T extends U> ScopeLocal<T> forType(Class<U> type) {\n-        return new ScopeLocal<T>(type, false);\n-    }\n-\n-    \/**\n-     * Creates an inheritable scoped variable to hold a value with the given type.\n+     * Creates a scope-local handle to refer to a value of type T.\n@@ -482,4 +348,2 @@\n-     * @param <T> the type of the scoped variable's value.\n-     * @param <U> a supertype of {@code T}. It should either be {@code T} itself or, if T is a parameterized type, its generic type.\n-     * @param type The {@code Class} instance {@code T.class}\n-     * @return a scope variable\n+     * @param <T> the type of the scope local's value.\n+     * @return a scope-local handle\n@@ -487,2 +351,2 @@\n-    public static <U,T extends U> ScopeLocal<T> inheritableForType(Class<U> type) {\n-        return new ScopeLocal<T>(type, true);\n+    public static <T> ScopeLocal<T> newInstance() {\n+        return new ScopeLocal<T>();\n@@ -492,3 +356,3 @@\n-     * Returns the value of the variable.\n-     * @return the value of the variable\n-     * @throws NoSuchElementException if the variable is not bound (exception is TBD)\n+     * Returns the value of the scope local.\n+     * @return the value of the scope local\n+     * @throws NoSuchElementException if the scope local is not bound (exception is TBD)\n@@ -519,2 +383,0 @@\n-        if (bindings == null)\n-            throw new NoSuchElementException();\n@@ -530,1 +392,1 @@\n-     * Returns {@code true} if the variable is bound to a value.\n+     * Returns {@code true} if the scope local is bound to a value.\n@@ -532,1 +394,1 @@\n-     * @return {@code true} if the variable is bound to a value, otherwise {@code false}\n+     * @return {@code true} if the scope local is bound to a value, otherwise {@code false}\n@@ -536,5 +398,1 @@\n-        var bindings = scopeLocalBindings();\n-        if (bindings == null) {\n-            return false;\n-        }\n-        return (bindings.find(this) != Snapshot.NIL);\n+        return (scopeLocalBindings().find(this) != Snapshot.NIL);\n@@ -544,1 +402,1 @@\n-     * Return the value of the variable or NIL if not bound.\n+     * Return the value of the scope local or NIL if not bound.\n@@ -547,6 +405,1 @@\n-        var bindings = scopeLocalBindings();\n-        if (bindings != null) {\n-            return bindings.find(this);\n-        } else {\n-            return Snapshot.NIL;\n-        }\n+        return scopeLocalBindings().find(this);\n@@ -556,1 +409,1 @@\n-     * Return the value of the variable if bound, otherwise returns {@code other}.\n+     * Return the value of the scope local if bound, otherwise returns {@code other}.\n@@ -558,1 +411,1 @@\n-     * @return the value of the variable if bound, otherwise {@code other}\n+     * @return the value of the scope local if bound, otherwise {@code other}\n@@ -572,1 +425,1 @@\n-     * Return the value of the variable if bound, otherwise throws an exception\n+     * Return the value of the scope local if bound, otherwise throws an exception\n@@ -577,2 +430,2 @@\n-     * @return the value of the variable if bound\n-     * @throws X if the variable is unbound\n+     * @return the value of the scope local if bound\n+     * @throws X if the scope local is unbound\n@@ -592,1 +445,1 @@\n-    private static Snapshot getScopeLocalBindings(boolean isInheritable) {\n+    private static Snapshot getScopeLocalBindings() {\n@@ -594,3 +447,1 @@\n-        return isInheritable\n-                ? currentThread.inheritableScopeLocalBindings\n-                : currentThread.noninheritableScopeLocalBindings;\n+        return currentThread.scopeLocalBindings;\n@@ -599,1 +450,1 @@\n-    private static void setScopeLocalBindings(Snapshot bindings, boolean isInheritable) {\n+    private static void setScopeLocalBindings(Snapshot bindings) {\n@@ -601,5 +452,1 @@\n-        if (isInheritable) {\n-            currentThread.inheritableScopeLocalBindings = bindings;\n-        } else {\n-            currentThread.noninheritableScopeLocalBindings = bindings;\n-        }\n+        currentThread.scopeLocalBindings = bindings;\n@@ -609,1 +456,1 @@\n-        return getScopeLocalBindings(isInheritable);\n+        return getScopeLocalBindings();\n@@ -629,45 +476,1 @@\n-    \/**\n-     * Returns a \"snapshot\" of the inheritable scoped variables that are currently\n-     * bound.\n-     *\n-     * <p>This snapshot may be capured at any time. It is inteneded to be used\n-     * in circumstances where values may be shared by sub-tasks.\n-     *\n-     * @return a \"snapshot\" of the currently-bound inheritable scoped variables.\n-     *\/\n-    public static Snapshot snapshot() {\n-        Thread thread = Thread.currentThread();\n-        var bindings = thread.inheritableScopeLocalBindings;\n-        if (bindings == null) {\n-            \/\/ A one-time per thread event. Maybe we should more\n-            \/\/ simply pre-initialize the bindings to an instance of\n-            \/\/ EmptySnapshot at thread creation time.\n-            return (thread.inheritableScopeLocalBindings = EmptySnapshot.getInstance());\n-        } else {\n-            return bindings;\n-        }\n-    }\n-\n-    \/\/ An immutable object that represents the binding of a single value\n-    \/\/ to a single key.\n-    static final class SingleBinding {\n-        final ScopeLocal<?> key;\n-        final Object value;\n-        final SingleBinding prev;\n-\n-        SingleBinding(ScopeLocal<?> key, Object value, SingleBinding prev) {\n-            this.value = key.type.cast(value);\n-            this.key = key;\n-            this.prev = prev;\n-        }\n-\n-        final Object get() {\n-            return value;\n-        }\n-\n-        final ScopeLocal<?> getKey() {\n-            return key;\n-        }\n-    }\n-\n-    \/\/ A small fixed-size key-value cache. When a scope variable's get() method\n+    \/\/ A small fixed-size key-value cache. When a scope scope local's get() method\n@@ -701,3 +504,3 @@\n-            int tmp = chooseVictim(thread);\n-            int victim = tmp == 0 ? k1 : k2;\n-            int other = tmp == 0 ? k2 : k1;\n+            var usePrimaryIndex = chooseVictim(thread);\n+            int victim = usePrimaryIndex ? k1 : k2;\n+            int other = usePrimaryIndex ? k2 : k1;\n@@ -751,3 +554,5 @@\n-        \/\/ Return either 0 or 1, at pseudo-random. This chooses either the\n-        \/\/ primary or secondary cache slot.\n-        private static int chooseVictim(Thread thread) {\n+        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n+        \/\/ This chooses either the primary or secondary cache slot, but the\n+        \/\/ primary slot is approximately twice as likely to be chosen as the\n+        \/\/ secondary one.\n+        private static boolean chooseVictim(Thread thread) {\n@@ -755,2 +560,5 @@\n-            thread.victims = (tmp << 31) | (tmp >>> 1);\n-            return tmp & 1;\n+            tmp ^= tmp << 13;\n+            tmp ^= tmp >>> 17;\n+            tmp ^= tmp << 5;\n+            thread.victims = tmp;\n+            return (tmp & 15) >= 5;\n@@ -768,2 +576,1 @@\n-                for (short bits = (short)toClearBits;\n-                     bits != 0; ) {\n+                for (short bits = (short)toClearBits; bits != 0; ) {\n@@ -771,1 +578,1 @@\n-                    setKey(objects, index, null);\n+                    setKeyAndObjectAt(index, null, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopeLocal.java","additions":88,"deletions":281,"binary":false,"changes":369,"status":"modified"},{"patch":"@@ -251,2 +251,1 @@\n-    ScopeLocal.Snapshot noninheritableScopeLocalBindings;\n-    ScopeLocal.Snapshot inheritableScopeLocalBindings;\n+    ScopeLocal.Snapshot scopeLocalBindings = ScopeLocal.EmptySnapshot.getInstance();\n@@ -678,5 +677,0 @@\n-\n-            \/\/ scoped variables\n-            if ((characteristics & NO_INHERIT_SCOPE_LOCALS) == 0) {\n-                this.inheritableScopeLocalBindings = parent.inheritableScopeLocalBindings;\n-            }\n@@ -735,5 +729,0 @@\n-        \/\/ scoped variables\n-        if ((characteristics & NO_INHERIT_SCOPE_LOCALS) == 0) {\n-            this.inheritableScopeLocalBindings = parent.inheritableScopeLocalBindings;\n-        }\n-\n@@ -942,9 +931,0 @@\n-        \/**\n-         * Sets whether the thread inherits {@linkplain ScopeLocal#inheritableForType(Class)\n-         * inheritable-scope-local} variables. The default is to inherit.\n-         *\n-         * @param inherit {@code true} to inherit, {@code false} to not inherit\n-         * @return this builder\n-         *\/\n-        Builder inheritInheritableScopeLocals(boolean inherit);\n-\n@@ -1532,1 +1512,1 @@\n-                    this.noninheritableScopeLocalBindings = parent.noninheritableScopeLocalBindings;\n+                    this.scopeLocalBindings = parent.scopeLocalBindings;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -117,11 +117,0 @@\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public T inheritInheritableScopeLocals(boolean inherit) {\n-            if (inherit) {\n-                characteristics &= ~Thread.NO_INHERIT_SCOPE_LOCALS;\n-            } else {\n-                characteristics |= Thread.NO_INHERIT_SCOPE_LOCALS;\n-            }\n-            return (T) this;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ThreadBuilders.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-                this.noninheritableScopeLocalBindings = parent.noninheritableScopeLocalBindings;\n+                this.scopeLocalBindings = parent.scopeLocalBindings;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -471,2 +471,0 @@\n-        private ScopeLocal.Snapshot snapshot = ScopeLocal.snapshot();\n-\n@@ -485,5 +483,1 @@\n-            if (snapshot != ScopeLocal.snapshot()) {\n-                snapshot.run(() -> tryFire(ASYNC));\n-            } else {\n-                tryFire(ASYNC);\n-            }\n+            tryFire(ASYNC);\n@@ -1806,2 +1800,0 @@\n-        private ScopeLocal.Snapshot snapshot = ScopeLocal.snapshot();\n-\n@@ -1829,5 +1821,1 @@\n-            if (snapshot != ScopeLocal.snapshot()) {\n-                snapshot.run(this::doRun);\n-            } else {\n-                doRun();\n-            }\n+            doRun();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -434,2 +434,0 @@\n-    private ScopeLocal.Snapshot snapshot = ScopeLocal.snapshot();\n-\n@@ -756,5 +754,1 @@\n-        if (snapshot != ScopeLocal.snapshot()) {\n-            snapshot.run(this::compute);\n-        } else {\n-            compute();\n-        }\n+        compute();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CountedCompleter.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-        U.putReference(thread, INHERITABLESCOPELOCALBINDINGS, null);\n+        \/\/ U.putReference(thread, INHERITABLESCOPELOCALBINDINGS, null);\n@@ -392,2 +392,0 @@\n-    private static final long INHERITABLESCOPELOCALBINDINGS\n-            = U.objectFieldOffset(Thread.class, \"inheritableScopeLocalBindings\");\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,8 +45,1 @@\n-        ScopeLocal<String> v = ScopeLocal.forType(String.class);\n-        assertFalse(v.isBound());\n-        v.get();\n-    }\n-\n-    @Test(expectedExceptions = { NoSuchElementException.class })\n-    public void testUnbound2() {\n-        ScopeLocal<String> v = ScopeLocal.inheritableForType(String.class);\n+        ScopeLocal<String> v = ScopeLocal.newInstance();\n@@ -58,1 +51,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -69,1 +62,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -83,1 +76,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -87,1 +80,0 @@\n-            ensureNotInherited(name);\n@@ -92,1 +84,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -100,1 +92,0 @@\n-                ensureNotInherited(name);\n@@ -105,1 +96,0 @@\n-            ensureNotInherited(name);\n@@ -113,1 +103,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -117,1 +107,0 @@\n-            ensureNotInherited(name);\n@@ -122,1 +111,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -130,1 +119,0 @@\n-                ensureNotInherited(name);\n@@ -135,1 +123,0 @@\n-            ensureNotInherited(name);\n@@ -142,56 +129,0 @@\n-    public void testRunWithBinding5() {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-            ensureInherited(name);\n-        });\n-    }\n-\n-    public void testRunWithBinding6() {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            ScopeLocal.where(name, \"joe\", () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(\"joe\".equals(name.get()));\n-                ensureInherited(name);\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-            ensureInherited(name);\n-        });\n-    }\n-\n-    \/**\n-     * Test runWithBinding with inheritable scope variable, null value.\n-     *\/\n-    public void testRunWithBinding7() {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        ScopeLocal.where(name, null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-            ensureInherited(name);\n-        });\n-    }\n-\n-    public void testRunWithBinding8() {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            ScopeLocal.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-                ensureInherited(name);\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-            ensureInherited(name);\n-        });\n-    }\n@@ -204,1 +135,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -212,1 +143,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -217,1 +148,0 @@\n-            ensureNotInherited(name);\n@@ -224,1 +154,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -229,1 +159,0 @@\n-            ensureNotInherited(name);\n@@ -248,1 +177,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -252,1 +181,0 @@\n-            ensureNotInherited(name);\n@@ -259,1 +187,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -264,71 +192,0 @@\n-            ensureNotInherited(name);\n-\n-            int result2 = ScopeLocal.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    \/**\n-     * Test callWithBinding with inheritable scope variable.\n-     *\/\n-    public void testCallWithBinding5() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        int result = ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value = name.get();\n-            assertTrue(\"fred\".equals(value));\n-            ensureInherited(name);\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    public void testCallWithBinding6() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        int result1 = ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-            ensureInherited(name);\n-\n-            int result2 = ScopeLocal.where(name, \"joe\", () -> {\n-                assertTrue(name.isBound());\n-                String value2 = name.get();\n-                assertTrue(\"joe\".equals(value2));\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    \/**\n-     * Test callWithBinding with inheritable scope variable, null value.\n-     *\/\n-    public void testCallWithBinding7() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        int result = ScopeLocal.where(name, null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-            ensureInherited(name);\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    public void testCallWithBinding8() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        int result1 = ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-            ensureInherited(name);\n@@ -353,1 +210,1 @@\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> name = ScopeLocal.newInstance();\n@@ -356,122 +213,0 @@\n-\n-    \/**\n-     * Test that inheritable scope variable are inherited at Thread create time.\n-     *\/\n-    public void testInheritAtCreateTime() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        ScopeLocal.where(name, \"fred\", () -> {\n-            AtomicReference<String> ref = new AtomicReference<>();\n-            Thread thread = new Thread(() -> ref.set(name.get()));\n-            \/\/ start thread with name set to joe\n-            ScopeLocal.where(name, \"joe\", thread::start);\n-            thread.join();\n-            assertEquals(ref.get(), \"fred\");\n-            return null;\n-        });\n-    }\n-\n-    \/**\n-     * Test snapshot inheritance.\n-     *\/\n-    public void testSnapshotInheritance() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n-        ScopeLocal<String> occupation = ScopeLocal.inheritableForType(String.class);\n-        var snapshot = ScopeLocal.where(name, \"aristotle\", () -> ScopeLocal.snapshot());\n-        assertFalse(name.isBound());\n-        assertBoundInSnapshot(snapshot, name, true);\n-        ScopeLocal.where(occupation, \"undertaker\", () -> {\n-            assertBoundInSnapshot(snapshot, occupation, false);\n-            assertEquals(occupation.get(), \"undertaker\");\n-            assertTrue(occupation.isBound());\n-            return null;\n-        });\n-        assertEqualsInSnapshot(snapshot, name, \"aristotle\");\n-    }\n-\n-    \/**\n-     * Test for snapshot non-inheritance.\n-     *\/\n-    public void testSnapshotNonInheritance() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n-        ScopeLocal<String> occupation = ScopeLocal.forType(String.class);\n-        var snapshot = ScopeLocal.where(name, \"aristotle\", () -> ScopeLocal.snapshot());\n-        assertFalse(name.isBound());\n-        assertBoundInSnapshot(snapshot, name, false);\n-        ScopeLocal.where(occupation, \"undertaker\", () -> {\n-            assertBoundInSnapshot(snapshot, occupation, true);\n-            assertEquals(occupation.get(), \"undertaker\");\n-            assertEqualsInSnapshot(snapshot, occupation, \"undertaker\");\n-            assertTrue(occupation.isBound());\n-            return null;\n-        });\n-        ScopeLocal.where(name, \"joe\", () -> {\n-            assertEqualsInSnapshot(snapshot, name, \"joe\");\n-            return null;\n-        });\n-    }\n-\n-    private <R> R callWithSnapshot(ScopeLocal.Snapshot snapshot, Callable<R> c) {\n-        try {\n-            return snapshot.call(c);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    private <T> void assertEqualsInSnapshot(ScopeLocal.Snapshot snapshot, ScopeLocal<T> var, T expected)\n-            throws Exception {\n-        callWithSnapshot(snapshot, () -> {\n-            assertEquals(var.get(), expected);\n-            return null;\n-        });\n-    }\n-\n-    private <T> void assertBoundInSnapshot(ScopeLocal.Snapshot snapshot, ScopeLocal<T> var, boolean expected)\n-            throws Exception {\n-        callWithSnapshot(snapshot, () -> {\n-            assertEquals(var.isBound(), expected);\n-            return null;\n-        });\n-    }\n-\n-    \/**\n-     * Ensures that a inheritable scope variable is inherited\n-     *\/\n-    private void ensureInherited(ScopeLocal<?> v) {\n-        Object valueInParent = v.get();\n-\n-        \/\/ check inherited by platform thread\n-        var platformThreadFactory = Thread.ofPlatform().factory();\n-        try (var executor = Executors.newThreadPerTaskExecutor(platformThreadFactory)) {\n-            Object valueInChild = executor.submit(v::get).join();\n-            assertEquals(valueInChild, valueInParent);\n-        }\n-\n-        \/\/ check inherited by virtual thread\n-        var virtualThreadFactory = Thread.ofVirtual().factory();\n-        try (var executor = Executors.newThreadPerTaskExecutor(virtualThreadFactory)) {\n-            Object valueInChild = executor.submit(v::get).join();\n-            assertEquals(valueInChild, valueInParent);\n-        }\n-    }\n-\n-    \/**\n-     * Ensures that a non-inheritable scope variable is not inherited\n-     *\/\n-    private void ensureNotInherited(ScopeLocal<?> v) {\n-        assertTrue(v.isBound());\n-\n-        \/\/ check not inherited by platform thread\n-        var platformThreadFactory = Thread.ofPlatform().factory();\n-        try (var executor = Executors.newThreadPerTaskExecutor(platformThreadFactory)) {\n-            boolean boundInChild = executor.submit(v::isBound).join();\n-            assertFalse(boundInChild);\n-        }\n-\n-        \/\/ check no inherited by virtual thread\n-        var virtualThreadFactory = Thread.ofVirtual().factory();\n-        try (var executor = Executors.newThreadPerTaskExecutor(virtualThreadFactory)) {\n-            boolean boundInChild = executor.submit(v::isBound).join();\n-            assertFalse(boundInChild);\n-        }\n-    }\n","filename":"test\/jdk\/java\/lang\/ScopeLocal\/Basic.java","additions":13,"deletions":278,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.java.lang.ScopeLocalsExecutorService\", \"-Djmh.executor=CUSTOM\", \"--enable-preview\"})\n+      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.java.lang.ScopeLocalsExecutorService\", \"-Djmh.executor=CUSTOM\", \"-Djmh.blackhole.mode=COMPILER\", \"--enable-preview\"})\n@@ -99,0 +99,9 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int CreateBindThenGetThenRemove_ScopeLocal() throws Exception {\n+        return ScopeLocal.where(sl1, 42).call(sl1::get);\n+    }\n+\n+\n+    \/\/ Create a Carrier ahead of time: might be slightly faster\n+    private static final ScopeLocal.Carrier HOLD_42 = ScopeLocal.where(sl1, 42);\n@@ -102,1 +111,1 @@\n-        return ScopeLocal.where(sl1, 42, sl1::get);\n+        return HOLD_42.call(sl1::get);\n@@ -125,1 +134,1 @@\n-    \/\/ Test 4: The cost of binding, but not using the any result\n+    \/\/ Test 4: The cost of binding, but not using any result\n@@ -179,26 +188,0 @@\n-\n-    \/\/ Test 6: Measure the cost of Snapshotting\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public ScopeLocal.Snapshot getSnapshot_ScopeLocal() {\n-        return ScopeLocal.snapshot();\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void runWithSnapshot_ScopeLocal() {\n-        aSnapshot.run(() -> { });\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public Object callWithSnapshot_ScopeLocal() throws Exception{\n-        return aSnapshot.call(() -> getClass());\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public Object callandGetWithSnapshot_ScopeLocal() throws Exception{\n-        return aSnapshot.call(sl1::get);\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopeLocals.java","additions":12,"deletions":29,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-    static final ScopeLocal<Integer> sl1 = ScopeLocal.forType(Integer.class);\n+    static final ScopeLocal<Integer> sl1 = ScopeLocal.newInstance();\n@@ -35,6 +35,6 @@\n-    static final ScopeLocal<Integer> sl2 = ScopeLocal.forType(Integer.class);\n-    static final ScopeLocal<Integer> sl3 = ScopeLocal.forType(Integer.class);\n-    static final ScopeLocal<Integer> sl4 = ScopeLocal.forType(Integer.class);\n-    static final ScopeLocal<Integer> sl5 = ScopeLocal.forType(Integer.class);\n-    static final ScopeLocal<Integer> sl6 = ScopeLocal.forType(Integer.class);\n-    static final ScopeLocal<AtomicInteger> sl_atomicInt = ScopeLocal.forType(AtomicInteger.class);\n+    static final ScopeLocal<Integer> sl2 = ScopeLocal.newInstance();\n+    static final ScopeLocal<Integer> sl3 = ScopeLocal.newInstance();\n+    static final ScopeLocal<Integer> sl4 = ScopeLocal.newInstance();\n+    static final ScopeLocal<Integer> sl5 = ScopeLocal.newInstance();\n+    static final ScopeLocal<Integer> sl6 = ScopeLocal.newInstance();\n+    static final ScopeLocal<AtomicInteger> sl_atomicInt = ScopeLocal.newInstance();\n@@ -42,1 +42,1 @@\n-    static final ScopeLocal<AtomicReference<Integer>> sl_atomicRef = ScopeLocal.forType(AtomicReference.class);\n+    static final ScopeLocal<AtomicReference<Integer>> sl_atomicRef = ScopeLocal.newInstance();\n@@ -51,11 +51,0 @@\n-    static final ScopeLocal.Snapshot aSnapshot;\n-\n-    static {\n-        try {\n-            aSnapshot = ScopeLocal.where(sl1, 99,\n-                    () -> ScopeLocal.snapshot());\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopeLocalsData.java","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"}]}