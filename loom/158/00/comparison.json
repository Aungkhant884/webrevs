{"files":[{"patch":"@@ -5065,1 +5065,1 @@\n-int jdk_internal_vm_StackChunk::_maxSize_offset;\n+int jdk_internal_vm_StackChunk::_maxThawingSize_offset;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1129,4 +1129,4 @@\n-  macro(jdk_internal_vm_StackChunk, cont,    continuation_signature, false)  \\\n-  macro(jdk_internal_vm_StackChunk, flags,   byte_signature, false)          \\\n-  macro(jdk_internal_vm_StackChunk, pc,      intptr_signature, false)        \\\n-  macro(jdk_internal_vm_StackChunk, maxSize, int_signature, false)           \\\n+  macro(jdk_internal_vm_StackChunk, cont,           continuation_signature, false)  \\\n+  macro(jdk_internal_vm_StackChunk, flags,          byte_signature, false)          \\\n+  macro(jdk_internal_vm_StackChunk, pc,             intptr_signature, false)        \\\n+  macro(jdk_internal_vm_StackChunk, maxThawingSize, int_signature, false)           \\\n@@ -1143,1 +1143,1 @@\n-  static int _maxSize_offset;\n+  static int _maxThawingSize_offset;\n@@ -1178,2 +1178,2 @@\n-  static inline int maxSize(oop chunk);\n-  static inline void set_maxSize(oop chunk, int value);\n+  static inline int maxThawingSize(oop chunk);\n+  static inline void set_maxThawingSize(oop chunk, int value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -365,2 +365,2 @@\n-inline int jdk_internal_vm_StackChunk::maxSize(oop chunk) {\n-  return chunk->int_field(_maxSize_offset);\n+inline int jdk_internal_vm_StackChunk::maxThawingSize(oop chunk) {\n+  return chunk->int_field(_maxThawingSize_offset);\n@@ -369,1 +369,1 @@\n-inline void jdk_internal_vm_StackChunk::set_maxSize(oop chunk, int value) {\n+inline void jdk_internal_vm_StackChunk::set_maxThawingSize(oop chunk, int value) {\n@@ -371,1 +371,1 @@\n-  jint old = maxSize(chunk);\n+  jint old = maxThawingSize(chunk);\n@@ -374,1 +374,1 @@\n-  chunk->int_field_put(_maxSize_offset, value);\n+  chunk->int_field_put(_maxThawingSize_offset, value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+  template(maxThawingSize_name,                       \"maxThawingSize\")                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -235,1 +235,1 @@\n-               c->stack_size(), c->argsize(), c->max_size(), c->sp(), p2i(c->pc()));\n+               c->stack_size(), c->argsize(), c->max_thawing_size(), c->sp(), p2i(c->pc()));\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -575,1 +575,1 @@\n-    assert(max_size() == 0, \"\");\n+    assert(max_thawing_size() == 0, \"\");\n@@ -617,1 +617,1 @@\n-    assert(max_size() == calculated_max_size,\n+    assert(max_thawing_size() == calculated_max_size,\n@@ -619,1 +619,1 @@\n-           max_size(), calculated_max_size, closure._argsize, closure._num_i2c);\n+           max_thawing_size(), calculated_max_size, closure._argsize, closure._num_i2c);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-  inline int max_size() const;\n-  inline void set_max_size(int value);\n+  inline int max_thawing_size() const;\n+  inline void set_max_thawing_size(int value);\n@@ -135,0 +135,3 @@\n+  inline void clear_chunk();\n+  inline int remove_top_compiled_frame(int &argsize);\n+\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-inline int stackChunkOopDesc::max_size() const          { return jdk_internal_vm_StackChunk::maxSize(as_oop()); }\n-inline void stackChunkOopDesc::set_max_size(int value)  {\n+inline int stackChunkOopDesc::max_thawing_size() const          { return jdk_internal_vm_StackChunk::maxThawingSize(as_oop()); }\n+inline void stackChunkOopDesc::set_max_thawing_size(int value)  {\n@@ -82,1 +82,1 @@\n-  jdk_internal_vm_StackChunk::set_maxSize(this, (jint)value);\n+  jdk_internal_vm_StackChunk::set_maxThawingSize(this, (jint)value);\n@@ -170,0 +170,33 @@\n+inline void stackChunkOopDesc::clear_chunk() {\n+  set_sp(stack_size());\n+  set_argsize(0);\n+  set_max_thawing_size(0);\n+}\n+\n+inline int stackChunkOopDesc::remove_top_compiled_frame(int &argsize) {\n+  bool empty = false;\n+  StackChunkFrameStream<ChunkFrames::CompiledOnly> f(this);\n+  intptr_t* const chunk_sp = start_address() + sp();\n+  assert(chunk_sp == f.sp(), \"\");\n+  assert(chunk_sp == f.unextended_sp(), \"\");\n+\n+  const int frame_size = f.cb()->frame_size();\n+  argsize = f.stack_argsize();\n+\n+  f.next(SmallRegisterMap::instance, true \/* stop *\/);\n+  empty = f.is_done();\n+  assert(!empty || argsize == this->argsize(), \"\");\n+\n+  if (empty) {\n+    clear_chunk();\n+  } else {\n+    set_sp(sp() + frame_size);\n+    set_max_thawing_size(max_thawing_size() - frame_size);\n+    \/\/ We set chunk->pc to the return pc into the next frame\n+    set_pc(f.pc());\n+    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n+  }\n+  assert(empty == is_empty(), \"\");\n+  return frame_size + argsize;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-      chunk->set_max_size(chunk->max_size() + cont_size - _cont.argsize());\n+      chunk->set_max_thawing_size(chunk->max_thawing_size() + cont_size - _cont.argsize());\n@@ -587,1 +587,1 @@\n-      chunk->set_max_size(cont_size);\n+      chunk->set_max_thawing_size(cont_size);\n@@ -601,1 +601,1 @@\n-    chunk->set_max_size(cont_size);\n+    chunk->set_max_thawing_size(cont_size);\n@@ -839,1 +839,1 @@\n-  assert(chunk == nullptr || (chunk->max_size() == 0) == chunk->is_empty(), \"\");\n+  assert(chunk == nullptr || (chunk->max_thawing_size() == 0) == chunk->is_empty(), \"\");\n@@ -907,1 +907,1 @@\n-      assert(chunk->max_size() == 0, \"\");\n+      assert(chunk->max_thawing_size() == 0, \"\");\n@@ -924,1 +924,1 @@\n-  chunk->set_max_size(chunk->max_size() + _size - frame::metadata_words);\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() + _size - frame::metadata_words);\n@@ -1150,1 +1150,1 @@\n-  chunk->set_max_size(chunk->max_size() + _align_size);\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() + _align_size);\n@@ -1229,1 +1229,1 @@\n-  assert(chunk->max_size() == 0, \"\");\n+  assert(chunk->max_thawing_size() == 0, \"\");\n@@ -1481,1 +1481,1 @@\n-  int size = chunk->max_size();\n+  int size = chunk->max_thawing_size();\n@@ -1514,1 +1514,1 @@\n-  assert(chunk->max_size() > 0, \"chunk invariant violated; expected to not be empty\");\n+  assert(chunk->max_thawing_size() > 0, \"chunk invariant violated; expected to not be empty\");\n@@ -1629,0 +1629,42 @@\n+class ReconstructedStack {\n+  intptr_t* _base;  \/\/ _cont.entrySP(); \/\/ top of the entry frame\n+  int _thaw_size;\n+  int _argsize;\n+public:\n+  ReconstructedStack(intptr_t* base, int thaw_size, int argsize) : _base(base), _thaw_size(thaw_size), _argsize(argsize) {\n+    \/\/ \/\/ possibly adds a one-word padding between entrySP and the bottom-most frame's stack args\n+    \/\/ \/\/ The only possible source of misalignment is stack-passed arguments because all compiled\n+    \/\/ \/\/ frames are 16-byte aligned.\n+    assert(argsize != 0 || (_base - _thaw_size) == ContinuationHelper::frame_align_pointer(_base - _thaw_size), \"\");\n+  }\n+  int thaw_size() const { return _thaw_size; }\n+  int argsize() const { return _argsize; }\n+\n+  \/\/ top and bottom stack pointers\n+  intptr_t* sp() const { return ContinuationHelper::frame_align_pointer(_base - _thaw_size); }\n+  intptr_t* bottom_sp() const { return ContinuationHelper::frame_align_pointer(_base - _argsize); }\n+\n+  \/\/ several operations operate ont the totality of the stack being reconstructed,\n+  \/\/ including the metadata words\n+  intptr_t* top() const { return sp() - frame::metadata_words;  }\n+  int total_size() const { return _thaw_size + frame::metadata_words; }\n+\n+  void patch_return(bool is_last, address entry_pc) {\n+    log_develop_trace(continuations)(\"thaw_fast patching -- sp: \" INTPTR_FORMAT, p2i(sp()));\n+    address pc = !is_last ? StubRoutines::cont_returnBarrier() : entry_pc;\n+    *(address*)(bottom_sp() - frame::sender_sp_ret_address_offset()) = pc;\n+    \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n+\n+    DEBUG_ONLY(address pc2 = *(address*)(bottom_sp() - frame::sender_sp_ret_address_offset());)\n+    assert(is_last ? CodeCache::find_blob(pc2)->as_compiled_method()->method()->is_continuation_enter_intrinsic()\n+                  : pc2 == StubRoutines::cont_returnBarrier(), \"is_last: %d\", is_last);\n+  }\n+  void verify() {\n+    \/\/ We assert we have not overwritten the entry frame, but that we're at most\n+    \/\/ one alignment word away from it.\n+    assert(top() + total_size() <= _base, \"overwritten entry frame\");\n+    assert(_base - 1 <= top() + total_size(), \"missed entry frame\");\n+    assert(argsize() != 0 || top() + total_size() == _base, \"missed entry frame\");\n+  }\n+};\n+\n@@ -1647,2 +1689,1 @@\n-  int chunk_start_sp = chunk->sp();\n-  const int full_chunk_size = chunk->stack_size() - chunk_start_sp; \/\/ this initial size could be reduced if it's a partial thaw\n+  const int full_chunk_size = chunk->stack_size() - chunk->sp(); \/\/ this initial size could be reduced if it's a partial thaw\n@@ -1651,1 +1692,1 @@\n-  intptr_t* const chunk_sp = chunk->start_address() + chunk_start_sp;\n+  intptr_t* const chunk_sp = chunk->start_address() + chunk->sp();\n@@ -1658,8 +1699,2 @@\n-\n-    argsize = chunk->argsize();\n-    empty = true;\n-\n-    chunk->set_sp(chunk->stack_size());\n-    chunk->set_argsize(0);\n-    chunk->set_max_size(0);\n-\n+    argsize = chunk->argsize(); \/\/ must be called *before* clearing the chunk\n+    chunk->clear_chunk();\n@@ -1667,0 +1702,1 @@\n+    empty = true;\n@@ -1669,25 +1705,2 @@\n-\n-    StackChunkFrameStream<ChunkFrames::CompiledOnly> f(chunk);\n-    assert(chunk_sp == f.sp(), \"\");\n-    assert(chunk_sp == f.unextended_sp(), \"\");\n-\n-    const int frame_size = f.cb()->frame_size();\n-    argsize = f.stack_argsize();\n-\n-    f.next(SmallRegisterMap::instance, true \/* stop *\/);\n-    empty = f.is_done();\n-    assert(!empty || argsize == chunk->argsize(), \"\");\n-\n-    if (empty) {\n-      chunk->set_sp(chunk->stack_size());\n-      chunk->set_argsize(0);\n-      chunk->set_max_size(0);\n-    } else {\n-      chunk->set_sp(chunk->sp() + frame_size);\n-      chunk->set_max_size(chunk->max_size() - frame_size);\n-      \/\/ We set chunk->pc to the return pc into the next frame\n-      chunk->set_pc(f.pc());\n-      assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n-    }\n-    assert(empty == chunk->is_empty(), \"\");\n-    thaw_size = frame_size + argsize;\n+    thaw_size = chunk->remove_top_compiled_frame(argsize);\n+    empty = chunk->is_empty();\n@@ -1698,0 +1711,1 @@\n+  assert(!is_last || argsize == 0, \"\");\n@@ -1702,2 +1716,1 @@\n-  intptr_t* stack_sp = _cont.entrySP();\n-  intptr_t* bottom_sp = ContinuationHelper::frame_align_pointer(stack_sp - argsize);\n+  ReconstructedStack rs(_cont.entrySP(), thaw_size, argsize);\n@@ -1705,6 +1718,2 @@\n-  stack_sp -= thaw_size;\n-  \/\/ possibly adds a one-word padding between entrySP and the bottom-most frame's stack args\n-  \/\/ The only possible source of misalignment is stack-passed arguments because all compiled\n-  \/\/ frames are 16-byte aligned.\n-  assert(argsize != 0 || stack_sp == ContinuationHelper::frame_align_pointer(stack_sp), \"\");\n-  stack_sp = ContinuationHelper::frame_align_pointer(stack_sp);\n+  \/\/ Verify that all sizes and addresses are correct before copying\n+  rs.verify();\n@@ -1713,8 +1722,1 @@\n-  intptr_t* from = chunk_sp - frame::metadata_words;\n-  intptr_t* to   = stack_sp - frame::metadata_words;\n-  copy_from_chunk(from, to, thaw_size + frame::metadata_words);\n-  \/\/ We assert we have not overwritten the entry frame, but that we're at most\n-  \/\/ one alignment word away from it.\n-  assert(to + thaw_size + frame::metadata_words <= _cont.entrySP(), \"overwritten entry frame\");\n-  assert(_cont.entrySP() - 1 <= to + thaw_size + frame::metadata_words, \"missed entry frame\");\n-  assert(argsize != 0 || to + thaw_size + frame::metadata_words == _cont.entrySP(), \"missed entry frame\");\n+  copy_from_chunk(chunk_sp - frame::metadata_words, rs.top(), rs.total_size());\n@@ -1722,2 +1724,2 @@\n-  assert(!is_last || argsize == 0, \"\");\n-  _cont.set_argsize(argsize); \/\/ sets argsize in ContinuationEntry\n+  \/\/ update the ContinuationEntry\n+  _cont.set_argsize(argsize);\n@@ -1725,1 +1727,1 @@\n-  assert(bottom_sp == _cont.entry()->bottom_sender_sp(), \"\");\n+  assert(rs.bottom_sp() == _cont.entry()->bottom_sender_sp(), \"\");\n@@ -1728,4 +1730,2 @@\n-  patch_return(bottom_sp, is_last);\n-  DEBUG_ONLY(address pc = *(address*)(bottom_sp - frame::sender_sp_ret_address_offset());)\n-  assert(is_last ? CodeCache::find_blob(pc)->as_compiled_method()->method()->is_continuation_enter_intrinsic()\n-                  : pc == StubRoutines::cont_returnBarrier(), \"is_last: %d\", is_last);\n+  rs.patch_return(is_last, _cont.entryPC());\n+\n@@ -1746,1 +1746,1 @@\n-  set_anchor(_thread, stack_sp);\n+  set_anchor(_thread, rs.sp());\n@@ -1754,1 +1754,1 @@\n-  return stack_sp;\n+  return rs.sp();\n@@ -1887,1 +1887,1 @@\n-  chunk->set_max_size(chunk->max_size() - delta);\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() - delta);\n@@ -2125,1 +2125,1 @@\n-    chunk->set_max_size(0);\n+    chunk->set_max_thawing_size(0);\n@@ -2128,1 +2128,1 @@\n-    chunk->set_max_size(chunk->max_size() - _align_size);\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() - _align_size);\n@@ -2130,1 +2130,1 @@\n-  assert(chunk->is_empty() == (chunk->max_size() == 0), \"\");\n+  assert(chunk->is_empty() == (chunk->max_thawing_size() == 0), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":75,"deletions":75,"binary":false,"changes":150,"status":"modified"}]}