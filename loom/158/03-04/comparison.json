{"files":[{"patch":"@@ -1645,0 +1645,51 @@\n+inline void ThawBase::clear_chunk(stackChunkOop chunk) {\n+  chunk->set_sp(chunk->stack_size());\n+  chunk->set_argsize(0);\n+  chunk->set_max_thawing_size(0);\n+}\n+\n+ int ThawBase::remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize) {\n+  bool empty = false;\n+  StackChunkFrameStream<ChunkFrames::CompiledOnly> f(chunk);\n+  DEBUG_ONLY(intptr_t* const chunk_sp = chunk->start_address() + chunk->sp();)\n+  assert(chunk_sp == f.sp(), \"\");\n+  assert(chunk_sp == f.unextended_sp(), \"\");\n+\n+  const int frame_size = f.cb()->frame_size();\n+  argsize = f.stack_argsize();\n+\n+  f.next(SmallRegisterMap::instance, true \/* stop *\/);\n+  empty = f.is_done();\n+  assert(!empty || argsize == chunk->argsize(), \"\");\n+\n+  if (empty) {\n+    clear_chunk(chunk);\n+  } else {\n+    chunk->set_sp(chunk->sp() + frame_size);\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() - frame_size);\n+    \/\/ We set chunk->pc to the return pc into the next frame\n+    chunk->set_pc(f.pc());\n+    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n+  }\n+  assert(empty == chunk->is_empty(), \"\");\n+  \/\/ returns the size required to store the frame on stack, and because it is a\n+  \/\/ compiled frame, it must include a copy of the arguments passed by the caller\n+  return frame_size + argsize;\n+}\n+\n+void ThawBase::copy_from_chunk(intptr_t* from, intptr_t* to, int size) {\n+  assert(to + size <= _cont.entrySP(), \"\");\n+  _cont.tail()->copy_from_chunk_to_stack(from, to, size);\n+  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n+  assert(to >= _top_stack_address, \"overwrote past thawing space\"\n+    \" to: \" INTPTR_FORMAT \" top_address: \" INTPTR_FORMAT, p2i(to), p2i(_top_stack_address));\n+}\n+\n+void ThawBase::patch_return(intptr_t* sp, bool is_last) {\n+  log_develop_trace(continuations)(\"thaw_fast patching -- sp: \" INTPTR_FORMAT, p2i(sp));\n+\n+  address pc = !is_last ? StubRoutines::cont_returnBarrier() : _cont.entryPC();\n+  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n+  \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n+}\n+\n@@ -1731,51 +1782,0 @@\n-inline void ThawBase::clear_chunk(stackChunkOop chunk) {\n-  chunk->set_sp(chunk->stack_size());\n-  chunk->set_argsize(0);\n-  chunk->set_max_thawing_size(0);\n-}\n-\n- int ThawBase::remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize) {\n-  bool empty = false;\n-  StackChunkFrameStream<ChunkFrames::CompiledOnly> f(chunk);\n-  DEBUG_ONLY(intptr_t* const chunk_sp = chunk->start_address() + chunk->sp();)\n-  assert(chunk_sp == f.sp(), \"\");\n-  assert(chunk_sp == f.unextended_sp(), \"\");\n-\n-  const int frame_size = f.cb()->frame_size();\n-  argsize = f.stack_argsize();\n-\n-  f.next(SmallRegisterMap::instance, true \/* stop *\/);\n-  empty = f.is_done();\n-  assert(!empty || argsize == chunk->argsize(), \"\");\n-\n-  if (empty) {\n-    clear_chunk(chunk);\n-  } else {\n-    chunk->set_sp(chunk->sp() + frame_size);\n-    chunk->set_max_thawing_size(chunk->max_thawing_size() - frame_size);\n-    \/\/ We set chunk->pc to the return pc into the next frame\n-    chunk->set_pc(f.pc());\n-    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n-  }\n-  assert(empty == chunk->is_empty(), \"\");\n-  \/\/ returns the size required to store the frame on stack, and because it is a\n-  \/\/ compiled frame, it must include a copy of the arguments passed by the caller\n-  return frame_size + argsize;\n-}\n-\n-void ThawBase::copy_from_chunk(intptr_t* from, intptr_t* to, int size) {\n-  assert(to + size <= _cont.entrySP(), \"\");\n-  _cont.tail()->copy_from_chunk_to_stack(from, to, size);\n-  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n-  assert(to >= _top_stack_address, \"overwrote past thawing space\"\n-    \" to: \" INTPTR_FORMAT \" top_address: \" INTPTR_FORMAT, p2i(to), p2i(_top_stack_address));\n-}\n-\n-void ThawBase::patch_return(intptr_t* sp, bool is_last) {\n-  log_develop_trace(continuations)(\"thaw_fast patching -- sp: \" INTPTR_FORMAT, p2i(sp));\n-\n-  address pc = !is_last ? StubRoutines::cont_returnBarrier() : _cont.entryPC();\n-  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n-  \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":51,"deletions":51,"binary":false,"changes":102,"status":"modified"}]}