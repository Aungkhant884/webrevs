{"files":[{"patch":"@@ -135,3 +135,0 @@\n-  inline void clear_chunk();\n-  inline int remove_top_compiled_frame(int &argsize);\n-\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -170,35 +170,0 @@\n-inline void stackChunkOopDesc::clear_chunk() {\n-  set_sp(stack_size());\n-  set_argsize(0);\n-  set_max_thawing_size(0);\n-}\n-\n-inline int stackChunkOopDesc::remove_top_compiled_frame(int &argsize) {\n-  bool empty = false;\n-  StackChunkFrameStream<ChunkFrames::CompiledOnly> f(this);\n-  DEBUG_ONLY(intptr_t* const chunk_sp = start_address() + sp();)\n-  assert(chunk_sp == f.sp(), \"\");\n-  assert(chunk_sp == f.unextended_sp(), \"\");\n-\n-  const int frame_size = f.cb()->frame_size();\n-  argsize = f.stack_argsize();\n-\n-  f.next(SmallRegisterMap::instance, true \/* stop *\/);\n-  empty = f.is_done();\n-  assert(!empty || argsize == this->argsize(), \"\");\n-\n-  if (empty) {\n-    clear_chunk();\n-  } else {\n-    set_sp(sp() + frame_size);\n-    set_max_thawing_size(max_thawing_size() - frame_size);\n-    \/\/ We set chunk->pc to the return pc into the next frame\n-    set_pc(f.pc());\n-    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n-  }\n-  assert(empty == is_empty(), \"\");\n-  \/\/ returns the size required to store the frame on stack, and because it is a\n-  \/\/ compiled frame, it must include a copy of the arguments passed by the caller\n-  return frame_size + argsize;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1556,0 +1556,2 @@\n+  void clear_chunk(stackChunkOop chunk);\n+  int remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize);\n@@ -1700,1 +1702,1 @@\n-    chunk->clear_chunk();\n+    clear_chunk(chunk);\n@@ -1705,1 +1707,1 @@\n-    thaw_size = chunk->remove_top_compiled_frame(argsize);\n+    thaw_size = remove_top_compiled_frame_from_chunk(chunk, argsize);\n@@ -1757,0 +1759,35 @@\n+inline void ThawBase::clear_chunk(stackChunkOop chunk) {\n+  chunk->set_sp(chunk->stack_size());\n+  chunk->set_argsize(0);\n+  chunk->set_max_thawing_size(0);\n+}\n+\n+ int ThawBase::remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize) {\n+  bool empty = false;\n+  StackChunkFrameStream<ChunkFrames::CompiledOnly> f(chunk);\n+  DEBUG_ONLY(intptr_t* const chunk_sp = chunk->start_address() + chunk->sp();)\n+  assert(chunk_sp == f.sp(), \"\");\n+  assert(chunk_sp == f.unextended_sp(), \"\");\n+\n+  const int frame_size = f.cb()->frame_size();\n+  argsize = f.stack_argsize();\n+\n+  f.next(SmallRegisterMap::instance, true \/* stop *\/);\n+  empty = f.is_done();\n+  assert(!empty || argsize == chunk->argsize(), \"\");\n+\n+  if (empty) {\n+    clear_chunk(chunk);\n+  } else {\n+    chunk->set_sp(chunk->sp() + frame_size);\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() - frame_size);\n+    \/\/ We set chunk->pc to the return pc into the next frame\n+    chunk->set_pc(f.pc());\n+    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n+  }\n+  assert(empty == chunk->is_empty(), \"\");\n+  \/\/ returns the size required to store the frame on stack, and because it is a\n+  \/\/ compiled frame, it must include a copy of the arguments passed by the caller\n+  return frame_size + argsize;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"}]}