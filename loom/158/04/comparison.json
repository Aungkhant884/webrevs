{"files":[{"patch":"@@ -5065,1 +5065,1 @@\n-int jdk_internal_vm_StackChunk::_maxSize_offset;\n+int jdk_internal_vm_StackChunk::_maxThawingSize_offset;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1129,4 +1129,4 @@\n-  macro(jdk_internal_vm_StackChunk, cont,    continuation_signature, false)  \\\n-  macro(jdk_internal_vm_StackChunk, flags,   byte_signature, false)          \\\n-  macro(jdk_internal_vm_StackChunk, pc,      intptr_signature, false)        \\\n-  macro(jdk_internal_vm_StackChunk, maxSize, int_signature, false)           \\\n+  macro(jdk_internal_vm_StackChunk, cont,           continuation_signature, false)  \\\n+  macro(jdk_internal_vm_StackChunk, flags,          byte_signature, false)          \\\n+  macro(jdk_internal_vm_StackChunk, pc,             intptr_signature, false)        \\\n+  macro(jdk_internal_vm_StackChunk, maxThawingSize, int_signature, false)           \\\n@@ -1143,1 +1143,1 @@\n-  static int _maxSize_offset;\n+  static int _maxThawingSize_offset;\n@@ -1178,2 +1178,2 @@\n-  static inline int maxSize(oop chunk);\n-  static inline void set_maxSize(oop chunk, int value);\n+  static inline int maxThawingSize(oop chunk);\n+  static inline void set_maxThawingSize(oop chunk, int value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -365,2 +365,2 @@\n-inline int jdk_internal_vm_StackChunk::maxSize(oop chunk) {\n-  return chunk->int_field(_maxSize_offset);\n+inline int jdk_internal_vm_StackChunk::maxThawingSize(oop chunk) {\n+  return chunk->int_field(_maxThawingSize_offset);\n@@ -369,1 +369,1 @@\n-inline void jdk_internal_vm_StackChunk::set_maxSize(oop chunk, int value) {\n+inline void jdk_internal_vm_StackChunk::set_maxThawingSize(oop chunk, int value) {\n@@ -371,1 +371,1 @@\n-  jint old = maxSize(chunk);\n+  jint old = maxThawingSize(chunk);\n@@ -374,1 +374,1 @@\n-  chunk->int_field_put(_maxSize_offset, value);\n+  chunk->int_field_put(_maxThawingSize_offset, value);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -528,0 +528,1 @@\n+  template(maxThawingSize_name,                       \"maxThawingSize\")                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-               c->stack_size(), c->argsize(), c->max_size(), c->sp(), p2i(c->pc()));\n+               c->stack_size(), c->argsize(), c->max_thawing_size(), c->sp(), p2i(c->pc()));\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -573,1 +573,1 @@\n-    assert(max_size() == 0, \"\");\n+    assert(max_thawing_size() == 0, \"\");\n@@ -615,1 +615,1 @@\n-    assert(max_size() == calculated_max_size,\n+    assert(max_thawing_size() == calculated_max_size,\n@@ -617,1 +617,1 @@\n-           max_size(), calculated_max_size, closure._argsize, closure._num_i2c);\n+           max_thawing_size(), calculated_max_size, closure._argsize, closure._num_i2c);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-  inline int max_size() const;\n-  inline void set_max_size(int value);\n+  inline int max_thawing_size() const;\n+  inline void set_max_thawing_size(int value);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-inline int stackChunkOopDesc::max_size() const          { return jdk_internal_vm_StackChunk::maxSize(as_oop()); }\n-inline void stackChunkOopDesc::set_max_size(int value)  {\n+inline int stackChunkOopDesc::max_thawing_size() const          { return jdk_internal_vm_StackChunk::maxThawingSize(as_oop()); }\n+inline void stackChunkOopDesc::set_max_thawing_size(int value)  {\n@@ -82,1 +82,1 @@\n-  jdk_internal_vm_StackChunk::set_maxSize(this, (jint)value);\n+  jdk_internal_vm_StackChunk::set_maxThawingSize(this, (jint)value);\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-      chunk->set_max_size(chunk->max_size() + cont_size - _cont.argsize());\n+      chunk->set_max_thawing_size(chunk->max_thawing_size() + cont_size - _cont.argsize());\n@@ -587,1 +587,1 @@\n-      chunk->set_max_size(cont_size);\n+      chunk->set_max_thawing_size(cont_size);\n@@ -601,1 +601,1 @@\n-    chunk->set_max_size(cont_size);\n+    chunk->set_max_thawing_size(cont_size);\n@@ -832,1 +832,1 @@\n-  assert(chunk == nullptr || (chunk->max_size() == 0) == chunk->is_empty(), \"\");\n+  assert(chunk == nullptr || (chunk->max_thawing_size() == 0) == chunk->is_empty(), \"\");\n@@ -900,1 +900,1 @@\n-      assert(chunk->max_size() == 0, \"\");\n+      assert(chunk->max_thawing_size() == 0, \"\");\n@@ -917,1 +917,1 @@\n-  chunk->set_max_size(chunk->max_size() + _size - frame::metadata_words);\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() + _size - frame::metadata_words);\n@@ -1140,1 +1140,1 @@\n-  chunk->set_max_size(chunk->max_size() + _align_size);\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() + _align_size);\n@@ -1219,1 +1219,1 @@\n-  assert(chunk->max_size() == 0, \"\");\n+  assert(chunk->max_thawing_size() == 0, \"\");\n@@ -1453,1 +1453,1 @@\n-  int size = chunk->max_size();\n+  int size = chunk->max_thawing_size();\n@@ -1486,1 +1486,1 @@\n-  assert(chunk->max_size() > 0, \"chunk invariant violated; expected to not be empty\");\n+  assert(chunk->max_thawing_size() > 0, \"chunk invariant violated; expected to not be empty\");\n@@ -1528,0 +1528,2 @@\n+  void clear_chunk(stackChunkOop chunk);\n+  int remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize);\n@@ -1601,0 +1603,93 @@\n+class ReconstructedStack : public StackObj {\n+  intptr_t* _base;  \/\/ _cont.entrySP(); \/\/ top of the entry frame\n+  int _thaw_size;\n+  int _argsize;\n+public:\n+  ReconstructedStack(intptr_t* base, int thaw_size, int argsize) : _base(base), _thaw_size(thaw_size), _argsize(argsize) {\n+    \/\/ \/\/ possibly adds a one-word padding between entrySP and the bottom-most frame's stack args\n+    \/\/ \/\/ The only possible source of misalignment is stack-passed arguments because all compiled\n+    \/\/ \/\/ frames are 16-byte aligned.\n+    assert(argsize != 0 || (_base - _thaw_size) == ContinuationHelper::frame_align_pointer(_base - _thaw_size), \"\");\n+  }\n+  int thaw_size() const { return _thaw_size; }\n+  int argsize() const { return _argsize; }\n+\n+  \/\/ top and bottom stack pointers\n+  intptr_t* sp() const { return ContinuationHelper::frame_align_pointer(_base - _thaw_size); }\n+  intptr_t* bottom_sp() const { return ContinuationHelper::frame_align_pointer(_base - _argsize); }\n+\n+  \/\/ several operations operate on the totality of the stack being reconstructed,\n+  \/\/ including the metadata words\n+  intptr_t* top() const { return sp() - frame::metadata_words;  }\n+  int total_size() const { return _thaw_size + frame::metadata_words; }\n+\n+  void patch_return(bool is_last, address entry_pc) {\n+    log_develop_trace(continuations)(\"thaw_fast patching -- sp: \" INTPTR_FORMAT, p2i(sp()));\n+    address pc = !is_last ? StubRoutines::cont_returnBarrier() : entry_pc;\n+    *(address*)(bottom_sp() - frame::sender_sp_ret_address_offset()) = pc;\n+    \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n+\n+    DEBUG_ONLY(address pc2 = *(address*)(bottom_sp() - frame::sender_sp_ret_address_offset());)\n+    assert(is_last ? CodeCache::find_blob(pc2)->as_compiled_method()->method()->is_continuation_enter_intrinsic()\n+                  : pc2 == StubRoutines::cont_returnBarrier(), \"is_last: %d\", is_last);\n+  }\n+  void verify() {\n+    \/\/ We assert we have not overwritten the entry frame, but that we're at most\n+    \/\/ one alignment word away from it.\n+    assert(top() + total_size() <= _base, \"overwritten entry frame\");\n+    assert(_base - 1 <= top() + total_size(), \"missed entry frame\");\n+    assert(argsize() != 0 || top() + total_size() == _base, \"missed entry frame\");\n+  }\n+};\n+\n+inline void ThawBase::clear_chunk(stackChunkOop chunk) {\n+  chunk->set_sp(chunk->stack_size());\n+  chunk->set_argsize(0);\n+  chunk->set_max_thawing_size(0);\n+}\n+\n+ int ThawBase::remove_top_compiled_frame_from_chunk(stackChunkOop chunk, int &argsize) {\n+  bool empty = false;\n+  StackChunkFrameStream<ChunkFrames::CompiledOnly> f(chunk);\n+  DEBUG_ONLY(intptr_t* const chunk_sp = chunk->start_address() + chunk->sp();)\n+  assert(chunk_sp == f.sp(), \"\");\n+  assert(chunk_sp == f.unextended_sp(), \"\");\n+\n+  const int frame_size = f.cb()->frame_size();\n+  argsize = f.stack_argsize();\n+\n+  f.next(SmallRegisterMap::instance, true \/* stop *\/);\n+  empty = f.is_done();\n+  assert(!empty || argsize == chunk->argsize(), \"\");\n+\n+  if (empty) {\n+    clear_chunk(chunk);\n+  } else {\n+    chunk->set_sp(chunk->sp() + frame_size);\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() - frame_size);\n+    \/\/ We set chunk->pc to the return pc into the next frame\n+    chunk->set_pc(f.pc());\n+    assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n+  }\n+  assert(empty == chunk->is_empty(), \"\");\n+  \/\/ returns the size required to store the frame on stack, and because it is a\n+  \/\/ compiled frame, it must include a copy of the arguments passed by the caller\n+  return frame_size + argsize;\n+}\n+\n+void ThawBase::copy_from_chunk(intptr_t* from, intptr_t* to, int size) {\n+  assert(to + size <= _cont.entrySP(), \"\");\n+  _cont.tail()->copy_from_chunk_to_stack(from, to, size);\n+  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n+  assert(to >= _top_stack_address, \"overwrote past thawing space\"\n+    \" to: \" INTPTR_FORMAT \" top_address: \" INTPTR_FORMAT, p2i(to), p2i(_top_stack_address));\n+}\n+\n+void ThawBase::patch_return(intptr_t* sp, bool is_last) {\n+  log_develop_trace(continuations)(\"thaw_fast patching -- sp: \" INTPTR_FORMAT, p2i(sp));\n+\n+  address pc = !is_last ? StubRoutines::cont_returnBarrier() : _cont.entryPC();\n+  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n+  \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n+}\n+\n@@ -1619,2 +1714,1 @@\n-  int chunk_start_sp = chunk->sp();\n-  const int full_chunk_size = chunk->stack_size() - chunk_start_sp; \/\/ this initial size could be reduced if it's a partial thaw\n+  const int full_chunk_size = chunk->stack_size() - chunk->sp(); \/\/ this initial size could be reduced if it's a partial thaw\n@@ -1623,1 +1717,1 @@\n-  intptr_t* const chunk_sp = chunk->start_address() + chunk_start_sp;\n+  intptr_t* const chunk_sp = chunk->start_address() + chunk->sp();\n@@ -1630,8 +1724,2 @@\n-\n-    argsize = chunk->argsize();\n-    empty = true;\n-\n-    chunk->set_sp(chunk->stack_size());\n-    chunk->set_argsize(0);\n-    chunk->set_max_size(0);\n-\n+    argsize = chunk->argsize(); \/\/ must be called *before* clearing the chunk\n+    clear_chunk(chunk);\n@@ -1639,0 +1727,1 @@\n+    empty = true;\n@@ -1641,25 +1730,2 @@\n-\n-    StackChunkFrameStream<ChunkFrames::CompiledOnly> f(chunk);\n-    assert(chunk_sp == f.sp(), \"\");\n-    assert(chunk_sp == f.unextended_sp(), \"\");\n-\n-    const int frame_size = f.cb()->frame_size();\n-    argsize = f.stack_argsize();\n-\n-    f.next(SmallRegisterMap::instance, true \/* stop *\/);\n-    empty = f.is_done();\n-    assert(!empty || argsize == chunk->argsize(), \"\");\n-\n-    if (empty) {\n-      chunk->set_sp(chunk->stack_size());\n-      chunk->set_argsize(0);\n-      chunk->set_max_size(0);\n-    } else {\n-      chunk->set_sp(chunk->sp() + frame_size);\n-      chunk->set_max_size(chunk->max_size() - frame_size);\n-      \/\/ We set chunk->pc to the return pc into the next frame\n-      chunk->set_pc(f.pc());\n-      assert(f.pc() == *(address*)(chunk_sp + frame_size - frame::sender_sp_ret_address_offset()), \"unexpected pc\");\n-    }\n-    assert(empty == chunk->is_empty(), \"\");\n-    thaw_size = frame_size + argsize;\n+    thaw_size = remove_top_compiled_frame_from_chunk(chunk, argsize);\n+    empty = chunk->is_empty();\n@@ -1670,0 +1736,1 @@\n+  assert(!is_last || argsize == 0, \"\");\n@@ -1674,2 +1741,1 @@\n-  intptr_t* stack_sp = _cont.entrySP();\n-  intptr_t* bottom_sp = ContinuationHelper::frame_align_pointer(stack_sp - argsize);\n+  ReconstructedStack rs(_cont.entrySP(), thaw_size, argsize);\n@@ -1677,6 +1743,2 @@\n-  stack_sp -= thaw_size;\n-  \/\/ possibly adds a one-word padding between entrySP and the bottom-most frame's stack args\n-  \/\/ The only possible source of misalignment is stack-passed arguments because all compiled\n-  \/\/ frames are 16-byte aligned.\n-  assert(argsize != 0 || stack_sp == ContinuationHelper::frame_align_pointer(stack_sp), \"\");\n-  stack_sp = ContinuationHelper::frame_align_pointer(stack_sp);\n+  \/\/ Verify that all sizes and addresses are correct before copying\n+  rs.verify();\n@@ -1685,8 +1747,1 @@\n-  intptr_t* from = chunk_sp - frame::metadata_words;\n-  intptr_t* to   = stack_sp - frame::metadata_words;\n-  copy_from_chunk(from, to, thaw_size + frame::metadata_words);\n-  \/\/ We assert we have not overwritten the entry frame, but that we're at most\n-  \/\/ one alignment word away from it.\n-  assert(to + thaw_size + frame::metadata_words <= _cont.entrySP(), \"overwritten entry frame\");\n-  assert(_cont.entrySP() - 1 <= to + thaw_size + frame::metadata_words, \"missed entry frame\");\n-  assert(argsize != 0 || to + thaw_size + frame::metadata_words == _cont.entrySP(), \"missed entry frame\");\n+  copy_from_chunk(chunk_sp - frame::metadata_words, rs.top(), rs.total_size());\n@@ -1694,2 +1749,2 @@\n-  assert(!is_last || argsize == 0, \"\");\n-  _cont.set_argsize(argsize); \/\/ sets argsize in ContinuationEntry\n+  \/\/ update the ContinuationEntry\n+  _cont.set_argsize(argsize);\n@@ -1697,1 +1752,1 @@\n-  assert(bottom_sp == _cont.entry()->bottom_sender_sp(), \"\");\n+  assert(rs.bottom_sp() == _cont.entry()->bottom_sender_sp(), \"\");\n@@ -1700,4 +1755,2 @@\n-  patch_return(bottom_sp, is_last);\n-  DEBUG_ONLY(address pc = *(address*)(bottom_sp - frame::sender_sp_ret_address_offset());)\n-  assert(is_last ? CodeCache::find_blob(pc)->as_compiled_method()->method()->is_continuation_enter_intrinsic()\n-                  : pc == StubRoutines::cont_returnBarrier(), \"is_last: %d\", is_last);\n+  rs.patch_return(is_last, _cont.entryPC());\n+\n@@ -1718,1 +1771,1 @@\n-  set_anchor(_thread, stack_sp);\n+  set_anchor(_thread, rs.sp());\n@@ -1726,17 +1779,1 @@\n-  return stack_sp;\n-}\n-\n-void ThawBase::copy_from_chunk(intptr_t* from, intptr_t* to, int size) {\n-  assert(to + size <= _cont.entrySP(), \"\");\n-  _cont.tail()->copy_from_chunk_to_stack(from, to, size);\n-  CONT_JFR_ONLY(_jfr_info.record_size_copied(size);)\n-  assert(to >= _top_stack_address, \"overwrote past thawing space\"\n-    \" to: \" INTPTR_FORMAT \" top_address: \" INTPTR_FORMAT, p2i(to), p2i(_top_stack_address));\n-}\n-\n-void ThawBase::patch_return(intptr_t* sp, bool is_last) {\n-  log_develop_trace(continuations)(\"thaw_fast patching -- sp: \" INTPTR_FORMAT, p2i(sp));\n-\n-  address pc = !is_last ? StubRoutines::cont_returnBarrier() : _cont.entryPC();\n-  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n-  \/\/ patch_chunk_pd(sp); -- TODO: If not needed - remove method; it's not used elsewhere\n+  return rs.sp();\n@@ -1859,1 +1896,1 @@\n-  chunk->set_max_size(chunk->max_size() - delta);\n+  chunk->set_max_thawing_size(chunk->max_thawing_size() - delta);\n@@ -2097,1 +2134,1 @@\n-    chunk->set_max_size(0);\n+    chunk->set_max_thawing_size(0);\n@@ -2100,1 +2137,1 @@\n-    chunk->set_max_size(chunk->max_size() - _align_size);\n+    chunk->set_max_thawing_size(chunk->max_thawing_size() - _align_size);\n@@ -2102,1 +2139,1 @@\n-  assert(chunk->is_empty() == (chunk->max_size() == 0), \"\");\n+  assert(chunk->is_empty() == (chunk->max_thawing_size() == 0), \"\");\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":128,"deletions":91,"binary":false,"changes":219,"status":"modified"}]}