{"files":[{"patch":"@@ -35,0 +35,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -2244,0 +2245,10 @@\n+\/\/ For redefinition, if any methods found in InstanceStackChunks, the marking_cycle is\n+\/\/ recorded in their constant pool cache. The on_stack-ness of the constant pool controls whether\n+\/\/ memory for the method is reclaimed.\n+bool ConstantPool::on_stack() const {\n+  if (_cache == NULL || _pool_holder == NULL) return false; \/\/ removed in loading\n+\n+  \/\/ See nmethod::is_not_on_continuation_stack for explanation of what this means.\n+  bool not_on_vthread_stack = CodeCache::marking_cycle() >= align_up(cache()->marking_cycle(), 2) + 2;\n+  return (_flags &_on_stack) != 0 || !not_on_vthread_stack;\n+}\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  bool on_stack() const                      { return (_flags &_on_stack) != 0; }\n+  bool on_stack() const;\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -708,0 +709,5 @@\n+\/\/ Record the GC marking cycle when redefined vs. when found in the InstanceStackChunks.\n+void ConstantPoolCache::record_marking_cycle() {\n+  _marking_cycle = CodeCache::marking_cycle();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -417,0 +417,4 @@\n+\n+  \/\/ RedefineClasses support\n+  uint64_t             _marking_cycle;\n+\n@@ -510,0 +514,2 @@\n+  void record_marking_cycle();\n+  uint64_t marking_cycle() { return _marking_cycle; }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,2 @@\n-                                                  _constant_pool(NULL) {\n+                                                  _constant_pool(NULL),\n+                                                  _marking_cycle(0) {\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3981,24 +3981,0 @@\n-    \/\/ At least one method is live in this previous version.\n-    \/\/ Reset dead EMCP methods not to get breakpoints.\n-    \/\/ All methods are deallocated when all of the methods for this class are no\n-    \/\/ longer running.\n-    Array<Method*>* method_refs = pv_node->methods();\n-    if (method_refs != NULL) {\n-      log_trace(redefine, class, iklass, purge)(\"previous methods length=%d\", method_refs->length());\n-      for (int j = 0; j < method_refs->length(); j++) {\n-        Method* method = method_refs->at(j);\n-\n-        if (!method->on_stack()) {\n-          \/\/ no breakpoints for non-running methods\n-          if (method->is_running_emcp()) {\n-            method->set_running_emcp(false);\n-          }\n-        } else {\n-          assert (method->is_obsolete() || method->is_running_emcp(),\n-                  \"emcp method cannot run after emcp bit is cleared\");\n-          log_trace(redefine, class, iklass, purge)\n-            (\"purge: %s(%s): prev method @%d in version @%d is alive\",\n-             method->name()->as_C_string(), method->signature()->as_C_string(), j, version);\n-        }\n-      }\n-    }\n@@ -4104,23 +4080,0 @@\n-  if (emcp_method_count != 0) {\n-    \/\/ At least one method is still running, check for EMCP methods\n-    for (int i = 0; i < old_methods->length(); i++) {\n-      Method* old_method = old_methods->at(i);\n-      if (!old_method->is_obsolete() && old_method->on_stack()) {\n-        \/\/ if EMCP method (not obsolete) is on the stack, mark as EMCP so that\n-        \/\/ we can add breakpoints for it.\n-\n-        \/\/ We set the method->on_stack bit during safepoints for class redefinition\n-        \/\/ and use this bit to set the is_running_emcp bit.\n-        \/\/ After the safepoint, the on_stack bit is cleared and the running emcp\n-        \/\/ method may exit.   If so, we would set a breakpoint in a method that\n-        \/\/ is never reached, but this won't be noticeable to the programmer.\n-        old_method->set_running_emcp(true);\n-        log_trace(redefine, class, iklass, add)\n-          (\"EMCP method %s is on_stack \" INTPTR_FORMAT, old_method->name_and_sig_as_C_string(), p2i(old_method));\n-      } else if (!old_method->is_obsolete()) {\n-        log_trace(redefine, class, iklass, add)\n-          (\"EMCP method %s is NOT on_stack \" INTPTR_FORMAT, old_method->name_and_sig_as_C_string(), p2i(old_method));\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -793,5 +793,12 @@\n-  CodeBlob* cb = f.cb();\n-  if ((mixed && cb == nullptr) || !cb->is_nmethod()) return;\n-  nmethod* nm = cb->as_nmethod();\n-  if (BarrierSet::barrier_set()->barrier_set_nmethod()->is_armed(nm)) {\n-    nm->run_nmethod_entry_barrier();\n+  if (f.is_interpreted()) {\n+    \/\/ Mark interpreted frames for marking_cycle\n+    Method* im = f.to_frame().interpreter_frame_method();\n+    im->record_marking_cycle();\n+  } else {\n+    CodeBlob* cb = f.cb();\n+    if (cb->is_nmethod()) {\n+      nmethod* nm = cb->as_nmethod();\n+      if (BarrierSet::barrier_set()->barrier_set_nmethod()->is_armed(nm)) {\n+        nm->run_nmethod_entry_barrier();\n+      }\n+    }\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2258,2 +2258,7 @@\n-  assert(!value || !is_old() || is_obsolete() || is_running_emcp(),\n-         \"emcp methods cannot run after emcp bit is cleared\");\n+}\n+\n+void Method::record_marking_cycle() {\n+  \/\/ If any method is on the stack in continuations, none of them can be reclaimed,\n+  \/\/ so save the marking cycle to check for the whole class in the cpCache.\n+  \/\/ The cpCache is writeable.\n+  constants()->cache()->record_marking_cycle();\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -92,6 +92,5 @@\n-    _running_emcp          = 1 << 5,\n-    _intrinsic_candidate   = 1 << 6,\n-    _reserved_stack_access = 1 << 7,\n-    _scoped                = 1 << 8,\n-    _changes_current_thread = 1 << 9,\n-    _jvmti_mount_transition = 1 << 10,\n+    _intrinsic_candidate   = 1 << 5,\n+    _reserved_stack_access = 1 << 6,\n+    _scoped                = 1 << 7,\n+    _changes_current_thread = 1 << 8,\n+    _jvmti_mount_transition = 1 << 9,\n@@ -761,14 +760,0 @@\n-  bool is_running_emcp() const {\n-    \/\/ EMCP methods are old but not obsolete or deleted. Equivalent\n-    \/\/ Modulo Constant Pool means the method is equivalent except\n-    \/\/ the constant pool and instructions that access the constant\n-    \/\/ pool might be different.\n-    \/\/ If a breakpoint is set in a redefined method, its EMCP methods that are\n-    \/\/ still running must have a breakpoint also.\n-    return (_flags & _running_emcp) != 0;\n-  }\n-\n-  void set_running_emcp(bool x) {\n-    _flags = x ? (_flags | _running_emcp) : (_flags & ~_running_emcp);\n-  }\n-\n@@ -778,0 +763,2 @@\n+  void record_marking_cycle();\n+\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -248,1 +248,10 @@\n-      if (method->is_running_emcp() &&\n+      \/\/ EMCP methods are old but not obsolete. Equivalent\n+      \/\/ Modulo Constant Pool means the method is equivalent except\n+      \/\/ the constant pool and instructions that access the constant\n+      \/\/ pool might be different.\n+      \/\/ If a breakpoint is set in a redefined method, its EMCP methods\n+      \/\/ must have a breakpoint also.\n+      \/\/ None of the methods are deleted until none are running.\n+      \/\/ This code could set a breakpoint in a method that\n+      \/\/ is never reached, but this won't be noticeable to the programmer.\n+      if (!method->is_obsolete() &&\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1500,0 +1500,2 @@\n+    Method* frame_method = Frame::frame_method(f);\n+\n@@ -1501,1 +1503,1 @@\n-      Frame::frame_method(f)->name_and_sig_as_C_string(), _size, fsize, argsize, callee_interpreted, callee_argsize, p2i(vsp), p2i(vsp+fsize));\n+      frame_method->name_and_sig_as_C_string(), _size, fsize, argsize, callee_interpreted, callee_argsize, p2i(vsp), p2i(vsp+fsize));\n@@ -1523,0 +1525,4 @@\n+\n+    \/\/ Mark frame_method's marking cycle for GC and redefinition on_stack calculation.\n+    frame_method->record_marking_cycle();\n+\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -512,1 +512,0 @@\n-#ifdef PRODUCT\n@@ -514,4 +513,1 @@\n-  } else {\n-    tty->print_cr(\"Cannot find the last Java frame, printing stack disabled.\");\n-#else \/\/ !PRODUCT\n-    p->trace_stack();\n+    if (Verbose) p->trace_stack();\n@@ -525,1 +521,0 @@\n-#endif \/\/ PRODUCT\n@@ -527,1 +522,0 @@\n-\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -170,1 +170,0 @@\n-runtime\/vthread\/RedefineClass.java                                            8253378 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+        System.gc();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefineLeak.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,0 +94,3 @@\n+        \/\/ Start with a full GC.\n+        System.gc();\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/RedefinePreviousVersions.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8055008 8197901 8010319\n+ * @summary Redefine EMCP and non-EMCP methods that are running in an infinite loop\n+ * @requires vm.jvmti\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.compiler\n+ *          java.instrument\n+ *          jdk.jartool\/sun.tools.jar\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm\/timeout=180 -Xint -javaagent:redefineagent.jar -Xlog:redefine+class+iklass+add=trace,redefine+class+iklass+purge=trace,class+loader+data=debug,safepoint+cleanup,gc+phases=debug:rt.log RedefineRunningMethods\n+ *\/\n+\n+\n+class RedefineContinuation {\n+    static final ContinuationScope FOO = new ContinuationScope() {};\n+\n+    static void moveToHeap(int a) {\n+        boolean res = Continuation.yield(FOO);\n+    }\n+}\n+\n+\/\/ package access top-level class to avoid problem with RedefineClassHelper\n+\/\/ and nested types.\n+class RedefineRunningMethods_B {\n+    static int count1 = 0;\n+    static int count2 = 0;\n+    public static volatile boolean stop = false;\n+    static void localSleep() {\n+        RedefineContinuation.moveToHeap(1);\n+    }\n+\n+    public static void infinite() {\n+        while (!stop) { count1++; localSleep(); }\n+    }\n+    public static void infinite_emcp() {\n+        System.out.println(\"infinite_emcp called\");\n+        while (!stop) { count2++; localSleep(); }\n+    }\n+}\n+\n+\n+public class RedefineRunningMethods {\n+\n+    public static String newB =\n+                \"class RedefineRunningMethods_B {\" +\n+                \"   static int count1 = 0;\" +\n+                \"   static int count2 = 0;\" +\n+                \"   public static volatile boolean stop = false;\" +\n+                \"  static void localSleep() { \" +\n+                \"      RedefineContinuation.moveToHeap(2);\" +\n+                \" } \" +\n+                \"   public static void infinite() { \" +\n+                \"       System.out.println(\\\"infinite called\\\");\" +\n+                \"   }\" +\n+                \"   public static void infinite_emcp() { \" +\n+                \"       System.out.println(\\\"infinite_emcp called\\\");\" +\n+                \"       while (!stop) { count2++; localSleep(); }\" +\n+                \"   }\" +\n+                \"}\";\n+\n+    public static String evenNewerB =\n+                \"class RedefineRunningMethods_B {\" +\n+                \"   static int count1 = 0;\" +\n+                \"   static int count2 = 0;\" +\n+                \"   public static volatile boolean stop = false;\" +\n+                \"  static void localSleep() { \" +\n+                \"      RedefineContinuation.moveToHeap(3);\" +\n+                \" } \" +\n+                \"   public static void infinite() { }\" +\n+                \"   public static void infinite_emcp() { \" +\n+                \"       System.out.println(\\\"infinite_emcp now obsolete called\\\");\" +\n+                \"   }\" +\n+                \"}\";\n+\n+    static void test_redef_emcp() {\n+        System.out.println(\"test_redef\");\n+        Continuation cont = new Continuation(RedefineContinuation.FOO, ()-> {\n+              RedefineRunningMethods_B.infinite_emcp();\n+        });\n+\n+        while (!cont.isDone()) {\n+            cont.run();\n+            \/\/ System.gc();\n+        }\n+    }\n+\n+    static void test_redef_infinite() {\n+        System.out.println(\"test_redef\");\n+        Continuation cont = new Continuation(RedefineContinuation.FOO, ()-> {\n+              RedefineRunningMethods_B.infinite();\n+        });\n+\n+        while (!cont.isDone()) {\n+            cont.run();\n+            \/\/ System.gc();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        \/\/ Start with GC\n+        System.gc();\n+\n+        new Thread() {\n+            public void run() {\n+                test_redef_infinite();\n+            }\n+        }.start();\n+\n+        new Thread() {\n+            public void run() {\n+                test_redef_emcp();\n+            }\n+        }.start();\n+\n+        RedefineClassHelper.redefineClass(RedefineRunningMethods_B.class, newB);\n+\n+        System.gc();\n+\n+        RedefineRunningMethods_B.infinite();\n+\n+        \/\/ Start a thread with the second version of infinite_emcp running\n+        new Thread() {\n+            public void run() {\n+                test_redef_emcp();\n+            }\n+        }.start();\n+\n+        for (int i = 0; i < 20 ; i++) {\n+            String s = new String(\"some garbage\");\n+            System.gc();\n+        }\n+\n+        RedefineClassHelper.redefineClass(RedefineRunningMethods_B.class, evenNewerB);\n+        System.gc();\n+\n+        for (int i = 0; i < 20 ; i++) {\n+            RedefineRunningMethods_B.infinite();\n+            String s = new String(\"some garbage\");\n+            System.gc();\n+        }\n+\n+        RedefineRunningMethods_B.infinite_emcp();\n+\n+        \/\/ purge should clean everything up.\n+        RedefineRunningMethods_B.stop = true;\n+\n+        for (int i = 0; i < 20 ; i++) {\n+            \/\/ RedefineRunningMethods_B.infinite();\n+            String s = new String(\"some garbage\");\n+            System.gc();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/RedefineClasses\/RedefineRunningMethods.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"}]}