{"files":[{"patch":"@@ -201,222 +201,0 @@\n-\/\/ This class provides a simple wrapper over the internal structure of\n-\/\/ exception backtrace to insulate users of the backtrace from needing\n-\/\/ to know what it looks like.\n-\/\/ The code of this class is not GC safe. Allocations can only happen\n-\/\/ in expand().\n-class BacktraceBuilder: public StackObj {\n- friend class BacktraceIterator;\n- private:\n-  Handle          _backtrace;\n-  objArrayOop     _head;\n-  typeArrayOop    _methods;\n-  typeArrayOop    _bcis;\n-  objArrayOop     _mirrors;\n-  typeArrayOop    _names; \/\/ Needed to insulate method name against redefinition.\n-  \/\/ True if the top frame of the backtrace is omitted because it shall be hidden.\n-  bool            _has_hidden_top_frame;\n-  int             _index;\n-  NoSafepointVerifier _nsv;\n-\n-  enum {\n-    trace_methods_offset = java_lang_Throwable::trace_methods_offset,\n-    trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,\n-    trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,\n-    trace_names_offset   = java_lang_Throwable::trace_names_offset,\n-    trace_conts_offset   = java_lang_Throwable::trace_conts_offset,\n-    trace_next_offset    = java_lang_Throwable::trace_next_offset,\n-    trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,\n-    trace_size           = java_lang_Throwable::trace_size,\n-    trace_chunk_size     = java_lang_Throwable::trace_chunk_size\n-  };\n-\n-  \/\/ get info out of chunks\n-  static typeArrayOop get_methods(objArrayHandle chunk) {\n-    typeArrayOop methods = typeArrayOop(chunk->obj_at(trace_methods_offset));\n-    assert(methods != NULL, \"method array should be initialized in backtrace\");\n-    return methods;\n-  }\n-  static typeArrayOop get_bcis(objArrayHandle chunk) {\n-    typeArrayOop bcis = typeArrayOop(chunk->obj_at(trace_bcis_offset));\n-    assert(bcis != NULL, \"bci array should be initialized in backtrace\");\n-    return bcis;\n-  }\n-  static objArrayOop get_mirrors(objArrayHandle chunk) {\n-    objArrayOop mirrors = objArrayOop(chunk->obj_at(trace_mirrors_offset));\n-    assert(mirrors != NULL, \"mirror array should be initialized in backtrace\");\n-    return mirrors;\n-  }\n-  static typeArrayOop get_names(objArrayHandle chunk) {\n-    typeArrayOop names = typeArrayOop(chunk->obj_at(trace_names_offset));\n-    assert(names != NULL, \"names array should be initialized in backtrace\");\n-    return names;\n-  }\n-  static bool has_hidden_top_frame(objArrayHandle chunk) {\n-    oop hidden = chunk->obj_at(trace_hidden_offset);\n-    return hidden != NULL;\n-  }\n-\n- public:\n-\n-  \/\/ constructor for new backtrace\n-  BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {\n-    expand(CHECK);\n-    _backtrace = Handle(THREAD, _head);\n-    _index = 0;\n-  }\n-\n-  BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {\n-    _methods = get_methods(backtrace);\n-    _bcis = get_bcis(backtrace);\n-    _mirrors = get_mirrors(backtrace);\n-    _names = get_names(backtrace);\n-    _has_hidden_top_frame = has_hidden_top_frame(backtrace);\n-    assert(_methods->length() == _bcis->length() &&\n-           _methods->length() == _mirrors->length() &&\n-           _mirrors->length() == _names->length(),\n-           \"method and source information arrays should match\");\n-\n-    \/\/ head is the preallocated backtrace\n-    _head = backtrace();\n-    _backtrace = Handle(thread, _head);\n-    _index = 0;\n-  }\n-\n-  void expand(TRAPS) {\n-    objArrayHandle old_head(THREAD, _head);\n-    PauseNoSafepointVerifier pnsv(&_nsv);\n-\n-    objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);\n-    objArrayHandle new_head(THREAD, head);\n-\n-    typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);\n-    typeArrayHandle new_methods(THREAD, methods);\n-\n-    typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);\n-    typeArrayHandle new_bcis(THREAD, bcis);\n-\n-    objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);\n-    objArrayHandle new_mirrors(THREAD, mirrors);\n-\n-    typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);\n-    typeArrayHandle new_names(THREAD, names);\n-\n-    if (!old_head.is_null()) {\n-      old_head->obj_at_put(trace_next_offset, new_head());\n-    }\n-    new_head->obj_at_put(trace_methods_offset, new_methods());\n-    new_head->obj_at_put(trace_bcis_offset, new_bcis());\n-    new_head->obj_at_put(trace_mirrors_offset, new_mirrors());\n-    new_head->obj_at_put(trace_names_offset, new_names());\n-    new_head->obj_at_put(trace_hidden_offset, NULL);\n-\n-    _head    = new_head();\n-    _methods = new_methods();\n-    _bcis = new_bcis();\n-    _mirrors = new_mirrors();\n-    _names  = new_names();\n-    _index = 0;\n-  }\n-\n-  oop backtrace() {\n-    return _backtrace();\n-  }\n-\n-  inline void push(Method* method, int bci, TRAPS) {\n-    \/\/ Smear the -1 bci to 0 since the array only holds unsigned\n-    \/\/ shorts.  The later line number lookup would just smear the -1\n-    \/\/ to a 0 even if it could be recorded.\n-    if (bci == SynchronizationEntryBCI) bci = 0;\n-\n-    if (_index >= trace_chunk_size) {\n-      methodHandle mhandle(THREAD, method);\n-      expand(CHECK);\n-      method = mhandle();\n-    }\n-\n-    _methods->ushort_at_put(_index, method->orig_method_idnum());\n-    _bcis->int_at_put(_index, Backtrace::merge_bci_and_version(bci, method->constants()->version()));\n-\n-    \/\/ Note:this doesn't leak symbols because the mirror in the backtrace keeps the\n-    \/\/ klass owning the symbols alive so their refcounts aren't decremented.\n-    Symbol* name = method->name();\n-    _names->symbol_at_put(_index, name);\n-\n-    \/\/ We need to save the mirrors in the backtrace to keep the class\n-    \/\/ from being unloaded while we still have this stack trace.\n-    assert(method->method_holder()->java_mirror() != NULL, \"never push null for mirror\");\n-    _mirrors->obj_at_put(_index, method->method_holder()->java_mirror());\n-\n-    _index++;\n-  }\n-\n-  void set_has_hidden_top_frame(TRAPS) {\n-    if (!_has_hidden_top_frame) {\n-      \/\/ It would be nice to add java\/lang\/Boolean::TRUE here\n-      \/\/ to indicate that this backtrace has a hidden top frame.\n-      \/\/ But this code is used before TRUE is allocated.\n-      \/\/ Therefore let's just use an arbitrary legal oop\n-      \/\/ available right here. _methods is a short[].\n-      assert(_methods != NULL, \"we need a legal oop\");\n-      _has_hidden_top_frame = true;\n-      _head->obj_at_put(trace_hidden_offset, _methods);\n-    }\n-  }\n-};\n-\n-struct BacktraceElement : public StackObj {\n-  int _method_id;\n-  int _bci;\n-  int _version;\n-  Symbol* _name;\n-  Handle _mirror;\n-  BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :\n-                   _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}\n-};\n-\n-class BacktraceIterator : public StackObj {\n-  int _index;\n-  objArrayHandle  _result;\n-  objArrayHandle  _mirrors;\n-  typeArrayHandle _methods;\n-  typeArrayHandle _bcis;\n-  typeArrayHandle _names;\n-\n-  void init(objArrayHandle result, Thread* thread) {\n-    \/\/ Get method id, bci, version and mirror from chunk\n-    _result = result;\n-    if (_result.not_null()) {\n-      _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));\n-      _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));\n-      _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));\n-      _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));\n-      _index = 0;\n-    }\n-  }\n- public:\n-  BacktraceIterator(objArrayHandle result, Thread* thread) {\n-    init(result, thread);\n-    assert(_methods.is_null() || _methods->length() == java_lang_Throwable::trace_chunk_size, \"lengths don't match\");\n-  }\n-\n-  BacktraceElement next(Thread* thread) {\n-    BacktraceElement e (Handle(thread, _mirrors->obj_at(_index)),\n-                        _methods->ushort_at(_index),\n-                        Backtrace::version_at(_bcis->int_at(_index)),\n-                        Backtrace::bci_at(_bcis->int_at(_index)),\n-                        _names->symbol_at(_index));\n-    _index++;\n-\n-    if (_index >= java_lang_Throwable::trace_chunk_size) {\n-      int next_offset = java_lang_Throwable::trace_next_offset;\n-      \/\/ Get next chunk\n-      objArrayHandle result (thread, objArrayOop(_result->obj_at(next_offset)));\n-      init(result, thread);\n-    }\n-    return e;\n-  }\n-\n-  bool repeat() {\n-    return _result.not_null() && _mirrors->obj_at(_index) != NULL;\n-  }\n-};\n-\n@@ -2583,0 +2361,223 @@\n+\/\/ This class provides a simple wrapper over the internal structure of\n+\/\/ exception backtrace to insulate users of the backtrace from needing\n+\/\/ to know what it looks like.\n+\/\/ The code of this class is not GC safe. Allocations can only happen\n+\/\/ in expand().\n+class BacktraceBuilder: public StackObj {\n+ friend class BacktraceIterator;\n+ private:\n+  Handle          _backtrace;\n+  objArrayOop     _head;\n+  typeArrayOop    _methods;\n+  typeArrayOop    _bcis;\n+  objArrayOop     _mirrors;\n+  typeArrayOop    _names; \/\/ Needed to insulate method name against redefinition.\n+  \/\/ True if the top frame of the backtrace is omitted because it shall be hidden.\n+  bool            _has_hidden_top_frame;\n+  int             _index;\n+  NoSafepointVerifier _nsv;\n+\n+  enum {\n+    trace_methods_offset = java_lang_Throwable::trace_methods_offset,\n+    trace_bcis_offset    = java_lang_Throwable::trace_bcis_offset,\n+    trace_mirrors_offset = java_lang_Throwable::trace_mirrors_offset,\n+    trace_names_offset   = java_lang_Throwable::trace_names_offset,\n+    trace_conts_offset   = java_lang_Throwable::trace_conts_offset,\n+    trace_next_offset    = java_lang_Throwable::trace_next_offset,\n+    trace_hidden_offset  = java_lang_Throwable::trace_hidden_offset,\n+    trace_size           = java_lang_Throwable::trace_size,\n+    trace_chunk_size     = java_lang_Throwable::trace_chunk_size\n+  };\n+\n+  \/\/ get info out of chunks\n+  static typeArrayOop get_methods(objArrayHandle chunk) {\n+    typeArrayOop methods = typeArrayOop(chunk->obj_at(trace_methods_offset));\n+    assert(methods != NULL, \"method array should be initialized in backtrace\");\n+    return methods;\n+  }\n+  static typeArrayOop get_bcis(objArrayHandle chunk) {\n+    typeArrayOop bcis = typeArrayOop(chunk->obj_at(trace_bcis_offset));\n+    assert(bcis != NULL, \"bci array should be initialized in backtrace\");\n+    return bcis;\n+  }\n+  static objArrayOop get_mirrors(objArrayHandle chunk) {\n+    objArrayOop mirrors = objArrayOop(chunk->obj_at(trace_mirrors_offset));\n+    assert(mirrors != NULL, \"mirror array should be initialized in backtrace\");\n+    return mirrors;\n+  }\n+  static typeArrayOop get_names(objArrayHandle chunk) {\n+    typeArrayOop names = typeArrayOop(chunk->obj_at(trace_names_offset));\n+    assert(names != NULL, \"names array should be initialized in backtrace\");\n+    return names;\n+  }\n+  static bool has_hidden_top_frame(objArrayHandle chunk) {\n+    oop hidden = chunk->obj_at(trace_hidden_offset);\n+    return hidden != NULL;\n+  }\n+\n+ public:\n+\n+  \/\/ constructor for new backtrace\n+  BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {\n+    expand(CHECK);\n+    _backtrace = Handle(THREAD, _head);\n+    _index = 0;\n+  }\n+\n+  BacktraceBuilder(Thread* thread, objArrayHandle backtrace) {\n+    _methods = get_methods(backtrace);\n+    _bcis = get_bcis(backtrace);\n+    _mirrors = get_mirrors(backtrace);\n+    _names = get_names(backtrace);\n+    _has_hidden_top_frame = has_hidden_top_frame(backtrace);\n+    assert(_methods->length() == _bcis->length() &&\n+           _methods->length() == _mirrors->length() &&\n+           _mirrors->length() == _names->length(),\n+           \"method and source information arrays should match\");\n+\n+    \/\/ head is the preallocated backtrace\n+    _head = backtrace();\n+    _backtrace = Handle(thread, _head);\n+    _index = 0;\n+  }\n+\n+  void expand(TRAPS) {\n+    objArrayHandle old_head(THREAD, _head);\n+    PauseNoSafepointVerifier pnsv(&_nsv);\n+\n+    objArrayOop head = oopFactory::new_objectArray(trace_size, CHECK);\n+    objArrayHandle new_head(THREAD, head);\n+\n+    typeArrayOop methods = oopFactory::new_shortArray(trace_chunk_size, CHECK);\n+    typeArrayHandle new_methods(THREAD, methods);\n+\n+    typeArrayOop bcis = oopFactory::new_intArray(trace_chunk_size, CHECK);\n+    typeArrayHandle new_bcis(THREAD, bcis);\n+\n+    objArrayOop mirrors = oopFactory::new_objectArray(trace_chunk_size, CHECK);\n+    objArrayHandle new_mirrors(THREAD, mirrors);\n+\n+    typeArrayOop names = oopFactory::new_symbolArray(trace_chunk_size, CHECK);\n+    typeArrayHandle new_names(THREAD, names);\n+\n+    if (!old_head.is_null()) {\n+      old_head->obj_at_put(trace_next_offset, new_head());\n+    }\n+    new_head->obj_at_put(trace_methods_offset, new_methods());\n+    new_head->obj_at_put(trace_bcis_offset, new_bcis());\n+    new_head->obj_at_put(trace_mirrors_offset, new_mirrors());\n+    new_head->obj_at_put(trace_names_offset, new_names());\n+    new_head->obj_at_put(trace_hidden_offset, NULL);\n+\n+    _head    = new_head();\n+    _methods = new_methods();\n+    _bcis = new_bcis();\n+    _mirrors = new_mirrors();\n+    _names  = new_names();\n+    _index = 0;\n+  }\n+\n+  oop backtrace() {\n+    return _backtrace();\n+  }\n+\n+  inline void push(Method* method, int bci, TRAPS) {\n+    \/\/ Smear the -1 bci to 0 since the array only holds unsigned\n+    \/\/ shorts.  The later line number lookup would just smear the -1\n+    \/\/ to a 0 even if it could be recorded.\n+    if (bci == SynchronizationEntryBCI) bci = 0;\n+\n+    if (_index >= trace_chunk_size) {\n+      methodHandle mhandle(THREAD, method);\n+      expand(CHECK);\n+      method = mhandle();\n+    }\n+\n+    _methods->ushort_at_put(_index, method->orig_method_idnum());\n+    _bcis->int_at_put(_index, Backtrace::merge_bci_and_version(bci, method->constants()->version()));\n+\n+    \/\/ Note:this doesn't leak symbols because the mirror in the backtrace keeps the\n+    \/\/ klass owning the symbols alive so their refcounts aren't decremented.\n+    Symbol* name = method->name();\n+    _names->symbol_at_put(_index, name);\n+\n+    \/\/ We need to save the mirrors in the backtrace to keep the class\n+    \/\/ from being unloaded while we still have this stack trace.\n+    assert(method->method_holder()->java_mirror() != NULL, \"never push null for mirror\");\n+    _mirrors->obj_at_put(_index, method->method_holder()->java_mirror());\n+\n+    _index++;\n+  }\n+\n+  void set_has_hidden_top_frame(TRAPS) {\n+    if (!_has_hidden_top_frame) {\n+      \/\/ It would be nice to add java\/lang\/Boolean::TRUE here\n+      \/\/ to indicate that this backtrace has a hidden top frame.\n+      \/\/ But this code is used before TRUE is allocated.\n+      \/\/ Therefore let's just use an arbitrary legal oop\n+      \/\/ available right here. _methods is a short[].\n+      assert(_methods != NULL, \"we need a legal oop\");\n+      _has_hidden_top_frame = true;\n+      _head->obj_at_put(trace_hidden_offset, _methods);\n+    }\n+  }\n+};\n+\n+struct BacktraceElement : public StackObj {\n+  int _method_id;\n+  int _bci;\n+  int _version;\n+  Symbol* _name;\n+  Handle _mirror;\n+  BacktraceElement(Handle mirror, int mid, int version, int bci, Symbol* name) :\n+                   _method_id(mid), _bci(bci), _version(version), _name(name), _mirror(mirror) {}\n+};\n+\n+class BacktraceIterator : public StackObj {\n+  int _index;\n+  objArrayHandle  _result;\n+  objArrayHandle  _mirrors;\n+  typeArrayHandle _methods;\n+  typeArrayHandle _bcis;\n+  typeArrayHandle _names;\n+\n+  void init(objArrayHandle result, Thread* thread) {\n+    \/\/ Get method id, bci, version and mirror from chunk\n+    _result = result;\n+    if (_result.not_null()) {\n+      _methods = typeArrayHandle(thread, BacktraceBuilder::get_methods(_result));\n+      _bcis = typeArrayHandle(thread, BacktraceBuilder::get_bcis(_result));\n+      _mirrors = objArrayHandle(thread, BacktraceBuilder::get_mirrors(_result));\n+      _names = typeArrayHandle(thread, BacktraceBuilder::get_names(_result));\n+      _index = 0;\n+    }\n+  }\n+ public:\n+  BacktraceIterator(objArrayHandle result, Thread* thread) {\n+    init(result, thread);\n+    assert(_methods.is_null() || _methods->length() == java_lang_Throwable::trace_chunk_size, \"lengths don't match\");\n+  }\n+\n+  BacktraceElement next(Thread* thread) {\n+    BacktraceElement e (Handle(thread, _mirrors->obj_at(_index)),\n+                        _methods->ushort_at(_index),\n+                        Backtrace::version_at(_bcis->int_at(_index)),\n+                        Backtrace::bci_at(_bcis->int_at(_index)),\n+                        _names->symbol_at(_index));\n+    _index++;\n+\n+    if (_index >= java_lang_Throwable::trace_chunk_size) {\n+      int next_offset = java_lang_Throwable::trace_next_offset;\n+      \/\/ Get next chunk\n+      objArrayHandle result (thread, objArrayOop(_result->obj_at(next_offset)));\n+      init(result, thread);\n+    }\n+    return e;\n+  }\n+\n+  bool repeat() {\n+    return _result.not_null() && _mirrors->obj_at(_index) != NULL;\n+  }\n+};\n+\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":223,"deletions":222,"binary":false,"changes":445,"status":"modified"}]}