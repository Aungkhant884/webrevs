{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"logging\/log.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,3 +58,0 @@\n-  \/\/ Loom support\n-  static bool requires_barriers(stackChunkOop obj);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -110,4 +109,0 @@\n-inline bool G1BarrierSet::requires_barriers(stackChunkOop obj) {\n-  return G1CollectedHeap::heap()->G1CollectedHeap::requires_barriers(obj);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -94,3 +94,0 @@\n-  \/\/ Loom support\n-  static bool requires_barriers(stackChunkOop obj);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -62,4 +61,0 @@\n-inline bool BarrierSet::requires_barriers(stackChunkOop obj) {\n-  return Universe::heap()->requires_barriers(obj);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  static bool requires_barriers(stackChunkOop obj);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"gc\/z\/zCollectedHeap.inline.hpp\"\n@@ -243,4 +242,0 @@\n-inline bool ZBarrierSet::requires_barriers(stackChunkOop obj) {\n-  return ZCollectedHeap::heap()->ZCollectedHeap::requires_barriers(obj);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -125,0 +125,21 @@\n+bool ZCollectedHeap::requires_barriers(stackChunkOop obj) const {\n+  uintptr_t* cont_addr = obj->field_addr<uintptr_t>(jdk_internal_vm_StackChunk::cont_offset());\n+\n+  if (!_heap.is_allocating(cast_from_oop<uintptr_t>(obj))) {\n+    \/\/ An object that isn't allocating, is visible from GC tracing. Such\n+    \/\/ stack chunks require barriers.\n+    return true;\n+  }\n+\n+  if (!ZAddress::is_good_or_null(*cont_addr)) {\n+    \/\/ If a chunk is allocated after a GC started, but before relocate start\n+    \/\/ we can have an allocating chunk that isn't deeply good. That means that\n+    \/\/ the contained oops might be bad and require GC barriers.\n+    return true;\n+  }\n+\n+  \/\/ The chunk is allocating and its pointers are good. This chunk needs no\n+  \/\/ GC barriers\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  virtual inline bool requires_barriers(stackChunkOop obj) const;\n+  virtual bool requires_barriers(stackChunkOop obj) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZCOLLECTEDHEAP_INLINE_HPP\n-#define SHARE_GC_Z_ZCOLLECTEDHEAP_INLINE_HPP\n-\n-#include \"gc\/z\/zCollectedHeap.hpp\"\n-\n-#include \"gc\/z\/zAddress.inline.hpp\"\n-#include \"gc\/z\/zHeap.inline.hpp\"\n-\n-inline bool ZCollectedHeap::requires_barriers(stackChunkOop obj) const {\n-  uintptr_t* cont_addr = obj->field_addr<uintptr_t>(jdk_internal_vm_StackChunk::cont_offset());\n-\n-  if (!_heap.is_allocating(cast_from_oop<uintptr_t>(obj))) {\n-    \/\/ An object that isn't allocating, is visible from GC tracing. Such\n-    \/\/ stack chunks require barriers.\n-    return true;\n-  }\n-\n-  if (!ZAddress::is_good_or_null(*cont_addr)) {\n-    \/\/ If a chunk is allocated after a GC started, but before relocate start\n-    \/\/ we can have an allocating chunk that isn't deeply good. That means that\n-    \/\/ the contained oops might be bad and require GC barriers.\n-    return true;\n-  }\n-\n-  \/\/ The chunk is allocating and its pointers are good. This chunk needs no\n-  \/\/ GC barriers\n-  return false;\n-}\n-\n-#endif \/\/ SHARE_GC_Z_ZCOLLECTEDHEAP_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.inline.hpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -36,0 +36,2 @@\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-    return BarrierSetT::requires_barriers(obj);\n+    return obj->requires_barriers();\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}