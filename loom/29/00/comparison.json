{"files":[{"patch":"@@ -360,2 +360,8 @@\n-  \/\/ If requires_barriers() returns false, then HeapAccesses into the object\n-  \/\/ are equivalent to RawAccesses.\n+\n+  \/\/ Return true, if accesses to the object would require barriers.\n+  \/\/ This is used by continuations to copy chunks of a thread stack into StackChunk object or out of a StackChunk\n+  \/\/ object back into the thread stack. These chunks may contain references to objects. It is crucial that\n+  \/\/ the GC does not attempt to traverse the object while we modify it, because its structure (oopmap) is changed\n+  \/\/ when stack chunks are stored into it.\n+  \/\/ StackChunk objects may be reused, the GC must not assume that a StackChunk object is always a freshly\n+  \/\/ allocated object.\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2316,0 +2316,7 @@\n+\n+bool ShenandoahHeap::requires_barriers(oop obj) const {\n+  ShenandoahHeapRegion* region = heap_region_containing(obj);\n+  bool requires_concmark_barriers = is_concurrent_mark_in_progress() && !marking_context()->allocated_after_mark_start(obj);\n+  bool requires_loadref_barriers = has_forwarded_objects() && cast_from_oop<HeapWord*>(obj) < heap_region_containing(obj)->get_update_watermark();\n+  return requires_concmark_barriers || requires_loadref_barriers;\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-  bool requires_barriers(oop obj) const { return true; }\n+  bool requires_barriers(oop obj) const override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}