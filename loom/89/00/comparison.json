{"files":[{"patch":"@@ -2562,8 +2562,0 @@\n-            public int scopeLocalCacheVictims() {\n-                return Thread.scopeLocalCacheVictims();\n-            }\n-\n-            public void setScopeLocalCacheVictims(int victims) {\n-                Thread.setScopeLocalCacheVictims(victims);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -241,12 +241,0 @@\n-    \/\/ A simple (not very) random string of bits to use when evicting\n-    \/\/ cache entries from the scoped variable cache.\n-    private int victims = 0b1100_1001_0000_1111_1101_1010_1010_0010;\n-\n-    static int scopeLocalCacheVictims() {\n-        return currentThread().victims;\n-    }\n-\n-    static void setScopeLocalCacheVictims(int value) {\n-        currentThread().victims = value;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+import jdk.internal.access.JavaUtilThreadLocalRandomAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -408,0 +410,11 @@\n+    static class Access {\n+        static {\n+            SharedSecrets.setJavaUtilThreadLocalRandomAccess\n+                    (new JavaUtilThreadLocalRandomAccess() {\n+                        public int nextSecondaryThreadLocalRandomSeed() {\n+                            return nextSecondarySeed();\n+                        }\n+                    });\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -475,13 +475,0 @@\n-\n-    \/**\n-     * Returns the current thread's \"victims\" field, used to select entries\n-     * from the scope local cache to evict.\n-     *\/\n-    int scopeLocalCacheVictims();\n-\n-    \/**\n-     * Sets the current thread's \"victims\" field, used to select entries\n-     * from the scope local cache to evict.\n-     *\/\n-    void setScopeLocalCacheVictims(int value);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+    private static JavaUtilThreadLocalRandomAccess javaUtilThreadLocalRandomAccess;\n@@ -102,0 +103,12 @@\n+    public static void setJavaUtilThreadLocalRandomAccess(JavaUtilThreadLocalRandomAccess access) {\n+        javaUtilThreadLocalRandomAccess = access;\n+    }\n+\n+    public static JavaUtilThreadLocalRandomAccess getJavaUtilThreadLocalRandomAccess() {\n+        if (javaUtilThreadLocalRandomAccess == null) {\n+            try {\n+                Class.forName(\"java.util.concurrent.ThreadLocalRandom$Access\", true, null);\n+            } catch (ClassNotFoundException e) {}\n+        }\n+        return javaUtilThreadLocalRandomAccess;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.access.JavaUtilThreadLocalRandomAccess;\n@@ -88,18 +89,0 @@\n- * As an alternative to the lambda expression form used above, {@link ScopeLocal} also supports\n- * a <i>try-with-resources<\/i> form, which looks like this:\n- * <pre>{@code}\n- *   try (var unused = ScopeLocal.where(CREDENTIALS, creds).bind()) {\n- *       :\n- *       Connection connection = connectDatabase();\n- *       :\n- *    }\n- * }<\/pre>\n- *\n- * This try-with-resources version of {@code bind()} is <i>insecure<\/i>: it is up\n- * to the application programmer to make sure that bindings are closed at the\n- * right time, in the right order. While a <i>try-with-resources<\/i> statement is\n- * enough to guarantee this, there is no way to enforce the requirement that\n- * {@link Carrier#bind} is only used in a <i>try-with-resources<\/i> statement.\n- * <p>Also, it is not possible to re-bind an already-bound {@link ScopeLocal}\n- * with this <i>try-with-resources<\/i> binding.<\/p>\n- *\n@@ -133,16 +116,0 @@\n-    \/**\n-     * The interface for a ScopeLocal try-with-resources binding.\n-     * @since 19\n-     *\/\n-    public sealed interface Binder extends AutoCloseable permits BinderImpl {\n-\n-        \/**\n-         * Closes this {@link ScopeLocal} binding. If this binding was not the most recent binding\n-         * created by {@code #Carrier.bind}, throws a {@link StructureViolationException}.\n-         * This method is invoked automatically on objects managed by the try-with-resources statement.\n-         *\n-         * @throws StructureViolationException if the bindings were not closed in the correct order.\n-         *\/\n-        public void close();\n-    }\n-\n@@ -389,93 +356,0 @@\n-\n-        \/**\n-         * Create a try-with-resources ScopeLocal binding to be used within\n-         * a try-with-resources block.\n-         * <p>If any of the {@link ScopeLocal}s bound in this {@link Carrier} are already bound in an outer context,\n-         * throw a {@link RuntimeException}.<\/p>\n-         * @return a {@link ScopeLocal.Binder}.\n-         *\n-         * @implNote Using try-with-resources in this way is more expensive than\n-         * using, for example, {@link Carrier#run} (or {@link Carrier#call})\n-         * because it has to do consistency checking at runtime in order to\n-         * ensure that scope locals are used in a correctly-nested way. Also,\n-         * it's necessary to search for existing bindings, so it can fail at\n-         * runtime. For those reasons, if your application can use {@link\n-         * Carrier#run}, it will probably perform better as well as being more\n-         * secure.\n-         *\/\n-        public ScopeLocal.Binder bind() {\n-            checkNotBound();\n-            return (Binder)new BinderImpl(this).push();\n-        }\n-    }\n-\n-    \/**\n-     * An @AutoCloseable that's used to bind a {@code ScopeLocal} in a try-with-resources construct.\n-     *\/\n-    static final class BinderImpl\n-            extends ScopeLocalContainer implements ScopeLocal.Binder {\n-        final Carrier bindings;\n-        final int bitmask;\n-        final BinderImpl prevBinder;\n-        private boolean closed;\n-\n-        BinderImpl(Carrier bindings) {\n-            super();\n-            this.bindings = bindings;\n-            this.prevBinder = innermostBinder();\n-            this.bitmask = bindings.bitmask\n-                    | (prevBinder == null ? 0 : prevBinder.bitmask);\n-        }\n-\n-        static BinderImpl innermostBinder() {\n-            return ScopeLocalContainer.latest(BinderImpl.class);\n-        }\n-\n-        \/**\n-         * Close a scope local binding context.\n-         *\n-         * @throws StructureViolationException if {@code this} isn't the current top binding\n-         * @throws WrongThreadException if the current thread is not the owner\n-         *\/\n-        public void close() throws RuntimeException {\n-            if (Thread.currentThread() != owner())\n-                throw new WrongThreadException();\n-            if (!closed) {\n-                Cache.invalidate(bindings.bitmask);\n-                if (!popForcefully()) {\n-                    setScopeLocalCache(null); \/\/ Cache.invalidate();\n-                    closed = true;\n-                    throw new StructureViolationException();\n-                }\n-                closed = true;\n-            }\n-        }\n-\n-        protected boolean tryClose() {\n-            assert Thread.currentThread() == owner();\n-            if (!closed) {\n-                closed = true;\n-                Cache.invalidate(bindings.bitmask);\n-                return true;\n-            } else {\n-                assert false : \"Should not get there\";\n-                return false;\n-            }\n-        }\n-\n-        static Object find(ScopeLocal<?> key) {\n-            int bits = key.bitmask();\n-            for (BinderImpl b = innermostBinder();\n-                 b != null && containsAll(b.bitmask, bits);\n-                 b = b.prevBinder) {\n-                for (Carrier carrier = b.bindings;\n-                     carrier != null && containsAll(carrier.bitmask, bits);\n-                     carrier = carrier.prev) {\n-                    if (carrier.getKey() == key) {\n-                        Object value = carrier.get();\n-                        return value;\n-                    }\n-                }\n-            }\n-            return Snapshot.NIL;\n-        }\n@@ -499,22 +373,0 @@\n-\n-    \/**\n-     * Create a try-with-resources ScopeLocal binding to be used within\n-     * a try-with-resources block.\n-     * <p>If this {@link ScopeLocal} is already bound in an outer context,\n-     * throw a {@link RuntimeException}.<\/p>\n-     * @param t The value to bind this to\n-     * @return a {@link ScopeLocal.Binder}.\n-     *\n-     * @implNote Using try-with-resources in this way is more expensive than\n-     * using, for example, {@link Carrier#run} (or {@link Carrier#call})\n-     * because it has to do consistency checking at runtime in order to\n-     * ensure that scope locals are used in a correctly-nested way. Also,\n-     * it's necessary to search for existing bindings, so it can fail at\n-     * runtime. For those reasons, if your application can use {@link\n-     * Carrier#run}, it will probably perform better as well as being more\n-     * secure.\n-     *\/\n-    public ScopeLocal.Binder bind(T t) {\n-        return where(this, t).bind();\n-    }\n-\n@@ -620,4 +472,1 @@\n-        if (value != Snapshot.NIL) {\n-            return value;\n-        }\n-        return BinderImpl.find(this);\n+        return value;\n@@ -795,0 +644,3 @@\n+        private static final JavaUtilThreadLocalRandomAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilThreadLocalRandomAccess();\n+\n@@ -800,6 +652,2 @@\n-            int tmp = JLA.scopeLocalCacheVictims();\n-            tmp ^= tmp << 13;\n-            tmp ^= tmp >>> 17;\n-            tmp ^= tmp << 5;\n-            JLA.setScopeLocalCacheVictims(tmp);\n-            return (tmp & 15) >= 5;\n+            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            return (r & 15) >= 5;\n@@ -808,1 +656,1 @@\n-        @ReservedStackAccess\n+        @ReservedStackAccess @DontInline\n@@ -814,1 +662,1 @@\n-        @ReservedStackAccess\n+        @ReservedStackAccess @DontInline\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ScopeLocal.java","additions":9,"deletions":161,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -38,0 +38,3 @@\n+\n+import org.testng.TestListenerAdapter;\n+import org.testng.TestNG;\n@@ -39,0 +42,2 @@\n+import org.testng.xml.XmlSuite;\n+\n@@ -44,0 +49,9 @@\n+    public static void main(String[] args) {\n+        TestListenerAdapter tla = new TestListenerAdapter();\n+        TestNG testNG = new TestNG();\n+        testNG.setParallel(XmlSuite.ParallelMode.METHODS);\n+        testNG.setTestClasses(new Class[] { Basic.class });\n+        testNG.addListener(tla);\n+        testNG.run();\n+    }\n+\n@@ -192,168 +206,0 @@\n-\n-    \/**\n-     * Basic test of bind method.\n-     *\/\n-    public void testTryWithResources1() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        try (var binding = ScopeLocal.where(name, \"x\").bind()) {\n-            assertEquals(name.get(), \"x\");\n-\n-            \/\/ re-bind should fail\n-            expectThrows(RuntimeException.class, () -> ScopeLocal.where(name, \"y\").bind());\n-            expectThrows(RuntimeException.class, () -> name.bind(\"y\"));\n-\n-            assertEquals(name.get(), \"x\");\n-        }\n-        assertFalse(name.isBound());\n-    }\n-\n-    \/**\n-     * Basic test of bind method with nested bindings.\n-     *\/\n-    public void testTryWithResources2() {\n-        ScopeLocal<String> name1 = ScopeLocal.newInstance();\n-        ScopeLocal<String> name2 = ScopeLocal.newInstance();\n-        try (var binding1 = ScopeLocal.where(name1, \"x\").bind()) {\n-            assertEquals(name1.get(), \"x\");\n-            assertFalse(name2.isBound());\n-\n-            try (var binding2 = ScopeLocal.where(name2, \"y\").bind()) {\n-                assertEquals(name1.get(), \"x\");\n-                assertEquals(name2.get(), \"y\");\n-            }\n-\n-            assertEquals(name1.get(), \"x\");\n-            assertFalse(name2.isBound());\n-        }\n-        assertFalse(name1.isBound());\n-    }\n-\n-    \/**\n-     * Basic test of re-binding after bind.\n-     *\/\n-    public void testTryWithResources3() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        try (var binding = ScopeLocal.where(name, \"x\").bind()) {\n-            assertEquals(name.get(), \"x\");\n-\n-            \/\/ re-bind\n-            ScopeLocal.where(name, \"y\").run(() -> {\n-                assertEquals(name.get(), \"y\");\n-            });\n-\n-            assertEquals(name.get(), \"x\");\n-        }\n-        assertFalse(name.isBound());\n-    }\n-\n-    \/**\n-     * Basic test that bind cannot re-bind.\n-     *\/\n-    public void testTryWithResources4() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        ScopeLocal.where(name, \"x\").run(() -> {\n-            assertEquals(name.get(), \"x\");\n-\n-            \/\/ re-bind should fail\n-            expectThrows(RuntimeException.class, () -> ScopeLocal.where(name, \"y\").bind());\n-            expectThrows(RuntimeException.class, () -> name.bind(\"y\"));\n-\n-            assertEquals(name.get(), \"x\");\n-        });\n-        assertFalse(name.isBound());\n-    }\n-\n-    \/**\n-     * Basic test that the shorthand form of bind works.\n-     *\/\n-    public void testTryWithResources5() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        try (var binding = name.bind(\"x\")) {\n-            assertEquals(name.get(), \"x\");\n-\n-            \/\/ re-bind should fail\n-            expectThrows(RuntimeException.class, () -> ScopeLocal.where(name, \"y\").bind());\n-\n-            assertEquals(name.get(), \"x\");\n-        }\n-        assertFalse(name.isBound());\n-    }\n-\n-    \/**\n-     * Test closing enclosing binder, should close nested binder.\n-     *\/\n-    public void testStructureViolation1() {\n-        ScopeLocal<String> NAME1 = ScopeLocal.newInstance();\n-        ScopeLocal<String> NAME2 = ScopeLocal.newInstance();\n-        try (var binding1 = ScopeLocal.where(NAME1, \"x\").bind()) {\n-            try (var binding2 = ScopeLocal.where(NAME2, \"y\").bind()) {\n-                expectThrows(StructureViolationException.class, binding1::close);\n-\n-                \/\/ binding1 and binding2 should be removed\n-                assertFalse(NAME1.isBound());\n-                assertFalse(NAME2.isBound());\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test closing enclosing binder, should not disrupt nested binding\n-     * when running an op.\n-     *\/\n-    public void testStructureViolation2() {\n-        ScopeLocal<String> NAME = ScopeLocal.newInstance();\n-        try (var binding = ScopeLocal.where(NAME, \"x\").bind()) {\n-            ScopeLocal.where(NAME, \"y\").run(() -> {\n-                expectThrows(StructureViolationException.class, binding::close);\n-                assertEquals(NAME.get(), \"y\");\n-            });\n-            assertFalse(NAME.isBound());\n-        }\n-    }\n-\n-    \/**\n-     * Test that close is idempotent.\n-     *\/\n-    public void testCloseIsIdempotent() {\n-        ScopeLocal<String> NAME1 = ScopeLocal.newInstance();\n-        ScopeLocal<String> NAME2 = ScopeLocal.newInstance();\n-        try (var binding1 = ScopeLocal.where(NAME1, \"x\").bind()) {\n-            try (var binding2 = ScopeLocal.where(NAME2, \"y\").bind()) {\n-\n-                assertTrue(NAME1.isBound());\n-                assertTrue(NAME2.isBound());\n-\n-                \/\/ call binding2::close several times.\n-                for (int i = 0; i < 3; i++) {\n-                    binding2.close();\n-                    assertTrue(NAME1.isBound());\n-                    assertFalse(NAME2.isBound());\n-                }\n-\n-                \/\/ call binding1::close several times.\n-                for (int i = 0; i < 3; i++) {\n-                    binding1.close();\n-                    assertFalse(NAME1.isBound());\n-                    assertFalse(NAME2.isBound());\n-                }\n-\n-                \/\/ call binding2::close again, should not throw\n-                binding2.close();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test that WrongThreadException if close is invoked by a thread other than the owner.\n-     *\/\n-    public void testCloseConfined() {\n-        ScopeLocal<String> NAME = ScopeLocal.newInstance();\n-        try (var binding = ScopeLocal.where(NAME, \"x\").bind();\n-             var executor = Executors.newFixedThreadPool(1)) {\n-\n-            \/\/ attempt to close binding from wrong thread\n-            Future<?> future = executor.submit(binding::close);\n-            Throwable ex = expectThrows(ExecutionException.class, future::get);\n-            assertTrue(ex.getCause() instanceof WrongThreadException);\n-        }\n-    }\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopeLocal\/Basic.java","additions":14,"deletions":168,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, red Hat, Inc. All rights reserved.\n@@ -43,1 +43,1 @@\n-      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.java.lang.ScopeLocalsExecutorService\",\n+      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ScopeLocalsExecutorService\",\n@@ -149,9 +149,0 @@\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    @SuppressWarnings(\"try\")\n-    public Object TWR_bind_ScopeLocal() throws Exception {\n-        try (var x = ScopeLocal.where(unbound, THE_ANSWER).bind()) {\n-            return getClass();\n-        }\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopeLocals.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"}]}