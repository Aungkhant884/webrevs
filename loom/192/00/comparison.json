{"files":[{"patch":"@@ -35,1 +35,1 @@\n-JVM_FindExtentLocalBindings\n+JVM_FindScopedValueBindings\n","filename":"make\/data\/hotspot-symbols\/symbols-shared","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -197,2 +197,2 @@\n-JVM_ExtentLocalCache\n-JVM_SetExtentLocalCache\n+JVM_ScopedValueCache\n+JVM_SetScopedValueCache\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1431,2 +1431,2 @@\n-void LIRGenerator::do_extentLocalCache(Intrinsic* x) {\n-  do_JavaThreadField(x, JavaThread::extentLocalCache_offset());\n+void LIRGenerator::do_scopedValueCache(Intrinsic* x) {\n+  do_JavaThreadField(x, JavaThread::scopedValueCache_offset());\n@@ -2951,1 +2951,1 @@\n-  case vmIntrinsics::_extentLocalCache: do_extentLocalCache(x); break;\n+  case vmIntrinsics::_scopedValueCache: do_scopedValueCache(x); break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  void do_extentLocalCache(Intrinsic* x);\n+  void do_scopedValueCache(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1743,1 +1743,1 @@\n-int java_lang_Thread::_extentLocalBindings_offset;\n+int java_lang_Thread::_scopedValueBindings_offset;\n@@ -1756,1 +1756,1 @@\n-  macro(_extentLocalBindings_offset, k, \"extentLocalBindings\", object_signature, false);\n+  macro(_scopedValueBindings_offset, k, \"scopedValueBindings\", object_signature, false);\n@@ -1789,1 +1789,1 @@\n-void java_lang_Thread::clear_extentLocalBindings(oop java_thread) {\n+void java_lang_Thread::clear_scopedValueBindings(oop java_thread) {\n@@ -1791,1 +1791,1 @@\n-    java_thread->obj_field_put(_extentLocalBindings_offset, NULL);\n+    java_thread->obj_field_put(_scopedValueBindings_offset, NULL);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-  static int _extentLocalBindings_offset;\n+  static int _scopedValueBindings_offset;\n@@ -403,2 +403,2 @@\n-  \/\/ Clear all extent local bindings on error\n-  static void clear_extentLocalBindings(oop java_thread);\n+  \/\/ Clear all scoped value bindings on error\n+  static void clear_scopedValueBindings(oop java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n@@ -130,2 +130,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n@@ -268,2 +268,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -289,8 +289,8 @@\n-  do_intrinsic(_extentLocalCache,         java_lang_Thread,       extentLocalCache_name, extentLocalCache_signature, F_SN) \\\n-   do_name(     extentLocalCache_name,                           \"extentLocalCache\")                                    \\\n-   do_signature(extentLocalCache_signature,                      \"()[Ljava\/lang\/Object;\")                               \\\n-  do_intrinsic(_setExtentLocalCache,      java_lang_Thread,       setExtentLocalCache_name, setExtentLocalCache_signature, F_SN) \\\n-   do_name(     setExtentLocalCache_name,                        \"setExtentLocalCache\")                                 \\\n-   do_signature(setExtentLocalCache_signature,                   \"([Ljava\/lang\/Object;)V\")                              \\\n-  do_intrinsic(_findExtentLocalBindings,  java_lang_Thread,       findExtentLocalBindings_name, void_object_signature, F_SN) \\\n-   do_name(     findExtentLocalBindings_name,                    \"findExtentLocalBindings\")                             \\\n+  do_intrinsic(_scopedValueCache,         java_lang_Thread,       scopedValueCache_name, scopedValueCache_signature, F_SN) \\\n+   do_name(     scopedValueCache_name,                           \"scopedValueCache\")                                    \\\n+   do_signature(scopedValueCache_signature,                      \"()[Ljava\/lang\/Object;\")                               \\\n+  do_intrinsic(_setScopedValueCache,      java_lang_Thread,       setScopedValueCache_name, setScopedValueCache_signature, F_SN) \\\n+   do_name(     setScopedValueCache_name,                        \"setScopedValueCache\")                                 \\\n+   do_signature(setScopedValueCache_signature,                   \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_findScopedValueBindings,  java_lang_Thread,       findScopedValueBindings_name, void_object_signature, F_SN) \\\n+   do_name(     findScopedValueBindings_name,                    \"findScopedValueBindings\")                             \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -159,2 +159,2 @@\n-  template(jdk_incubator_concurrent_ExtentLocal,      \"jdk\/incubator\/concurrent\/ExtentLocal\")     \\\n-  template(jdk_incubator_concurrent_ExtentLocal_Carrier, \"jdk\/incubator\/concurrent\/ExtentLocal$Carrier\") \\\n+  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n+  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -313,1 +313,1 @@\n-JVM_ExtentLocalCache(JNIEnv *env, jclass threadClass);\n+JVM_ScopedValueCache(JNIEnv *env, jclass threadClass);\n@@ -316,1 +316,1 @@\n-JVM_SetExtentLocalCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+JVM_SetScopedValueCache(JNIEnv *env, jclass threadClass, jobject theCache);\n@@ -319,1 +319,1 @@\n-JVM_FindExtentLocalBindings(JNIEnv *env, jclass threadClass);\n+JVM_FindScopedValueBindings(JNIEnv *env, jclass threadClass);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -374,4 +374,4 @@\n-  \/\/ Remove the ExtentLocal cache in case we got a StackOverflowError\n-  \/\/ while we were trying to remove ExtentLocal bindings.\n-  current->set_extentLocalCache(NULL);\n-  \/\/ And the ExtentLocal bindings too.\n+  \/\/ Remove the ScopedValue cache in case we got a StackOverflowError\n+  \/\/ while we were trying to remove ScopedValue bindings.\n+  current->set_scopedValueCache(NULL);\n+  \/\/ And the ScopedValue bindings too.\n@@ -379,1 +379,1 @@\n-  java_lang_Thread::clear_extentLocalBindings(threadObj);\n+  java_lang_Thread::clear_scopedValueBindings(threadObj);\n@@ -391,4 +391,4 @@\n-  \/\/ Remove the ExtentLocal cache in case we got a StackOverflowError\n-  \/\/ while we were trying to remove ExtentLocal bindings.\n-  current->set_extentLocalCache(NULL);\n-  \/\/ And the ExtentLocal bindings too.\n+  \/\/ Remove the ScopedValue cache in case we got a StackOverflowError\n+  \/\/ while we were trying to remove ScopedValue bindings.\n+  current->set_scopedValueCache(NULL);\n+  \/\/ And the ScopedValue bindings too.\n@@ -396,1 +396,1 @@\n-  java_lang_Thread::clear_extentLocalBindings(threadObj);\n+  java_lang_Thread::clear_scopedValueBindings(threadObj);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1602,1 +1602,1 @@\n-    GrowableArray<ScopeValue*>* extentLocals = cvf->scope()->locals();\n+    GrowableArray<ScopeValue*>* scopedValues = cvf->scope()->locals();\n@@ -1607,1 +1607,1 @@\n-        if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+        if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -683,2 +683,2 @@\n-  case vmIntrinsics::_extentLocalCache:\n-  case vmIntrinsics::_setExtentLocalCache:\n+  case vmIntrinsics::_scopedValueCache:\n+  case vmIntrinsics::_setScopedValueCache:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -475,2 +475,2 @@\n-  case vmIntrinsics::_extentLocalCache:          return inline_native_extentLocalCache();\n-  case vmIntrinsics::_setExtentLocalCache:       return inline_native_setExtentLocalCache();\n+  case vmIntrinsics::_scopedValueCache:          return inline_native_scopedValueCache();\n+  case vmIntrinsics::_setScopedValueCache:       return inline_native_setScopedValueCache();\n@@ -3359,1 +3359,1 @@\n-Node* LibraryCallKit::extentLocalCache_helper() {\n+Node* LibraryCallKit::scopedValueCache_helper() {\n@@ -3366,1 +3366,1 @@\n-  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::extentLocalCache_offset()));\n+  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::scopedValueCache_offset()));\n@@ -3375,2 +3375,2 @@\n-\/\/------------------------inline_native_extentLocalCache------------------\n-bool LibraryCallKit::inline_native_extentLocalCache() {\n+\/\/------------------------inline_native_scopedValueCache------------------\n+bool LibraryCallKit::inline_native_scopedValueCache() {\n@@ -3381,1 +3381,1 @@\n-  \/\/ Because we create the extentLocal cache lazily we have to make the\n+  \/\/ Because we create the scopedValue cache lazily we have to make the\n@@ -3385,1 +3385,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n@@ -3391,2 +3391,2 @@\n-\/\/------------------------inline_native_setExtentLocalCache------------------\n-bool LibraryCallKit::inline_native_setExtentLocalCache() {\n+\/\/------------------------inline_native_setScopedValueCache------------------\n+bool LibraryCallKit::inline_native_setScopedValueCache() {\n@@ -3394,1 +3394,1 @@\n-  Node* cache_obj_handle = extentLocalCache_helper();\n+  Node* cache_obj_handle = scopedValueCache_helper();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -242,3 +242,3 @@\n-  bool inline_native_extentLocalCache();\n-  Node* extentLocalCache_helper();\n-  bool inline_native_setExtentLocalCache();\n+  bool inline_native_scopedValueCache();\n+  Node* scopedValueCache_helper();\n+  bool inline_native_setScopedValueCache();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -868,1 +868,1 @@\n-      in_bytes(JavaThread::extentLocalCache_offset()),\n+      in_bytes(JavaThread::scopedValueCache_offset()),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1366,1 +1366,1 @@\n-class ExtentLocalBindingsResolver {\n+class ScopedValueBindingsResolver {\n@@ -1372,2 +1372,2 @@\n-  ExtentLocalBindingsResolver(JavaThread* THREAD) {\n-    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_incubator_concurrent_ExtentLocal_Carrier(), true, THREAD);\n+  ScopedValueBindingsResolver(JavaThread* THREAD) {\n+    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_incubator_concurrent_ScopedValue_Carrier(), true, THREAD);\n@@ -1386,1 +1386,1 @@\n-JVM_ENTRY(jobject, JVM_FindExtentLocalBindings(JNIEnv *env, jclass cls))\n+JVM_ENTRY(jobject, JVM_FindScopedValueBindings(JNIEnv *env, jclass cls))\n@@ -1393,1 +1393,1 @@\n-  static ExtentLocalBindingsResolver resolver(THREAD);\n+  static ScopedValueBindingsResolver resolver(THREAD);\n@@ -1416,1 +1416,1 @@\n-      StackValue* head_sv = locals->at(loc); \/\/ jdk\/incubator\/concurrent\/ExtentLocal$Snapshot\n+      StackValue* head_sv = locals->at(loc); \/\/ jdk\/incubator\/concurrent\/ScopedValue$Snapshot\n@@ -3178,2 +3178,2 @@\n-JVM_ENTRY(jobject, JVM_ExtentLocalCache(JNIEnv* env, jclass threadClass))\n-  oop theCache = thread->extentLocalCache();\n+JVM_ENTRY(jobject, JVM_ScopedValueCache(JNIEnv* env, jclass threadClass))\n+  oop theCache = thread->scopedValueCache();\n@@ -3183,1 +3183,1 @@\n-JVM_ENTRY(void, JVM_SetExtentLocalCache(JNIEnv* env, jclass threadClass,\n+JVM_ENTRY(void, JVM_SetScopedValueCache(JNIEnv* env, jclass threadClass,\n@@ -3186,1 +3186,1 @@\n-  thread->set_extentLocalCache(objs);\n+  thread->set_scopedValueCache(objs);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -457,1 +457,1 @@\n-    \/\/ FIXME: This very crudely destroys all ExtentLocal bindings. This\n+    \/\/ FIXME: This very crudely destroys all ScopedValue bindings. This\n@@ -460,2 +460,2 @@\n-    current->set_extentLocalCache(NULL);\n-    java_lang_Thread::clear_extentLocalBindings(java_thread);\n+    current->set_scopedValueCache(NULL);\n+    java_lang_Thread::clear_scopedValueBindings(java_thread);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-  _extentLocalCache = OopHandle(_thread_oop_storage, NULL);\n+  _scopedValueCache = OopHandle(_thread_oop_storage, NULL);\n@@ -189,2 +189,2 @@\n-oop JavaThread::extentLocalCache() const {\n-  return _extentLocalCache.resolve();\n+oop JavaThread::scopedValueCache() const {\n+  return _scopedValueCache.resolve();\n@@ -193,3 +193,3 @@\n-void JavaThread::set_extentLocalCache(oop p) {\n-  if (_extentLocalCache.ptr_raw() != NULL) { \/\/ i.e. if the OopHandle has been allocated\n-    _extentLocalCache.replace(p);\n+void JavaThread::set_scopedValueCache(oop p) {\n+  if (_scopedValueCache.ptr_raw() != NULL) { \/\/ i.e. if the OopHandle has been allocated\n+    _scopedValueCache.replace(p);\n@@ -1073,2 +1073,2 @@\n-  \/\/ Clear any extent-local bindings\n-  set_extentLocalCache(NULL);\n+  \/\/ Clear any scoped-value bindings\n+  set_scopedValueCache(NULL);\n@@ -1077,1 +1077,1 @@\n-  java_lang_Thread::clear_extentLocalBindings(threadOop);\n+  java_lang_Thread::clear_scopedValueBindings(threadOop);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  OopHandle      _extentLocalCache;\n+  OopHandle      _scopedValueCache;\n@@ -467,1 +467,1 @@\n-  jlong _extentLocal_hash_table_shift;\n+  jlong _scopedValue_hash_table_shift;\n@@ -469,1 +469,1 @@\n-  void allocate_extentLocal_hash_table(int count);\n+  void allocate_scopedValue_hash_table(int count);\n@@ -523,2 +523,2 @@\n-  oop extentLocalCache() const;\n-  void set_extentLocalCache(oop p);\n+  oop scopedValueCache() const;\n+  void set_scopedValueCache(oop p);\n@@ -755,1 +755,1 @@\n-  static ByteSize extentLocalCache_offset()       { return byte_offset_of(JavaThread, _extentLocalCache); }\n+  static ByteSize scopedValueCache_offset()       { return byte_offset_of(JavaThread, _scopedValueCache); }\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -889,4 +889,4 @@\n-  \/\/ Remove the ExtentLocal cache in case we got a StackOverflowError\n-  \/\/ while we were trying to remove ExtentLocal bindings.\n-  current->set_extentLocalCache(NULL);\n-  \/\/ And the ExtentLocal bindings too.\n+  \/\/ Remove the ScopedValue cache in case we got a StackOverflowError\n+  \/\/ while we were trying to remove ScopedValue bindings.\n+  current->set_scopedValueCache(NULL);\n+  \/\/ And the ScopedValue bindings too.\n@@ -894,1 +894,1 @@\n-  java_lang_Thread::clear_extentLocalBindings(threadObj);\n+  java_lang_Thread::clear_scopedValueBindings(threadObj);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  GrowableArray<ScopeValue*>* extentLocals = scope()->locals();\n+  GrowableArray<ScopeValue*>* scopedValues = scope()->locals();\n@@ -153,1 +153,1 @@\n-      if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+      if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -713,1 +713,1 @@\n-  nonstatic_field(JavaThread,                  _extentLocalCache,                              OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                              OopHandle)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,4 +164,4 @@\n-    \/\/ Remove the ExtentLocal cache in case we got a virtual machine\n-    \/\/ Error while we were trying to manipulate ExtentLocal bindings.\n-    thread->set_extentLocalCache(NULL);\n-    \/\/ And the ExtentLocal bindings too.\n+    \/\/ Remove the ScopedValue cache in case we got a virtual machine\n+    \/\/ Error while we were trying to manipulate ScopedValue bindings.\n+    thread->set_scopedValueCache(NULL);\n+    \/\/ And the ScopedValue bindings too.\n@@ -169,1 +169,1 @@\n-    java_lang_Thread::clear_extentLocalBindings(threadObj);\n+    java_lang_Thread::clear_scopedValueBindings(threadObj);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2577,2 +2577,2 @@\n-            public Object[] extentLocalCache() {\n-                return Thread.extentLocalCache();\n+            public Object[] scopedValueCache() {\n+                return Thread.scopedValueCache();\n@@ -2581,2 +2581,2 @@\n-            public void setExtentLocalCache(Object[] cache) {\n-                Thread.setExtentLocalCache(cache);\n+            public void setScopedValueCache(Object[] cache) {\n+                Thread.setScopedValueCache(cache);\n@@ -2585,2 +2585,2 @@\n-            public Object extentLocalBindings() {\n-                return Thread.extentLocalBindings();\n+            public Object scopedValueBindings() {\n+                return Thread.scopedValueBindings();\n@@ -2589,2 +2589,2 @@\n-            public Object findExtentLocalBindings() {\n-                return Thread.findExtentLocalBindings();\n+            public Object findScopedValueBindings() {\n+                return Thread.findScopedValueBindings();\n@@ -2593,2 +2593,2 @@\n-            public void setExtentLocalBindings(Object bindings) {\n-                Thread.setExtentLocalBindings(bindings);\n+            public void setScopedValueBindings(Object bindings) {\n+                Thread.setScopedValueBindings(bindings);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-import jdk.internal.vm.ExtentLocalContainer;\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -282,1 +282,1 @@\n-     * Extent locals binding are maintained by the ExtentLocal class.\n+     * Scoped values binding are maintained by the ScopedValue class.\n@@ -284,1 +284,1 @@\n-    private Object extentLocalBindings;\n+    private Object scopedValueBindings;\n@@ -286,2 +286,2 @@\n-    static Object extentLocalBindings() {\n-        return currentThread().extentLocalBindings;\n+    static Object scopedValueBindings() {\n+        return currentThread().scopedValueBindings;\n@@ -290,2 +290,2 @@\n-    static void setExtentLocalBindings(Object bindings) {\n-        currentThread().extentLocalBindings = bindings;\n+    static void setScopedValueBindings(Object bindings) {\n+        currentThread().scopedValueBindings = bindings;\n@@ -295,1 +295,1 @@\n-     * Search the stack for the most recent extent-local bindings.\n+     * Search the stack for the most recent scoped-value bindings.\n@@ -298,1 +298,1 @@\n-    static native Object findExtentLocalBindings();\n+    static native Object findScopedValueBindings();\n@@ -301,1 +301,1 @@\n-     * Inherit the extent-local bindings from the given container.\n+     * Inherit the scoped-value bindings from the given container.\n@@ -304,2 +304,2 @@\n-    void inheritExtentLocalBindings(ThreadContainer container) {\n-        ExtentLocalContainer.BindingsSnapshot snapshot;\n+    void inheritScopedValueBindings(ThreadContainer container) {\n+        ScopedValueContainer.BindingsSnapshot snapshot;\n@@ -307,1 +307,1 @@\n-                && (snapshot = container.extentLocalBindings()) != null) {\n+                && (snapshot = container.scopedValueBindings()) != null) {\n@@ -310,3 +310,3 @@\n-            Object bindings = snapshot.extentLocalBindings();\n-            if (currentThread().extentLocalBindings != bindings) {\n-                StructureViolationExceptions.throwException(\"Extent local bindings have changed\");\n+            Object bindings = snapshot.scopedValueBindings();\n+            if (currentThread().scopedValueBindings != bindings) {\n+                StructureViolationExceptions.throwException(\"Scoped value bindings have changed\");\n@@ -315,1 +315,1 @@\n-            this.extentLocalBindings = bindings;\n+            this.scopedValueBindings = bindings;\n@@ -402,1 +402,1 @@\n-    \/\/ ExtentLocal support:\n+    \/\/ ScopedValue support:\n@@ -405,1 +405,1 @@\n-    static native Object[] extentLocalCache();\n+    static native Object[] scopedValueCache();\n@@ -408,1 +408,1 @@\n-    static native void setExtentLocalCache(Object[] cache);\n+    static native void setScopedValueCache(Object[] cache);\n@@ -742,1 +742,1 @@\n-        this.extentLocalBindings = Thread.class;\n+        this.scopedValueBindings = Thread.class;\n@@ -783,1 +783,1 @@\n-        this.extentLocalBindings = Thread.class;\n+        this.scopedValueBindings = Thread.class;\n@@ -1575,2 +1575,2 @@\n-                \/\/ extent locals may be inherited\n-                inheritExtentLocalBindings(container);\n+                \/\/ scoped values may be inherited\n+                inheritScopedValueBindings(container);\n@@ -1607,1 +1607,1 @@\n-            Object bindings = extentLocalBindings();\n+            Object bindings = scopedValueBindings();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-        Object bindings = extentLocalBindings();\n+        Object bindings = scopedValueBindings();\n@@ -495,2 +495,2 @@\n-            \/\/ extent locals may be inherited\n-            inheritExtentLocalBindings(container);\n+            \/\/ scoped values may be inherited\n+            inheritScopedValueBindings(container);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -404,1 +404,1 @@\n-    \/\/ used by ExtentLocal\n+    \/\/ used by ScopedValue\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-     * Returns the current thread's extent locals cache\n+     * Returns the current thread's scoped values cache\n@@ -480,1 +480,1 @@\n-    Object[] extentLocalCache();\n+    Object[] scopedValueCache();\n@@ -483,1 +483,1 @@\n-     * Sets the current thread's extent locals cache\n+     * Sets the current thread's scoped values cache\n@@ -485,1 +485,1 @@\n-    void setExtentLocalCache(Object[] cache);\n+    void setScopedValueCache(Object[] cache);\n@@ -488,1 +488,1 @@\n-     * Return the current thread's extent local bindings.\n+     * Return the current thread's scoped value bindings.\n@@ -490,1 +490,1 @@\n-    Object extentLocalBindings();\n+    Object scopedValueBindings();\n@@ -493,1 +493,1 @@\n-     * Set the current thread's extent local bindings.\n+     * Set the current thread's scoped value bindings.\n@@ -495,1 +495,1 @@\n-    void setExtentLocalBindings(Object bindings);\n+    void setScopedValueBindings(Object bindings);\n@@ -497,1 +497,1 @@\n-    Object findExtentLocalBindings();\n+    Object findScopedValueBindings();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.internal.vm.ExtentLocalContainer;\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -102,1 +102,1 @@\n-    private final ExtentLocalContainer.BindingsSnapshot extentLocalBindings;\n+    private final ScopedValueContainer.BindingsSnapshot scopedValueBindings;\n@@ -114,1 +114,1 @@\n-        this.extentLocalBindings = ExtentLocalContainer.captureBindings();\n+        this.scopedValueBindings = ScopedValueContainer.captureBindings();\n@@ -122,2 +122,2 @@\n-    private ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n-        return extentLocalBindings;\n+    private ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n+        return scopedValueBindings;\n@@ -213,1 +213,1 @@\n-     * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n+     * <p> This method captures the current thread's {@linkplain ScopedValue scoped-value}\n@@ -253,1 +253,1 @@\n-     * <p> The thread is started with the extent-local bindings that were captured\n+     * <p> The thread is started with the scoped-value bindings that were captured\n@@ -266,1 +266,1 @@\n-     * extent-local bindings are not the same as when the flock was created\n+     * scoped-value bindings are not the same as when the flock was created\n@@ -404,2 +404,2 @@\n-     * jdk.incubator.concurrent.ExtentLocal.Carrier#run(Runnable) operations} with\n-     * extent-local bindings then it also throws {@code StructureViolationException}\n+     * jdk.incubator.concurrent.ScopedValue.Carrier#run(Runnable) operations} with\n+     * scoped-value bindings then it also throws {@code StructureViolationException}\n@@ -588,2 +588,2 @@\n-        public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n-            return flock.extentLocalBindings();\n+        public ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n+            return flock.scopedValueBindings();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private static final boolean PRESERVE_EXTENT_LOCAL_CACHE;\n+    private static final boolean PRESERVE_SCOPED_VALUE_CACHE;\n@@ -57,2 +57,2 @@\n-        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveExtentLocalCache\");\n-        PRESERVE_EXTENT_LOCAL_CACHE = (value == null) || Boolean.parseBoolean(value);\n+        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveScopedValueCache\");\n+        PRESERVE_SCOPED_VALUE_CACHE = (value == null) || Boolean.parseBoolean(value);\n@@ -132,1 +132,1 @@\n-    private Object[] extentLocalCache;\n+    private Object[] scopedValueCache;\n@@ -241,1 +241,1 @@\n-            JLA.setExtentLocalCache(extentLocalCache);\n+            JLA.setScopedValueCache(scopedValueCache);\n@@ -273,2 +273,2 @@\n-                    if (PRESERVE_EXTENT_LOCAL_CACHE) {\n-                        extentLocalCache = JLA.extentLocalCache();\n+                    if (PRESERVE_SCOPED_VALUE_CACHE) {\n+                        scopedValueCache = JLA.scopedValueCache();\n@@ -276,1 +276,1 @@\n-                        extentLocalCache = null;\n+                        scopedValueCache = null;\n@@ -278,1 +278,1 @@\n-                    JLA.setExtentLocalCache(null);\n+                    JLA.setScopedValueCache(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.vm;\n-\n-import java.util.concurrent.Callable;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.StructureViolationExceptions;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ReservedStackAccess;\n-\n-\/**\n- * A StackableScope to represent extent-local bindings.\n- *\n- * This class defines static methods to run an operation with a ExtentLocalContainer\n- * on the scope stack. It also defines a method to get the latest ExtentLocalContainer\n- * and a method to return a snapshot of the extent local bindings.\n- *\/\n-public class ExtentLocalContainer extends StackableScope {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-    static {\n-        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n-    }\n-\n-    private ExtentLocalContainer() {\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This may be on\n-     * the current thread's scope task or ma require walking up the tree to find it.\n-     *\/\n-    public static <T extends ExtentLocalContainer> T latest(Class<T> containerClass) {\n-        StackableScope scope = head();\n-        if (scope == null) {\n-            scope = JLA.threadContainer(Thread.currentThread());\n-            if (scope == null || scope.owner() == null)\n-                return null;\n-        }\n-        if (containerClass.isInstance(scope)) {\n-            @SuppressWarnings(\"unchecked\")\n-            T tmp = (T) scope;\n-            return tmp;\n-        } else {\n-            return scope.enclosingScope(containerClass);\n-        }\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This\n-     * may be on the current thread's scope task or may require walking up the\n-     * tree to find it.\n-     *\/\n-    public static ExtentLocalContainer latest() {\n-        return latest(ExtentLocalContainer.class);\n-    }\n-\n-    \/**\n-     * A snapshot of the extent local bindings. The snapshot includes the bindings\n-     * established for the current thread and extent local container.\n-     *\/\n-    public record BindingsSnapshot(Object extentLocalBindings,\n-                                   ExtentLocalContainer container) { }\n-\n-    \/**\n-     * Returns the extent local bindings for the current thread.\n-     *\/\n-    public static BindingsSnapshot captureBindings() {\n-        return new BindingsSnapshot(JLA.extentLocalBindings(), latest());\n-    }\n-\n-    \/**\n-     * For use by ExtentLocal to run an operation in a structured context.\n-     *\/\n-    public static void run(Runnable op) {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            runWithoutScope(op);\n-        } else {\n-            new ExtentLocalContainer().doRun(op);\n-        }\n-    }\n-\n-    \/**\n-     * Run an operation without a scope on the stack.\n-     *\/\n-    private static void runWithoutScope(Runnable op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();   \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * Run an operation with this scope on the stack.\n-     *\/\n-    private void doRun(Runnable op) {\n-        Throwable ex;\n-        boolean atTop;\n-        push();\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * For use by ExtentLocal to call a value returning operation in a structured context.\n-     *\/\n-    public static <V> V call(Callable<V> op) throws Exception {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            return callWithoutScope(op);\n-        } else {\n-            return new ExtentLocalContainer().doCall(op);\n-        }\n-    }\n-\n-    \/**\n-     * Call an operation without a scope on the stack.\n-     *\/\n-    private static <V> V callWithoutScope(Callable<V> op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Call an operation with this scope on the stack.\n-     *\/\n-    private <V> V doCall(Callable<V> op) {\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        push();\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n-     * as a suppressed exception when {@code atTop} is false.\n-     *\/\n-    @DontInline @ReservedStackAccess\n-    private static void throwIfFailed(Throwable ex, boolean atTop) {\n-        if (ex != null || !atTop) {\n-            if (!atTop) {\n-                var sve = StructureViolationExceptions.newException();\n-                if (ex == null) {\n-                    ex = sve;\n-                } else {\n-                    ex.addSuppressed(sve);\n-                }\n-            }\n-            Unsafe.getUnsafe().throwException(ex);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ExtentLocalContainer.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.util.concurrent.Callable;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.StructureViolationExceptions;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ReservedStackAccess;\n+\n+\/**\n+ * A StackableScope to represent scoped-value bindings.\n+ *\n+ * This class defines static methods to run an operation with a ScopedValueContainer\n+ * on the scope stack. It also defines a method to get the latest ScopedValueContainer\n+ * and a method to return a snapshot of the scoped value bindings.\n+ *\/\n+public class ScopedValueContainer extends StackableScope {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    static {\n+        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n+    }\n+\n+    private ScopedValueContainer() {\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ScopedValueContainer for the current Thread. This may be on\n+     * the current thread's scope task or ma require walking up the tree to find it.\n+     *\/\n+    public static <T extends ScopedValueContainer> T latest(Class<T> containerClass) {\n+        StackableScope scope = head();\n+        if (scope == null) {\n+            scope = JLA.threadContainer(Thread.currentThread());\n+            if (scope == null || scope.owner() == null)\n+                return null;\n+        }\n+        if (containerClass.isInstance(scope)) {\n+            @SuppressWarnings(\"unchecked\")\n+            T tmp = (T) scope;\n+            return tmp;\n+        } else {\n+            return scope.enclosingScope(containerClass);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ScopedValueContainer for the current Thread. This\n+     * may be on the current thread's scope task or may require walking up the\n+     * tree to find it.\n+     *\/\n+    public static ScopedValueContainer latest() {\n+        return latest(ScopedValueContainer.class);\n+    }\n+\n+    \/**\n+     * A snapshot of the scoped value bindings. The snapshot includes the bindings\n+     * established for the current thread and scoped value container.\n+     *\/\n+    public record BindingsSnapshot(Object scopedValueBindings,\n+                                   ScopedValueContainer container) { }\n+\n+    \/**\n+     * Returns the scoped value bindings for the current thread.\n+     *\/\n+    public static BindingsSnapshot captureBindings() {\n+        return new BindingsSnapshot(JLA.scopedValueBindings(), latest());\n+    }\n+\n+    \/**\n+     * For use by ScopedValue to run an operation in a structured context.\n+     *\/\n+    public static void run(Runnable op) {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            runWithoutScope(op);\n+        } else {\n+            new ScopedValueContainer().doRun(op);\n+        }\n+    }\n+\n+    \/**\n+     * Run an operation without a scope on the stack.\n+     *\/\n+    private static void runWithoutScope(Runnable op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();   \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * Run an operation with this scope on the stack.\n+     *\/\n+    private void doRun(Runnable op) {\n+        Throwable ex;\n+        boolean atTop;\n+        push();\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * For use by ScopedValue to call a value returning operation in a structured context.\n+     *\/\n+    public static <V> V call(Callable<V> op) throws Exception {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            return callWithoutScope(op);\n+        } else {\n+            return new ScopedValueContainer().doCall(op);\n+        }\n+    }\n+\n+    \/**\n+     * Call an operation without a scope on the stack.\n+     *\/\n+    private static <V> V callWithoutScope(Callable<V> op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Call an operation with this scope on the stack.\n+     *\/\n+    private <V> V doCall(Callable<V> op) {\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        push();\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n+     * as a suppressed exception when {@code atTop} is false.\n+     *\/\n+    @DontInline @ReservedStackAccess\n+    private static void throwIfFailed(Throwable ex, boolean atTop) {\n+        if (ex != null || !atTop) {\n+            if (!atTop) {\n+                var sve = StructureViolationExceptions.newException();\n+                if (ex == null) {\n+                    ex = sve;\n+                } else {\n+                    ex.addSuppressed(sve);\n+                }\n+            }\n+            Unsafe.getUnsafe().throwException(ex);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ScopedValueContainer.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -92,1 +92,1 @@\n-     * The extent locals captured when the thread container was created.\n+     * The scoped values captured when the thread container was created.\n@@ -94,1 +94,1 @@\n-    public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n+    public ScopedValueContainer.BindingsSnapshot scopedValueBindings() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-    {\"extentLocalCache\", \"()[\" OBJ,    (void *)&JVM_ExtentLocalCache},\n-    {\"setExtentLocalCache\", \"([\" OBJ \")V\",(void *)&JVM_SetExtentLocalCache},\n+    {\"scopedValueCache\", \"()[\" OBJ,    (void *)&JVM_ScopedValueCache},\n+    {\"setScopedValueCache\", \"([\" OBJ \")V\",(void *)&JVM_SetScopedValueCache},\n@@ -56,1 +56,1 @@\n-    {\"findExtentLocalBindings\", \"()\" OBJ, (void *)&JVM_FindExtentLocalBindings},\n+    {\"findScopedValueBindings\", \"()\" OBJ, (void *)&JVM_FindScopedValueBindings},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,723 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.concurrent;\n-\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.lang.ref.Reference;\n-import java.util.concurrent.Callable;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.vm.ExtentLocalContainer;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.ReservedStackAccess;\n-import jdk.internal.vm.annotation.Stable;\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * Represents a variable that is local to an <em>extent<\/em>. It is a per-thread variable\n- * that allows context to be set in a caller and read by callees. The <em>extent<\/em> is\n- * the set of methods that the caller directly invokes, and any methods invoked\n- * transitively. Extent-local variables also provide a way to share immutable data across\n- * threads.\n- *\n- * <p> An extent-local variable is bound, meaning it gets a value, when invoking an\n- * operation with the {@link Carrier#run(Runnable) Carrier.run} or {@link\n- * Carrier#call(Callable) Carrier.call} methods. {@link Carrier Carrier} instances are\n- * created by the static method {@link #where(ExtentLocal, Object)}. The operations\n- * executed by the {@code run} and {@code call} methods use the {@link #get()} method to\n- * read the value of a bound extent local. An extent-local variable reverts to being\n- * unbound (or its previous value) when the operation completes.\n- *\n- * <p> An {@code ExtentLocal} object will typically be declared in a {@code private\n- * static final} field so that it can only be accessed by code in that class (or other\n- * classes within its nest).\n- *\n- * <p> {@link ExtentLocal} bindings are immutable: there is no \"{@code set}\" method.\n- * There may be cases when an operation might need to use the same extent-local variable\n- * to communicate a different value to the methods that it calls. The requirement is not\n- * to change the original binding but to establish a new binding for nested calls. If an\n- * extent local already has a value, then {@code run} or {@code call} methods may be\n- * invoked to run another operation with a newly-bound value. Code executed by the\n- * operation will read the new value of the extent local. The extent local reverts to its\n- * previous value when the operation completes.\n- *\n- * <h2> Sharing extent-local variables across threads <\/h2>\n- *\n- * Extent-local variables can be shared across threads when used in conjunction with\n- * {@link StructuredTaskScope}. Creating a {@code StructuredTaskScope} captures the\n- * current thread's extent-local bindings for inheritance by threads {@link\n- * StructuredTaskScope#fork(Callable) forked} in the task scope. This means that a thread\n- * may bind an extent-local variable and share its value in a structured concurrency\n- * context. Threads forked in the task scope that read the extent-local variable will read\n- * the value bound by the thread that created the task scope.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n- * or method in this class will cause a {@link NullPointerException} to be thrown.\n- *\n- * @apiNote\n- * The following example uses an extent local to make credentials available to callees.\n- *\n- * {@snippet lang=java :\n- *   \/\/ @link substring=\"newInstance\" target=\"ExtentLocal#newInstance\" :\n- *   private static final ExtentLocal<Credentials> CREDENTIALS = ExtentLocal.newInstance();\n- *\n- *   Credentials creds = ...\n- *   ExtentLocal.where(CREDENTIALS, creds).run(() -> {\n- *       ...\n- *       Connection connection = connectDatabase();\n- *       ...\n- *   });\n- *\n- *   ...\n- *\n- *   Connection connectDatabase() {\n- *       \/\/ @link substring=\"get\" target=\"ExtentLocal#get\" :\n- *       Credentials credentials = CREDENTIALS.get();\n- *       ...\n- *   }\n- * }\n- *\n- * @implNote\n- * Extent-local variables are designed to be used in fairly small\n- * numbers. {@link #get} initially performs a search through enclosing\n- * scopes to find an extent-local variable's innermost binding. It\n- * then caches the result of the search in a small thread-local\n- * cache. Subsequent invocations of {@link #get} for that extent local\n- * will almost always be very fast. However, if a program has many\n- * extent-local variables that it uses cyclically, the cache hit rate\n- * will be low and performance will be poor. This design allows\n- * extent-local inheritance by {@link StructuredTaskScope} threads to\n- * be very fast: in essence, no more than copying a pointer, and\n- * leaving an extent-local binding also requires little more than\n- * updating a pointer.\n- *\n- * <p>Because the extent-local per-thread cache is small, you should\n- * try to minimize the number of bound extent-local variables in\n- * use. For example, if you need to pass a number of values in this\n- * way, it makes sense to create a record class to hold those values,\n- * and then bind a single extent-local variable to an instance of that\n- * record.\n- *\n- * <p>For this incubator release, we have provided some system properties\n- * to tune the performance of extent-local variables.\n- *\n- * <p>The system property {@code jdk.incubator.concurrent.ExtentLocal.cacheSize}\n- * controls the size of the (per-thread) extent-local cache. This cache is crucial\n- * for the performance of extent-local variables. If it is too small,\n- * the runtime library will repeatedly need to scan for each\n- * {@link #get}. If it is too large, memory will be unnecessarily\n- * consumed. The default extent-local cache size is 16 entries. It may\n- * be varied from 2 to 16 entries in size. {@code ExtentLocal.cacheSize}\n- * must be an integer power of 2.\n- *\n- * <p>For example, you could use {@code -Djdk.incubator.concurrent.ExtentLocal.cacheSize=8}.\n- *\n- * <p>The other system property is {@code jdk.preserveExtentLocalCache}.\n- * This property determines whether the per-thread extent-local\n- * cache is preserved when a virtual thread is blocked. By default\n- * this property is set to {@code true}, meaning that every virtual\n- * thread preserves its extent-local cache when blocked. Like {@code\n- * ExtentLocal.cacheSize}, this is a space versus speed trade-off: if\n- * you have a great many virtual threads that are blocked most of the\n- * time, setting this property to {@code false} might result in a\n- * useful memory saving, but each virtual thread's extent-local cache\n- * would have to be regenerated after a blocking operation.\n- *\n- * @param <T> the extent local's type\n- * @since 19\n- *\/\n-public final class ExtentLocal<T> {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    private final @Stable int hash;\n-\n-    @Override\n-    public int hashCode() { return hash; }\n-\n-    \/**\n-     * An immutable map from {@code ExtentLocal} to values.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n-     * or method in this class will cause a {@link NullPointerException} to be thrown.\n-     *\/\n-    static sealed class Snapshot permits EmptySnapshot {\n-        final Snapshot prev;\n-        final Carrier bindings;\n-        final int bitmask;\n-\n-        private static final Object NIL = new Object();\n-\n-        Snapshot(Carrier bindings, Snapshot prev) {\n-            this.prev = prev;\n-            this.bindings = bindings;\n-            this.bitmask = bindings.bitmask | prev.bitmask;\n-        }\n-\n-        protected Snapshot() {\n-            this.prev = null;\n-            this.bindings = null;\n-            this.bitmask = 0;\n-        }\n-\n-        Object find(ExtentLocal<?> key) {\n-            int bits = key.bitmask();\n-            for (Snapshot snapshot = this;\n-                 containsAll(snapshot.bitmask, bits);\n-                 snapshot = snapshot.prev) {\n-                for (Carrier carrier = snapshot.bindings;\n-                     carrier != null && containsAll(carrier.bitmask, bits);\n-                     carrier = carrier.prev) {\n-                    if (carrier.getKey() == key) {\n-                        Object value = carrier.get();\n-                        return value;\n-                    }\n-                }\n-            }\n-            return NIL;\n-        }\n-    }\n-\n-    static final class EmptySnapshot extends Snapshot {\n-\n-        private EmptySnapshot() {\n-            super();\n-        }\n-\n-        private static final Snapshot SINGLETON = new EmptySnapshot();\n-\n-        static final Snapshot getInstance() {\n-            return SINGLETON;\n-        }\n-    }\n-\n-    \/**\n-     * An immutable map of extent-local variables to values.\n-     * It define the {@link #run(Runnable) run} and {@link #call(Callable) call} methods\n-     * to invoke an operation with the extent-local variable mappings bound to the thread\n-     * that invokes {@code run} or {@code call}.\n-     *\n-     * @since 19\n-     *\/\n-    public static final class Carrier {\n-        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n-        \/\/ hits that slot in the cache.\n-        final int bitmask;\n-        final ExtentLocal<?> key;\n-        final Object value;\n-        final Carrier prev;\n-\n-        Carrier(ExtentLocal<?> key, Object value, Carrier prev) {\n-            this.key = key;\n-            this.value = value;\n-            this.prev = prev;\n-            int bits = key.bitmask();\n-            if (prev != null) {\n-                bits |= prev.bitmask;\n-            }\n-            this.bitmask = bits;\n-        }\n-\n-        \/**\n-         * Add a binding to this map, returning a new Carrier instance.\n-         *\/\n-        private static final <T> Carrier where(ExtentLocal<T> key, T value,\n-                                               Carrier prev) {\n-            return new Carrier(key, value, prev);\n-        }\n-\n-        \/**\n-         * Returns a new {@link Carrier Carrier}, which consists of the contents of this\n-         * carrier plus a new mapping from {@code key} to {@code value}. If this carrier\n-         * already has a mapping for the extent-local variable {@code key} then the new\n-         * value added by this method overrides the previous mapping. That is to say, if\n-         * there is a list of {@code where(...)} clauses, the rightmost clause wins.\n-         * @param key   the ExtentLocal to bind a value to\n-         * @param value the new value, can be {@code null}\n-         * @param <T>   the type of the ExtentLocal\n-         * @return a new carrier, consisting of {@code this} plus a new binding\n-         * ({@code this} is unchanged)\n-         *\/\n-        public <T> Carrier where(ExtentLocal<T> key, T value) {\n-            return where(key, value, this);\n-        }\n-\n-        \/*\n-         * Return a new set consisting of a single binding.\n-         *\/\n-        static <T> Carrier of(ExtentLocal<T> key, T value) {\n-            return where(key, value, null);\n-        }\n-\n-        final Object get() {\n-            return value;\n-        }\n-\n-        final ExtentLocal<?> getKey() {\n-            return key;\n-        }\n-\n-        \/**\n-         * Returns the value of a variable in this map of extent-local variables.\n-         * @param key the ExtentLocal variable\n-         * @param <T> the type of the ExtentLocal\n-         * @return the value\n-         * @throws NoSuchElementException if key is not bound to any value\n-         *\/\n-        @SuppressWarnings(\"unchecked\")\n-        public <T> T get(ExtentLocal<T> key) {\n-            var bits = key.bitmask();\n-            for (Carrier carrier = this;\n-                 carrier != null && containsAll(carrier.bitmask, bits);\n-                 carrier = carrier.prev) {\n-                if (carrier.getKey() == key) {\n-                    Object value = carrier.get();\n-                    return (T)value;\n-                }\n-            }\n-            throw new NoSuchElementException();\n-        }\n-\n-        \/**\n-         * Runs a value-returning operation with this map of extent-local variables bound\n-         * to values. Code invoked by {@code op} can use the {@link ExtentLocal#get()\n-         * get} method to get the value of the extent local. The extent-local variables\n-         * revert to their previous values or become {@linkplain #isBound() unbound} when\n-         * the operation completes.\n-         *\n-         * <p> Extent-local variables are intended to be used in a <em>structured\n-         * manner<\/em>. If {@code op} creates any {@link StructuredTaskScope}s but does\n-         * not close them, then exiting {@code op} causes the underlying construct of each\n-         * {@link StructuredTaskScope} to be closed (in the reverse order that they were\n-         * created in), and {@link StructureViolationException} to be thrown.\n-         *\n-         * @param op    the operation to run\n-         * @param <R>   the type of the result of the function\n-         * @return the result\n-         * @throws Exception if {@code op} completes with an exception\n-         *\/\n-        public <R> R call(Callable<R> op) throws Exception {\n-            Objects.requireNonNull(op);\n-            Cache.invalidate(bitmask);\n-            var prevSnapshot = extentLocalBindings();\n-            var newSnapshot = new Snapshot(this, prevSnapshot);\n-            R result;\n-            try {\n-                JLA.setExtentLocalBindings(newSnapshot);\n-                JLA.ensureMaterializedForStackWalk(newSnapshot);\n-                result = ExtentLocalContainer.call(op);\n-            } finally {\n-                Reference.reachabilityFence(newSnapshot);\n-                JLA.setExtentLocalBindings(prevSnapshot);\n-                Cache.invalidate(bitmask);\n-            }\n-            return result;\n-        }\n-\n-        \/**\n-         * Runs an operation with this map of ExtentLocals bound to values. Code executed\n-         * by the operation can use the {@link ExtentLocal#get() get()} method to get the\n-         * value of the extent local. The extent-local variables revert to their previous\n-         * values or becomes {@linkplain #isBound() unbound} when the operation completes.\n-         *\n-         * <p> Extent-local variables are intended to be used in a <em>structured\n-         * manner<\/em>. If {@code op} creates any {@link StructuredTaskScope}s but does\n-         * not close them, then exiting {@code op} causes the underlying construct of each\n-         * {@link StructuredTaskScope} to be closed (in the reverse order that they were\n-         * created in), and {@link StructureViolationException} to be thrown.\n-         *\n-         * @param op    the operation to run\n-         *\/\n-        public void run(Runnable op) {\n-            Objects.requireNonNull(op);\n-            Cache.invalidate(bitmask);\n-            Snapshot newSnapshot = null;\n-            JLA.ensureMaterializedForStackWalk(newSnapshot);\n-            var prevSnapshot = extentLocalBindings();\n-            newSnapshot = new Snapshot(this, prevSnapshot);\n-            try {\n-                JLA.setExtentLocalBindings(newSnapshot);\n-                JLA.ensureMaterializedForStackWalk(newSnapshot);\n-                ExtentLocalContainer.run(op);\n-            } finally {\n-                Reference.reachabilityFence(newSnapshot);\n-                JLA.setExtentLocalBindings(prevSnapshot);\n-                Cache.invalidate(bitmask);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Creates a binding for an extent-local variable.\n-     * The {@link Carrier Carrier} may be used later to invoke a {@link Callable} or\n-     * {@link Runnable} instance. More bindings may be added to the {@link Carrier Carrier}\n-     * by further calls to this method.\n-     *\n-     * @param key the ExtentLocal to bind\n-     * @param value the value to bind it to, can be {@code null}\n-     * @param <T> the type of the ExtentLocal\n-     * @return A Carrier instance that contains one binding, that of key and value\n-     *\/\n-    public static <T> Carrier where(ExtentLocal<T> key, T value) {\n-        return Carrier.of(key, value);\n-    }\n-\n-    \/**\n-     * Creates a binding for an extent-local variable and runs a\n-     * value-returning operation with that {@link ExtentLocal} bound to the value.\n-     * @param key the ExtentLocal to bind\n-     * @param value the value to bind it to, can be {@code null}\n-     * @param <T> the type of the ExtentLocal\n-     * @param <U> the type of the Result\n-     * @param op the operation to call\n-     * @return the result\n-     * @throws Exception if the operation completes with an exception\n-     *\/\n-    public static <T, U> U where(ExtentLocal<T> key, T value, Callable<U> op) throws Exception {\n-        return where(key, value).call(op);\n-    }\n-\n-    \/**\n-     * Creates a binding for extent-local variable and runs an\n-     * operation with that  {@link ExtentLocal} bound to the value.\n-     * @param key the ExtentLocal to bind\n-     * @param value the value to bind it to, can be {@code null}\n-     * @param <T> the type of the ExtentLocal\n-     * @param op the operation to run\n-     *\/\n-    public static <T> void where(ExtentLocal<T> key, T value, Runnable op) {\n-        where(key, value).run(op);\n-    }\n-\n-    private ExtentLocal() {\n-        this.hash = generateKey();\n-    }\n-\n-    \/**\n-     * Creates an extent-local variable to refer to a value of type T.\n-     *\n-     * @param <T> the type of the extent local's value.\n-     * @return an extent-local variable\n-     *\/\n-    public static <T> ExtentLocal<T> newInstance() {\n-        return new ExtentLocal<T>();\n-    }\n-\n-    \/**\n-     * Returns the current thread's bound value for this extent-local variable.\n-     * @return the value of the extent local\n-     * @throws NoSuchElementException if the extent local is not bound\n-     *\/\n-    @ForceInline\n-    @SuppressWarnings(\"unchecked\")\n-    public T get() {\n-        Object[] objects;\n-        if ((objects = extentLocalCache()) != null) {\n-            \/\/ This code should perhaps be in class Cache. We do it\n-            \/\/ here because the generated code is small and fast and\n-            \/\/ we really want it to be inlined in the caller.\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-        }\n-        return slowGet();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private T slowGet() {\n-        var value = findBinding();\n-        if (value == Snapshot.NIL) {\n-            throw new NoSuchElementException();\n-        }\n-        Cache.put(this, value);\n-        return (T)value;\n-    }\n-\n-    \/**\n-     * {@return {@code true} if the extent local is bound to a value}\n-     *\/\n-    public boolean isBound() {\n-        \/\/ ??? Do we want to search cache for this? In most cases we don't expect\n-        \/\/ this {@link ExtentLocal} to be bound, so it's not worth it. But I may\n-        \/\/ be wrong about that.\n-\/*\n-        if (Cache.find(this) != Snapshot.NIL) {\n-            return true;\n-        }\n- *\/\n-        return findBinding() != Snapshot.NIL;\n-    }\n-\n-    \/**\n-     * Return the value of the extent local or NIL if not bound.\n-     *\/\n-    private Object findBinding() {\n-        Object value = extentLocalBindings().find(this);\n-        return value;\n-    }\n-\n-    \/**\n-     * Returns the value of the extent local if bound, otherwise returns {@code other}.\n-     * @param other the value to return if not bound, can be {@code null}\n-     * @return the value of the extent local if bound, otherwise {@code other}\n-     *\/\n-    public T orElse(T other) {\n-        Object obj = findBinding();\n-        if (obj != Snapshot.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            return other;\n-        }\n-    }\n-\n-    \/**\n-     * Returns the value of the extent local if bound, otherwise throws the exception\n-     * produced by the exception supplying function.\n-     * @param <X> Type of the exception to be thrown\n-     * @param exceptionSupplier the supplying function that produces the exception to throw\n-     * @return the value of the extent local if bound\n-     * @throws X prodouced by the exception suppying function if the extent local is unbound\n-     *\/\n-    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n-        Objects.requireNonNull(exceptionSupplier);\n-        Object obj = findBinding();\n-        if (obj != Snapshot.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            throw exceptionSupplier.get();\n-        }\n-    }\n-\n-    private static Object[] extentLocalCache() {\n-        return JLA.extentLocalCache();\n-    }\n-\n-    private static void setExtentLocalCache(Object[] cache) {\n-        JLA.setExtentLocalCache(cache);\n-    }\n-\n-    private static Snapshot extentLocalBindings() {\n-        \/\/ Bindings can be in one of four states:\n-        \/\/\n-        \/\/ 1: class Thread: this is a new Thread instance, and no\n-        \/\/ extent locals have ever been bound in this Thread.\n-        \/\/ 2: EmptySnapshot.SINGLETON: This is effectively an empty binding.\n-        \/\/ 3: A Snapshot instance: this contains one or more extent local\n-        \/\/ bindings.\n-        \/\/ 4: null: there may be some bindings in this Thread, but we don't know\n-        \/\/ where they are. We must invoke JLA.findExtentLocalBindings() to walk\n-        \/\/ the stack to find them.\n-\n-        Object bindings = JLA.extentLocalBindings();\n-        if (bindings == Thread.class) {\n-            \/\/ This must be a new thread\n-           return EmptySnapshot.getInstance();\n-        }\n-        if (bindings == null) {\n-            \/\/ Search the stack\n-            bindings = JLA.findExtentLocalBindings();\n-            if (bindings == null) {\n-                \/\/ Nothing on the stack.\n-                return EmptySnapshot.getInstance();\n-            }\n-        }\n-        assert (bindings != null);\n-        return (Snapshot) bindings;\n-    }\n-\n-    private static int nextKey = 0xf0f0_f0f0;\n-\n-    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n-    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n-    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n-    \/\/ to different slots in the cache.\n-    private static synchronized int generateKey() {\n-        int x = nextKey;\n-        do {\n-            x ^= x >>> 12;\n-            x ^= x << 9;\n-            x ^= x >>> 23;\n-        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n-        return (nextKey = x);\n-    }\n-\n-    \/**\n-     * Return a bit mask that may be used to determine if this ExtentLocal is\n-     * bound in the current context. Each Carrier holds a bit mask which is\n-     * the OR of all the bit masks of the bound ExtentLocals.\n-     * @return the bitmask\n-     *\/\n-    int bitmask() {\n-        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n-    }\n-\n-    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n-    \/\/ of the bits in targetBits.\n-    static boolean containsAll(int bitmask, int targetBits) {\n-        return (bitmask & targetBits) == targetBits;\n-    }\n-\n-    \/\/ A small fixed-size key-value cache. When an extent local's get() method\n-    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n-    \/\/ for fast access in future.\n-    private static class Cache {\n-        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n-        static final int TABLE_SIZE = 1 << INDEX_BITS;\n-        static final int TABLE_MASK = TABLE_SIZE - 1;\n-        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n-\n-        \/\/ The number of elements in the cache array, and a bit mask used to\n-        \/\/ select elements from it.\n-        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n-        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n-        \/\/ or equal to 2.\n-        private static final int MAX_CACHE_SIZE = 16;\n-\n-        static {\n-            final String propertyName = \"jdk.incubator.concurrent.ExtentLocal.cacheSize\";\n-            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n-            var cacheSize = Integer.valueOf(sizeString);\n-            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n-            }\n-            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n-            }\n-            CACHE_TABLE_SIZE = cacheSize;\n-            SLOT_MASK = cacheSize - 1;\n-        }\n-\n-        static final int primaryIndex(ExtentLocal<?> key) {\n-            return key.hash & TABLE_MASK;\n-        }\n-\n-        static final int secondaryIndex(ExtentLocal<?> key) {\n-            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n-        }\n-\n-        private static final int primarySlot(ExtentLocal<?> key) {\n-            return key.hashCode() & SLOT_MASK;\n-        }\n-\n-        private static final int secondarySlot(ExtentLocal<?> key) {\n-            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n-        }\n-\n-        static final int primarySlot(int hash) {\n-            return hash & SLOT_MASK;\n-        }\n-\n-        static final int secondarySlot(int hash) {\n-            return (hash >> INDEX_BITS) & SLOT_MASK;\n-        }\n-\n-        static void put(ExtentLocal<?> key, Object value) {\n-            Object[] theCache = extentLocalCache();\n-            if (theCache == null) {\n-                theCache = new Object[CACHE_TABLE_SIZE * 2];\n-                setExtentLocalCache(theCache);\n-            }\n-            \/\/ Update the cache to replace one entry with the value we just looked up.\n-            \/\/ Each value can be in one of two possible places in the cache.\n-            \/\/ Pick a victim at (pseudo-)random.\n-            int k1 = primarySlot(key);\n-            int k2 = secondarySlot(key);\n-            var usePrimaryIndex = chooseVictim();\n-            int victim = usePrimaryIndex ? k1 : k2;\n-            int other = usePrimaryIndex ? k2 : k1;\n-            setKeyAndObjectAt(victim, key, value);\n-            if (getKey(theCache, other) == key) {\n-                setKeyAndObjectAt(other, key, value);\n-            }\n-        }\n-\n-        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n-            var cache = extentLocalCache();\n-            cache[n * 2] = key;\n-            cache[n * 2 + 1] = value;\n-        }\n-\n-        private static void setKeyAndObjectAt(Object[] cache, int n, Object key, Object value) {\n-            cache[n * 2] = key;\n-            cache[n * 2 + 1] = value;\n-        }\n-\n-        private static Object getKey(Object[] objs, int n) {\n-            return objs[n * 2];\n-        }\n-\n-        private static void setKey(Object[] objs, int n, Object key) {\n-            objs[n * 2] = key;\n-        }\n-\n-        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n-                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n-\n-        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n-        \/\/ This chooses either the primary or secondary cache slot, but the\n-        \/\/ primary slot is approximately twice as likely to be chosen as the\n-        \/\/ secondary one.\n-        private static boolean chooseVictim() {\n-            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n-            return (r & 15) >= 5;\n-        }\n-\n-        @ReservedStackAccess @DontInline\n-        public static void invalidate() {\n-            setExtentLocalCache(null);\n-        }\n-\n-        \/\/ Null a set of cache entries, indicated by the 1-bits given\n-        @ReservedStackAccess @DontInline\n-        static void invalidate(int toClearBits) {\n-            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n-            Object[] objects;\n-            if ((objects = extentLocalCache()) != null) {\n-                for (int bits = toClearBits; bits != 0; ) {\n-                    int index = Integer.numberOfTrailingZeros(bits);\n-                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n-                    bits &= ~1 << index;\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ExtentLocal.java","additions":0,"deletions":723,"binary":false,"changes":723,"status":"deleted"},{"patch":"@@ -0,0 +1,723 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.concurrent;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.Callable;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.ScopedValueContainer;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.ReservedStackAccess;\n+import jdk.internal.vm.annotation.Stable;\n+import sun.security.action.GetPropertyAction;\n+\n+\/**\n+ * Represents a value that is local to a <em>scope<\/em>. It is a per-thread value\n+ * that allows context to be set in a caller and read by callees. The <em>scope<\/em> is\n+ * the set of methods that the caller directly invokes, and any methods invoked\n+ * transitively. Scoped values also provide a way to share immutable data across\n+ * threads.\n+ *\n+ * <p> An scoped value is bound, meaning it gets a value, when invoking an\n+ * operation with the {@link Carrier#run(Runnable) Carrier.run} or {@link\n+ * Carrier#call(Callable) Carrier.call} methods. {@link Carrier Carrier} instances are\n+ * created by the static method {@link #where(ScopedValue, Object)}. The operations\n+ * executed by the {@code run} and {@code call} methods use the {@link #get()} method to\n+ * read the value of a bound scoped value. A scoped value reverts to being\n+ * unbound (or its previous value) when the operation completes.\n+ *\n+ * <p> An {@code ScopedValue} object will typically be declared in a {@code private\n+ * static final} field so that it can only be accessed by code in that class (or other\n+ * classes within its nest).\n+ *\n+ * <p> {@link ScopedValue} bindings are immutable: there is no \"{@code set}\" method.\n+ * There may be cases when an operation might need to use the same scoped-value variable\n+ * to communicate a different value to the methods that it calls. The requirement is not\n+ * to change the original binding but to establish a new binding for nested calls. If an\n+ * scoped value already has a value, then {@code run} or {@code call} methods may be\n+ * invoked to run another operation with a newly-bound value. Code executed by the\n+ * operation will read the new value of the scoped value. The scoped value reverts to its\n+ * previous value when the operation completes.\n+ *\n+ * <h2> Sharing scoped values across threads <\/h2>\n+ *\n+ * scoped values can be shared across threads when used in conjunction with\n+ * {@link StructuredTaskScope}. Creating a {@code StructuredTaskScope} captures the\n+ * current thread's scoped-value bindings for inheritance by threads {@link\n+ * StructuredTaskScope#fork(Callable) forked} in the task scope. This means that a thread\n+ * may bind an scoped-value variable and share its value in a structured concurrency\n+ * context. Threads forked in the task scope that read the scoped-value variable will read\n+ * the value bound by the thread that created the task scope.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+ * or method in this class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * @apiNote\n+ * The following example uses an scoped value to make credentials available to callees.\n+ *\n+ * {@snippet lang=java :\n+ *   \/\/ @link substring=\"newInstance\" target=\"ScopedValue#newInstance\" :\n+ *   private static final ScopedValue<Credentials> CREDENTIALS = ScopedValue.newInstance();\n+ *\n+ *   Credentials creds = ...\n+ *   ScopedValue.where(CREDENTIALS, creds).run(() -> {\n+ *       ...\n+ *       Connection connection = connectDatabase();\n+ *       ...\n+ *   });\n+ *\n+ *   ...\n+ *\n+ *   Connection connectDatabase() {\n+ *       \/\/ @link substring=\"get\" target=\"ScopedValue#get\" :\n+ *       Credentials credentials = CREDENTIALS.get();\n+ *       ...\n+ *   }\n+ * }\n+ *\n+ * @implNote\n+ * scoped values are designed to be used in fairly small\n+ * numbers. {@link #get} initially performs a search through enclosing\n+ * scopes to find an scoped-value variable's innermost binding. It\n+ * then caches the result of the search in a small thread-local\n+ * cache. Subsequent invocations of {@link #get} for that scoped value\n+ * will almost always be very fast. However, if a program has many\n+ * scoped values that it uses cyclically, the cache hit rate\n+ * will be low and performance will be poor. This design allows\n+ * scoped-value inheritance by {@link StructuredTaskScope} threads to\n+ * be very fast: in essence, no more than copying a pointer, and\n+ * leaving an scoped-value binding also requires little more than\n+ * updating a pointer.\n+ *\n+ * <p>Because the scoped-value per-thread cache is small, you should\n+ * try to minimize the number of bound scoped values in\n+ * use. For example, if you need to pass a number of values in this\n+ * way, it makes sense to create a record class to hold those values,\n+ * and then bind a single scoped-value variable to an instance of that\n+ * record.\n+ *\n+ * <p>For this incubator release, we have provided some system properties\n+ * to tune the performance of scoped values.\n+ *\n+ * <p>The system property {@code jdk.incubator.concurrent.ScopedValue.cacheSize}\n+ * controls the size of the (per-thread) scoped-value cache. This cache is crucial\n+ * for the performance of scoped values. If it is too small,\n+ * the runtime library will repeatedly need to scan for each\n+ * {@link #get}. If it is too large, memory will be unnecessarily\n+ * consumed. The default scoped-value cache size is 16 entries. It may\n+ * be varied from 2 to 16 entries in size. {@code ScopedValue.cacheSize}\n+ * must be an integer power of 2.\n+ *\n+ * <p>For example, you could use {@code -Djdk.incubator.concurrent.ScopedValue.cacheSize=8}.\n+ *\n+ * <p>The other system property is {@code jdk.preserveScopedValueCache}.\n+ * This property determines whether the per-thread scoped-value\n+ * cache is preserved when a virtual thread is blocked. By default\n+ * this property is set to {@code true}, meaning that every virtual\n+ * thread preserves its scoped-value cache when blocked. Like {@code\n+ * ScopedValue.cacheSize}, this is a space versus speed trade-off: if\n+ * you have a great many virtual threads that are blocked most of the\n+ * time, setting this property to {@code false} might result in a\n+ * useful memory saving, but each virtual thread's scoped-value cache\n+ * would have to be regenerated after a blocking operation.\n+ *\n+ * @param <T> the scoped value's type\n+ * @since 19\n+ *\/\n+public final class ScopedValue<T> {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private final @Stable int hash;\n+\n+    @Override\n+    public int hashCode() { return hash; }\n+\n+    \/**\n+     * An immutable map from {@code ScopedValue} to values.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+     * or method in this class will cause a {@link NullPointerException} to be thrown.\n+     *\/\n+    static sealed class Snapshot permits EmptySnapshot {\n+        final Snapshot prev;\n+        final Carrier bindings;\n+        final int bitmask;\n+\n+        private static final Object NIL = new Object();\n+\n+        Snapshot(Carrier bindings, Snapshot prev) {\n+            this.prev = prev;\n+            this.bindings = bindings;\n+            this.bitmask = bindings.bitmask | prev.bitmask;\n+        }\n+\n+        protected Snapshot() {\n+            this.prev = null;\n+            this.bindings = null;\n+            this.bitmask = 0;\n+        }\n+\n+        Object find(ScopedValue<?> key) {\n+            int bits = key.bitmask();\n+            for (Snapshot snapshot = this;\n+                 containsAll(snapshot.bitmask, bits);\n+                 snapshot = snapshot.prev) {\n+                for (Carrier carrier = snapshot.bindings;\n+                     carrier != null && containsAll(carrier.bitmask, bits);\n+                     carrier = carrier.prev) {\n+                    if (carrier.getKey() == key) {\n+                        Object value = carrier.get();\n+                        return value;\n+                    }\n+                }\n+            }\n+            return NIL;\n+        }\n+    }\n+\n+    static final class EmptySnapshot extends Snapshot {\n+\n+        private EmptySnapshot() {\n+            super();\n+        }\n+\n+        private static final Snapshot SINGLETON = new EmptySnapshot();\n+\n+        static final Snapshot getInstance() {\n+            return SINGLETON;\n+        }\n+    }\n+\n+    \/**\n+     * An immutable map of scoped values to values.\n+     * It define the {@link #run(Runnable) run} and {@link #call(Callable) call} methods\n+     * to invoke an operation with the scoped-value variable mappings bound to the thread\n+     * that invokes {@code run} or {@code call}.\n+     *\n+     * @since 19\n+     *\/\n+    public static final class Carrier {\n+        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n+        \/\/ hits that slot in the cache.\n+        final int bitmask;\n+        final ScopedValue<?> key;\n+        final Object value;\n+        final Carrier prev;\n+\n+        Carrier(ScopedValue<?> key, Object value, Carrier prev) {\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n+            int bits = key.bitmask();\n+            if (prev != null) {\n+                bits |= prev.bitmask;\n+            }\n+            this.bitmask = bits;\n+        }\n+\n+        \/**\n+         * Add a binding to this map, returning a new Carrier instance.\n+         *\/\n+        private static final <T> Carrier where(ScopedValue<T> key, T value,\n+                                               Carrier prev) {\n+            return new Carrier(key, value, prev);\n+        }\n+\n+        \/**\n+         * Returns a new {@link Carrier Carrier}, which consists of the contents of this\n+         * carrier plus a new mapping from {@code key} to {@code value}. If this carrier\n+         * already has a mapping for the scoped-value variable {@code key} then the new\n+         * value added by this method overrides the previous mapping. That is to say, if\n+         * there is a list of {@code where(...)} clauses, the rightmost clause wins.\n+         * @param key   the ScopedValue to bind a value to\n+         * @param value the new value, can be {@code null}\n+         * @param <T>   the type of the ScopedValue\n+         * @return a new carrier, consisting of {@code this} plus a new binding\n+         * ({@code this} is unchanged)\n+         *\/\n+        public <T> Carrier where(ScopedValue<T> key, T value) {\n+            return where(key, value, this);\n+        }\n+\n+        \/*\n+         * Return a new set consisting of a single binding.\n+         *\/\n+        static <T> Carrier of(ScopedValue<T> key, T value) {\n+            return where(key, value, null);\n+        }\n+\n+        final Object get() {\n+            return value;\n+        }\n+\n+        final ScopedValue<?> getKey() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Returns the value of a variable in this map of scoped values.\n+         * @param key the ScopedValue variable\n+         * @param <T> the type of the ScopedValue\n+         * @return the value\n+         * @throws NoSuchElementException if key is not bound to any value\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T get(ScopedValue<T> key) {\n+            var bits = key.bitmask();\n+            for (Carrier carrier = this;\n+                 carrier != null && containsAll(carrier.bitmask, bits);\n+                 carrier = carrier.prev) {\n+                if (carrier.getKey() == key) {\n+                    Object value = carrier.get();\n+                    return (T)value;\n+                }\n+            }\n+            throw new NoSuchElementException();\n+        }\n+\n+        \/**\n+         * Runs a value-returning operation with this map of scoped values bound\n+         * to values. Code invoked by {@code op} can use the {@link ScopedValue#get()\n+         * get} method to get the value of the scoped value. The scoped values\n+         * revert to their previous values or become {@linkplain #isBound() unbound} when\n+         * the operation completes.\n+         *\n+         * <p> scoped values are intended to be used in a <em>structured\n+         * manner<\/em>. If {@code op} creates any {@link StructuredTaskScope}s but does\n+         * not close them, then exiting {@code op} causes the underlying construct of each\n+         * {@link StructuredTaskScope} to be closed (in the reverse order that they were\n+         * created in), and {@link StructureViolationException} to be thrown.\n+         *\n+         * @param op    the operation to run\n+         * @param <R>   the type of the result of the function\n+         * @return the result\n+         * @throws Exception if {@code op} completes with an exception\n+         *\/\n+        public <R> R call(Callable<R> op) throws Exception {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            R result;\n+            try {\n+                JLA.setScopedValueBindings(newSnapshot);\n+                JLA.ensureMaterializedForStackWalk(newSnapshot);\n+                result = ScopedValueContainer.call(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                JLA.setScopedValueBindings(prevSnapshot);\n+                Cache.invalidate(bitmask);\n+            }\n+            return result;\n+        }\n+\n+        \/**\n+         * Runs an operation with this map of ScopedValues bound to values. Code executed\n+         * by the operation can use the {@link ScopedValue#get() get()} method to get the\n+         * value of the scoped value. The scoped values revert to their previous\n+         * values or becomes {@linkplain #isBound() unbound} when the operation completes.\n+         *\n+         * <p> scoped values are intended to be used in a <em>structured\n+         * manner<\/em>. If {@code op} creates any {@link StructuredTaskScope}s but does\n+         * not close them, then exiting {@code op} causes the underlying construct of each\n+         * {@link StructuredTaskScope} to be closed (in the reverse order that they were\n+         * created in), and {@link StructureViolationException} to be thrown.\n+         *\n+         * @param op    the operation to run\n+         *\/\n+        public void run(Runnable op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            Snapshot newSnapshot = null;\n+            JLA.ensureMaterializedForStackWalk(newSnapshot);\n+            var prevSnapshot = scopedValueBindings();\n+            newSnapshot = new Snapshot(this, prevSnapshot);\n+            try {\n+                JLA.setScopedValueBindings(newSnapshot);\n+                JLA.ensureMaterializedForStackWalk(newSnapshot);\n+                ScopedValueContainer.run(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                JLA.setScopedValueBindings(prevSnapshot);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a binding for an scoped-value variable.\n+     * The {@link Carrier Carrier} may be used later to invoke a {@link Callable} or\n+     * {@link Runnable} instance. More bindings may be added to the {@link Carrier Carrier}\n+     * by further calls to this method.\n+     *\n+     * @param key the ScopedValue to bind\n+     * @param value the value to bind it to, can be {@code null}\n+     * @param <T> the type of the ScopedValue\n+     * @return A Carrier instance that contains one binding, that of key and value\n+     *\/\n+    public static <T> Carrier where(ScopedValue<T> key, T value) {\n+        return Carrier.of(key, value);\n+    }\n+\n+    \/**\n+     * Creates a binding for an scoped-value variable and runs a\n+     * value-returning operation with that {@link ScopedValue} bound to the value.\n+     * @param key the ScopedValue to bind\n+     * @param value the value to bind it to, can be {@code null}\n+     * @param <T> the type of the ScopedValue\n+     * @param <U> the type of the Result\n+     * @param op the operation to call\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public static <T, U> U where(ScopedValue<T> key, T value, Callable<U> op) throws Exception {\n+        return where(key, value).call(op);\n+    }\n+\n+    \/**\n+     * Creates a binding for scoped-value variable and runs an\n+     * operation with that  {@link ScopedValue} bound to the value.\n+     * @param key the ScopedValue to bind\n+     * @param value the value to bind it to, can be {@code null}\n+     * @param <T> the type of the ScopedValue\n+     * @param op the operation to run\n+     *\/\n+    public static <T> void where(ScopedValue<T> key, T value, Runnable op) {\n+        where(key, value).run(op);\n+    }\n+\n+    private ScopedValue() {\n+        this.hash = generateKey();\n+    }\n+\n+    \/**\n+     * Creates an scoped-value variable to refer to a value of type T.\n+     *\n+     * @param <T> the type of the scoped value's value.\n+     * @return an scoped-value variable\n+     *\/\n+    public static <T> ScopedValue<T> newInstance() {\n+        return new ScopedValue<T>();\n+    }\n+\n+    \/**\n+     * Returns the current thread's bound value for this scoped-value variable.\n+     * @return the value of the scoped value\n+     * @throws NoSuchElementException if the scoped value is not bound\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = scopedValueCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private T slowGet() {\n+        var value = findBinding();\n+        if (value == Snapshot.NIL) {\n+            throw new NoSuchElementException();\n+        }\n+        Cache.put(this, value);\n+        return (T)value;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if the scoped value is bound to a value}\n+     *\/\n+    public boolean isBound() {\n+        \/\/ ??? Do we want to search cache for this? In most cases we don't expect\n+        \/\/ this {@link ScopedValue} to be bound, so it's not worth it. But I may\n+        \/\/ be wrong about that.\n+\/*\n+        if (Cache.find(this) != Snapshot.NIL) {\n+            return true;\n+        }\n+ *\/\n+        return findBinding() != Snapshot.NIL;\n+    }\n+\n+    \/**\n+     * Return the value of the scoped value or NIL if not bound.\n+     *\/\n+    private Object findBinding() {\n+        Object value = scopedValueBindings().find(this);\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the value of the scoped value if bound, otherwise returns {@code other}.\n+     * @param other the value to return if not bound, can be {@code null}\n+     * @return the value of the scoped value if bound, otherwise {@code other}\n+     *\/\n+    public T orElse(T other) {\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            return other;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the value of the scoped value if bound, otherwise throws the exception\n+     * produced by the exception supplying function.\n+     * @param <X> Type of the exception to be thrown\n+     * @param exceptionSupplier the supplying function that produces the exception to throw\n+     * @return the value of the scoped value if bound\n+     * @throws X prodouced by the exception suppying function if the scoped value is unbound\n+     *\/\n+    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n+        Objects.requireNonNull(exceptionSupplier);\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    private static Object[] scopedValueCache() {\n+        return JLA.scopedValueCache();\n+    }\n+\n+    private static void setScopedValueCache(Object[] cache) {\n+        JLA.setScopedValueCache(cache);\n+    }\n+\n+    private static Snapshot scopedValueBindings() {\n+        \/\/ Bindings can be in one of four states:\n+        \/\/\n+        \/\/ 1: class Thread: this is a new Thread instance, and no\n+        \/\/ scoped values have ever been bound in this Thread.\n+        \/\/ 2: EmptySnapshot.SINGLETON: This is effectively an empty binding.\n+        \/\/ 3: A Snapshot instance: this contains one or more scoped value\n+        \/\/ bindings.\n+        \/\/ 4: null: there may be some bindings in this Thread, but we don't know\n+        \/\/ where they are. We must invoke JLA.findScopedValueBindings() to walk\n+        \/\/ the stack to find them.\n+\n+        Object bindings = JLA.scopedValueBindings();\n+        if (bindings == Thread.class) {\n+            \/\/ This must be a new thread\n+           return EmptySnapshot.getInstance();\n+        }\n+        if (bindings == null) {\n+            \/\/ Search the stack\n+            bindings = JLA.findScopedValueBindings();\n+            if (bindings == null) {\n+                \/\/ Nothing on the stack.\n+                return EmptySnapshot.getInstance();\n+            }\n+        }\n+        assert (bindings != null);\n+        return (Snapshot) bindings;\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n+    \/\/ to different slots in the cache.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        return (nextKey = x);\n+    }\n+\n+    \/**\n+     * Return a bit mask that may be used to determine if this ScopedValue is\n+     * bound in the current context. Each Carrier holds a bit mask which is\n+     * the OR of all the bit masks of the bound ScopedValues.\n+     * @return the bitmask\n+     *\/\n+    int bitmask() {\n+        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+    }\n+\n+    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n+    \/\/ of the bits in targetBits.\n+    static boolean containsAll(int bitmask, int targetBits) {\n+        return (bitmask & targetBits) == targetBits;\n+    }\n+\n+    \/\/ A small fixed-size key-value cache. When an scoped value's get() method\n+    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n+    \/\/ for fast access in future.\n+    private static class Cache {\n+        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n+        static final int TABLE_SIZE = 1 << INDEX_BITS;\n+        static final int TABLE_MASK = TABLE_SIZE - 1;\n+        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n+\n+        \/\/ The number of elements in the cache array, and a bit mask used to\n+        \/\/ select elements from it.\n+        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+        \/\/ or equal to 2.\n+        private static final int MAX_CACHE_SIZE = 16;\n+\n+        static {\n+            final String propertyName = \"jdk.incubator.concurrent.ScopedValue.cacheSize\";\n+            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n+            var cacheSize = Integer.valueOf(sizeString);\n+            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+            }\n+            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+            }\n+            CACHE_TABLE_SIZE = cacheSize;\n+            SLOT_MASK = cacheSize - 1;\n+        }\n+\n+        static final int primaryIndex(ScopedValue<?> key) {\n+            return key.hash & TABLE_MASK;\n+        }\n+\n+        static final int secondaryIndex(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        }\n+\n+        private static final int primarySlot(ScopedValue<?> key) {\n+            return key.hashCode() & SLOT_MASK;\n+        }\n+\n+        private static final int secondarySlot(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static final int primarySlot(int hash) {\n+            return hash & SLOT_MASK;\n+        }\n+\n+        static final int secondarySlot(int hash) {\n+            return (hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static void put(ScopedValue<?> key, Object value) {\n+            Object[] theCache = scopedValueCache();\n+            if (theCache == null) {\n+                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                setScopedValueCache(theCache);\n+            }\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            int k1 = primarySlot(key);\n+            int k2 = secondarySlot(key);\n+            var usePrimaryIndex = chooseVictim();\n+            int victim = usePrimaryIndex ? k1 : k2;\n+            int other = usePrimaryIndex ? k2 : k1;\n+            setKeyAndObjectAt(victim, key, value);\n+            if (getKey(theCache, other) == key) {\n+                setKeyAndObjectAt(other, key, value);\n+            }\n+        }\n+\n+        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n+            var cache = scopedValueCache();\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static void setKeyAndObjectAt(Object[] cache, int n, Object key, Object value) {\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static Object getKey(Object[] objs, int n) {\n+            return objs[n * 2];\n+        }\n+\n+        private static void setKey(Object[] objs, int n, Object key) {\n+            objs[n * 2] = key;\n+        }\n+\n+        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n+        \/\/ This chooses either the primary or secondary cache slot, but the\n+        \/\/ primary slot is approximately twice as likely to be chosen as the\n+        \/\/ secondary one.\n+        private static boolean chooseVictim() {\n+            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            return (r & 15) >= 5;\n+        }\n+\n+        @ReservedStackAccess @DontInline\n+        public static void invalidate() {\n+            setScopedValueCache(null);\n+        }\n+\n+        \/\/ Null a set of cache entries, indicated by the 1-bits given\n+        @ReservedStackAccess @DontInline\n+        static void invalidate(int toClearBits) {\n+            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            Object[] objects;\n+            if ((objects = scopedValueCache()) != null) {\n+                for (int bits = toClearBits; bits != 0; ) {\n+                    int index = Integer.numberOfTrailingZeros(bits);\n+                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    bits &= ~1 << index;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ScopedValue.java","additions":723,"deletions":0,"binary":false,"changes":723,"status":"added"},{"patch":"@@ -227,1 +227,1 @@\n- *   <li> Inheritance of {@linkplain ExtentLocal extent-local} variables across threads.\n+ *   <li> Inheritance of {@linkplain ScopedValue scoped-value} variables across threads.\n@@ -232,2 +232,2 @@\n- * <p> The following example demonstrates the inheritance of an extent-local variable. An\n- * extent local {@code NAME} is bound to the value \"duke\". A StructuredTaskScope is created\n+ * <p> The following example demonstrates the inheritance of an scoped-value variable. An\n+ * scoped value {@code NAME} is bound to the value \"duke\". A StructuredTaskScope is created\n@@ -235,1 +235,1 @@\n- * The thread inherits the extent-local {@linkplain ExtentLocal.Carrier bindings} captured\n+ * The thread inherits the scoped-value {@linkplain ScopedValue.Carrier bindings} captured\n@@ -237,1 +237,1 @@\n- * extent-local and so reads the value \"duke\".\n+ * scoped-value and so reads the value \"duke\".\n@@ -239,1 +239,1 @@\n- *     private static final ExtentLocal<String> NAME = ExtentLocal.newInstance();\n+ *     private static final ScopedValue<String> NAME = ScopedValue.newInstance();\n@@ -241,2 +241,2 @@\n- *     \/\/ @link substring=\"where\" target=\"ExtentLocal#where\" :\n- *     ExtentLocal.where(NAME, \"duke\").run(() -> {\n+ *     \/\/ @link substring=\"where\" target=\"ScopedValue#where\" :\n+ *     ScopedValue.where(NAME, \"duke\").run(() -> {\n@@ -314,1 +314,1 @@\n-     * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n+     * <p> This method captures the current thread's {@linkplain ScopedValue scoped-value}\n@@ -318,1 +318,1 @@\n-     * inheritance of extent-local bindings.\n+     * inheritance of scoped-value bindings.\n@@ -408,1 +408,1 @@\n-     * inherits the current thread's {@linkplain ExtentLocal extent-local} bindings. The\n+     * inherits the current thread's {@linkplain ScopedValue scoped-value} bindings. The\n@@ -437,1 +437,1 @@\n-     * @throws StructureViolationException if the current extent-local bindings are not\n+     * @throws StructureViolationException if the current scoped-value bindings are not\n@@ -674,1 +674,1 @@\n-     * ExtentLocal.Carrier#run(Runnable) operations} with extent-local bindings then\n+     * ScopedValue.Carrier#run(Runnable) operations} with scoped-value bindings then\n@@ -873,1 +873,1 @@\n-         * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n+         * <p> This method captures the current thread's {@linkplain ScopedValue scoped-value}\n@@ -877,1 +877,1 @@\n-         * implicitly for the purpose of inheritance of extent-local bindings.\n+         * implicitly for the purpose of inheritance of scoped-value bindings.\n@@ -1055,1 +1055,1 @@\n-         * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n+         * <p> This method captures the current thread's {@linkplain ScopedValue scoped-value}\n@@ -1059,1 +1059,1 @@\n-         * implicitly for the purpose of inheritance of extent-local bindings.\n+         * implicitly for the purpose of inheritance of scoped-value bindings.\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -800,1 +800,1 @@\n-jdk\/incubator\/concurrent\/ExtentLocal\/Stress.java                            0000000 generic-all\n+jdk\/incubator\/concurrent\/ScopedValue\/Stress.java                            0000000 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,205 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Basic test for ExtentLocal\n- * @modules jdk.incubator.concurrent\n- * @run testng Basic\n- *\/\n-\n-import jdk.incubator.concurrent.ExtentLocal;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.NoSuchElementException;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.*;\n-\n-public class Basic {\n-\n-    @Test\n-    public void testUnbound1() {\n-        ExtentLocal<String> v = ExtentLocal.newInstance();\n-        assertFalse(v.isBound());\n-        assertThrows(NoSuchElementException.class, () -> v.get());\n-    }\n-\n-    @Test\n-    public void testOrElse() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        assertFalse(name.isBound());\n-        assertTrue(name.orElse(null) == null);\n-        assertEquals(name.orElse(\"default\"), \"default\");\n-        ExtentLocal.where(name, \"fred\", () -> {\n-            assertEquals(name.orElse(null), \"fred\");\n-            assertEquals(name.orElse(\"default\"), \"fred\");\n-        });\n-    }\n-\n-    @Test\n-    public void testOrElseThrow() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        assertFalse(name.isBound());\n-        assertThrows(IllegalStateException.class, () -> name.orElseThrow(IllegalStateException::new));\n-        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n-        ExtentLocal.where(name, \"fred\", () -> {\n-            assertEquals(name.orElseThrow(IllegalStateException::new), \"fred\");\n-            assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding1() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        ExtentLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding2() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        ExtentLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            ExtentLocal.where(name, \"joe\", () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(\"joe\".equals(name.get()));\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding3() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        ExtentLocal.where(name, null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding4() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        ExtentLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            ExtentLocal.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding9() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        assertThrows(NullPointerException.class,\n-                     () -> ExtentLocal.where(name, \"fred\", (Runnable) null));\n-    }\n-\n-    @Test\n-    public void testCallWithBinding1() throws Exception {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        int result = ExtentLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value = name.get();\n-            assertTrue(\"fred\".equals(value));\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    @Test\n-    public void testCallWithBinding2() throws Exception {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        int result1 = ExtentLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-\n-            int result2 = ExtentLocal.where(name, \"joe\", () -> {\n-                assertTrue(name.isBound());\n-                String value2 = name.get();\n-                assertTrue(\"joe\".equals(value2));\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    @Test\n-    public void testCallWithBinding3() throws Exception {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        int result = ExtentLocal.where(name, null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    @Test\n-    public void testCallWithBinding4() throws Exception {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        int result1 = ExtentLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-\n-            int result2 = ExtentLocal.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    @Test\n-    public void testCallWithBinding9() throws Exception {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        assertThrows(NullPointerException.class,\n-                     () -> ExtentLocal.where(name, \"fred\", (Callable) null));\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ExtentLocal\/Basic.java","additions":0,"deletions":205,"binary":false,"changes":205,"status":"deleted"},{"patch":"@@ -1,256 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Stress test for ExtentLocal\n- * @modules jdk.incubator.concurrent\n- * @compile --enable-preview -source ${jdk.version} Stress.java\n- * @run testng\/othervm\/timeout=300 -XX:-TieredCompilation --enable-preview Stress\n- * @run testng\/othervm\/timeout=300 --enable-preview Stress\n- *\/\n-\n-import jdk.incubator.concurrent.ExtentLocal;\n-import jdk.incubator.concurrent.StructuredTaskScope;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.concurrent.ThreadFactory;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class Stress {\n-\n-    ExtentLocal<Integer> sl1 = ExtentLocal.newInstance();\n-    ExtentLocal<Integer> sl2 = ExtentLocal.newInstance();\n-\n-    static final ExtentLocal<ThreadFactory> factory = ExtentLocal.newInstance();\n-    static final ExtentLocal.Carrier platformFactoryCarrier = ExtentLocal.where(factory, Thread.ofPlatform().factory());\n-    static final ExtentLocal.Carrier virtualFactoryCarrier = ExtentLocal.where(factory, Thread.ofVirtual().factory());\n-\n-    final ExtentLocal<Integer>[] scopeLocals;\n-\n-    Stress() {\n-        scopeLocals = new ExtentLocal[500];\n-        for (int i = 0; i < scopeLocals.length; i++) {\n-            scopeLocals[i] = ExtentLocal.newInstance();\n-        }\n-    }\n-\n-    private class MyBanger implements Runnable {\n-        final ExtentLocal.Binder binder;\n-        boolean shouldRunOutOfMemory;\n-        boolean failed = false;\n-\n-        MyBanger(ExtentLocal.Binder binder, boolean shouldRunOutOfMemory) {\n-            this.binder = binder;\n-            this.shouldRunOutOfMemory = shouldRunOutOfMemory;\n-        }\n-\n-        volatile int a[][] = new int[10000][];\n-\n-        public void runOutOfMemory(int base, int size) {\n-            for (int i = base; i < a.length; i++) {\n-                try {\n-                    a[i] = new int[size];\n-                } catch (OutOfMemoryError e) {\n-                    size \/= 2;\n-                    if (size == 0) {\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-\n-        public void run() {\n-            int n = sl1.get();\n-            try {\n-                ExtentLocal.where(sl1, n + 1).run(this);\n-            } catch (StackOverflowError e) {\n-                if (sl1.get() != n) {\n-                    failed = true;\n-                }\n-            }\n-            if (shouldRunOutOfMemory) {\n-                runOutOfMemory(0, 0x1000_0000);\n-            }\n-\n-            \/\/ Trigger a StructureViolationException\n-            binder.close();\n-        }\n-\n-    }\n-\n-    public void stackOverflow() {\n-        ExtentLocal.Binder binder = sl2.bind(99);\n-        try {\n-            var myBanger = new MyBanger(binder, false);\n-            try {\n-                ExtentLocal.where(sl1, 0, myBanger);\n-            } catch (RuntimeException e) {\n-                assertFalse(sl1.isBound());\n-            } finally {\n-                binder.close();\n-            }\n-            assertFalse(myBanger.failed);\n-        } finally {\n-            binder.close();\n-        }\n-    }\n-\n-    private int deepBindings(int depth) {\n-        try {\n-            if (depth > 0) {\n-                try (var unused = scopeLocals[depth].bind(depth)) {\n-                    var vx = scopeLocals[depth].get();\n-                    return ExtentLocal.where(sl1, sl1.get() + 1)\n-                            .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n-                            .call(() -> scopeLocals[depth].get() + deepBindings(depth - 1) + sl1.get());\n-                }\n-            } else {\n-                return sl2.get();\n-            }\n-        } catch (Exception foo) {\n-            return 0;\n-        }\n-    }\n-\n-    private void deepBindings() {\n-        int result;\n-        try {\n-            result = ExtentLocal.where(sl2, 42).where(sl1, 99).call(() ->\n-                    deepBindings(scopeLocals.length - 1));\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-        assertEquals(result, 423693);\n-    }\n-\n-    private int deepBindings2(int depth) throws Exception {\n-        if (depth > 0) {\n-            try (var unused = scopeLocals[depth].bind(depth)) {\n-                try (var structuredTaskScope = new StructuredTaskScope<Integer>(null, factory.get())) {\n-                    var future = structuredTaskScope.fork(\n-                            () -> ExtentLocal.where(sl1, sl1.get() + 1)\n-                                    .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n-                                    .call(() -> scopeLocals[depth].get() + deepBindings2(depth - 1) + sl1.get()));\n-                    structuredTaskScope.join();\n-                    return future.get();\n-                }\n-            }\n-        } else {\n-            return sl2.get();\n-        }\n-    }\n-\n-    \/\/ Serious abuse of ExtentLocals. Make sure everything still works,\n-    \/\/ even with a ridiculous number of bindings.\n-    @Test\n-    public void manyExtentLocals() {\n-        ExtentLocal<Object>[] scopeLocals = new ExtentLocal[10_000];\n-        ExtentLocal.Binder[] binders = new ExtentLocal.Binder[scopeLocals.length];\n-\n-        for (int i = 0; i < scopeLocals.length; i++) {\n-            scopeLocals[i] = ExtentLocal.newInstance();\n-            binders[i] = scopeLocals[i].bind(i);\n-        }\n-        long n = 0;\n-        for (var sl : scopeLocals) {\n-            n += (Integer)sl.get();\n-        }\n-        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n-            binders[i].close();\n-        }\n-        assertEquals(n, 49995000);\n-        for (int i = 0; i < scopeLocals.length; i++) {\n-            binders[i] = scopeLocals[i].bind(i);\n-        }\n-        int caught = 0;\n-        \/\/ Trigger StructureViolationExceptions\n-        for (int i = scopeLocals.length - 2; i >= 0; i -= 2) {\n-            try {\n-                binders[i].close();\n-            } catch (StructureViolationException x) {\n-                caught++;\n-            }\n-        }\n-\n-        assertEquals(caught, 5000);\n-\n-        \/\/ They should all be closed now\n-        caught = 0;\n-        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n-            binders[i].close();\n-            try {\n-                binders[i].close();\n-            } catch (StructureViolationException x) {\n-                caught++;\n-            }\n-        }\n-        assertEquals(caught, 0);\n-    }\n-\n-    private void testDeepBindings(ExtentLocal.Carrier factoryCarrier) {\n-        int val = 0;\n-        try (var unused = factoryCarrier.where(sl2, 42).where(sl1, 99).bind()) {\n-            val = deepBindings2(scopeLocals.length - 1);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-        assertEquals(val, 423693);\n-    }\n-\n-    \/\/ Make sure that stack overflows are handled correctly.\n-    \/\/ Run for a while to trigger JIT compilation.\n-    @Test\n-    public void stackOverflowTest() {\n-        assertFalse(sl2.isBound());\n-        for (int i = 0; i < 200; i++) {\n-            try {\n-                stackOverflow();\n-            } catch (Throwable t) {\n-                ;\n-            }\n-            assertFalse(sl2.isBound());\n-        }\n-    }\n-\n-    @Test\n-    public void platformFactorydeepBindings() {\n-        testDeepBindings(platformFactoryCarrier);\n-    }\n-\n-    @Test\n-    public void virtualFactorydeepBindings() {\n-        testDeepBindings(virtualFactoryCarrier);\n-    }\n-\n-    void run() {\n-        manyExtentLocals();\n-        platformFactorydeepBindings();\n-        stackOverflowTest();\n-        virtualFactorydeepBindings();\n-    }\n-\n-    public static void main(String[] args) {\n-        new Stress().run();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ExtentLocal\/Stress.java","additions":0,"deletions":256,"binary":false,"changes":256,"status":"deleted"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic test for ScopedValue\n+ * @modules jdk.incubator.concurrent\n+ * @run testng Basic\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+public class Basic {\n+\n+    @Test\n+    public void testUnbound1() {\n+        ScopedValue<String> v = ScopedValue.newInstance();\n+        assertFalse(v.isBound());\n+        assertThrows(NoSuchElementException.class, () -> v.get());\n+    }\n+\n+    @Test\n+    public void testOrElse() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        assertFalse(name.isBound());\n+        assertTrue(name.orElse(null) == null);\n+        assertEquals(name.orElse(\"default\"), \"default\");\n+        ScopedValue.where(name, \"fred\", () -> {\n+            assertEquals(name.orElse(null), \"fred\");\n+            assertEquals(name.orElse(\"default\"), \"fred\");\n+        });\n+    }\n+\n+    @Test\n+    public void testOrElseThrow() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        assertFalse(name.isBound());\n+        assertThrows(IllegalStateException.class, () -> name.orElseThrow(IllegalStateException::new));\n+        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+        ScopedValue.where(name, \"fred\", () -> {\n+            assertEquals(name.orElseThrow(IllegalStateException::new), \"fred\");\n+            assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding1() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        ScopedValue.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding2() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        ScopedValue.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+\n+            ScopedValue.where(name, \"joe\", () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(\"joe\".equals(name.get()));\n+            });\n+\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding3() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        ScopedValue.where(name, null, () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(name.get() == null);\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding4() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        ScopedValue.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+\n+            ScopedValue.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+            });\n+\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding9() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        assertThrows(NullPointerException.class,\n+                     () -> ScopedValue.where(name, \"fred\", (Runnable) null));\n+    }\n+\n+    @Test\n+    public void testCallWithBinding1() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        int result = ScopedValue.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value = name.get();\n+            assertTrue(\"fred\".equals(value));\n+            return 1;\n+        });\n+        assertTrue(result == 1);\n+    }\n+\n+    @Test\n+    public void testCallWithBinding2() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        int result1 = ScopedValue.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value1 = name.get();\n+            assertTrue(\"fred\".equals(value1));\n+\n+            int result2 = ScopedValue.where(name, \"joe\", () -> {\n+                assertTrue(name.isBound());\n+                String value2 = name.get();\n+                assertTrue(\"joe\".equals(value2));\n+                return 2;\n+            });\n+            assertTrue(result2 == 2);\n+\n+            return 1;\n+        });\n+        assertTrue(result1 == 1);\n+    }\n+\n+    @Test\n+    public void testCallWithBinding3() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        int result = ScopedValue.where(name, null, () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(name.get() == null);\n+            return 1;\n+        });\n+        assertTrue(result == 1);\n+    }\n+\n+    @Test\n+    public void testCallWithBinding4() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        int result1 = ScopedValue.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value1 = name.get();\n+            assertTrue(\"fred\".equals(value1));\n+\n+            int result2 = ScopedValue.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+                return 2;\n+            });\n+            assertTrue(result2 == 2);\n+\n+            return 1;\n+        });\n+        assertTrue(result1 == 1);\n+    }\n+\n+    @Test\n+    public void testCallWithBinding9() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        assertThrows(NullPointerException.class,\n+                     () -> ScopedValue.where(name, \"fred\", (Callable) null));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/Basic.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Stress test for ScopedValue\n+ * @modules jdk.incubator.concurrent\n+ * @compile --enable-preview -source ${jdk.version} Stress.java\n+ * @run testng\/othervm\/timeout=300 -XX:-TieredCompilation --enable-preview Stress\n+ * @run testng\/othervm\/timeout=300 --enable-preview Stress\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.concurrent.ThreadFactory;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class Stress {\n+\n+    ScopedValue<Integer> sl1 = ScopedValue.newInstance();\n+    ScopedValue<Integer> sl2 = ScopedValue.newInstance();\n+\n+    static final ScopedValue<ThreadFactory> factory = ScopedValue.newInstance();\n+    static final ScopedValue.Carrier platformFactoryCarrier = ScopedValue.where(factory, Thread.ofPlatform().factory());\n+    static final ScopedValue.Carrier virtualFactoryCarrier = ScopedValue.where(factory, Thread.ofVirtual().factory());\n+\n+    final ScopedValue<Integer>[] scopeLocals;\n+\n+    Stress() {\n+        scopeLocals = new ScopedValue[500];\n+        for (int i = 0; i < scopeLocals.length; i++) {\n+            scopeLocals[i] = ScopedValue.newInstance();\n+        }\n+    }\n+\n+    private class MyBanger implements Runnable {\n+        final ScopedValue.Binder binder;\n+        boolean shouldRunOutOfMemory;\n+        boolean failed = false;\n+\n+        MyBanger(ScopedValue.Binder binder, boolean shouldRunOutOfMemory) {\n+            this.binder = binder;\n+            this.shouldRunOutOfMemory = shouldRunOutOfMemory;\n+        }\n+\n+        volatile int a[][] = new int[10000][];\n+\n+        public void runOutOfMemory(int base, int size) {\n+            for (int i = base; i < a.length; i++) {\n+                try {\n+                    a[i] = new int[size];\n+                } catch (OutOfMemoryError e) {\n+                    size \/= 2;\n+                    if (size == 0) {\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        public void run() {\n+            int n = sl1.get();\n+            try {\n+                ScopedValue.where(sl1, n + 1).run(this);\n+            } catch (StackOverflowError e) {\n+                if (sl1.get() != n) {\n+                    failed = true;\n+                }\n+            }\n+            if (shouldRunOutOfMemory) {\n+                runOutOfMemory(0, 0x1000_0000);\n+            }\n+\n+            \/\/ Trigger a StructureViolationException\n+            binder.close();\n+        }\n+\n+    }\n+\n+    public void stackOverflow() {\n+        ScopedValue.Binder binder = sl2.bind(99);\n+        try {\n+            var myBanger = new MyBanger(binder, false);\n+            try {\n+                ScopedValue.where(sl1, 0, myBanger);\n+            } catch (RuntimeException e) {\n+                assertFalse(sl1.isBound());\n+            } finally {\n+                binder.close();\n+            }\n+            assertFalse(myBanger.failed);\n+        } finally {\n+            binder.close();\n+        }\n+    }\n+\n+    private int deepBindings(int depth) {\n+        try {\n+            if (depth > 0) {\n+                try (var unused = scopeLocals[depth].bind(depth)) {\n+                    var vx = scopeLocals[depth].get();\n+                    return ScopedValue.where(sl1, sl1.get() + 1)\n+                            .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n+                            .call(() -> scopeLocals[depth].get() + deepBindings(depth - 1) + sl1.get());\n+                }\n+            } else {\n+                return sl2.get();\n+            }\n+        } catch (Exception foo) {\n+            return 0;\n+        }\n+    }\n+\n+    private void deepBindings() {\n+        int result;\n+        try {\n+            result = ScopedValue.where(sl2, 42).where(sl1, 99).call(() ->\n+                    deepBindings(scopeLocals.length - 1));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        assertEquals(result, 423693);\n+    }\n+\n+    private int deepBindings2(int depth) throws Exception {\n+        if (depth > 0) {\n+            try (var unused = scopeLocals[depth].bind(depth)) {\n+                try (var structuredTaskScope = new StructuredTaskScope<Integer>(null, factory.get())) {\n+                    var future = structuredTaskScope.fork(\n+                            () -> ScopedValue.where(sl1, sl1.get() + 1)\n+                                    .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n+                                    .call(() -> scopeLocals[depth].get() + deepBindings2(depth - 1) + sl1.get()));\n+                    structuredTaskScope.join();\n+                    return future.get();\n+                }\n+            }\n+        } else {\n+            return sl2.get();\n+        }\n+    }\n+\n+    \/\/ Serious abuse of ScopedValues. Make sure everything still works,\n+    \/\/ even with a ridiculous number of bindings.\n+    @Test\n+    public void manyScopedValues() {\n+        ScopedValue<Object>[] scopeLocals = new ScopedValue[10_000];\n+        ScopedValue.Binder[] binders = new ScopedValue.Binder[scopeLocals.length];\n+\n+        for (int i = 0; i < scopeLocals.length; i++) {\n+            scopeLocals[i] = ScopedValue.newInstance();\n+            binders[i] = scopeLocals[i].bind(i);\n+        }\n+        long n = 0;\n+        for (var sl : scopeLocals) {\n+            n += (Integer)sl.get();\n+        }\n+        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n+            binders[i].close();\n+        }\n+        assertEquals(n, 49995000);\n+        for (int i = 0; i < scopeLocals.length; i++) {\n+            binders[i] = scopeLocals[i].bind(i);\n+        }\n+        int caught = 0;\n+        \/\/ Trigger StructureViolationExceptions\n+        for (int i = scopeLocals.length - 2; i >= 0; i -= 2) {\n+            try {\n+                binders[i].close();\n+            } catch (StructureViolationException x) {\n+                caught++;\n+            }\n+        }\n+\n+        assertEquals(caught, 5000);\n+\n+        \/\/ They should all be closed now\n+        caught = 0;\n+        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n+            binders[i].close();\n+            try {\n+                binders[i].close();\n+            } catch (StructureViolationException x) {\n+                caught++;\n+            }\n+        }\n+        assertEquals(caught, 0);\n+    }\n+\n+    private void testDeepBindings(ScopedValue.Carrier factoryCarrier) {\n+        int val = 0;\n+        try (var unused = factoryCarrier.where(sl2, 42).where(sl1, 99).bind()) {\n+            val = deepBindings2(scopeLocals.length - 1);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        assertEquals(val, 423693);\n+    }\n+\n+    \/\/ Make sure that stack overflows are handled correctly.\n+    \/\/ Run for a while to trigger JIT compilation.\n+    @Test\n+    public void stackOverflowTest() {\n+        assertFalse(sl2.isBound());\n+        for (int i = 0; i < 200; i++) {\n+            try {\n+                stackOverflow();\n+            } catch (Throwable t) {\n+                ;\n+            }\n+            assertFalse(sl2.isBound());\n+        }\n+    }\n+\n+    @Test\n+    public void platformFactorydeepBindings() {\n+        testDeepBindings(platformFactoryCarrier);\n+    }\n+\n+    @Test\n+    public void virtualFactorydeepBindings() {\n+        testDeepBindings(virtualFactoryCarrier);\n+    }\n+\n+    void run() {\n+        manyScopedValues();\n+        platformFactorydeepBindings();\n+        stackOverflowTest();\n+        virtualFactorydeepBindings();\n+    }\n+\n+    public static void main(String[] args) {\n+        new Stress().run();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/Stress.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Basic tests for StructuredTaskScope with extent-locals\n- * @enablePreview\n- * @modules jdk.incubator.concurrent\n- * @run testng ExtentLocalsTest\n- *\/\n-\n-import jdk.incubator.concurrent.ExtentLocal;\n-import jdk.incubator.concurrent.StructuredTaskScope;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class ExtentLocalsTest {\n-\n-    \/**\n-     * Test that fork inherits extent-local bindings.\n-     *\/\n-    @Test\n-    public void testForkInheritsExtentLocals1() throws Exception {\n-        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n-        String value = ExtentLocal.where(NAME, \"x\").call(() -> {\n-            try (var scope = new StructuredTaskScope()) {\n-                Future<String> future = scope.fork(() -> {\n-                    \/\/ child\n-                    return NAME.get();\n-                });\n-                scope.join();\n-                return future.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"x\");\n-    }\n-\n-    \/**\n-     * Test that fork inherits extent-local bindings into a grandchild.\n-     *\/\n-    @Test\n-    public void testForkInheritsExtentLocals2() throws Exception {\n-        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n-        String value = ExtentLocal.where(NAME, \"x\").call(() -> {\n-            try (var scope1 = new StructuredTaskScope()) {\n-                Future<String> future1 = scope1.fork(() -> {\n-                    try (var scope2 = new StructuredTaskScope()) {\n-                        Future<String> future2 = scope2.fork(() -> {\n-                            \/\/ grandchild\n-                            return NAME.get();\n-                        });\n-                        scope2.join();\n-                        return future2.resultNow();\n-                    }\n-                });\n-                scope1.join();\n-                return future1.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"x\");\n-    }\n-\n-    \/**\n-     * Test exiting an extent local operation closes the thread flock of a nested scope\n-     * and throws StructureViolationException.\n-     *\/\n-    @Test\n-    public void testStructureViolation1() throws Exception {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        class Box {\n-            StructuredTaskScope<Object> scope;\n-        }\n-        var box = new Box();\n-        try {\n-            try {\n-                ExtentLocal.where(name, \"x\").run(() -> {\n-                    box.scope = new StructuredTaskScope();\n-                });\n-                fail();\n-            } catch (StructureViolationException expected) { }\n-\n-            \/\/ underlying flock should be closed, fork should return a cancelled task\n-            StructuredTaskScope<Object> scope = box.scope;\n-            AtomicBoolean ran = new AtomicBoolean();\n-            Future<String> future = scope.fork(() -> {\n-                ran.set(true);\n-                return null;\n-            });\n-            assertTrue(future.isCancelled());\n-            scope.join();\n-            assertFalse(ran.get());\n-\n-        } finally {\n-            StructuredTaskScope<Object> scope = box.scope;\n-            if (scope != null) {\n-                scope.close();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test that fork throws StructureViolationException if extent-local bindings\n-     * created after StructuredTaskScope is created.\n-     *\/\n-    @Test\n-    public void testStructureViolation2() throws Exception {\n-        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n-\n-        try (var scope = new StructuredTaskScope()) {\n-            ExtentLocal.where(NAME, \"x\").run(() -> {\n-                assertThrows(StructureViolationException.class,\n-                        () -> scope.fork(() -> \"foo\"));\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test that fork throws StructureViolationException if extent-local bindings\n-     * change after StructuredTaskScope is created.\n-     *\/\n-    @Test\n-    public void testStructureViolation3() throws Exception {\n-        ExtentLocal<String> NAME1 = ExtentLocal.newInstance();\n-        ExtentLocal<String> NAME2 = ExtentLocal.newInstance();\n-\n-        \/\/ re-bind\n-        ExtentLocal.where(NAME1, \"x\").run(() -> {\n-            try (var scope = new StructuredTaskScope()) {\n-                ExtentLocal.where(NAME1, \"y\").run(() -> {\n-                    assertThrows(StructureViolationException.class,\n-                            () -> scope.fork(() -> \"foo\"));\n-                });\n-            }\n-        });\n-\n-        \/\/ new binding\n-        ExtentLocal.where(NAME1, \"x\").run(() -> {\n-            try (var scope = new StructuredTaskScope()) {\n-                ExtentLocal.where(NAME2, \"y\").run(() -> {\n-                    assertThrows(StructureViolationException.class,\n-                            () -> scope.fork(() -> \"foo\"));\n-                });\n-            }\n-        });\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/ExtentLocalsTest.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Basic tests for StructuredTaskScope with scoped-values\n+ * @enablePreview\n+ * @modules jdk.incubator.concurrent\n+ * @run testng ScopedValuesTest\n+ *\/\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class ScopedValuesTest {\n+\n+    \/**\n+     * Test that fork inherits scoped-value bindings.\n+     *\/\n+    @Test\n+    public void testForkInheritsScopedValues1() throws Exception {\n+        ScopedValue<String> NAME = ScopedValue.newInstance();\n+        String value = ScopedValue.where(NAME, \"x\").call(() -> {\n+            try (var scope = new StructuredTaskScope()) {\n+                Future<String> future = scope.fork(() -> {\n+                    \/\/ child\n+                    return NAME.get();\n+                });\n+                scope.join();\n+                return future.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits scoped-value bindings into a grandchild.\n+     *\/\n+    @Test\n+    public void testForkInheritsScopedValues2() throws Exception {\n+        ScopedValue<String> NAME = ScopedValue.newInstance();\n+        String value = ScopedValue.where(NAME, \"x\").call(() -> {\n+            try (var scope1 = new StructuredTaskScope()) {\n+                Future<String> future1 = scope1.fork(() -> {\n+                    try (var scope2 = new StructuredTaskScope()) {\n+                        Future<String> future2 = scope2.fork(() -> {\n+                            \/\/ grandchild\n+                            return NAME.get();\n+                        });\n+                        scope2.join();\n+                        return future2.resultNow();\n+                    }\n+                });\n+                scope1.join();\n+                return future1.resultNow();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test exiting an scoped value operation closes the thread flock of a nested scope\n+     * and throws StructureViolationException.\n+     *\/\n+    @Test\n+    public void testStructureViolation1() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            StructuredTaskScope<Object> scope;\n+        }\n+        var box = new Box();\n+        try {\n+            try {\n+                ScopedValue.where(name, \"x\").run(() -> {\n+                    box.scope = new StructuredTaskScope();\n+                });\n+                fail();\n+            } catch (StructureViolationException expected) { }\n+\n+            \/\/ underlying flock should be closed, fork should return a cancelled task\n+            StructuredTaskScope<Object> scope = box.scope;\n+            AtomicBoolean ran = new AtomicBoolean();\n+            Future<String> future = scope.fork(() -> {\n+                ran.set(true);\n+                return null;\n+            });\n+            assertTrue(future.isCancelled());\n+            scope.join();\n+            assertFalse(ran.get());\n+\n+        } finally {\n+            StructuredTaskScope<Object> scope = box.scope;\n+            if (scope != null) {\n+                scope.close();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that fork throws StructureViolationException if scoped-value bindings\n+     * created after StructuredTaskScope is created.\n+     *\/\n+    @Test\n+    public void testStructureViolation2() throws Exception {\n+        ScopedValue<String> NAME = ScopedValue.newInstance();\n+\n+        try (var scope = new StructuredTaskScope()) {\n+            ScopedValue.where(NAME, \"x\").run(() -> {\n+                assertThrows(StructureViolationException.class,\n+                        () -> scope.fork(() -> \"foo\"));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test that fork throws StructureViolationException if scoped-value bindings\n+     * change after StructuredTaskScope is created.\n+     *\/\n+    @Test\n+    public void testStructureViolation3() throws Exception {\n+        ScopedValue<String> NAME1 = ScopedValue.newInstance();\n+        ScopedValue<String> NAME2 = ScopedValue.newInstance();\n+\n+        \/\/ re-bind\n+        ScopedValue.where(NAME1, \"x\").run(() -> {\n+            try (var scope = new StructuredTaskScope()) {\n+                ScopedValue.where(NAME1, \"y\").run(() -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+\n+        \/\/ new binding\n+        ScopedValue.where(NAME1, \"x\").run(() -> {\n+            try (var scope = new StructuredTaskScope()) {\n+                ScopedValue.where(NAME2, \"y\").run(() -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/ScopedValuesTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"},{"patch":"@@ -1,209 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test ThreadFlock with extent locals\n- * @enablePreview\n- * @modules java.base\/jdk.internal.misc\n- * @modules jdk.incubator.concurrent\n- * @run testng ExtentLocalsTest\n- *\/\n-\n-import java.util.*;\n-import java.util.concurrent.*;\n-import java.util.concurrent.atomic.AtomicReference;\n-import jdk.internal.misc.ThreadFlock;\n-import jdk.incubator.concurrent.ExtentLocal;\n-import jdk.incubator.concurrent.StructureViolationException;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class ExtentLocalsTest {\n-\n-    @DataProvider(name = \"factories\")\n-    public Object[][] factories() {\n-        var defaultThreadFactory = Executors.defaultThreadFactory();\n-        var virtualThreadFactory = Thread.ofVirtual().factory();\n-        return new Object[][]{\n-                { defaultThreadFactory, },\n-                { virtualThreadFactory, },\n-        };\n-    }\n-\n-    \/**\n-     * Test inheritance of extent-local bindings.\n-     *\/\n-    @Test(dataProvider = \"factories\")\n-    public void testInheritsExtentLocals(ThreadFactory factory) throws Exception {\n-        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n-        String value = ExtentLocal.where(NAME, \"fred\").call(() -> {\n-            var result = new AtomicReference<String>();\n-            try (var flock = ThreadFlock.open(null)) {\n-                Thread thread = factory.newThread(() -> {\n-                    \/\/ child\n-                    result.set(NAME.get());\n-                });\n-                flock.start(thread);\n-            }\n-            return result.get();\n-        });\n-        assertEquals(value, \"fred\");\n-    }\n-\n-    \/**\n-     * Test exiting a extent local operation should close nested thread flocks.\n-     *\/\n-    @Test\n-    public void testStructureViolation1() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        class Box {\n-            ThreadFlock flock1;\n-            ThreadFlock flock2;\n-        }\n-        var box = new Box();\n-        try {\n-            ExtentLocal.where(name, \"x1\").run(() -> {\n-                box.flock1 = ThreadFlock.open(null);\n-                box.flock2 = ThreadFlock.open(null);\n-            });\n-            fail();\n-        } catch (StructureViolationException expected) { }\n-        assertTrue(box.flock1.isClosed());\n-        assertTrue(box.flock2.isClosed());\n-    }\n-\n-    \/**\n-     * Test closing a thread flock with enclosing extent local operations and\n-     * thread flocks. This test closes enclosing flock1.\n-     *\/\n-    @Test\n-    public void testStructureViolation2() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n-            ExtentLocal.where(name, \"x1\").run(() -> {\n-                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n-                    ExtentLocal.where(name, \"x2\").run(() -> {\n-                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n-                            ExtentLocal.where(name, \"x3\").run(() -> {\n-                                var flock4 = ThreadFlock.open(\"flock4\");\n-\n-                                try {\n-                                    flock1.close();\n-                                    fail();\n-                                } catch (StructureViolationException expected) { }\n-\n-                                assertTrue(flock1.isClosed());\n-                                assertTrue(flock2.isClosed());\n-                                assertTrue(flock3.isClosed());\n-                                assertTrue(flock4.isClosed());\n-\n-                            });\n-                        }\n-                    });\n-                }\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test closing a thread flock with enclosing extent local operations and\n-     * thread flocks. This test closes enclosing flock2.\n-     *\/\n-    @Test\n-    public void testStructureViolation3() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n-            ExtentLocal.where(name, \"x1\").run(() -> {\n-                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n-                    ExtentLocal.where(name, \"x2\").run(() -> {\n-                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n-                            ExtentLocal.where(name, \"x3\").run(() -> {\n-                                var flock4 = ThreadFlock.open(\"flock4\");\n-\n-                                try {\n-                                    flock2.close();\n-                                    fail();\n-                                } catch (StructureViolationException expected) { }\n-\n-                                assertFalse(flock1.isClosed());\n-                                assertTrue(flock2.isClosed());\n-                                assertTrue(flock3.isClosed());\n-                                assertTrue(flock4.isClosed());\n-                            });\n-                        }\n-                    });\n-                }\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test closing a thread flock with enclosing extent local operations and\n-     * thread flocks. This test closes enclosing flock3.\n-     *\/\n-    @Test\n-    public void testStructureViolation4() {\n-        ExtentLocal<String> name = ExtentLocal.newInstance();\n-        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n-            ExtentLocal.where(name, \"x1\").run(() -> {\n-                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n-                    ExtentLocal.where(name, \"x2\").run(() -> {\n-                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n-                            ExtentLocal.where(name, \"x3\").run(() -> {\n-                                var flock4 = ThreadFlock.open(\"flock4\");\n-\n-                                try {\n-                                    flock3.close();\n-                                    fail();\n-                                } catch (StructureViolationException expected) { }\n-\n-                                assertFalse(flock1.isClosed());\n-                                assertFalse(flock2.isClosed());\n-                                assertTrue(flock3.isClosed());\n-                                assertTrue(flock4.isClosed());\n-                            });\n-                        }\n-                    });\n-                }\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test that start throws StructureViolationException if extent-local bindings\n-     * have changed.\n-     *\/\n-    @Test(dataProvider = \"factories\")\n-    public void testStructureViolation5(ThreadFactory factory) throws Exception {\n-        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n-        try (var flock = ThreadFlock.open(null)) {\n-            ExtentLocal.where(NAME, \"fred\").run(() -> {\n-                Thread thread = factory.newThread(() -> { });\n-                expectThrows(StructureViolationException.class, () -> flock.start(thread));\n-            });\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ExtentLocalsTest.java","additions":0,"deletions":209,"binary":false,"changes":209,"status":"deleted"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ThreadFlock with scoped values\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules jdk.incubator.concurrent\n+ * @run testng ScopedValuesTest\n+ *\/\n+\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicReference;\n+import jdk.internal.misc.ThreadFlock;\n+import jdk.incubator.concurrent.ScopedValue;\n+import jdk.incubator.concurrent.StructureViolationException;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class ScopedValuesTest {\n+\n+    @DataProvider(name = \"factories\")\n+    public Object[][] factories() {\n+        var defaultThreadFactory = Executors.defaultThreadFactory();\n+        var virtualThreadFactory = Thread.ofVirtual().factory();\n+        return new Object[][]{\n+                { defaultThreadFactory, },\n+                { virtualThreadFactory, },\n+        };\n+    }\n+\n+    \/**\n+     * Test inheritance of scoped-value bindings.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInheritsScopedValues(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> NAME = ScopedValue.newInstance();\n+        String value = ScopedValue.where(NAME, \"fred\").call(() -> {\n+            var result = new AtomicReference<String>();\n+            try (var flock = ThreadFlock.open(null)) {\n+                Thread thread = factory.newThread(() -> {\n+                    \/\/ child\n+                    result.set(NAME.get());\n+                });\n+                flock.start(thread);\n+            }\n+            return result.get();\n+        });\n+        assertEquals(value, \"fred\");\n+    }\n+\n+    \/**\n+     * Test exiting a scoped value operation should close nested thread flocks.\n+     *\/\n+    @Test\n+    public void testStructureViolation1() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            ThreadFlock flock1;\n+            ThreadFlock flock2;\n+        }\n+        var box = new Box();\n+        try {\n+            ScopedValue.where(name, \"x1\").run(() -> {\n+                box.flock1 = ThreadFlock.open(null);\n+                box.flock2 = ThreadFlock.open(null);\n+            });\n+            fail();\n+        } catch (StructureViolationException expected) { }\n+        assertTrue(box.flock1.isClosed());\n+        assertTrue(box.flock2.isClosed());\n+    }\n+\n+    \/**\n+     * Test closing a thread flock with enclosing scoped value operations and\n+     * thread flocks. This test closes enclosing flock1.\n+     *\/\n+    @Test\n+    public void testStructureViolation2() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\").run(() -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\").run(() -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\").run(() -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock1.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertTrue(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock with enclosing scoped value operations and\n+     * thread flocks. This test closes enclosing flock2.\n+     *\/\n+    @Test\n+    public void testStructureViolation3() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\").run(() -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\").run(() -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\").run(() -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock2.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock with enclosing scoped value operations and\n+     * thread flocks. This test closes enclosing flock3.\n+     *\/\n+    @Test\n+    public void testStructureViolation4() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ScopedValue.where(name, \"x1\").run(() -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ScopedValue.where(name, \"x2\").run(() -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ScopedValue.where(name, \"x3\").run(() -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock3.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertFalse(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test that start throws StructureViolationException if scoped-value bindings\n+     * have changed.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testStructureViolation5(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> NAME = ScopedValue.newInstance();\n+        try (var flock = ThreadFlock.open(null)) {\n+            ScopedValue.where(NAME, \"fred\").run(() -> {\n+                Thread thread = factory.newThread(() -> { });\n+                expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ScopedValuesTest.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 2022, red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n-\n-import jdk.incubator.concurrent.ExtentLocal;\n-import java.util.concurrent.TimeUnit;\n-import org.openjdk.jmh.annotations.*;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import static org.openjdk.bench.jdk.incubator.concurrent.ExtentLocalsData.*;\n-\n-\/**\n- * Tests ExtentLocal\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@Warmup(iterations=4, time=1)\n-@Measurement(iterations=10, time=1)\n-@Threads(1)\n-@Fork(value = 1,\n-      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ExtentLocalsExecutorService\",\n-                        \"-Djmh.executor=CUSTOM\",\n-                        \"-Djmh.blackhole.mode=COMPILER\",\n-                        \"--add-modules=jdk.incubator.concurrent\",\n-                        \"--enable-preview\"})\n-@State(Scope.Thread)\n-@SuppressWarnings(\"preview\")\n-public class ExtentLocals {\n-\n-    private static final Integer THE_ANSWER = 42;\n-\n-    \/\/ Test 1: make sure ExtentLocal.get() is hoisted out of loops.\n-\n-    @Benchmark\n-    public void thousandAdds_ExtentLocal(Blackhole bh) throws Exception {\n-        int result = 0;\n-        for (int i = 0; i < 1_000; i++) {\n-            result += ExtentLocalsData.sl1.get();\n-        }\n-        bh.consume(result);\n-    }\n-\n-    @Benchmark\n-    public void thousandAdds_ThreadLocal(Blackhole bh) throws Exception {\n-        int result = 0;\n-        for (int i = 0; i < 1_000; i++) {\n-            result += ExtentLocalsData.tl1.get();\n-        }\n-        bh.consume(result);\n-    }\n-\n-    \/\/ Test 2: stress the ExtentLocal cache.\n-    \/\/ The idea here is to use a bunch of bound values cyclically, which\n-    \/\/ stresses the ExtentLocal cache.\n-\n-    int combine(int n, int i1, int i2, int i3, int i4, int i5, int i6) {\n-        return n + ((i1 ^ i2 >>> 6) + (i3 << 7) + i4 - i5 | i6);\n-    }\n-\n-    @Benchmark\n-    public int sixValues_ExtentLocal() throws Exception {\n-        int result = 0;\n-        for (int i = 0 ; i < 166; i++) {\n-            result = combine(result, sl1.get(), sl2.get(), sl3.get(), sl4.get(), sl5.get(), sl6.get());\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public int sixValues_ThreadLocal() throws Exception {\n-        int result = 0;\n-        for (int i = 0 ; i < 166; i++) {\n-            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n-        }\n-        return result;\n-    }\n-\n-    \/\/ Test 3: The cost of bind, then get\n-    \/\/ This is the worst case for ExtentLocals because we have to create\n-    \/\/ a binding, link it in, then search the current bindings. In addition, we\n-    \/\/ create a cache entry for the bound value, then we immediately have to\n-    \/\/ destroy it.\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int CreateBindThenGetThenRemove_ExtentLocal() throws Exception {\n-        return ExtentLocal.where(sl1, THE_ANSWER).call(sl1::get);\n-    }\n-\n-\n-    \/\/ Create a Carrier ahead of time: might be slightly faster\n-    private static final ExtentLocal.Carrier HOLD_42 = ExtentLocal.where(sl1, 42);\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int bindThenGetThenRemove_ExtentLocal() throws Exception {\n-        return HOLD_42.call(sl1::get);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int bindThenGetThenRemove_ThreadLocal() throws Exception {\n-        try {\n-            tl1.set(THE_ANSWER);\n-            return tl1.get();\n-        } finally {\n-            tl1.remove();\n-        }\n-    }\n-\n-    \/\/ This has no exact equivalent in ExtentLocal, but it's provided here for\n-    \/\/ information.\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int bindThenGetNoRemove_ThreadLocal() throws Exception {\n-        tl1.set(THE_ANSWER);\n-        return tl1.get();\n-    }\n-\n-    \/\/ Test 4: The cost of binding, but not using any result\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public Object bind_ExtentLocal() throws Exception {\n-        return HOLD_42.call(this::getClass);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public Object bind_ThreadLocal() throws Exception {\n-        try {\n-            tl1.set(THE_ANSWER);\n-            return this.getClass();\n-        } finally {\n-            tl1.remove();\n-        }\n-    }\n-\n-    \/\/ Simply set a ThreadLocal so that the caller can see it\n-    \/\/ This has no exact equivalent in ExtentLocal, but it's provided here for\n-    \/\/ information.\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void setNoRemove_ThreadLocal() throws Exception {\n-        tl1.set(THE_ANSWER);\n-    }\n-\n-    \/\/ This is the closest I can think of to setNoRemove_ThreadLocal in that it\n-    \/\/ returns a value in a ExtentLocal container. The container must already\n-    \/\/ be bound to an AtomicReference for this to work.\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void setNoRemove_ExtentLocal() throws Exception {\n-        sl_atomicRef.get().setPlain(THE_ANSWER);\n-    }\n-\n-    \/\/ Test 5: A simple counter\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void counter_ExtentLocal() {\n-        sl_atomicInt.get().setPlain(\n-                sl_atomicInt.get().getPlain() + 1);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void counter_ThreadLocal() {\n-        \/\/ Very slow:\n-        \/\/ tl1.set(tl1.get() + 1);\n-        var ctr = tl_atomicInt.get();\n-        ctr.setPlain(ctr.getPlain() + 1);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ExtentLocals.java","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n-\n-import jdk.incubator.concurrent.ExtentLocal;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-@SuppressWarnings(\"preview\")\n-public class ExtentLocalsData {\n-\n-    static final ExtentLocal<Integer> sl1 = ExtentLocal.newInstance();\n-    static final ThreadLocal<Integer> tl1 = new ThreadLocal<>();\n-\n-    static final ExtentLocal<Integer> sl2 = ExtentLocal.newInstance();\n-    static final ExtentLocal<Integer> sl3 = ExtentLocal.newInstance();\n-    static final ExtentLocal<Integer> sl4 = ExtentLocal.newInstance();\n-    static final ExtentLocal<Integer> sl5 = ExtentLocal.newInstance();\n-    static final ExtentLocal<Integer> sl6 = ExtentLocal.newInstance();\n-    static final ExtentLocal<AtomicInteger> sl_atomicInt = ExtentLocal.newInstance();\n-\n-    static final ExtentLocal<Integer> unbound = ExtentLocal.newInstance();\n-\n-    static final ExtentLocal<AtomicReference<Integer>> sl_atomicRef = ExtentLocal.newInstance();\n-\n-    static final ThreadLocal<Integer> tl2 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl3 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl4 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl5 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl6 = new ThreadLocal<>();\n-    static final ThreadLocal<AtomicInteger> tl_atomicInt = new ThreadLocal<>();\n-\n-    static final ExtentLocal.Carrier VALUES = ExtentLocal\n-            .where(sl1, 42).where(sl2, 2).where(sl3, 3)\n-            .where(sl4, 4).where(sl5, 5).where(sl6, 6);\n-\n-    public static void run(Runnable action) {\n-        try {\n-            tl1.set(42); tl2.set(2); tl3.set(3); tl4.set(4); tl5.set(5); tl6.set(6);\n-            tl1.get();  \/\/ Create the ExtentLocal cache as a side effect\n-            tl_atomicInt.set(new AtomicInteger());\n-            VALUES.where(sl_atomicInt, new AtomicInteger())\n-                  .where(sl_atomicRef, new AtomicReference<>())\n-                  .run(action);\n-        } finally {\n-            tl1.remove(); tl2.remove(); tl3.remove(); tl4.remove(); tl5.remove(); tl6.remove();\n-            tl_atomicInt.remove();\n-        }\n-    }\n-}\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ExtentLocalsData.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n-\n-import java.util.concurrent.*;\n-\n-public class ExtentLocalsExecutorService extends ThreadPoolExecutor {\n-    public ExtentLocalsExecutorService(int corePoolSize, String prefix) {\n-        super(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),\n-              new AThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n-    }\n-}\n-\n-class AThreadFactory implements ThreadFactory {\n-    public Thread newThread(Runnable action) {\n-        return new Thread() {\n-            public void run() {\n-                ExtentLocalsData.run(action);\n-            }\n-        };\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ExtentLocalsExecutorService.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2022, red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesData.*;\n+\n+\/**\n+ * Tests ScopedValue\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations=4, time=1)\n+@Measurement(iterations=10, time=1)\n+@Threads(1)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesExecutorService\",\n+                        \"-Djmh.executor=CUSTOM\",\n+                        \"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--add-modules=jdk.incubator.concurrent\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class ScopedValues {\n+\n+    private static final Integer THE_ANSWER = 42;\n+\n+    \/\/ Test 1: make sure ScopedValue.get() is hoisted out of loops.\n+\n+    @Benchmark\n+    public void thousandAdds_ScopedValue(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.sl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    @Benchmark\n+    public void thousandAdds_ThreadLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.tl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ Test 2: stress the ScopedValue cache.\n+    \/\/ The idea here is to use a bunch of bound values cyclically, which\n+    \/\/ stresses the ScopedValue cache.\n+\n+    int combine(int n, int i1, int i2, int i3, int i4, int i5, int i6) {\n+        return n + ((i1 ^ i2 >>> 6) + (i3 << 7) + i4 - i5 | i6);\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ScopedValue() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, sl1.get(), sl2.get(), sl3.get(), sl4.get(), sl5.get(), sl6.get());\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ThreadLocal() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Test 3: The cost of bind, then get\n+    \/\/ This is the worst case for ScopedValues because we have to create\n+    \/\/ a binding, link it in, then search the current bindings. In addition, we\n+    \/\/ create a cache entry for the bound value, then we immediately have to\n+    \/\/ destroy it.\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int CreateBindThenGetThenRemove_ScopedValue() throws Exception {\n+        return ScopedValue.where(sl1, THE_ANSWER).call(sl1::get);\n+    }\n+\n+\n+    \/\/ Create a Carrier ahead of time: might be slightly faster\n+    private static final ScopedValue.Carrier HOLD_42 = ScopedValue.where(sl1, 42);\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ScopedValue() throws Exception {\n+        return HOLD_42.call(sl1::get);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return tl1.get();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+        return tl1.get();\n+    }\n+\n+    \/\/ Test 4: The cost of binding, but not using any result\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ScopedValue() throws Exception {\n+        return HOLD_42.call(this::getClass);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return this.getClass();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ Simply set a ThreadLocal so that the caller can see it\n+    \/\/ This has no exact equivalent in ScopedValue, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+    }\n+\n+    \/\/ This is the closest I can think of to setNoRemove_ThreadLocal in that it\n+    \/\/ returns a value in a ScopedValue container. The container must already\n+    \/\/ be bound to an AtomicReference for this to work.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ScopedValue() throws Exception {\n+        sl_atomicRef.get().setPlain(THE_ANSWER);\n+    }\n+\n+    \/\/ Test 5: A simple counter\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ScopedValue() {\n+        sl_atomicInt.get().setPlain(\n+                sl_atomicInt.get().getPlain() + 1);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ThreadLocal() {\n+        \/\/ Very slow:\n+        \/\/ tl1.set(tl1.get() + 1);\n+        var ctr = tl_atomicInt.get();\n+        ctr.setPlain(ctr.getPlain() + 1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValues.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+@SuppressWarnings(\"preview\")\n+public class ScopedValuesData {\n+\n+    static final ScopedValue<Integer> sl1 = ScopedValue.newInstance();\n+    static final ThreadLocal<Integer> tl1 = new ThreadLocal<>();\n+\n+    static final ScopedValue<Integer> sl2 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl3 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl4 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl5 = ScopedValue.newInstance();\n+    static final ScopedValue<Integer> sl6 = ScopedValue.newInstance();\n+    static final ScopedValue<AtomicInteger> sl_atomicInt = ScopedValue.newInstance();\n+\n+    static final ScopedValue<Integer> unbound = ScopedValue.newInstance();\n+\n+    static final ScopedValue<AtomicReference<Integer>> sl_atomicRef = ScopedValue.newInstance();\n+\n+    static final ThreadLocal<Integer> tl2 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl3 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl4 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl5 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl6 = new ThreadLocal<>();\n+    static final ThreadLocal<AtomicInteger> tl_atomicInt = new ThreadLocal<>();\n+\n+    static final ScopedValue.Carrier VALUES = ScopedValue\n+            .where(sl1, 42).where(sl2, 2).where(sl3, 3)\n+            .where(sl4, 4).where(sl5, 5).where(sl6, 6);\n+\n+    public static void run(Runnable action) {\n+        try {\n+            tl1.set(42); tl2.set(2); tl3.set(3); tl4.set(4); tl5.set(5); tl6.set(6);\n+            tl1.get();  \/\/ Create the ScopedValue cache as a side effect\n+            tl_atomicInt.set(new AtomicInteger());\n+            VALUES.where(sl_atomicInt, new AtomicInteger())\n+                  .where(sl_atomicRef, new AtomicReference<>())\n+                  .run(action);\n+        } finally {\n+            tl1.remove(); tl2.remove(); tl3.remove(); tl4.remove(); tl5.remove(); tl6.remove();\n+            tl_atomicInt.remove();\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesData.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import java.util.concurrent.*;\n+\n+public class ScopedValuesExecutorService extends ThreadPoolExecutor {\n+    public ScopedValuesExecutorService(int corePoolSize, String prefix) {\n+        super(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),\n+              new AThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n+    }\n+}\n+\n+class AThreadFactory implements ThreadFactory {\n+    public Thread newThread(Runnable action) {\n+        return new Thread() {\n+            public void run() {\n+                ScopedValuesData.run(action);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesExecutorService.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"}]}