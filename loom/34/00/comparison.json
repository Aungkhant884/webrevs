{"files":[{"patch":"@@ -189,2 +189,2 @@\n-JVM_ScopedCache\n-JVM_SetScopedCache\n+JVM_ScopeLocalCache\n+JVM_SetScopeLocalCache\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  case vmIntrinsics::_scopedCache:\n+  case vmIntrinsics::_scopeLocalCache:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1430,1 +1430,1 @@\n-void LIRGenerator::do_scopedCache(Intrinsic* x) {\n+void LIRGenerator::do_scopeLocalCache(Intrinsic* x) {\n@@ -1434,1 +1434,1 @@\n-  __ move(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::scopedCache_offset()), T_ADDRESS), temp);\n+  __ move(new LIR_Address(getThreadPointer(), in_bytes(JavaThread::scopeLocalCache_offset()), T_ADDRESS), temp);\n@@ -3163,1 +3163,1 @@\n-  case vmIntrinsics::_scopedCache:    do_scopedCache(x);   break;\n+  case vmIntrinsics::_scopeLocalCache: do_scopeLocalCache(x); break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-  void do_scopedCache(Intrinsic* x);\n+  void do_scopeLocalCache(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  case vmIntrinsics::_scopedCache:\n+  case vmIntrinsics::_scopeLocalCache:\n@@ -126,2 +126,2 @@\n-  case vmIntrinsics::_scopedCache:\n-  case vmIntrinsics::_setScopedCache:\n+  case vmIntrinsics::_scopeLocalCache:\n+  case vmIntrinsics::_setScopeLocalCache:\n@@ -260,2 +260,2 @@\n-  case vmIntrinsics::_scopedCache:\n-  case vmIntrinsics::_setScopedCache:\n+  case vmIntrinsics::_scopeLocalCache:\n+  case vmIntrinsics::_setScopeLocalCache:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -237,3 +237,3 @@\n-  do_intrinsic(_currentThread,            java_lang_Thread,       currentThread_name, currentThread_signature,   F_S)   \\\n-  do_intrinsic(_scopedCache,              java_lang_Thread,       scopedCache_name, scopedCache_signature,   F_S)       \\\n-  do_intrinsic(_setScopedCache,           java_lang_Thread,       setScopedCache_name, setScopedCache_signature,   F_S) \\\n+  do_intrinsic(_currentThread,            java_lang_Thread,       currentThread_name, currentThread_signature,    F_S)  \\\n+  do_intrinsic(_scopeLocalCache,          java_lang_Thread,       scopeLocalCache_name, scopeLocalCache_signature, F_S)  \\\n+  do_intrinsic(_setScopeLocalCache,       java_lang_Thread,       setScopeLocalCache_name, setScopeLocalCache_signature, F_S) \\\n@@ -243,2 +243,2 @@\n-   do_name(     scopedCache_name,                                \"scopedCache\")                                         \\\n-   do_name(     setScopedCache_name,                             \"setScopedCache\")                                      \\\n+   do_name(     scopeLocalCache_name,                            \"scopeLocalCache\")                                     \\\n+   do_name(     setScopeLocalCache_name,                         \"setScopeLocalCache\")                                  \\\n@@ -247,2 +247,2 @@\n-   do_signature(scopedCache_signature,                           \"()[Ljava\/lang\/Object;\")                               \\\n-   do_signature(setScopedCache_signature,                        \"([Ljava\/lang\/Object;)V\")                              \\\n+   do_signature(scopeLocalCache_signature,                       \"()[Ljava\/lang\/Object;\")                               \\\n+   do_signature(setScopeLocalCache_signature,                    \"([Ljava\/lang\/Object;)V\")                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-JVM_ScopedCache(JNIEnv *env, jclass threadClass);\n+JVM_ScopeLocalCache(JNIEnv *env, jclass threadClass);\n@@ -244,1 +244,1 @@\n-JVM_SetScopedCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+JVM_SetScopeLocalCache(JNIEnv *env, jclass threadClass, jobject theCache);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -590,2 +590,2 @@\n-  case vmIntrinsics::_scopedCache:\n-  case vmIntrinsics::_setScopedCache:\n+  case vmIntrinsics::_scopeLocalCache:\n+  case vmIntrinsics::_setScopeLocalCache:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -471,2 +471,2 @@\n-  case vmIntrinsics::_scopedCache:              return inline_native_scopedCache();\n-  case vmIntrinsics::_setScopedCache:           return inline_native_setScopedCache();\n+  case vmIntrinsics::_scopeLocalCache:          return inline_native_scopeLocalCache();\n+  case vmIntrinsics::_setScopeLocalCache:       return inline_native_setScopeLocalCache();\n@@ -3040,1 +3040,1 @@\n-Node* LibraryCallKit::scopedCache_helper() {\n+Node* LibraryCallKit::scopeLocalCache_helper() {\n@@ -3047,1 +3047,1 @@\n-  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::scopedCache_offset()));\n+  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::scopeLocalCache_offset()));\n@@ -3052,2 +3052,2 @@\n-\/\/------------------------inline_native_scopedCache------------------\n-bool LibraryCallKit::inline_native_scopedCache() {\n+\/\/------------------------inline_native_scopeLocalCache------------------\n+bool LibraryCallKit::inline_native_scopeLocalCache() {\n@@ -3058,1 +3058,1 @@\n-  \/\/ Because we create the scoped cache lazily we have to make the\n+  \/\/ Because we create the scopeLocal cache lazily we have to make the\n@@ -3062,1 +3062,1 @@\n-  Node* cache_obj_handle = scopedCache_helper();\n+  Node* cache_obj_handle = scopeLocalCache_helper();\n@@ -3068,2 +3068,2 @@\n-\/\/------------------------inline_native_setScopedCache------------------\n-bool LibraryCallKit::inline_native_setScopedCache() {\n+\/\/------------------------inline_native_setScopeLocalCache------------------\n+bool LibraryCallKit::inline_native_setScopeLocalCache() {\n@@ -3071,1 +3071,1 @@\n-  Node* cache_obj_handle = scopedCache_helper();\n+  Node* cache_obj_handle = scopeLocalCache_helper();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -236,3 +236,3 @@\n-  bool inline_native_scopedCache();\n-  Node* scopedCache_helper();\n-  bool inline_native_setScopedCache();\n+  bool inline_native_scopeLocalCache();\n+  Node* scopeLocalCache_helper();\n+  bool inline_native_setScopeLocalCache();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -829,1 +829,1 @@\n-      in_bytes(JavaThread::scopedCache_offset()),\n+      in_bytes(JavaThread::scopeLocalCache_offset()),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3130,2 +3130,2 @@\n-JVM_ENTRY(jobject, JVM_ScopedCache(JNIEnv* env, jclass threadClass))\n-  oop theCache = thread->scopedCache();\n+JVM_ENTRY(jobject, JVM_ScopeLocalCache(JNIEnv* env, jclass threadClass))\n+  oop theCache = thread->scopeLocalCache();\n@@ -3134,1 +3134,1 @@\n-    assert(objs->length() == ScopedCacheSize * 2, \"wrong length\");\n+    assert(objs->length() == ScopeLocalCacheSize * 2, \"wrong length\");\n@@ -3139,1 +3139,1 @@\n-JVM_ENTRY(void, JVM_SetScopedCache(JNIEnv* env, jclass threadClass,\n+JVM_ENTRY(void, JVM_SetScopeLocalCache(JNIEnv* env, jclass threadClass,\n@@ -3143,1 +3143,1 @@\n-    assert(objs->length() == ScopedCacheSize * 2, \"wrong length\");\n+    assert(objs->length() == ScopeLocalCacheSize * 2, \"wrong length\");\n@@ -3145,1 +3145,1 @@\n-  thread->set_scopedCache(objs);\n+  thread->set_scopeLocalCache(objs);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1074,1 +1074,1 @@\n-  _scopedCache = OopHandle(_thread_oop_storage, NULL);\n+  _scopeLocalCache = OopHandle(_thread_oop_storage, NULL);\n@@ -1077,2 +1077,2 @@\n-oop JavaThread::scopedCache() const {\n-  return _scopedCache.resolve();\n+oop JavaThread::scopeLocalCache() const {\n+  return _scopeLocalCache.resolve();\n@@ -1090,1 +1090,1 @@\n-void JavaThread::set_scopedCache(oop p) {\n+void JavaThread::set_scopeLocalCache(oop p) {\n@@ -1092,1 +1092,1 @@\n-  _scopedCache.replace(p);\n+  _scopeLocalCache.replace(p);\n@@ -2310,1 +2310,1 @@\n-        ScopeDesc* sd = nm->scope_desc_at(pc);\n+        ScopeLocalesc* sd = nm->scope_desc_at(pc);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -885,1 +885,1 @@\n-  OopHandle      _scopedCache;\n+  OopHandle      _scopeLocalCache;\n@@ -1102,1 +1102,1 @@\n-  jlong _scoped_hash_table_shift;\n+  jlong _scopeLocal_hash_table_shift;\n@@ -1104,1 +1104,1 @@\n-  void allocate_scoped_hash_table(int count);\n+  void allocate_scopeLocal_hash_table(int count);\n@@ -1158,2 +1158,2 @@\n-  oop scopedCache() const;\n-  void set_scopedCache(oop p);\n+  oop scopeLocalCache() const;\n+  void set_scopeLocalCache(oop p);\n@@ -1481,1 +1481,1 @@\n-  static ByteSize scopedCache_offset()           { return byte_offset_of(JavaThread, _scopedCache); }\n+  static ByteSize scopeLocalCache_offset()       { return byte_offset_of(JavaThread, _scopeLocalCache); }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -753,1 +753,1 @@\n-  nonstatic_field(JavaThread,                  _scopedCache,                                  OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _scopeLocalCache,                              OopHandle)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    private Object[] scopedCache;\n+    private Object[] scopeLocalCache;\n@@ -293,1 +293,1 @@\n-        Thread.setScopedCache(scopedCache);\n+        Thread.setScopeLocalCache(scopeLocalCache);\n@@ -297,2 +297,2 @@\n-        scopedCache = Thread.scopedCache();\n-        Thread.setScopedCache(null);\n+        scopeLocalCache = Thread.scopeLocalCache();\n+        Thread.setScopeLocalCache(null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Continuation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,492 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.function.Supplier;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+\/**\n+ * Represents a scoped variable.\n+ *\n+ * <p> A scoped variable differs from a normal variable in that it is dynamically\n+ * scoped and intended for cases where context needs to be passed from a caller\n+ * to a transitive callee without using an explicit parameter. A scoped variable\n+ * does not have a default\/initial value, it is bound, meaning it gets a value,\n+ * when executing an operation specified to {@link #runWithBinding(Object, Runnable)}\n+ * or {@link #callWithBinding(Object, Callable)}. Code executed by the operation\n+ * uses the {@link #get()} method to get the value of the variable. The variable reverts\n+ * to being unbound (or its previous value) when the operation completes.\n+ *\n+ * <p> Access to the value of a scoped variable is controlled by the accessibility\n+ * of the {@code ScopeLocal} object. A {@code ScopeLocal} object  will typically be declared\n+ * in a private static field so that it can only be accessed by code in that class\n+ * (or other classes within its nest).\n+ *\n+ * <p> ScopeLocal variables support nested bindings. If a scoped variable has a value\n+ * then the {@code runWithBinding} or {@code callWithBinding} can be invoked to run\n+ * another operation with a new value. Code executed by this methods \"sees\" the new\n+ * value of the variable. The variable reverts to its previous value when the\n+ * operation completes.\n+ *\n+ * <p> An <em>inheritable scoped variable<\/em> is created with the {@link\n+ * #inheritableForType(Class)} method and provides inheritance of values from\n+ * parent thread to child thread that is arranged when the child thread is\n+ * created. Unlike {@link InheritableThreadLocal}, inheritable scoped variable\n+ * are not copied into the child thread, instead the child thread will access\n+ * the same variable as the parent thread. The value of inheritable scoped\n+ * variables should be immutable to avoid needing synchronization to coordinate\n+ * access.\n+ *\n+ * <p> As an advanced feature, the {@link #snapshot()} method is defined to obtain\n+ * a {@link Snapshot} of the inheritable scoped variables that are currently bound.\n+ * This can be used to support cases where inheritance needs to be done at times\n+ * other than thread creation.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+ * or method in this class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * @apiNote\n+ * The following example uses a scoped variable to make credentials available to callees.\n+ *\n+ * <pre>{@code\n+ *   private static final ScopeLocal<Credentials> CREDENTIALS = ScopeLocal.forType(Credentials.class);\n+ *\n+ *   Credentials creds = ...\n+ *   CREDENTIALS.runWithBinding(creds, () -> {\n+ *       :\n+ *       Connection connection = connectDatabase();\n+ *       :\n+ *   });\n+ *\n+ *   Connection connectDatabase() {\n+ *       Credentials credentials = CREDENTIALS.get();\n+ *       :\n+ *   }\n+ * }<\/pre>\n+ *\n+ * @param <T> the variable type\n+ * @since 99\n+ *\/\n+public final class ScopeLocal<T> {\n+    private final @Stable Class<? super T> type;\n+    private final @Stable int hash;\n+\n+    \/\/ Is this scope-local value inheritable? We could handle this by\n+    \/\/ making ScopeLocal an abstract base class and scopeLocalBindings() a\n+    \/\/ virtual method, but that seems a little excessive.\n+    private final @Stable boolean isInheritable;\n+\n+    public int hashCode() { return hash; }\n+\n+    \/**\n+     * Represents a snapshot of inheritable scoped variables.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+     * or method in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @since 99\n+     * @see ScopeLocal#snapshot()\n+     *\/\n+\n+    public static class Snapshot {\n+        final ScopeLocal<?> key;\n+        final Object value;\n+        final Snapshot prev;\n+\n+        private static final Object NIL = new Object();\n+\n+        Snapshot(ScopeLocal<?> key, Object value, Snapshot prev) {\n+            key.type.cast(value);\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n+        }\n+\n+        final Object get() {\n+            return value;\n+        }\n+\n+        final ScopeLocal<?> getKey() {\n+            return key;\n+        }\n+\n+        Object find(ScopeLocal<?> key) {\n+            for (Snapshot b = this; b != null; b = b.prev) {\n+                if (b.getKey() == key) {\n+                    Object value = b.get();\n+                    return value;\n+                }\n+            }\n+            return NIL;\n+        }\n+        \/**\n+         * Runs an operation with this snapshot of inheritable scoped variables.\n+         *\n+         * @param op the operation to run\n+         *\/\n+        public void runWithSnapshot(Runnable op) {\n+            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+            var cache = Thread.scopeLocalCache();\n+            Cache.invalidate();\n+            try {\n+                Thread.currentThread().inheritableScopeLocalBindings = this;\n+                op.run();\n+            } finally {\n+                Thread.currentThread().inheritableScopeLocalBindings = prev;\n+                Thread.setScopeLocalCache(cache);\n+            }\n+        }\n+\n+        \/**\n+         * Runs a value-returning operation with this snapshot of inheritable\n+         * scoped variables.\n+         *\n+         * @param op the operation to run\n+         * @param <R> the type of the result of the function\n+         * @return the result\n+         * @throws Exception if the operation completes with an exception\n+         *\/\n+        public <R> R callWithSnapshot(Callable<R> op) throws Exception {\n+            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+            var cache = Thread.scopeLocalCache();\n+            Cache.invalidate();\n+            try {\n+                Thread.currentThread().inheritableScopeLocalBindings = this;\n+                return op.call();\n+            } finally {\n+                Thread.currentThread().inheritableScopeLocalBindings = prev;\n+                Thread.setScopeLocalCache(cache);\n+            }\n+        }\n+    }\n+\n+    private ScopeLocal(Class<? super T> type, boolean isInheritable) {\n+        this.type = Objects.requireNonNull(type);\n+        this.isInheritable = isInheritable;\n+        this.hash = generateKey();\n+    }\n+\n+    \/**\n+     * Creates a scoped variable to hold a value with the given type.\n+     *\n+     * @param <T> the type of the scoped variable's value.\n+     * @param <U> a supertype of {@code T}. It should either be {@code T} itself or, if T is a parameterized type, its generic type.\n+     * @param type The {@Class} instance {@codeT.class}\n+     * @return a scope variable\n+     *\/\n+    public static <U,T extends U> ScopeLocal<T> forType(Class<U> type) {\n+        return new ScopeLocal<T>(type, false);\n+    }\n+\n+    \/**\n+     * Creates an inheritable scoped variable to hold a value with the given type.\n+     *\n+     * @param <T> the type of the scoped variable's value.\n+     * @param <U> a supertype of {@code T}. It should either be {@code T} itself or, if T is a parameterized type, its generic type.\n+     * @param type The {@Class} instance {@codeT.class}\n+     * @return a scope variable\n+     *\/\n+    public static <U,T extends U> ScopeLocal<T> inheritableForType(Class<U> type) {\n+        return new ScopeLocal<T>(type, true);\n+    }\n+\n+    private Snapshot scopeLocalBindings() {\n+        Thread currentThread = Thread.currentThread();\n+        return isInheritable\n+                ? currentThread.inheritableScopeLocalBindings\n+                : currentThread.noninheritableScopeLocalBindings;\n+    }\n+\n+    private void setScopeLocalBindings(Snapshot bindings) {\n+        Thread currentThread = Thread.currentThread();\n+        if (isInheritable) {\n+            currentThread.inheritableScopeLocalBindings = bindings;\n+        } else {\n+            currentThread.noninheritableScopeLocalBindings = bindings;\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the variable is bound to a value.\n+     *\n+     * @return {@code true} if the variable is bound to a value, otherwise {@code false}\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean isBound() {\n+        var bindings = scopeLocalBindings();\n+        if (bindings == null) {\n+            return false;\n+        }\n+        return (bindings.find(this) != Snapshot.NIL);\n+    }\n+\n+    \/**\n+     * Return the value of the variable or NIL if not bound.\n+     *\/\n+    private Object findBinding() {\n+        var bindings = scopeLocalBindings();\n+        if (bindings != null) {\n+            return bindings.find(this);\n+        } else {\n+            return Snapshot.NIL;\n+        }\n+    }\n+\n+    \/**\n+     * Return the value of the variable if bound, otherwise returns {@code other}.\n+     * @param other the value to return if not bound, can be {@code null}\n+     * @return the value of the variable if bound, otherwise {@code other}\n+     *\/\n+    public T orElse(T other) {\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            return other;\n+        }\n+    }\n+\n+    \/**\n+     * Return the value of the variable if bound, otherwise throws an exception\n+     * produced by the exception supplying function.\n+     * @param <X> Type of the exception to be thrown\n+     * @param exceptionSupplier the supplying function that produces an\n+     *        exception to be thrown\n+     * @return the value of the variable if bound\n+     * @throws X if the variable is unbound\n+     *\/\n+    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n+        Objects.requireNonNull(exceptionSupplier);\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private T slowGet() {\n+        var bindings = scopeLocalBindings();\n+        if (bindings != null) {\n+            for (var b = bindings; b != null; b = b.prev) {\n+                if (b.getKey() == this) {\n+                    return (T) b.get();\n+                }\n+            }\n+        }\n+        throw new NoSuchElementException();\n+    }\n+\n+    \/**\n+     * Returns the value of the variable.\n+     * @return the value of the variable\n+     * @throws NoSuchElementException if the variable is not bound (exception is TBD)\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = Thread.scopeLocalCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.TABLE_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.TABLE_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n+    }\n+\n+    \/**\n+     * Runs an operation with this variable bound to the given value. Code\n+     * executed by the operation can use the {@link #get()} method to get the\n+     * value of the variable. The variable reverts to its previous value or\n+     * becomes {@linkplain #isBound() unbound} when the operation completes.\n+     *\n+     * @param value the value for the variable, can be null\n+     * @param op the operation to run\n+     *\/\n+    public void runWithBinding(T value, Runnable op) {\n+        Objects.requireNonNull(op);\n+        Snapshot top = scopeLocalBindings();\n+        Cache.update(this, value);\n+        try {\n+            setScopeLocalBindings(new Snapshot(this, value, top));\n+            op.run();\n+        } finally {\n+            \/\/ assert(top == Thread.currentThread().scopeLocalBindings.prev);\n+            setScopeLocalBindings(top);\n+            Cache.remove(this);\n+        }\n+    }\n+\n+    \/**\n+     * Runs a value-returning operation with this variable bound to the given\n+     * value. Code executed by the operation can use the {@link #get()} method to\n+     * get the value of the variable. The variable reverts to its previous value or\n+     * becomes {@linkplain #isBound() unbound} when the operation completes.\n+     *\n+     * @param value the value for the variable, can be null\n+     * @param op the operation to run\n+     * @param <R> the type of the result of the function\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public <R> R callWithBinding(T value, Callable<R> op) throws Exception {\n+        Objects.requireNonNull(op);\n+        Snapshot top = scopeLocalBindings();\n+        Cache.update(this, value);\n+        try {\n+            setScopeLocalBindings(new Snapshot(this, value, top));\n+            return op.call();\n+        } finally {\n+            setScopeLocalBindings(top);\n+            Cache.remove(this);\n+        }\n+    }\n+\n+    \/\/ A small fixed-size key-value cache. When a scope variable's get() method\n+    \/\/ is called, we record the result of the lookup in this per-thread cache\n+    \/\/ for fast access in future.\n+    private static class Cache {\n+        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n+        static final int TABLE_SIZE = 1 << INDEX_BITS;\n+        static final int TABLE_MASK = TABLE_SIZE - 1;\n+\n+        static void put(ScopeLocal<?> key, Object value) {\n+            if (Thread.scopeLocalCache() == null) {\n+                Thread.setScopeLocalCache(new Object[TABLE_SIZE * 2]);\n+            }\n+            int victim = chooseVictim(Thread.currentCarrierThread(), key.hashCode());\n+            setKeyAndObjectAt(victim, key, value);\n+        }\n+\n+        private static final void update(Object key, Object value) {\n+            Object[] objects;\n+            if ((objects = Thread.scopeLocalCache()) != null) {\n+\n+                int k1 = key.hashCode() & TABLE_MASK;\n+                if (getKey(objects, k1) == key) {\n+                    setKeyAndObjectAt(k1, key, value);\n+                }\n+                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n+                if (getKey(objects, k2) == key) {\n+                    setKeyAndObjectAt(k2, key, value);\n+                }\n+            }\n+        }\n+\n+        private static final void remove(Object key) {\n+            Object[] objects;\n+            if ((objects = Thread.scopeLocalCache()) != null) {\n+\n+                int k1 = key.hashCode() & TABLE_MASK;\n+                if (getKey(objects, k1) == key) {\n+                    setKeyAndObjectAt(k1, null, null);\n+                }\n+                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n+                if (getKey(objects, k2) == key) {\n+                    setKeyAndObjectAt(k2, null, null);\n+                }\n+            }\n+        }\n+\n+        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n+            Thread.scopeLocalCache()[n * 2] = key;\n+            Thread.scopeLocalCache()[n * 2 + 1] = value;\n+        }\n+\n+        private static Object getKey(Object[] objs, long hash) {\n+            int n = (int) (hash & TABLE_MASK);\n+            return objs[n * 2];\n+        }\n+\n+        private static void setKey(Object[] objs, long hash, Object key) {\n+            int n = (int) (hash & TABLE_MASK);\n+            objs[n * 2] = key;\n+        }\n+\n+        private static int chooseVictim(Thread thread, int hash) {\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            int k1 = hash & TABLE_MASK;\n+            int k2 = (hash >> INDEX_BITS) & TABLE_MASK;\n+            int tmp = thread.victims;\n+            thread.victims = (tmp << 31) | (tmp >>> 1);\n+            return (tmp & 1) == 0 ? k1 : k2;\n+        }\n+\n+        public static void invalidate() {\n+            Thread.setScopeLocalCache(null);\n+        }\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes are\n+    \/\/ different.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while ((x & Cache.TABLE_MASK)\n+                == ((x >>> Cache.INDEX_BITS) & Cache.TABLE_MASK));\n+        return (nextKey = x);\n+    }\n+\n+    \/**\n+     * Returns a \"snapshot\" of the inheritable scoped variables that are currently\n+     * bound.\n+     *\n+     * <p>This snapshot may be capured at any time. It is inteneded to be used\n+     * in circumstances where values may be shared by sub-tasks.\n+     *\n+     * @return a \"snapshot\" of the currently-bound inheritable scoped variables. May be null.\n+     *\/\n+    public static Snapshot snapshot() {\n+        return Thread.currentThread().inheritableScopeLocalBindings;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopeLocal.java","additions":492,"deletions":0,"binary":false,"changes":492,"status":"added"},{"patch":"@@ -1,505 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.concurrent.Callable;\n-import java.util.function.Supplier;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Stable;\n-\n-\/**\n- * Represents a scoped variable.\n- *\n- * <p> A scoped variable differs to a normal variable in that it is dynamically\n- * scoped and intended for cases where context needs to be passed from a caller\n- * to a transitive callee without using an explicit parameter. A scoped variable\n- * does not have a default\/initial value, it is bound, meaning it gets a value,\n- * when executing an operation specified to {@link #runWithBinding(Object, Runnable)}\n- * or {@link #callWithBinding(Object, Callable)}. Code executed by the operation\n- * uses the {@link #get()} method to get the value of the variable. The variable reverts\n- * to being unbound (or its previous value) when the operation completes.\n- *\n- * <p> Access to the value of a scoped variable is controlled by the accessibility\n- * of the {@code Scoped} object. A {@code Scoped} object  will typically be declared\n- * in a private static field so that it can only be accessed by code in that class\n- * (or other classes within its nest).\n- *\n- * <p> Scoped variables support nested bindings. If a scoped variable has a value\n- * then the {@code runWithBinding} or {@code callWithBinding} can be invoked to run\n- * another operation with a new value. Code executed by this methods \"sees\" the new\n- * value of the variable. The variable reverts to its previous value when the\n- * operation completes.\n- *\n- * <p> An <em>inheritable scoped variable<\/em> is created with the {@link\n- * #inheritableForType(Class)} method and provides inheritance of values from\n- * parent thread to child thread that is arranged when the child thread is\n- * created. Unlike {@link InheritableThreadLocal}, inheritable scoped variable\n- * are not copied into the child thread, instead the child thread will access\n- * the same variable as the parent thread. The value of inheritable scoped\n- * variables should be immutable to avoid needing synchronization to coordinate\n- * access.\n- *\n- * <p> As an advanced feature, the {@link #snapshot()} method is defined to obtain\n- * a {@link Snapshot} of the inheritable scoped variables that are currently bound.\n- * This can be used to support cases where inheritance needs to be done at times\n- * other than thread creation.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n- * or method in this class will cause a {@link NullPointerException} to be thrown.\n- *\n- * @apiNote\n- * The following example uses a scoped variable to make credentials available to callees.\n- *\n- * <pre>{@code\n- *   private static final Scoped<Credentials> CREDENTIALS = Scoped.forType(Credentials.class);\n- *\n- *   Credentials creds = ...\n- *   CREDENTIALS.runWithBinding(creds, () -> {\n- *       :\n- *       Connection connection = connectDatabase();\n- *       :\n- *   });\n- *\n- *   Connection connectDatabase() {\n- *       Credentials credentials = CREDENTIALS.get();\n- *       :\n- *   }\n- * }<\/pre>\n- *\n- * @param <T> the variable type\n- * @since 99\n- *\/\n-public final class Scoped<T> {\n-    private final @Stable Class<? super T> type;\n-    private final @Stable int hash;\n-\n-    \/\/ Is this scope-local value inheritable? We could handle this by\n-    \/\/ making Scoped an abstract base class and scopeLocalBindings() a\n-    \/\/ virtual method, but that seems a little excessive.\n-    private final @Stable boolean isInheritable;\n-\n-    public int hashCode() { return hash; }\n-\n-    static class Binding<T> {\n-        final Scoped<T> key;\n-        final T value;\n-        final Binding<?> prev;\n-\n-        private static final Object NIL = new Object();\n-\n-        Binding(Scoped<T> key, T value, Binding<?> prev) {\n-            key.type.cast(value);\n-            this.key = key;\n-            this.value = value;\n-            this.prev = prev;\n-        }\n-\n-        final T get() {\n-            return value;\n-        }\n-\n-        final Scoped<T> getKey() {\n-            return key;\n-        }\n-\n-        Object find(Scoped<?> key) {\n-            for (Binding<?> b = this; b != null; b = b.prev) {\n-                if (b.getKey() == key) {\n-                    Object value = b.get();\n-                    return value;\n-                }\n-            }\n-            return NIL;\n-        }\n-    }\n-\n-    private Scoped(Class<? super T> type, boolean isInheritable) {\n-        this.type = Objects.requireNonNull(type);\n-        this.isInheritable = isInheritable;\n-        this.hash = generateKey();\n-    }\n-\n-    \/**\n-     * Creates a scoped variable to hold a value with the given type.\n-     *\n-     * @param <T> TBD\n-     * @param <U>   TBD\n-     * @param type TBD\n-     * @return a scope variable\n-     *\/\n-    public static <U,T extends U> Scoped<T> forType(Class<U> type) {\n-        return new Scoped<T>(type, false);\n-    }\n-\n-    \/**\n-     * Creates an inheritable scoped variable to hold a value with the given type.\n-     *\n-     * @param <T> TBD\n-     * @param <U>   TBD\n-     * @param type TBD\n-     * @return a scope variable\n-     *\/\n-    public static <U,T extends U> Scoped<T> inheritableForType(Class<U> type) {\n-        return new Scoped<T>(type, true);\n-    }\n-\n-    private Binding<?> scopeLocalBindings() {\n-        Thread currentThread = Thread.currentThread();\n-        return isInheritable\n-                ? currentThread.inheritableScopeLocalBindings\n-                : currentThread.noninheritableScopeLocalBindings;\n-    }\n-\n-    private void setScopeLocalBindings(Binding<?> bindings) {\n-        Thread currentThread = Thread.currentThread();\n-        if (isInheritable) {\n-            currentThread.inheritableScopeLocalBindings = bindings;\n-        } else {\n-            currentThread.noninheritableScopeLocalBindings = bindings;\n-        }\n-    }\n-\n-    \/**\n-     * Returns {@code true} if the variable is bound to a value.\n-     *\n-     * @return {@code true} if the variable is bound to a value, otherwise {@code false}\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public boolean isBound() {\n-        var bindings = scopeLocalBindings();\n-        if (bindings == null) {\n-            return false;\n-        }\n-        return (bindings.find(this) != Binding.NIL);\n-    }\n-\n-    \/**\n-     * Return the value of the variable or NIL if not bound.\n-     *\/\n-    private Object findBinding() {\n-        var bindings = scopeLocalBindings();\n-        if (bindings != null) {\n-            return bindings.find(this);\n-        } else {\n-            return Binding.NIL;\n-        }\n-    }\n-\n-    \/**\n-     * Return the value of the variable if bound, otherwise returns {@code other}.\n-     * @param other the value to return if not bound, can be {@code null}\n-     * @return the value of the variable if bound, otherwise {@code other}\n-     *\/\n-    public T orElse(T other) {\n-        Object obj = findBinding();\n-        if (obj != Binding.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            return other;\n-        }\n-    }\n-\n-    \/**\n-     * Return the value of the variable if bound, otherwise throws an exception\n-     * produced by the exception supplying function.\n-     * @param <X> Type of the exception to be thrown\n-     * @param exceptionSupplier the supplying function that produces an\n-     *        exception to be thrown\n-     * @return the value of the variable if bound\n-     * @throws X if the variable is unbound\n-     *\/\n-    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n-        Objects.requireNonNull(exceptionSupplier);\n-        Object obj = findBinding();\n-        if (obj != Binding.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            throw exceptionSupplier.get();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private T slowGet() {\n-        var bindings = scopeLocalBindings();\n-        if (bindings != null) {\n-            for (var b = bindings; b != null; b = b.prev) {\n-                if (b.getKey() == this) {\n-                    return (T) b.get();\n-                }\n-            }\n-        }\n-        throw new NoSuchElementException();\n-    }\n-\n-    \/**\n-     * Returns the value the variable.\n-     * @return the value the variable\n-     * @throws NoSuchElementException if the variable is not bound (exception is TBD)\n-     *\/\n-    @ForceInline\n-    @SuppressWarnings(\"unchecked\")\n-    public T get() {\n-        Object[] objects;\n-        if ((objects = Thread.scopedCache()) != null) {\n-            \/\/ This code should perhaps be in class Cache. We do it\n-            \/\/ here because the generated code is small and fast and\n-            \/\/ we really want it to be inlined in the caller.\n-            int n = (hash & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-        }\n-        return slowGet();\n-    }\n-\n-    \/**\n-     * Runs an operation with this variable bound to the given value. Code\n-     * executed by the operation can use the {@link #get()} method to get the\n-     * value of the variable. The variable reverts to its previous value or\n-     * becomes {@linkplain #isBound() unbound} when the operation completes.\n-     *\n-     * @param value the value for the variable, can be null\n-     * @param op the operation to run\n-     *\/\n-    public void runWithBinding(T value, Runnable op) {\n-        Objects.requireNonNull(op);\n-        Binding<?> top = scopeLocalBindings();\n-        Cache.update(this, value);\n-        try {\n-            setScopeLocalBindings(new Binding<T>(this, value, top));\n-            op.run();\n-        } finally {\n-            \/\/ assert(top == Thread.currentThread().scopeLocalBindings.prev);\n-            setScopeLocalBindings(top);\n-            Cache.remove(this);\n-        }\n-    }\n-\n-    \/**\n-     * Runs a value-returning operation with this variable bound to the given\n-     * value. Code executed by the operation can use the {@link #get()} method to\n-     * get the value of the variable. The variable reverts to its previous value or\n-     * becomes {@linkplain #isBound() unbound} when the operation completes.\n-     *\n-     * @param value the value for the variable, can be null\n-     * @param op the operation to run\n-     * @param <R> the type of the result of the function\n-     * @return the result\n-     * @throws Exception if the operation completes with an exception\n-     *\/\n-    public <R> R callWithBinding(T value, Callable<R> op) throws Exception {\n-        Objects.requireNonNull(op);\n-        Binding<?> top = scopeLocalBindings();\n-        Cache.update(this, value);\n-        try {\n-            setScopeLocalBindings(new Binding<T>(this, value, top));\n-            return op.call();\n-        } finally {\n-            setScopeLocalBindings(top);\n-            Cache.remove(this);\n-        }\n-    }\n-\n-    private static class Cache {\n-        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n-        static final int TABLE_SIZE = 1 << INDEX_BITS;\n-        static final int TABLE_MASK = TABLE_SIZE - 1;\n-\n-        static void put(Scoped<?> key, Object value) {\n-            if (Thread.scopedCache() == null) {\n-                Thread.setScopedCache(new Object[TABLE_SIZE * 2]);\n-            }\n-            int victim = chooseVictim(Thread.currentCarrierThread(), key.hashCode());\n-            setKeyAndObjectAt(victim, key, value);\n-        }\n-\n-        private static final void update(Object key, Object value) {\n-            Object[] objects;\n-            if ((objects = Thread.scopedCache()) != null) {\n-\n-                int k1 = key.hashCode() & TABLE_MASK;\n-                if (getKey(objects, k1) == key) {\n-                    setKeyAndObjectAt(k1, key, value);\n-                }\n-                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n-                if (getKey(objects, k2) == key) {\n-                    setKeyAndObjectAt(k2, key, value);\n-                }\n-            }\n-        }\n-\n-        private static final void remove(Object key) {\n-            Object[] objects;\n-            if ((objects = Thread.scopedCache()) != null) {\n-\n-                int k1 = key.hashCode() & TABLE_MASK;\n-                if (getKey(objects, k1) == key) {\n-                    setKeyAndObjectAt(k1, null, null);\n-                }\n-                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n-                if (getKey(objects, k2) == key) {\n-                    setKeyAndObjectAt(k2, null, null);\n-                }\n-            }\n-        }\n-\n-        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n-            Thread.scopedCache()[n * 2] = key;\n-            Thread.scopedCache()[n * 2 + 1] = value;\n-        }\n-\n-        private static Object getKey(Object[] objs, long hash) {\n-            int n = (int) (hash & TABLE_MASK);\n-            return objs[n * 2];\n-        }\n-\n-        private static void setKey(Object[] objs, long hash, Object key) {\n-            int n = (int) (hash & TABLE_MASK);\n-            objs[n * 2] = key;\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-        final Object getKey(int n) {\n-            return Thread.scopedCache()[n * 2];\n-        }\n-\n-        @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n-        private static Object getObject(int n) {\n-            return Thread.scopedCache()[n * 2 + 1];\n-        }\n-\n-        private static int chooseVictim(Thread thread, int hash) {\n-            \/\/ Update the cache to replace one entry with the value we just looked up.\n-            \/\/ Each value can be in one of two possible places in the cache.\n-            \/\/ Pick a victim at (pseudo-)random.\n-            int k1 = hash & TABLE_MASK;\n-            int k2 = (hash >> INDEX_BITS) & TABLE_MASK;\n-            int tmp = thread.victims;\n-            thread.victims = (tmp << 31) | (tmp >>> 1);\n-            return (tmp & 1) == 0 ? k1 : k2;\n-        }\n-\n-        public static void invalidate() {\n-            Thread.setScopedCache(null);\n-        }\n-    }\n-\n-    private static int nextKey = 0xf0f0_f0f0;\n-\n-    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n-    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n-    \/\/ and the next n bits as cache indexes, so we make sure that those indexes are\n-    \/\/ different.\n-    private static synchronized int generateKey() {\n-        int x = nextKey;\n-        do {\n-            x ^= x >>> 12;\n-            x ^= x << 9;\n-            x ^= x >>> 23;\n-        } while ((x & Cache.TABLE_MASK)\n-                == ((x >>> Cache.INDEX_BITS) & Cache.TABLE_MASK));\n-        return (nextKey = x);\n-    }\n-\n-    \/**\n-     * Represents a snapshot of inheritable scoped variables.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n-     * or method in this class will cause a {@link NullPointerException} to be thrown.\n-     *\n-     * @since 99\n-     * @see Scoped#snapshot()\n-     *\/\n-    public static final class Snapshot {\n-        private final Binding<?> bindings;\n-\n-        private Snapshot() {\n-            bindings = Thread.currentThread().inheritableScopeLocalBindings;\n-        }\n-\n-        \/**\n-         * Runs an operation with this snapshot of inheritable scoped variables.\n-         *\n-         * @param op the operation to run\n-         *\/\n-        @SuppressWarnings(\"rawtypes\")\n-        public void runWithSnapshot(Runnable op) {\n-            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-            var cache = Thread.scopedCache();\n-            Cache.invalidate();\n-            try {\n-                Thread.currentThread().inheritableScopeLocalBindings = bindings;\n-                op.run();\n-            } finally {\n-                Thread.currentThread().inheritableScopeLocalBindings = prev;\n-                Thread.setScopedCache(cache);\n-            }\n-        }\n-\n-        \/**\n-         * Runs a value-returning operation with this snapshot of inheritable\n-         * scoped variables.\n-         *\n-         * @param op the operation to run\n-         * @param <R> the type of the result of the function\n-         * @return the result\n-         * @throws Exception if the operation completes with an exception\n-         *\/\n-        public <R> R callWithSnapshot(Callable<R> op) throws Exception {\n-            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n-            var cache = Thread.scopedCache();\n-            Cache.invalidate();\n-            try {\n-                Thread.currentThread().inheritableScopeLocalBindings = bindings;\n-                return op.call();\n-            } finally {\n-                Thread.currentThread().inheritableScopeLocalBindings = prev;\n-                Thread.setScopedCache(cache);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Returns a \"snapshot\" of the inheritable scoped variables that are currently\n-     * bound.\n-     *\n-     * @return a \"snapshot\" of the inheritable scoped variables\n-     *\/\n-    public static Snapshot snapshot() {\n-        return new Snapshot();\n-    }\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Scoped.java","additions":0,"deletions":505,"binary":false,"changes":505,"status":"deleted"},{"patch":"@@ -251,2 +251,2 @@\n-    Scoped.Binding<?> noninheritableScopeLocalBindings;\n-    Scoped.Binding<?> inheritableScopeLocalBindings;\n+    ScopeLocal.Snapshot noninheritableScopeLocalBindings;\n+    ScopeLocal.Snapshot inheritableScopeLocalBindings;\n@@ -367,1 +367,1 @@\n-    \/\/ Scoped support:\n+    \/\/ ScopeLocal support:\n@@ -374,1 +374,1 @@\n-    static native Object[] scopedCache();\n+    static native Object[] scopeLocalCache();\n@@ -377,1 +377,1 @@\n-    static native void setScopedCache(Object[] cache);\n+    static native void setScopeLocalCache(Object[] cache);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -475,0 +475,2 @@\n+        private ScopeLocal.Snapshot snapshot = ScopeLocal.snapshot();\n+\n@@ -486,2 +488,15 @@\n-        public final void run()                { tryFire(ASYNC); }\n-        public final boolean exec()            { tryFire(ASYNC); return false; }\n+        public final void run() {\n+            if (snapshot != null) {\n+                snapshot.runWithSnapshot(() -> tryFire(ASYNC));\n+            } else {\n+                tryFire(ASYNC);\n+            }\n+        }\n+        public final boolean exec() {\n+            if (snapshot != null) {\n+                snapshot.runWithSnapshot(() -> tryFire(ASYNC));\n+            } else {\n+                tryFire(ASYNC);\n+            }\n+            return false;\n+        }\n@@ -1798,0 +1813,2 @@\n+        private ScopeLocal.Snapshot snapshot = ScopeLocal.snapshot();\n+\n@@ -1802,1 +1819,1 @@\n-        public void run() {\n+        private void doRun() {\n@@ -1817,0 +1834,8 @@\n+\n+        public void run() {\n+            if (snapshot != null) {\n+                snapshot.runWithSnapshot(this::doRun);\n+            } else {\n+                doRun();\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -434,0 +434,2 @@\n+    private ScopeLocal.Snapshot snapshot = ScopeLocal.snapshot();\n+\n@@ -754,1 +756,5 @@\n-        compute();\n+        if (snapshot != null) {\n+            snapshot.runWithSnapshot(this::compute);\n+        } else {\n+            compute();\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CountedCompleter.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-    {\"scopedCache\",      \"()[\" OBJ,    (void *)&JVM_ScopedCache},\n-    {\"setScopedCache\",   \"([\" OBJ \")V\",(void *)&JVM_SetScopedCache},\n+    {\"scopeLocalCache\",   \"()[\" OBJ,   (void *)&JVM_ScopeLocalCache},\n+    {\"setScopeLocalCache\", \"([\" OBJ \")V\",(void *)&JVM_SetScopeLocalCache},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,475 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @run testng Basic\n+ * @summary Basic test for java.lang.ScopeLocal\n+ *\/\n+\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class Basic {\n+\n+    @Test(expectedExceptions = { NoSuchElementException.class })\n+    public void testUnbound1() {\n+        ScopeLocal<String> v = ScopeLocal.forType(String.class);\n+        assertFalse(v.isBound());\n+        v.get();\n+    }\n+\n+    @Test(expectedExceptions = { NoSuchElementException.class })\n+    public void testUnbound2() {\n+        ScopeLocal<String> v = ScopeLocal.inheritableForType(String.class);\n+        assertFalse(v.isBound());\n+        v.get();\n+    }\n+\n+    public void testOrElse() {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        assertFalse(name.isBound());\n+        assertTrue(name.orElse(null) == null);\n+        assertEquals(name.orElse(\"default\"), \"default\");\n+        name.runWithBinding(\"fred\", () -> {\n+            assertEquals(name.orElse(null), \"fred\");\n+            assertEquals(name.orElse(\"default\"), \"fred\");\n+        });\n+    }\n+\n+    public void testOrElseThrow() {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        assertFalse(name.isBound());\n+        assertThrows(IllegalStateException.class, () -> name.orElseThrow(IllegalStateException::new));\n+        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+        name.runWithBinding(\"fred\", () -> {\n+            assertEquals(name.orElseThrow(IllegalStateException::new), \"fred\");\n+            assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+        });\n+    }\n+\n+    \/**\n+     * Test runWithBinding with non-inheritable scope variable.\n+     *\/\n+    public void testRunWithBinding1() {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        name.runWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+            ensureNotInherited(name);\n+        });\n+    }\n+\n+    public void testRunWithBinding2() {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        name.runWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+\n+            name.runWithBinding(\"joe\", () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(\"joe\".equals(name.get()));\n+                ensureNotInherited(name);\n+            });\n+\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+            ensureNotInherited(name);\n+        });\n+    }\n+\n+    \/**\n+     * Test runWithBinding with non-inheritable scope variable, null value.\n+     *\/\n+    public void testRunWithBinding3() {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        name.runWithBinding(null, () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(name.get() == null);\n+            ensureNotInherited(name);\n+        });\n+    }\n+\n+    public void testRunWithBinding4() {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        name.runWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+\n+            name.runWithBinding(null, () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+                ensureNotInherited(name);\n+            });\n+\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+            ensureNotInherited(name);\n+        });\n+    }\n+\n+    \/**\n+     * Test runWithBinding with inheritable scope variable.\n+     *\/\n+    public void testRunWithBinding5() {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        name.runWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+            ensureInherited(name);\n+        });\n+    }\n+\n+    public void testRunWithBinding6() {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        name.runWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+\n+            name.runWithBinding(\"joe\", () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(\"joe\".equals(name.get()));\n+                ensureInherited(name);\n+            });\n+\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+            ensureInherited(name);\n+        });\n+    }\n+\n+    \/**\n+     * Test runWithBinding with inheritable scope variable, null value.\n+     *\/\n+    public void testRunWithBinding7() {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        name.runWithBinding(null, () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(name.get() == null);\n+            ensureInherited(name);\n+        });\n+    }\n+\n+    public void testRunWithBinding8() {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        name.runWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+\n+            name.runWithBinding(null, () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+                ensureInherited(name);\n+            });\n+\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+            ensureInherited(name);\n+        });\n+    }\n+\n+    \/**\n+     * Test runWithBinding with null operation\n+     *\/\n+    @Test(expectedExceptions = { NullPointerException.class })\n+    public void testRunWithBinding9() {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        name.runWithBinding(\"fred\", null);\n+    }\n+\n+    \/**\n+     * Test callWithBinding with non-inheritable scope variable.\n+     *\/\n+    public void testCallWithBinding1() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        int result = name.callWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value = name.get();\n+            assertTrue(\"fred\".equals(value));\n+            ensureNotInherited(name);\n+            return 1;\n+        });\n+        assertTrue(result == 1);\n+    }\n+\n+    public void testCallWithBinding2() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        int result1 = name.callWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value1 = name.get();\n+            assertTrue(\"fred\".equals(value1));\n+            ensureNotInherited(name);\n+\n+            int result2 = name.callWithBinding(\"joe\", () -> {\n+                assertTrue(name.isBound());\n+                String value2 = name.get();\n+                assertTrue(\"joe\".equals(value2));\n+                return 2;\n+            });\n+            assertTrue(result2 == 2);\n+\n+            return 1;\n+        });\n+        assertTrue(result1 == 1);\n+    }\n+\n+    \/**\n+     * Test callWithBinding with non-inheritable scope variable, null value.\n+     *\/\n+    public void testCallWithBinding3() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        int result = name.callWithBinding(null, () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(name.get() == null);\n+            ensureNotInherited(name);\n+            return 1;\n+        });\n+        assertTrue(result == 1);\n+    }\n+\n+    public void testCallWithBinding4() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        int result1 = name.callWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value1 = name.get();\n+            assertTrue(\"fred\".equals(value1));\n+            ensureNotInherited(name);\n+\n+            int result2 = name.callWithBinding(null, () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+                return 2;\n+            });\n+            assertTrue(result2 == 2);\n+\n+            return 1;\n+        });\n+        assertTrue(result1 == 1);\n+    }\n+\n+    \/**\n+     * Test callWithBinding with inheritable scope variable.\n+     *\/\n+    public void testCallWithBinding5() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        int result = name.callWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value = name.get();\n+            assertTrue(\"fred\".equals(value));\n+            ensureInherited(name);\n+            return 1;\n+        });\n+        assertTrue(result == 1);\n+    }\n+\n+    public void testCallWithBinding6() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        int result1 = name.callWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value1 = name.get();\n+            assertTrue(\"fred\".equals(value1));\n+            ensureInherited(name);\n+\n+            int result2 = name.callWithBinding(\"joe\", () -> {\n+                assertTrue(name.isBound());\n+                String value2 = name.get();\n+                assertTrue(\"joe\".equals(value2));\n+                return 2;\n+            });\n+            assertTrue(result2 == 2);\n+\n+            return 1;\n+        });\n+        assertTrue(result1 == 1);\n+    }\n+\n+    \/**\n+     * Test callWithBinding with inheritable scope variable, null value.\n+     *\/\n+    public void testCallWithBinding7() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        int result = name.callWithBinding(null, () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(name.get() == null);\n+            ensureInherited(name);\n+            return 1;\n+        });\n+        assertTrue(result == 1);\n+    }\n+\n+    public void testCallWithBinding8() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        int result1 = name.callWithBinding(\"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value1 = name.get();\n+            assertTrue(\"fred\".equals(value1));\n+            ensureInherited(name);\n+\n+            int result2 = name.callWithBinding(null, () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+                return 2;\n+            });\n+            assertTrue(result2 == 2);\n+\n+            return 1;\n+        });\n+        assertTrue(result1 == 1);\n+    }\n+\n+    \/**\n+     * Test callWithBinding with null operation\n+     *\/\n+    @Test(expectedExceptions = { NullPointerException.class })\n+    public void testCallWithBinding9() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        name.callWithBinding(\"fred\", null);\n+    }\n+\n+    \/**\n+     * Test that inheritable scope variable are inherited at Thread create time.\n+     *\/\n+    public void testInheritAtCreateTime() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        name.callWithBinding(\"fred\", () -> {\n+            AtomicReference<String> ref = new AtomicReference<>();\n+            Thread thread = new Thread(() -> ref.set(name.get()));\n+            \/\/ start thread with name set to joe\n+            name.runWithBinding(\"joe\", thread::start);\n+            thread.join();\n+            assertEquals(ref.get(), \"fred\");\n+            return null;\n+        });\n+    }\n+\n+    \/**\n+     * Test snapshot inheritance.\n+     *\/\n+    public void testSnapshotInheritance() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.inheritableForType(String.class);\n+        ScopeLocal<String> occupation = ScopeLocal.inheritableForType(String.class);\n+        var snapshot = name.callWithBinding(\"aristotle\", () -> ScopeLocal.snapshot());\n+        assertFalse(name.isBound());\n+        assertBoundInSnapshot(snapshot, name, true);\n+        occupation.callWithBinding(\"undertaker\", () -> {\n+            assertBoundInSnapshot(snapshot, occupation, false);\n+            assertEquals(occupation.get(), \"undertaker\");\n+            assertTrue(occupation.isBound());\n+            return null;\n+        });\n+        assertEqualsInSnapshot(snapshot, name, \"aristotle\");\n+    }\n+\n+    \/**\n+     * Test for snapshot non-inheritance.\n+     *\/\n+    public void testSnapshotNonInheritance() throws Exception {\n+        ScopeLocal<String> name = ScopeLocal.forType(String.class);\n+        ScopeLocal<String> occupation = ScopeLocal.forType(String.class);\n+        var snapshot = name.callWithBinding(\"aristotle\", () -> ScopeLocal.snapshot());\n+        assertFalse(name.isBound());\n+        assertBoundInSnapshot(snapshot, name, false);\n+        occupation.callWithBinding(\"undertaker\", () -> {\n+            assertBoundInSnapshot(snapshot, occupation, true);\n+            assertEquals(occupation.get(), \"undertaker\");\n+            assertEqualsInSnapshot(snapshot, occupation, \"undertaker\");\n+            assertTrue(occupation.isBound());\n+            return null;\n+        });\n+        name.callWithBinding(\"joe\", () -> {\n+            assertEqualsInSnapshot(snapshot, name, \"joe\");\n+            return null;\n+        });\n+    }\n+\n+    private <R> R callWithSnapshot(ScopeLocal.Snapshot snapshot, Callable<R> c) {\n+        try {\n+            return snapshot == null ? c.call() : snapshot.callWithSnapshot(c);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private <T> void assertEqualsInSnapshot(ScopeLocal.Snapshot snapshot, ScopeLocal<T> var, T expected)\n+            throws Exception {\n+        callWithSnapshot(snapshot, () -> {\n+            assertEquals(var.get(), expected);\n+            return null;\n+        });\n+    }\n+\n+    private <T> void assertBoundInSnapshot(ScopeLocal.Snapshot snapshot, ScopeLocal<T> var, boolean expected)\n+            throws Exception {\n+        callWithSnapshot(snapshot, () -> {\n+            assertEquals(var.isBound(), expected);\n+            return null;\n+        });\n+    }\n+\n+    \/**\n+     * Ensures that a inheritable scope variable is inherited\n+     *\/\n+    private void ensureInherited(ScopeLocal<?> v) {\n+        Object valueInParent = v.get();\n+\n+        \/\/ check inherited by platform thread\n+        ThreadFactory factory = Thread.ofPlatform().factory();\n+        try (var executor = Executors.newThreadExecutor(factory)) {\n+            Object valueInChild = executor.submit(v::get).join();\n+            assertEquals(valueInChild, valueInParent);\n+        }\n+\n+        \/\/ check inherited by virtual thread\n+        try (var executor = Executors.newVirtualThreadExecutor()) {\n+            Object valueInChild = executor.submit(v::get).join();\n+            assertEquals(valueInChild, valueInParent);\n+        }\n+    }\n+\n+    \/**\n+     * Ensures that a non-inheritable scope variable is not inherited\n+     *\/\n+    private void ensureNotInherited(ScopeLocal<?> v) {\n+        assertTrue(v.isBound());\n+\n+        \/\/ check not inherited by platform thread\n+        ThreadFactory factory = Thread.ofPlatform().factory();\n+        try (var executor = Executors.newThreadExecutor(factory)) {\n+            boolean boundInChild = executor.submit(v::isBound).join();\n+            assertFalse(boundInChild);\n+        }\n+\n+        \/\/ check no inherited by virtual thread\n+        try (var executor = Executors.newVirtualThreadExecutor()) {\n+            boolean boundInChild = executor.submit(v::isBound).join();\n+            assertFalse(boundInChild);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ScopeLocal\/Basic.java","additions":475,"deletions":0,"binary":false,"changes":475,"status":"added"},{"patch":"@@ -1,466 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @run testng Basic\n- * @summary Basic test for java.lang.Scoped\n- *\/\n-\n-import java.util.NoSuchElementException;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-@Test\n-public class Basic {\n-\n-    @Test(expectedExceptions = { NoSuchElementException.class })\n-    public void testUnbound1() {\n-        Scoped<String> v = Scoped.forType(String.class);\n-        assertFalse(v.isBound());\n-        v.get();\n-    }\n-\n-    @Test(expectedExceptions = { NoSuchElementException.class })\n-    public void testUnbound2() {\n-        Scoped<String> v = Scoped.inheritableForType(String.class);\n-        assertFalse(v.isBound());\n-        v.get();\n-    }\n-\n-    public void testOrElse() {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        assertFalse(name.isBound());\n-        assertTrue(name.orElse(null) == null);\n-        assertEquals(name.orElse(\"default\"), \"default\");\n-        name.runWithBinding(\"fred\", () -> {\n-            assertEquals(name.orElse(null), \"fred\");\n-            assertEquals(name.orElse(\"default\"), \"fred\");\n-        });\n-    }\n-\n-    public void testOrElseThrow() {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        assertFalse(name.isBound());\n-        assertThrows(IllegalStateException.class, () -> name.orElseThrow(IllegalStateException::new));\n-        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n-        name.runWithBinding(\"fred\", () -> {\n-            assertEquals(name.orElseThrow(IllegalStateException::new), \"fred\");\n-            assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n-        });\n-    }\n-\n-    \/**\n-     * Test runWithBinding with non-inheritable scope variable.\n-     *\/\n-    public void testRunWithBinding1() {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        name.runWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-            ensureNotInherited(name);\n-        });\n-    }\n-\n-    public void testRunWithBinding2() {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        name.runWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            name.runWithBinding(\"joe\", () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(\"joe\".equals(name.get()));\n-                ensureNotInherited(name);\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-            ensureNotInherited(name);\n-        });\n-    }\n-\n-    \/**\n-     * Test runWithBinding with non-inheritable scope variable, null value.\n-     *\/\n-    public void testRunWithBinding3() {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        name.runWithBinding(null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-            ensureNotInherited(name);\n-        });\n-    }\n-\n-    public void testRunWithBinding4() {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        name.runWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            name.runWithBinding(null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-                ensureNotInherited(name);\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-            ensureNotInherited(name);\n-        });\n-    }\n-\n-    \/**\n-     * Test runWithBinding with inheritable scope variable.\n-     *\/\n-    public void testRunWithBinding5() {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        name.runWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-            ensureInherited(name);\n-        });\n-    }\n-\n-    public void testRunWithBinding6() {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        name.runWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            name.runWithBinding(\"joe\", () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(\"joe\".equals(name.get()));\n-                ensureInherited(name);\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-            ensureInherited(name);\n-        });\n-    }\n-\n-    \/**\n-     * Test runWithBinding with inheritable scope variable, null value.\n-     *\/\n-    public void testRunWithBinding7() {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        name.runWithBinding(null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-            ensureInherited(name);\n-        });\n-    }\n-\n-    public void testRunWithBinding8() {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        name.runWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            name.runWithBinding(null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-                ensureInherited(name);\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-            ensureInherited(name);\n-        });\n-    }\n-\n-    \/**\n-     * Test runWithBinding with null operation\n-     *\/\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testRunWithBinding9() {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        name.runWithBinding(\"fred\", null);\n-    }\n-\n-    \/**\n-     * Test callWithBinding with non-inheritable scope variable.\n-     *\/\n-    public void testCallWithBinding1() throws Exception {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        int result = name.callWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value = name.get();\n-            assertTrue(\"fred\".equals(value));\n-            ensureNotInherited(name);\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    public void testCallWithBinding2() throws Exception {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        int result1 = name.callWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-            ensureNotInherited(name);\n-\n-            int result2 = name.callWithBinding(\"joe\", () -> {\n-                assertTrue(name.isBound());\n-                String value2 = name.get();\n-                assertTrue(\"joe\".equals(value2));\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    \/**\n-     * Test callWithBinding with non-inheritable scope variable, null value.\n-     *\/\n-    public void testCallWithBinding3() throws Exception {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        int result = name.callWithBinding(null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-            ensureNotInherited(name);\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    public void testCallWithBinding4() throws Exception {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        int result1 = name.callWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-            ensureNotInherited(name);\n-\n-            int result2 = name.callWithBinding(null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    \/**\n-     * Test callWithBinding with inheritable scope variable.\n-     *\/\n-    public void testCallWithBinding5() throws Exception {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        int result = name.callWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value = name.get();\n-            assertTrue(\"fred\".equals(value));\n-            ensureInherited(name);\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    public void testCallWithBinding6() throws Exception {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        int result1 = name.callWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-            ensureInherited(name);\n-\n-            int result2 = name.callWithBinding(\"joe\", () -> {\n-                assertTrue(name.isBound());\n-                String value2 = name.get();\n-                assertTrue(\"joe\".equals(value2));\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    \/**\n-     * Test callWithBinding with inheritable scope variable, null value.\n-     *\/\n-    public void testCallWithBinding7() throws Exception {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        int result = name.callWithBinding(null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-            ensureInherited(name);\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    public void testCallWithBinding8() throws Exception {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        int result1 = name.callWithBinding(\"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-            ensureInherited(name);\n-\n-            int result2 = name.callWithBinding(null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    \/**\n-     * Test callWithBinding with null operation\n-     *\/\n-    @Test(expectedExceptions = { NullPointerException.class })\n-    public void testCallWithBinding9() throws Exception {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        name.callWithBinding(\"fred\", null);\n-    }\n-\n-    \/**\n-     * Test that inheritable scope variable are inherited at Thread create time.\n-     *\/\n-    public void testInheritAtCreateTime() throws Exception {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        name.callWithBinding(\"fred\", () -> {\n-            AtomicReference<String> ref = new AtomicReference<>();\n-            Thread thread = new Thread(() -> ref.set(name.get()));\n-            \/\/ start thread with name set to joe\n-            name.runWithBinding(\"joe\", thread::start);\n-            thread.join();\n-            assertEquals(ref.get(), \"fred\");\n-            return null;\n-        });\n-    }\n-\n-    \/**\n-     * Test snapshot inheritance.\n-     *\/\n-    public void testSnapshotInheritance() throws Exception {\n-        Scoped<String> name = Scoped.inheritableForType(String.class);\n-        Scoped<String> occupation = Scoped.inheritableForType(String.class);\n-        var snapshot = name.callWithBinding(\"aristotle\", () -> Scoped.snapshot());\n-        assertFalse(name.isBound());\n-        assertBoundInSnapshot(snapshot, name, true);\n-        occupation.callWithBinding(\"undertaker\", () -> {\n-            assertBoundInSnapshot(snapshot, occupation, false);\n-            assertEquals(occupation.get(), \"undertaker\");\n-            assertTrue(occupation.isBound());\n-            return null;\n-        });\n-        assertEqualsInSnapshot(snapshot, name, \"aristotle\");\n-    }\n-\n-    \/**\n-     * Test for snapshot non-inheritance.\n-     *\/\n-    public void testSnapshotNonInheritance() throws Exception {\n-        Scoped<String> name = Scoped.forType(String.class);\n-        Scoped<String> occupation = Scoped.forType(String.class);\n-        var snapshot = name.callWithBinding(\"aristotle\", () -> Scoped.snapshot());\n-        assertFalse(name.isBound());\n-        assertBoundInSnapshot(snapshot, name, false);\n-        occupation.callWithBinding(\"undertaker\", () -> {\n-            assertBoundInSnapshot(snapshot, occupation, true);\n-            assertEquals(occupation.get(), \"undertaker\");\n-            assertEqualsInSnapshot(snapshot, occupation, \"undertaker\");\n-            assertTrue(occupation.isBound());\n-            return null;\n-        });\n-        name.callWithBinding(\"joe\", () -> {\n-            assertEqualsInSnapshot(snapshot, name, \"joe\");\n-            return null;\n-        });\n-    }\n-\n-    private <T> void assertEqualsInSnapshot(Scoped.Snapshot snapshot, Scoped<T> var, T expected)\n-            throws Exception {\n-        snapshot.callWithSnapshot(() -> {\n-            assertEquals(var.get(), expected);\n-            return null;\n-        });\n-    }\n-\n-    private <T> void assertBoundInSnapshot(Scoped.Snapshot snapshot, Scoped<T> var, boolean expected)\n-            throws Exception {\n-        snapshot.callWithSnapshot(() -> {\n-            assertEquals(var.isBound(), expected);\n-            return null;\n-        });\n-    }\n-\n-    \/**\n-     * Ensures that a inheritable scope variable is inherited\n-     *\/\n-    private void ensureInherited(Scoped<?> v) {\n-        Object valueInParent = v.get();\n-\n-        \/\/ check inherited by platform thread\n-        ThreadFactory factory = Thread.ofPlatform().factory();\n-        try (var executor = Executors.newThreadExecutor(factory)) {\n-            Object valueInChild = executor.submit(v::get).join();\n-            assertEquals(valueInChild, valueInParent);\n-        }\n-\n-        \/\/ check inherited by virtual thread\n-        try (var executor = Executors.newVirtualThreadExecutor()) {\n-            Object valueInChild = executor.submit(v::get).join();\n-            assertEquals(valueInChild, valueInParent);\n-        }\n-    }\n-\n-    \/**\n-     * Ensures that a non-inheritable scope variable is not inherited\n-     *\/\n-    private void ensureNotInherited(Scoped<?> v) {\n-        assertTrue(v.isBound());\n-\n-        \/\/ check not inherited by platform thread\n-        ThreadFactory factory = Thread.ofPlatform().factory();\n-        try (var executor = Executors.newThreadExecutor(factory)) {\n-            boolean boundInChild = executor.submit(v::isBound).join();\n-            assertFalse(boundInChild);\n-        }\n-\n-        \/\/ check no inherited by virtual thread\n-        try (var executor = Executors.newVirtualThreadExecutor()) {\n-            boolean boundInChild = executor.submit(v::isBound).join();\n-            assertFalse(boundInChild);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/Scoped\/Basic.java","additions":0,"deletions":466,"binary":false,"changes":466,"status":"deleted"}]}