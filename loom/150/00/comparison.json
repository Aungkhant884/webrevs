{"files":[{"patch":"@@ -304,0 +304,4 @@\n+void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n+  fatal(\"Continuation.doYield intrinsic is not implemented on this platform\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRGenerator_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_CONTINUATIONENTRY_RISCV_INLINE_HPP\n+#define CPU_RISCV_CONTINUATIONENTRY_RISCV_INLINE_HPP\n+\n+#include \"runtime\/continuationEntry.hpp\"\n+\n+\/\/ TODO: Implement\n+\n+inline frame ContinuationEntry::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_RISCV_CONTINUATIONENTRY_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/continuationEntry_riscv.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_CONTINUATIONFREEZETHAW_RISCV_INLINE_HPP\n+#define CPU_RISCV_CONTINUATIONFREEZETHAW_RISCV_INLINE_HPP\n+\n+#include \"oops\/stackChunkOop.inline.hpp\"\n+#include \"runtime\/frame.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+\n+\n+inline void FreezeBase::set_top_frame_metadata_pd(const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template<typename FKind>\n+inline frame FreezeBase::sender(const frame& f) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template<typename FKind> frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+void FreezeBase::adjust_interpreted_frame_unextended_sp(frame& f) {\n+  Unimplemented();\n+}\n+\n+inline void FreezeBase::relativize_interpreted_frame_metadata(const frame& f, const frame& hf) {\n+  Unimplemented();\n+}\n+\n+inline void FreezeBase::patch_pd(frame& hf, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+  Unimplemented();\n+}\n+\n+inline frame ThawBase::new_entry_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n+inline void ThawBase::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* ThawBase::align(const frame& hf, intptr_t* frame_sp, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void ThawBase::patch_pd(frame& f, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+void ThawBase::patch_chunk_pd(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline void ThawBase::prefetch_chunk_pd(void* start, int size) {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_RISCV_CONTINUATIONFREEZETHAW_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_CONTINUATIONHELPER_RISCV_INLINE_HPP\n+#define CPU_RISCV_CONTINUATIONHELPER_RISCV_INLINE_HPP\n+\n+#include \"runtime\/continuationHelper.hpp\"\n+\n+template<typename FKind>\n+static inline intptr_t** link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int ContinuationHelper::frame_align_words(int size) {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline intptr_t* ContinuationHelper::frame_align_pointer(intptr_t* sp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind>\n+inline void ContinuationHelper::update_register_map(const frame& f, RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+inline void ContinuationHelper::update_register_map_with_callee(const frame& f, RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+inline void ContinuationHelper::push_pd(const frame& f) {\n+  Unimplemented();\n+}\n+\n+\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+  Unimplemented();\n+}\n+\n+#ifdef ASSERT\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline bool ContinuationHelper::Frame::assert_frame_laid_out(frame f) {\n+  Unimplemented();\n+  return false;\n+}\n+#endif\n+\n+inline intptr_t** ContinuationHelper::Frame::callee_link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind>\n+static inline intptr_t* real_fp(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address* ContinuationHelper::InterpretedFrame::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void ContinuationHelper::InterpretedFrame::patch_sender_sp(frame& f, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline address* ContinuationHelper::Frame::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address ContinuationHelper::Frame::real_pc(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void ContinuationHelper::Frame::patch_pc(const frame& f, address pc) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, InterpreterOopMap* mask) { \/\/ inclusive; this will be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_bottom(const frame& f) { \/\/ exclusive; this will not be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline intptr_t* ContinuationHelper::InterpretedFrame::frame_top(const frame& f, int callee_argsize, bool callee_interpreted) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+#endif \/\/ CPU_RISCV_CONTINUATIONFRAMEHELPERS_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -285,5 +285,0 @@\n-int frame::frame_size(RegisterMap* map) const {\n-  frame sender = this->sender(map);\n-  return sender.sp() - sp();\n-}\n-\n@@ -401,1 +396,1 @@\n-        DEBUG_ONLY(verify_deopt_original_pc(sender_cm, _unextended_sp));\n+        verify_deopt_original_pc(sender_cm, _unextended_sp);\n@@ -407,20 +402,0 @@\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::update_map_with_saved_link\n-void frame::update_map_with_saved_link(RegisterMap* map, intptr_t** link_addr) {\n-  \/\/ The interpreter and compiler(s) always save fp in a known\n-  \/\/ location on entry. We must record where that location is\n-  \/\/ so that if fp was live on callout from c2 we can find\n-  \/\/ the saved copy no matter what it called.\n-\n-  \/\/ Since the interpreter always saves fp if we record where it is then\n-  \/\/ we don't have to always save fp on entry and exit to c2 compiled\n-  \/\/ code, on entry will be enough.\n-  assert(map != NULL, \"map must be set\");\n-  map->set_location(::fp->as_VMReg(), (address) link_addr);\n-  \/\/ this is weird \"H\" ought to be at a higher address however the\n-  \/\/ oopMaps seems to have the \"H\" regs at the same address and the\n-  \/\/ vanilla register.\n-  map->set_location(::fp->as_VMReg()->next(), (address) link_addr);\n-}\n-\n-\n@@ -447,74 +422,0 @@\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::sender_for_compiled_frame\n-frame frame::sender_for_compiled_frame(RegisterMap* map) const {\n-  \/\/ we cannot rely upon the last fp having been saved to the thread\n-  \/\/ in C2 code but it will have been pushed onto the stack. so we\n-  \/\/ have to find it relative to the unextended sp\n-\n-  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n-  intptr_t* l_sender_sp = unextended_sp() + _cb->frame_size();\n-  intptr_t* unextended_sp = l_sender_sp;\n-\n-  \/\/ the return_address is always the word on the stack\n-  address sender_pc = (address) *(l_sender_sp + frame::return_addr_offset);\n-\n-  intptr_t** saved_fp_addr = (intptr_t**) (l_sender_sp + frame::link_offset);\n-\n-  assert(map != NULL, \"map must be set\");\n-  if (map->update_map()) {\n-    \/\/ Tell GC to use argument oopmaps for some runtime stubs that need it.\n-    \/\/ For C1, the runtime stub might not have oop maps, so set this flag\n-    \/\/ outside of update_register_map.\n-    map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n-    if (_cb->oop_maps() != NULL) {\n-      OopMapSet::update_register_map(this, map);\n-    }\n-\n-    \/\/ Since the prolog does the save and restore of FP there is no\n-    \/\/ oopmap for it so we must fill in its location as if there was\n-    \/\/ an oopmap entry since if our caller was compiled code there\n-    \/\/ could be live jvm state in it.\n-    update_map_with_saved_link(map, saved_fp_addr);\n-  }\n-\n-  return frame(l_sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n-}\n-\n-\/\/------------------------------------------------------------------------------\n-\/\/ frame::sender_raw\n-frame frame::sender_raw(RegisterMap* map) const {\n-  \/\/ Default is we done have to follow them. The sender_for_xxx will\n-  \/\/ update it accordingly\n-  assert(map != NULL, \"map must be set\");\n-  map->set_include_argument_oops(false);\n-\n-  if (is_entry_frame()) {\n-    return sender_for_entry_frame(map);\n-  }\n-  if (is_interpreted_frame()) {\n-    return sender_for_interpreter_frame(map);\n-  }\n-  assert(_cb == CodeCache::find_blob(pc()),\"Must be the same\");\n-\n-  \/\/ This test looks odd: why is it not is_compiled_frame() ?  That's\n-  \/\/ because stubs also have OOP maps.\n-  if (_cb != NULL) {\n-    return sender_for_compiled_frame(map);\n-  }\n-\n-  \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n-  \/\/ methods that exists in the core system.\n-  return frame(sender_sp(), link(), sender_pc());\n-}\n-\n-frame frame::sender(RegisterMap* map) const {\n-  frame result = sender_raw(map);\n-\n-  if (map->process_frames()) {\n-    StackWatermarkSet::on_iteration(map->thread(), result);\n-  }\n-\n-  return result;\n-}\n-\n@@ -658,13 +559,0 @@\n-intptr_t* frame::real_fp() const {\n-  if (_cb != NULL) {\n-    \/\/ use the frame size if valid\n-    int size = _cb->frame_size();\n-    if (size > 0) {\n-      return unextended_sp() + size;\n-    }\n-  }\n-  \/\/ else rely on fp()\n-  assert(!is_compiled_frame(), \"unknown compiled frame size\");\n-  return fp();\n-}\n-\n@@ -675,1 +563,1 @@\n-frame::frame(void* ptr_sp, void* ptr_fp, void* pc) {\n+frame::frame(void* ptr_sp, void* ptr_fp, void* pc) : _on_heap(false) {\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":2,"deletions":114,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -138,1 +138,8 @@\n-    arg_reg_save_area_bytes                          =  0\n+    arg_reg_save_area_bytes                          =  0,\n+\n+    \/\/ size, in words, of frame metadata (e.g. pc and link)\n+    metadata_words                                   = sender_sp_offset,\n+    \/\/ in bytes\n+    frame_alignment                                  = 16,\n+    \/\/ size, in words, of maximum shift in frame position due to alignment\n+    align_wiggle                                     =  1\n@@ -171,0 +178,2 @@\n+  const ImmutableOopMap* get_oop_map() const;\n+\n@@ -184,1 +193,1 @@\n-  intptr_t*   fp() const { return _fp; }\n+  intptr_t* fp() const { return _fp; }\n@@ -191,2 +200,2 @@\n-  \/\/ helper to update a map with callee-saved RBP\n-  static void update_map_with_saved_link(RegisterMap* map, intptr_t** link_addr);\n+  template <typename RegisterMapT>\n+  static void update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr);\n@@ -200,1 +209,1 @@\n-  frame sender_raw(RegisterMap* map) const;\n+  inline frame sender_raw(RegisterMap* map) const;\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n@@ -66,0 +68,3 @@\n+\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n@@ -92,0 +97,7 @@\n+\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n+}\n+\n+inline frame::frame(intptr_t* ptr_sp) {\n+  Unimplemented();\n@@ -122,0 +134,3 @@\n+\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n@@ -153,0 +168,32 @@\n+inline void frame::set_unextended_sp(intptr_t* value) {\n+  Unimplemented();\n+}\n+\n+inline int frame::offset_unextended_sp() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::set_offset_unextended_sp(int value) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* frame::real_fp() const {\n+  if (_cb != NULL) {\n+    \/\/ use the frame size if valid\n+    int size = _cb->frame_size();\n+    if (size > 0) {\n+      return unextended_sp() + size;\n+    }\n+  }\n+  \/\/ else rely on fp()\n+  assert(!is_compiled_frame(), \"unknown compiled frame size\");\n+  return fp();\n+}\n+\n+inline int frame::frame_size() const {\n+  return is_interpreted_frame()\n+    ? sender_sp() - sp()\n+    : cb()->frame_size();\n+}\n+\n@@ -163,1 +210,1 @@\n-  return *(intptr_t**)addr_at(interpreter_frame_last_sp_offset);\n+  return (intptr_t*)at(interpreter_frame_last_sp_offset);\n@@ -236,1 +283,1 @@\n-  oop* result_adr = (oop *)map->location(x10->as_VMReg());\n+  oop* result_adr = (oop *)map->location(x10->as_VMReg(), nullptr);\n@@ -242,1 +289,1 @@\n-  oop* result_adr = (oop *)map->location(x10->as_VMReg());\n+  oop* result_adr = (oop *)map->location(x10->as_VMReg(), nullptr);\n@@ -248,0 +295,114 @@\n+inline const ImmutableOopMap* frame::get_oop_map() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::compiled_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+}\n+\n+inline int frame::sender_sp_ret_address_offset() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+\/\/------------------------------------------------------------------------------\n+\/\/ frame::sender\n+frame frame::sender(RegisterMap* map) const {\n+  frame result = sender_raw(map);\n+\n+  if (map->process_frames()) {\n+    StackWatermarkSet::on_iteration(map->thread(), result);\n+  }\n+\n+  return result;\n+}\n+\n+\/\/------------------------------------------------------------------------------\n+\/\/ frame::sender_raw\n+frame frame::sender_raw(RegisterMap* map) const {\n+  \/\/ Default is we done have to follow them. The sender_for_xxx will\n+  \/\/ update it accordingly\n+  assert(map != NULL, \"map must be set\");\n+  map->set_include_argument_oops(false);\n+\n+  if (is_entry_frame()) {\n+    return sender_for_entry_frame(map);\n+  }\n+  if (is_interpreted_frame()) {\n+    return sender_for_interpreter_frame(map);\n+  }\n+  assert(_cb == CodeCache::find_blob(pc()),\"Must be the same\");\n+\n+  \/\/ This test looks odd: why is it not is_compiled_frame() ?  That's\n+  \/\/ because stubs also have OOP maps.\n+  if (_cb != NULL) {\n+    return sender_for_compiled_frame(map);\n+  }\n+\n+  \/\/ Must be native-compiled frame, i.e. the marshaling code for native\n+  \/\/ methods that exists in the core system.\n+  return frame(sender_sp(), link(), sender_pc());\n+}\n+\n+\/\/------------------------------------------------------------------------------\n+\/\/ frame::sender_for_compiled_frame\n+frame frame::sender_for_compiled_frame(RegisterMap* map) const {\n+  \/\/ we cannot rely upon the last fp having been saved to the thread\n+  \/\/ in C2 code but it will have been pushed onto the stack. so we\n+  \/\/ have to find it relative to the unextended sp\n+\n+  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n+  intptr_t* l_sender_sp = unextended_sp() + _cb->frame_size();\n+  intptr_t* unextended_sp = l_sender_sp;\n+\n+  \/\/ the return_address is always the word on the stack\n+  address sender_pc = (address) *(l_sender_sp + frame::return_addr_offset);\n+\n+  intptr_t** saved_fp_addr = (intptr_t**) (l_sender_sp + frame::link_offset);\n+\n+  assert(map != NULL, \"map must be set\");\n+  if (map->update_map()) {\n+    \/\/ Tell GC to use argument oopmaps for some runtime stubs that need it.\n+    \/\/ For C1, the runtime stub might not have oop maps, so set this flag\n+    \/\/ outside of update_register_map.\n+    map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n+    if (_cb->oop_maps() != NULL) {\n+      OopMapSet::update_register_map(this, map);\n+    }\n+\n+    \/\/ Since the prolog does the save and restore of FP there is no\n+    \/\/ oopmap for it so we must fill in its location as if there was\n+    \/\/ an oopmap entry since if our caller was compiled code there\n+    \/\/ could be live jvm state in it.\n+    update_map_with_saved_link(map, saved_fp_addr);\n+  }\n+\n+  return frame(l_sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+}\n+\n+\/\/------------------------------------------------------------------------------\n+\/\/ frame::update_map_with_saved_link\n+template <typename RegisterMapT>\n+void frame::update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr) {\n+  \/\/ The interpreter and compiler(s) always save fp in a known\n+  \/\/ location on entry. We must record where that location is\n+  \/\/ so that if fp was live on callout from c2 we can find\n+  \/\/ the saved copy no matter what it called.\n+\n+  \/\/ Since the interpreter always saves fp if we record where it is then\n+  \/\/ we don't have to always save fp on entry and exit to c2 compiled\n+  \/\/ code, on entry will be enough.\n+  assert(map != NULL, \"map must be set\");\n+  map->set_location(::fp->as_VMReg(), (address) link_addr);\n+  \/\/ this is weird \"H\" ought to be at a higher address however the\n+  \/\/ oopMaps seems to have the \"H\" regs at the same address and the\n+  \/\/ vanilla register.\n+  map->set_location(::fp->as_VMReg()->next(), (address) link_addr);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":164,"deletions":3,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"runtime\/frame.inline.hpp\"\n@@ -164,0 +165,4 @@\n+void BarrierSetNMethod::arm(nmethod* nm, int arm_value) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetNMethod_riscv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -572,0 +572,31 @@\n+class NativePostCallNop: public NativeInstruction {\n+public:\n+  bool check() const { Unimplemented(); return false; }\n+  int displacement() const { Unimplemented(); return 0; }\n+  void patch(jint diff) { Unimplemented(); }\n+  void make_deopt() { Unimplemented(); }\n+};\n+\n+inline NativePostCallNop* nativePostCallNop_at(address address) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+class NativeDeoptInstruction: public NativeInstruction {\n+public:\n+  address instruction_address() const       { Unimplemented(); return NULL; }\n+  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+\n+  void  verify() { Unimplemented(); }\n+\n+  static bool is_deopt_at(address instr) {\n+    Unimplemented();\n+    return false;\n+  }\n+\n+  \/\/ MT-safe patching\n+  static void insert(address code_pos) {\n+    Unimplemented();\n+  }\n+};\n+\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2021, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -36,1 +36,1 @@\n-    address base_location = location(base_reg);\n+    address base_location = location(base_reg, nullptr);\n@@ -43,1 +43,1 @@\n-    return location(base_reg->next(slot_idx));\n+    return location(base_reg->next(slot_idx), nullptr);\n","filename":"src\/hotspot\/cpu\/riscv\/registerMap_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_SMALLREGISTERMAP_RISCV_INLINE_HPP\n+#define CPU_RISCV_SMALLREGISTERMAP_RISCV_INLINE_HPP\n+\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_RISCV_SMALLREGISTERMAP_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/smallRegisterMap_riscv.inline.hpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_STACKCHUNKFRAMESTREAM_RISCV_INLINE_HPP\n+#define CPU_RISCV_STACKCHUNKFRAMESTREAM_RISCV_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+#ifdef ASSERT\n+template <ChunkFrames frame_kind>\n+inline bool StackChunkFrameStream<frame_kind>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <ChunkFrames frame_kind>\n+inline frame StackChunkFrameStream<frame_kind>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline address StackChunkFrameStream<frame_kind>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline intptr_t* StackChunkFrameStream<frame_kind>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+intptr_t* StackChunkFrameStream<frame_kind>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline void StackChunkFrameStream<frame_kind>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <ChunkFrames frame_kind>\n+inline int StackChunkFrameStream<frame_kind>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<ChunkFrames::Mixed>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<ChunkFrames::CompiledOnly>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <ChunkFrames frame_kind>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<frame_kind>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+#endif \/\/ CPU_RISCV_STACKCHUNKFRAMESTREAM_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_STACKCHUNKOOP_RISCV_INLINE_HPP\n+#define CPU_RISCV_STACKCHUNKOOP_RISCV_INLINE_HPP\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+#endif \/\/ CPU_RISCV_STACKCHUNKOOP_RISCV_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkOop_riscv.inline.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -3858,1 +3858,1 @@\n-void StubGenerator_generate(CodeBuffer* code, bool all) {\n+void StubGenerator_generate(CodeBuffer* code, int phase) {\n@@ -3863,1 +3863,1 @@\n-  StubGenerator g(code, all);\n+  StubGenerator g(code, phase);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -800,0 +800,5 @@\n+address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}