{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Comparator;\n@@ -800,0 +801,13 @@\n+    private static int stateToInt(Future.State s) {\n+        return switch (s) {\n+            case RUNNING   -> 0;\n+            case CANCELLED -> 1;\n+            case FAILED    -> 2;\n+            case SUCCESS   -> 3;\n+        };\n+    }\n+\n+    \/\/ RUNNING < CANCELLED < FAILED < SUCCESS\n+    static final Comparator<Future.State> FUTURE_STATE_COMPARATOR =\n+            Comparator.comparingInt(StructuredTaskScope::stateToInt);\n+\n@@ -815,3 +829,1 @@\n-        private static final VarHandle FIRST_SUCCESS;\n-        private static final VarHandle FIRST_FAILED;\n-        private static final VarHandle FIRST_CANCELLED;\n+        private static final VarHandle FUTURE;\n@@ -821,6 +833,2 @@\n-                FIRST_SUCCESS = l.findVarHandle(ShutdownOnSuccess.class,\n-                        \"firstSuccess\", Future.class);\n-                FIRST_FAILED = l.findVarHandle(ShutdownOnSuccess.class,\n-                        \"firstFailed\", Future.class);\n-                FIRST_CANCELLED = l.findVarHandle(ShutdownOnSuccess.class,\n-                        \"firstCancelled\", Future.class);\n+                FUTURE = l.findVarHandle(ShutdownOnSuccess.class,\n+                        \"future\", Future.class);\n@@ -831,3 +839,2 @@\n-        private volatile Future<T> firstSuccess;\n-        private volatile Future<T> firstFailed;\n-        private volatile Future<T> firstCancelled;\n+\n+        private volatile Future<T> future;\n@@ -875,6 +882,10 @@\n-            switch (future.state()) {\n-                case RUNNING -> throw new IllegalArgumentException(\"Task is not completed\");\n-                case SUCCESS -> {\n-                    \/\/ capture first task to complete normally\n-                    if (firstSuccess == null\n-                            && FIRST_SUCCESS.compareAndSet(this, null, future)) {\n+            Future.State state = future.state();\n+            if (state == Future.State.RUNNING) {\n+                throw new IllegalArgumentException(\"Task is not completed\");\n+            }\n+\n+            Future<T> currentFuture;\n+            while ((currentFuture = this.future) == null ||\n+                    FUTURE_STATE_COMPARATOR.compare(currentFuture.state(), state) < 0) {\n+                if (FUTURE.compareAndSet(this, currentFuture, future)) {\n+                    if (state == Future.State.SUCCESS) {\n@@ -883,12 +894,1 @@\n-                }\n-                case FAILED -> {\n-                    \/\/ capture first task to complete with an exception\n-                    if (firstSuccess == null && firstFailed == null) {\n-                        FIRST_FAILED.compareAndSet(this, null, future);\n-                    }\n-                }\n-                case CANCELLED ->  {\n-                    \/\/ capture the first cancelled task\n-                    if (firstSuccess == null && firstFailed == null && firstCancelled == null) {\n-                        FIRST_CANCELLED.compareAndSet(this, null, future);\n-                    }\n+                    break;\n@@ -944,8 +944,10 @@\n-            Future<T> f = firstSuccess;\n-            if (f != null)\n-                return f.resultNow();\n-            if ((f = firstFailed) != null)\n-                throw new ExecutionException(f.exceptionNow());\n-            if (firstCancelled != null)\n-                throw new CancellationException();\n-            throw new IllegalStateException(\"No completed tasks\");\n+            Future<T> f = future;\n+            if (f == null) {\n+                throw new IllegalStateException(\"No completed tasks\");\n+            }\n+            return switch (f.state()) {\n+                case SUCCESS   -> f.resultNow();\n+                case FAILED    -> throw new ExecutionException(f.exceptionNow());\n+                case CANCELLED -> throw new CancellationException();\n+                default        -> throw new InternalError(\"Unexpected value: \" + f.state());\n+            };\n@@ -977,8 +979,4 @@\n-            Future<T> f = firstSuccess;\n-            if (f != null)\n-                return f.resultNow();\n-            Throwable throwable = null;\n-            if ((f = firstFailed) != null) {\n-                throwable = f.exceptionNow();\n-            } else if (firstCancelled != null) {\n-                throwable = new CancellationException();\n+\n+            Future<T> f = future;\n+            if (f == null) {\n+                throw new IllegalStateException(\"No completed tasks\");\n@@ -986,4 +984,4 @@\n-            if (throwable != null) {\n-                X ex = esf.apply(throwable);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n+\n+            Future.State state = f.state();\n+            if (state == Future.State.SUCCESS) {\n+                return f.resultNow();\n@@ -991,1 +989,6 @@\n-            throw new IllegalStateException(\"No tasks completed\");\n+\n+            Throwable throwable = (state == Future.State.FAILED)\n+                    ? f.exceptionNow()\n+                    : new CancellationException();\n+\n+            throw Objects.requireNonNull(esf.apply(throwable), \"esf returned null\");\n@@ -1008,2 +1011,1 @@\n-        private static final VarHandle FIRST_FAILED;\n-        private static final VarHandle FIRST_CANCELLED;\n+        private static final VarHandle FUTURE;\n@@ -1013,4 +1015,2 @@\n-                FIRST_FAILED = l.findVarHandle(ShutdownOnFailure.class,\n-                        \"firstFailed\", Future.class);\n-                FIRST_CANCELLED = l.findVarHandle(ShutdownOnFailure.class,\n-                        \"firstCancelled\", Future.class);\n+                FUTURE = l.findVarHandle(ShutdownOnFailure.class,\n+                        \"future\", Future.class);\n@@ -1021,2 +1021,2 @@\n-        private volatile Future<Object> firstFailed;\n-        private volatile Future<Object> firstCancelled;\n+\n+        private volatile Future<Object> future;\n@@ -1065,14 +1065,16 @@\n-            switch (future.state()) {\n-                case RUNNING -> throw new IllegalArgumentException(\"Task is not completed\");\n-                case SUCCESS -> { }\n-                case FAILED -> {\n-                    if (firstFailed == null\n-                            && FIRST_FAILED.compareAndSet(this, null, future)) {\n-                        shutdown();\n-                    }\n-                }\n-                case CANCELLED -> {\n-                    if (firstFailed == null && firstCancelled == null\n-                            && FIRST_CANCELLED.compareAndSet(this, null, future)) {\n-                        shutdown();\n-                    }\n+            Future.State state = future.state();\n+            if (state == Future.State.RUNNING) {\n+                throw new IllegalArgumentException(\"Task is not completed\");\n+            }\n+\n+            if (state == Future.State.SUCCESS) {\n+                return;\n+            }\n+\n+            \/\/ A cancelled task causes shutdown, a subsequent failed task overrides\n+            Future<Object> currentFuture;\n+            while ((currentFuture = this.future) == null ||\n+                    FUTURE_STATE_COMPARATOR.compare(currentFuture.state(), state) < 0) {\n+                if (FUTURE.compareAndSet(this, currentFuture, future)) {\n+                    shutdown();\n+                    break;\n@@ -1124,6 +1126,8 @@\n-            Future<Object> f = firstFailed;\n-            if (f != null)\n-                return Optional.of(f.exceptionNow());\n-            if (firstCancelled != null)\n-                return Optional.of(new CancellationException());\n-            return Optional.empty();\n+            Future<Object> f = future;\n+            if (f == null) {\n+                return Optional.empty();\n+            }\n+\n+            return Optional.of(f.state() == Future.State.FAILED\n+                    ? f.exceptionNow()\n+                    : new CancellationException());\n@@ -1149,2 +1153,6 @@\n-            Future<Object> f = firstFailed;\n-            if (f != null)\n+            Future<Object> f = future;\n+            if (f == null) {\n+                return;\n+            }\n+\n+            if (f.state() == Future.State.FAILED) {\n@@ -1152,1 +1160,1 @@\n-            if (firstCancelled != null)\n+            } else {\n@@ -1154,0 +1162,1 @@\n+            }\n@@ -1176,11 +1185,4 @@\n-            Throwable throwable = null;\n-            Future<Object> f = firstFailed;\n-            if (f != null) {\n-                throwable = f.exceptionNow();\n-            } else if (firstCancelled != null) {\n-                throwable = new CancellationException();\n-            }\n-            if (throwable != null) {\n-                X ex = esf.apply(throwable);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n+\n+            Future<Object> f = future;\n+            if (f == null) {\n+                return;\n@@ -1188,0 +1190,6 @@\n+\n+            Throwable throwable = f.state() == Future.State.FAILED\n+                    ? f.exceptionNow()\n+                    : new CancellationException();\n+\n+            throw Objects.requireNonNull(esf.apply(throwable), \"esf returned null\");\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":101,"deletions":93,"binary":false,"changes":194,"status":"modified"}]}