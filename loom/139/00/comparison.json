{"files":[{"patch":"@@ -65,1 +65,1 @@\n-frame FreezeBase::new_hframe(frame& f, frame& caller) {\n+frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n@@ -88,1 +88,5 @@\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset); \/\/ we need to re-read fp because it may be an oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ we need to re-read fp because it may be an oop and we might have had a safepoint in finalize_freeze,\n+    \/\/ after constructing f.\n+    \/\/ This comment doesn't make sense since we don't reread fp\n+    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+\n@@ -179,1 +183,1 @@\n-template<typename FKind> frame ThawBase::new_frame(const frame& hf, frame& caller, bool bottom) {\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n","filename":"src\/hotspot\/cpu\/aarch64\/continuation_aarch64.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-template<typename FKind> frame FreezeBase::new_hframe(frame& f, frame& caller) {\n+template<typename FKind> frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n@@ -81,1 +81,1 @@\n-template<typename FKind> frame ThawBase::new_frame(const frame& hf, frame& caller, bool bottom) {\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n","filename":"src\/hotspot\/cpu\/arm\/continuation_arm.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-template<typename FKind> frame FreezeBase::new_hframe(frame& f, frame& caller) {\n+template<typename FKind> frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n@@ -81,1 +81,1 @@\n-template<typename FKind> frame ThawBase::new_frame(const frame& hf, frame& caller, bool bottom) {\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n","filename":"src\/hotspot\/cpu\/ppc\/continuation_ppc.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-template<typename FKind> frame FreezeBase::new_hframe(frame& f, frame& caller) {\n+template<typename FKind> frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n@@ -81,1 +81,1 @@\n-template<typename FKind> frame ThawBase::new_frame(const frame& hf, frame& caller, bool bottom) {\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n","filename":"src\/hotspot\/cpu\/s390\/continuation_s390.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-frame FreezeBase::new_hframe(frame& f, frame& caller) {\n+frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n@@ -90,1 +90,1 @@\n-    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n+    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ?  ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n@@ -102,1 +102,5 @@\n-    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset); \/\/ we need to re-read fp because it may be an oop and we might have had a safepoint in finalize_freeze, after constructing f.\n+    \/\/ we need to re-read fp because it may be an oop and we might have had a safepoint in\n+    \/\/ finalize_freeze, after constructing f.\n+    \/\/ This comment doesn't make sense since we don't reread fp\n+    fp = *(intptr_t**)(f.sp() - frame::sender_sp_offset);\n+\n@@ -194,1 +198,1 @@\n-template<typename FKind> frame ThawBase::new_frame(const frame& hf, frame& caller, bool bottom) {\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n","filename":"src\/hotspot\/cpu\/x86\/continuation_x86.inline.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-template<typename FKind> frame FreezeBase::new_hframe(frame& f, frame& caller) {\n+template<typename FKind> frame FreezeBase::new_heap_frame(frame& f, frame& caller) {\n@@ -81,1 +81,1 @@\n-template<typename FKind> frame ThawBase::new_frame(const frame& hf, frame& caller, bool bottom) {\n+template<typename FKind> frame ThawBase::new_stack_frame(const frame& hf, frame& caller, bool bottom) {\n","filename":"src\/hotspot\/cpu\/zero\/continuation_zero.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-template<typename ConfigT> static inline int freeze0(JavaThread* current, intptr_t* const sp);\n+template<typename ConfigT> static inline int freeze_internal(JavaThread* current, intptr_t* const sp);\n@@ -212,2 +212,2 @@\n-static inline int prepare_thaw0(JavaThread* thread, bool return_barrier);\n-template<typename ConfigT> static inline intptr_t* thaw0(JavaThread* thread, const thaw_kind kind);\n+static inline int prepare_thaw_internal(JavaThread* thread, bool return_barrier);\n+template<typename ConfigT> static inline intptr_t* thaw_internal(JavaThread* thread, const thaw_kind kind);\n@@ -225,1 +225,1 @@\n-    return freeze0<SelfT>(thread, sp);\n+    return freeze_internal<SelfT>(thread, sp);\n@@ -229,1 +229,1 @@\n-    return thaw0<SelfT>(thread, kind);\n+    return thaw_internal<SelfT>(thread, kind);\n@@ -540,1 +540,1 @@\n-  return prepare_thaw0(thread, return_barrier);\n+  return prepare_thaw_internal(thread, return_barrier);\n@@ -977,1 +977,1 @@\n-  template<typename FKind> frame new_hframe(frame& f, frame& caller);\n+  template<typename FKind> frame new_heap_frame(frame& f, frame& caller);\n@@ -1000,2 +1000,2 @@\n-  template <bool chunk_available> freeze_result try_freeze_fast(intptr_t* sp);\n-  template <bool chunk_available> bool freeze_fast(intptr_t* top_sp);\n+  freeze_result try_freeze_fast(intptr_t* sp, bool chunk_available);\n+  bool freeze_fast(intptr_t* top_sp, bool chunk_available);\n@@ -1061,3 +1061,2 @@\n-template <bool chunk_available>\n-freeze_result Freeze<ConfigT>::try_freeze_fast(intptr_t* sp) {\n-  if (freeze_fast<chunk_available>(sp)) {\n+freeze_result Freeze<ConfigT>::try_freeze_fast(intptr_t* sp, bool chunk_available) {\n+  if (freeze_fast(sp, chunk_available)) {\n@@ -1115,2 +1114,1 @@\n-template <bool chunk_available>\n-bool Freeze<ConfigT>::freeze_fast(intptr_t* top_sp) {\n+bool Freeze<ConfigT>::freeze_fast(intptr_t* top_sp, bool chunk_available) {\n@@ -1605,1 +1603,1 @@\n-  frame hf = new_hframe<ContinuationHelper::InterpretedFrame>(f, caller);\n+  frame hf = new_heap_frame<ContinuationHelper::InterpretedFrame>(f, caller);\n@@ -1651,1 +1649,1 @@\n-  frame hf = new_hframe<ContinuationHelper::CompiledFrame>(f, caller);\n+  frame hf = new_heap_frame<ContinuationHelper::CompiledFrame>(f, caller);\n@@ -1706,1 +1704,1 @@\n-  frame hf = new_hframe<ContinuationHelper::StubFrame>(f, caller);\n+  frame hf = new_heap_frame<ContinuationHelper::StubFrame>(f, caller);\n@@ -1952,1 +1950,1 @@\n-static inline int freeze0(JavaThread* current, intptr_t* const sp) {\n+static inline int freeze_internal(JavaThread* current, intptr_t* const sp) {\n@@ -1954,2 +1952,0 @@\n-  \/\/ This was a bug once?\n-  \/\/ assert(current->deferred_updates() == nullptr || current->deferred_updates()->count() == 0, \"\");\n@@ -1983,3 +1979,0 @@\n-  bool fast = can_freeze_fast(current);\n-  assert(!fast || current->held_monitor_count() == 0, \"\");\n-\n@@ -1988,0 +1981,1 @@\n+  bool fast = can_freeze_fast(current);\n@@ -1989,1 +1983,1 @@\n-    freeze_result res = fr.template try_freeze_fast<true>(sp);\n+    freeze_result res = fr.try_freeze_fast(sp, true);\n@@ -2000,1 +1994,1 @@\n-    freeze_result res = fast ? fr.template try_freeze_fast<false>(sp)\n+    freeze_result res = fast ? fr.try_freeze_fast(sp, false)\n@@ -2066,1 +2060,1 @@\n-static inline int prepare_thaw0(JavaThread* thread, bool return_barrier) {\n+static inline int prepare_thaw_internal(JavaThread* thread, bool return_barrier) {\n@@ -2080,0 +2074,1 @@\n+  \/\/ Comment needed: Why would the tail chunk be empty? Why do you get the parent?\n@@ -2090,0 +2085,2 @@\n+  \/\/ Comment needed: Just the size for the first chunk? Isn't there a linked list of chunks?\n+  \/\/ Don't you need the sum of their sizes?\n@@ -2099,0 +2096,1 @@\n+  \/\/ 300 ?\n@@ -2146,1 +2144,1 @@\n-  void thaw(const frame& hf, frame& caller, int num_frames, bool top);\n+  void thaw_one_frame(const frame& heap_frame, frame& caller, int num_frames, bool top);\n@@ -2162,1 +2160,1 @@\n-  template<typename FKind> frame new_frame(const frame& hf, frame& caller, bool bottom);\n+  template<typename FKind> frame new_stack_frame(const frame& hf, frame& caller, bool bottom);\n@@ -2189,0 +2187,1 @@\n+  \/\/ Comment in assert needed: is entryPC in the heap? or enterSpecial stub frame?\n@@ -2199,0 +2198,1 @@\n+  \/\/ I have no idea what config does in this function.\n@@ -2206,1 +2206,0 @@\n-  assert(chunk != nullptr, \"\");\n@@ -2208,1 +2207,0 @@\n-  assert(!chunk->is_empty(), \"\");\n@@ -2216,0 +2214,1 @@\n+  \/\/ LogTarget might generate some test code\n@@ -2223,0 +2222,1 @@\n+  \/\/ Comment needed: why is 500? Related to 300 in can_thaw_fast?\n@@ -2341,3 +2341,0 @@\n-  assert(!_cont.is_empty(), \"\");\n-  assert(chunk != nullptr, \"\");\n-  assert(!chunk->is_empty(), \"\");\n@@ -2352,0 +2349,1 @@\n+  \/\/ Does this need ifdef JFR around it? Or can we remove all the conditional JFR inclusions (better)?\n@@ -2366,1 +2364,1 @@\n-  frame hf = _stream.to_frame();\n+  frame heap_frame = _stream.to_frame();\n@@ -2370,2 +2368,2 @@\n-    assert(hf.is_heap_frame(), \"should have created a relative frame\");\n-    hf.print_on(&ls);\n+    assert(heap_frame.is_heap_frame(), \"should have created a relative frame\");\n+    heap_frame.print_on(&ls);\n@@ -2374,3 +2372,3 @@\n-  frame f;\n-  thaw(hf, f, num_frames, true);\n-  finish_thaw(f); \/\/ f is now the topmost thawed frame\n+  frame caller;\n+  thaw_one_frame(heap_frame, caller, num_frames, true);\n+  finish_thaw(caller); \/\/ caller is now the topmost thawed frame\n@@ -2385,1 +2383,1 @@\n-  intptr_t* sp = f.sp();\n+  intptr_t* sp = caller.sp();\n@@ -2402,1 +2400,1 @@\n-void ThawBase::thaw(const frame& hf, frame& caller, int num_frames, bool top) {\n+void ThawBase::thaw_one_frame(const frame& heap_frame, frame& caller, int num_frames, bool top) {\n@@ -2406,1 +2404,1 @@\n-  assert(!hf.is_empty(), \"\");\n+  assert(!heap_frame.is_empty(), \"\");\n@@ -2408,5 +2406,5 @@\n-  if (top && hf.is_safepoint_blob_frame()) {\n-    assert(ContinuationHelper::Frame::is_stub(hf.cb()), \"cb: %s\", hf.cb()->name());\n-    recurse_thaw_stub_frame(hf, caller, num_frames);\n-  } else if (!hf.is_interpreted_frame()) {\n-    recurse_thaw_compiled_frame(hf, caller, num_frames, false);\n+  if (top && heap_frame.is_safepoint_blob_frame()) {\n+    assert(ContinuationHelper::Frame::is_stub(heap_frame.cb()), \"cb: %s\", heap_frame.cb()->name());\n+    recurse_thaw_stub_frame(heap_frame, caller, num_frames);\n+  } else if (!heap_frame.is_interpreted_frame()) {\n+    recurse_thaw_compiled_frame(heap_frame, caller, num_frames, false);\n@@ -2414,1 +2412,1 @@\n-    recurse_thaw_interpreted_frame(hf, caller, num_frames);\n+    recurse_thaw_interpreted_frame(heap_frame, caller, num_frames);\n@@ -2440,1 +2438,1 @@\n-    thaw(_stream.to_frame(), caller, num_frames - 1, false);\n+    thaw_one_frame(_stream.to_frame(), caller, num_frames - 1, false);\n@@ -2526,1 +2524,1 @@\n-  frame f = new_frame<ContinuationHelper::InterpretedFrame>(hf, caller, bottom);\n+  frame f = new_stack_frame<ContinuationHelper::InterpretedFrame>(hf, caller, bottom);\n@@ -2598,1 +2596,1 @@\n-  frame f = new_frame<ContinuationHelper::CompiledFrame>(hf, caller, bottom);\n+  frame f = new_stack_frame<ContinuationHelper::CompiledFrame>(hf, caller, bottom);\n@@ -2673,1 +2671,1 @@\n-  frame f = new_frame<ContinuationHelper::StubFrame>(hf, caller, false);\n+  frame f = new_stack_frame<ContinuationHelper::StubFrame>(hf, caller, false);\n@@ -2750,1 +2748,1 @@\n-static inline intptr_t* thaw0(JavaThread* thread, const thaw_kind kind) {\n+static inline intptr_t* thaw_internal(JavaThread* thread, const thaw_kind kind) {\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":51,"deletions":53,"binary":false,"changes":104,"status":"modified"}]}