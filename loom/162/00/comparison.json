{"files":[{"patch":"@@ -196,2 +196,2 @@\n-JVM_ScopeLocalCache\n-JVM_SetScopeLocalCache\n+JVM_ExtentLocalCache\n+JVM_SetExtentLocalCache\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-  case vmIntrinsics::_scopeLocalCache:\n+  case vmIntrinsics::_extentLocalCache:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1420,2 +1420,2 @@\n-void LIRGenerator::do_scopeLocalCache(Intrinsic* x) {\n-  do_JavaThreadField(x, JavaThread::scopeLocalCache_offset());\n+void LIRGenerator::do_extentLocalCache(Intrinsic* x) {\n+  do_JavaThreadField(x, JavaThread::extentLocalCache_offset());\n@@ -2963,1 +2963,1 @@\n-  case vmIntrinsics::_scopeLocalCache: do_scopeLocalCache(x); break;\n+  case vmIntrinsics::_extentLocalCache: do_extentLocalCache(x); break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  void do_scopeLocalCache(Intrinsic* x);\n+  void do_extentLocalCache(Intrinsic* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1792,1 +1792,1 @@\n-int java_lang_Thread::_scopeLocalBindings_offset;\n+int java_lang_Thread::_extentLocalBindings_offset;\n@@ -1805,1 +1805,1 @@\n-  macro(_scopeLocalBindings_offset, k, \"scopeLocalBindings\", object_signature, false);\n+  macro(_extentLocalBindings_offset, k, \"extentLocalBindings\", object_signature, false);\n@@ -1838,2 +1838,2 @@\n-void java_lang_Thread::clear_scopeLocalBindings(oop java_thread) {\n-  java_thread->obj_field_put(_scopeLocalBindings_offset, NULL);\n+void java_lang_Thread::clear_extentLocalBindings(oop java_thread) {\n+  java_thread->obj_field_put(_extentLocalBindings_offset, NULL);\n@@ -4882,1 +4882,1 @@\n-      mirror->int_field_put(fd->offset(), ScopeLocalCacheSize ? exact_log2(ScopeLocalCacheSize) : -1);\n+      mirror->int_field_put(fd->offset(), ExtentLocalCacheSize ? exact_log2(ExtentLocalCacheSize) : -1);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -421,1 +421,1 @@\n-  static int _scopeLocalBindings_offset;\n+  static int _extentLocalBindings_offset;\n@@ -471,1 +471,1 @@\n-  static void clear_scopeLocalBindings(oop java_thread);\n+  static void clear_extentLocalBindings(oop java_thread);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  case vmIntrinsics::_scopeLocalCache:\n+  case vmIntrinsics::_extentLocalCache:\n@@ -130,2 +130,2 @@\n-  case vmIntrinsics::_scopeLocalCache:\n-  case vmIntrinsics::_setScopeLocalCache:\n+  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_setExtentLocalCache:\n@@ -267,2 +267,2 @@\n-  case vmIntrinsics::_scopeLocalCache:\n-  case vmIntrinsics::_setScopeLocalCache:\n+  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_setExtentLocalCache:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -262,6 +262,6 @@\n-  do_intrinsic(_scopeLocalCache,          java_lang_Thread,       scopeLocalCache_name, scopeLocalCache_signature, F_SN) \\\n-   do_name(     scopeLocalCache_name,                            \"scopeLocalCache\")                                     \\\n-   do_signature(scopeLocalCache_signature,                       \"()[Ljava\/lang\/Object;\")                               \\\n-  do_intrinsic(_setScopeLocalCache,       java_lang_Thread,       setScopeLocalCache_name, setScopeLocalCache_signature, F_SN) \\\n-   do_name(     setScopeLocalCache_name,                         \"setScopeLocalCache\")                                  \\\n-   do_signature(setScopeLocalCache_signature,                    \"([Ljava\/lang\/Object;)V\")                              \\\n+  do_intrinsic(_extentLocalCache,          java_lang_Thread,       extentLocalCache_name, extentLocalCache_signature, F_SN) \\\n+   do_name(     extentLocalCache_name,                            \"extentLocalCache\")                                     \\\n+   do_signature(extentLocalCache_signature,                       \"()[Ljava\/lang\/Object;\")                               \\\n+  do_intrinsic(_setExtentLocalCache,       java_lang_Thread,       setExtentLocalCache_name, setExtentLocalCache_signature, F_SN) \\\n+   do_name(     setExtentLocalCache_name,                         \"setExtentLocalCache\")                                  \\\n+   do_signature(setExtentLocalCache_signature,                    \"([Ljava\/lang\/Object;)V\")                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -319,1 +319,1 @@\n-JVM_ScopeLocalCache(JNIEnv *env, jclass threadClass);\n+JVM_ExtentLocalCache(JNIEnv *env, jclass threadClass);\n@@ -322,1 +322,1 @@\n-JVM_SetScopeLocalCache(JNIEnv *env, jclass threadClass, jobject theCache);\n+JVM_SetExtentLocalCache(JNIEnv *env, jclass threadClass, jobject theCache);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1521,1 +1521,1 @@\n-    GrowableArray<ScopeValue*>* scopeLocals = cvf->scope()->locals();\n+    GrowableArray<ScopeValue*>* extentLocals = cvf->scope()->locals();\n@@ -1526,1 +1526,1 @@\n-        if (var->type() == T_OBJECT && scopeLocals->at(i2)->is_object()) {\n+        if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -644,2 +644,2 @@\n-  case vmIntrinsics::_scopeLocalCache:\n-  case vmIntrinsics::_setScopeLocalCache:\n+  case vmIntrinsics::_extentLocalCache:\n+  case vmIntrinsics::_setExtentLocalCache:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -475,2 +475,2 @@\n-  case vmIntrinsics::_scopeLocalCache:          return inline_native_scopeLocalCache();\n-  case vmIntrinsics::_setScopeLocalCache:       return inline_native_setScopeLocalCache();\n+  case vmIntrinsics::_extentLocalCache:          return inline_native_extentLocalCache();\n+  case vmIntrinsics::_setExtentLocalCache:       return inline_native_setExtentLocalCache();\n@@ -3447,1 +3447,1 @@\n-Node* LibraryCallKit::scopeLocalCache_helper() {\n+Node* LibraryCallKit::extentLocalCache_helper() {\n@@ -3454,1 +3454,1 @@\n-  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::scopeLocalCache_offset()));\n+  Node* p = basic_plus_adr(top()\/*!oop*\/, thread, in_bytes(JavaThread::extentLocalCache_offset()));\n@@ -3459,2 +3459,2 @@\n-\/\/------------------------inline_native_scopeLocalCache------------------\n-bool LibraryCallKit::inline_native_scopeLocalCache() {\n+\/\/------------------------inline_native_extentLocalCache------------------\n+bool LibraryCallKit::inline_native_extentLocalCache() {\n@@ -3465,1 +3465,1 @@\n-  \/\/ Because we create the scopeLocal cache lazily we have to make the\n+  \/\/ Because we create the extentLocal cache lazily we have to make the\n@@ -3469,1 +3469,1 @@\n-  Node* cache_obj_handle = scopeLocalCache_helper();\n+  Node* cache_obj_handle = extentLocalCache_helper();\n@@ -3475,2 +3475,2 @@\n-\/\/------------------------inline_native_setScopeLocalCache------------------\n-bool LibraryCallKit::inline_native_setScopeLocalCache() {\n+\/\/------------------------inline_native_setExtentLocalCache------------------\n+bool LibraryCallKit::inline_native_setExtentLocalCache() {\n@@ -3478,1 +3478,1 @@\n-  Node* cache_obj_handle = scopeLocalCache_helper();\n+  Node* cache_obj_handle = extentLocalCache_helper();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -242,3 +242,3 @@\n-  bool inline_native_scopeLocalCache();\n-  Node* scopeLocalCache_helper();\n-  bool inline_native_setScopeLocalCache();\n+  bool inline_native_extentLocalCache();\n+  Node* extentLocalCache_helper();\n+  bool inline_native_setExtentLocalCache();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -861,1 +861,1 @@\n-      in_bytes(JavaThread::scopeLocalCache_offset()),\n+      in_bytes(JavaThread::extentLocalCache_offset()),\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3182,2 +3182,2 @@\n-JVM_ENTRY(jobject, JVM_ScopeLocalCache(JNIEnv* env, jclass threadClass))\n-  oop theCache = thread->scopeLocalCache();\n+JVM_ENTRY(jobject, JVM_ExtentLocalCache(JNIEnv* env, jclass threadClass))\n+  oop theCache = thread->extentLocalCache();\n@@ -3186,1 +3186,1 @@\n-    assert(objs->length() == ScopeLocalCacheSize * 2, \"wrong length\");\n+    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n@@ -3191,1 +3191,1 @@\n-JVM_ENTRY(void, JVM_SetScopeLocalCache(JNIEnv* env, jclass threadClass,\n+JVM_ENTRY(void, JVM_SetExtentLocalCache(JNIEnv* env, jclass threadClass,\n@@ -3195,1 +3195,1 @@\n-    assert(objs->length() == ScopeLocalCacheSize * 2, \"wrong length\");\n+    assert(objs->length() == ExtentLocalCacheSize * 2, \"wrong length\");\n@@ -3197,1 +3197,1 @@\n-  thread->set_scopeLocalCache(objs);\n+  thread->set_extentLocalCache(objs);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -446,1 +446,1 @@\n-    \/\/ FIXME: This very crudely destroys all ScopeLocal bindings. This\n+    \/\/ FIXME: This very crudely destroys all ExtentLocal bindings. This\n@@ -449,2 +449,2 @@\n-    current->set_scopeLocalCache(NULL);\n-    java_lang_Thread::clear_scopeLocalBindings(java_thread);\n+    current->set_extentLocalCache(NULL);\n+    java_lang_Thread::clear_extentLocalBindings(java_thread);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-JVMFlag::Error ScopeLocalCacheSizeConstraintFunc(intx value, bool verbose) {\n+JVMFlag::Error ExtentLocalCacheSizeConstraintFunc(intx value, bool verbose) {\n@@ -98,1 +98,1 @@\n-                        \"ScopeLocalCacheSize (\" INTX_FORMAT \") must be \"\n+                        \"ExtentLocalCacheSize (\" INTX_FORMAT \") must be \"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  f(intx,   ScopeLocalCacheSizeConstraintFunc)        \\\n+  f(intx,   ExtentLocalCacheSizeConstraintFunc)        \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2019,1 +2019,1 @@\n-  product(intx, ScopeLocalCacheSize, 16,                                    \\\n+  product(intx, ExtentLocalCacheSize, 16,                                    \\\n@@ -2022,1 +2022,1 @@\n-           constraint(ScopeLocalCacheSizeConstraintFunc, AtParse)           \\\n+           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)           \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -808,3 +808,3 @@\n-  \/\/ Remove the ScopeLocal cache in case we got a StackOverflowError\n-  \/\/ while we were trying to remove ScopeLocal bindings.\n-  current->set_scopeLocalCache(NULL);\n+  \/\/ Remove the ExtentLocal cache in case we got a StackOverflowError\n+  \/\/ while we were trying to remove ExtentLocal bindings.\n+  current->set_extentLocalCache(NULL);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -792,1 +792,1 @@\n-  _scopeLocalCache = OopHandle(_thread_oop_storage, NULL);\n+  _extentLocalCache = OopHandle(_thread_oop_storage, NULL);\n@@ -817,2 +817,2 @@\n-oop JavaThread::scopeLocalCache() const {\n-  return _scopeLocalCache.resolve();\n+oop JavaThread::extentLocalCache() const {\n+  return _extentLocalCache.resolve();\n@@ -821,1 +821,1 @@\n-void JavaThread::set_scopeLocalCache(oop p) {\n+void JavaThread::set_extentLocalCache(oop p) {\n@@ -823,1 +823,1 @@\n-  _scopeLocalCache.replace(p);\n+  _extentLocalCache.replace(p);\n@@ -1679,2 +1679,2 @@\n-    \/\/ Clear any scope-local bindings on ThreadDeath\n-    set_scopeLocalCache(NULL);\n+    \/\/ Clear any extent-local bindings on ThreadDeath\n+    set_extentLocalCache(NULL);\n@@ -1683,1 +1683,1 @@\n-    java_lang_Thread::clear_scopeLocalBindings(threadOop);\n+    java_lang_Thread::clear_extentLocalBindings(threadOop);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -708,1 +708,1 @@\n-  OopHandle      _scopeLocalCache;\n+  OopHandle      _extentLocalCache;\n@@ -1066,1 +1066,1 @@\n-  jlong _scopeLocal_hash_table_shift;\n+  jlong _extentLocal_hash_table_shift;\n@@ -1068,1 +1068,1 @@\n-  void allocate_scopeLocal_hash_table(int count);\n+  void allocate_extentLocal_hash_table(int count);\n@@ -1122,2 +1122,2 @@\n-  oop scopeLocalCache() const;\n-  void set_scopeLocalCache(oop p);\n+  oop extentLocalCache() const;\n+  void set_extentLocalCache(oop p);\n@@ -1342,1 +1342,1 @@\n-  static ByteSize scopeLocalCache_offset()       { return byte_offset_of(JavaThread, _scopeLocalCache); }\n+  static ByteSize extentLocalCache_offset()       { return byte_offset_of(JavaThread, _extentLocalCache); }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-  GrowableArray<ScopeValue*>* scopeLocals = scope()->locals();\n+  GrowableArray<ScopeValue*>* extentLocals = scope()->locals();\n@@ -153,1 +153,1 @@\n-      if (var->type() == T_OBJECT && scopeLocals->at(i2)->is_object()) {\n+      if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -717,1 +717,1 @@\n-  nonstatic_field(JavaThread,                  _scopeLocalCache,                              OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _extentLocalCache,                              OopHandle)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2544,2 +2544,2 @@\n-            public Object[] scopeLocalCache() {\n-                return Thread.scopeLocalCache();\n+            public Object[] extentLocalCache() {\n+                return Thread.extentLocalCache();\n@@ -2548,2 +2548,2 @@\n-            public void setScopeLocalCache(Object[] cache) {\n-                Thread.setScopeLocalCache(cache);\n+            public void setExtentLocalCache(Object[] cache) {\n+                Thread.setExtentLocalCache(cache);\n@@ -2552,2 +2552,2 @@\n-            public Object scopeLocalBindings() {\n-                return Thread.scopeLocalBindings();\n+            public Object extentLocalBindings() {\n+                return Thread.extentLocalBindings();\n@@ -2556,2 +2556,2 @@\n-            public void setScopeLocalBindings(Object bindings) {\n-                Thread.setScopeLocalBindings(bindings);\n+            public void setExtentLocalBindings(Object bindings) {\n+                Thread.setExtentLocalBindings(bindings);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-import jdk.internal.vm.ScopeLocalContainer;\n+import jdk.internal.vm.ExtentLocalContainer;\n@@ -247,1 +247,1 @@\n-     * Scope locals binding are maintained by the ScopeLocal class.\n+     * Scope locals binding are maintained by the ExtentLocal class.\n@@ -249,1 +249,1 @@\n-    private Object scopeLocalBindings;\n+    private Object extentLocalBindings;\n@@ -251,2 +251,2 @@\n-    static Object scopeLocalBindings() {\n-        return currentThread().scopeLocalBindings;\n+    static Object extentLocalBindings() {\n+        return currentThread().extentLocalBindings;\n@@ -255,2 +255,2 @@\n-    static void setScopeLocalBindings(Object bindings) {\n-        currentThread().scopeLocalBindings = bindings;\n+    static void setExtentLocalBindings(Object bindings) {\n+        currentThread().extentLocalBindings = bindings;\n@@ -260,1 +260,1 @@\n-     * Inherit the scope-local bindings from the given container.\n+     * Inherit the extent-local bindings from the given container.\n@@ -263,2 +263,2 @@\n-    void inheritScopeLocalBindings(ThreadContainer container) {\n-        ScopeLocalContainer.BindingsSnapshot snapshot;\n+    void inheritExtentLocalBindings(ThreadContainer container) {\n+        ExtentLocalContainer.BindingsSnapshot snapshot;\n@@ -266,1 +266,1 @@\n-                && (snapshot = container.scopeLocalBindings()) != null) {\n+                && (snapshot = container.extentLocalBindings()) != null) {\n@@ -269,2 +269,2 @@\n-            Object bindings = snapshot.scopeLocalBindings();\n-            if (currentThread().scopeLocalBindings != bindings) {\n+            Object bindings = snapshot.extentLocalBindings();\n+            if (currentThread().extentLocalBindings != bindings) {\n@@ -274,1 +274,1 @@\n-            this.scopeLocalBindings = bindings;\n+            this.extentLocalBindings = bindings;\n@@ -361,1 +361,1 @@\n-    \/\/ ScopeLocal support:\n+    \/\/ ExtentLocal support:\n@@ -364,1 +364,1 @@\n-    static native Object[] scopeLocalCache();\n+    static native Object[] extentLocalCache();\n@@ -367,1 +367,1 @@\n-    static native void setScopeLocalCache(Object[] cache);\n+    static native void setExtentLocalCache(Object[] cache);\n@@ -1521,1 +1521,1 @@\n-                inheritScopeLocalBindings(container);\n+                inheritExtentLocalBindings(container);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -455,1 +455,1 @@\n-            inheritScopeLocalBindings(container);\n+            inheritExtentLocalBindings(container);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-        \/\/ any ScopeLocals to have yet been bound by this thread, so the\n+        \/\/ any ExtentLocals to have yet been bound by this thread, so the\n@@ -410,1 +410,1 @@\n-    \/\/ used by ScopeLocal\n+    \/\/ used by ExtentLocal\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -469,1 +469,1 @@\n-    Object[] scopeLocalCache();\n+    Object[] extentLocalCache();\n@@ -474,1 +474,1 @@\n-    void setScopeLocalCache(Object[] cache);\n+    void setExtentLocalCache(Object[] cache);\n@@ -479,1 +479,1 @@\n-    Object scopeLocalBindings();\n+    Object extentLocalBindings();\n@@ -484,1 +484,1 @@\n-    void setScopeLocalBindings(Object bindings);\n+    void setExtentLocalBindings(Object bindings);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.internal.vm.ScopeLocalContainer;\n+import jdk.internal.vm.ExtentLocalContainer;\n@@ -102,1 +102,1 @@\n-    private final ScopeLocalContainer.BindingsSnapshot scopeLocalBindings;\n+    private final ExtentLocalContainer.BindingsSnapshot extentLocalBindings;\n@@ -114,1 +114,1 @@\n-        this.scopeLocalBindings = ScopeLocalContainer.captureBindings();\n+        this.extentLocalBindings = ExtentLocalContainer.captureBindings();\n@@ -122,2 +122,2 @@\n-    private ScopeLocalContainer.BindingsSnapshot scopeLocalBindings() {\n-        return scopeLocalBindings;\n+    private ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n+        return extentLocalBindings;\n@@ -213,1 +213,1 @@\n-     * <p> This method captures the current thread's {@linkplain ScopeLocal scope-local}\n+     * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n@@ -253,1 +253,1 @@\n-     * <p> The thread is started with the scope-local bindings that were captured\n+     * <p> The thread is started with the extent-local bindings that were captured\n@@ -266,1 +266,1 @@\n-     * scope-local bindings are not the same as when the flock was created\n+     * extent-local bindings are not the same as when the flock was created\n@@ -404,2 +404,2 @@\n-     * jdk.incubator.concurrent.ScopeLocal.Carrier#run(Runnable) operations} with\n-     * scope-local bindings then it also throws {@code StructureViolationException}\n+     * jdk.incubator.concurrent.ExtentLocal.Carrier#run(Runnable) operations} with\n+     * extent-local bindings then it also throws {@code StructureViolationException}\n@@ -591,2 +591,2 @@\n-        public ScopeLocalContainer.BindingsSnapshot scopeLocalBindings() {\n-            return flock.scopeLocalBindings();\n+        public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n+            return flock.extentLocalBindings();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveScopeLocalCache\");\n+        String value = GetPropertyAction.privilegedGetProperty(\"jdk.preserveExtentLocalCache\");\n@@ -131,1 +131,1 @@\n-    private Object[] scopeLocalCache;\n+    private Object[] extentLocalCache;\n@@ -240,1 +240,1 @@\n-            JLA.setScopeLocalCache(scopeLocalCache);\n+            JLA.setExtentLocalCache(extentLocalCache);\n@@ -273,1 +273,1 @@\n-                        scopeLocalCache = JLA.scopeLocalCache();\n+                        extentLocalCache = JLA.extentLocalCache();\n@@ -275,1 +275,1 @@\n-                        scopeLocalCache = null;\n+                        extentLocalCache = null;\n@@ -277,1 +277,1 @@\n-                    JLA.setScopeLocalCache(null);\n+                    JLA.setExtentLocalCache(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.vm;\n+\n+import java.util.concurrent.Callable;\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.StructureViolationExceptions;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ReservedStackAccess;\n+\n+\/**\n+ * A StackableScope to represent extent-local bindings.\n+ *\n+ * This class defines static methods to run an operation with a ExtentLocalContainer\n+ * on the scope stack. It also defines a method to get the latest ExtentLocalContainer\n+ * and a method to return a snapshot of the scope local bindings.\n+ *\/\n+public class ExtentLocalContainer extends StackableScope {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+    static {\n+        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n+    }\n+\n+    private ExtentLocalContainer() {\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This may be on\n+     * the current thread's scope task or ma require walking up the tree to find it.\n+     *\/\n+    public static <T extends ExtentLocalContainer> T latest(Class<T> containerClass) {\n+        StackableScope scope = head();\n+        if (scope == null) {\n+            scope = JLA.threadContainer(Thread.currentThread());\n+            if (scope == null || scope.owner() == null)\n+                return null;\n+        }\n+        if (containerClass.isInstance(scope)) {\n+            @SuppressWarnings(\"unchecked\")\n+            T tmp = (T) scope;\n+            return tmp;\n+        } else {\n+            return scope.enclosingScope(containerClass);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the \"latest\" ExtentLocalContainer for the current Thread. This\n+     * may be on the current thread's scope task or may require walking up the\n+     * tree to find it.\n+     *\/\n+    public static ExtentLocalContainer latest() {\n+        return latest(ExtentLocalContainer.class);\n+    }\n+\n+    \/**\n+     * A snapshot of the scope local bindings. The snapshot includes the bindings\n+     * established for the current thread and scope local container.\n+     *\/\n+    public record BindingsSnapshot(Object extentLocalBindings,\n+                                   ExtentLocalContainer container) { }\n+\n+    \/**\n+     * Returns a scope local bindings for the current thread.\n+     *\/\n+    public static BindingsSnapshot captureBindings() {\n+        return new BindingsSnapshot(JLA.extentLocalBindings(), latest());\n+    }\n+\n+    \/**\n+     * For use by ExtentLocal to run an operation in a structured context.\n+     *\/\n+    public static void run(Runnable op) {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            runWithoutScope(op);\n+        } else {\n+            new ExtentLocalContainer().doRun(op);\n+        }\n+    }\n+\n+    \/**\n+     * Run an operation without a scope on the stack.\n+     *\/\n+    private static void runWithoutScope(Runnable op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();   \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * Run an operation with this scope on the stack.\n+     *\/\n+    private void doRun(Runnable op) {\n+        Throwable ex;\n+        boolean atTop;\n+        push();\n+        try {\n+            op.run();\n+            ex = null;\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+    }\n+\n+    \/**\n+     * For use by ExtentLocal to call a value returning operation in a structured context.\n+     *\/\n+    public static <V> V call(Callable<V> op) throws Exception {\n+        if (head() == null) {\n+            \/\/ no need to push scope when stack is empty\n+            return callWithoutScope(op);\n+        } else {\n+            return new ExtentLocalContainer().doCall(op);\n+        }\n+    }\n+\n+    \/**\n+     * Call an operation without a scope on the stack.\n+     *\/\n+    private static <V> V callWithoutScope(Callable<V> op) {\n+        assert head() == null;\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = (head() == null);\n+            if (!atTop) popAll();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Call an operation with this scope on the stack.\n+     *\/\n+    private <V> V doCall(Callable<V> op) {\n+        Throwable ex;\n+        boolean atTop;\n+        V result;\n+        push();\n+        try {\n+            result = op.call();\n+            ex = null;\n+        } catch (Throwable e) {\n+            result = null;\n+            ex = e;\n+        } finally {\n+            atTop = popForcefully();  \/\/ may block\n+        }\n+        throwIfFailed(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n+     * as a suppressed exception when {@code atTop} is false.\n+     *\/\n+    @DontInline @ReservedStackAccess\n+    private static void throwIfFailed(Throwable ex, boolean atTop) {\n+        if (ex != null || !atTop) {\n+            if (!atTop) {\n+                var sve = StructureViolationExceptions.newException();\n+                if (ex == null) {\n+                    ex = sve;\n+                } else {\n+                    ex.addSuppressed(sve);\n+                }\n+            }\n+            Unsafe.getUnsafe().throwException(ex);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ExtentLocalContainer.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -1,216 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.vm;\n-\n-import java.util.concurrent.Callable;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.misc.StructureViolationExceptions;\n-import jdk.internal.misc.Unsafe;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ReservedStackAccess;\n-\n-\/**\n- * A StackableScope to represent scope-local bindings.\n- *\n- * This class defines static methods to run an operation with a ScopeLocalContainer\n- * on the scope stack. It also defines a method to get the latest ScopeLocalContainer\n- * and a method to return a snapshot of the scope local bindings.\n- *\/\n-public class ScopeLocalContainer extends StackableScope {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-    static {\n-        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n-    }\n-\n-    private ScopeLocalContainer() {\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ScopeLocalContainer for the current Thread. This may be on\n-     * the current thread's scope task or ma require walking up the tree to find it.\n-     *\/\n-    public static <T extends ScopeLocalContainer> T latest(Class<T> containerClass) {\n-        StackableScope scope = head();\n-        if (scope == null) {\n-            scope = JLA.threadContainer(Thread.currentThread());\n-            if (scope == null || scope.owner() == null)\n-                return null;\n-        }\n-        if (containerClass.isInstance(scope)) {\n-            @SuppressWarnings(\"unchecked\")\n-            T tmp = (T) scope;\n-            return tmp;\n-        } else {\n-            return scope.enclosingScope(containerClass);\n-        }\n-    }\n-\n-    \/**\n-     * Returns the \"latest\" ScopeLocalContainer for the current Thread. This\n-     * may be on the current thread's scope task or may require walking up the\n-     * tree to find it.\n-     *\/\n-    public static ScopeLocalContainer latest() {\n-        return latest(ScopeLocalContainer.class);\n-    }\n-\n-    \/**\n-     * A snapshot of the scope local bindings. The snapshot includes the bindings\n-     * established for the current thread and scope local container.\n-     *\/\n-    public record BindingsSnapshot(Object scopeLocalBindings,\n-                                   ScopeLocalContainer container) { }\n-\n-    \/**\n-     * Returns a scope local bindings for the current thread.\n-     *\/\n-    public static BindingsSnapshot captureBindings() {\n-        return new BindingsSnapshot(JLA.scopeLocalBindings(), latest());\n-    }\n-\n-    \/**\n-     * For use by ScopeLocal to run an operation in a structured context.\n-     *\/\n-    public static void run(Runnable op) {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            runWithoutScope(op);\n-        } else {\n-            new ScopeLocalContainer().doRun(op);\n-        }\n-    }\n-\n-    \/**\n-     * Run an operation without a scope on the stack.\n-     *\/\n-    private static void runWithoutScope(Runnable op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();   \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * Run an operation with this scope on the stack.\n-     *\/\n-    private void doRun(Runnable op) {\n-        Throwable ex;\n-        boolean atTop;\n-        push();\n-        try {\n-            op.run();\n-            ex = null;\n-        } catch (Throwable e) {\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-    }\n-\n-    \/**\n-     * For use by ScopeLocal to call a value returning operation in a structured context.\n-     *\/\n-    public static <V> V call(Callable<V> op) throws Exception {\n-        if (head() == null) {\n-            \/\/ no need to push scope when stack is empty\n-            return callWithoutScope(op);\n-        } else {\n-            return new ScopeLocalContainer().doCall(op);\n-        }\n-    }\n-\n-    \/**\n-     * Call an operation without a scope on the stack.\n-     *\/\n-    private static <V> V callWithoutScope(Callable<V> op) {\n-        assert head() == null;\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = (head() == null);\n-            if (!atTop) popAll();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Call an operation with this scope on the stack.\n-     *\/\n-    private <V> V doCall(Callable<V> op) {\n-        Throwable ex;\n-        boolean atTop;\n-        V result;\n-        push();\n-        try {\n-            result = op.call();\n-            ex = null;\n-        } catch (Throwable e) {\n-            result = null;\n-            ex = e;\n-        } finally {\n-            atTop = popForcefully();  \/\/ may block\n-        }\n-        throwIfFailed(ex, atTop);\n-        return result;\n-    }\n-\n-    \/**\n-     * Throws {@code ex} if not null. StructureViolationException is thrown or added\n-     * as a suppressed exception when {@code atTop} is false.\n-     *\/\n-    @DontInline @ReservedStackAccess\n-    private static void throwIfFailed(Throwable ex, boolean atTop) {\n-        if (ex != null || !atTop) {\n-            if (!atTop) {\n-                var sve = StructureViolationExceptions.newException();\n-                if (ex == null) {\n-                    ex = sve;\n-                } else {\n-                    ex.addSuppressed(sve);\n-                }\n-            }\n-            Unsafe.getUnsafe().throwException(ex);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ScopeLocalContainer.java","additions":0,"deletions":216,"binary":false,"changes":216,"status":"deleted"},{"patch":"@@ -95,1 +95,1 @@\n-    public ScopeLocalContainer.BindingsSnapshot scopeLocalBindings() {\n+    public ExtentLocalContainer.BindingsSnapshot extentLocalBindings() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-    {\"scopeLocalCache\",  \"()[\" OBJ,    (void *)&JVM_ScopeLocalCache},\n-    {\"setScopeLocalCache\", \"([\" OBJ \")V\",(void *)&JVM_SetScopeLocalCache},\n+    {\"extentLocalCache\",  \"()[\" OBJ,    (void *)&JVM_ExtentLocalCache},\n+    {\"setExtentLocalCache\", \"([\" OBJ \")V\",(void *)&JVM_SetExtentLocalCache},\n","filename":"src\/java.base\/share\/native\/libjava\/Thread.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,675 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.incubator.concurrent;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.ExtentLocalContainer;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.ReservedStackAccess;\n+import jdk.internal.vm.annotation.Stable;\n+\n+\/**\n+ * Represents a scoped value.\n+ *\n+ * <p> A extent-local value (hereinafter called a scope local) differs from a normal variable in that it is dynamically\n+ * scoped and intended for cases where context needs to be passed from a caller\n+ * to a transitive callee without using an explicit parameter. A extent-local value\n+ * does not have a default\/initial value: it is bound, meaning it gets a value,\n+ * when executing an operation specified to {@link #where(ExtentLocal, Object)}.\n+ * Code executed by the operation\n+ * uses the {@link #get()} method to get the value of the scope local. The scope local reverts\n+ * to being unbound (or its previous value) when the operation completes.\n+ *\n+ * <p> Access to the value of a scope local is controlled by the accessibility\n+ * of the {@code ExtentLocal} object. A {@code ExtentLocal} object  will typically be declared\n+ * in a private static field so that it can only be accessed by code in that class\n+ * (or other classes within its nest).\n+ *\n+ * <p> Scope locals support nested bindings. If a scope local has a value\n+ * then the {@code runWithBinding} or {@code callWithBinding} can be invoked to run\n+ * another operation with a new value. Code executed by this methods \"sees\" the new\n+ * value of the scope local. The scope local reverts to its previous value when the\n+ * operation completes.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+ * or method in this class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * @apiNote\n+ * The following example uses a scope local to make credentials available to callees.\n+ *\n+ * <pre>{@code\n+ *   private static final ExtentLocal<Credentials> CREDENTIALS = ExtentLocal.newInstance();\n+ *\n+ *   Credentials creds = ...\n+ *   ExtentLocal.where(CREDENTIALS, creds).run(() -> {\n+ *       :\n+ *       Connection connection = connectDatabase();\n+ *       :\n+ *   });\n+ *\n+ *   Connection connectDatabase() {\n+ *       Credentials credentials = CREDENTIALS.get();\n+ *       :\n+ *   }\n+ * }<\/pre>\n+ *\n+ * @implNote Scope locals are designed to be used in fairly small numbers. {@link\n+ * #get} initially performs a linear search through enclosing scopes to find a\n+ * scope local's innermost binding. It then caches the result of the search in a\n+ * small thread-local cache. Subsequent invocations of {@link #get} for that\n+ * scope local will almost always be very fast. However, if a program has many\n+ * scope locals that it uses cyclically, the cache hit rate will be low and\n+ * performance will be poor. On the other hand, this design allows extent-local\n+ * inheritance by {@link StructuredTaskScope} threads to be\n+ * very fast: in essence, no more than copying a pointer, and leaving a\n+ * extent-local binding also requires little more than updating a pointer.\n+ *\n+ * Because the extent-local per-thread cache is small, you should try to minimize\n+ * the number of bound scope locals in use. For example, if you need to pass a\n+ * number of values as scope locals, it makes sense to create a record class to\n+ * hold those values, and then bind a single scope local to an instance of that\n+ * record.\n+ *\n+ * @param <T> the scope local's type\n+ * @since 19\n+ *\/\n+public final class ExtentLocal<T> {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private final @Stable int hash;\n+\n+    public final int hashCode() { return hash; }\n+\n+    \/**\n+     * An immutable map from {@code ExtentLocal} to values.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+     * or method in this class will cause a {@link NullPointerException} to be thrown.\n+     *\/\n+    static sealed class Snapshot permits EmptySnapshot {\n+        final Snapshot prev;\n+        final Carrier bindings;\n+        final int bitmask;\n+\n+        private static final Object NIL = new Object();\n+\n+        Snapshot(Carrier bindings, Snapshot prev) {\n+            this.prev = prev;\n+            this.bindings = bindings;\n+            this.bitmask = bindings.bitmask | prev.bitmask;\n+        }\n+\n+        protected Snapshot() {\n+            this.prev = null;\n+            this.bindings = null;\n+            this.bitmask = 0;\n+        }\n+\n+        Object find(ExtentLocal<?> key) {\n+            int bits = key.bitmask();\n+            for (Snapshot snapshot = this;\n+                 containsAll(snapshot.bitmask, bits);\n+                 snapshot = snapshot.prev) {\n+                for (Carrier carrier = snapshot.bindings;\n+                     carrier != null && containsAll(carrier.bitmask, bits);\n+                     carrier = carrier.prev) {\n+                    if (carrier.getKey() == key) {\n+                        Object value = carrier.get();\n+                        return value;\n+                    }\n+                }\n+            }\n+            return NIL;\n+        }\n+    }\n+\n+    static final class EmptySnapshot extends Snapshot {\n+\n+        private EmptySnapshot() {\n+            super();\n+        }\n+\n+        private static final Snapshot SINGLETON = new EmptySnapshot();\n+\n+        static final Snapshot getInstance() {\n+            return SINGLETON;\n+        }\n+    }\n+\n+    \/**\n+     * An immutable map from a set of ExtentLocals to their bound values.\n+     * When map() or call() is invoked, the ExtentLocals bound in this set\n+     * are bound, such that calling the get() method returns the associated\n+     * value.\n+     * @since 19\n+     *\/\n+    public static final class Carrier {\n+        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n+        \/\/ hits that slot in the cache.\n+        final int bitmask;\n+        final ExtentLocal<?> key;\n+        final Object value;\n+        final Carrier prev;\n+\n+        Carrier(ExtentLocal<?> key, Object value, Carrier prev) {\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n+            int bits = key.bitmask();\n+            if (prev != null) {\n+                bits |= prev.bitmask;\n+            }\n+            this.bitmask = bits;\n+        }\n+\n+        \/**\n+         * Add a binding to this map, returning a new Carrier instance.\n+         *\/\n+        private static final <T> Carrier where(ExtentLocal<T> key, T value,\n+                                               Carrier prev) {\n+            return new Carrier(key, value, prev);\n+        }\n+\n+        \/**\n+         * Return a new map, which consists of the contents of this map plus a\n+         * new binding of key and value.\n+         * @param key   The ExtentLocal to bind a value to\n+         * @param value The new value\n+         * @param <T>   The type of the ExtentLocal\n+         * @return A new map, consisting of {@code this}. plus a new binding. {@code this} is unchanged.\n+         *\/\n+        public final <T> Carrier where(ExtentLocal<T> key, T value) {\n+            return where(key, value, this);\n+        }\n+\n+        \/*\n+         * Return a new set consisting of a single binding.\n+         *\/\n+        static final <T> Carrier of(ExtentLocal<T> key, T value) {\n+            return where(key, value, null);\n+        }\n+\n+        final Object get() {\n+            return value;\n+        }\n+\n+        final ExtentLocal<?> getKey() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Search for the value of a binding in this set\n+         * @param key the ExtentLocal to find\n+         * @param <T> the type of the ExtentLocal\n+         * @return the value\n+         * @throws NoSuchElementException if key is not bound to any value\n+         *\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public final <T> T get(ExtentLocal<T> key) {\n+            var bits = key.bitmask();\n+            for (Carrier carrier = this;\n+                 carrier != null && containsAll(carrier.bitmask, bits);\n+                 carrier = carrier.prev) {\n+                if (carrier.getKey() == key) {\n+                    Object value = carrier.get();\n+                    return (T)value;\n+                }\n+            }\n+            throw new NoSuchElementException();\n+        }\n+\n+        \/**\n+         * Run a value-returning operation with some ExtentLocals bound to values.\n+         * Code executed by the operation can use the {@link #get()} method to\n+         * get the value of the scope local. The scope locals revert to their previous values or\n+         * become {@linkplain #isBound() unbound} when the operation completes.\n+         *\n+         * <p> Scope locals are intended to be used in a <em>structured manner<\/em>. If the\n+         * operation creates {@link StructuredTaskScope}\n+         * but does not close them, then exiting the operation causes the underlying construct\n+         * of each executor to be closed (in the reverse order that they were created in), and\n+         * {@link StructureViolationException} to be thrown.\n+         *\n+         * @param op    the operation to run\n+         * @param <R>   the type of the result of the function\n+         * @return the result\n+         * @throws Exception if the operation completes with an exception\n+         *\/\n+        public final <R> R call(Callable<R> op) throws Exception {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevBindings = addExtentLocalBindings(this);\n+            try {\n+                return ExtentLocalContainer.call(op);\n+            } catch (Throwable t) {\n+                setExtentLocalCache(null); \/\/ Cache.invalidate();\n+                throw t;\n+            } finally {\n+                setExtentLocalBindings(prevBindings);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+\n+        \/**\n+         * Run a value-returning operation with this set of ExtentLocals bound to values,\n+         * in the same way as {@code call()}.<p>\n+         *     If the operation throws an exception, pass it as a single argument to the {@link Function}\n+         *     {@code handler}. {@code handler} must return a value compatible with the type returned by {@code op}.\n+         * <\/p>\n+         * @param op    the operation to run\n+         * @param <R>   the type of the result of the function\n+         * @param handler the handler to be applied if {code op} threw an exception\n+         * @return the result.\n+          *\/\n+        public final <R> R callOrElse(Callable<R> op,\n+                                      Function<? super Exception, ? extends R> handler) {\n+            try {\n+                return call(op);\n+            } catch (Exception e) {\n+                return handler.apply(e);\n+            }\n+        }\n+\n+        \/**\n+         * Runs an operation with some ExtentLocals bound to our values.\n+         * Code executed by the operation can use the {@link #get()} method to\n+         * get the value of the scope local. The scope locals revert to their previous values or\n+         * becomes {@linkplain #isBound() unbound} when the operation completes.\n+         *\n+         * <p> Scope locals are intended to be used in a <em>structured manner<\/em>. If the\n+         * operation creates {@link StructuredTaskScope}s\n+         * but does not close them, then exiting the operation causes the underlying construct\n+         * of each executor to be closed (in the reverse order that they were created in), and\n+         * {@link StructureViolationException} to be thrown.\n+         *\n+         * @param op    the operation to run\n+         *\/\n+        public final void run(Runnable op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevBindings = addExtentLocalBindings(this);\n+            try {\n+                ExtentLocalContainer.run(op);\n+            } catch (Throwable t) {\n+                setExtentLocalCache(null); \/\/ Cache.invalidate();\n+                throw t;\n+            } finally {\n+                setExtentLocalBindings(prevBindings);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+\n+        \/*\n+         * Add a list of bindings to the current Thread's set of bound values.\n+         *\/\n+        private static final Snapshot addExtentLocalBindings(Carrier bindings) {\n+            Snapshot prev = extentLocalBindings();\n+            var b = new Snapshot(bindings, prev);\n+            ExtentLocal.setExtentLocalBindings(b);\n+            return prev;\n+        }\n+\n+        \/*\n+         * Ensure that none of these bindings is already bound.\n+         *\/\n+        void checkNotBound() {\n+            for (Carrier c = this; c != null; c = c.prev) {\n+                if (c.key.isBound()) {\n+                    throw new RuntimeException(\"Scope Local already bound\");\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Create a binding for a ExtentLocal instance.\n+     * That {@link Carrier} may be used later to invoke a {@link Callable} or\n+     * {@link Runnable} instance. More bindings may be added to the {@link Carrier}\n+     * by the {@link Carrier#where(ExtentLocal, Object)} method.\n+     *\n+     * @param key the ExtentLocal to bind\n+     * @param value The value to bind it to\n+     * @param <T> the type of the ExtentLocal\n+     * @return A Carrier instance that contains one binding, that of key and value\n+     *\/\n+    public static <T> Carrier where(ExtentLocal<T> key, T value) {\n+        return Carrier.of(key, value);\n+    }\n+\n+    \/**\n+     * Creates a binding for a ExtentLocal instance and runs a value-returning\n+     * operation with that bound ExtentLocal.\n+     * @param key the ExtentLocal to bind\n+     * @param value The value to bind it to\n+     * @param <T> the type of the ExtentLocal\n+     * @param <U> the type of the Result\n+     * @param op the operation to call\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public static <T, U> U where(ExtentLocal<T> key, T value, Callable<U> op) throws Exception {\n+        return where(key, value).call(op);\n+    }\n+\n+    \/**\n+     * Creates a binding for a ExtentLocal instance and runs an\n+     * operation with that bound ExtentLocal.\n+     * @param key the ExtentLocal to bind\n+     * @param value The value to bind it to\n+     * @param <T> the type of the ExtentLocal\n+     * @param op the operation to run\n+     *\/\n+    public static <T> void where(ExtentLocal<T> key, T value, Runnable op) {\n+        where(key, value).run(op);\n+    }\n+\n+    private ExtentLocal() {\n+        this.hash = generateKey();\n+    }\n+\n+    \/**\n+     * Creates a extent-local handle to refer to a value of type T.\n+     *\n+     * @param <T> the type of the scope local's value.\n+     * @return a extent-local handle\n+     *\/\n+    public static <T> ExtentLocal<T> newInstance() {\n+        return new ExtentLocal<T>();\n+    }\n+\n+    \/**\n+     * Returns the value of the scope local.\n+     * @return the value of the scope local\n+     * @throws NoSuchElementException if the scope local is not bound (exception is TBD)\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = extentLocalCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.TABLE_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.TABLE_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private T slowGet() {\n+        var value = findBinding();\n+        if (value == Snapshot.NIL) {\n+            throw new NoSuchElementException();\n+        }\n+        Cache.put(this, value);\n+        return (T)value;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the scope local is bound to a value.\n+     *\n+     * @return {@code true} if the scope local is bound to a value, otherwise {@code false}\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean isBound() {\n+        \/\/ ??? Do we want to search cache for this? In most cases we don't expect\n+        \/\/ this {@link ExtentLocal} to be bound, so it's not worth it. But I may\n+        \/\/ be wrong about that.\n+\/*\n+        if (Cache.find(this) != Snapshot.NIL) {\n+            return true;\n+        }\n+ *\/\n+        return findBinding() != Snapshot.NIL;\n+    }\n+\n+    \/**\n+     * Return the value of the scope local or NIL if not bound.\n+     *\/\n+    private Object findBinding() {\n+        Object value = extentLocalBindings().find(this);\n+        return value;\n+    }\n+\n+    \/**\n+     * Return the value of the scope local if bound, otherwise returns {@code other}.\n+     * @param other the value to return if not bound, can be {@code null}\n+     * @return the value of the scope local if bound, otherwise {@code other}\n+     *\/\n+    public T orElse(T other) {\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            return other;\n+        }\n+    }\n+\n+    \/**\n+     * Return the value of the scope local if bound, otherwise throw an exception\n+     * produced by the exception supplying function.\n+     * @param <X> Type of the exception to be thrown\n+     * @param exceptionSupplier the supplying function that produces an\n+     *        exception to be thrown\n+     * @return the value of the scope local if bound\n+     * @throws X if the scope local is unbound\n+     *\/\n+    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n+        Objects.requireNonNull(exceptionSupplier);\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    private static Object[] extentLocalCache() {\n+        return JLA.extentLocalCache();\n+    }\n+\n+    private static void setExtentLocalCache(Object[] cache) {\n+        JLA.setExtentLocalCache(cache);\n+    }\n+\n+    private static Snapshot extentLocalBindings() {\n+        Object bindings = JLA.extentLocalBindings();\n+        if (bindings != null) {\n+            return (Snapshot) bindings;\n+        } else {\n+            return EmptySnapshot.getInstance();\n+        }\n+    }\n+\n+    private static void setExtentLocalBindings(Snapshot bindings) {\n+        JLA.setExtentLocalBindings(bindings);\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes are\n+    \/\/ different.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while ((x & Cache.TABLE_MASK)\n+                == ((x >>> Cache.INDEX_BITS) & Cache.TABLE_MASK));\n+        return (nextKey = x);\n+    }\n+\n+    \/**\n+     * Return a bit mask that may be used to determine if this ExtentLocal is\n+     * bound in the current context. Each Carrier holds a bit mask which is\n+     * the OR of all the bit masks of the bound ExtentLocals.\n+     * @return the bitmask\n+     *\/\n+    int bitmask() {\n+        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+    }\n+\n+    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n+    \/\/ of the bits in targetBits.\n+    static boolean containsAll(int bitmask, int targetBits) {\n+        return (bitmask & targetBits) == targetBits;\n+    }\n+\n+    \/\/ A small fixed-size key-value cache. When a scope scope local's get() method\n+    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n+    \/\/ for fast access in future.\n+    private static class Cache {\n+        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n+        static final int TABLE_SIZE = 1 << INDEX_BITS;\n+        static final int TABLE_MASK = TABLE_SIZE - 1;\n+        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n+\n+        static final int primaryIndex(ExtentLocal<?> key) {\n+            return key.hash & TABLE_MASK;\n+        }\n+\n+        static final int secondaryIndex(ExtentLocal<?> key) {\n+            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        }\n+\n+        static void put(ExtentLocal<?> key, Object value) {\n+            Object[] theCache = extentLocalCache();\n+            if (theCache == null) {\n+                theCache = new Object[TABLE_SIZE * 2];\n+                setExtentLocalCache(theCache);\n+            }\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            int k1 = primaryIndex(key);\n+            int k2 = secondaryIndex(key);\n+            var usePrimaryIndex = chooseVictim();\n+            int victim = usePrimaryIndex ? k1 : k2;\n+            int other = usePrimaryIndex ? k2 : k1;\n+            setKeyAndObjectAt(victim, key, value);\n+            if (getKey(theCache, other) == key) {\n+                setKey(theCache, other, null);\n+            }\n+        }\n+\n+        private static final void update(Object key, Object value) {\n+            Object[] objects;\n+            if ((objects = extentLocalCache()) != null) {\n+                int k1 = key.hashCode() & TABLE_MASK;\n+                if (getKey(objects, k1) == key) {\n+                    setKeyAndObjectAt(k1, key, value);\n+                }\n+                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n+                if (getKey(objects, k2) == key) {\n+                    setKeyAndObjectAt(k2, key, value);\n+                }\n+            }\n+        }\n+\n+        private static final void remove(Object key) {\n+            Object[] objects;\n+            if ((objects = extentLocalCache()) != null) {\n+                int k1 = key.hashCode() & TABLE_MASK;\n+                if (getKey(objects, k1) == key) {\n+                    setKeyAndObjectAt(k1, null, null);\n+                }\n+                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n+                if (getKey(objects, k2) == key) {\n+                    setKeyAndObjectAt(k2, null, null);\n+                }\n+            }\n+        }\n+\n+        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n+            extentLocalCache()[n * 2] = key;\n+            extentLocalCache()[n * 2 + 1] = value;\n+        }\n+\n+        private static Object getKey(Object[] objs, int n) {\n+            return objs[n * 2];\n+        }\n+\n+        private static void setKey(Object[] objs, int n, Object key) {\n+            objs[n * 2] = key;\n+        }\n+\n+        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n+        \/\/ This chooses either the primary or secondary cache slot, but the\n+        \/\/ primary slot is approximately twice as likely to be chosen as the\n+        \/\/ secondary one.\n+        private static boolean chooseVictim() {\n+            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            return (r & 15) >= 5;\n+        }\n+\n+        @ReservedStackAccess @DontInline\n+        public static void invalidate() {\n+            setExtentLocalCache(null);\n+        }\n+\n+        \/\/ Null a set of cache entries, indicated by the 1-bits given\n+        @ReservedStackAccess @DontInline\n+        static void invalidate(int toClearBits) {\n+            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            Object[] objects;\n+            if ((objects = extentLocalCache()) != null) {\n+                for (int bits = toClearBits; bits != 0; ) {\n+                    int index = Integer.numberOfTrailingZeros(bits);\n+                    setKeyAndObjectAt(index, null, null);\n+                    bits &= ~1 << index;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ExtentLocal.java","additions":675,"deletions":0,"binary":false,"changes":675,"status":"added"},{"patch":"@@ -1,675 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2021, Red Hat Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.concurrent;\n-\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.util.concurrent.Callable;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.vm.ScopeLocalContainer;\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.ReservedStackAccess;\n-import jdk.internal.vm.annotation.Stable;\n-\n-\/**\n- * Represents a scoped value.\n- *\n- * <p> A scope-local value (hereinafter called a scope local) differs from a normal variable in that it is dynamically\n- * scoped and intended for cases where context needs to be passed from a caller\n- * to a transitive callee without using an explicit parameter. A scope-local value\n- * does not have a default\/initial value: it is bound, meaning it gets a value,\n- * when executing an operation specified to {@link #where(ScopeLocal, Object)}.\n- * Code executed by the operation\n- * uses the {@link #get()} method to get the value of the scope local. The scope local reverts\n- * to being unbound (or its previous value) when the operation completes.\n- *\n- * <p> Access to the value of a scope local is controlled by the accessibility\n- * of the {@code ScopeLocal} object. A {@code ScopeLocal} object  will typically be declared\n- * in a private static field so that it can only be accessed by code in that class\n- * (or other classes within its nest).\n- *\n- * <p> Scope locals support nested bindings. If a scope local has a value\n- * then the {@code runWithBinding} or {@code callWithBinding} can be invoked to run\n- * another operation with a new value. Code executed by this methods \"sees\" the new\n- * value of the scope local. The scope local reverts to its previous value when the\n- * operation completes.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n- * or method in this class will cause a {@link NullPointerException} to be thrown.\n- *\n- * @apiNote\n- * The following example uses a scope local to make credentials available to callees.\n- *\n- * <pre>{@code\n- *   private static final ScopeLocal<Credentials> CREDENTIALS = ScopeLocal.newInstance();\n- *\n- *   Credentials creds = ...\n- *   ScopeLocal.where(CREDENTIALS, creds).run(() -> {\n- *       :\n- *       Connection connection = connectDatabase();\n- *       :\n- *   });\n- *\n- *   Connection connectDatabase() {\n- *       Credentials credentials = CREDENTIALS.get();\n- *       :\n- *   }\n- * }<\/pre>\n- *\n- * @implNote Scope locals are designed to be used in fairly small numbers. {@link\n- * #get} initially performs a linear search through enclosing scopes to find a\n- * scope local's innermost binding. It then caches the result of the search in a\n- * small thread-local cache. Subsequent invocations of {@link #get} for that\n- * scope local will almost always be very fast. However, if a program has many\n- * scope locals that it uses cyclically, the cache hit rate will be low and\n- * performance will be poor. On the other hand, this design allows scope-local\n- * inheritance by {@link StructuredTaskScope} threads to be\n- * very fast: in essence, no more than copying a pointer, and leaving a\n- * scope-local binding also requires little more than updating a pointer.\n- *\n- * Because the scope-local per-thread cache is small, you should try to minimize\n- * the number of bound scope locals in use. For example, if you need to pass a\n- * number of values as scope locals, it makes sense to create a record class to\n- * hold those values, and then bind a single scope local to an instance of that\n- * record.\n- *\n- * @param <T> the scope local's type\n- * @since 19\n- *\/\n-public final class ScopeLocal<T> {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    private final @Stable int hash;\n-\n-    public final int hashCode() { return hash; }\n-\n-    \/**\n-     * An immutable map from {@code ScopeLocal} to values.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n-     * or method in this class will cause a {@link NullPointerException} to be thrown.\n-     *\/\n-    static sealed class Snapshot permits EmptySnapshot {\n-        final Snapshot prev;\n-        final Carrier bindings;\n-        final int bitmask;\n-\n-        private static final Object NIL = new Object();\n-\n-        Snapshot(Carrier bindings, Snapshot prev) {\n-            this.prev = prev;\n-            this.bindings = bindings;\n-            this.bitmask = bindings.bitmask | prev.bitmask;\n-        }\n-\n-        protected Snapshot() {\n-            this.prev = null;\n-            this.bindings = null;\n-            this.bitmask = 0;\n-        }\n-\n-        Object find(ScopeLocal<?> key) {\n-            int bits = key.bitmask();\n-            for (Snapshot snapshot = this;\n-                 containsAll(snapshot.bitmask, bits);\n-                 snapshot = snapshot.prev) {\n-                for (Carrier carrier = snapshot.bindings;\n-                     carrier != null && containsAll(carrier.bitmask, bits);\n-                     carrier = carrier.prev) {\n-                    if (carrier.getKey() == key) {\n-                        Object value = carrier.get();\n-                        return value;\n-                    }\n-                }\n-            }\n-            return NIL;\n-        }\n-    }\n-\n-    static final class EmptySnapshot extends Snapshot {\n-\n-        private EmptySnapshot() {\n-            super();\n-        }\n-\n-        private static final Snapshot SINGLETON = new EmptySnapshot();\n-\n-        static final Snapshot getInstance() {\n-            return SINGLETON;\n-        }\n-    }\n-\n-    \/**\n-     * An immutable map from a set of ScopeLocals to their bound values.\n-     * When map() or call() is invoked, the ScopeLocals bound in this set\n-     * are bound, such that calling the get() method returns the associated\n-     * value.\n-     * @since 19\n-     *\/\n-    public static final class Carrier {\n-        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n-        \/\/ hits that slot in the cache.\n-        final int bitmask;\n-        final ScopeLocal<?> key;\n-        final Object value;\n-        final Carrier prev;\n-\n-        Carrier(ScopeLocal<?> key, Object value, Carrier prev) {\n-            this.key = key;\n-            this.value = value;\n-            this.prev = prev;\n-            int bits = key.bitmask();\n-            if (prev != null) {\n-                bits |= prev.bitmask;\n-            }\n-            this.bitmask = bits;\n-        }\n-\n-        \/**\n-         * Add a binding to this map, returning a new Carrier instance.\n-         *\/\n-        private static final <T> Carrier where(ScopeLocal<T> key, T value,\n-                                               Carrier prev) {\n-            return new Carrier(key, value, prev);\n-        }\n-\n-        \/**\n-         * Return a new map, which consists of the contents of this map plus a\n-         * new binding of key and value.\n-         * @param key   The ScopeLocal to bind a value to\n-         * @param value The new value\n-         * @param <T>   The type of the ScopeLocal\n-         * @return A new map, consisting of {@code this}. plus a new binding. {@code this} is unchanged.\n-         *\/\n-        public final <T> Carrier where(ScopeLocal<T> key, T value) {\n-            return where(key, value, this);\n-        }\n-\n-        \/*\n-         * Return a new set consisting of a single binding.\n-         *\/\n-        static final <T> Carrier of(ScopeLocal<T> key, T value) {\n-            return where(key, value, null);\n-        }\n-\n-        final Object get() {\n-            return value;\n-        }\n-\n-        final ScopeLocal<?> getKey() {\n-            return key;\n-        }\n-\n-        \/**\n-         * Search for the value of a binding in this set\n-         * @param key the ScopeLocal to find\n-         * @param <T> the type of the ScopeLocal\n-         * @return the value\n-         * @throws NoSuchElementException if key is not bound to any value\n-         *\n-         *\/\n-        @SuppressWarnings(\"unchecked\")\n-        public final <T> T get(ScopeLocal<T> key) {\n-            var bits = key.bitmask();\n-            for (Carrier carrier = this;\n-                 carrier != null && containsAll(carrier.bitmask, bits);\n-                 carrier = carrier.prev) {\n-                if (carrier.getKey() == key) {\n-                    Object value = carrier.get();\n-                    return (T)value;\n-                }\n-            }\n-            throw new NoSuchElementException();\n-        }\n-\n-        \/**\n-         * Run a value-returning operation with some ScopeLocals bound to values.\n-         * Code executed by the operation can use the {@link #get()} method to\n-         * get the value of the scope local. The scope locals revert to their previous values or\n-         * become {@linkplain #isBound() unbound} when the operation completes.\n-         *\n-         * <p> Scope locals are intended to be used in a <em>structured manner<\/em>. If the\n-         * operation creates {@link StructuredTaskScope}\n-         * but does not close them, then exiting the operation causes the underlying construct\n-         * of each executor to be closed (in the reverse order that they were created in), and\n-         * {@link StructureViolationException} to be thrown.\n-         *\n-         * @param op    the operation to run\n-         * @param <R>   the type of the result of the function\n-         * @return the result\n-         * @throws Exception if the operation completes with an exception\n-         *\/\n-        public final <R> R call(Callable<R> op) throws Exception {\n-            Objects.requireNonNull(op);\n-            Cache.invalidate(bitmask);\n-            var prevBindings = addScopeLocalBindings(this);\n-            try {\n-                return ScopeLocalContainer.call(op);\n-            } catch (Throwable t) {\n-                setScopeLocalCache(null); \/\/ Cache.invalidate();\n-                throw t;\n-            } finally {\n-                setScopeLocalBindings(prevBindings);\n-                Cache.invalidate(bitmask);\n-            }\n-        }\n-\n-        \/**\n-         * Run a value-returning operation with this set of ScopeLocals bound to values,\n-         * in the same way as {@code call()}.<p>\n-         *     If the operation throws an exception, pass it as a single argument to the {@link Function}\n-         *     {@code handler}. {@code handler} must return a value compatible with the type returned by {@code op}.\n-         * <\/p>\n-         * @param op    the operation to run\n-         * @param <R>   the type of the result of the function\n-         * @param handler the handler to be applied if {code op} threw an exception\n-         * @return the result.\n-          *\/\n-        public final <R> R callOrElse(Callable<R> op,\n-                                      Function<? super Exception, ? extends R> handler) {\n-            try {\n-                return call(op);\n-            } catch (Exception e) {\n-                return handler.apply(e);\n-            }\n-        }\n-\n-        \/**\n-         * Runs an operation with some ScopeLocals bound to our values.\n-         * Code executed by the operation can use the {@link #get()} method to\n-         * get the value of the scope local. The scope locals revert to their previous values or\n-         * becomes {@linkplain #isBound() unbound} when the operation completes.\n-         *\n-         * <p> Scope locals are intended to be used in a <em>structured manner<\/em>. If the\n-         * operation creates {@link StructuredTaskScope}s\n-         * but does not close them, then exiting the operation causes the underlying construct\n-         * of each executor to be closed (in the reverse order that they were created in), and\n-         * {@link StructureViolationException} to be thrown.\n-         *\n-         * @param op    the operation to run\n-         *\/\n-        public final void run(Runnable op) {\n-            Objects.requireNonNull(op);\n-            Cache.invalidate(bitmask);\n-            var prevBindings = addScopeLocalBindings(this);\n-            try {\n-                ScopeLocalContainer.run(op);\n-            } catch (Throwable t) {\n-                setScopeLocalCache(null); \/\/ Cache.invalidate();\n-                throw t;\n-            } finally {\n-                setScopeLocalBindings(prevBindings);\n-                Cache.invalidate(bitmask);\n-            }\n-        }\n-\n-        \/*\n-         * Add a list of bindings to the current Thread's set of bound values.\n-         *\/\n-        private static final Snapshot addScopeLocalBindings(Carrier bindings) {\n-            Snapshot prev = scopeLocalBindings();\n-            var b = new Snapshot(bindings, prev);\n-            ScopeLocal.setScopeLocalBindings(b);\n-            return prev;\n-        }\n-\n-        \/*\n-         * Ensure that none of these bindings is already bound.\n-         *\/\n-        void checkNotBound() {\n-            for (Carrier c = this; c != null; c = c.prev) {\n-                if (c.key.isBound()) {\n-                    throw new RuntimeException(\"Scope Local already bound\");\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Create a binding for a ScopeLocal instance.\n-     * That {@link Carrier} may be used later to invoke a {@link Callable} or\n-     * {@link Runnable} instance. More bindings may be added to the {@link Carrier}\n-     * by the {@link Carrier#where(ScopeLocal, Object)} method.\n-     *\n-     * @param key the ScopeLocal to bind\n-     * @param value The value to bind it to\n-     * @param <T> the type of the ScopeLocal\n-     * @return A Carrier instance that contains one binding, that of key and value\n-     *\/\n-    public static <T> Carrier where(ScopeLocal<T> key, T value) {\n-        return Carrier.of(key, value);\n-    }\n-\n-    \/**\n-     * Creates a binding for a ScopeLocal instance and runs a value-returning\n-     * operation with that bound ScopeLocal.\n-     * @param key the ScopeLocal to bind\n-     * @param value The value to bind it to\n-     * @param <T> the type of the ScopeLocal\n-     * @param <U> the type of the Result\n-     * @param op the operation to call\n-     * @return the result\n-     * @throws Exception if the operation completes with an exception\n-     *\/\n-    public static <T, U> U where(ScopeLocal<T> key, T value, Callable<U> op) throws Exception {\n-        return where(key, value).call(op);\n-    }\n-\n-    \/**\n-     * Creates a binding for a ScopeLocal instance and runs an\n-     * operation with that bound ScopeLocal.\n-     * @param key the ScopeLocal to bind\n-     * @param value The value to bind it to\n-     * @param <T> the type of the ScopeLocal\n-     * @param op the operation to run\n-     *\/\n-    public static <T> void where(ScopeLocal<T> key, T value, Runnable op) {\n-        where(key, value).run(op);\n-    }\n-\n-    private ScopeLocal() {\n-        this.hash = generateKey();\n-    }\n-\n-    \/**\n-     * Creates a scope-local handle to refer to a value of type T.\n-     *\n-     * @param <T> the type of the scope local's value.\n-     * @return a scope-local handle\n-     *\/\n-    public static <T> ScopeLocal<T> newInstance() {\n-        return new ScopeLocal<T>();\n-    }\n-\n-    \/**\n-     * Returns the value of the scope local.\n-     * @return the value of the scope local\n-     * @throws NoSuchElementException if the scope local is not bound (exception is TBD)\n-     *\/\n-    @ForceInline\n-    @SuppressWarnings(\"unchecked\")\n-    public T get() {\n-        Object[] objects;\n-        if ((objects = scopeLocalCache()) != null) {\n-            \/\/ This code should perhaps be in class Cache. We do it\n-            \/\/ here because the generated code is small and fast and\n-            \/\/ we really want it to be inlined in the caller.\n-            int n = (hash & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.TABLE_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-        }\n-        return slowGet();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private T slowGet() {\n-        var value = findBinding();\n-        if (value == Snapshot.NIL) {\n-            throw new NoSuchElementException();\n-        }\n-        Cache.put(this, value);\n-        return (T)value;\n-    }\n-\n-    \/**\n-     * Returns {@code true} if the scope local is bound to a value.\n-     *\n-     * @return {@code true} if the scope local is bound to a value, otherwise {@code false}\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public boolean isBound() {\n-        \/\/ ??? Do we want to search cache for this? In most cases we don't expect\n-        \/\/ this {@link ScopeLocal} to be bound, so it's not worth it. But I may\n-        \/\/ be wrong about that.\n-\/*\n-        if (Cache.find(this) != Snapshot.NIL) {\n-            return true;\n-        }\n- *\/\n-        return findBinding() != Snapshot.NIL;\n-    }\n-\n-    \/**\n-     * Return the value of the scope local or NIL if not bound.\n-     *\/\n-    private Object findBinding() {\n-        Object value = scopeLocalBindings().find(this);\n-        return value;\n-    }\n-\n-    \/**\n-     * Return the value of the scope local if bound, otherwise returns {@code other}.\n-     * @param other the value to return if not bound, can be {@code null}\n-     * @return the value of the scope local if bound, otherwise {@code other}\n-     *\/\n-    public T orElse(T other) {\n-        Object obj = findBinding();\n-        if (obj != Snapshot.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            return other;\n-        }\n-    }\n-\n-    \/**\n-     * Return the value of the scope local if bound, otherwise throw an exception\n-     * produced by the exception supplying function.\n-     * @param <X> Type of the exception to be thrown\n-     * @param exceptionSupplier the supplying function that produces an\n-     *        exception to be thrown\n-     * @return the value of the scope local if bound\n-     * @throws X if the scope local is unbound\n-     *\/\n-    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n-        Objects.requireNonNull(exceptionSupplier);\n-        Object obj = findBinding();\n-        if (obj != Snapshot.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            throw exceptionSupplier.get();\n-        }\n-    }\n-\n-    private static Object[] scopeLocalCache() {\n-        return JLA.scopeLocalCache();\n-    }\n-\n-    private static void setScopeLocalCache(Object[] cache) {\n-        JLA.setScopeLocalCache(cache);\n-    }\n-\n-    private static Snapshot scopeLocalBindings() {\n-        Object bindings = JLA.scopeLocalBindings();\n-        if (bindings != null) {\n-            return (Snapshot) bindings;\n-        } else {\n-            return EmptySnapshot.getInstance();\n-        }\n-    }\n-\n-    private static void setScopeLocalBindings(Snapshot bindings) {\n-        JLA.setScopeLocalBindings(bindings);\n-    }\n-\n-    private static int nextKey = 0xf0f0_f0f0;\n-\n-    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n-    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n-    \/\/ and the next n bits as cache indexes, so we make sure that those indexes are\n-    \/\/ different.\n-    private static synchronized int generateKey() {\n-        int x = nextKey;\n-        do {\n-            x ^= x >>> 12;\n-            x ^= x << 9;\n-            x ^= x >>> 23;\n-        } while ((x & Cache.TABLE_MASK)\n-                == ((x >>> Cache.INDEX_BITS) & Cache.TABLE_MASK));\n-        return (nextKey = x);\n-    }\n-\n-    \/**\n-     * Return a bit mask that may be used to determine if this ScopeLocal is\n-     * bound in the current context. Each Carrier holds a bit mask which is\n-     * the OR of all the bit masks of the bound ScopeLocals.\n-     * @return the bitmask\n-     *\/\n-    int bitmask() {\n-        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n-    }\n-\n-    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n-    \/\/ of the bits in targetBits.\n-    static boolean containsAll(int bitmask, int targetBits) {\n-        return (bitmask & targetBits) == targetBits;\n-    }\n-\n-    \/\/ A small fixed-size key-value cache. When a scope scope local's get() method\n-    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n-    \/\/ for fast access in future.\n-    private static class Cache {\n-        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n-        static final int TABLE_SIZE = 1 << INDEX_BITS;\n-        static final int TABLE_MASK = TABLE_SIZE - 1;\n-        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n-\n-        static final int primaryIndex(ScopeLocal<?> key) {\n-            return key.hash & TABLE_MASK;\n-        }\n-\n-        static final int secondaryIndex(ScopeLocal<?> key) {\n-            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n-        }\n-\n-        static void put(ScopeLocal<?> key, Object value) {\n-            Object[] theCache = scopeLocalCache();\n-            if (theCache == null) {\n-                theCache = new Object[TABLE_SIZE * 2];\n-                setScopeLocalCache(theCache);\n-            }\n-            \/\/ Update the cache to replace one entry with the value we just looked up.\n-            \/\/ Each value can be in one of two possible places in the cache.\n-            \/\/ Pick a victim at (pseudo-)random.\n-            int k1 = primaryIndex(key);\n-            int k2 = secondaryIndex(key);\n-            var usePrimaryIndex = chooseVictim();\n-            int victim = usePrimaryIndex ? k1 : k2;\n-            int other = usePrimaryIndex ? k2 : k1;\n-            setKeyAndObjectAt(victim, key, value);\n-            if (getKey(theCache, other) == key) {\n-                setKey(theCache, other, null);\n-            }\n-        }\n-\n-        private static final void update(Object key, Object value) {\n-            Object[] objects;\n-            if ((objects = scopeLocalCache()) != null) {\n-                int k1 = key.hashCode() & TABLE_MASK;\n-                if (getKey(objects, k1) == key) {\n-                    setKeyAndObjectAt(k1, key, value);\n-                }\n-                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n-                if (getKey(objects, k2) == key) {\n-                    setKeyAndObjectAt(k2, key, value);\n-                }\n-            }\n-        }\n-\n-        private static final void remove(Object key) {\n-            Object[] objects;\n-            if ((objects = scopeLocalCache()) != null) {\n-                int k1 = key.hashCode() & TABLE_MASK;\n-                if (getKey(objects, k1) == key) {\n-                    setKeyAndObjectAt(k1, null, null);\n-                }\n-                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n-                if (getKey(objects, k2) == key) {\n-                    setKeyAndObjectAt(k2, null, null);\n-                }\n-            }\n-        }\n-\n-        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n-            scopeLocalCache()[n * 2] = key;\n-            scopeLocalCache()[n * 2 + 1] = value;\n-        }\n-\n-        private static Object getKey(Object[] objs, int n) {\n-            return objs[n * 2];\n-        }\n-\n-        private static void setKey(Object[] objs, int n, Object key) {\n-            objs[n * 2] = key;\n-        }\n-\n-        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n-                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n-\n-        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n-        \/\/ This chooses either the primary or secondary cache slot, but the\n-        \/\/ primary slot is approximately twice as likely to be chosen as the\n-        \/\/ secondary one.\n-        private static boolean chooseVictim() {\n-            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n-            return (r & 15) >= 5;\n-        }\n-\n-        @ReservedStackAccess @DontInline\n-        public static void invalidate() {\n-            setScopeLocalCache(null);\n-        }\n-\n-        \/\/ Null a set of cache entries, indicated by the 1-bits given\n-        @ReservedStackAccess @DontInline\n-        static void invalidate(int toClearBits) {\n-            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n-            Object[] objects;\n-            if ((objects = scopeLocalCache()) != null) {\n-                for (int bits = toClearBits; bits != 0; ) {\n-                    int index = Integer.numberOfTrailingZeros(bits);\n-                    setKeyAndObjectAt(index, null, null);\n-                    bits &= ~1 << index;\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ScopeLocal.java","additions":0,"deletions":675,"binary":false,"changes":675,"status":"deleted"},{"patch":"@@ -220,1 +220,1 @@\n- *   <li> Inheritance of {@linkplain ScopeLocal scope-local} bindings by threads.\n+ *   <li> Inheritance of {@linkplain ExtentLocal extent-local} bindings by threads.\n@@ -225,1 +225,1 @@\n- * <p> The following example demonstrates the inheritance of a scope-local binding. A scope\n+ * <p> The following example demonstrates the inheritance of a extent-local binding. A scope\n@@ -228,2 +228,2 @@\n- * inherits the scope-local binding. The code in {@code childTask} uses the value of the\n- * scope-local and so reads the value \"duke\".\n+ * inherits the extent-local binding. The code in {@code childTask} uses the value of the\n+ * extent-local and so reads the value \"duke\".\n@@ -231,1 +231,1 @@\n- *     private static final ScopeLocal<String> NAME = ScopeLocal.newInstance();\n+ *     private static final ExtentLocal<String> NAME = ExtentLocal.newInstance();\n@@ -233,2 +233,2 @@\n- *     \/\/ @link substring=\"where\" target=\"ScopeLocal#where\" :\n- *     ScopeLocal.where(NAME, \"duke\").run(() -> {\n+ *     \/\/ @link substring=\"where\" target=\"ExtentLocal#where\" :\n+ *     ExtentLocal.where(NAME, \"duke\").run(() -> {\n@@ -303,1 +303,1 @@\n-     * <p> This method captures the current thread's {@linkplain ScopeLocal scope-local}\n+     * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n@@ -307,1 +307,1 @@\n-     * inheritance of scope-local bindings.\n+     * inheritance of extent-local bindings.\n@@ -393,1 +393,1 @@\n-     * the current thread's {@linkplain ScopeLocal scope-local} bindings. The bindings must\n+     * the current thread's {@linkplain ExtentLocal extent-local} bindings. The bindings must\n@@ -422,1 +422,1 @@\n-     * @throws StructureViolationException if the current scope-local bindings are not\n+     * @throws StructureViolationException if the current extent-local bindings are not\n@@ -657,1 +657,1 @@\n-     * ScopeLocal.Carrier#run(Runnable) operations} with scope-local bindings then\n+     * ExtentLocal.Carrier#run(Runnable) operations} with extent-local bindings then\n@@ -849,1 +849,1 @@\n-         * <p> This method captures the current thread's {@linkplain ScopeLocal scope-local}\n+         * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n@@ -853,1 +853,1 @@\n-         * for the purpose of inheritance of scope-local bindings.\n+         * for the purpose of inheritance of extent-local bindings.\n@@ -1031,1 +1031,1 @@\n-         * <p> This method captures the current thread's {@linkplain ScopeLocal scope-local}\n+         * <p> This method captures the current thread's {@linkplain ExtentLocal extent-local}\n@@ -1035,1 +1035,1 @@\n-         * for the purpose of inheritance of scope-local bindings.\n+         * for the purpose of inheritance of extent-local bindings.\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -879,1 +879,1 @@\n-jdk\/incubator\/concurrent\/ScopeLocal\/Stress.java                 0000000 generic-all\n+jdk\/incubator\/concurrent\/ExtentLocal\/Stress.java                 0000000 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic test for ExtentLocal\n+ * @modules jdk.incubator.concurrent\n+ * @run testng Basic\n+ *\/\n+\n+import jdk.incubator.concurrent.ExtentLocal;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+\n+import org.testng.TestListenerAdapter;\n+import org.testng.TestNG;\n+import org.testng.annotations.Test;\n+import org.testng.xml.XmlSuite;\n+\n+import static org.testng.Assert.*;\n+\n+public class Basic {\n+\n+    public static void main(String[] args) {\n+        TestListenerAdapter tla = new TestListenerAdapter();\n+        TestNG testNG = new TestNG();\n+        testNG.setParallel(XmlSuite.ParallelMode.METHODS);\n+        testNG.setTestClasses(new Class[] { Basic.class });\n+        testNG.addListener(tla);\n+        testNG.run();\n+    }\n+\n+    @Test\n+    public void testUnbound1() {\n+        ExtentLocal<String> v = ExtentLocal.newInstance();\n+        assertFalse(v.isBound());\n+        assertThrows(NoSuchElementException.class, () -> v.get());\n+    }\n+\n+    @Test\n+    public void testOrElse() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        assertFalse(name.isBound());\n+        assertTrue(name.orElse(null) == null);\n+        assertEquals(name.orElse(\"default\"), \"default\");\n+        ExtentLocal.where(name, \"fred\", () -> {\n+            assertEquals(name.orElse(null), \"fred\");\n+            assertEquals(name.orElse(\"default\"), \"fred\");\n+        });\n+    }\n+\n+    @Test\n+    public void testOrElseThrow() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        assertFalse(name.isBound());\n+        assertThrows(IllegalStateException.class, () -> name.orElseThrow(IllegalStateException::new));\n+        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+        ExtentLocal.where(name, \"fred\", () -> {\n+            assertEquals(name.orElseThrow(IllegalStateException::new), \"fred\");\n+            assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding1() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        ExtentLocal.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding2() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        ExtentLocal.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+\n+            ExtentLocal.where(name, \"joe\", () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(\"joe\".equals(name.get()));\n+            });\n+\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding3() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        ExtentLocal.where(name, null, () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(name.get() == null);\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding4() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        ExtentLocal.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+\n+            ExtentLocal.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+            });\n+\n+            assertTrue(name.isBound());\n+            assertTrue(\"fred\".equals(name.get()));\n+        });\n+    }\n+\n+    @Test\n+    public void testRunWithBinding9() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        assertThrows(NullPointerException.class,\n+                     () -> ExtentLocal.where(name, \"fred\", (Runnable) null));\n+    }\n+\n+    @Test\n+    public void testCallWithBinding1() throws Exception {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        int result = ExtentLocal.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value = name.get();\n+            assertTrue(\"fred\".equals(value));\n+            return 1;\n+        });\n+        assertTrue(result == 1);\n+    }\n+\n+    @Test\n+    public void testCallWithBinding2() throws Exception {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        int result1 = ExtentLocal.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value1 = name.get();\n+            assertTrue(\"fred\".equals(value1));\n+\n+            int result2 = ExtentLocal.where(name, \"joe\", () -> {\n+                assertTrue(name.isBound());\n+                String value2 = name.get();\n+                assertTrue(\"joe\".equals(value2));\n+                return 2;\n+            });\n+            assertTrue(result2 == 2);\n+\n+            return 1;\n+        });\n+        assertTrue(result1 == 1);\n+    }\n+\n+    @Test\n+    public void testCallWithBinding3() throws Exception {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        int result = ExtentLocal.where(name, null, () -> {\n+            assertTrue(name.isBound());\n+            assertTrue(name.get() == null);\n+            return 1;\n+        });\n+        assertTrue(result == 1);\n+    }\n+\n+    @Test\n+    public void testCallWithBinding4() throws Exception {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        int result1 = ExtentLocal.where(name, \"fred\", () -> {\n+            assertTrue(name.isBound());\n+            String value1 = name.get();\n+            assertTrue(\"fred\".equals(value1));\n+\n+            int result2 = ExtentLocal.where(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertTrue(name.get() == null);\n+                return 2;\n+            });\n+            assertTrue(result2 == 2);\n+\n+            return 1;\n+        });\n+        assertTrue(result1 == 1);\n+    }\n+\n+    @Test\n+    public void testCallWithBinding9() throws Exception {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        assertThrows(NullPointerException.class,\n+                     () -> ExtentLocal.where(name, \"fred\", (Callable) null));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ExtentLocal\/Basic.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Stress test for ExtentLocal\n+ * @modules jdk.incubator.concurrent\n+ * @compile --enable-preview -source ${jdk.version} Stress.java\n+ * @run testng\/othervm\/timeout=300 -XX:-TieredCompilation --enable-preview Stress\n+ * @run testng\/othervm\/timeout=300 --enable-preview Stress\n+ *\/\n+\n+import jdk.incubator.concurrent.ExtentLocal;\n+import jdk.incubator.concurrent.StructuredTaskScope;\n+import jdk.incubator.concurrent.StructureViolationException;\n+import java.util.concurrent.ThreadFactory;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class Stress {\n+\n+    ExtentLocal<Integer> sl1 = ExtentLocal.newInstance();\n+    ExtentLocal<Integer> sl2 = ExtentLocal.newInstance();\n+\n+    static final ExtentLocal<ThreadFactory> factory = ExtentLocal.newInstance();\n+    static final ExtentLocal.Carrier platformFactoryCarrier = ExtentLocal.where(factory, Thread.ofPlatform().factory());\n+    static final ExtentLocal.Carrier virtualFactoryCarrier = ExtentLocal.where(factory, Thread.ofVirtual().factory());\n+\n+    final ExtentLocal<Integer>[] scopeLocals;\n+\n+    Stress() {\n+        scopeLocals = new ExtentLocal[500];\n+        for (int i = 0; i < scopeLocals.length; i++) {\n+            scopeLocals[i] = ExtentLocal.newInstance();\n+        }\n+    }\n+\n+    private class MyBanger implements Runnable {\n+        final ExtentLocal.Binder binder;\n+        boolean shouldRunOutOfMemory;\n+        boolean failed = false;\n+\n+        MyBanger(ExtentLocal.Binder binder, boolean shouldRunOutOfMemory) {\n+            this.binder = binder;\n+            this.shouldRunOutOfMemory = shouldRunOutOfMemory;\n+        }\n+\n+        volatile int a[][] = new int[10000][];\n+\n+        public void runOutOfMemory(int base, int size) {\n+            for (int i = base; i < a.length; i++) {\n+                try {\n+                    a[i] = new int[size];\n+                } catch (OutOfMemoryError e) {\n+                    size \/= 2;\n+                    if (size == 0) {\n+                        return;\n+                    }\n+                }\n+            }\n+        }\n+\n+        public void run() {\n+            int n = sl1.get();\n+            try {\n+                ExtentLocal.where(sl1, n + 1).run(this);\n+            } catch (StackOverflowError e) {\n+                if (sl1.get() != n) {\n+                    failed = true;\n+                }\n+            }\n+            if (shouldRunOutOfMemory) {\n+                runOutOfMemory(0, 0x1000_0000);\n+            }\n+\n+            \/\/ Trigger a StructureViolationException\n+            binder.close();\n+        }\n+\n+    }\n+\n+    public void stackOverflow() {\n+        ExtentLocal.Binder binder = sl2.bind(99);\n+        try {\n+            var myBanger = new MyBanger(binder, false);\n+            try {\n+                ExtentLocal.where(sl1, 0, myBanger);\n+            } catch (RuntimeException e) {\n+                assertFalse(sl1.isBound());\n+            } finally {\n+                binder.close();\n+            }\n+            assertFalse(myBanger.failed);\n+        } finally {\n+            binder.close();\n+        }\n+    }\n+\n+    private int deepBindings(int depth) {\n+        try {\n+            if (depth > 0) {\n+                try (var unused = scopeLocals[depth].bind(depth)) {\n+                    var vx = scopeLocals[depth].get();\n+                    return ExtentLocal.where(sl1, sl1.get() + 1)\n+                            .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n+                            .call(() -> scopeLocals[depth].get() + deepBindings(depth - 1) + sl1.get());\n+                }\n+            } else {\n+                return sl2.get();\n+            }\n+        } catch (Exception foo) {\n+            return 0;\n+        }\n+    }\n+\n+    private void deepBindings() {\n+        int result;\n+        try {\n+            result = ExtentLocal.where(sl2, 42).where(sl1, 99).call(() ->\n+                    deepBindings(scopeLocals.length - 1));\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        assertEquals(result, 423693);\n+    }\n+\n+    private int deepBindings2(int depth) throws Exception {\n+        if (depth > 0) {\n+            try (var unused = scopeLocals[depth].bind(depth)) {\n+                try (var structuredTaskScope = new StructuredTaskScope<Integer>(null, factory.get())) {\n+                    var future = structuredTaskScope.fork(\n+                            () -> ExtentLocal.where(sl1, sl1.get() + 1)\n+                                    .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n+                                    .call(() -> scopeLocals[depth].get() + deepBindings2(depth - 1) + sl1.get()));\n+                    structuredTaskScope.join();\n+                    return future.get();\n+                }\n+            }\n+        } else {\n+            return sl2.get();\n+        }\n+    }\n+\n+    \/\/ Serious abuse of ExtentLocals. Make sure everything still works,\n+    \/\/ even with a ridiculous number of bindings.\n+    @Test\n+    public void manyExtentLocals() {\n+        ExtentLocal<Object>[] scopeLocals = new ExtentLocal[10_000];\n+        ExtentLocal.Binder[] binders = new ExtentLocal.Binder[scopeLocals.length];\n+\n+        for (int i = 0; i < scopeLocals.length; i++) {\n+            scopeLocals[i] = ExtentLocal.newInstance();\n+            binders[i] = scopeLocals[i].bind(i);\n+        }\n+        long n = 0;\n+        for (var sl : scopeLocals) {\n+            n += (Integer)sl.get();\n+        }\n+        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n+            binders[i].close();\n+        }\n+        assertEquals(n, 49995000);\n+        for (int i = 0; i < scopeLocals.length; i++) {\n+            binders[i] = scopeLocals[i].bind(i);\n+        }\n+        int caught = 0;\n+        \/\/ Trigger StructureViolationExceptions\n+        for (int i = scopeLocals.length - 2; i >= 0; i -= 2) {\n+            try {\n+                binders[i].close();\n+            } catch (StructureViolationException x) {\n+                caught++;\n+            }\n+        }\n+\n+        assertEquals(caught, 5000);\n+\n+        \/\/ They should all be closed now\n+        caught = 0;\n+        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n+            binders[i].close();\n+            try {\n+                binders[i].close();\n+            } catch (StructureViolationException x) {\n+                caught++;\n+            }\n+        }\n+        assertEquals(caught, 0);\n+    }\n+\n+    private void testDeepBindings(ExtentLocal.Carrier factoryCarrier) {\n+        int val = 0;\n+        try (var unused = factoryCarrier.where(sl2, 42).where(sl1, 99).bind()) {\n+            val = deepBindings2(scopeLocals.length - 1);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+        assertEquals(val, 423693);\n+    }\n+\n+    \/\/ Make sure that stack overflows are handled correctly.\n+    \/\/ Run for a while to trigger JIT compilation.\n+    @Test\n+    public void stackOverflowTest() {\n+        assertFalse(sl2.isBound());\n+        for (int i = 0; i < 200; i++) {\n+            try {\n+                stackOverflow();\n+            } catch (Throwable t) {\n+                ;\n+            }\n+            assertFalse(sl2.isBound());\n+        }\n+    }\n+\n+    @Test\n+    public void platformFactorydeepBindings() {\n+        testDeepBindings(platformFactoryCarrier);\n+    }\n+\n+    @Test\n+    public void virtualFactorydeepBindings() {\n+        testDeepBindings(virtualFactoryCarrier);\n+    }\n+\n+    void run() {\n+        manyExtentLocals();\n+        platformFactorydeepBindings();\n+        stackOverflowTest();\n+        virtualFactorydeepBindings();\n+    }\n+\n+    public static void main(String[] args) {\n+        new Stress().run();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ExtentLocal\/Stress.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -1,217 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Basic test for ScopeLocal\n- * @modules jdk.incubator.concurrent\n- * @run testng Basic\n- *\/\n-\n-import jdk.incubator.concurrent.ScopeLocal;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.NoSuchElementException;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-\n-import org.testng.TestListenerAdapter;\n-import org.testng.TestNG;\n-import org.testng.annotations.Test;\n-import org.testng.xml.XmlSuite;\n-\n-import static org.testng.Assert.*;\n-\n-public class Basic {\n-\n-    public static void main(String[] args) {\n-        TestListenerAdapter tla = new TestListenerAdapter();\n-        TestNG testNG = new TestNG();\n-        testNG.setParallel(XmlSuite.ParallelMode.METHODS);\n-        testNG.setTestClasses(new Class[] { Basic.class });\n-        testNG.addListener(tla);\n-        testNG.run();\n-    }\n-\n-    @Test\n-    public void testUnbound1() {\n-        ScopeLocal<String> v = ScopeLocal.newInstance();\n-        assertFalse(v.isBound());\n-        assertThrows(NoSuchElementException.class, () -> v.get());\n-    }\n-\n-    @Test\n-    public void testOrElse() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        assertFalse(name.isBound());\n-        assertTrue(name.orElse(null) == null);\n-        assertEquals(name.orElse(\"default\"), \"default\");\n-        ScopeLocal.where(name, \"fred\", () -> {\n-            assertEquals(name.orElse(null), \"fred\");\n-            assertEquals(name.orElse(\"default\"), \"fred\");\n-        });\n-    }\n-\n-    @Test\n-    public void testOrElseThrow() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        assertFalse(name.isBound());\n-        assertThrows(IllegalStateException.class, () -> name.orElseThrow(IllegalStateException::new));\n-        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n-        ScopeLocal.where(name, \"fred\", () -> {\n-            assertEquals(name.orElseThrow(IllegalStateException::new), \"fred\");\n-            assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding1() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding2() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            ScopeLocal.where(name, \"joe\", () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(\"joe\".equals(name.get()));\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding3() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        ScopeLocal.where(name, null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding4() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-\n-            ScopeLocal.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-            });\n-\n-            assertTrue(name.isBound());\n-            assertTrue(\"fred\".equals(name.get()));\n-        });\n-    }\n-\n-    @Test\n-    public void testRunWithBinding9() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        assertThrows(NullPointerException.class,\n-                     () -> ScopeLocal.where(name, \"fred\", (Runnable) null));\n-    }\n-\n-    @Test\n-    public void testCallWithBinding1() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        int result = ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value = name.get();\n-            assertTrue(\"fred\".equals(value));\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    @Test\n-    public void testCallWithBinding2() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        int result1 = ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-\n-            int result2 = ScopeLocal.where(name, \"joe\", () -> {\n-                assertTrue(name.isBound());\n-                String value2 = name.get();\n-                assertTrue(\"joe\".equals(value2));\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    @Test\n-    public void testCallWithBinding3() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        int result = ScopeLocal.where(name, null, () -> {\n-            assertTrue(name.isBound());\n-            assertTrue(name.get() == null);\n-            return 1;\n-        });\n-        assertTrue(result == 1);\n-    }\n-\n-    @Test\n-    public void testCallWithBinding4() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        int result1 = ScopeLocal.where(name, \"fred\", () -> {\n-            assertTrue(name.isBound());\n-            String value1 = name.get();\n-            assertTrue(\"fred\".equals(value1));\n-\n-            int result2 = ScopeLocal.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertTrue(name.get() == null);\n-                return 2;\n-            });\n-            assertTrue(result2 == 2);\n-\n-            return 1;\n-        });\n-        assertTrue(result1 == 1);\n-    }\n-\n-    @Test\n-    public void testCallWithBinding9() throws Exception {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        assertThrows(NullPointerException.class,\n-                     () -> ScopeLocal.where(name, \"fred\", (Callable) null));\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopeLocal\/Basic.java","additions":0,"deletions":217,"binary":false,"changes":217,"status":"deleted"},{"patch":"@@ -1,256 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @summary Stress test for ScopeLocal\n- * @modules jdk.incubator.concurrent\n- * @compile --enable-preview -source ${jdk.version} Stress.java\n- * @run testng\/othervm\/timeout=300 -XX:-TieredCompilation --enable-preview Stress\n- * @run testng\/othervm\/timeout=300 --enable-preview Stress\n- *\/\n-\n-import jdk.incubator.concurrent.ScopeLocal;\n-import jdk.incubator.concurrent.StructuredTaskScope;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.concurrent.ThreadFactory;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class Stress {\n-\n-    ScopeLocal<Integer> sl1 = ScopeLocal.newInstance();\n-    ScopeLocal<Integer> sl2 = ScopeLocal.newInstance();\n-\n-    static final ScopeLocal<ThreadFactory> factory = ScopeLocal.newInstance();\n-    static final ScopeLocal.Carrier platformFactoryCarrier = ScopeLocal.where(factory, Thread.ofPlatform().factory());\n-    static final ScopeLocal.Carrier virtualFactoryCarrier = ScopeLocal.where(factory, Thread.ofVirtual().factory());\n-\n-    final ScopeLocal<Integer>[] scopeLocals;\n-\n-    Stress() {\n-        scopeLocals = new ScopeLocal[500];\n-        for (int i = 0; i < scopeLocals.length; i++) {\n-            scopeLocals[i] = ScopeLocal.newInstance();\n-        }\n-    }\n-\n-    private class MyBanger implements Runnable {\n-        final ScopeLocal.Binder binder;\n-        boolean shouldRunOutOfMemory;\n-        boolean failed = false;\n-\n-        MyBanger(ScopeLocal.Binder binder, boolean shouldRunOutOfMemory) {\n-            this.binder = binder;\n-            this.shouldRunOutOfMemory = shouldRunOutOfMemory;\n-        }\n-\n-        volatile int a[][] = new int[10000][];\n-\n-        public void runOutOfMemory(int base, int size) {\n-            for (int i = base; i < a.length; i++) {\n-                try {\n-                    a[i] = new int[size];\n-                } catch (OutOfMemoryError e) {\n-                    size \/= 2;\n-                    if (size == 0) {\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-\n-        public void run() {\n-            int n = sl1.get();\n-            try {\n-                ScopeLocal.where(sl1, n + 1).run(this);\n-            } catch (StackOverflowError e) {\n-                if (sl1.get() != n) {\n-                    failed = true;\n-                }\n-            }\n-            if (shouldRunOutOfMemory) {\n-                runOutOfMemory(0, 0x1000_0000);\n-            }\n-\n-            \/\/ Trigger a StructureViolationException\n-            binder.close();\n-        }\n-\n-    }\n-\n-    public void stackOverflow() {\n-        ScopeLocal.Binder binder = sl2.bind(99);\n-        try {\n-            var myBanger = new MyBanger(binder, false);\n-            try {\n-                ScopeLocal.where(sl1, 0, myBanger);\n-            } catch (RuntimeException e) {\n-                assertFalse(sl1.isBound());\n-            } finally {\n-                binder.close();\n-            }\n-            assertFalse(myBanger.failed);\n-        } finally {\n-            binder.close();\n-        }\n-    }\n-\n-    private int deepBindings(int depth) {\n-        try {\n-            if (depth > 0) {\n-                try (var unused = scopeLocals[depth].bind(depth)) {\n-                    var vx = scopeLocals[depth].get();\n-                    return ScopeLocal.where(sl1, sl1.get() + 1)\n-                            .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n-                            .call(() -> scopeLocals[depth].get() + deepBindings(depth - 1) + sl1.get());\n-                }\n-            } else {\n-                return sl2.get();\n-            }\n-        } catch (Exception foo) {\n-            return 0;\n-        }\n-    }\n-\n-    private void deepBindings() {\n-        int result;\n-        try {\n-            result = ScopeLocal.where(sl2, 42).where(sl1, 99).call(() ->\n-                    deepBindings(scopeLocals.length - 1));\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-        assertEquals(result, 423693);\n-    }\n-\n-    private int deepBindings2(int depth) throws Exception {\n-        if (depth > 0) {\n-            try (var unused = scopeLocals[depth].bind(depth)) {\n-                try (var structuredTaskScope = new StructuredTaskScope<Integer>(null, factory.get())) {\n-                    var future = structuredTaskScope.fork(\n-                            () -> ScopeLocal.where(sl1, sl1.get() + 1)\n-                                    .where(scopeLocals[depth], scopeLocals[depth].get() * 2)\n-                                    .call(() -> scopeLocals[depth].get() + deepBindings2(depth - 1) + sl1.get()));\n-                    structuredTaskScope.join();\n-                    return future.get();\n-                }\n-            }\n-        } else {\n-            return sl2.get();\n-        }\n-    }\n-\n-    \/\/ Serious abuse of ScopeLocals. Make sure everything still works,\n-    \/\/ even with a ridiculous number of bindings.\n-    @Test\n-    public void manyScopeLocals() {\n-        ScopeLocal<Object>[] scopeLocals = new ScopeLocal[10_000];\n-        ScopeLocal.Binder[] binders = new ScopeLocal.Binder[scopeLocals.length];\n-\n-        for (int i = 0; i < scopeLocals.length; i++) {\n-            scopeLocals[i] = ScopeLocal.newInstance();\n-            binders[i] = scopeLocals[i].bind(i);\n-        }\n-        long n = 0;\n-        for (var sl : scopeLocals) {\n-            n += (Integer)sl.get();\n-        }\n-        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n-            binders[i].close();\n-        }\n-        assertEquals(n, 49995000);\n-        for (int i = 0; i < scopeLocals.length; i++) {\n-            binders[i] = scopeLocals[i].bind(i);\n-        }\n-        int caught = 0;\n-        \/\/ Trigger StructureViolationExceptions\n-        for (int i = scopeLocals.length - 2; i >= 0; i -= 2) {\n-            try {\n-                binders[i].close();\n-            } catch (StructureViolationException x) {\n-                caught++;\n-            }\n-        }\n-\n-        assertEquals(caught, 5000);\n-\n-        \/\/ They should all be closed now\n-        caught = 0;\n-        for (int i = scopeLocals.length - 1; i >= 0; --i) {\n-            binders[i].close();\n-            try {\n-                binders[i].close();\n-            } catch (StructureViolationException x) {\n-                caught++;\n-            }\n-        }\n-        assertEquals(caught, 0);\n-    }\n-\n-    private void testDeepBindings(ScopeLocal.Carrier factoryCarrier) {\n-        int val = 0;\n-        try (var unused = factoryCarrier.where(sl2, 42).where(sl1, 99).bind()) {\n-            val = deepBindings2(scopeLocals.length - 1);\n-        } catch (Exception e) {\n-            throw new RuntimeException(e);\n-        }\n-        assertEquals(val, 423693);\n-    }\n-\n-    \/\/ Make sure that stack overflows are handled correctly.\n-    \/\/ Run for a while to trigger JIT compilation.\n-    @Test\n-    public void stackOverflowTest() {\n-        assertFalse(sl2.isBound());\n-        for (int i = 0; i < 200; i++) {\n-            try {\n-                stackOverflow();\n-            } catch (Throwable t) {\n-                ;\n-            }\n-            assertFalse(sl2.isBound());\n-        }\n-    }\n-\n-    @Test\n-    public void platformFactorydeepBindings() {\n-        testDeepBindings(platformFactoryCarrier);\n-    }\n-\n-    @Test\n-    public void virtualFactorydeepBindings() {\n-        testDeepBindings(virtualFactoryCarrier);\n-    }\n-\n-    void run() {\n-        manyScopeLocals();\n-        platformFactorydeepBindings();\n-        stackOverflowTest();\n-        virtualFactorydeepBindings();\n-    }\n-\n-    public static void main(String[] args) {\n-        new Stress().run();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopeLocal\/Stress.java","additions":0,"deletions":256,"binary":false,"changes":256,"status":"deleted"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.concurrent.ScopeLocal;\n+import jdk.incubator.concurrent.ExtentLocal;\n@@ -311,3 +311,3 @@\n-    public void testForkInheritsScopeLocals1() throws Exception {\n-        ScopeLocal<String> NAME = ScopeLocal.newInstance();\n-        String value = ScopeLocal.where(NAME, \"x\").call(() -> {\n+    public void testForkInheritsExtentLocals1() throws Exception {\n+        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n+        String value = ExtentLocal.where(NAME, \"x\").call(() -> {\n@@ -330,3 +330,3 @@\n-    public void testForkInheritsScopeLocals2() throws Exception {\n-        ScopeLocal<String> NAME = ScopeLocal.newInstance();\n-        String value = ScopeLocal.where(NAME, \"x\").call(() -> {\n+    public void testForkInheritsExtentLocals2() throws Exception {\n+        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n+        String value = ExtentLocal.where(NAME, \"x\").call(() -> {\n@@ -917,1 +917,1 @@\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n@@ -924,1 +924,1 @@\n-                ScopeLocal.where(name, \"x\").run(() -> {\n+                ExtentLocal.where(name, \"x\").run(() -> {\n@@ -955,1 +955,1 @@\n-        ScopeLocal<String> NAME = ScopeLocal.newInstance();\n+        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n@@ -958,1 +958,1 @@\n-            ScopeLocal.where(NAME, \"x\").run(() -> {\n+            ExtentLocal.where(NAME, \"x\").run(() -> {\n@@ -971,2 +971,2 @@\n-        ScopeLocal<String> NAME1 = ScopeLocal.newInstance();\n-        ScopeLocal<String> NAME2 = ScopeLocal.newInstance();\n+        ExtentLocal<String> NAME1 = ExtentLocal.newInstance();\n+        ExtentLocal<String> NAME2 = ExtentLocal.newInstance();\n@@ -975,1 +975,1 @@\n-        ScopeLocal.where(NAME1, \"x\").run(() -> {\n+        ExtentLocal.where(NAME1, \"x\").run(() -> {\n@@ -977,1 +977,1 @@\n-                ScopeLocal.where(NAME1, \"y\").run(() -> {\n+                ExtentLocal.where(NAME1, \"y\").run(() -> {\n@@ -985,1 +985,1 @@\n-        ScopeLocal.where(NAME1, \"x\").run(() -> {\n+        ExtentLocal.where(NAME1, \"x\").run(() -> {\n@@ -987,1 +987,1 @@\n-                ScopeLocal.where(NAME2, \"y\").run(() -> {\n+                ExtentLocal.where(NAME2, \"y\").run(() -> {\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ThreadFlock with scope locals\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules jdk.incubator.concurrent\n+ * @compile --enable-preview -source ${jdk.version} ExtentLocalsTest.java\n+ * @run testng\/othervm --enable-preview ExtentLocalsTest\n+ *\/\n+\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicReference;\n+import jdk.internal.misc.ThreadFlock;\n+import jdk.incubator.concurrent.ExtentLocal;\n+import jdk.incubator.concurrent.StructureViolationException;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class ExtentLocalsTest {\n+\n+    @DataProvider(name = \"factories\")\n+    public Object[][] factories() {\n+        var defaultThreadFactory = Executors.defaultThreadFactory();\n+        var virtualThreadFactory = Thread.ofVirtual().factory();\n+        return new Object[][]{\n+                { defaultThreadFactory, },\n+                { virtualThreadFactory, },\n+        };\n+    }\n+\n+    \/**\n+     * Test inheritance of scope-local bindings.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testInheritsExtentLocals(ThreadFactory factory) throws Exception {\n+        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n+        String value = ExtentLocal.where(NAME, \"fred\").call(() -> {\n+            var result = new AtomicReference<String>();\n+            try (var flock = ThreadFlock.open(null)) {\n+                Thread thread = factory.newThread(() -> {\n+                    \/\/ child\n+                    result.set(NAME.get());\n+                });\n+                flock.start(thread);\n+            }\n+            return result.get();\n+        });\n+        assertEquals(value, \"fred\");\n+    }\n+\n+    \/**\n+     * Test exiting a scope local operation should close nested thread flocks.\n+     *\/\n+    @Test\n+    public void testStructureViolation1() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        class Box {\n+            ThreadFlock flock1;\n+            ThreadFlock flock2;\n+        }\n+        var box = new Box();\n+        try {\n+            ExtentLocal.where(name, \"x1\").run(() -> {\n+                box.flock1 = ThreadFlock.open(null);\n+                box.flock2 = ThreadFlock.open(null);\n+            });\n+            fail();\n+        } catch (StructureViolationException expected) { }\n+        assertTrue(box.flock1.isClosed());\n+        assertTrue(box.flock2.isClosed());\n+    }\n+\n+    \/**\n+     * Test closing a thread flock with enclosing scope local operations and\n+     * thread flocks. This test closes enclosing flock1.\n+     *\/\n+    @Test\n+    public void testStructureViolation2() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ExtentLocal.where(name, \"x1\").run(() -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ExtentLocal.where(name, \"x2\").run(() -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ExtentLocal.where(name, \"x3\").run(() -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock1.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertTrue(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock with enclosing scope local operations and\n+     * thread flocks. This test closes enclosing flock2.\n+     *\/\n+    @Test\n+    public void testStructureViolation3() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ExtentLocal.where(name, \"x1\").run(() -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ExtentLocal.where(name, \"x2\").run(() -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ExtentLocal.where(name, \"x3\").run(() -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock2.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertTrue(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a thread flock with enclosing scope local operations and\n+     * thread flocks. This test closes enclosing flock3.\n+     *\/\n+    @Test\n+    public void testStructureViolation4() {\n+        ExtentLocal<String> name = ExtentLocal.newInstance();\n+        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n+            ExtentLocal.where(name, \"x1\").run(() -> {\n+                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n+                    ExtentLocal.where(name, \"x2\").run(() -> {\n+                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n+                            ExtentLocal.where(name, \"x3\").run(() -> {\n+                                var flock4 = ThreadFlock.open(\"flock4\");\n+\n+                                try {\n+                                    flock3.close();\n+                                    fail();\n+                                } catch (StructureViolationException expected) { }\n+\n+                                assertFalse(flock1.isClosed());\n+                                assertFalse(flock2.isClosed());\n+                                assertTrue(flock3.isClosed());\n+                                assertTrue(flock4.isClosed());\n+                            });\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test that start throws StructureViolationException if scope-local bindings\n+     * have changed.\n+     *\/\n+    @Test(dataProvider = \"factories\")\n+    public void testStructureViolation5(ThreadFactory factory) throws Exception {\n+        ExtentLocal<String> NAME = ExtentLocal.newInstance();\n+        try (var flock = ThreadFlock.open(null)) {\n+            ExtentLocal.where(NAME, \"fred\").run(() -> {\n+                Thread thread = factory.newThread(() -> { });\n+                expectThrows(StructureViolationException.class, () -> flock.start(thread));\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ExtentLocalsTest.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -1,209 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test ThreadFlock with scope locals\n- * @modules java.base\/jdk.internal.misc\n- * @modules jdk.incubator.concurrent\n- * @compile --enable-preview -source ${jdk.version} ScopeLocalsTest.java\n- * @run testng\/othervm --enable-preview ScopeLocalsTest\n- *\/\n-\n-import java.util.*;\n-import java.util.concurrent.*;\n-import java.util.concurrent.atomic.AtomicReference;\n-import jdk.internal.misc.ThreadFlock;\n-import jdk.incubator.concurrent.ScopeLocal;\n-import jdk.incubator.concurrent.StructureViolationException;\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class ScopeLocalsTest {\n-\n-    @DataProvider(name = \"factories\")\n-    public Object[][] factories() {\n-        var defaultThreadFactory = Executors.defaultThreadFactory();\n-        var virtualThreadFactory = Thread.ofVirtual().factory();\n-        return new Object[][]{\n-                { defaultThreadFactory, },\n-                { virtualThreadFactory, },\n-        };\n-    }\n-\n-    \/**\n-     * Test inheritance of scope-local bindings.\n-     *\/\n-    @Test(dataProvider = \"factories\")\n-    public void testInheritsScopeLocals(ThreadFactory factory) throws Exception {\n-        ScopeLocal<String> NAME = ScopeLocal.newInstance();\n-        String value = ScopeLocal.where(NAME, \"fred\").call(() -> {\n-            var result = new AtomicReference<String>();\n-            try (var flock = ThreadFlock.open(null)) {\n-                Thread thread = factory.newThread(() -> {\n-                    \/\/ child\n-                    result.set(NAME.get());\n-                });\n-                flock.start(thread);\n-            }\n-            return result.get();\n-        });\n-        assertEquals(value, \"fred\");\n-    }\n-\n-    \/**\n-     * Test exiting a scope local operation should close nested thread flocks.\n-     *\/\n-    @Test\n-    public void testStructureViolation1() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        class Box {\n-            ThreadFlock flock1;\n-            ThreadFlock flock2;\n-        }\n-        var box = new Box();\n-        try {\n-            ScopeLocal.where(name, \"x1\").run(() -> {\n-                box.flock1 = ThreadFlock.open(null);\n-                box.flock2 = ThreadFlock.open(null);\n-            });\n-            fail();\n-        } catch (StructureViolationException expected) { }\n-        assertTrue(box.flock1.isClosed());\n-        assertTrue(box.flock2.isClosed());\n-    }\n-\n-    \/**\n-     * Test closing a thread flock with enclosing scope local operations and\n-     * thread flocks. This test closes enclosing flock1.\n-     *\/\n-    @Test\n-    public void testStructureViolation2() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n-            ScopeLocal.where(name, \"x1\").run(() -> {\n-                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n-                    ScopeLocal.where(name, \"x2\").run(() -> {\n-                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n-                            ScopeLocal.where(name, \"x3\").run(() -> {\n-                                var flock4 = ThreadFlock.open(\"flock4\");\n-\n-                                try {\n-                                    flock1.close();\n-                                    fail();\n-                                } catch (StructureViolationException expected) { }\n-\n-                                assertTrue(flock1.isClosed());\n-                                assertTrue(flock2.isClosed());\n-                                assertTrue(flock3.isClosed());\n-                                assertTrue(flock4.isClosed());\n-\n-                            });\n-                        }\n-                    });\n-                }\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test closing a thread flock with enclosing scope local operations and\n-     * thread flocks. This test closes enclosing flock2.\n-     *\/\n-    @Test\n-    public void testStructureViolation3() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n-            ScopeLocal.where(name, \"x1\").run(() -> {\n-                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n-                    ScopeLocal.where(name, \"x2\").run(() -> {\n-                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n-                            ScopeLocal.where(name, \"x3\").run(() -> {\n-                                var flock4 = ThreadFlock.open(\"flock4\");\n-\n-                                try {\n-                                    flock2.close();\n-                                    fail();\n-                                } catch (StructureViolationException expected) { }\n-\n-                                assertFalse(flock1.isClosed());\n-                                assertTrue(flock2.isClosed());\n-                                assertTrue(flock3.isClosed());\n-                                assertTrue(flock4.isClosed());\n-                            });\n-                        }\n-                    });\n-                }\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test closing a thread flock with enclosing scope local operations and\n-     * thread flocks. This test closes enclosing flock3.\n-     *\/\n-    @Test\n-    public void testStructureViolation4() {\n-        ScopeLocal<String> name = ScopeLocal.newInstance();\n-        try (var flock1 = ThreadFlock.open(\"flock1\")) {\n-            ScopeLocal.where(name, \"x1\").run(() -> {\n-                try (var flock2 = ThreadFlock.open(\"flock2\")) {\n-                    ScopeLocal.where(name, \"x2\").run(() -> {\n-                        try (var flock3 = ThreadFlock.open(\"flock3\")) {\n-                            ScopeLocal.where(name, \"x3\").run(() -> {\n-                                var flock4 = ThreadFlock.open(\"flock4\");\n-\n-                                try {\n-                                    flock3.close();\n-                                    fail();\n-                                } catch (StructureViolationException expected) { }\n-\n-                                assertFalse(flock1.isClosed());\n-                                assertFalse(flock2.isClosed());\n-                                assertTrue(flock3.isClosed());\n-                                assertTrue(flock4.isClosed());\n-                            });\n-                        }\n-                    });\n-                }\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test that start throws StructureViolationException if scope-local bindings\n-     * have changed.\n-     *\/\n-    @Test(dataProvider = \"factories\")\n-    public void testStructureViolation5(ThreadFactory factory) throws Exception {\n-        ScopeLocal<String> NAME = ScopeLocal.newInstance();\n-        try (var flock = ThreadFlock.open(null)) {\n-            ScopeLocal.where(NAME, \"fred\").run(() -> {\n-                Thread thread = factory.newThread(() -> { });\n-                expectThrows(StructureViolationException.class, () -> flock.start(thread));\n-            });\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ScopeLocalsTest.java","additions":0,"deletions":209,"binary":false,"changes":209,"status":"deleted"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2022, red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ExtentLocal;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import static org.openjdk.bench.jdk.incubator.concurrent.ExtentLocalsData.*;\n+\n+\/**\n+ * Tests ExtentLocal\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@Warmup(iterations=4, time=1)\n+@Measurement(iterations=10, time=1)\n+@Threads(1)\n+@Fork(value = 1,\n+      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ExtentLocalsExecutorService\",\n+                        \"-Djmh.executor=CUSTOM\",\n+                        \"-Djmh.blackhole.mode=COMPILER\",\n+                        \"--add-modules=jdk.incubator.concurrent\",\n+                        \"--enable-preview\"})\n+@State(Scope.Thread)\n+@SuppressWarnings(\"preview\")\n+public class ExtentLocals {\n+\n+    private static final Integer THE_ANSWER = 42;\n+\n+    \/\/ Test 1: make sure ExtentLocal.get() is hoisted out of loops.\n+\n+    @Benchmark\n+    public void thousandAdds_ExtentLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ExtentLocalsData.sl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    @Benchmark\n+    public void thousandAdds_ThreadLocal(Blackhole bh) throws Exception {\n+        int result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ExtentLocalsData.tl1.get();\n+        }\n+        bh.consume(result);\n+    }\n+\n+    \/\/ Test 2: stress the ExtentLocal cache.\n+    \/\/ The idea here is to use a bunch of bound values cyclically, which\n+    \/\/ stresses the ExtentLocal cache.\n+\n+    int combine(int n, int i1, int i2, int i3, int i4, int i5, int i6) {\n+        return n + ((i1 ^ i2 >>> 6) + (i3 << 7) + i4 - i5 | i6);\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ExtentLocal() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, sl1.get(), sl2.get(), sl3.get(), sl4.get(), sl5.get(), sl6.get());\n+        }\n+        return result;\n+    }\n+\n+    @Benchmark\n+    public int sixValues_ThreadLocal() throws Exception {\n+        int result = 0;\n+        for (int i = 0 ; i < 166; i++) {\n+            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Test 3: The cost of bind, then get\n+    \/\/ This is the worst case for ExtentLocals because we have to create\n+    \/\/ a binding, link it in, then search the current bindings. In addition, we\n+    \/\/ create a cache entry for the bound value, then we immediately have to\n+    \/\/ destroy it.\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int CreateBindThenGetThenRemove_ExtentLocal() throws Exception {\n+        return ExtentLocal.where(sl1, THE_ANSWER).call(sl1::get);\n+    }\n+\n+\n+    \/\/ Create a Carrier ahead of time: might be slightly faster\n+    private static final ExtentLocal.Carrier HOLD_42 = ExtentLocal.where(sl1, 42);\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ExtentLocal() throws Exception {\n+        return HOLD_42.call(sl1::get);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetThenRemove_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return tl1.get();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ This has no exact equivalent in ExtentLocal, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int bindThenGetNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+        return tl1.get();\n+    }\n+\n+    \/\/ Test 4: The cost of binding, but not using any result\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ExtentLocal() throws Exception {\n+        return HOLD_42.call(this::getClass);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bind_ThreadLocal() throws Exception {\n+        try {\n+            tl1.set(THE_ANSWER);\n+            return this.getClass();\n+        } finally {\n+            tl1.remove();\n+        }\n+    }\n+\n+    \/\/ Simply set a ThreadLocal so that the caller can see it\n+    \/\/ This has no exact equivalent in ExtentLocal, but it's provided here for\n+    \/\/ information.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ThreadLocal() throws Exception {\n+        tl1.set(THE_ANSWER);\n+    }\n+\n+    \/\/ This is the closest I can think of to setNoRemove_ThreadLocal in that it\n+    \/\/ returns a value in a ExtentLocal container. The container must already\n+    \/\/ be bound to an AtomicReference for this to work.\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void setNoRemove_ExtentLocal() throws Exception {\n+        sl_atomicRef.get().setPlain(THE_ANSWER);\n+    }\n+\n+    \/\/ Test 5: A simple counter\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ExtentLocal() {\n+        sl_atomicInt.get().setPlain(\n+                sl_atomicInt.get().getPlain() + 1);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void counter_ThreadLocal() {\n+        \/\/ Very slow:\n+        \/\/ tl1.set(tl1.get() + 1);\n+        var ctr = tl_atomicInt.get();\n+        ctr.setPlain(ctr.getPlain() + 1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ExtentLocals.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import jdk.incubator.concurrent.ExtentLocal;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+@SuppressWarnings(\"preview\")\n+public class ExtentLocalsData {\n+\n+    static final ExtentLocal<Integer> sl1 = ExtentLocal.newInstance();\n+    static final ThreadLocal<Integer> tl1 = new ThreadLocal<>();\n+\n+    static final ExtentLocal<Integer> sl2 = ExtentLocal.newInstance();\n+    static final ExtentLocal<Integer> sl3 = ExtentLocal.newInstance();\n+    static final ExtentLocal<Integer> sl4 = ExtentLocal.newInstance();\n+    static final ExtentLocal<Integer> sl5 = ExtentLocal.newInstance();\n+    static final ExtentLocal<Integer> sl6 = ExtentLocal.newInstance();\n+    static final ExtentLocal<AtomicInteger> sl_atomicInt = ExtentLocal.newInstance();\n+\n+    static final ExtentLocal<Integer> unbound = ExtentLocal.newInstance();\n+\n+    static final ExtentLocal<AtomicReference<Integer>> sl_atomicRef = ExtentLocal.newInstance();\n+\n+    static final ThreadLocal<Integer> tl2 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl3 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl4 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl5 = new ThreadLocal<>();\n+    static final ThreadLocal<Integer> tl6 = new ThreadLocal<>();\n+    static final ThreadLocal<AtomicInteger> tl_atomicInt = new ThreadLocal<>();\n+\n+    static final ExtentLocal.Carrier VALUES = ExtentLocal\n+            .where(sl1, 42).where(sl2, 2).where(sl3, 3)\n+            .where(sl4, 4).where(sl5, 5).where(sl6, 6);\n+\n+    public static void run(Runnable action) {\n+        try {\n+            tl1.set(42); tl2.set(2); tl3.set(3); tl4.set(4); tl5.set(5); tl6.set(6);\n+            tl1.get();  \/\/ Create the ExtentLocal cache as a side effect\n+            tl_atomicInt.set(new AtomicInteger());\n+            VALUES.where(sl_atomicInt, new AtomicInteger())\n+                  .where(sl_atomicRef, new AtomicReference<>())\n+                  .run(action);\n+        } finally {\n+            tl1.remove(); tl2.remove(); tl3.remove(); tl4.remove(); tl5.remove(); tl6.remove();\n+            tl_atomicInt.remove();\n+        }\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ExtentLocalsData.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+package org.openjdk.bench.jdk.incubator.concurrent;\n+\n+import java.util.concurrent.*;\n+\n+public class ExtentLocalsExecutorService extends ThreadPoolExecutor {\n+    public ExtentLocalsExecutorService(int corePoolSize, String prefix) {\n+        super(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),\n+              new AThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n+    }\n+}\n+\n+class AThreadFactory implements ThreadFactory {\n+    public Thread newThread(Runnable action) {\n+        return new Thread() {\n+            public void run() {\n+                ExtentLocalsData.run(action);\n+            }\n+        };\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ExtentLocalsExecutorService.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 2022, red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n-\n-import jdk.incubator.concurrent.ScopeLocal;\n-import java.util.concurrent.TimeUnit;\n-import org.openjdk.jmh.annotations.*;\n-import org.openjdk.jmh.infra.Blackhole;\n-\n-import static org.openjdk.bench.jdk.incubator.concurrent.ScopeLocalsData.*;\n-\n-\/**\n- * Tests ScopeLocal\n- *\/\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.MICROSECONDS)\n-@Warmup(iterations=4, time=1)\n-@Measurement(iterations=10, time=1)\n-@Threads(1)\n-@Fork(value = 1,\n-      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ScopeLocalsExecutorService\",\n-                        \"-Djmh.executor=CUSTOM\",\n-                        \"-Djmh.blackhole.mode=COMPILER\",\n-                        \"--add-modules=jdk.incubator.concurrent\",\n-                        \"--enable-preview\"})\n-@State(Scope.Thread)\n-@SuppressWarnings(\"preview\")\n-public class ScopeLocals {\n-\n-    private static final Integer THE_ANSWER = 42;\n-\n-    \/\/ Test 1: make sure ScopeLocal.get() is hoisted out of loops.\n-\n-    @Benchmark\n-    public void thousandAdds_ScopeLocal(Blackhole bh) throws Exception {\n-        int result = 0;\n-        for (int i = 0; i < 1_000; i++) {\n-            result += ScopeLocalsData.sl1.get();\n-        }\n-        bh.consume(result);\n-    }\n-\n-    @Benchmark\n-    public void thousandAdds_ThreadLocal(Blackhole bh) throws Exception {\n-        int result = 0;\n-        for (int i = 0; i < 1_000; i++) {\n-            result += ScopeLocalsData.tl1.get();\n-        }\n-        bh.consume(result);\n-    }\n-\n-    \/\/ Test 2: stress the ScopeLocal cache.\n-    \/\/ The idea here is to use a bunch of bound values cyclically, which\n-    \/\/ stresses the ScopeLocal cache.\n-\n-    int combine(int n, int i1, int i2, int i3, int i4, int i5, int i6) {\n-        return n + ((i1 ^ i2 >>> 6) + (i3 << 7) + i4 - i5 | i6);\n-    }\n-\n-    @Benchmark\n-    public int sixValues_ScopeLocal() throws Exception {\n-        int result = 0;\n-        for (int i = 0 ; i < 166; i++) {\n-            result = combine(result, sl1.get(), sl2.get(), sl3.get(), sl4.get(), sl5.get(), sl6.get());\n-        }\n-        return result;\n-    }\n-\n-    @Benchmark\n-    public int sixValues_ThreadLocal() throws Exception {\n-        int result = 0;\n-        for (int i = 0 ; i < 166; i++) {\n-            result = combine(result, tl1.get(), tl2.get(), tl3.get(), tl4.get(), tl5.get(), tl6.get());\n-        }\n-        return result;\n-    }\n-\n-    \/\/ Test 3: The cost of bind, then get\n-    \/\/ This is the worst case for ScopeLocals because we have to create\n-    \/\/ a binding, link it in, then search the current bindings. In addition, we\n-    \/\/ create a cache entry for the bound value, then we immediately have to\n-    \/\/ destroy it.\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int CreateBindThenGetThenRemove_ScopeLocal() throws Exception {\n-        return ScopeLocal.where(sl1, THE_ANSWER).call(sl1::get);\n-    }\n-\n-\n-    \/\/ Create a Carrier ahead of time: might be slightly faster\n-    private static final ScopeLocal.Carrier HOLD_42 = ScopeLocal.where(sl1, 42);\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int bindThenGetThenRemove_ScopeLocal() throws Exception {\n-        return HOLD_42.call(sl1::get);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int bindThenGetThenRemove_ThreadLocal() throws Exception {\n-        try {\n-            tl1.set(THE_ANSWER);\n-            return tl1.get();\n-        } finally {\n-            tl1.remove();\n-        }\n-    }\n-\n-    \/\/ This has no exact equivalent in ScopeLocal, but it's provided here for\n-    \/\/ information.\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public int bindThenGetNoRemove_ThreadLocal() throws Exception {\n-        tl1.set(THE_ANSWER);\n-        return tl1.get();\n-    }\n-\n-    \/\/ Test 4: The cost of binding, but not using any result\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public Object bind_ScopeLocal() throws Exception {\n-        return HOLD_42.call(this::getClass);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public Object bind_ThreadLocal() throws Exception {\n-        try {\n-            tl1.set(THE_ANSWER);\n-            return this.getClass();\n-        } finally {\n-            tl1.remove();\n-        }\n-    }\n-\n-    \/\/ Simply set a ThreadLocal so that the caller can see it\n-    \/\/ This has no exact equivalent in ScopeLocal, but it's provided here for\n-    \/\/ information.\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void setNoRemove_ThreadLocal() throws Exception {\n-        tl1.set(THE_ANSWER);\n-    }\n-\n-    \/\/ This is the closest I can think of to setNoRemove_ThreadLocal in that it\n-    \/\/ returns a value in a ScopeLocal container. The container must already\n-    \/\/ be bound to an AtomicReference for this to work.\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void setNoRemove_ScopeLocal() throws Exception {\n-        sl_atomicRef.get().setPlain(THE_ANSWER);\n-    }\n-\n-    \/\/ Test 5: A simple counter\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void counter_ScopeLocal() {\n-        sl_atomicInt.get().setPlain(\n-                sl_atomicInt.get().getPlain() + 1);\n-    }\n-\n-    @Benchmark\n-    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n-    public void counter_ThreadLocal() {\n-        \/\/ Very slow:\n-        \/\/ tl1.set(tl1.get() + 1);\n-        var ctr = tl_atomicInt.get();\n-        ctr.setPlain(ctr.getPlain() + 1);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopeLocals.java","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n-\n-import jdk.incubator.concurrent.ScopeLocal;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-@SuppressWarnings(\"preview\")\n-public class ScopeLocalsData {\n-\n-    static final ScopeLocal<Integer> sl1 = ScopeLocal.newInstance();\n-    static final ThreadLocal<Integer> tl1 = new ThreadLocal<>();\n-\n-    static final ScopeLocal<Integer> sl2 = ScopeLocal.newInstance();\n-    static final ScopeLocal<Integer> sl3 = ScopeLocal.newInstance();\n-    static final ScopeLocal<Integer> sl4 = ScopeLocal.newInstance();\n-    static final ScopeLocal<Integer> sl5 = ScopeLocal.newInstance();\n-    static final ScopeLocal<Integer> sl6 = ScopeLocal.newInstance();\n-    static final ScopeLocal<AtomicInteger> sl_atomicInt = ScopeLocal.newInstance();\n-\n-    static final ScopeLocal<Integer> unbound = ScopeLocal.newInstance();\n-\n-    static final ScopeLocal<AtomicReference<Integer>> sl_atomicRef = ScopeLocal.newInstance();\n-\n-    static final ThreadLocal<Integer> tl2 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl3 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl4 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl5 = new ThreadLocal<>();\n-    static final ThreadLocal<Integer> tl6 = new ThreadLocal<>();\n-    static final ThreadLocal<AtomicInteger> tl_atomicInt = new ThreadLocal<>();\n-\n-    static final ScopeLocal.Carrier VALUES = ScopeLocal\n-            .where(sl1, 42).where(sl2, 2).where(sl3, 3)\n-            .where(sl4, 4).where(sl5, 5).where(sl6, 6);\n-\n-    public static void run(Runnable action) {\n-        try {\n-            tl1.set(42); tl2.set(2); tl3.set(3); tl4.set(4); tl5.set(5); tl6.set(6);\n-            tl1.get();  \/\/ Create the ScopeLocal cache as a side effect\n-            tl_atomicInt.set(new AtomicInteger());\n-            VALUES.where(sl_atomicInt, new AtomicInteger())\n-                  .where(sl_atomicRef, new AtomicReference<>())\n-                  .run(action);\n-        } finally {\n-            tl1.remove(); tl2.remove(); tl3.remove(); tl4.remove(); tl5.remove(); tl6.remove();\n-            tl_atomicInt.remove();\n-        }\n-    }\n-}\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopeLocalsData.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,44 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n-\n-import java.util.concurrent.*;\n-\n-public class ScopeLocalsExecutorService extends ThreadPoolExecutor {\n-    public ScopeLocalsExecutorService(int corePoolSize, String prefix) {\n-        super(1, 1, 0, TimeUnit.MILLISECONDS, new LinkedBlockingQueue<Runnable>(),\n-              new AThreadFactory(), new ThreadPoolExecutor.AbortPolicy());\n-    }\n-}\n-\n-class AThreadFactory implements ThreadFactory {\n-    public Thread newThread(Runnable action) {\n-        return new Thread() {\n-            public void run() {\n-                ScopeLocalsData.run(action);\n-            }\n-        };\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopeLocalsExecutorService.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"deleted"}]}