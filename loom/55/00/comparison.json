{"files":[{"patch":"@@ -153,0 +153,1 @@\n+  JavaThread* current = JavaThread::current();\n@@ -155,1 +156,1 @@\n-    java_thread = JavaThread::current();\n+    java_thread = current;\n@@ -171,1 +172,3 @@\n-    state = JvmtiThreadState::state_for(java_thread, thread_obj);\n+    HandleMark hm(current);\n+    Handle thread_handle(current, thread_obj);\n+    state = JvmtiThreadState::state_for(java_thread, thread_handle);\n@@ -210,1 +213,3 @@\n-    JvmtiThreadState* state = JvmtiThreadState::state_for(java_thread, thread_obj);\n+    HandleMark hm(current_thread);\n+    Handle thread_handle(current_thread, thread_obj);\n+    JvmtiThreadState* state = JvmtiThreadState::state_for(java_thread, thread_handle);\n@@ -1910,0 +1915,4 @@\n+  JavaThread* current = JavaThread::current();\n+  HandleMark hm(current);\n+  Handle thread_handle(current, thread_obj);\n+\n@@ -1914,1 +1923,1 @@\n-      JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread, thread_obj);\n+      JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread, thread_handle);\n@@ -1925,1 +1934,1 @@\n-  JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread, thread_obj);\n+  JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread, thread_handle);\n@@ -1931,2 +1940,2 @@\n-  MutexLocker mu(JvmtiThreadState_lock);\n-  if (java_thread == JavaThread::current()) {\n+  MutexLocker mu(current, JvmtiThreadState_lock);\n+  if (java_thread == current) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  _thread_oop_h = OopHandle(Universe::vm_global(), thread_oop);\n+  _thread_oop_h = OopHandle(JvmtiExport::jvmti_oop_storage(), thread_oop);\n@@ -173,1 +173,1 @@\n-  _thread_oop_h.release(Universe::vm_global());\n+  _thread_oop_h.release(JvmtiExport::jvmti_oop_storage());\n@@ -322,5 +322,2 @@\n-  \/\/ This is to work around assert in OopHandle copy constructor.\n-  GrowableArrayCHeap<OopHandle, mtServiceability>::append(NULLHandle);\n-  pop();\n-\n-  GrowableArrayCHeap<OopHandle, mtServiceability>::append(OopHandle(Universe::vm_global(), vt));\n+  OopHandle vthandle(JvmtiExport::jvmti_oop_storage(), vt);\n+  GrowableArrayCHeap<OopHandle, mtServiceability>::append(vthandle);\n@@ -333,6 +330,10 @@\n-  at(idx).release(Universe::vm_global());\n-\n-  \/\/ To work around assert in OopHandle copy constructor do not use remove_at().\n-  for (int i = idx + 1; i < length(); i++) {\n-    at_put(i - 1, NULLHandle); \/\/ work around assert in OopHandle copy constructor\n-    at_put(i - 1, at(i));\n+  at(idx).release(JvmtiExport::jvmti_oop_storage());\n+  at_put(idx, NULLHandle); \/\/ clear released OopHandle entry\n+\n+  \/\/ To work around assert in OopHandle assignment operator do not use remove_at().\n+  \/\/ OopHandle doesn't allow overwrites if the oop pointer is non-null.\n+  \/\/ Order doesn't matter, put the last element in idx\n+  int last = length() - 1;\n+  if (last > idx) {\n+    at_put(idx, at(last));\n+    at_put(last, NULLHandle); \/\/ clear moved OopHandle entry.\n@@ -346,1 +347,2 @@\n-    at(idx).release(Universe::vm_global());\n+    at(idx).release(JvmtiExport::jvmti_oop_storage());\n+    at_put(idx, NULLHandle); \/\/ clear released OopHandle entries\n@@ -376,1 +378,1 @@\n-  _vthread_suspend_list->invalidate(); \n+  _vthread_suspend_list->invalidate();\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-class JvmtiVTSuspender {\n+class JvmtiVTSuspender : AllStatic {\n@@ -265,1 +265,1 @@\n-  inline JavaThread *get_thread_or_saved(); \/\/ return _thread_saved if _thread is NULL \n+  inline JavaThread *get_thread_or_saved(); \/\/ return _thread_saved if _thread is NULL\n@@ -451,1 +451,1 @@\n-  static JvmtiThreadState *state_for(JavaThread *thread, oop thread_oop = NULL);\n+  static JvmtiThreadState *state_for(JavaThread *thread, Handle thread_handle = Handle());\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/safepointVerifiers.hpp\"\n@@ -78,0 +79,2 @@\n+  NoSafepointVerifier nsv;  \/\/ oop is safe to use.\n+\n@@ -96,4 +99,0 @@\n-      Thread* current_thread = Thread::current();\n-      HandleMark hm(current_thread);\n-      Handle thread_oop_h = Handle(current_thread, thread_oop);\n-\n@@ -101,2 +100,2 @@\n-      if (thread_oop_h() != NULL) { \/\/ thread_oop can be NULL at early VMStart\n-        java_lang_Thread::set_jvmti_thread_state(thread_oop_h(), state);\n+      if (thread_oop != NULL) { \/\/ thread_oop can be NULL at early VMStart\n+        java_lang_Thread::set_jvmti_thread_state(thread_oop, state);\n@@ -110,1 +109,1 @@\n-inline JvmtiThreadState* JvmtiThreadState::state_for(JavaThread *thread, oop thread_oop) {\n+inline JvmtiThreadState* JvmtiThreadState::state_for(JavaThread *thread, Handle thread_handle) {\n@@ -112,2 +111,2 @@\n-  JvmtiThreadState* state = thread_oop == NULL ? thread->jvmti_thread_state() :\n-                                                java_lang_Thread::jvmti_thread_state(thread_oop);\n+  JvmtiThreadState* state = thread_handle == NULL ? thread->jvmti_thread_state() :\n+                                                java_lang_Thread::jvmti_thread_state(thread_handle());\n@@ -115,3 +114,0 @@\n-    Thread* current_thread = Thread::current();\n-    HandleMark hm(current_thread);\n-    Handle h_thread_oop = Handle(current_thread, thread_oop);\n@@ -120,1 +116,1 @@\n-    state = state_for_while_locked(thread, h_thread_oop());\n+    state = state_for_while_locked(thread, thread_handle());\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"}]}