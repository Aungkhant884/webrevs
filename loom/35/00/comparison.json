{"files":[{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.loom;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(3)\n+@Warmup(iterations = 5, time = 10)\n+@Measurement(iterations = 10, time = 10)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+public class Skynet {\n+\n+    @Param({\"1000000\"})\n+    private int num;\n+\n+    static class Channel<T> {\n+        private final BlockingQueue<T> q;\n+\n+        Channel() {\n+            q = new SynchronousQueue<>();\n+        }\n+\n+        void send(T e) {\n+            boolean interrupted = false;\n+            while (true) {\n+                try {\n+                    q.put(e);\n+                    break;\n+                } catch (InterruptedException x) {\n+                    interrupted = true;\n+                }\n+            }\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n+        }\n+\n+        T receive() {\n+            boolean interrupted = false;\n+            T e;\n+            while (true) {\n+                try {\n+                    e = q.take();\n+                    break;\n+                } catch (InterruptedException x) {\n+                    interrupted = true;\n+                }\n+            }\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n+            return e;\n+        }\n+    }\n+\n+    static void skynet(Channel<Long> result, int num, int size, int div) {\n+        if (size == 1) {\n+            result.send((long)num);\n+        } else {\n+            var chan = new Channel<Long>();\n+            for (int i = 0; i < div; i++) {\n+                int subNum = num + i * (size \/ div);\n+                Thread.startVirtualThread(() -> skynet(chan, subNum, size \/ div, div));\n+            }\n+            long sum = 0;\n+            for (int i = 0; i < div; i++) {\n+                sum += chan.receive();\n+            }\n+            result.send(sum);\n+        }\n+    }\n+\n+    @Benchmark\n+    public long skynet() {\n+        var chan = new Channel<Long>();\n+        Thread.startVirtualThread(() -> skynet(chan, 0, num, 10));\n+        return chan.receive();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/Skynet.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.bench.loom;\n+package org.openjdk.bench.loom.obsolete;\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/obsolete\/ContVsThread.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/micro\/org\/openjdk\/bench\/loom\/ContVsThread.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.bench.loom;\n+package org.openjdk.bench.loom.obsolete;\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/obsolete\/Freeze.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/micro\/org\/openjdk\/bench\/loom\/Freeze.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.bench.loom;\n+package org.openjdk.bench.loom.obsolete;\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/obsolete\/FreezeAndThaw.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/micro\/org\/openjdk\/bench\/loom\/FreezeAndThaw.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.bench.loom;\n+package org.openjdk.bench.loom.obsolete;\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/obsolete\/OneShot.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/micro\/org\/openjdk\/bench\/loom\/OneShot.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.bench.loom;\n+package org.openjdk.bench.loom.obsolete;\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/obsolete\/Oscillation.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/micro\/org\/openjdk\/bench\/loom\/Oscillation.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.bench.loom;\n+package org.openjdk.bench.loom.obsolete;\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/obsolete\/Thaw.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/micro\/org\/openjdk\/bench\/loom\/Thaw.java","status":"renamed"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.loom.ring;\n+\n+public interface Channel<T> {\n+\n+    void send(T e);\n+\n+    T receive();\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/ring\/Channel.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,536 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.loom.ring;\n+\n+import java.util.Objects;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.stream.IntStream;\n+\n+public class Channels {\n+\n+    static class DirectChannel<T> implements Channel<T> {\n+        private final BlockingQueue<T> q;\n+\n+        DirectChannel(BlockingQueue<T> q) {\n+            this.q = q;\n+        }\n+\n+        @Override\n+        public void send(T e) {\n+            boolean interrupted = false;\n+            while (true) {\n+                try {\n+                    q.put(e);\n+                    break;\n+                } catch (InterruptedException x) {\n+                    interrupted = true;\n+                }\n+            }\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n+        }\n+\n+        @Override\n+        public T receive() {\n+            boolean interrupted = false;\n+            T e;\n+            while (true) {\n+                try {\n+                    e = q.take();\n+                    break;\n+                } catch (InterruptedException x) {\n+                    interrupted = true;\n+                }\n+            }\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n+            return e;\n+        }\n+    }\n+\n+    static abstract class AbstractStackChannel<T> implements Channel<T> {\n+        private final BlockingQueue<T> q;\n+\n+        protected AbstractStackChannel(BlockingQueue<T> q) {\n+            this.q = q;\n+        }\n+\n+        public void sendImpl(T e) {\n+            boolean interrupted = false;\n+            while (true) {\n+                try {\n+                    q.put(e);\n+                    break;\n+                } catch (InterruptedException x) {\n+                    interrupted = true;\n+                }\n+            }\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n+        }\n+\n+        public T receiveImpl() {\n+            boolean interrupted = false;\n+            T e;\n+            while (true) {\n+                try {\n+                    e = q.take();\n+                    break;\n+                } catch (InterruptedException x) {\n+                    interrupted = true;\n+                }\n+            }\n+            if (interrupted)\n+                Thread.currentThread().interrupt();\n+            return e;\n+        }\n+\n+    }\n+\n+    public static class ChannelFixedStackI1<T> extends AbstractStackChannel<T> {\n+        private final int depth;\n+        private T sendMsg;     \/\/ store data in heap, not on stack\n+        private T receiveMsg;\n+\n+        public ChannelFixedStackI1(BlockingQueue<T> q, int depth) {\n+            super(q);\n+            this.depth = depth;\n+        }\n+\n+        @Override\n+        public void send(T e) {\n+            sendMsg = e;\n+            recursiveSend(depth);\n+        }\n+\n+        @Override\n+        public T receive() {\n+            recursiveReceive(depth);\n+            return receiveMsg;\n+        }\n+\n+        private void recursiveSend(int depth) {\n+            if (depth == 0) {\n+                sendImpl(sendMsg);\n+            } else {\n+                recursiveSend(depth - 1);\n+            }\n+        }\n+\n+        private void recursiveReceive(int depth) {\n+            if (depth == 0) {\n+                receiveMsg = receiveImpl();\n+            } else {\n+                recursiveReceive(depth - 1);\n+            }\n+        }\n+    }\n+\n+    public static class ChannelFixedStackI2<T> extends AbstractStackChannel<T> {\n+        private final int depth;\n+        private int x2 = 42;\n+        private T sendMsg;     \/\/ store data in heap, not on stack\n+        private T receiveMsg;\n+\n+        public ChannelFixedStackI2(BlockingQueue<T> q, int depth) {\n+            super(q);\n+            this.depth = depth;\n+        }\n+\n+        @Override\n+        public void send(T e) {\n+            sendMsg = e;\n+            recursiveSend(depth, x2);\n+        }\n+\n+        @Override\n+        public T receive() {\n+            recursiveReceive(depth, x2);\n+            return receiveMsg;\n+        }\n+\n+        private void recursiveSend(int depth, int x2) {\n+            if (depth == 0) {\n+                sendImpl(sendMsg);\n+            } else {\n+                recursiveSend(depth - 1, x2 + 1);\n+            }\n+        }\n+\n+        private void recursiveReceive(int depth, int x2) {\n+            if (depth == 0) {\n+                receiveMsg = receiveImpl();\n+            } else {\n+                recursiveReceive(depth - 1, x2 + 1);\n+            }\n+        }\n+    }\n+\n+    public static class ChannelFixedStackI4<T> extends AbstractStackChannel<T> {\n+        private final int depth;\n+        private int x2 = 42;\n+        private int x3 = 43;\n+        private int x4 = 44;\n+        private T sendMsg;     \/\/ store data in heap, not on stack\n+        private T receiveMsg;\n+\n+        public ChannelFixedStackI4(BlockingQueue<T> q, int depth) {\n+            super(q);\n+            this.depth = depth;\n+        }\n+\n+        @Override\n+        public void send(T e) {\n+            sendMsg = e;\n+            recursiveSend(depth, x2, x3, x4);\n+        }\n+\n+        @Override\n+        public T receive() {\n+            recursiveReceive(depth, x2, x3, x4);\n+            return receiveMsg;\n+        }\n+\n+        private void recursiveSend(int depth, int x2, int x3, int x4) {\n+            if (depth == 0) {\n+                sendImpl(sendMsg);\n+            } else {\n+                recursiveSend(depth - 1, x2 + 1, x3 + 2, x4 + 3);\n+            }\n+        }\n+\n+        private void recursiveReceive(int depth, int x2, int x3, int x4) {\n+            if (depth == 0) {\n+                receiveMsg = receiveImpl();\n+            } else {\n+                recursiveReceive(depth - 1, x2 + 1, x3 + 2, x4 + 3);\n+            }\n+        }\n+    }\n+\n+    public static class ChannelFixedStackI8<T> extends AbstractStackChannel<T> {\n+        private final int depth;\n+        private int x2 = 42;\n+        private int x3 = 43;\n+        private int x4 = 44;\n+        private int x5 = 45;\n+        private int x6 = 46;\n+        private int x7 = 47;\n+        private int x8 = 48;\n+        private T sendMsg;     \/\/ store data in heap, not on stack\n+        private T receiveMsg;\n+\n+        public ChannelFixedStackI8(BlockingQueue<T> q, int depth) {\n+            super(q);\n+            this.depth = depth;\n+        }\n+\n+        @Override\n+        public void send(T e) {\n+            sendMsg = e;\n+            recursiveSend(depth, x2, x3, x4, x5, x6, x7, x8);\n+        }\n+\n+        @Override\n+        public T receive() {\n+            recursiveReceive(depth, x2, x3, x4, x5, x6, x7, x8);\n+            return receiveMsg;\n+        }\n+\n+        private void recursiveSend(int depth, int x2, int x3, int x4, int x5, int x6, int x7, int x8) {\n+            if (depth == 0) {\n+                sendImpl(sendMsg);\n+            } else {\n+                recursiveSend(depth - 1, x2 + 1, x3 + 2, x4 + 3, x5 + 4, x6 + 5, x7 + 6, x8 + 7);\n+            }\n+        }\n+\n+        private void recursiveReceive(int depth, int x2, int x3, int x4, int x5, int x6, int x7, int x8) {\n+            if (depth == 0) {\n+                receiveMsg = receiveImpl();\n+            } else {\n+                recursiveReceive(depth - 1, x2 + 1, x3 + 2, x4 + 3, x5 + 4, x6 + 5, x7 + 6, x8 + 7);\n+            }\n+        }\n+    }\n+\n+    public static class ChannelFixedStackR1<T> extends AbstractStackChannel<T> {\n+        private final int depth;\n+        private int x1;\n+\n+        public ChannelFixedStackR1(BlockingQueue<T> q, int depth, int start) {\n+            super(q);\n+            this.depth = depth;\n+            x1 = start + 1;\n+        }\n+\n+        @Override\n+        public void send(T e) {\n+            recursiveSend(depth, e, Ref.of(x1));\n+        }\n+\n+        @Override\n+        public T receive() {\n+            return recursiveReceive(depth, Ref.of(x1));\n+        }\n+\n+        private void recursiveSend(int depth, T msg, Ref x1) {\n+            if (depth == 0) {\n+                sendImpl(msg);\n+            } else {\n+                recursiveSend(depth - 1, msg, x1.inc());\n+            }\n+        }\n+\n+        private T recursiveReceive(int depth, Ref x1) {\n+            if (depth == 0) {\n+                return receiveImpl();\n+            } else {\n+                return recursiveReceive(depth - 1, x1.inc());\n+            }\n+        }\n+    }\n+\n+    public static class ChannelFixedStackR2<T> extends AbstractStackChannel<T> {\n+        private final int depth;\n+        private int x1;\n+        private int x2;\n+\n+        public ChannelFixedStackR2(BlockingQueue<T> q, int depth, int start) {\n+            super(q);\n+            this.depth = depth;\n+            x1 = start + 1;\n+            x2 = start + 2;\n+        }\n+\n+        @Override\n+        public void send(T e) {\n+            recursiveSend(depth, e, Ref.of(x1), Ref.of(x2));\n+        }\n+\n+        @Override\n+        public T receive() {\n+            return recursiveReceive(depth, Ref.of(x1), Ref.of(x2));\n+        }\n+\n+        private void recursiveSend(int depth, T msg, Ref x1, Ref x2) {\n+            if (depth == 0) {\n+                sendImpl(msg);\n+            } else {\n+                recursiveSend(depth - 1, msg, x1.inc(), x2.inc());\n+            }\n+        }\n+\n+        private T recursiveReceive(int depth, Ref x1, Ref x2) {\n+            if (depth == 0) {\n+                return receiveImpl();\n+            } else {\n+                return recursiveReceive(depth - 1, x1.inc(), x2.inc());\n+            }\n+        }\n+    }\n+\n+    public static class ChannelFixedStackR4<T> extends AbstractStackChannel<T> {\n+        private final int depth;\n+        private int x1;\n+        private int x2;\n+        private int x3;\n+        private int x4;\n+\n+        public ChannelFixedStackR4(BlockingQueue<T> q, int depth, int start) {\n+            super(q);\n+            this.depth = depth;\n+            x1 = start + 1;\n+            x2 = start + 2;\n+            x3 = start + 3;\n+            x4 = start + 4;\n+\n+        }\n+\n+        @Override\n+        public void send(T e) {\n+            recursiveSend(depth, e, Ref.of(x1), Ref.of(x2), Ref.of(x3), Ref.of(x4));\n+        }\n+\n+        @Override\n+        public T receive() {\n+            return recursiveReceive(depth, Ref.of(x1), Ref.of(x2), Ref.of(x3), Ref.of(x4));\n+        }\n+\n+        private void recursiveSend(int depth, T msg, Ref x1, Ref x2, Ref x3, Ref x4) {\n+            if (depth == 0) {\n+                sendImpl(msg);\n+            } else {\n+                recursiveSend(depth - 1, msg, x1.inc(), x2.inc(), x3.inc(), x4.inc());\n+            }\n+        }\n+\n+        private T recursiveReceive(int depth, Ref x1, Ref x2, Ref x3, Ref x4) {\n+            if (depth == 0) {\n+                return receiveImpl();\n+            } else {\n+                return recursiveReceive(depth - 1, x1.inc(), x2.inc(), x3.inc(), x4.inc());\n+            }\n+        }\n+    }\n+\n+    public static class ChannelFixedStackR8<T> extends AbstractStackChannel<T> {\n+        private final int depth;\n+        private int x1;\n+        private int x2;\n+        private int x3;\n+        private int x4;\n+        private int x5;\n+        private int x6;\n+        private int x7;\n+        private int x8;\n+\n+        public ChannelFixedStackR8(BlockingQueue<T> q, int depth, int start) {\n+            super(q);\n+            this.depth = depth;\n+            x1 = start + 1;\n+            x2 = start + 2;\n+            x3 = start + 3;\n+            x4 = start + 4;\n+            x5 = start + 5;\n+            x6 = start + 6;\n+            x7 = start + 7;\n+            x8 = start + 8;\n+        }\n+\n+        @Override\n+        public void send(T e) {\n+            recursiveSend(depth, e, Ref.of(x1), Ref.of(x2), Ref.of(x3), Ref.of(x4), Ref.of(x5), Ref.of(x6), Ref.of(x7), Ref.of(x8));\n+        }\n+\n+        @Override\n+        public T receive() {\n+            return recursiveReceive(depth, Ref.of(x1), Ref.of(x2), Ref.of(x3), Ref.of(x4), Ref.of(x5), Ref.of(x6), Ref.of(x7), Ref.of(x8));\n+        }\n+\n+        private void recursiveSend(int depth, T msg, Ref x1, Ref x2, Ref x3, Ref x4, Ref x5, Ref x6, Ref x7, Ref x8) {\n+            if (depth == 0) {\n+                sendImpl(msg);\n+            } else {\n+                recursiveSend(depth - 1, msg, x1.inc(), x2.inc(), x3.inc(), x4.inc(), x5.inc(), x6.inc(), x7.inc(), x8.inc());\n+            }\n+        }\n+\n+        private T recursiveReceive(int depth, Ref x1, Ref x2, Ref x3, Ref x4, Ref x5, Ref x6, Ref x7, Ref x8) {\n+            if (depth == 0) {\n+                return receiveImpl();\n+            } else {\n+                return recursiveReceive(depth - 1, x1.inc(), x2.inc(), x3.inc(), x4.inc(), x5.inc(), x6.inc(), x7.inc(), x8.inc());\n+            }\n+        }\n+    }\n+\n+\n+\n+    static class Ref {\n+        private final int v;\n+\n+        Ref(int v) {\n+            this.v = v;\n+        }\n+\n+        public static Ref of(int v) {\n+            return ((v >= 0) && (v < CACHE_MAX)) ? cache[v] : new Ref(v);\n+        }\n+\n+        private static final int CACHE_MAX = 1024*2;\n+        private static final Ref[] cache = IntStream.range(0, CACHE_MAX).mapToObj(Ref::new).toArray(Ref[]::new);\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (!(o instanceof Ref)) return false;\n+            Ref ref = (Ref) o;\n+            return v == ref.v;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(v);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Ref{\" +\n+                    \"v=\" + v +\n+                    '}';\n+        }\n+\n+        public Ref inc() {\n+            return of(v + 1);\n+        }\n+    }\n+\n+\/\/    static class Ref {\n+\/\/        private final int v;\n+\/\/\n+\/\/        Ref(int v) {\n+\/\/            this.v = v;\n+\/\/        }\n+\/\/\n+\/\/        public static Ref of(int v) {\n+\/\/            return getRef(new Ref(v));\n+\/\/        }\n+\/\/\n+\/\/        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+\/\/        private static Ref getRef(Ref x) {\n+\/\/            Ref y = cache.get(x);\n+\/\/            return y == null ? x : y;\n+\/\/        }\n+\/\/\n+\/\/        private static final int CACHE_MAX = 1024*2;\n+\/\/\n+\/\/        private static final Map<Ref, Ref> cache = IntStream.range(0, CACHE_MAX).mapToObj(Ref::new).collect(Collectors.toMap( k -> k, v-> v));\n+\/\/\n+\/\/        @Override\n+\/\/        public boolean equals(Object o) {\n+\/\/            if (this == o) return true;\n+\/\/            if (!(o instanceof Ref)) return false;\n+\/\/            Ref ref = (Ref) o;\n+\/\/            return v == ref.v;\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public int hashCode() {\n+\/\/            return Objects.hash(v);\n+\/\/        }\n+\/\/\n+\/\/        @Override\n+\/\/        public String toString() {\n+\/\/            return \"Ref{\" +\n+\/\/                    \"v=\" + v +\n+\/\/                    '}';\n+\/\/        }\n+\/\/\n+\/\/        public Ref inc() {\n+\/\/            return of(v + 1);\n+\/\/        }\n+\/\/    }\n+\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/ring\/Channels.java","additions":536,"deletions":0,"binary":false,"changes":536,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.loom.ring;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Predicate;\n+\n+@Fork(3)\n+@Warmup(iterations = 20, time = 1)\n+@Measurement(iterations = 20, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Thread)\n+public class Ring {\n+\n+    public static class Worker<T> implements Runnable {\n+        private final Channel<T> source;\n+        private final Channel<T> sink;\n+        private final Predicate<T> finisher;\n+\n+        public Worker(Channel<T> source, Channel<T> sink, Predicate<T> finisher) {\n+            this.source = source;\n+            this.sink = sink;\n+            this.finisher = finisher;\n+        }\n+\n+        @Override\n+        public void run() {\n+            boolean endOfWork = false;\n+            do {\n+                T msg = source.receive();\n+                endOfWork = finisher.test(msg);\n+                sink.send(msg);\n+            } while (!endOfWork);\n+        }\n+    }\n+\n+    @Param({\"1000\"})\n+    int threads;\n+\n+    \/\/    @Param({\"lbq\", \"abq\", \"sq\"})\n+    @Param({\"sq\"})\n+    public String queue;\n+\n+    @Param({\"1\", \"4\", \"16\", \"64\", \"256\"})\n+    public int stackDepth;\n+\n+    @Param({\"1\", \"4\", \"8\"})\n+    public int stackFrame;\n+\n+    @Param({\"true\", \"false\"})\n+    public boolean allocalot;\n+\n+    @Param({\"true\", \"false\"})\n+    public boolean singleshot;\n+\n+\n+    @Setup\n+    @SuppressWarnings(\"unchecked\")\n+    public void setup() {\n+        msg = 42;\n+        Channel<Integer>[] chans = new Channel[threads + 1];\n+        for (int i = 0; i < chans.length; i++) {\n+            chans[i] = getChannel();\n+        }\n+        head = chans[0];\n+        tail = chans[chans.length - 1];\n+        Predicate<Integer> finalCondition = singleshot ? (x -> true) : (x -> (x < 0));\n+        workers = new Worker[chans.length - 1];\n+        for (int i = 0; i < chans.length - 1; i++) {\n+            workers[i] = new Worker<>(chans[i], chans[i+1], finalCondition);\n+        }\n+        if(!singleshot) {\n+            startAll();\n+        }\n+    }\n+\n+    private void startAll() {\n+        for (Worker<Integer> w : workers) {\n+            Thread.startVirtualThread(w);\n+        }\n+    }\n+\n+    Worker<Integer>[] workers;\n+    Channel<Integer> head;\n+    Channel<Integer> tail;\n+    Integer msg;\n+\n+    @TearDown\n+    public void tearDown() {\n+        if(!singleshot) {\n+            head.send(-1);\n+            tail.receive();\n+        }\n+    }\n+\n+    @Benchmark\n+    public Object trip(){\n+        if(singleshot) {\n+            startAll();\n+        }\n+        head.send(msg);\n+        return tail.receive();\n+    }\n+\n+    public static <T> BlockingQueue<T> getQueue(String queue) {\n+        switch (queue) {\n+            case \"lbq\":\n+                return new LinkedBlockingQueue<>();\n+            case \"abq\":\n+                return new ArrayBlockingQueue<>(1);\n+            case \"sq\":\n+                return new SynchronousQueue<>();\n+        }\n+        return null;\n+    }\n+\n+    Channel<Integer> getChannel() {\n+        return switch(stackFrame) {\n+            case 1 -> new Channels.ChannelFixedStackR1<>(getQueue(queue), stackDepth, allocalot ? 4242 : 0);\n+            case 2 -> new Channels.ChannelFixedStackR2<>(getQueue(queue), stackDepth, allocalot ? 4242 : 0);\n+            case 4 -> new Channels.ChannelFixedStackR4<>(getQueue(queue), stackDepth, allocalot ? 4242 : 0);\n+            case 8 -> new Channels.ChannelFixedStackR8<>(getQueue(queue), stackDepth, allocalot ? 4242 : 0);\n+            default -> throw new RuntimeException(\"Illegal stack parameter value: \"+ stackFrame +\" (allowed: 1,2,4,8)\");\n+        };\n+\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/loom\/ring\/Ring.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}