{"files":[{"patch":"@@ -143,0 +143,1 @@\n+  LOG_TAG(preempt) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -889,0 +889,9 @@\n+const char* freeze_result_names[6] = {\n+  \"freeze_ok\",\n+  \"freeze_ok_bottom\",\n+  \"freeze_pinned_cs\",\n+  \"freeze_pinned_native\",\n+  \"freeze_pinned_monitor\",\n+  \"freeze_exception\"\n+};\n+\n@@ -1260,1 +1269,1 @@\n-  \n+\n@@ -2044,1 +2053,14 @@\n-typedef int (*DoYieldStub)(int scopes);\n+static void print_stack_trace(JavaThread* thread) {\n+  if (log_is_enabled(Trace, jvmcont, preempt)) {\n+    LogTarget(Trace, jvmcont, preempt) lt;\n+    assert(lt.is_enabled(), \"already tested\");\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    char buf[256];\n+    ls.print_cr(\"Java frames: (J=compiled Java code, j=interpreted, Vv=VM code)\");\n+    for (StackFrameStream sfs(thread, true \/* update *\/, true \/* process_frames *\/); !sfs.is_done(); sfs.next()) {\n+      sfs.current()->print_on_error(&ls, buf, 256, false);\n+      ls.cr();\n+    }\n+  }\n+}\n@@ -2047,4 +2069,0 @@\n-  \/\/ if (Thread::current()->is_VM_thread() && thread->thread_state() == _thread_blocked) {\n-  \/\/   log_develop_trace(jvmcont)(\"is_safe_to_preempt: thread blocked\");\n-  \/\/   return false;\n-  \/\/ }\n@@ -2053,1 +2071,1 @@\n-    log_develop_trace(jvmcont)(\"is_safe_to_preempt: no last Java frame\");\n+    log_trace(jvmcont, preempt)(\"is_safe_to_preempt: no last Java frame\");\n@@ -2057,1 +2075,5 @@\n-  if (log_develop_is_enabled(Trace, jvmcont)) {\n+  if (log_is_enabled(Trace, jvmcont, preempt)) {\n+    LogTarget(Trace, jvmcont, preempt) lt;\n+    assert(lt.is_enabled(), \"already tested\");\n+    ResourceMark rm;\n+    LogStream ls(lt);\n@@ -2059,2 +2081,2 @@\n-    log_develop_trace(jvmcont)(\"is_safe_to_preempt %sSAFEPOINT\", Interpreter::contains(f.pc()) ? \"INTERPRETER \" : \"\");\n-    f.print_on(tty);\n+    ls.print(\"is_safe_to_preempt %sSAFEPOINT \", Interpreter::contains(f.pc()) ? \"INTERPRETER \" : \"\");\n+    f.print_on(&ls);\n@@ -2068,1 +2090,0 @@\n-      if (log_develop_is_enabled(Trace, jvmcont)) codelet->print_on(tty);\n@@ -2071,1 +2092,2 @@\n-        log_develop_trace(jvmcont)(\"is_safe_to_preempt: safe bytecode: %s\", Bytecodes::name(codelet->bytecode()));\n+        log_trace(jvmcont, preempt)(\"is_safe_to_preempt: safe bytecode: %s\",\n+                                    Bytecodes::name(codelet->bytecode()));\n@@ -2075,1 +2097,1 @@\n-        log_develop_trace(jvmcont)(\"is_safe_to_preempt: safepoint entry: %s\", codelet->description());\n+        log_trace(jvmcont, preempt)(\"is_safe_to_preempt: safepoint entry: %s\", codelet->description());\n@@ -2078,1 +2100,2 @@\n-        log_develop_trace(jvmcont)(\"is_safe_to_preempt: %s (unsafe)\", codelet->description());\n+        log_trace(jvmcont, preempt)(\"is_safe_to_preempt: %s (unsafe)\", codelet->description());\n+        print_stack_trace(thread);\n@@ -2082,1 +2105,1 @@\n-      log_develop_trace(jvmcont)(\"is_safe_to_preempt: no codelet (safe?)\");\n+      log_trace(jvmcont, preempt)(\"is_safe_to_preempt: no codelet (safe?)\");\n@@ -2088,1 +2111,1 @@\n-      log_develop_trace(jvmcont)(\"is_safe_to_preempt: safepoint stub\");\n+      log_trace(jvmcont, preempt)(\"is_safe_to_preempt: safepoint stub\");\n@@ -2091,1 +2114,1 @@\n-      log_develop_trace(jvmcont)(\"is_safe_to_preempt: not safepoint stub\");\n+      log_trace(jvmcont, preempt)(\"is_safe_to_preempt: not safepoint stub\");\n@@ -2097,3 +2120,5 @@\n-\/\/ called in a safepoint\n-int Continuation::try_force_yield(JavaThread* thread, const oop cont) {\n-  log_develop_trace(jvmcont)(\"try_force_yield: thread state: %s VM thread: %d\", thread->thread_state_name(), Thread::current()->is_VM_thread());\n+\/\/ Called while the thread is blocked by the JavaThread caller, might not be completely in blocked state.\n+\/\/ May still be in thread_in_vm getting to the blocked state.  I don't think we care that much since\n+\/\/ the only frames we're looking at are Java frames.\n+int Continuation::try_force_yield(JavaThread* target, const oop cont) {\n+  log_trace(jvmcont, preempt)(\"try_force_yield: thread state: %s\", target->thread_state_name());\n@@ -2101,1 +2126,1 @@\n-  ContinuationEntry* ce = thread->last_continuation();\n+  ContinuationEntry* ce = target->last_continuation();\n@@ -2109,1 +2134,1 @@\n-  if (thread->_cont_yield) {\n+  if (target->_cont_yield) {\n@@ -2112,1 +2137,1 @@\n-  if (!is_safe_to_preempt(thread)) {\n+  if (!is_safe_to_preempt(target)) {\n@@ -2116,1 +2141,1 @@\n-  assert (thread->has_last_Java_frame(), \"\");\n+  assert (target->has_last_Java_frame(), \"\");\n@@ -2118,1 +2143,3 @@\n-  assert (!Interpreter::contains(thread->last_Java_pc()) || !thread->cont_fastpath(), \"fast_path at codelet %s\", Interpreter::codelet_containing(thread->last_Java_pc())->description());\n+  assert (!Interpreter::contains(target->last_Java_pc()) || !target->cont_fastpath(),\n+          \"fast_path at codelet %s\",\n+          Interpreter::codelet_containing(target->last_Java_pc())->description());\n@@ -2123,2 +2150,3 @@\n-    freeze_result res_pinned = is_pinned0(thread, scope, true);\n-    if (res_pinned != freeze_ok)\n+    freeze_result res_pinned = is_pinned0(target, scope, true);\n+    if (res_pinned != freeze_ok) {\n+      log_trace(jvmcont, preempt)(\"try_force_yield: res_pinned\");\n@@ -2126,1 +2154,1 @@\n-\n+    }\n@@ -2130,4 +2158,3 @@\n-  \/\/ TODO: save return value\n-\n-  assert (thread->has_last_Java_frame(), \"\");\n-  int res = cont_freeze(thread, thread->last_Java_sp(), true); \/\/ CAST_TO_FN_PTR(DoYieldStub, StubRoutines::cont_doYield_C())(-1);\n+  assert (target->has_last_Java_frame(), \"need to test again?\");\n+  int res = cont_freeze(target, target->last_Java_sp(), true);\n+  log_trace(jvmcont, preempt)(\"try_force_yield: %s\", freeze_result_names[res]);\n@@ -2135,1 +2162,1 @@\n-    thread->set_cont_preempt(true);\n+    target->set_cont_preempt(true);\n@@ -2137,5 +2164,3 @@\n-    \/\/ frame last = thread->last_frame();\n-    \/\/ Frame::patch_pc(last, StubRoutines::cont_jump_from_sp()); \/\/ reinstates rbpc and rlocals for the sake of the interpreter\n-    \/\/ log_develop_trace(jvmcont)(\"try_force_yield installed cont_jump_from_sp stub on\"); if (log_develop_is_enabled(Trace, jvmcont)) last.print_on(tty);\n-\n-    \/\/ this return barrier is used for compiled frames; for interpreted frames we use the call to StubRoutines::cont_jump_from_sp_C in JavaThread::handle_special_runtime_exit_condition\n+    \/\/ The target thread calls\n+    \/\/ StubRoutines::cont_jump_from_sp_C from JavaThread::handle_special_runtime_exit_condition\n+    \/\/ to yield on return from suspension\/blocking handshake.\n@@ -2145,0 +2170,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":64,"deletions":38,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-* @run testng\/othervm\/timeout=60 -Xint Preempt\n+* @run testng\/othervm\/timeout=60 -Xlog:jvmcont+preempt=trace -Xint Preempt\n@@ -31,1 +31,1 @@\n-* @run testng\/othervm -XX:-UseTLAB -Xint Preempt\n+* @run testng\/othervm -Xlog:jvmcont+preempt=trace -XX:-UseTLAB -Xint Preempt\n@@ -74,0 +74,1 @@\n+                        Thread.sleep(10);\n@@ -84,0 +85,1 @@\n+                        Thread.sleep(10);\n","filename":"test\/jdk\/java\/lang\/Continuation\/Preempt.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}