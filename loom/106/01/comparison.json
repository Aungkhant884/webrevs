{"files":[{"patch":"@@ -120,1 +120,3 @@\n-    ? frame(sender_sp, sender_sp, *link_addr, sender_pc, sender_cb, slot == -1 ? nullptr : sender_cb->oop_map_for_slot(slot, sender_pc))\n+    ? frame(sender_sp, sender_sp, *link_addr, sender_pc, sender_cb,\n+            slot == -1 ? nullptr : sender_cb->oop_map_for_slot(slot, sender_pc),\n+            false \/* on_heap ? *\/)\n@@ -190,1 +192,1 @@\n-    frame hf(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* relative *\/);\n+    frame hf(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n@@ -205,1 +207,1 @@\n-    return frame(sp, sp, fp, f.pc(), nullptr, nullptr, false);\n+    return frame(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n@@ -290,1 +292,1 @@\n-    return frame(vsp, vsp, fp, hf.pc(), hf.cb(), hf.oop_map()); \/\/ TODO PERF : this computes deopt state; is it necessary?\n+    return frame(vsp, vsp, fp, hf.pc(), hf.cb(), hf.oop_map(), false); \/\/ TODO PERF : this computes deopt state; is it necessary?\n","filename":"src\/hotspot\/cpu\/aarch64\/continuation_aarch64.inline.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -152,3 +152,1 @@\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map);\n-\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool dummy); \/\/ used for fast frame construction by continuations\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool on_heap); \/\/ used for fast frame construction by continuations\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -64,1 +64,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -106,1 +106,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -111,15 +111,1 @@\n-inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map) {\n-  _sp = sp;\n-  _unextended_sp = unextended_sp;\n-  _fp = fp;\n-  _pc = pc;\n-  assert(pc != NULL, \"no pc?\");\n-  _cb = cb;\n-  _oop_map = oop_map;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT, p2i(pc));\n-  _pointers = addressing::ABSOLUTE;\n-\n-  setup(pc);\n-}\n-\n-inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool relative) {\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool on_heap) {\n@@ -134,5 +120,3 @@\n-  _pointers = relative ? addressing::RELATIVE : addressing::ABSOLUTE;\n-  assert(relative || !is_interpreted_frame(), \"these interpreter frames are heap frames\");\n-#ifdef ASSERT\n-  \/\/ The following assertion has been disabled because it would sometime trap for Continuation.run, which is not *in* a continuation\n-  \/\/ and therefore does not clear the _cont_fastpath flag, but this is benign even in fast mode (see Freeze::setup_jump)\n+  _on_heap = on_heap;\n+  \/\/ In thaw, non-heap frames use this constructor to pass oop_map.  I don't know why.\n+  assert(_on_heap || _cb != nullptr, \"these frames are always heap frames\");\n@@ -141,1 +125,0 @@\n-    assert(_pc == pc && _deopt_state == not_deoptimized, \"\");\n@@ -143,0 +126,6 @@\n+#ifdef ASSERT\n+  \/\/ The following assertion has been disabled because it would sometime trap for Continuation.run,\n+  \/\/ which is not *in* a continuation and therefore does not clear the _cont_fastpath flag, but this\n+  \/\/ is benign even in fast mode (see Freeze::setup_jump)\n+  \/\/ We might freeze deoptimized frame in slow mode\n+  \/\/ assert(_pc == pc && _deopt_state == not_deoptimized, \"\");\n@@ -156,1 +145,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -193,1 +182,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  *la = f._pointers == frame::addressing::RELATIVE ? (intptr_t)(sp - f.fp()) : (intptr_t)sp;\n+  *la = f.is_heap_frame() ? (intptr_t)(sp - f.fp()) : (intptr_t)sp;\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_helpers_aarch64.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,4 +48,5 @@\n-  if (is_done()) return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n-  return frame_kind == chunk_frames::MIXED && !is_interpreted()\n-    ? frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap) \/\/ we might freeze deoptimized frame in slow mode\n-    : frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n+  if (is_done()) {\n+    return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n+  } else {\n+    return frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/instanceStackChunkKlass_aarch64.inline.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -65,1 +65,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -90,1 +90,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -111,1 +111,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -391,1 +391,1 @@\n-                                             _pointers(addressing::ABSOLUTE),\n+                                             _on_heap(false),\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,2 +58,1 @@\n-inline frame::frame() : _sp(NULL), _pc(NULL), _cb(NULL),  _deopt_state(unknown),\n-                        _pointers(addressing::ABSOLUTE),\n+inline frame::frame() : _sp(NULL), _pc(NULL), _cb(NULL),  _deopt_state(unknown), _on_heap(false),\n@@ -62,1 +61,1 @@\n-inline frame::frame(intptr_t* sp) : _sp(sp),  _pointers(addressing::ABSOLUTE), _unextended_sp(sp) {\n+inline frame::frame(intptr_t* sp) : _sp(sp), _on_heap(false), _unextended_sp(sp) {\n@@ -66,1 +65,1 @@\n-inline frame::frame(intptr_t* sp, address pc) : _sp(sp), _pointers(addressing::ABSOLUTE), _unextended_sp(sp) {\n+inline frame::frame(intptr_t* sp, address pc) : _sp(sp), _on_heap(false), _unextended_sp(sp) {\n@@ -70,2 +69,1 @@\n-inline frame::frame(intptr_t* sp, address pc, intptr_t* unextended_sp) : _sp(sp),\n-                    _pointers(addressing::ABSOLUTE),\n+inline frame::frame(intptr_t* sp, address pc, intptr_t* unextended_sp) : _sp(sp), _on_heap(false),\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,2 +57,1 @@\n-inline frame::frame() : _sp(NULL), _pc(NULL), _cb(NULL), _deopt_state(unknown),\n-                        _pointers(addressing::ABSOLUTE),\n+inline frame::frame() : _sp(NULL), _pc(NULL), _cb(NULL), _deopt_state(unknown), _on_heap(false),\n@@ -61,1 +60,1 @@\n-inline frame::frame(intptr_t* sp) : _sp(sp), _pointers(addressing::ABSOLUTE), _unextended_sp(sp) {\n+inline frame::frame(intptr_t* sp) : _sp(sp), _on_heap(false), _unextended_sp(sp) {\n@@ -65,1 +64,1 @@\n-inline frame::frame(intptr_t* sp, address pc) : _sp(sp), _pointers(addressing::ABSOLUTE), _unextended_sp(sp) {\n+inline frame::frame(intptr_t* sp, address pc) : _sp(sp), _on_heap(false), _unextended_sp(sp) {\n@@ -69,2 +68,1 @@\n-inline frame::frame(intptr_t* sp, address pc, intptr_t* unextended_sp) : _sp(sp),\n-                                                                         _pointers(addressing::ABSOLUTE),\n+inline frame::frame(intptr_t* sp, address pc, intptr_t* unextended_sp) : _sp(sp), _on_heap(false),\n@@ -78,2 +76,1 @@\n-  _sp((intptr_t*)sp), _pc(NULL), _cb(NULL),\n-   _pointers(addressing::ABSOLUTE),\n+  _sp((intptr_t*)sp), _pc(NULL), _cb(NULL), _on_heap(false),\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -120,1 +120,2 @@\n-    ? frame(sender_sp, sender_sp, *link_addr, sender_pc, sender_cb, slot == -1 ? nullptr : sender_cb->oop_map_for_slot(slot, sender_pc))\n+    ? frame(sender_sp, sender_sp, *link_addr, sender_pc, sender_cb,\n+            slot == -1 ? nullptr : sender_cb->oop_map_for_slot(slot, sender_pc), false)\n@@ -188,1 +189,1 @@\n-    frame hf(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* relative *\/);\n+    frame hf(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n@@ -203,1 +204,1 @@\n-    return frame(sp, sp, fp, f.pc(), nullptr, nullptr, false);\n+    return frame(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n@@ -281,1 +282,1 @@\n-    return frame(vsp, vsp, fp, hf.pc(), hf.cb(), hf.oop_map()); \/\/ TODO PERF : this computes deopt state; is it necessary?\n+    return frame(vsp, vsp, fp, hf.pc(), hf.cb(), hf.oop_map(), false); \/\/ TODO PERF : this computes deopt state; is it necessary?\n","filename":"src\/hotspot\/cpu\/x86\/continuation_x86.inline.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-  *la = f._pointers == frame::addressing::RELATIVE ? (intptr_t)(sp - f.fp()) : (intptr_t)sp;\n+  *la = f.is_heap_frame() ? (intptr_t)(sp - f.fp()) : (intptr_t)sp;\n","filename":"src\/hotspot\/cpu\/x86\/frame_helpers_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -665,1 +665,1 @@\n-  tty->print_cr(\"address::%s\", _pointers == addressing::RELATIVE ? \"relative\" : \"absolute\");\n+  tty->print_cr(\"address::%s\", is_heap_frame() ? \"heap_frame\" : \"stack_frame\");\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -143,3 +143,1 @@\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map);\n-\n-  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool relative); \/\/ used for fast frame construction by continuations\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool relative); \/\/ used for heap frame construction by continuations\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -63,1 +63,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -97,1 +97,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -102,15 +102,2 @@\n-inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map) {\n-  _sp = sp;\n-  _unextended_sp = unextended_sp;\n-  _fp = fp;\n-  _pc = pc;\n-  assert(pc != NULL, \"no pc?\");\n-  _cb = cb;\n-  _oop_map = oop_map;\n-  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT, p2i(pc));\n-  _pointers = addressing::ABSOLUTE;\n-\n-  setup(pc);\n-}\n-\n-inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool relative) {\n+inline frame::frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb,\n+                    const ImmutableOopMap* oop_map, bool on_heap) {\n@@ -124,5 +111,3 @@\n-  _pointers = relative ? addressing::RELATIVE : addressing::ABSOLUTE;\n-  assert(relative || !is_interpreted_frame(), \"these interpreter frames are heap frames\");\n-#ifdef ASSERT\n-  \/\/ The following assertion has been disabled because it would sometime trap for Continuation.run, which is not *in* a continuation\n-  \/\/ and therefore does not clear the _cont_fastpath flag, but this is benign even in fast mode (see Freeze::setup_jump)\n+  _on_heap = on_heap;\n+  \/\/ In thaw, non-heap frames use this constructor to pass oop_map.  I don't know why.\n+  assert(_on_heap || _cb != nullptr, \"these frames are always heap frames\");\n@@ -131,1 +116,0 @@\n-    assert(_pc == pc && _deopt_state == not_deoptimized, \"\");\n@@ -133,0 +117,6 @@\n+#ifdef ASSERT\n+  \/\/ The following assertion has been disabled because it would sometime trap for Continuation.run,\n+  \/\/ which is not *in* a continuation and therefore does not clear the _cont_fastpath flag, but this\n+  \/\/ is benign even in fast mode (see Freeze::setup_jump)\n+  \/\/ We might freeze deoptimized frame in slow mode\n+  \/\/ assert(_pc == pc && _deopt_state == not_deoptimized, \"\");\n@@ -145,1 +135,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -157,1 +147,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":16,"deletions":26,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -48,4 +48,5 @@\n-  if (is_done()) return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n-  return frame_kind == chunk_frames::MIXED && !is_interpreted()\n-    ? frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap) \/\/ we might freeze deoptimized frame in slow mode\n-    : frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n+  if (is_done()) {\n+    return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n+  } else {\n+    return frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/instanceStackChunkKlass_x86.inline.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n@@ -51,1 +51,1 @@\n-  _pointers = addressing::ABSOLUTE;\n+  _on_heap = false;\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,1 +204,1 @@\n-  assert(heap_frame.is_interpreted_heap_frame(), \"must be\");\n+  assert(heap_frame.is_heap_frame(), \"must be\");\n@@ -210,1 +210,1 @@\n-  assert(heap_frame.is_interpreted_heap_frame(), \"must be\");\n+  assert(heap_frame.is_heap_frame(), \"must be\");\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1436,1 +1436,1 @@\n-      assert(hf.is_interpreted_heap_frame(), \"should be\");\n+      assert(hf.is_heap_frame(), \"should be\");\n@@ -1566,1 +1566,1 @@\n-      assert(caller.is_interpreted_heap_frame(), \"should be\");\n+      assert(caller.is_heap_frame(), \"should be\");\n@@ -1595,1 +1595,1 @@\n-      assert(hf.is_interpreted_heap_frame(), \"should be\");\n+      assert(hf.is_heap_frame(), \"should be\");\n@@ -1767,1 +1767,1 @@\n-      assert(top.is_interpreted_heap_frame(), \"should be\");\n+      assert(top.is_heap_frame(), \"should be\");\n@@ -1790,1 +1790,1 @@\n-      assert(_cont.last_frame().is_interpreted_heap_frame(), \"should be\");\n+      assert(_cont.last_frame().is_heap_frame(), \"should be\");\n@@ -2460,1 +2460,1 @@\n-      assert(hf.is_interpreted_heap_frame(), \"should have created a relative frame\");\n+      assert(hf.is_heap_frame(), \"should have created a relative frame\");\n@@ -2572,1 +2572,1 @@\n-      assert(hf.is_interpreted_heap_frame(), \"should be\");\n+      assert(hf.is_heap_frame(), \"should be\");\n@@ -2628,1 +2628,1 @@\n-    assert(hf.is_interpreted_heap_frame(), \"should be\");\n+    assert(hf.is_heap_frame(), \"should be\");\n@@ -2638,2 +2638,2 @@\n-    assert(hf.is_interpreted_heap_frame(), \"should be\");\n-    assert(!f.is_interpreted_heap_frame(), \"should not be\");\n+    assert(hf.is_heap_frame(), \"should be\");\n+    assert(!f.is_heap_frame(), \"should not be\");\n@@ -2668,1 +2668,1 @@\n-      assert(hf.is_interpreted_heap_frame(), \"should be\");\n+      assert(hf.is_heap_frame(), \"should be\");\n@@ -2819,1 +2819,1 @@\n-      assert(_cont.last_frame().is_interpreted_heap_frame(), \"should be\");\n+      assert(_cont.last_frame().is_heap_frame(), \"should be\");\n@@ -3085,3 +3085,3 @@\n-  RegisterMap map(f._pointers == frame::addressing::RELATIVE ?\n-                     (JavaThread*)nullptr :\n-                     JavaThread::current(), true, false, false);\n+  RegisterMap map(f.is_heap_frame() ?\n+                  (JavaThread*)nullptr :\n+                  JavaThread::current(), true, false, false);\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -465,2 +465,1 @@\n-  intptr_t* first = _pointers == addressing::RELATIVE\n-                             ? fp() + (intptr_t)*interpreter_frame_locals_addr()\n+  intptr_t* first = _on_heap ? fp() + (intptr_t)*interpreter_frame_locals_addr()\n@@ -1628,1 +1627,1 @@\n-  print_on(st, min_index, max_index, v0, v1, frame::addressing::RELATIVE);\n+  print_on(st, min_index, max_index, v0, v1, true \/* on_heap *\/);\n@@ -1631,1 +1630,1 @@\n-void FrameValues::print_on(outputStream* st, int min_index, int max_index, intptr_t* v0, intptr_t* v1, frame::addressing pointers) {\n+void FrameValues::print_on(outputStream* st, int min_index, int max_index, intptr_t* v0, intptr_t* v1, bool on_heap) {\n@@ -1646,1 +1645,1 @@\n-      if (pointers == frame::addressing::RELATIVE\n+      if (on_heap\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,4 +39,0 @@\n-\/\/ defined in wingdi.h\n-#undef ABSOLUTE\n-#undef RELATIVE\n-\n@@ -88,6 +84,4 @@\n- public:\n-  \/\/ Do internal pointers in interpreter frames use absolute adddresses or relative (to fp)\n-  \/\/ Interpreter frames in stack chunks use relative addressing; on the stack they use absolute addressing\n-  enum class addressing { ABSOLUTE, RELATIVE };\n-\n-  addressing _pointers;\n+  \/\/ Do internal pointers in interpreter frames use absolute adddresses or relative (to fp)?\n+  \/\/ Frames in stack chunks are on the Java heap and use relative addressing; on the stack\n+  \/\/ they use absolute addressing\n+  bool        _on_heap;  \/\/ This frame represents a frame on the heap.\n@@ -95,0 +89,1 @@\n+ public:\n@@ -124,2 +119,0 @@\n-  bool has_relative_pointers() const { return _pointers == addressing::RELATIVE; }\n-\n@@ -192,1 +185,1 @@\n-  bool is_interpreted_heap_frame() const { return is_interpreted_frame() && _pointers == addressing::RELATIVE; }\n+  bool is_heap_frame()             const { return _on_heap; }\n@@ -253,1 +246,1 @@\n-  \/\/ in interpreter frames in continuation stacks, internal addresses are relative to fp.\n+  \/\/ Interpreter frames in continuation stacks are on the heap, and internal addresses are relative to fp.\n@@ -257,1 +250,1 @@\n-    return _pointers == addressing::RELATIVE ? at_relative(index) : at_absolute(index);\n+    return _on_heap ? at_relative(index) : at_absolute(index);\n@@ -528,1 +521,1 @@\n-                frame::addressing pointers = frame::addressing::ABSOLUTE);\n+                bool on_heap = false);\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"}]}