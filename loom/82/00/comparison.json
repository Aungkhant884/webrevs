{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n@@ -33,0 +34,3 @@\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -72,1 +76,1 @@\n- *   ScopeLocal.where(CREDENTIALS, creds).run(creds, () -> {\n+ *   ScopeLocal.where(CREDENTIALS, creds).run(() -> {\n@@ -84,0 +88,15 @@\n+ * As an alternative to the lambda expression form used above, {@link ScopeLocal} also supports\n+ * a <i>try-with-resources<\/i> form, which looks like this:\n+ * <pre>{@code}\n+ *   try (var unused = ScopeLocal.where(CREDENTIALS, creds).bind()) {\n+ *       :\n+ *       Connection connection = connectDatabase();\n+ *       :\n+ *    }\n+ * }<\/pre>\n+ *\n+ * Note, however, that this version is <i>insecure<\/i>: it is up to the application programmer\n+ * to make sure that bindings are closed at the right time. While a <i>try-with-resources<\/i>\n+ * statement is enough to guarantee this, there is no way to enforce the requirement that this form\n+ * is only used in a <i>try-with-resources<\/i> statement.\n+ * <p>Also, it is not possible to re-bind an already-bound {@link ScopeLocal} with this <i>try-with-resources<\/i> binding.<\/p>\n@@ -91,0 +110,2 @@\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n@@ -118,0 +139,3 @@\n+                    if (b.getClass() != Snapshot.class) {\n+                        return b.find(key);\n+                    }\n@@ -183,1 +207,1 @@\n-         * @return TBD\n+         * @return A new map, consisting of {@code this}. plus a new binding. {@code this} is unchanged.\n@@ -245,4 +269,0 @@\n-            Throwable ex = null;\n-            R result = null;\n-            var scope = new StackableScope().push();\n-            boolean atTop;\n@@ -250,3 +270,4 @@\n-                result = op.call();\n-            } catch (Throwable e) {\n-                ex = e;\n+                return StackableScope.call(op);\n+            } catch (Throwable t) {\n+                Cache.invalidate();\n+                throw t;\n@@ -254,1 +275,0 @@\n-                atTop = scope.popForcefully();  \/\/ may block\n@@ -258,18 +278,0 @@\n-            \/\/ re-throw exception if op completed with exception\n-            \/\/ throw exception if a structure mismatch was detected\n-            if (ex != null || !atTop) {\n-                if (!atTop) {\n-                    var e = new StructureViolationException();\n-                    if (ex == null) {\n-                        ex = e;\n-                    } else {\n-                        ex.addSuppressed(e);\n-                    }\n-                }\n-                if (ex instanceof Exception e)\n-                    throw e;\n-                if (ex instanceof Error e)\n-                    throw e;\n-                assert false;\n-            }\n-            return result;\n@@ -279,9 +281,10 @@\n-         * Runs a value-returning operation with this some ScopeLocals bound to values.\n-         * If the operation terminates with an exception {@code e}, apply {@code handler}\n-         * to {@code e} and return the result.\n-         *\n-         * @param op the operation to run\n-         * @param handler a function to be applied if the operation completes with an exception\n-         * @param <R> the type of the result of the function\n-         * @return the result\n-         *\/\n+         * Runs a value-returning operation with this some ScopeLocals bound to values,\n+         * in the same way as {@code call()}.<p>\n+         *     If the operation throws an exception, pass it as a single argument to the {@link Function}\n+         *     {@code handler}. {@code handler} must return a value compatible with the type returned by {@code op}.\n+         * <\/p>\n+         * @param op    the operation to run\n+         * @param <R>   the type of the result of the function\n+         * @param handler the handler to be applied if {code op} threw an exception\n+         * @return the result.\n+          *\/\n@@ -315,3 +318,0 @@\n-            Throwable ex = null;\n-            boolean atTop;\n-            var scope = new StackableScope().push();\n@@ -319,3 +319,4 @@\n-                op.run();\n-            } catch (Throwable e) {\n-                ex = e;\n+                StackableScope.run(op);\n+            } catch (Throwable t) {\n+                Cache.invalidate();\n+                throw t;\n@@ -323,1 +324,0 @@\n-                atTop = scope.popForcefully();  \/\/ may block\n@@ -327,17 +327,0 @@\n-            \/\/ re-throw exception if op completed with exception\n-            \/\/ throw exception if a structure mismatch was detected\n-            if (ex != null || !atTop) {\n-                if (!atTop) {\n-                    var e = new StructureViolationException();\n-                    if (ex == null) {\n-                        ex = e;\n-                    } else {\n-                        ex.addSuppressed(e);\n-                    }\n-                }\n-                if (ex instanceof RuntimeException e)\n-                    throw e;\n-                if (ex instanceof Error e)\n-                    throw e;\n-                assert false;\n-            }\n@@ -349,1 +332,1 @@\n-        private final static Snapshot addScopeLocalBindings(Carrier bindings, short primaryBits) {\n+        private static final Snapshot addScopeLocalBindings(Carrier bindings, short primaryBits) {\n@@ -355,0 +338,23 @@\n+\n+        \/*\n+         * Ensure that none of these bindings is already bound.\n+         *\/\n+        void checkNotBound() {\n+            for (Carrier c = this; c != null; c = c.prev) {\n+                if (c.key.isBound()) {\n+                    throw new RuntimeException(\"Scope Local already bound\");\n+                }\n+            }\n+        }\n+\n+        \/**\n+         * Create a try-with-resources ScopeLocal binding to be used within\n+         * a try-with-resources block.\n+         * <p>If any of the {@link ScopeLocal}s bound in this {@link Carrier} are already bound in an outer context,\n+         * throw a {@link RuntimeException}.<\/p>\n+         * @return a {@link ScopeLocalBinder}.\n+         *\/\n+        public ScopeLocalBinder bind() {\n+            checkNotBound();\n+            return (ScopeLocalBinder)new Binder(this).push();\n+        }\n@@ -358,1 +364,62 @@\n-     * Creates a binding for a ScopeLocal instance.\n+     * An @AutoCloseable that's used to bind a {@code ScopeLocal} in a try-with-resources construct.\n+     *\/\n+    static final class Binder extends StackableScope implements ScopeLocalBinder {\n+        final Carrier bindings;\n+        final short primaryBits;\n+        final Binder prevBinder;\n+\n+        Binder(Carrier bindings) {\n+            this.bindings = bindings;\n+            this.prevBinder = innermostBinder();\n+            this.primaryBits = (short)(bindings.primaryBits\n+                    | (prevBinder == null ? 0 : prevBinder.primaryBits));\n+        }\n+\n+        static Binder innermostBinder() {\n+            StackableScope headScope =  JLA.headStackableScope(Thread.currentThread());\n+            if (headScope == null) {\n+                headScope = JLA.threadContainer(Thread.currentThread());\n+            }\n+            if (headScope == null) {\n+                return null;\n+            }\n+            return headScope.innermostScope(Binder.class);\n+        }\n+\n+        \/**\n+         * Close a scope local binding context.\n+         *\n+         * @throws StructureViolationException if {@code this} isn't the current top binding\n+         *\/\n+        public void close() throws RuntimeException {\n+            Cache.invalidate(bindings.primaryBits|bindings.secondaryBits);\n+            if (! popForcefully()) {\n+                Cache.invalidate();\n+                throw new StructureViolationException();\n+            }\n+        }\n+\n+        protected boolean tryClose() {\n+            Cache.invalidate(bindings.primaryBits|bindings.secondaryBits);\n+            return true;\n+        }\n+\n+        static Object find(ScopeLocal<?> key) {\n+            for (Binder b = innermostBinder(); b != null; b = b.prevBinder) {\n+                if (((1 << Cache.primaryIndex(key)) & b.primaryBits) != 0) {\n+                    for (Carrier binding = b.bindings;\n+                         binding != null;\n+                         binding = binding.prev) {\n+                        if (binding.getKey() == key) {\n+                            Object value = binding.get();\n+                            return value;\n+                        }\n+                    }\n+                }\n+            }\n+            return Snapshot.NIL;\n+        }\n+    }\n+\n+    \/**\n+     * Create a binding for a ScopeLocal instance.\n@@ -440,2 +507,1 @@\n-        var bindings = scopeLocalBindings();\n-        var value =  bindings.find(this);\n+        var value =  findBinding();\n@@ -456,1 +522,1 @@\n-        return (scopeLocalBindings().find(this) != Snapshot.NIL);\n+        return findBinding() != Snapshot.NIL;\n@@ -463,1 +529,5 @@\n-        return scopeLocalBindings().find(this);\n+        Object value = scopeLocalBindings().find(this);\n+        if (value != Snapshot.NIL) {\n+            return value;\n+        }\n+        return Binder.find(this);\n@@ -504,2 +574,1 @@\n-        Thread currentThread = Thread.currentThread();\n-        return currentThread.scopeLocalBindings;\n+        return Thread.currentThread().scopeLocalBindings;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopeLocal.java","additions":138,"deletions":69,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+\/**\n+ * The interface for a ScopeLocal try-with-resources binding.\n+ *\/\n+public sealed interface ScopeLocalBinder extends AutoCloseable permits ScopeLocal.Binder {\n+\n+    \/**\n+     * Closes this {@link ScopeLocal} binding. If this binding was not the most recent binding\n+     * created by {@code Carrier.bind()}, throws a {@link StructureViolationException}.\n+     * This method is invoked automatically on objects managed by the try-with-resources statement.\n+     * @throws StructureViolationException if the bindings were not closed in the correct order.\n+     *\/\n+    public void close() throws StructureViolationException;\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopeLocalBinder.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -30,0 +30,2 @@\n+import java.util.concurrent.Callable;\n+\n@@ -76,0 +78,103 @@\n+    private static void handleThrows(Throwable ex, boolean atTop) {\n+        \/\/ re-throw exception if op completed with exception\n+        \/\/ throw exception if a structure mismatch was detected\n+        if (ex != null || !atTop) {\n+            if (!atTop) {\n+                var e = new StructureViolationException();\n+                if (ex == null) {\n+                    ex = e;\n+                } else {\n+                    ex.addSuppressed(e);\n+                }\n+            }\n+            if (ex instanceof RuntimeException e)\n+                throw e;\n+            if (ex instanceof Error e)\n+                throw e;\n+            assert false;\n+        }\n+    }\n+\n+    \/**\n+     * Call op, wrapped in a {@code StackableScope}\n+     * @param op a Callable\n+     * @param <T> a class\n+     * @return a T\n+     * @throws Exception\n+     *\/\n+    public static <T> T call(Callable<T> op) throws Exception {\n+        if (head() == null) {\n+            Throwable ex = null;\n+            T result = null;\n+            try {\n+                result = op.call();\n+            } catch (Throwable e) {\n+                ex = e;\n+            } finally {\n+                StackableScope head = head();\n+                if (head != null) {\n+                    popAll();\n+                }\n+                handleThrows(ex, head == null);\n+            }\n+            return result;\n+        } else {\n+            \/\/ Slow path\n+            return new StackableScope().doCall(op);\n+        }\n+    }\n+\n+    private <T> T doCall(Callable<T> op) throws Exception {\n+        Throwable ex = null;\n+        boolean atTop;\n+        T result = null;\n+        var scope = push();\n+        try {\n+            result = op.call();\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = scope.popForcefully();  \/\/ may block\n+        }\n+        handleThrows(ex, atTop);\n+        return result;\n+    }\n+\n+    \/**\n+     * Run op, wrapped in a {@code StackableScope}\n+     * @param op a Runnable\n+     *\/\n+    public static void run(Runnable op) {\n+        if (head() == null) {\n+            Throwable ex = null;\n+            try {\n+                op.run();\n+            } catch (Throwable e) {\n+                ex = e;\n+            } finally {\n+                StackableScope head = head();\n+                if (head != null) {\n+                    popAll();\n+                }\n+                handleThrows(ex, head == null);\n+            }\n+        } else {\n+            \/\/ Slow path\n+            new StackableScope().doRun(op);\n+        }\n+    }\n+\n+    private void doRun(Runnable op) {\n+        Throwable ex = null;\n+        boolean atTop;\n+        var scope = push();\n+        try {\n+            op.run();\n+        } catch (Throwable e) {\n+            ex = e;\n+        } finally {\n+            atTop = scope.popForcefully();  \/\/ may block\n+        }\n+        handleThrows(ex, atTop);\n+    }\n+\n@@ -167,1 +272,9 @@\n-        StackableScope current = enclosingScope();\n+        StackableScope enclosing = enclosingScope();\n+        if (enclosing != null) {\n+            return enclosing.innermostScope(type);\n+        }\n+        return null;\n+    }\n+\n+    public <T extends StackableScope> T innermostScope(Class<T> type) {\n+        StackableScope current = this;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/StackableScope.java","additions":114,"deletions":1,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -142,0 +142,8 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object TWR_bind_ScopeLocal() throws Exception {\n+        try (var x = ScopeLocal.where(unbound, 42).bind()) {\n+            return getClass();\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopeLocals.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+    static final ScopeLocal<Integer> unbound = ScopeLocal.newInstance();\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopeLocalsData.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}