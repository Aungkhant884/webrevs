{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -369,0 +369,2 @@\n+\n+        \/\/ Iterate over all the threads to figure out the max field widths needed\n@@ -379,0 +381,1 @@\n+        \/\/ Iterate over all threads in the threadgroup.\n@@ -466,1 +469,1 @@\n-            printThreadGroup(ThreadInfo.group());\n+            printThreadGroup(ThreadInfo.group()); \/\/ print threads in the current threadgroup\n@@ -474,1 +477,1 @@\n-            printThreadGroup(tg);\n+            printThreadGroup(tg); \/\/ print threads in specified group (and its subgroups)\n@@ -518,2 +521,2 @@\n-         * The 'run' command makes little sense in a\n-         * that doesn't support restarts or multiple VMs. However,\n+         * The 'run' command makes little sense in\n+         * that it doesn't support restarts or multiple VMs. However,\n@@ -571,0 +574,1 @@\n+    \/* Note: no longer used, but kept around as sample code. *\/\n@@ -717,0 +721,2 @@\n+            } catch (IllegalThreadStateException its) {\n+                MessageOutput.println(\"Illegal thread state\");\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/Commands.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,2 +60,2 @@\n-    static void init(String connectSpec, boolean openNow, int flags, String extraOptions) {\n-        connection = new VMConnection(connectSpec, flags, extraOptions);\n+    static void init(String connectSpec, boolean openNow, int flags, boolean trackAllVthreads, String extraOptions) {\n+        connection = new VMConnection(connectSpec, flags, trackAllVthreads, extraOptions);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/Env.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,2 @@\n+import com.sun.jdi.request.EventRequestManager;\n+import com.sun.jdi.request.ThreadDeathRequest;\n@@ -49,0 +51,1 @@\n+    boolean trackAllVthreads;\n@@ -50,1 +53,1 @@\n-    EventHandler(EventNotifier notifier, boolean stopOnVMStart) {\n+    EventHandler(EventNotifier notifier, boolean stopOnVMStart, boolean trackAllVthreads) {\n@@ -53,0 +56,1 @@\n+        this.trackAllVthreads = trackAllVthreads;\n@@ -99,0 +103,29 @@\n+        \/*\n+         * See if the event thread is a vthread that we need to start tracking.\n+         *\/\n+        ThreadReference eventThread = null;\n+        if (event instanceof ClassPrepareEvent) {\n+            eventThread = ((ClassPrepareEvent)event).thread();\n+        } else if (event instanceof LocatableEvent) {\n+            eventThread = ((LocatableEvent)event).thread();\n+        }\n+        if (eventThread != null) {\n+            \/\/ This might be a vthread we haven't seen before, so add it to the list.\n+            boolean added = ThreadInfo.addThread(eventThread);\n+            if (added) {\n+                \/\/ If added, it should be a vthread. Platform threads are always added\n+                \/\/ when the ThreadStart event arrives, so should already be in the list.\n+                assert eventThread.isVirtual();\n+            }\n+            \/\/ If we added it, we need to make sure it eventually gets removed. Usually\n+            \/\/ this happens when the ThreadDeathEvent comes in, but if !trackAllVthreads,\n+            \/\/ then the ThreadDeathReqest was setup to filter out vthreads. So we'll need\n+            \/\/ to create a special ThreadDeathReqest just to detect when this vthread dies.\n+            if (added && !trackAllVthreads) {\n+                EventRequestManager erm = Env.vm().eventRequestManager();\n+                ThreadDeathRequest tdr = erm.createThreadDeathRequest();\n+                tdr.addThreadFilter(eventThread);\n+                tdr.enable();\n+            }\n+        }\n+\n@@ -267,2 +300,10 @@\n-        ThreadDeathEvent tee = (ThreadDeathEvent)event;\n-        ThreadInfo.removeThread(tee.thread());\n+        ThreadDeathEvent tde = (ThreadDeathEvent)event;\n+        ThreadReference thread = tde.thread();\n+        ThreadInfo.removeThread(thread);\n+\n+        if (!trackAllVthreads && thread.isVirtual()) {\n+            \/\/ Remove the ThreadDeathRequest used for this event since it was created\n+            \/\/ just to remove this one vthread.\n+            EventRequestManager erm = Env.vm().eventRequestManager();\n+            erm.deleteEventRequest(event.request());\n+        }\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/EventHandler.java","additions":45,"deletions":4,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+    private static boolean trackAllVthreads;\n@@ -75,1 +76,1 @@\n-    private volatile boolean shuttingDown = false;\n+    private volatile boolean shuttingDown;\n@@ -567,1 +568,1 @@\n-                                handler = new EventHandler(this, false);\n+                                handler = new EventHandler(this, false, trackAllVthreads);\n@@ -795,1 +796,1 @@\n-            this.handler = new EventHandler(this, true);\n+            this.handler = new EventHandler(this, true, trackAllVthreads);\n@@ -975,0 +976,2 @@\n+            } else if (token.equals(\"-trackallvthreads\")) {\n+                trackAllVthreads = true;\n@@ -996,0 +999,2 @@\n+            } else if (token.startsWith(\"-R\")) {\n+                javaArgs = addArgument(javaArgs, token.substring(2));\n@@ -1166,1 +1171,1 @@\n-        if (connectSpec.startsWith(\"com.sun.jdi.CommandLineLaunch:\")) {\n+        if (connectSpec.startsWith(\"com.sun.jdi.CommandLineLaunch:\") && trackAllVthreads) {\n@@ -1171,1 +1176,1 @@\n-            Env.init(connectSpec, launchImmediately, traceFlags, javaArgs);\n+            Env.init(connectSpec, launchImmediately, traceFlags, trackAllVthreads, javaArgs);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTY.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,0 +144,1 @@\n+        {\"Illegal thread state\", \"Illegal thread state\"},\n@@ -478,0 +479,1 @@\n+             \"    -trackallvthreads attempt to keep track of all virtual threads\\n\" +\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+    private static List<ThreadInfo> vthreads = Collections.synchronizedList(new ArrayList<ThreadInfo>());\n@@ -73,1 +74,2 @@\n-    static void addThread(ThreadReference thread) {\n+    \/\/ Returns true if thread is newly added. Returns false if previously added.\n+    static boolean addThread(ThreadReference thread) {\n@@ -81,1 +83,6 @@\n-                threads.add(ti);\n+                if (thread.isVirtual()) {\n+                    vthreads.add(ti);\n+                } else {\n+                    threads.add(ti);\n+                }\n+                return true;\n@@ -83,0 +90,1 @@\n+            return false;\n@@ -106,1 +114,5 @@\n-        threads.remove(getThreadInfo(thread));\n+        if (thread.isVirtual()) {\n+            vthreads.remove(getThreadInfo(thread));\n+        } else {\n+            threads.remove(getThreadInfo(thread));\n+        }\n@@ -113,1 +125,11 @@\n-            return new ArrayList<ThreadInfo>(threads);\n+            List<ThreadInfo> list = new ArrayList<ThreadInfo>(threads);\n+            list.addAll(vthreads); \/\/ also include the vthreads list\n+            return list;\n+        }\n+    }\n+\n+    static List<ThreadInfo> vthreads() {\n+        synchronized(threads) {\n+            initThreads();\n+            \/\/ Make a copy to allow iteration without synchronization\n+            return new ArrayList<ThreadInfo>(vthreads);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/ThreadInfo.java","additions":27,"deletions":5,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.NoSuchElementException;\n@@ -45,0 +46,1 @@\n+    Iterator<ThreadInfo> vthreadIter;\n@@ -48,4 +50,4 @@\n-    }\n-\n-    ThreadIterator(List<ThreadGroupReference> tgl) {\n-        tgi = new ThreadGroupIterator(tgl);\n+        if (tg == Env.vm().topLevelThreadGroups().get(0)) {\n+            \/\/ This means all groups are included, so include vthreads.\n+            vthreadIter = ThreadInfo.vthreads().iterator();\n+        }\n@@ -56,0 +58,1 @@\n+        vthreadIter = ThreadInfo.vthreads().iterator();\n@@ -62,1 +65,3 @@\n-                return false; \/\/ no more\n+                return (vthreadIter == null ? false : vthreadIter.hasNext());\n+            } else {\n+                it = tgi.nextThreadGroup().threads().iterator();\n@@ -64,1 +69,0 @@\n-            it = tgi.nextThreadGroup().threads().iterator();\n@@ -71,1 +75,9 @@\n-        return it.next();\n+        if (it.hasNext()) {\n+            return it.next();\n+        } else {\n+            if (vthreadIter == null) {\n+                throw new NoSuchElementException();\n+            } else {\n+                return vthreadIter.next().getThread();\n+            }\n+        }\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/ThreadIterator.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+    private boolean trackAllVthreads;\n@@ -330,1 +331,1 @@\n-    VMConnection(String connectSpec, int traceFlags, String extraOptions) {\n+    VMConnection(String connectSpec, int traceFlags, boolean trackAllVthreads, String extraOptions) {\n@@ -350,0 +351,1 @@\n+        this.trackAllVthreads = trackAllVthreads;\n@@ -469,1 +471,0 @@\n-        tsr.enable();\n@@ -471,0 +472,5 @@\n+        if (!trackAllVthreads) {\n+            tsr.addPlatformThreadsOnlyFilter();\n+            tdr.addPlatformThreadsOnlyFilter();\n+        }\n+        tsr.enable();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/VMConnection.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,2 @@\n- *      -waittime=5\n+ *      -waittime=1 \n+ *      -verbose\n@@ -59,0 +60,1 @@\n+ *      -jdb.option=\"-trackallvthreads\"\n@@ -101,0 +103,1 @@\n+        boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n@@ -105,1 +108,3 @@\n-        threads = jdb.getThreadIds(DEBUGGEE_THREAD);\n+        \/\/ At this point we are at the breakpoint triggered by the breakHere() call done\n+        \/\/ after creating all the threads. Get the list of debuggee threads.\n+        threads = jdb.getThreadIdsByName(MYTHREAD);\n@@ -113,0 +118,2 @@\n+        \/\/ Kill each debuggee thread. This will cause each thread to stop in the debugger,\n+        \/\/ indicating that an exception was thrown.\n@@ -114,0 +121,2 @@\n+            \/\/ kill (ThreadReference.stop) is not supproted for vthreads, so we expect an error.\n+            String msg = (vthreadMode ? \"Illegal thread state\" : \"killed\");\n@@ -116,1 +125,1 @@\n-                                                       \"killed\");\n+                                                       msg);\n@@ -119,1 +128,7 @@\n-        for (int i = 0; i <= numThreads; i++) {\n+        \/\/ Continue the main thread, which is still at the breakpoint. This will resume\n+        \/\/ all the debuggee threads, allowing the kill to take place.\n+        reply = jdb.receiveReplyFor(JdbCommand.cont);\n+\n+        \/\/ Continue each of the threads that received the \"kill\" exception. Not needed\n+        \/\/ for the vthread case since they are not actually killed.\n+        if (!vthreadMode) for (int i = 0; i < numThreads; i++) {\n@@ -135,3 +150,8 @@\n-            if (found.indexOf(DEBUGGEE_RESULT + \" = 0\") < 0) {\n-               log.complain(\"Not all \" + MYTHREAD + \"s were killed. \" + found + \" remaining\");\n-               success = false;\n+            if (vthreadMode) {\n+                if (found.indexOf(DEBUGGEE_RESULT + \" = \" + numThreads) < 0) {\n+                    log.complain(\"Some \" + MYTHREAD + \"s were killed. \" + found + \" remaining\");\n+                    success = false;\n+                }\n+            } else if (found.indexOf(DEBUGGEE_RESULT + \" = 0\") < 0) {\n+                log.complain(\"Not all \" + MYTHREAD + \"s were killed. \" + found + \" remaining\");\n+                success = false;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import nsk.share.jdi.JDIThreadFactory;\n@@ -42,1 +43,1 @@\n-    static final String MYTHREAD         = \"MyThread\";\n+    static final String MYTHREAD         = nsk.jdb.kill.kill001.kill001.MYTHREAD;\n@@ -49,0 +50,1 @@\n+    static boolean vthreadMode           = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n@@ -72,1 +74,2 @@\n-            holder[i] = new MyThread(MYTHREAD + \"-\" + i);\n+            String name = MYTHREAD + \"-\" + i;\n+            holder[i] = JDIThreadFactory.newThread(new MyThread(name), name);\n@@ -91,1 +94,1 @@\n-        \/\/ wait during watTime until all MyThreads will be killed\n+        \/\/ wait during waitTime until all MyThreads will be killed\n@@ -96,1 +99,7 @@\n-                if (holder[i].isAlive()) {\n+                if (vthreadMode) {\n+                    \/\/ vthreads will exit on their own without being killed, so just wait for them to exit.\n+                    try {\n+                        holder[i].join();\n+                    } catch (InterruptedException e) {\n+                    }\n+                } else if (holder[i].isAlive()) {\n@@ -107,1 +116,1 @@\n-            if (!waited) {\n+            if (!waited || vthreadMode) {\n@@ -115,1 +124,1 @@\n-            if (holder[i].isAlive()) {\n+            if (holder[i].isAlive() && !vthreadMode) {\n@@ -152,1 +161,3 @@\n-        \/\/ sleep during waitTime to give debugger a chance to kill debugee's thread\n+        \/\/ Sleep during waitTime to give debugger a chance to kill debugee's thread.\n+        \/\/ Note vthreads need a short sleep because they will never receive the kill,\n+        \/\/ and therefore sleep the full time, resulting in a test timeout if too long.\n@@ -154,1 +165,1 @@\n-            Thread.currentThread().sleep(kill001a.waitTime);\n+            Thread.currentThread().sleep(kill001a.vthreadMode ? 1000 : kill001a.waitTime);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001a.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+ *      -verbose\n@@ -52,0 +53,1 @@\n+ *      -jdb.option=\"-trackallvthreads\"\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/threads\/threads002\/threads002.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import nsk.share.jdi.JDIThreadFactory;\n@@ -41,2 +42,3 @@\n-    static int numThreads = 5;   \/\/ number of threads\n-    static Object waitnotify = new Object();\n+    static final String THREAD_NAME = threads002.THREAD_NAME;\n+    static int numThreads           = 5;   \/\/ number of threads\n+    static Object waitnotify        = new Object();\n@@ -54,1 +56,2 @@\n-                holder[i] = new MyThread(lock);\n+                String name = THREAD_NAME + \"-\" + i;\n+                holder[i] = JDIThreadFactory.newThread(new MyThread(lock), name);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/threads\/threads002\/threads002a.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jdb\/threads\/threads003.\n+ * VM Testbase keywords: [jpda, jdb]\n+ * VM Testbase readme:\n+ * DECSRIPTION\n+ *  This is a test for jdb 'threads' command in conjunction with jdb's\n+ *  ability to start tracking a vthread when the first event arrives on it.\n+ *  It also tests that vthreads where no event is received are not tracked.\n+ *  The debugee starts 5 'MyThreads'. The odd numbered threads call a\n+ *  method that has been setup as a breakpoint. The others do not. All\n+ *  5 are then suspended on a lock that the main thread posseses. The\n+ *  'threads' command is issued at this point. The test passes if\n+ *  only 'MyThreads-1' and 'MyThreads-3' are reported.\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.jdb.threads.threads003.threads003a\n+ * @run main\/othervm\n+ *      nsk.jdb.threads.threads003.threads003\n+ *      -arch=${os.family}-${os.simpleArch}\n+ *      -waittime=1\n+ *      -verbose\n+ *      -debugee.vmkind=java\n+ *      -transport.address=dynamic\n+ *      -jdb=${test.jdk}\/bin\/jdb\n+ *      -java.options=\"${test.vm.opts} ${test.java.opts}\"\n+ *      -workdir=.\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *\/\n+\n+package nsk.jdb.threads.threads003;\n+\n+import nsk.share.*;\n+import nsk.share.jdb.*;\n+\n+import java.io.*;\n+import java.util.*;\n+\n+public class threads003 extends JdbTest {\n+\n+    public static void main (String argv[]) {\n+        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n+    }\n+\n+    public static int run(String argv[], PrintStream out) {\n+        debuggeeClass =  DEBUGGEE_CLASS;\n+        firstBreak = FIRST_BREAK;\n+        lastBreak = LAST_BREAK;\n+        return new threads003().runTest(argv, out);\n+    }\n+\n+    static final String PACKAGE_NAME     = \"nsk.jdb.threads.threads003\";\n+    static final String TEST_CLASS       = PACKAGE_NAME + \".threads003\";\n+    static final String DEBUGGEE_CLASS   = TEST_CLASS + \"a\";\n+    static final String FIRST_BREAK      = DEBUGGEE_CLASS + \".main\";\n+    static final String LAST_BREAK       = DEBUGGEE_CLASS + \".breakpoint\";\n+    static final String THREAD_NAME      = \"MyThread\";\n+    static final int    NUM_THREADS      = 5;\n+    static final int    KNOWN_THREADS    = NUM_THREADS \/ 2; \/\/ only odd nubmered threads will be known threads\n+\n+    protected void runCases() {\n+        String[] reply;\n+        Paragrep grep;\n+        int count;\n+        Vector v;\n+        String[] threads;\n+        boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n+\n+        if (!vthreadMode) {\n+            \/\/ This test is only meant to be run in vthread mode.\n+            log.display(\"Test not run in vthread mode. Exiting early.\");\n+            jdb.contToExit(1);\n+            return;\n+        }\n+\n+        jdb.setBreakpointInMethod(LAST_BREAK);\n+        jdb.receiveReplyFor(JdbCommand.cont); \/\/ This is to get the test going\n+        jdb.receiveReplyFor(JdbCommand.cont); \/\/ This is to continue after MYTHREAD-1 breakpoint\n+        jdb.receiveReplyFor(JdbCommand.cont); \/\/ This is to continue after MYTHREAD-3 breakpoint\n+\n+        \/\/ At this point we are at the breakpoint done,after creating all the threads.\n+        \/\/ Get the list of debuggee threads that jdb knows about\n+        threads = jdb.getThreadIdsByName(THREAD_NAME);\n+\n+        \/\/ There were NUM_THREADS threads created, but only KNOWN_THREADS hit the breakpoint,\n+        \/\/ so these should be the only threads found.\n+        if (threads.length != KNOWN_THREADS) {\n+            failure(\"Unexpected number of \" + THREAD_NAME + \" was listed: \" + threads.length +\n+                    \"\\n\\texpected value: \" + KNOWN_THREADS);\n+        }\n+\n+        \/\/ Now make sure the correct threads were reported.\n+        for (int i = 0; i < threads.length; i++) {\n+            \/\/ Switch to the thread. The reply should be the new prompt with the thread's name.\n+            reply = jdb.receiveReplyFor(JdbCommand.thread + \" \" + threads[i]);\n+            String prompt = THREAD_NAME + \"-\" + (i * 2 + 1) + \"[1] \";\n+            if (!reply[0].equals(prompt)) {\n+                failure(\"Expect to find prompt \\\"\" + prompt + \"\\\" but found \\\"\" + reply[0] + \"\\\"\");\n+            }\n+        }\n+\n+        jdb.contToExit(1);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/threads\/threads003\/threads003.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jdb.threads.threads003;\n+\n+import nsk.share.*;\n+import nsk.share.jpda.*;\n+import nsk.share.jdb.*;\n+import nsk.share.jdi.JDIThreadFactory;\n+\n+import java.io.*;\n+\n+\/* This is debuggee aplication *\/\n+public class threads003a {\n+    public static void main(String args[]) {\n+        threads003a _threads003a = new threads003a();\n+        System.exit(threads003.JCK_STATUS_BASE + _threads003a.runIt(args, System.out));\n+    }\n+\n+    static void breakpoint () {}\n+\n+    static final String THREAD_NAME = nsk.jdb.threads.threads003.threads003.THREAD_NAME;\n+    static int numThreads           = nsk.jdb.threads.threads003.threads003.NUM_THREADS;\n+    static Object waitnotify        = new Object();\n+\n+    public int runIt(String args[], PrintStream out) {\n+        JdbArgumentHandler argumentHandler = new JdbArgumentHandler(args);\n+        Log log = new Log(out, argumentHandler);\n+\n+        Thread holder [] = new Thread[numThreads];\n+        Lock lock = new Lock();\n+\n+        try {\n+            lock.setLock();\n+            for (int i = 0; i < numThreads ; i++) {\n+                boolean doBreakpoint = i % 2 == 1;  \/\/ breakpoint on odd threads only\n+                String name = THREAD_NAME + \"-\" + i;\n+                holder[i] = JDIThreadFactory.newThread(new MyThread(lock, doBreakpoint), name);\n+                synchronized (waitnotify) {\n+                    holder[i].start();\n+                    waitnotify.wait();\n+                }\n+            }\n+        } catch (Exception e) {\n+            System.err.println(\"TEST ERROR: Caught unexpected Exception while waiting in main thread: \" +\n+                e.getMessage());\n+            System.exit(threads003.FAILED);\n+        }\n+\n+        breakpoint();   \/\/ When jdb stops here, there should be 5 running MyThreads.\n+        lock.releaseLock();\n+\n+        for (int i = 0; i < numThreads ; i++) {\n+            if (holder[i].isAlive()) {\n+                try {\n+                    holder[i].join(argumentHandler.getWaitTime() * 60000);\n+                } catch (InterruptedException e) {\n+                    throw new Failure(\"Unexpected InterruptedException catched while waiting for join of: \" + holder[i]);\n+                }\n+            }\n+        }\n+\n+        log.display(\"Debuggee PASSED\");\n+        return threads003.PASSED;\n+    }\n+\n+}\n+\n+class Lock {\n+    boolean lockSet;\n+\n+    synchronized void setLock() throws InterruptedException {\n+        while (lockSet == true)\n+            wait();\n+        lockSet = true;\n+    }\n+\n+    synchronized void releaseLock() {\n+        if (lockSet == true) {\n+            lockSet = false;\n+            notify();\n+        }\n+    }\n+}\n+\n+class MyThread extends Thread {\n+\n+    Lock lock;\n+    boolean doBreakpoint;\n+    MyThread (Lock l, boolean doBreakpoint) {\n+        this.lock = l;\n+        this.doBreakpoint = doBreakpoint;\n+    }\n+\n+    public void run() {\n+        if (doBreakpoint) {\n+            threads003a.breakpoint();\n+        }\n+        synchronized (threads003a.waitnotify) {\n+            threads003a.waitnotify.notifyAll();\n+        }\n+        try {\n+            lock.setLock();\n+        } catch(Exception e) {\n+            System.err.println(\"TEST ERROR: Caught unexpected Exception while waiting in MyThread: \" +\n+                e.getMessage());\n+            System.exit(threads003.FAILED);\n+        }\n+        lock.releaseLock();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/threads\/threads003\/threads003a.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+ *      -jdb.option=\"-trackallvthreads\"\n@@ -104,1 +105,1 @@\n-        threads = jdb.getThreadIds(DEBUGGEE_THREAD);\n+        threads = jdb.getThreadIdsByName(MYTHREAD);\n@@ -107,1 +108,1 @@\n-            log.complain(\"jdb should report 2 instance of \" + DEBUGGEE_THREAD);\n+            log.complain(\"jdb should report 2 instance named \" + MYTHREAD + \"-<n>\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/trace\/trace001\/trace001.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import nsk.share.jdi.JDIThreadFactory;\n@@ -32,1 +33,1 @@\n-\/* This is debuggee aplication *\/\n+\/* This is the debuggee application *\/\n@@ -41,1 +42,1 @@\n-    static final String MYTHREAD  = \"MyThread\";\n+    static final String MYTHREAD  = trace001.MYTHREAD;\n@@ -57,1 +58,2 @@\n-            holder[i] = new MyThread(locks[i],MYTHREAD + \"-\" + i);\n+            String name = MYTHREAD + \"-\" + i;\n+            holder[i] = JDIThreadFactory.newThread(new MyThread(locks[i], name), name);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/trace\/trace001\/trace001a.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -806,1 +806,1 @@\n-     * Returns as string array all id's for a given <i>threadName<\/i>.\n+     * Returns as string array all id's for a given thread name of <i>threadName<\/i>.\n@@ -808,1 +808,22 @@\n-    public String[] getThreadIds(String threadName) {\n+    public String[] getThreadIdsByName(String threadName) {\n+        Vector<String> v = new Vector<String>();\n+        String[] reply = receiveReplyFor(JdbCommand.threads);\n+        Paragrep grep = new Paragrep(reply);\n+\n+        String[] found = grep.findStrings(threadName);\n+        for (int i = 0; i < found.length; i++) {\n+            String string = found[i];\n+            \/\/ Check for \"(java.lang.Thread)\" or \"(java.lang.VirtualThread)\"\n+            String searchString = \"Thread)\";\n+            int j = string.indexOf(searchString);\n+            if (j >= 0) {\n+               j += searchString.length(); \/\/ The threadID is right after the thread type\n+               String threadId = string.substring(j, string.indexOf(\" \", j));\n+               v.add(threadId);\n+            }\n+        }\n+\n+        String[] result = new String[v.size()];\n+        v.toArray(result);\n+        return result;\n+    }\n@@ -810,2 +831,7 @@\n-        if (!threadName.startsWith(\"(\")) {\n-            threadName = \"(\" + threadName;\n+    \/**\n+     * Returns as string array all id's for a given class type of <i>threadType<\/i>.\n+     *\/\n+    public String[] getThreadIds(String threadType) {\n+\n+        if (!threadType.startsWith(\"(\")) {\n+            threadType = \"(\" + threadType;\n@@ -813,2 +839,2 @@\n-        if (!threadName.endsWith(\")\")) {\n-            threadName = threadName + \")\";\n+        if (!threadType.endsWith(\")\")) {\n+            threadType = threadType + \")\";\n@@ -821,1 +847,1 @@\n-        String[] found = grep.findStrings(threadName);\n+        String[] found = grep.findStrings(threadType);\n@@ -824,1 +850,1 @@\n-            int j = string.indexOf(threadName);\n+            int j = string.indexOf(threadType);\n@@ -826,1 +852,1 @@\n-               j += threadName.length();\n+               j += threadType.length();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Jdb.java","additions":36,"deletions":10,"binary":false,"changes":46,"status":"modified"}]}