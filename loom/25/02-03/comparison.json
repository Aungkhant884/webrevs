{"files":[{"patch":"@@ -30,0 +30,2 @@\n+#include \"jvmti_thread.h\"\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEnter\/mcontenter001\/libmcontenter.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jvmti_thread.h\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEntered\/mcontentered001\/libmcontentered.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"jvmti_thread.h\"\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWait\/monitorwait001\/libmonitorwait.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"jvmti_thread.h\"\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWaited\/monitorwaited001\/libmonitorwaited.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jvmti_thread.h\"\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend002\/libthreadend02.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"jvmti_thread.h\"\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/VMObjectAlloc\/vmobjalloc001\/libvmobjalloc.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,22 +72,0 @@\n-static jvmtiEnv* jvmti_env = NULL;\n-static JavaVM* jvm = NULL;\n-static JNIEnv* jni_env = NULL;\n-\n-static volatile int currentAgentStatus = NSK_STATUS_PASSED;\n-\n-static jthread agentThread = NULL;\n-static jvmtiStartFunction agentThreadProc = NULL;\n-static void* agentThreadArg = NULL;\n-\n-void nsk_jvmti_setFailStatus() {\n-  currentAgentStatus = NSK_STATUS_FAILED;\n-}\n-\n-jint nsk_jvmti_getStatus() {\n-  return currentAgentStatus;\n-}\n-\n-int  nsk_jvmti_getWaitTime() {\n-  return 1;\n-}\n-\n@@ -120,17 +98,0 @@\n-typedef enum { NEW, RUNNABLE, WAITING, SUSPENDED, TERMINATED } thread_state_t;\n-\n-typedef struct agent_data_t {\n-  volatile thread_state_t thread_state;\n-  int last_debuggee_status;\n-  jrawMonitorID monitor;\n-} agent_data_t;\n-\n-int nsk_jvmti_setAgentProc(jvmtiStartFunction proc, void* arg) {\n-  agentThreadProc = proc;\n-  agentThreadArg = arg;\n-  return NSK_TRUE;\n-}\n-\n-static agent_data_t agent_data;\n-\n-\n@@ -144,282 +105,0 @@\n-\n-static jvmtiError init_agent_data(jvmtiEnv *jvmti_env, agent_data_t *data) {\n-  data->thread_state = NEW;\n-  data->last_debuggee_status = NSK_STATUS_PASSED;\n-\n-  return jvmti_env->CreateRawMonitor(\"agent_data_monitor\", &data->monitor);\n-}\n-\n-jint createRawMonitor(jvmtiEnv *env, const char *name, jrawMonitorID *monitor) {\n-  jvmtiError error = env->CreateRawMonitor(name, monitor);\n-  if (error != JVMTI_ERROR_NONE) {\n-    return JNI_ERR;\n-  }\n-  return JNI_OK;\n-}\n-\n-void exitOnError(jvmtiError error) {\n-  if (error != JVMTI_ERROR_NONE) {\n-    exit(error);\n-  }\n-}\n-\n-void rawMonitorEnter(jvmtiEnv *env, jrawMonitorID monitor) {\n-  jvmtiError error = env->RawMonitorEnter(monitor);\n-  exitOnError(error);\n-}\n-\n-void rawMonitorExit(jvmtiEnv *env, jrawMonitorID monitor) {\n-  jvmtiError error = env->RawMonitorExit(monitor);\n-  exitOnError(error);\n-}\n-\n-void rawMonitorNotify(jvmtiEnv *env, jrawMonitorID monitor) {\n-  jvmtiError error = env->RawMonitorNotify(monitor);\n-  exitOnError(error);\n-}\n-\n-void rawMonitorWait(jvmtiEnv *env, jrawMonitorID monitor, jlong millis) {\n-  jvmtiError error = env->RawMonitorWait(monitor, millis);\n-  exitOnError(error);\n-}\n-\n-\n-\/** Wait for sync point with Java code. *\/\n-int nsk_jvmti_waitForSync(jlong timeout) {\n-  static const int inc_timeout = 1000;\n-\n-  jlong t = 0;\n-  int result = NSK_TRUE;\n-\n-  rawMonitorEnter(jvmti_env, agent_data.monitor);\n-\n-  agent_data.thread_state = WAITING;\n-\n-  \/* SP2.2-n - notify agent is waiting and wait *\/\n-  \/* SP4.1-n - notify agent is waiting and wait *\/\n-  rawMonitorNotify(jvmti_env, agent_data.monitor);\n-\n-  while (agent_data.thread_state == WAITING) {\n-    \/* SP3.2-w - wait to start test *\/\n-    \/* SP6.2-w - wait to end test *\/\n-    rawMonitorWait(jvmti_env, agent_data.monitor, inc_timeout);\n-\n-    if (timeout == 0) continue;\n-\n-    t += inc_timeout;\n-\n-    if (t >= timeout) break;\n-  }\n-\n-  if (agent_data.thread_state == WAITING) {\n-      NSK_COMPLAIN1(\"No status sync occured for timeout: %\" LL \"d ms\\n\", timeout);\n-    nsk_jvmti_setFailStatus();\n-    result = NSK_FALSE;\n-  }\n-\n-  rawMonitorExit(jvmti_env, agent_data.monitor);\n-\n-  return result;\n-}\n-\n-\/** Resume java code suspended on sync point. *\/\n-int nsk_jvmti_resumeSync() {\n-  int result;\n-  rawMonitorEnter(jvmti_env, agent_data.monitor);\n-\n-  if (agent_data.thread_state == SUSPENDED) {\n-    result = NSK_TRUE;\n-    agent_data.thread_state = RUNNABLE;\n-    \/* SP5.2-n - notify suspend done *\/\n-    \/* SP7.2-n - notify agent end *\/\n-    rawMonitorNotify(jvmti_env, agent_data.monitor);\n-  }\n-  else {\n-    NSK_COMPLAIN0(\"Debuggee was not suspended on status sync\\n\");\n-    nsk_jvmti_setFailStatus();\n-    result = NSK_FALSE;\n-  }\n-\n-  rawMonitorExit(jvmti_env, agent_data.monitor);\n-  return NSK_TRUE;\n-}\n-\n-\/* ============================================================================= *\/\n-static void set_agent_thread_state(thread_state_t value) {\n-  rawMonitorEnter(jvmti_env, agent_data.monitor);\n-  agent_data.thread_state = value;\n-  rawMonitorNotify(jvmti_env, agent_data.monitor);\n-  rawMonitorExit(jvmti_env, agent_data.monitor);\n-}\n-\n-\/** Wrapper for user agent thread. *\/\n-static void JNICALL\n-agentThreadWrapper(jvmtiEnv* jvmti_env, JNIEnv* agentJNI, void* arg) {\n-  jni_env = agentJNI;\n-\n-  \/* run user agent proc *\/\n-  {\n-    set_agent_thread_state(RUNNABLE);\n-\n-    \/\/ TODO was NSK_TRACE\n-    (*agentThreadProc)(jvmti_env, agentJNI, agentThreadArg);\n-\n-    set_agent_thread_state(TERMINATED);\n-  }\n-\n-  \/* finalize agent thread *\/\n-  {\n-    \/* gelete global ref for agent thread *\/\n-    agentJNI->DeleteGlobalRef(agentThread);\n-    agentThread = NULL;\n-  }\n-}\n-\n-\n-\/** Start wrapper for user agent thread. *\/\n-static jthread startAgentThreadWrapper(JNIEnv *jni_env, jvmtiEnv* jvmti_env) {\n-  const jint  THREAD_PRIORITY = JVMTI_THREAD_MAX_PRIORITY;\n-  const char* THREAD_NAME = \"JVMTI agent thread\";\n-  const char* THREAD_CLASS_NAME = \"java\/lang\/Thread\";\n-  const char* THREAD_CTOR_NAME = \"<init>\";\n-  const char* THREAD_CTOR_SIGNATURE = \"(Ljava\/lang\/String;)V\";\n-\n-  jobject threadName = NULL;\n-  jclass threadClass = NULL;\n-  jmethodID threadCtor = NULL;\n-  jobject threadObject = NULL;\n-  jobject threadGlobalRef = NULL;\n-  jvmtiError err;\n-\n-  threadClass = jni_env->FindClass(THREAD_CLASS_NAME);\n-  if (threadClass == NULL) {\n-    return NULL;\n-  }\n-\n-  threadCtor = jni_env->GetMethodID(threadClass, THREAD_CTOR_NAME, THREAD_CTOR_SIGNATURE);\n-  if (threadCtor == NULL) {\n-    return NULL;\n-  }\n-\n-  threadName = jni_env->NewStringUTF(THREAD_NAME);\n-  if (threadName == NULL) {\n-    return NULL;\n-  }\n-\n-  threadObject = jni_env->NewObject(threadClass, threadCtor, threadName);\n-  if (threadObject == NULL) {\n-    return NULL;\n-  }\n-\n-  threadGlobalRef = jni_env->NewGlobalRef(threadObject);\n-  if (threadGlobalRef == NULL) {\n-    jni_env->DeleteLocalRef(threadObject);\n-    return NULL;\n-  }\n-  agentThread = (jthread)threadGlobalRef;\n-\n-  err = jvmti_env->RunAgentThread(agentThread, &agentThreadWrapper, agentThreadArg, THREAD_PRIORITY);\n-  if (err != JVMTI_ERROR_NONE) {\n-    jni_env->DeleteGlobalRef(threadGlobalRef);\n-    jni_env->DeleteLocalRef(threadObject);\n-    return NULL;\n-  }\n-  return agentThread;\n-}\n-\n-\/** Run registered user agent thread via wrapper. *\/\n-static jthread nsk_jvmti_runAgentThread(JNIEnv *jni_env, jvmtiEnv* jvmti_env) {\n-  \/* start agent thread wrapper *\/\n-  jthread thread = startAgentThreadWrapper(jni_env, jvmti_env);\n-  if (thread == NULL) {\n-    nsk_jvmti_setFailStatus();\n-    return NULL;\n-  }\n-\n-  return thread;\n-}\n-\n-\/** Sync point called from Java code. *\/\n-static jint syncDebuggeeStatus(JNIEnv* jni_env, jvmtiEnv* jvmti_env, jint debuggeeStatus) {\n-  jint result = NSK_STATUS_FAILED;\n-\n-  printf(\"Data %p %p\\n\", jvmti_env, agent_data.monitor);\n-  rawMonitorEnter(jvmti_env, agent_data.monitor);\n-\n-  \/* save last debugee status *\/\n-  agent_data.last_debuggee_status = debuggeeStatus;\n-\n-  \/* we don't enter if-stmt in second call *\/\n-  if (agent_data.thread_state == NEW) {\n-    if (nsk_jvmti_runAgentThread(jni_env, jvmti_env) == NULL)\n-      goto monitor_exit_and_return;\n-\n-    \/* SP2.2-w - wait for agent thread *\/\n-    while (agent_data.thread_state == NEW) {\n-      rawMonitorWait(jvmti_env, agent_data.monitor, 0);\n-    }\n-  }\n-\n-  \/* wait for sync permit *\/\n-  \/* we don't enter loop in first call *\/\n-  while (agent_data.thread_state != WAITING && agent_data.thread_state != TERMINATED) {\n-    \/* SP4.2-w - second wait for agent thread *\/\n-    rawMonitorWait(jvmti_env, agent_data.monitor, 0);\n-  }\n-\n-  if (agent_data.thread_state != TERMINATED) {\n-    agent_data.thread_state = SUSPENDED;\n-    \/* SP3.2-n - notify to start test *\/\n-    \/* SP6.2-n - notify to end test *\/\n-    rawMonitorNotify(jvmti_env, agent_data.monitor);\n-  } else {\n-    NSK_COMPLAIN0(\"Debuggee status sync aborted because agent thread has finished\\n\");\n-    goto monitor_exit_and_return;\n-  }\n-\n-  \/* update status from debuggee *\/\n-  if (debuggeeStatus != NSK_STATUS_PASSED) {\n-    printf(\"FAIL: Status is %d\\n\", debuggeeStatus);\n-    nsk_jvmti_setFailStatus();\n-  }\n-\n-  while (agent_data.thread_state == SUSPENDED) {\n-    \/* SP5.2-w - wait while testing *\/\n-    \/* SP7.2 - wait for agent end *\/\n-    rawMonitorWait(jvmti_env, agent_data.monitor, 0);\n-  }\n-\n-  agent_data.last_debuggee_status = nsk_jvmti_getStatus();\n-  result = agent_data.last_debuggee_status;\n-\n-  monitor_exit_and_return:\n-  rawMonitorExit(jvmti_env, agent_data.monitor);\n-  return result;\n-}\n-\n-\/** Native function for Java code to provide sync point. *\/\n-JNIEXPORT jint JNICALL\n-Java_jdk_test_lib_jvmti_DebugeeClass_checkStatus(JNIEnv* jni_env, jclass cls, jint debuggeeStatus) {\n-  jint status;\n-  \/\/ TODO NSK_TRACE\n-  status = syncDebuggeeStatus(jni_env, jvmti_env, debuggeeStatus);\n-  return status;\n-}\n-\n-\/** Create JVMTI environment. *\/\n-jvmtiEnv* nsk_jvmti_createJVMTIEnv(JavaVM* javaVM, void* reserved) {\n-  jvm = javaVM;\n-  if (javaVM->GetEnv((void **)&jvmti_env, JVMTI_VERSION_1_1) != JNI_OK) {\n-    nsk_jvmti_setFailStatus();\n-    return NULL;\n-  }\n-\n-  if (init_agent_data(jvmti_env, &agent_data) != 0) {\n-    nsk_jvmti_setFailStatus();\n-    return NULL;\n-  }\n-\n-  return jvmti_env;\n-}\n-\n-\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.h","additions":0,"deletions":321,"binary":false,"changes":321,"status":"modified"},{"patch":"@@ -0,0 +1,356 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef JVMTI_THREAD_H\n+#define JVMTI_THREAD_H\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include <string.h>\n+#include <ctype.h>\n+\n+extern \"C\" {\n+\n+static jvmtiEnv* jvmti_env = NULL;\n+static JavaVM* jvm = NULL;\n+static JNIEnv* jni_env = NULL;\n+\n+static volatile int currentAgentStatus = NSK_STATUS_PASSED;\n+\n+static jthread agentThread = NULL;\n+static jvmtiStartFunction agentThreadProc = NULL;\n+static void* agentThreadArg = NULL;\n+\n+void nsk_jvmti_setFailStatus() {\n+  currentAgentStatus = NSK_STATUS_FAILED;\n+}\n+\n+jint nsk_jvmti_getStatus() {\n+  return currentAgentStatus;\n+}\n+\n+int  nsk_jvmti_getWaitTime() {\n+  return 1;\n+}\n+\n+typedef enum { NEW, RUNNABLE, WAITING, SUSPENDED, TERMINATED } thread_state_t;\n+\n+typedef struct agent_data_t {\n+  volatile thread_state_t thread_state;\n+  int last_debuggee_status;\n+  jrawMonitorID monitor;\n+} agent_data_t;\n+\n+int nsk_jvmti_setAgentProc(jvmtiStartFunction proc, void* arg) {\n+  agentThreadProc = proc;\n+  agentThreadArg = arg;\n+  return NSK_TRUE;\n+}\n+\n+static agent_data_t agent_data;\n+\n+\n+static jvmtiError init_agent_data(jvmtiEnv *jvmti_env, agent_data_t *data) {\n+  data->thread_state = NEW;\n+  data->last_debuggee_status = NSK_STATUS_PASSED;\n+\n+  return jvmti_env->CreateRawMonitor(\"agent_data_monitor\", &data->monitor);\n+}\n+\n+jint createRawMonitor(jvmtiEnv *env, const char *name, jrawMonitorID *monitor) {\n+  jvmtiError error = env->CreateRawMonitor(name, monitor);\n+  if (error != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  return JNI_OK;\n+}\n+\n+void exitOnError(jvmtiError error) {\n+  if (error != JVMTI_ERROR_NONE) {\n+    exit(error);\n+  }\n+}\n+\n+void rawMonitorEnter(jvmtiEnv *env, jrawMonitorID monitor) {\n+  jvmtiError error = env->RawMonitorEnter(monitor);\n+  exitOnError(error);\n+}\n+\n+void rawMonitorExit(jvmtiEnv *env, jrawMonitorID monitor) {\n+  jvmtiError error = env->RawMonitorExit(monitor);\n+  exitOnError(error);\n+}\n+\n+void rawMonitorNotify(jvmtiEnv *env, jrawMonitorID monitor) {\n+  jvmtiError error = env->RawMonitorNotify(monitor);\n+  exitOnError(error);\n+}\n+\n+void rawMonitorWait(jvmtiEnv *env, jrawMonitorID monitor, jlong millis) {\n+  jvmtiError error = env->RawMonitorWait(monitor, millis);\n+  exitOnError(error);\n+}\n+\n+\n+\/** Wait for sync point with Java code. *\/\n+int nsk_jvmti_waitForSync(jlong timeout) {\n+  static const int inc_timeout = 1000;\n+\n+  jlong t = 0;\n+  int result = NSK_TRUE;\n+\n+  rawMonitorEnter(jvmti_env, agent_data.monitor);\n+\n+  agent_data.thread_state = WAITING;\n+\n+  \/* SP2.2-n - notify agent is waiting and wait *\/\n+  \/* SP4.1-n - notify agent is waiting and wait *\/\n+  rawMonitorNotify(jvmti_env, agent_data.monitor);\n+\n+  while (agent_data.thread_state == WAITING) {\n+    \/* SP3.2-w - wait to start test *\/\n+    \/* SP6.2-w - wait to end test *\/\n+    rawMonitorWait(jvmti_env, agent_data.monitor, inc_timeout);\n+\n+    if (timeout == 0) continue;\n+\n+    t += inc_timeout;\n+\n+    if (t >= timeout) break;\n+  }\n+\n+  if (agent_data.thread_state == WAITING) {\n+      NSK_COMPLAIN1(\"No status sync occured for timeout: %\" LL \"d ms\\n\", timeout);\n+    nsk_jvmti_setFailStatus();\n+    result = NSK_FALSE;\n+  }\n+\n+  rawMonitorExit(jvmti_env, agent_data.monitor);\n+\n+  return result;\n+}\n+\n+\/** Resume java code suspended on sync point. *\/\n+int nsk_jvmti_resumeSync() {\n+  int result;\n+  rawMonitorEnter(jvmti_env, agent_data.monitor);\n+\n+  if (agent_data.thread_state == SUSPENDED) {\n+    result = NSK_TRUE;\n+    agent_data.thread_state = RUNNABLE;\n+    \/* SP5.2-n - notify suspend done *\/\n+    \/* SP7.2-n - notify agent end *\/\n+    rawMonitorNotify(jvmti_env, agent_data.monitor);\n+  }\n+  else {\n+    NSK_COMPLAIN0(\"Debuggee was not suspended on status sync\\n\");\n+    nsk_jvmti_setFailStatus();\n+    result = NSK_FALSE;\n+  }\n+\n+  rawMonitorExit(jvmti_env, agent_data.monitor);\n+  return NSK_TRUE;\n+}\n+\n+\/* ============================================================================= *\/\n+static void set_agent_thread_state(thread_state_t value) {\n+  rawMonitorEnter(jvmti_env, agent_data.monitor);\n+  agent_data.thread_state = value;\n+  rawMonitorNotify(jvmti_env, agent_data.monitor);\n+  rawMonitorExit(jvmti_env, agent_data.monitor);\n+}\n+\n+\/** Wrapper for user agent thread. *\/\n+static void JNICALL\n+agentThreadWrapper(jvmtiEnv* jvmti_env, JNIEnv* agentJNI, void* arg) {\n+  jni_env = agentJNI;\n+\n+  \/* run user agent proc *\/\n+  {\n+    set_agent_thread_state(RUNNABLE);\n+\n+    \/\/ TODO was NSK_TRACE\n+    (*agentThreadProc)(jvmti_env, agentJNI, agentThreadArg);\n+\n+    set_agent_thread_state(TERMINATED);\n+  }\n+\n+  \/* finalize agent thread *\/\n+  {\n+    \/* gelete global ref for agent thread *\/\n+    agentJNI->DeleteGlobalRef(agentThread);\n+    agentThread = NULL;\n+  }\n+}\n+\n+\n+\/** Start wrapper for user agent thread. *\/\n+static jthread startAgentThreadWrapper(JNIEnv *jni_env, jvmtiEnv* jvmti_env) {\n+  const jint  THREAD_PRIORITY = JVMTI_THREAD_MAX_PRIORITY;\n+  const char* THREAD_NAME = \"JVMTI agent thread\";\n+  const char* THREAD_CLASS_NAME = \"java\/lang\/Thread\";\n+  const char* THREAD_CTOR_NAME = \"<init>\";\n+  const char* THREAD_CTOR_SIGNATURE = \"(Ljava\/lang\/String;)V\";\n+\n+  jobject threadName = NULL;\n+  jclass threadClass = NULL;\n+  jmethodID threadCtor = NULL;\n+  jobject threadObject = NULL;\n+  jobject threadGlobalRef = NULL;\n+  jvmtiError err;\n+\n+  threadClass = jni_env->FindClass(THREAD_CLASS_NAME);\n+  if (threadClass == NULL) {\n+    return NULL;\n+  }\n+\n+  threadCtor = jni_env->GetMethodID(threadClass, THREAD_CTOR_NAME, THREAD_CTOR_SIGNATURE);\n+  if (threadCtor == NULL) {\n+    return NULL;\n+  }\n+\n+  threadName = jni_env->NewStringUTF(THREAD_NAME);\n+  if (threadName == NULL) {\n+    return NULL;\n+  }\n+\n+  threadObject = jni_env->NewObject(threadClass, threadCtor, threadName);\n+  if (threadObject == NULL) {\n+    return NULL;\n+  }\n+\n+  threadGlobalRef = jni_env->NewGlobalRef(threadObject);\n+  if (threadGlobalRef == NULL) {\n+    jni_env->DeleteLocalRef(threadObject);\n+    return NULL;\n+  }\n+  agentThread = (jthread)threadGlobalRef;\n+\n+  err = jvmti_env->RunAgentThread(agentThread, &agentThreadWrapper, agentThreadArg, THREAD_PRIORITY);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni_env->DeleteGlobalRef(threadGlobalRef);\n+    jni_env->DeleteLocalRef(threadObject);\n+    return NULL;\n+  }\n+  return agentThread;\n+}\n+\n+\/** Run registered user agent thread via wrapper. *\/\n+static jthread nsk_jvmti_runAgentThread(JNIEnv *jni_env, jvmtiEnv* jvmti_env) {\n+  \/* start agent thread wrapper *\/\n+  jthread thread = startAgentThreadWrapper(jni_env, jvmti_env);\n+  if (thread == NULL) {\n+    nsk_jvmti_setFailStatus();\n+    return NULL;\n+  }\n+\n+  return thread;\n+}\n+\n+\/** Sync point called from Java code. *\/\n+static jint syncDebuggeeStatus(JNIEnv* jni_env, jvmtiEnv* jvmti_env, jint debuggeeStatus) {\n+  jint result = NSK_STATUS_FAILED;\n+\n+  printf(\"Data %p %p\\n\", jvmti_env, agent_data.monitor);\n+  rawMonitorEnter(jvmti_env, agent_data.monitor);\n+\n+  \/* save last debugee status *\/\n+  agent_data.last_debuggee_status = debuggeeStatus;\n+\n+  \/* we don't enter if-stmt in second call *\/\n+  if (agent_data.thread_state == NEW) {\n+    if (nsk_jvmti_runAgentThread(jni_env, jvmti_env) == NULL)\n+      goto monitor_exit_and_return;\n+\n+    \/* SP2.2-w - wait for agent thread *\/\n+    while (agent_data.thread_state == NEW) {\n+      rawMonitorWait(jvmti_env, agent_data.monitor, 0);\n+    }\n+  }\n+\n+  \/* wait for sync permit *\/\n+  \/* we don't enter loop in first call *\/\n+  while (agent_data.thread_state != WAITING && agent_data.thread_state != TERMINATED) {\n+    \/* SP4.2-w - second wait for agent thread *\/\n+    rawMonitorWait(jvmti_env, agent_data.monitor, 0);\n+  }\n+\n+  if (agent_data.thread_state != TERMINATED) {\n+    agent_data.thread_state = SUSPENDED;\n+    \/* SP3.2-n - notify to start test *\/\n+    \/* SP6.2-n - notify to end test *\/\n+    rawMonitorNotify(jvmti_env, agent_data.monitor);\n+  } else {\n+    NSK_COMPLAIN0(\"Debuggee status sync aborted because agent thread has finished\\n\");\n+    goto monitor_exit_and_return;\n+  }\n+\n+  \/* update status from debuggee *\/\n+  if (debuggeeStatus != NSK_STATUS_PASSED) {\n+    printf(\"FAIL: Status is %d\\n\", debuggeeStatus);\n+    nsk_jvmti_setFailStatus();\n+  }\n+\n+  while (agent_data.thread_state == SUSPENDED) {\n+    \/* SP5.2-w - wait while testing *\/\n+    \/* SP7.2 - wait for agent end *\/\n+    rawMonitorWait(jvmti_env, agent_data.monitor, 0);\n+  }\n+\n+  agent_data.last_debuggee_status = nsk_jvmti_getStatus();\n+  result = agent_data.last_debuggee_status;\n+\n+  monitor_exit_and_return:\n+  rawMonitorExit(jvmti_env, agent_data.monitor);\n+  return result;\n+}\n+\n+\/** Native function for Java code to provide sync point. *\/\n+JNIEXPORT jint JNICALL\n+Java_jdk_test_lib_jvmti_DebugeeClass_checkStatus(JNIEnv* jni_env, jclass cls, jint debuggeeStatus) {\n+  jint status;\n+  \/\/ TODO NSK_TRACE\n+  status = syncDebuggeeStatus(jni_env, jvmti_env, debuggeeStatus);\n+  return status;\n+}\n+\n+\/** Create JVMTI environment. *\/\n+jvmtiEnv* nsk_jvmti_createJVMTIEnv(JavaVM* javaVM, void* reserved) {\n+  jvm = javaVM;\n+  if (javaVM->GetEnv((void **)&jvmti_env, JVMTI_VERSION_1_1) != JNI_OK) {\n+    nsk_jvmti_setFailStatus();\n+    return NULL;\n+  }\n+\n+  if (init_agent_data(jvmti_env, &agent_data) != 0) {\n+    nsk_jvmti_setFailStatus();\n+    return NULL;\n+  }\n+\n+  return jvmti_env;\n+}\n+\n+}\n+\n+#endif\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_thread.h","additions":356,"deletions":0,"binary":false,"changes":356,"status":"added"}]}