{"files":[{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-import java.io.*;\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/Breakpoint\/breakpoint001.\n- * VM Testbase keywords: [quick, jpda, jvmti, onload_only_caps, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     This test exercises the JVMTI event Breakpoint.\n- *     It verifies that thread info, method info and location of received\n- *     Breakpoint events will be the same with two breakpoints previously\n- *     set on the methods 'bpMethod()' and 'bpMethod2()' via the function\n- *     SetBreakpoint().\n- * COMMENTS\n- *\n- * @library \/test\/lib\n- *\n- * @comment make sure breakpoint001 is compiled with full debug info\n- * @build breakpoint001\n- * @clean breakpoint001\n- * @compile -g:lines,source,vars breakpoint001.java\n- *\n- * @run main\/othervm\/native -agentlib:breakpoint breakpoint001\n- *\/\n-\n-\n-\/**\n- * This test exercises the JVMTI event <code>Breakpoint<\/code>.\n- * <br>It verifies that thread info, method info and location of\n- * received Breakpoint events will be the same with two breakpoints\n- * previously set on the methods <code>bpMethod()<\/code> and\n- * <code>bpMethod2()<\/code> via the function SetBreakpoint().\n- *\/\n-public class breakpoint001 {\n-    static {\n-        try {\n-            System.loadLibrary(\"breakpoint\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load \\\"breakpoint001\\\" library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native int check();\n-\n-    public static void main(String[] argv) {\n-       new breakpoint001().runThis();\n-    }\n-\n-    private int runThis() {\n-        Thread.currentThread().setName(\"breakpoint001Thr\");\n-\n-        System.out.println(\"Reaching a breakpoint method ...\");\n-        bpMethod();\n-        System.out.println(\"The breakpoint method leaved ...\");\n-\n-        return check();\n-    }\n-\n-    \/**\n-     * dummy method used only to reach breakpoint set in the agent\n-     *\/\n-    private void bpMethod() {\n-        int dummyVar = bpMethod2();\n-    }\n-\n-    \/**\n-     * dummy method used only to reach breakpoint set in the agent\n-     *\/\n-    private int bpMethod2() {\n-        return 0;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/breakpoint001\/breakpoint001.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.io.*;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/Breakpoint\/breakpoint001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, onload_only_caps, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test exercises the JVMTI event Breakpoint.\n+ *     It verifies that thread info, method info and location of received\n+ *     Breakpoint events will be the same with two breakpoints previously\n+ *     set on the methods 'bpMethod()' and 'bpMethod2()' via the function\n+ *     SetBreakpoint().\n+ * COMMENTS\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @comment make sure breakpoint01 is compiled with full debug info\n+ * @build breakpoint01\n+ * @clean breakpoint01\n+ * @compile -g:lines,source,vars breakpoint01.java\n+ *\n+ * @run main\/othervm\/native -agentlib:breakpoint01 breakpoint01\n+ *\/\n+\n+\n+\/**\n+ * This test exercises the JVMTI event <code>Breakpoint<\/code>.\n+ * <br>It verifies that thread info, method info and location of\n+ * received Breakpoint events will be the same with two breakpoints\n+ * previously set on the methods <code>bpMethod()<\/code> and\n+ * <code>bpMethod2()<\/code> via the function SetBreakpoint().\n+ *\/\n+public class breakpoint01 {\n+    static {\n+        try {\n+            System.loadLibrary(\"breakpoint01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load \\\"breakpoint01\\\" library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native int check();\n+\n+    public static void main(String[] argv) {\n+       new breakpoint01().runThis();\n+    }\n+\n+    private int runThis() {\n+        Thread.currentThread().setName(\"breakpoint01Thr\");\n+\n+        System.out.println(\"Reaching a breakpoint method ...\");\n+        bpMethod();\n+        System.out.println(\"The breakpoint method leaved ...\");\n+\n+        return check();\n+    }\n+\n+    \/**\n+     * dummy method used only to reach breakpoint set in the agent\n+     *\/\n+    private void bpMethod() {\n+        int dummyVar = bpMethod2();\n+    }\n+\n+    \/**\n+     * dummy method used only to reach breakpoint set in the agent\n+     *\/\n+    private int bpMethod2() {\n+        return 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/breakpoint01\/breakpoint01.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -45,1 +45,1 @@\n-    \"Lbreakpoint001;\";\n+    \"Lbreakpoint01;\";\n@@ -47,1 +47,1 @@\n-static const char *THREAD_NAME = \"breakpoint001Thr\";\n+static const char *THREAD_NAME = \"breakpoint01Thr\";\n@@ -221,1 +221,1 @@\n-JNIEXPORT jint JNICALL Java_breakpoint001_check(\n+JNIEXPORT jint JNICALL Java_breakpoint01_check(\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/breakpoint01\/libbreakpoint01.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/breakpoint001\/libbreakpoint.cpp","status":"renamed"},{"patch":"@@ -46,1 +46,1 @@\n- * @run main\/othervm\/native -agentlib:classload classload001\n+ * @run main\/othervm\/native -agentlib:classload01 classload01\n@@ -60,1 +60,1 @@\n-public class classload001 {\n+public class classload01 {\n@@ -63,1 +63,1 @@\n-            System.loadLibrary(\"classload001\");\n+            System.loadLibrary(\"classload01\");\n@@ -65,1 +65,1 @@\n-            System.err.println(\"Could not load \\\"classload001\\\" library\");\n+            System.err.println(\"Could not load \\\"classload01\\\" library\");\n@@ -75,1 +75,1 @@\n-        int result = new classload001().check();\n+        int result = new classload01().check();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassLoad\/classload01\/classload01.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassLoad\/classload001\/classload001.java","status":"renamed"},{"patch":"@@ -38,2 +38,2 @@\n-    \"Lclassload001;\",\n-    \"Lclassload001$TestedClass;\"\n+    \"Lclassload01;\",\n+    \"Lclassload01$TestedClass;\"\n@@ -62,1 +62,1 @@\n-    \"[Lclassload001$TestedClass;\"\n+    \"[Lclassload01$TestedClass;\"\n@@ -147,1 +147,1 @@\n-Java_classload001_check(\n+Java_classload01_check(\n@@ -166,1 +166,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_classload001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_classload01(JavaVM *jvm, char *options, void *reserved) {\n@@ -169,1 +169,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_classload001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_classload01(JavaVM *jvm, char *options, void *reserved) {\n@@ -172,1 +172,1 @@\n-JNIEXPORT jint JNI_OnLoad_classload001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_classload01(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassLoad\/classload01\/libclassload01.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassLoad\/classload001\/libclassload.cpp","status":"renamed"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm\/native -agentlib:classprep classprep001\n+ * @run main\/othervm\/native -agentlib:classprep01 classprep01\n@@ -47,1 +47,1 @@\n-public class classprep001 {\n+public class classprep01 {\n@@ -53,1 +53,1 @@\n-            System.loadLibrary(\"classprep001\");\n+            System.loadLibrary(\"classprep01\");\n@@ -55,1 +55,1 @@\n-            System.err.println(\"Could not load classprep001 library\");\n+            System.err.println(\"Could not load classprep01 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassPrepare\/classprep01\/classprep01.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassPrepare\/classprep001\/classprep001.java","status":"renamed"},{"patch":"@@ -63,2 +63,2 @@\n-    { \"Lclassprep001$TestInterface;\", EXP_STATUS, 2, 1, 0 },\n-    { \"Lclassprep001$TestClass;\", EXP_STATUS, 3, 2, 1 }\n+    { \"Lclassprep01$TestInterface;\", EXP_STATUS, 2, 1, 0 },\n+    { \"Lclassprep01$TestClass;\", EXP_STATUS, 3, 2, 1 }\n@@ -234,1 +234,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_classprep001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_classprep01(JavaVM *jvm, char *options, void *reserved) {\n@@ -237,1 +237,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_classprep001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_classprep01(JavaVM *jvm, char *options, void *reserved) {\n@@ -240,1 +240,1 @@\n-JNIEXPORT jint JNI_OnLoad_classprep001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_classprep01(JavaVM *jvm, char *options, void *reserved) {\n@@ -270,1 +270,1 @@\n-Java_classprep001_getReady(JNIEnv *jni, jclass cls) {\n+Java_classprep01_getReady(JNIEnv *jni, jclass cls) {\n@@ -298,1 +298,1 @@\n-Java_classprep001_check(JNIEnv *jni, jclass cls) {\n+Java_classprep01_check(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassPrepare\/classprep01\/libclassprep01.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassPrepare\/classprep001\/libclassprep.cpp","status":"renamed"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.PrintStream;\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/Exception\/exception001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function Exception.\n- *     The test checks if the parameters of the function contain\n- *     the expected values for the following exceptions thrown by Java methods:\n- *       - custom class exception001c extending Throwable\n- *       - ArithmeticException caused by division with zero devisor\n- *       - IndexOutOfBoundsException caused by using out of range array index\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/test\/lib\n- * @compile exception001a.jasm\n- * @run main\/othervm\/native -agentlib:exception exception001\n- *\/\n-\n-\n-\n-public class exception001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"exception\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load exception001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        int result = check();\n-        if (result != 0) {\n-            throw new RuntimeException(\"check failed with result \" + result);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception001\/exception001.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* Reassembled from the following Java pattern:\n- *\n- * public class exception001a {\n- *     public static void run() {\n- *         exception001b t = new exception001b();\n- *         try {\n- *             t.meth1();\n- *         } catch (Throwable e) {}\n- *         try {\n- *             t.meth2(0);\n- *         } catch (Throwable e) {}\n- *         try {\n- *             t.meth3(2);\n- *         } catch (Throwable e) {}\n- *     }\n- * }\n- *\n- * class exception001b {\n- *     public static void meth1() throws Throwable {\n- *         throw new exception001c();\n- *     }\n- *\n- *     public int meth2(int i) throws ArithmeticException {\n- *         return (10 \/ i);\n- *     }\n- *\n- *     public int meth3(int i) throws IndexOutOfBoundsException {\n- *         int arr[] = {1};\n- *         return arr[i];\n- *     }\n- * }\n- *\n- * class exception001c extends Throwable {\n- * }\n- *\n- *\/\n-\n-super public class exception001a {\n-\n-    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public static Method run:\"()V\" stack 2 locals 2 {\n-        new     class exception001b;\n-        dup;\n-        invokespecial Method exception001b.\"<init>\":\"()V\";\n-        astore_0;\n-    try t0;\n-        invokestatic Method exception001b.meth1:\"()V\";\n-    endtry t0;\n-        goto    L15;\n-    catch t0 java\/lang\/Throwable; \/\/ bci=14\n-        astore_1;\n-    try t1;\n-L15:    aload_0;\n-        iconst_0;\n-        invokevirtual Method exception001b.meth2:\"(I)I\";\n-        pop;\n-    endtry t1;\n-        goto    L25;\n-    catch t1 java\/lang\/Throwable; \/\/ bci=24\n-        astore_1;\n-    try t2;\n-L25:    aload_0;\n-        iconst_2;\n-        invokevirtual Method exception001b.meth3:\"(I)I\";\n-        pop;\n-    endtry t2;\n-        goto    L35;\n-    catch t2 java\/lang\/Throwable; \/\/ bci=34\n-        astore_1;\n-L35:    return;\n-    }\n-\n-}\n-\n-super class exception001b {\n-\n-    Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public static Method meth1:\"()V\"\n-    throws java\/lang\/Throwable\n-    stack 2 locals 0 {\n-        new     class exception001c;\n-        dup;\n-        invokespecial Method exception001c.\"<init>\":\"()V\";\n-        athrow; \/\/ bci=7\n-    }\n-\n-    public Method meth2:\"(I)I\"\n-    throws java\/lang\/ArithmeticException\n-    stack 2 locals 2 {\n-        bipush  10;\n-        iload_1;\n-        idiv;   \/\/ bci=3\n-        ireturn;\n-    }\n-\n-    public Method meth3:\"(I)I\"\n-    throws java\/lang\/IndexOutOfBoundsException\n-    stack 4 locals 3 {\n-        iconst_1;\n-        newarray int;\n-        dup;\n-        iconst_0;\n-        iconst_1;\n-        iastore;\n-        astore_2;\n-        aload_2;\n-        iload_1;\n-        iaload;  \/\/ bci=10\n-        ireturn;\n-    }\n-}\n-\n-super class exception001c extends java\/lang\/Throwable {\n-\n-    Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial Method java\/lang\/Throwable.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception001\/exception001a.jasm","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/Exception\/exception001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function Exception.\n+ *     The test checks if the parameters of the function contain\n+ *     the expected values for the following exceptions thrown by Java methods:\n+ *       - custom class exception01c extending Throwable\n+ *       - ArithmeticException caused by division with zero devisor\n+ *       - IndexOutOfBoundsException caused by using out of range array index\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @compile exception01a.jasm\n+ * @run main\/othervm\/native -agentlib:exception01 exception01\n+ *\/\n+\n+\n+\n+public class exception01 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"exception01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load exception01 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+        int result = check();\n+        if (result != 0) {\n+            throw new RuntimeException(\"check failed with result \" + result);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception01\/exception01.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* Reassembled from the following Java pattern:\n+ *\n+ * public class exception01a {\n+ *     public static void run() {\n+ *         exception01b t = new exception01b();\n+ *         try {\n+ *             t.meth1();\n+ *         } catch (Throwable e) {}\n+ *         try {\n+ *             t.meth2(0);\n+ *         } catch (Throwable e) {}\n+ *         try {\n+ *             t.meth3(2);\n+ *         } catch (Throwable e) {}\n+ *     }\n+ * }\n+ *\n+ * class exception01b {\n+ *     public static void meth1() throws Throwable {\n+ *         throw new exception01c();\n+ *     }\n+ *\n+ *     public int meth2(int i) throws ArithmeticException {\n+ *         return (10 \/ i);\n+ *     }\n+ *\n+ *     public int meth3(int i) throws IndexOutOfBoundsException {\n+ *         int arr[] = {1};\n+ *         return arr[i];\n+ *     }\n+ * }\n+ *\n+ * class exception01c extends Throwable {\n+ * }\n+ *\n+ *\/\n+\n+super public class exception01a {\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method run:\"()V\" stack 2 locals 2 {\n+        new     class exception01b;\n+        dup;\n+        invokespecial Method exception01b.\"<init>\":\"()V\";\n+        astore_0;\n+    try t0;\n+        invokestatic Method exception01b.meth1:\"()V\";\n+    endtry t0;\n+        goto    L15;\n+    catch t0 java\/lang\/Throwable; \/\/ bci=14\n+        astore_1;\n+    try t1;\n+L15:    aload_0;\n+        iconst_0;\n+        invokevirtual Method exception01b.meth2:\"(I)I\";\n+        pop;\n+    endtry t1;\n+        goto    L25;\n+    catch t1 java\/lang\/Throwable; \/\/ bci=24\n+        astore_1;\n+    try t2;\n+L25:    aload_0;\n+        iconst_2;\n+        invokevirtual Method exception01b.meth3:\"(I)I\";\n+        pop;\n+    endtry t2;\n+        goto    L35;\n+    catch t2 java\/lang\/Throwable; \/\/ bci=34\n+        astore_1;\n+L35:    return;\n+    }\n+\n+}\n+\n+super class exception01b {\n+\n+    Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method meth1:\"()V\"\n+    throws java\/lang\/Throwable\n+    stack 2 locals 0 {\n+        new     class exception01c;\n+        dup;\n+        invokespecial Method exception01c.\"<init>\":\"()V\";\n+        athrow; \/\/ bci=7\n+    }\n+\n+    public Method meth2:\"(I)I\"\n+    throws java\/lang\/ArithmeticException\n+    stack 2 locals 2 {\n+        bipush  10;\n+        iload_1;\n+        idiv;   \/\/ bci=3\n+        ireturn;\n+    }\n+\n+    public Method meth3:\"(I)I\"\n+    throws java\/lang\/IndexOutOfBoundsException\n+    stack 4 locals 3 {\n+        iconst_1;\n+        newarray int;\n+        dup;\n+        iconst_0;\n+        iconst_1;\n+        iastore;\n+        astore_2;\n+        aload_2;\n+        iload_1;\n+        iaload;  \/\/ bci=10\n+        ireturn;\n+    }\n+}\n+\n+super class exception01c extends java\/lang\/Throwable {\n+\n+    Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial Method java\/lang\/Throwable.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception01\/exception01a.jasm","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -65,3 +65,3 @@\n-    { \"Lexception001c;\",\n-        \"Lexception001b;\", \"meth1\", \"()V\", 7,\n-        \"Lexception001a;\", \"run\", \"()V\", 14 },\n+    { \"Lexception01c;\",\n+        \"Lexception01b;\", \"meth1\", \"()V\", 7,\n+        \"Lexception01a;\", \"run\", \"()V\", 14 },\n@@ -69,2 +69,2 @@\n-        \"Lexception001b;\", \"meth2\", \"(I)I\", 3,\n-        \"Lexception001a;\", \"run\", \"()V\", 24 },\n+        \"Lexception01b;\", \"meth2\", \"(I)I\", 3,\n+        \"Lexception01a;\", \"run\", \"()V\", 24 },\n@@ -72,2 +72,2 @@\n-        \"Lexception001b;\", \"meth3\", \"(I)I\", 10,\n-        \"Lexception001a;\", \"run\", \"()V\", 34 }\n+        \"Lexception01b;\", \"meth3\", \"(I)I\", 10,\n+        \"Lexception01a;\", \"run\", \"()V\", 34 }\n@@ -182,1 +182,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_exception001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_exception01(JavaVM *jvm, char *options, void *reserved) {\n@@ -185,1 +185,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_exception001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_exception01(JavaVM *jvm, char *options, void *reserved) {\n@@ -188,1 +188,1 @@\n-JNIEXPORT jint JNI_OnLoad_exception001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_exception01(JavaVM *jvm, char *options, void *reserved) {\n@@ -243,1 +243,1 @@\n-Java_exception001_check(JNIEnv *jni, jclass cls) {\n+Java_exception01_check(JNIEnv *jni, jclass cls) {\n@@ -258,1 +258,1 @@\n-  clz = jni->FindClass(\"exception001c\");\n+  clz = jni->FindClass(\"exception01c\");\n@@ -260,1 +260,1 @@\n-    printf(\"Cannot find exception001c class!\\n\");\n+    printf(\"Cannot find exception01c class!\\n\");\n@@ -263,1 +263,1 @@\n-  clz = jni->FindClass(\"exception001b\");\n+  clz = jni->FindClass(\"exception01b\");\n@@ -265,1 +265,1 @@\n-    printf(\"Cannot find exception001b class!\\n\");\n+    printf(\"Cannot find exception01b class!\\n\");\n@@ -268,1 +268,1 @@\n-  clz = jni->FindClass(\"exception001a\");\n+  clz = jni->FindClass(\"exception01a\");\n@@ -270,1 +270,1 @@\n-    printf(\"Cannot find exception001a class!\\n\");\n+    printf(\"Cannot find exception01a class!\\n\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception01\/libexception01.cpp","additions":17,"deletions":17,"binary":false,"changes":34,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception001\/libexception.cpp","status":"renamed"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ExceptionCatch\/excatch001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercise JVMTI event callback function ExceptionCatch.\n- *     The test checks if the parameters of the function contain the\n- *     expected values for the following exceptions thrown by Java methods:\n- *       - custom class exception001c extending Throwable\n- *       - ArithmeticException caused by division with zero devisor\n- *       - IndexOutOfBoundsException caused by using out of range array index\n- * COMMENTS\n- *     Ported from JVMDI.\n- *\n- * @library \/test\/lib\n- * @compile excatch001a.jasm\n- * @run main\/othervm\/native -agentlib:excatch excatch001\n- *\/\n-\n-\n-\n-public class excatch001 {\n-\n-    final static int JCK_STATUS_BASE = 95;\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"excatch\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load excatch001 library\");\n-            System.err.println(\"java.library.path:\"\n-                + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    native static int check();\n-\n-    public static void main(String args[]) {\n-        int res = check();\n-        if (res != 0) {\n-            throw new RuntimeException(\"Check() returned \" + res);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch001\/excatch001.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* Reassembled from the following Java pattern:\n- *\n- * public class excatch001a {\n- *     public static void run() {\n- *         excatch001b t = new excatch001b();\n- *         try {\n- *             t.meth1();\n- *         } catch (Throwable e) {}\n- *         try {\n- *             t.meth2(0);\n- *         } catch (Throwable e) {}\n- *         try {\n- *             t.meth3(2);\n- *         } catch (Throwable e) {}\n- *     }\n- * }\n- *\n- * class excatch001b {\n- *     public static void meth1() throws Throwable {\n- *         throw new excatch001c();\n- *     }\n- *\n- *     public int meth2(int i) throws ArithmeticException {\n- *         return (10 \/ i);\n- *     }\n- *\n- *     public int meth3(int i) throws IndexOutOfBoundsException {\n- *         int arr[] = {1};\n- *         return arr[i];\n- *     }\n- * }\n- *\n- * class excatch001c extends Throwable {\n- * }\n- *\n- *\/\n-\n-super public class excatch001a {\n-\n-    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public static Method run:\"()V\" stack 2 locals 2 {\n-        new     class excatch001b;\n-        dup;\n-        invokespecial Method excatch001b.\"<init>\":\"()V\";\n-        astore_0;\n-    try t0;\n-        invokestatic Method excatch001b.meth1:\"()V\";\n-    endtry t0;\n-        goto    L15;\n-    catch t0 java\/lang\/Throwable; \/\/ bci=14\n-        astore_1;\n-    try t1;\n-L15:    aload_0;\n-        iconst_0;\n-        invokevirtual Method excatch001b.meth2:\"(I)I\";\n-        pop;\n-    endtry t1;\n-        goto    L25;\n-    catch t1 java\/lang\/Throwable; \/\/ bci=24\n-        astore_1;\n-    try t2;\n-L25:    aload_0;\n-        iconst_2;\n-        invokevirtual Method excatch001b.meth3:\"(I)I\";\n-        pop;\n-    endtry t2;\n-        goto    L35;\n-    catch t2 java\/lang\/Throwable; \/\/ bci=34\n-        astore_1;\n-L35:    return;\n-    }\n-\n-}\n-\n-super class excatch001b {\n-\n-    Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-    public static Method meth1:\"()V\"\n-    throws java\/lang\/Throwable\n-    stack 2 locals 0 {\n-        new     class excatch001c;\n-        dup;\n-        invokespecial Method excatch001c.\"<init>\":\"()V\";\n-        athrow; \/\/ bci=7\n-    }\n-\n-    public Method meth2:\"(I)I\"\n-    throws java\/lang\/ArithmeticException\n-    stack 2 locals 2 {\n-        bipush  10;\n-        iload_1;\n-        idiv;   \/\/ bci=3\n-        ireturn;\n-    }\n-\n-    public Method meth3:\"(I)I\"\n-    throws java\/lang\/IndexOutOfBoundsException\n-    stack 4 locals 3 {\n-        iconst_1;\n-        newarray int;\n-        dup;\n-        iconst_0;\n-        iconst_1;\n-        iastore;\n-        astore_2;\n-        aload_2;\n-        iload_1;\n-        iaload;  \/\/ bci=10\n-        ireturn;\n-    }\n-}\n-\n-super class excatch001c extends java\/lang\/Throwable {\n-\n-    Method \"<init>\":\"()V\" stack 1 locals 1 {\n-        aload_0;\n-        invokespecial Method java\/lang\/Throwable.\"<init>\":\"()V\";\n-        return;\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch001\/excatch001a.jasm","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/ExceptionCatch\/excatch001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function ExceptionCatch.\n+ *     The test checks if the parameters of the function contain the\n+ *     expected values for the following exceptions thrown by Java methods:\n+ *       - custom class exception01c extending Throwable\n+ *       - ArithmeticException caused by division with zero devisor\n+ *       - IndexOutOfBoundsException caused by using out of range array index\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @compile excatch01a.jasm\n+ * @run main\/othervm\/native -agentlib:excatch01 excatch01\n+ *\/\n+\n+\n+\n+public class excatch01 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"excatch01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load excatch01 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch01\/excatch01.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* Reassembled from the following Java pattern:\n+ *\n+ * public class excatch01a {\n+ *     public static void run() {\n+ *         excatch01b t = new excatch01b();\n+ *         try {\n+ *             t.meth1();\n+ *         } catch (Throwable e) {}\n+ *         try {\n+ *             t.meth2(0);\n+ *         } catch (Throwable e) {}\n+ *         try {\n+ *             t.meth3(2);\n+ *         } catch (Throwable e) {}\n+ *     }\n+ * }\n+ *\n+ * class excatch01b {\n+ *     public static void meth1() throws Throwable {\n+ *         throw new excatch01c();\n+ *     }\n+ *\n+ *     public int meth2(int i) throws ArithmeticException {\n+ *         return (10 \/ i);\n+ *     }\n+ *\n+ *     public int meth3(int i) throws IndexOutOfBoundsException {\n+ *         int arr[] = {1};\n+ *         return arr[i];\n+ *     }\n+ * }\n+ *\n+ * class excatch01c extends Throwable {\n+ * }\n+ *\n+ *\/\n+\n+super public class excatch01a {\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method run:\"()V\" stack 2 locals 2 {\n+        new     class excatch01b;\n+        dup;\n+        invokespecial Method excatch01b.\"<init>\":\"()V\";\n+        astore_0;\n+    try t0;\n+        invokestatic Method excatch01b.meth1:\"()V\";\n+    endtry t0;\n+        goto    L15;\n+    catch t0 java\/lang\/Throwable; \/\/ bci=14\n+        astore_1;\n+    try t1;\n+L15:    aload_0;\n+        iconst_0;\n+        invokevirtual Method excatch01b.meth2:\"(I)I\";\n+        pop;\n+    endtry t1;\n+        goto    L25;\n+    catch t1 java\/lang\/Throwable; \/\/ bci=24\n+        astore_1;\n+    try t2;\n+L25:    aload_0;\n+        iconst_2;\n+        invokevirtual Method excatch01b.meth3:\"(I)I\";\n+        pop;\n+    endtry t2;\n+        goto    L35;\n+    catch t2 java\/lang\/Throwable; \/\/ bci=34\n+        astore_1;\n+L35:    return;\n+    }\n+\n+}\n+\n+super class excatch01b {\n+\n+    Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method meth1:\"()V\"\n+    throws java\/lang\/Throwable\n+    stack 2 locals 0 {\n+        new     class excatch01c;\n+        dup;\n+        invokespecial Method excatch01c.\"<init>\":\"()V\";\n+        athrow; \/\/ bci=7\n+    }\n+\n+    public Method meth2:\"(I)I\"\n+    throws java\/lang\/ArithmeticException\n+    stack 2 locals 2 {\n+        bipush  10;\n+        iload_1;\n+        idiv;   \/\/ bci=3\n+        ireturn;\n+    }\n+\n+    public Method meth3:\"(I)I\"\n+    throws java\/lang\/IndexOutOfBoundsException\n+    stack 4 locals 3 {\n+        iconst_1;\n+        newarray int;\n+        dup;\n+        iconst_0;\n+        iconst_1;\n+        iastore;\n+        astore_2;\n+        aload_2;\n+        iload_1;\n+        iaload;  \/\/ bci=10\n+        ireturn;\n+    }\n+}\n+\n+super class excatch01c extends java\/lang\/Throwable {\n+\n+    Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial Method java\/lang\/Throwable.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch01\/excatch01a.jasm","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -57,2 +57,2 @@\n-  { \"Lexcatch001c;\",\n-    \"Lexcatch001a;\", \"run\", \"()V\", 14 },\n+  { \"Lexcatch01c;\",\n+    \"Lexcatch01a;\", \"run\", \"()V\", 14 },\n@@ -60,1 +60,1 @@\n-    \"Lexcatch001a;\", \"run\", \"()V\", 24 },\n+    \"Lexcatch01a;\", \"run\", \"()V\", 24 },\n@@ -62,1 +62,1 @@\n-    \"Lexcatch001a;\", \"run\", \"()V\", 34 }\n+    \"Lexcatch01a;\", \"run\", \"()V\", 34 }\n@@ -138,1 +138,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_excatch001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_excatch01(JavaVM *jvm, char *options, void *reserved) {\n@@ -141,1 +141,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_excatch001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_excatch01(JavaVM *jvm, char *options, void *reserved) {\n@@ -144,1 +144,1 @@\n-JNIEXPORT jint JNI_OnLoad_excatch001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_excatch01(JavaVM *jvm, char *options, void *reserved) {\n@@ -199,1 +199,1 @@\n-Java_excatch001_check(JNIEnv *jni, jclass cls) {\n+Java_excatch01_check(JNIEnv *jni, jclass cls) {\n@@ -213,1 +213,1 @@\n-    clz = jni->FindClass(\"excatch001c\");\n+    clz = jni->FindClass(\"excatch01c\");\n@@ -215,1 +215,1 @@\n-        printf(\"Cannot find excatch001c class!\\n\");\n+        printf(\"Cannot find excatch01c class!\\n\");\n@@ -218,1 +218,1 @@\n-    clz = jni->FindClass(\"excatch001b\");\n+    clz = jni->FindClass(\"excatch01b\");\n@@ -220,1 +220,1 @@\n-        printf(\"Cannot find excatch001b class!\\n\");\n+        printf(\"Cannot find excatch01b class!\\n\");\n@@ -223,1 +223,1 @@\n-    clz = jni->FindClass(\"excatch001a\");\n+    clz = jni->FindClass(\"excatch01a\");\n@@ -225,1 +225,1 @@\n-        printf(\"Cannot find excatch001a class!\\n\");\n+        printf(\"Cannot find excatch01a class!\\n\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch01\/libexcatch01.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch001\/libexcatch.cpp","status":"renamed"},{"patch":"@@ -1,367 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-  jfieldID fid;\n-  char *m_cls;\n-  char *m_name;\n-  char *m_sig;\n-  jlocation loc;\n-  char *f_cls;\n-  char *f_name;\n-  char *f_sig;\n-  jboolean is_static;\n-} writable_watch_info;\n-\n-typedef struct {\n-  jfieldID fid;\n-  const char *m_cls;\n-  const char *m_name;\n-  const char *m_sig;\n-  jlocation loc;\n-  const char *f_cls;\n-  const char *f_name;\n-  const char *f_sig;\n-  jboolean is_static;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 2,\n-        \"Lfieldacc001a;\", \"staticBoolean\", \"Z\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 6,\n-        \"Lfieldacc001a;\", \"instanceBoolean\", \"Z\", JNI_FALSE },\n-    { NULL, \"Lfieldacc001a;\",   \"run\", \"()I\", 15,\n-        \"Lfieldacc001a;\", \"staticByte\", \"B\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 19,\n-        \"Lfieldacc001a;\", \"instanceByte\", \"B\", JNI_FALSE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 28,\n-        \"Lfieldacc001a;\", \"staticShort\", \"S\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 32,\n-        \"Lfieldacc001a;\", \"instanceShort\", \"S\", JNI_FALSE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 41,\n-        \"Lfieldacc001a;\", \"staticInt\", \"I\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 45,\n-        \"Lfieldacc001a;\", \"instanceInt\", \"I\", JNI_FALSE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 54,\n-        \"Lfieldacc001a;\", \"staticLong\", \"J\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 58,\n-        \"Lfieldacc001a;\", \"instanceLong\", \"J\", JNI_FALSE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 68,\n-        \"Lfieldacc001a;\", \"staticFloat\", \"F\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 72,\n-        \"Lfieldacc001a;\", \"instanceFloat\", \"F\", JNI_FALSE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 82,\n-        \"Lfieldacc001a;\", \"staticDouble\", \"D\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 86,\n-        \"Lfieldacc001a;\", \"instanceDouble\", \"D\", JNI_FALSE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 96,\n-        \"Lfieldacc001a;\", \"staticChar\", \"C\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 100,\n-        \"Lfieldacc001a;\", \"instanceChar\", \"C\", JNI_FALSE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 109,\n-        \"Lfieldacc001a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 113,\n-        \"Lfieldacc001a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 122,\n-        \"Lfieldacc001a;\", \"staticArrInt\", \"[I\", JNI_TRUE },\n-    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 128,\n-        \"Lfieldacc001a;\", \"instanceArrInt\", \"[I\", JNI_FALSE }\n-};\n-\n-\n-void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *jni,\n-                         jthread thr, jmethodID method,\n-                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n-  jvmtiError err;\n-  jclass cls;\n-  writable_watch_info watch;\n-  char *generic;\n-  size_t i;\n-\n-  eventsCount++;\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> retrieving access watch info ...\\n\");\n-  }\n-  watch.fid = field;\n-  watch.loc = location;\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-  err = jvmti->GetMethodDeclaringClass(method, &cls);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(cls,\n-                                     &watch.m_cls, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetMethodName(method,\n-                                 &watch.m_name, &watch.m_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(field_klass,\n-                                     &watch.f_cls, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetFieldName(field_klass, field,\n-                                &watch.f_name, &watch.f_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-    printf(\">>>   location: 0x%x%08x\\n\",\n-           (jint)(watch.loc >> 32), (jint)watch.loc);\n-    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-    printf(\">>>     object: 0x%p\\n\", obj);\n-    printf(\">>> ... done\\n\");\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    if (watch.fid == watches[i].fid) {\n-      if (watch.m_cls == NULL ||\n-          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-               i, watch.m_cls, watches[i].m_cls);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_name == NULL ||\n-          strcmp(watch.m_name, watches[i].m_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-               i, watch.m_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_sig == NULL ||\n-          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-               i, watch.m_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.loc != watches[i].loc) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\", expected: 0x%x%08x\\n\",\n-               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_name == NULL ||\n-          strcmp(watch.f_name, watches[i].f_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-               i, watch.f_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_sig == NULL ||\n-          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-               i, watch.f_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.is_static != watches[i].is_static) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        printf(\", expected: %s\\n\",\n-               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        result = STATUS_FAILED;\n-      }\n-      return;\n-    }\n-  }\n-  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n-  result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldacc001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-  jvmtiError err;\n-  jint res;\n-\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-    printdump = JNI_TRUE;\n-  }\n-\n-  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetPotentialCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->AddCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  if (caps.can_generate_field_access_events) {\n-    callbacks.FieldAccess = &FieldAccess;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-  } else {\n-    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-\n-JNIEXPORT void JNICALL\n-Java_fieldacc001_getReady(JNIEnv *jni, jclass klass) {\n-  jvmtiError err;\n-  jclass cls;\n-  size_t i;\n-\n-  if (!caps.can_generate_field_access_events) {\n-    return;\n-  }\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> setting field access watches ...\\n\");\n-  }\n-  cls = jni->FindClass(\"fieldacc001a\");\n-  if (cls == NULL) {\n-    printf(\"Cannot find fieldacc001a class!\\n\");\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    if (watches[i].is_static == JNI_TRUE) {\n-      watches[i].fid = jni->GetStaticFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    } else {\n-      watches[i].fid = jni->GetFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    }\n-    if (watches[i].fid == NULL) {\n-      printf(\"Cannot find field \\\"%s\\\"!\\n\", watches[i].f_name);\n-      result = STATUS_FAILED;\n-      return;\n-    }\n-    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n-    if (err == JVMTI_ERROR_NONE) {\n-      eventsExpected++;\n-    } else {\n-      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-             i, TranslateError(err), err);\n-      result = STATUS_FAILED;\n-    }\n-  }\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> ... done\\n\");\n-  }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_fieldacc001_check(JNIEnv *jni, jclass cls) {\n-  if (eventsCount != eventsExpected) {\n-    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n-           eventsCount, eventsExpected);\n-    result = STATUS_FAILED;\n-  }\n-  return result;\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc001\/libfieldacc01.cpp","additions":0,"deletions":367,"binary":false,"changes":367,"status":"deleted"},{"patch":"@@ -1,408 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-  jfieldID fid;\n-  char *m_cls;\n-  char *m_name;\n-  char *m_sig;\n-  jlocation loc;\n-  char *f_cls;\n-  char *f_name;\n-  char *f_sig;\n-  jboolean is_static;\n-} writable_watch_info;\n-\n-typedef struct {\n-  jfieldID fid;\n-  const char *m_cls;\n-  const char *m_name;\n-  const char *m_sig;\n-  jlocation loc;\n-  const char *f_cls;\n-  const char *f_name;\n-  const char *f_sig;\n-  jboolean is_static;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticBoolean\", \"Z\", JNI_TRUE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticByte\", \"B\", JNI_TRUE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticShort\", \"S\", JNI_TRUE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticInt\", \"I\", JNI_TRUE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticLong\", \"J\", JNI_TRUE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticFloat\", \"F\", JNI_TRUE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticDouble\", \"D\", JNI_TRUE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticChar\", \"C\", JNI_TRUE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"staticArrInt\", \"[I\", JNI_TRUE },\n-\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceBoolean\", \"Z\", JNI_FALSE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceByte\", \"B\", JNI_FALSE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceShort\", \"S\", JNI_FALSE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceInt\", \"I\", JNI_FALSE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceLong\", \"J\", JNI_FALSE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceFloat\", \"F\", JNI_FALSE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceDouble\", \"D\", JNI_FALSE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceChar\", \"C\", JNI_FALSE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n-    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldacc002a;\", \"instanceArrInt\", \"[I\", JNI_FALSE }\n-};\n-\n-void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *jni,\n-                         jthread thr, jmethodID method,\n-                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n-  jvmtiError err;\n-  jclass cls;\n-  writable_watch_info watch;\n-  char *generic;\n-  size_t i;\n-\n-  eventsCount++;\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> retrieving access watch info ...\\n\");\n-  }\n-  watch.fid = field;\n-  watch.loc = location;\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-  err = jvmti->GetMethodDeclaringClass(method, &cls);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(cls,\n-                                     &watch.m_cls, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetMethodName(method,\n-                                 &watch.m_name, &watch.m_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(field_klass,\n-                                     &watch.f_cls, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetFieldName(field_klass, field,\n-                                &watch.f_name, &watch.f_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-    printf(\">>>   location: 0x%x%08x\\n\",\n-           (jint)(watch.loc >> 32), (jint)watch.loc);\n-    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-    printf(\">>>     object: 0x%p\\n\", obj);\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    if (watch.fid == watches[i].fid) {\n-      if (watch.m_cls == NULL ||\n-          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-               i, watch.m_cls, watches[i].m_cls);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_name == NULL ||\n-          strcmp(watch.m_name, watches[i].m_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-               i, watch.m_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_sig == NULL ||\n-          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-               i, watch.m_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.loc != watches[i].loc) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\", expected: 0x%x%08x\\n\",\n-               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_name == NULL ||\n-          strcmp(watch.f_name, watches[i].f_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-               i, watch.f_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_sig == NULL ||\n-          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-               i, watch.f_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.is_static != watches[i].is_static) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        printf(\", expected: %s\\n\",\n-               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        result = STATUS_FAILED;\n-      }\n-      return;\n-    }\n-  }\n-  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n-  result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldacc002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-  jvmtiError err;\n-  jint res;\n-\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-    printdump = JNI_TRUE;\n-  }\n-\n-  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetPotentialCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->AddCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  if (caps.can_generate_field_access_events) {\n-    callbacks.FieldAccess = &FieldAccess;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-  } else {\n-    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL Java_fieldacc002_getReady(JNIEnv *jni, jclass clz) {\n-  jvmtiError err;\n-  jclass cls;\n-  size_t i;\n-\n-  if (!caps.can_generate_field_access_events) {\n-    return;\n-  }\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> setting field access watches ...\\n\");\n-  }\n-\n-  cls = jni->FindClass(\"fieldacc002a\");\n-  if (cls == NULL) {\n-    printf(\"Cannot find fieldacc002a class!\\n\");\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    if (watches[i].is_static == JNI_TRUE) {\n-      watches[i].fid = jni->GetStaticFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    } else {\n-      watches[i].fid = jni->GetFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    }\n-    if (watches[i].fid == NULL) {\n-      printf(\"Cannot find field \\\"%s\\\"!\\n\", watches[i].f_name);\n-      result = STATUS_FAILED;\n-      return;\n-    }\n-    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n-    if (err == JVMTI_ERROR_NONE) {\n-      eventsExpected++;\n-    } else {\n-      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-             i, TranslateError(err), err);\n-      result = STATUS_FAILED;\n-    }\n-  }\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> ... done\\n\");\n-  }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_fieldacc002_check(JNIEnv *jni, jclass clz, jobject obj) {\n-  jclass cls;\n-\n-  if (!caps.can_generate_field_access_events) {\n-    return result;\n-  }\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> accessing fields ...\\n\");\n-  }\n-\n-  cls = jni->FindClass(\"fieldacc002a\");\n-  if (cls == NULL) {\n-    printf(\"Cannot find fieldacc002a class!\\n\");\n-    return STATUS_FAILED;\n-  }\n-\n-  jni->GetStaticBooleanField(cls, watches[0].fid);\n-  jni->GetStaticByteField(cls, watches[1].fid);\n-  jni->GetStaticShortField(cls, watches[2].fid);\n-  jni->GetStaticIntField(cls, watches[3].fid);\n-  jni->GetStaticLongField(cls, watches[4].fid);\n-  jni->GetStaticFloatField(cls, watches[5].fid);\n-  jni->GetStaticDoubleField(cls, watches[6].fid);\n-  jni->GetStaticCharField(cls, watches[7].fid);\n-  jni->GetStaticObjectField(cls, watches[8].fid);\n-  jni->GetStaticObjectField(cls, watches[9].fid);\n-\n-  jni->GetBooleanField(obj, watches[10].fid);\n-  jni->GetByteField(obj, watches[11].fid);\n-  jni->GetShortField(obj, watches[12].fid);\n-  jni->GetIntField(obj, watches[13].fid);\n-  jni->GetLongField(obj, watches[14].fid);\n-  jni->GetFloatField(obj, watches[15].fid);\n-  jni->GetDoubleField(obj, watches[16].fid);\n-  jni->GetCharField(obj, watches[17].fid);\n-  jni->GetObjectField(obj, watches[18].fid);\n-  jni->GetObjectField(obj, watches[19].fid);\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> ... done\\n\");\n-  }\n-\n-  if (eventsCount != eventsExpected) {\n-    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n-           eventsCount, eventsExpected);\n-    result = STATUS_FAILED;\n-  }\n-  return result;\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc002\/libfieldacc02.cpp","additions":0,"deletions":408,"binary":false,"changes":408,"status":"deleted"},{"patch":"@@ -1,346 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-  jfieldID fid;\n-  char *m_cls;\n-  char *m_name;\n-  char *m_sig;\n-  jlocation loc;\n-  char *f_cls;\n-  char *f_name;\n-  char *f_sig;\n-  jboolean is_static;\n-} writable_watch_info;\n-\n-typedef struct {\n-  jfieldID fid;\n-  const char *m_cls;\n-  const char *m_name;\n-  const char *m_sig;\n-  jlocation loc;\n-  const char *f_cls;\n-  const char *f_name;\n-  const char *f_sig;\n-  jboolean is_static;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 3,\n-        \"Lfieldacc003a;\", \"extendsBoolean\", \"Z\", JNI_FALSE },\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 14,\n-        \"Lfieldacc003a;\", \"extendsByte\", \"B\", JNI_FALSE },\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 25,\n-        \"Lfieldacc003a;\", \"extendsShort\", \"S\", JNI_FALSE },\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 36,\n-        \"Lfieldacc003a;\", \"extendsInt\", \"I\", JNI_FALSE },\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 47,\n-        \"Lfieldacc003a;\", \"extendsLong\", \"J\", JNI_FALSE },\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 61,\n-        \"Lfieldacc003a;\", \"extendsFloat\", \"F\", JNI_FALSE },\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 74,\n-        \"Lfieldacc003a;\", \"extendsDouble\", \"D\", JNI_FALSE },\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 88,\n-        \"Lfieldacc003a;\", \"extendsChar\", \"C\", JNI_FALSE },\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 100,\n-        \"Lfieldacc003a;\", \"extendsObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n-    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 111,\n-        \"Lfieldacc003a;\", \"extendsArrInt\", \"[I\", JNI_FALSE }\n-};\n-\n-void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *jni,\n-                         jthread thr, jmethodID method,\n-                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n-  jvmtiError err;\n-  jclass cls;\n-  writable_watch_info watch;\n-  char *generic;\n-  size_t i;\n-\n-  eventsCount++;\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> retrieving access watch info ...\\n\");\n-  }\n-  watch.fid = field;\n-  watch.loc = location;\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-  err = jvmti->GetMethodDeclaringClass(method, &cls);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(cls,\n-                                     &watch.m_cls, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetMethodName(method,\n-                                 &watch.m_name, &watch.m_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(field_klass,\n-                                     &watch.f_cls,  &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetFieldName(field_klass, field,\n-                                &watch.f_name, &watch.f_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-    printf(\">>>   location: 0x%x%08x\\n\",\n-           (jint)(watch.loc >> 32), (jint)watch.loc);\n-    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-    printf(\">>>     object: 0x%p\\n\", obj);\n-    printf(\">>> ... done\\n\");\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    if (watch.fid == watches[i].fid) {\n-      if (watch.m_cls == NULL ||\n-          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-               i, watch.m_cls, watches[i].m_cls);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_name == NULL ||\n-          strcmp(watch.m_name, watches[i].m_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-               i, watch.m_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_sig == NULL ||\n-          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-               i, watch.m_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.loc != watches[i].loc) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\", expected: 0x%x%08x\\n\",\n-               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_name == NULL ||\n-          strcmp(watch.f_name, watches[i].f_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-               i, watch.f_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_sig == NULL ||\n-          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-               i, watch.f_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.is_static != watches[i].is_static) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        printf(\", expected: %s\\n\",\n-               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        result = STATUS_FAILED;\n-      }\n-      return;\n-    }\n-  }\n-  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n-  result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc003(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldacc003(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-  jvmtiError err;\n-  jint res;\n-\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-    printdump = JNI_TRUE;\n-  }\n-\n-  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetPotentialCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->AddCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  if (caps.can_generate_field_access_events) {\n-    callbacks.FieldAccess = &FieldAccess;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-  } else {\n-    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_fieldacc003_getReady(JNIEnv *jni, jclass klass) {\n-  jvmtiError err;\n-  jclass cls;\n-  size_t i;\n-\n-  if (!caps.can_generate_field_access_events) {\n-    return;\n-  }\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> setting field access watches ...\\n\");\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    cls = jni->FindClass(watches[i].f_cls);\n-    if (cls == NULL) {\n-      printf(\"Cannot find %s class!\\n\", watches[i].f_cls);\n-      result = STATUS_FAILED;\n-      return;\n-    }\n-    if (watches[i].is_static == JNI_TRUE) {\n-      watches[i].fid = jni->GetStaticFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    } else {\n-      watches[i].fid = jni->GetFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    }\n-    if (watches[i].fid == NULL) {\n-      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n-             watches[i].f_name, watches[i].f_sig);\n-      result = STATUS_FAILED;\n-      return;\n-    }\n-    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n-    if (err == JVMTI_ERROR_NONE) {\n-      eventsExpected++;\n-    } else {\n-      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-             i, TranslateError(err), err);\n-      result = STATUS_FAILED;\n-    }\n-  }\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> ... done\\n\");\n-  }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_fieldacc003_check(JNIEnv *jni, jclass cls) {\n-  if (eventsCount != eventsExpected) {\n-    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n-           eventsCount, eventsExpected);\n-    result = STATUS_FAILED;\n-  }\n-  return result;\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc003\/libfieldacc03.cpp","additions":0,"deletions":346,"binary":false,"changes":346,"status":"deleted"},{"patch":"@@ -42,2 +42,2 @@\n- * @compile fieldacc001a.jasm\n- * @run main\/othervm\/native -agentlib:fieldacc01 fieldacc001\n+ * @compile fieldacc01a.jasm\n+ * @run main\/othervm\/native -agentlib:fieldacc01 fieldacc01\n@@ -48,1 +48,1 @@\n-public class fieldacc001 {\n+public class fieldacc01 {\n@@ -56,1 +56,1 @@\n-            System.err.println(\"Could not load fieldacc001 library\");\n+            System.err.println(\"Could not load fieldacc01 library\");\n@@ -68,1 +68,1 @@\n-        fieldacc001a t = new fieldacc001a();\n+        fieldacc01a t = new fieldacc01a();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc01\/fieldacc01.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc001\/fieldacc001.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-super public class fieldacc001a {\n+super public class fieldacc01a {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc01\/fieldacc01a.jasm","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc001\/fieldacc001a.jasm","status":"renamed"},{"patch":"@@ -0,0 +1,367 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  jboolean is_static;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 2,\n+        \"Lfieldacc01a;\", \"staticBoolean\", \"Z\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 6,\n+        \"Lfieldacc01a;\", \"instanceBoolean\", \"Z\", JNI_FALSE },\n+    { NULL, \"Lfieldacc01a;\",   \"run\", \"()I\", 15,\n+        \"Lfieldacc01a;\", \"staticByte\", \"B\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 19,\n+        \"Lfieldacc01a;\", \"instanceByte\", \"B\", JNI_FALSE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 28,\n+        \"Lfieldacc01a;\", \"staticShort\", \"S\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 32,\n+        \"Lfieldacc01a;\", \"instanceShort\", \"S\", JNI_FALSE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 41,\n+        \"Lfieldacc01a;\", \"staticInt\", \"I\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 45,\n+        \"Lfieldacc01a;\", \"instanceInt\", \"I\", JNI_FALSE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 54,\n+        \"Lfieldacc01a;\", \"staticLong\", \"J\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 58,\n+        \"Lfieldacc01a;\", \"instanceLong\", \"J\", JNI_FALSE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 68,\n+        \"Lfieldacc01a;\", \"staticFloat\", \"F\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 72,\n+        \"Lfieldacc01a;\", \"instanceFloat\", \"F\", JNI_FALSE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 82,\n+        \"Lfieldacc01a;\", \"staticDouble\", \"D\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 86,\n+        \"Lfieldacc01a;\", \"instanceDouble\", \"D\", JNI_FALSE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 96,\n+        \"Lfieldacc01a;\", \"staticChar\", \"C\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 100,\n+        \"Lfieldacc01a;\", \"instanceChar\", \"C\", JNI_FALSE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 109,\n+        \"Lfieldacc01a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 113,\n+        \"Lfieldacc01a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 122,\n+        \"Lfieldacc01a;\", \"staticArrInt\", \"[I\", JNI_TRUE },\n+    { NULL, \"Lfieldacc01a;\", \"run\", \"()I\", 128,\n+        \"Lfieldacc01a;\", \"instanceArrInt\", \"[I\", JNI_FALSE }\n+};\n+\n+\n+void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *jni,\n+                         jthread thr, jmethodID method,\n+                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving access watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+    printf(\">>> ... done\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc01(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc01(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldacc01(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_access_events) {\n+    callbacks.FieldAccess = &FieldAccess;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_fieldacc01_getReady(JNIEnv *jni, jclass klass) {\n+  jvmtiError err;\n+  jclass cls;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_access_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field access watches ...\\n\");\n+  }\n+  cls = jni->FindClass(\"fieldacc01a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldacc01a class!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = jni->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = jni->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot find field \\\"%s\\\"!\\n\", watches[i].f_name);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldacc01_check(JNIEnv *jni, jclass cls) {\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc01\/libfieldacc01.cpp","additions":367,"deletions":0,"binary":false,"changes":367,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm\/native -agentlib:fieldacc02 fieldacc002\n+ * @run main\/othervm\/native -agentlib:fieldacc02 fieldacc02\n@@ -46,1 +46,1 @@\n-public class fieldacc002 {\n+public class fieldacc02 {\n@@ -54,1 +54,1 @@\n-            System.err.println(\"Could not load fieldacc002 library\");\n+            System.err.println(\"Could not load fieldacc02 library\");\n@@ -65,1 +65,1 @@\n-        fieldacc002a t = new fieldacc002a();\n+        fieldacc02a t = new fieldacc02a();\n@@ -74,1 +74,1 @@\n-class fieldacc002a {\n+class fieldacc02a {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc02\/fieldacc02.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc002\/fieldacc002.java","status":"renamed"},{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  jboolean is_static;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticBoolean\", \"Z\", JNI_TRUE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticByte\", \"B\", JNI_TRUE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticShort\", \"S\", JNI_TRUE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticInt\", \"I\", JNI_TRUE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticLong\", \"J\", JNI_TRUE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticFloat\", \"F\", JNI_TRUE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticDouble\", \"D\", JNI_TRUE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticChar\", \"C\", JNI_TRUE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"staticArrInt\", \"[I\", JNI_TRUE },\n+\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceBoolean\", \"Z\", JNI_FALSE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceByte\", \"B\", JNI_FALSE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceShort\", \"S\", JNI_FALSE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceInt\", \"I\", JNI_FALSE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceLong\", \"J\", JNI_FALSE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceFloat\", \"F\", JNI_FALSE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceDouble\", \"D\", JNI_FALSE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceChar\", \"C\", JNI_FALSE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n+    { NULL, \"Lfieldacc02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc02a;\", \"instanceArrInt\", \"[I\", JNI_FALSE }\n+};\n+\n+void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *jni,\n+                         jthread thr, jmethodID method,\n+                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving access watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc02(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc02(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldacc02(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_access_events) {\n+    callbacks.FieldAccess = &FieldAccess;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL Java_fieldacc02_getReady(JNIEnv *jni, jclass clz) {\n+  jvmtiError err;\n+  jclass cls;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_access_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field access watches ...\\n\");\n+  }\n+\n+  cls = jni->FindClass(\"fieldacc02a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldacc02a class!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = jni->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = jni->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot find field \\\"%s\\\"!\\n\", watches[i].f_name);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldacc02_check(JNIEnv *jni, jclass clz, jobject obj) {\n+  jclass cls;\n+\n+  if (!caps.can_generate_field_access_events) {\n+    return result;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> accessing fields ...\\n\");\n+  }\n+\n+  cls = jni->FindClass(\"fieldacc02a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldacc02a class!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  jni->GetStaticBooleanField(cls, watches[0].fid);\n+  jni->GetStaticByteField(cls, watches[1].fid);\n+  jni->GetStaticShortField(cls, watches[2].fid);\n+  jni->GetStaticIntField(cls, watches[3].fid);\n+  jni->GetStaticLongField(cls, watches[4].fid);\n+  jni->GetStaticFloatField(cls, watches[5].fid);\n+  jni->GetStaticDoubleField(cls, watches[6].fid);\n+  jni->GetStaticCharField(cls, watches[7].fid);\n+  jni->GetStaticObjectField(cls, watches[8].fid);\n+  jni->GetStaticObjectField(cls, watches[9].fid);\n+\n+  jni->GetBooleanField(obj, watches[10].fid);\n+  jni->GetByteField(obj, watches[11].fid);\n+  jni->GetShortField(obj, watches[12].fid);\n+  jni->GetIntField(obj, watches[13].fid);\n+  jni->GetLongField(obj, watches[14].fid);\n+  jni->GetFloatField(obj, watches[15].fid);\n+  jni->GetDoubleField(obj, watches[16].fid);\n+  jni->GetCharField(obj, watches[17].fid);\n+  jni->GetObjectField(obj, watches[18].fid);\n+  jni->GetObjectField(obj, watches[19].fid);\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc02\/libfieldacc02.cpp","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm\/native -agentlib:fieldacc03 fieldacc003\n+ * @run main\/othervm\/native -agentlib:fieldacc03 fieldacc03\n@@ -47,1 +47,1 @@\n-public class fieldacc003 {\n+public class fieldacc03 {\n@@ -55,1 +55,1 @@\n-            System.err.println(\"Could not load fieldacc003 library\");\n+            System.err.println(\"Could not load fieldacc03 library\");\n@@ -73,1 +73,1 @@\n-        fieldacc003a t = new fieldacc003a();\n+        fieldacc03a t = new fieldacc03a();\n@@ -79,1 +79,1 @@\n-class fieldacc003e {\n+class fieldacc03e {\n@@ -92,1 +92,1 @@\n-class fieldacc003a extends fieldacc003e {\n+class fieldacc03a extends fieldacc03e {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc03\/fieldacc03.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc003\/fieldacc003.java","status":"renamed"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  jboolean is_static;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 3,\n+        \"Lfieldacc03a;\", \"extendsBoolean\", \"Z\", JNI_FALSE },\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 14,\n+        \"Lfieldacc03a;\", \"extendsByte\", \"B\", JNI_FALSE },\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 25,\n+        \"Lfieldacc03a;\", \"extendsShort\", \"S\", JNI_FALSE },\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 36,\n+        \"Lfieldacc03a;\", \"extendsInt\", \"I\", JNI_FALSE },\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 47,\n+        \"Lfieldacc03a;\", \"extendsLong\", \"J\", JNI_FALSE },\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 61,\n+        \"Lfieldacc03a;\", \"extendsFloat\", \"F\", JNI_FALSE },\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 74,\n+        \"Lfieldacc03a;\", \"extendsDouble\", \"D\", JNI_FALSE },\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 88,\n+        \"Lfieldacc03a;\", \"extendsChar\", \"C\", JNI_FALSE },\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 100,\n+        \"Lfieldacc03a;\", \"extendsObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n+    { NULL, \"Lfieldacc03a;\", \"run\", \"()I\", 111,\n+        \"Lfieldacc03a;\", \"extendsArrInt\", \"[I\", JNI_FALSE }\n+};\n+\n+void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *jni,\n+                         jthread thr, jmethodID method,\n+                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving access watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls,  &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+    printf(\">>> ... done\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc03(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc03(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldacc03(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_access_events) {\n+    callbacks.FieldAccess = &FieldAccess;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_fieldacc03_getReady(JNIEnv *jni, jclass klass) {\n+  jvmtiError err;\n+  jclass cls;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_access_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field access watches ...\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    cls = jni->FindClass(watches[i].f_cls);\n+    if (cls == NULL) {\n+      printf(\"Cannot find %s class!\\n\", watches[i].f_cls);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = jni->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = jni->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n+             watches[i].f_name, watches[i].f_sig);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldacc03_check(JNIEnv *jni, jclass cls) {\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc03\/libfieldacc03.cpp","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm\/native -agentlib:fieldacc04 fieldacc004\n+ * @run main\/othervm\/native -agentlib:fieldacc04 fieldacc04\n@@ -45,1 +45,1 @@\n-public class fieldacc004 {\n+public class fieldacc04 {\n@@ -53,1 +53,1 @@\n-            System.err.println(\"Could not load fieldacc004 library\");\n+            System.err.println(\"Could not load fieldacc04 library\");\n@@ -71,1 +71,1 @@\n-        fieldacc004a t = new fieldacc004a();\n+        fieldacc04a t = new fieldacc04a();\n@@ -77,1 +77,1 @@\n-interface fieldacc004i {\n+interface fieldacc04i {\n@@ -82,1 +82,1 @@\n-class fieldacc004a implements fieldacc004i {\n+class fieldacc04a implements fieldacc04i {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc04\/fieldacc04.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc004\/fieldacc004.java","status":"renamed"},{"patch":"@@ -68,2 +68,2 @@\n-    { NULL, \"Lfieldacc004a;\", \"run\", \"()I\", 2,\n-        \"Lfieldacc004a;\", \"interfaceObject\",\n+    { NULL, \"Lfieldacc04a;\", \"run\", \"()I\", 2,\n+        \"Lfieldacc04a;\", \"interfaceObject\",\n@@ -71,2 +71,2 @@\n-    { NULL, \"Lfieldacc004a;\", \"run\", \"()I\", 12,\n-        \"Lfieldacc004a;\", \"interfaceArrInt\",\n+    { NULL, \"Lfieldacc04a;\", \"run\", \"()I\", 12,\n+        \"Lfieldacc04a;\", \"interfaceArrInt\",\n@@ -199,1 +199,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc004(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc04(JavaVM *jvm, char *options, void *reserved) {\n@@ -202,1 +202,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc004(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc04(JavaVM *jvm, char *options, void *reserved) {\n@@ -205,1 +205,1 @@\n-JNIEXPORT jint JNI_OnLoad_fieldacc004(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_fieldacc04(JavaVM *jvm, char *options, void *reserved) {\n@@ -268,1 +268,1 @@\n-Java_fieldacc004_getReady(JNIEnv *jni, jclass klass) {\n+Java_fieldacc04_getReady(JNIEnv *jni, jclass klass) {\n@@ -315,1 +315,1 @@\n-Java_fieldacc004_check(JNIEnv *jni, jclass cls) {\n+Java_fieldacc04_check(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc04\/libfieldacc04.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc004\/libfieldacc04.cpp","status":"renamed"},{"patch":"@@ -1,467 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-  jfieldID fid;\n-  char *m_cls;\n-  char *m_name;\n-  char *m_sig;\n-  jlocation loc;\n-  char *f_cls;\n-  char *f_name;\n-  char *f_sig;\n-  jboolean is_static;\n-  jvalue val;\n-} writable_watch_info;\n-\n-typedef struct {\n-  jfieldID fid;\n-  const char *m_cls;\n-  const char *m_name;\n-  const char *m_sig;\n-  jlocation loc;\n-  const char *f_cls;\n-  const char *f_name;\n-  const char *f_sig;\n-  const jboolean is_static;\n-  jvalue val;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 1,\n-        \"Lfieldmod001a;\", \"staticBoolean\", \"Z\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 5,\n-        \"Lfieldmod001a;\", \"staticByte\", \"B\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 9,\n-        \"Lfieldmod001a;\", \"staticShort\", \"S\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 13,\n-        \"Lfieldmod001a;\", \"staticInt\", \"I\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 19,\n-        \"Lfieldmod001a;\", \"staticLong\", \"J\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 24,\n-        \"Lfieldmod001a;\", \"staticFloat\", \"F\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 30,\n-        \"Lfieldmod001a;\", \"staticDouble\", \"D\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 35,\n-        \"Lfieldmod001a;\", \"staticChar\", \"C\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 41,\n-        \"Lfieldmod001a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 47,\n-        \"Lfieldmod001a;\", \"staticArrInt\", \"[I\", JNI_TRUE, {} },\n-\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 52,\n-        \"Lfieldmod001a;\", \"instanceBoolean\", \"Z\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 58,\n-        \"Lfieldmod001a;\", \"instanceByte\", \"B\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 64,\n-        \"Lfieldmod001a;\", \"instanceShort\", \"S\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 70,\n-        \"Lfieldmod001a;\", \"instanceInt\", \"I\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 77,\n-        \"Lfieldmod001a;\", \"instanceLong\", \"J\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 83,\n-        \"Lfieldmod001a;\", \"instanceFloat\", \"F\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 90,\n-        \"Lfieldmod001a;\", \"instanceDouble\", \"D\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 96,\n-        \"Lfieldmod001a;\", \"instanceChar\", \"C\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 103,\n-        \"Lfieldmod001a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 110,\n-        \"Lfieldmod001a;\", \"instanceArrInt\", \"[I\", JNI_FALSE, {} }\n-};\n-\n-void printValue(jvalue val, char *sig) {\n-  switch (*sig) {\n-    case 'J':\n-      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n-      break;\n-    case 'F':\n-      printf(\"%.3f\", (double)val.f);\n-      break;\n-    case 'D':\n-      printf(\"%f\", (double)val.d);\n-      break;\n-    case 'L':\n-    case '[':\n-      printf(\"0x%p\", val.l);\n-      break;\n-    case 'Z':\n-      printf(\"0x%x\", val.z);\n-      break;\n-    case 'B':\n-      printf(\"%d\", val.b);\n-      break;\n-    case 'S':\n-      printf(\"%d\", val.s);\n-      break;\n-    case 'C':\n-      printf(\"0x%x\", val.c);\n-      break;\n-    case 'I':\n-      printf(\"%d\", val.i);\n-      break;\n-    default:\n-      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n-      break;\n-  }\n-}\n-\n-int isEqual(JNIEnv *jni, char *sig, jvalue v1, jvalue v2) {\n-  switch (*sig) {\n-    case 'J':\n-      return (v1.j == v2.j);\n-    case 'F':\n-      return (v1.f == v2.f);\n-    case 'D':\n-      return (v1.d == v2.d);\n-    case 'L':\n-    case '[':\n-      return jni->IsSameObject(v1.l, v2.l);\n-    case 'Z':\n-      return (v1.z == v2.z);\n-    case 'B':\n-      return (v1.b == v2.b);\n-    case 'S':\n-      return (v1.s == v2.s);\n-    case 'C':\n-      return (v1.c == v2.c);\n-    case 'I':\n-      return (v1.i == v2.i);\n-    default:\n-      return (1);\n-  }\n-}\n-\n-void JNICALL FieldModification(jvmtiEnv *jvmti, JNIEnv *jni,\n-                               jthread thr, jmethodID method, jlocation location,\n-                               jclass field_klass, jobject obj,\n-                               jfieldID field, char sig, jvalue new_value) {\n-  jvmtiError err;\n-  jclass cls;\n-  writable_watch_info watch;\n-  char *generic;\n-  size_t i;\n-\n-  eventsCount++;\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> retrieving modification watch info ...\\n\");\n-  }\n-  watch.fid = field;\n-  watch.loc = location;\n-  watch.val = new_value;\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-  err = jvmti->GetMethodDeclaringClass(method, &cls);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(cls,\n-                                     &watch.m_cls, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetMethodName(method,\n-                                 &watch.m_name, &watch.m_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(field_klass,\n-                                     &watch.f_cls, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetFieldName(field_klass, field,\n-                                &watch.f_name, &watch.f_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-    printf(\">>>   location: 0x%x%08x\\n\",\n-           (jint)(watch.loc >> 32), (jint)watch.loc);\n-    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-    printf(\">>>     object: 0x%p\\n\", obj);\n-    printf(\">>>  new value: \");\n-    printValue(watch.val, watch.f_sig);\n-    printf(\"\\n\");\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    if (watch.fid == watches[i].fid) {\n-      if (watch.m_cls == NULL ||\n-          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-               i, watch.m_cls, watches[i].m_cls);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_name == NULL ||\n-          strcmp(watch.m_name, watches[i].m_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-               i, watch.m_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_sig == NULL ||\n-          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-               i, watch.m_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.loc != watches[i].loc) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\", expected: 0x%x%08x\\n\",\n-               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_name == NULL ||\n-          strcmp(watch.f_name, watches[i].f_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-               i, watch.f_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_sig == NULL ||\n-          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-               i, watch.f_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.is_static != watches[i].is_static) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        printf(\", expected: %s\\n\",\n-               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        result = STATUS_FAILED;\n-      }\n-      if (!isEqual((JNIEnv *)jni, watch.f_sig, watch.val, watches[i].val)) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong new value: \", i);\n-        printValue(watch.val, watch.f_sig);\n-        printf(\", expected: \");\n-        printValue(watches[i].val, watch.f_sig);\n-        printf(\"\\n\");\n-        result = STATUS_FAILED;\n-      }\n-      return;\n-    }\n-  }\n-  printf(\"Unexpected field modification catched: 0x%p\\n\", watch.fid);\n-  result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldmod001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldmod001(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldmod001(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-  jvmtiError err;\n-  jint res;\n-\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-    printdump = JNI_TRUE;\n-  }\n-\n-  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetPotentialCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->AddCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  if (caps.can_generate_field_modification_events) {\n-    callbacks.FieldModification = &FieldModification;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                          JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"Failed to enable JVMTI_EVENT_FIELD_MODIFICATION: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-  } else {\n-    printf(\"Warning: FieldModification watch is not implemented\\n\");\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_fieldmod001_getReady(JNIEnv *jni, jclass klass,\n-                                                      jobject obj1, jobject obj2, jobject arr1, jobject arr2) {\n-  jvmtiError err;\n-  jclass cls;\n-  size_t i;\n-\n-  if (!caps.can_generate_field_modification_events) {\n-    return;\n-  }\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> setting field modification watches ...\\n\");\n-  }\n-  cls = jni->FindClass(\"fieldmod001a\");\n-  if (cls == NULL) {\n-    printf(\"Cannot find fieldmod001a class!\\n\");\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    if (watches[i].is_static == JNI_TRUE) {\n-      watches[i].fid = jni->GetStaticFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    } else {\n-      watches[i].fid = jni->GetFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    }\n-    if (watches[i].fid == NULL) {\n-      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n-             watches[i].f_name, watches[i].f_sig);\n-      result = STATUS_FAILED;\n-      return;\n-    }\n-    err = jvmti->SetFieldModificationWatch(cls, watches[i].fid);\n-    if (err == JVMTI_ERROR_NONE) {\n-      eventsExpected++;\n-    } else {\n-      printf(\"(SetFieldModificationWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-             i, TranslateError(err), err);\n-      result = STATUS_FAILED;\n-    }\n-  }\n-\n-  watches[0].val.z = JNI_TRUE;\n-  watches[1].val.b = 1;\n-  watches[2].val.s = 2;\n-  watches[3].val.i = 3;\n-  watches[4].val.j = 4;\n-  watches[5].val.f = 0.5F;\n-  watches[6].val.d = 0.6;\n-  watches[7].val.c = 0x61;\n-  watches[8].val.l = jni->NewGlobalRef(obj1);\n-  watches[9].val.l = jni->NewGlobalRef(arr1);\n-\n-  watches[10].val.z = JNI_FALSE;\n-  watches[11].val.b = 10;\n-  watches[12].val.s = 20;\n-  watches[13].val.i = 30;\n-  watches[14].val.j = 40;\n-  watches[15].val.f = 0.05F;\n-  watches[16].val.d = 0.06;\n-  watches[17].val.c = 0x7a;\n-  watches[18].val.l = jni->NewGlobalRef(obj2);\n-  watches[19].val.l = jni->NewGlobalRef(arr2);\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> ... done\\n\");\n-  }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_fieldmod001_check(JNIEnv *jni, jclass cls) {\n-  if (eventsCount != eventsExpected) {\n-    printf(\"Wrong number of field modification events: %d, expected: %d\\n\",\n-           eventsCount, eventsExpected);\n-    result = STATUS_FAILED;\n-  }\n-  return result;\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod001\/libfieldmod01.cpp","additions":0,"deletions":467,"binary":false,"changes":467,"status":"deleted"},{"patch":"@@ -1,517 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-  jfieldID fid;\n-  char *m_cls;\n-  char *m_name;\n-  char *m_sig;\n-  jlocation loc;\n-  char *f_cls;\n-  char *f_name;\n-  char *f_sig;\n-  jboolean is_static;\n-  jvalue val;\n-} writable_watch_info;\n-\n-typedef struct {\n-  jfieldID fid;\n-  const char *m_cls;\n-  const char *m_name;\n-  const char *m_sig;\n-  jlocation loc;\n-  const char *f_cls;\n-  const char *f_name;\n-  const char *f_sig;\n-  jboolean is_static;\n-  jvalue val;\n-} watch_info;\n-\n-static jvmtiEnv *jvmti;\n-static jvmtiEventCallbacks callbacks;\n-static jvmtiCapabilities caps;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_FALSE;\n-static int eventsExpected = 0;\n-static int eventsCount = 0;\n-static watch_info watches[] = {\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticBoolean\", \"Z\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticByte\", \"B\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticShort\", \"S\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticInt\", \"I\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticLong\", \"J\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticFloat\", \"F\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticDouble\", \"D\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticChar\", \"C\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"staticArrInt\", \"[I\", JNI_TRUE, {} },\n-\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceBoolean\", \"Z\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceByte\", \"B\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceShort\", \"S\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceInt\", \"I\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceLong\", \"J\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceFloat\", \"F\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceDouble\", \"D\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceChar\", \"C\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, {} },\n-    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n-        \"Lfieldmod002a;\", \"instanceArrInt\", \"[I\", JNI_FALSE, {} }\n-};\n-\n-void printValue(jvalue val, char *sig) {\n-  switch (*sig) {\n-    case 'J':\n-      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n-      break;\n-    case 'F':\n-      printf(\"%.3f\", (double)val.f);\n-      break;\n-    case 'D':\n-      printf(\"%f\", (double)val.d);\n-      break;\n-    case 'L':\n-    case '[':\n-      printf(\"0x%p\", val.l);\n-      break;\n-    case 'Z':\n-      printf(\"0x%x\", val.z);\n-      break;\n-    case 'B':\n-      printf(\"%d\", val.b);\n-      break;\n-    case 'S':\n-      printf(\"%d\", val.s);\n-      break;\n-    case 'C':\n-      printf(\"0x%x\", val.c);\n-      break;\n-    case 'I':\n-      printf(\"%d\", val.i);\n-      break;\n-    default:\n-      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n-      break;\n-  }\n-}\n-\n-int isEqual(JNIEnv *jni, char *sig, jvalue v1, jvalue v2) {\n-  switch (*sig) {\n-    case 'J':\n-      return (v1.j == v2.j);\n-    case 'F':\n-      return (v1.f == v2.f);\n-    case 'D':\n-      return (v1.d == v2.d);\n-    case 'L':\n-    case '[':\n-      return jni->IsSameObject(v1.l, v2.l);\n-    case 'Z':\n-      return (v1.z == v2.z);\n-    case 'B':\n-      return (v1.b == v2.b);\n-    case 'S':\n-      return (v1.s == v2.s);\n-    case 'C':\n-      return (v1.c == v2.c);\n-    case 'I':\n-      return (v1.i == v2.i);\n-    default:\n-      return (1);\n-  }\n-}\n-\n-void JNICALL FieldModification(jvmtiEnv *jvmti, JNIEnv *jni,\n-                               jthread thr, jmethodID method, jlocation location,\n-                               jclass field_klass, jobject obj,\n-                               jfieldID field, char sig, jvalue new_value) {\n-  jvmtiError err;\n-  jclass cls;\n-  writable_watch_info watch;\n-  char *generic;\n-  size_t i;\n-\n-  eventsCount++;\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> retrieving modification watch info ...\\n\");\n-  }\n-  watch.fid = field;\n-  watch.loc = location;\n-  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n-  watch.val = new_value;\n-  err = jvmti->GetMethodDeclaringClass(method, &cls);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(cls,\n-                                     &watch.m_cls, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetMethodName(method, &watch.m_name, &watch.m_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(field_klass,\n-                                     &watch.f_cls, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetFieldName(field_klass, field,\n-                                &watch.f_name, &watch.f_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n-    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n-    printf(\">>>   location: 0x%x%08x\\n\",\n-           (jint)(watch.loc >> 32), (jint)watch.loc);\n-    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n-    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n-    printf(\">>>     object: 0x%p\\n\", obj);\n-    printf(\">>>  new value: \");\n-    printValue(watch.val, watch.f_sig);\n-    printf(\"\\n\");\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    if (watch.fid == watches[i].fid) {\n-      if (watch.m_cls == NULL ||\n-          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n-               i, watch.m_cls, watches[i].m_cls);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_name == NULL ||\n-          strcmp(watch.m_name, watches[i].m_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-               i, watch.m_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.m_sig == NULL ||\n-          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-               i, watch.m_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.loc != watches[i].loc) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n-               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n-        printf(\", expected: 0x%x%08x\\n\",\n-               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_name == NULL ||\n-          strcmp(watch.f_name, watches[i].f_name) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n-               i, watch.f_name);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.f_sig == NULL ||\n-          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n-               i, watch.f_sig);\n-        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n-        result = STATUS_FAILED;\n-      }\n-      if (watch.is_static != watches[i].is_static) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n-               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        printf(\", expected: %s\\n\",\n-               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n-        result = STATUS_FAILED;\n-      }\n-      if (!isEqual((JNIEnv *)jni, watch.f_sig, watch.val, watches[i].val)) {\n-        printf(\"(watch#%\" PRIuPTR \") wrong new value: \", i);\n-        printValue(watch.val, watch.f_sig);\n-        printf(\", expected: \");\n-        printValue(watches[i].val, watch.f_sig);\n-        printf(\"\\n\");\n-        result = STATUS_FAILED;\n-      }\n-      return;\n-    }\n-  }\n-  printf(\"Unexpected field modification catched: 0x%p\\n\", watch.fid);\n-  result = STATUS_FAILED;\n-}\n-\n-#ifdef STATIC_BUILD\n-JNIEXPORT jint JNICALL Agent_OnLoad_fieldmod002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNICALL Agent_OnAttach_fieldmod002(JavaVM *jvm, char *options, void *reserved) {\n-    return Agent_Initialize(jvm, options, reserved);\n-}\n-JNIEXPORT jint JNI_OnLoad_fieldmod002(JavaVM *jvm, char *options, void *reserved) {\n-    return JNI_VERSION_1_8;\n-}\n-#endif\n-jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n-  jvmtiError err;\n-  jint res;\n-\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-    printdump = JNI_TRUE;\n-  }\n-\n-  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetPotentialCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->AddCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  if (caps.can_generate_field_modification_events) {\n-    callbacks.FieldModification = &FieldModification;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-\n-    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                          JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"Failed to enable JVMTI_EVENT_FIELD_MODIFICATION: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-  } else {\n-    printf(\"Warning: FieldModification watch is not implemented\\n\");\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_fieldmod002_getReady(JNIEnv *jni, jclass clz) {\n-  jvmtiError err;\n-  jclass cls;\n-  jmethodID ctor;\n-  jintArray arr1, arr2;\n-  jobject obj1, obj2;\n-  size_t i;\n-\n-  if (!caps.can_generate_field_modification_events) {\n-    return;\n-  }\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> setting field modification watches ...\\n\");\n-  }\n-  cls = jni->FindClass(\"fieldmod002a\");\n-  if (cls == NULL) {\n-    printf(\"Cannot find fieldmod001a class!\\n\");\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n-    if (watches[i].is_static == JNI_TRUE) {\n-      watches[i].fid = jni->GetStaticFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    } else {\n-      watches[i].fid = jni->GetFieldID(\n-          cls, watches[i].f_name, watches[i].f_sig);\n-    }\n-    if (watches[i].fid == NULL) {\n-      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n-             watches[i].f_name, watches[i].f_sig);\n-      result = STATUS_FAILED;\n-      return;\n-    }\n-    err = jvmti->SetFieldModificationWatch(cls, watches[i].fid);\n-    if (err == JVMTI_ERROR_NONE) {\n-      eventsExpected++;\n-    } else {\n-      printf(\"(SetFieldModificationWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n-             i, TranslateError(err), err);\n-      result = STATUS_FAILED;\n-    }\n-  }\n-\n-  ctor = jni->GetMethodID(cls, \"<init>\", \"()V\");\n-  obj1 = jni->NewGlobalRef(jni->NewObject(cls, ctor));\n-  obj2 = jni->NewGlobalRef(jni->NewObject(cls, ctor));\n-  arr1 = (jintArray) jni->NewGlobalRef(jni->NewIntArray((jsize) 1));\n-  arr2 = (jintArray) jni->NewGlobalRef(jni->NewIntArray((jsize) 1));\n-\n-  watches[0].val.z = JNI_TRUE;\n-  watches[1].val.b = 1;\n-  watches[2].val.s = 2;\n-  watches[3].val.i = 3;\n-  watches[4].val.j = 4;\n-  watches[5].val.f = 0.5F;\n-  watches[6].val.d = 0.6;\n-  watches[7].val.c = 0x7;\n-  watches[8].val.l = obj1;\n-  watches[9].val.l = arr1;\n-\n-  watches[10].val.z = JNI_FALSE;\n-  watches[11].val.b = 10;\n-  watches[12].val.s = 20;\n-  watches[13].val.i = 30;\n-  watches[14].val.j = 40;\n-  watches[15].val.f = 0.05F;\n-  watches[16].val.d = 0.06;\n-  watches[17].val.c = 0x70;\n-  watches[18].val.l = obj2;\n-  watches[19].val.l = arr2;\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> ... done\\n\");\n-  }\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_fieldmod002_check(JNIEnv *jni,\n-                                                   jclass clz, jobject obj) {\n-  jclass cls;\n-\n-  if (!caps.can_generate_field_modification_events) {\n-    return PASSED;\n-  }\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> modifying fields ...\\n\");\n-  }\n-\n-  cls = jni->FindClass(\"fieldmod002a\");\n-  if (cls == NULL) {\n-    printf(\"Cannot find fieldmod001a class!\\n\");\n-    return STATUS_FAILED;\n-  }\n-\n-  jni->SetStaticBooleanField(cls, watches[0].fid, watches[0].val.z);\n-  jni->SetStaticByteField(cls, watches[1].fid, watches[1].val.b);\n-  jni->SetStaticShortField(cls, watches[2].fid, watches[2].val.s);\n-  jni->SetStaticIntField(cls, watches[3].fid, watches[3].val.i);\n-  jni->SetStaticLongField(cls, watches[4].fid, watches[4].val.j);\n-  jni->SetStaticFloatField(cls, watches[5].fid, watches[5].val.f);\n-  jni->SetStaticDoubleField(cls, watches[6].fid, watches[6].val.d);\n-  jni->SetStaticCharField(cls, watches[7].fid, watches[7].val.c);\n-  jni->SetStaticObjectField(cls, watches[8].fid, watches[8].val.l);\n-  jni->SetStaticObjectField(cls, watches[9].fid, watches[9].val.l);\n-\n-  jni->SetBooleanField(obj, watches[10].fid, watches[10].val.z);\n-  jni->SetByteField(obj, watches[11].fid, watches[11].val.b);\n-  jni->SetShortField(obj, watches[12].fid, watches[12].val.s);\n-  jni->SetIntField(obj, watches[13].fid, watches[13].val.i);\n-  jni->SetLongField(obj, watches[14].fid, watches[14].val.j);\n-  jni->SetFloatField(obj, watches[15].fid, watches[15].val.f);\n-  jni->SetDoubleField(obj, watches[16].fid, watches[16].val.d);\n-  jni->SetCharField(obj, watches[17].fid, watches[17].val.c);\n-  jni->SetObjectField(obj, watches[18].fid, watches[18].val.l);\n-  jni->SetObjectField(obj, watches[19].fid, watches[19].val.l);\n-\n-  if (printdump == JNI_TRUE) {\n-    printf(\">>> ... done\\n\");\n-  }\n-\n-  if (eventsCount != eventsExpected) {\n-    printf(\"Wrong number of field modification events: %d, expected: %d\\n\",\n-           eventsCount, eventsExpected);\n-    result = STATUS_FAILED;\n-  }\n-  return result;\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n-  return Agent_Initialize(jvm, options, reserved);\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod002\/libfieldmod02.cpp","additions":0,"deletions":517,"binary":false,"changes":517,"status":"deleted"},{"patch":"@@ -42,2 +42,2 @@\n- * @compile fieldmod001a.jasm\n- * @run main\/othervm\/native -agentlib:fieldmod01 fieldmod001\n+ * @compile fieldmod01a.jasm\n+ * @run main\/othervm\/native -agentlib:fieldmod01 fieldmod01\n@@ -46,1 +46,1 @@\n-public class fieldmod001 {\n+public class fieldmod01 {\n@@ -54,1 +54,1 @@\n-            System.err.println(\"Could not load fieldmod001 library\");\n+            System.err.println(\"Could not load fieldmod01 library\");\n@@ -71,1 +71,1 @@\n-        fieldmod001a t = new fieldmod001a();\n+        fieldmod01a t = new fieldmod01a();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod01\/fieldmod01.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod001\/fieldmod001.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-super public class fieldmod001a {\n+super public class fieldmod01a {\n@@ -70,1 +70,1 @@\n-        getstatic   Field fieldmod001.obj1:\"Ljava\/lang\/Object;\";\n+        getstatic   Field fieldmod01.obj1:\"Ljava\/lang\/Object;\";\n@@ -72,1 +72,1 @@\n-        getstatic   Field fieldmod001.arr1:\"[I\";\n+        getstatic   Field fieldmod01.arr1:\"[I\";\n@@ -99,1 +99,1 @@\n-        getstatic   Field fieldmod001.obj2:\"Ljava\/lang\/Object;\";\n+        getstatic   Field fieldmod01.obj2:\"Ljava\/lang\/Object;\";\n@@ -102,1 +102,1 @@\n-        getstatic   Field fieldmod001.arr2:\"[I\";\n+        getstatic   Field fieldmod01.arr2:\"[I\";\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod01\/fieldmod01a.jasm","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod001\/fieldmod001a.jasm","status":"renamed"},{"patch":"@@ -0,0 +1,467 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+  jvalue val;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  const jboolean is_static;\n+  jvalue val;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 1,\n+        \"Lfieldmod01a;\", \"staticBoolean\", \"Z\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 5,\n+        \"Lfieldmod01a;\", \"staticByte\", \"B\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 9,\n+        \"Lfieldmod01a;\", \"staticShort\", \"S\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 13,\n+        \"Lfieldmod01a;\", \"staticInt\", \"I\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 19,\n+        \"Lfieldmod01a;\", \"staticLong\", \"J\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 24,\n+        \"Lfieldmod01a;\", \"staticFloat\", \"F\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 30,\n+        \"Lfieldmod01a;\", \"staticDouble\", \"D\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 35,\n+        \"Lfieldmod01a;\", \"staticChar\", \"C\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 41,\n+        \"Lfieldmod01a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 47,\n+        \"Lfieldmod01a;\", \"staticArrInt\", \"[I\", JNI_TRUE, {} },\n+\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 52,\n+        \"Lfieldmod01a;\", \"instanceBoolean\", \"Z\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 58,\n+        \"Lfieldmod01a;\", \"instanceByte\", \"B\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 64,\n+        \"Lfieldmod01a;\", \"instanceShort\", \"S\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 70,\n+        \"Lfieldmod01a;\", \"instanceInt\", \"I\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 77,\n+        \"Lfieldmod01a;\", \"instanceLong\", \"J\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 83,\n+        \"Lfieldmod01a;\", \"instanceFloat\", \"F\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 90,\n+        \"Lfieldmod01a;\", \"instanceDouble\", \"D\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 96,\n+        \"Lfieldmod01a;\", \"instanceChar\", \"C\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 103,\n+        \"Lfieldmod01a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod01a;\", \"run\", \"()V\", 110,\n+        \"Lfieldmod01a;\", \"instanceArrInt\", \"[I\", JNI_FALSE, {} }\n+};\n+\n+void printValue(jvalue val, char *sig) {\n+  switch (*sig) {\n+    case 'J':\n+      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n+      break;\n+    case 'F':\n+      printf(\"%.3f\", (double)val.f);\n+      break;\n+    case 'D':\n+      printf(\"%f\", (double)val.d);\n+      break;\n+    case 'L':\n+    case '[':\n+      printf(\"0x%p\", val.l);\n+      break;\n+    case 'Z':\n+      printf(\"0x%x\", val.z);\n+      break;\n+    case 'B':\n+      printf(\"%d\", val.b);\n+      break;\n+    case 'S':\n+      printf(\"%d\", val.s);\n+      break;\n+    case 'C':\n+      printf(\"0x%x\", val.c);\n+      break;\n+    case 'I':\n+      printf(\"%d\", val.i);\n+      break;\n+    default:\n+      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n+      break;\n+  }\n+}\n+\n+int isEqual(JNIEnv *jni, char *sig, jvalue v1, jvalue v2) {\n+  switch (*sig) {\n+    case 'J':\n+      return (v1.j == v2.j);\n+    case 'F':\n+      return (v1.f == v2.f);\n+    case 'D':\n+      return (v1.d == v2.d);\n+    case 'L':\n+    case '[':\n+      return jni->IsSameObject(v1.l, v2.l);\n+    case 'Z':\n+      return (v1.z == v2.z);\n+    case 'B':\n+      return (v1.b == v2.b);\n+    case 'S':\n+      return (v1.s == v2.s);\n+    case 'C':\n+      return (v1.c == v2.c);\n+    case 'I':\n+      return (v1.i == v2.i);\n+    default:\n+      return (1);\n+  }\n+}\n+\n+void JNICALL FieldModification(jvmtiEnv *jvmti, JNIEnv *jni,\n+                               jthread thr, jmethodID method, jlocation location,\n+                               jclass field_klass, jobject obj,\n+                               jfieldID field, char sig, jvalue new_value) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving modification watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.val = new_value;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+    printf(\">>>  new value: \");\n+    printValue(watch.val, watch.f_sig);\n+    printf(\"\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      if (!isEqual((JNIEnv *)jni, watch.f_sig, watch.val, watches[i].val)) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong new value: \", i);\n+        printValue(watch.val, watch.f_sig);\n+        printf(\", expected: \");\n+        printValue(watches[i].val, watch.f_sig);\n+        printf(\"\\n\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field modification catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldmod01(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldmod01(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldmod01(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_modification_events) {\n+    callbacks.FieldModification = &FieldModification;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_MODIFICATION: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldModification watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_fieldmod01_getReady(JNIEnv *jni, jclass klass,\n+                                                      jobject obj1, jobject obj2, jobject arr1, jobject arr2) {\n+  jvmtiError err;\n+  jclass cls;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_modification_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field modification watches ...\\n\");\n+  }\n+  cls = jni->FindClass(\"fieldmod01a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldmod01a class!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = jni->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = jni->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n+             watches[i].f_name, watches[i].f_sig);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldModificationWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldModificationWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+\n+  watches[0].val.z = JNI_TRUE;\n+  watches[1].val.b = 1;\n+  watches[2].val.s = 2;\n+  watches[3].val.i = 3;\n+  watches[4].val.j = 4;\n+  watches[5].val.f = 0.5F;\n+  watches[6].val.d = 0.6;\n+  watches[7].val.c = 0x61;\n+  watches[8].val.l = jni->NewGlobalRef(obj1);\n+  watches[9].val.l = jni->NewGlobalRef(arr1);\n+\n+  watches[10].val.z = JNI_FALSE;\n+  watches[11].val.b = 10;\n+  watches[12].val.s = 20;\n+  watches[13].val.i = 30;\n+  watches[14].val.j = 40;\n+  watches[15].val.f = 0.05F;\n+  watches[16].val.d = 0.06;\n+  watches[17].val.c = 0x7a;\n+  watches[18].val.l = jni->NewGlobalRef(obj2);\n+  watches[19].val.l = jni->NewGlobalRef(arr2);\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldmod01_check(JNIEnv *jni, jclass cls) {\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field modification events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod01\/libfieldmod01.cpp","additions":467,"deletions":0,"binary":false,"changes":467,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n- * @run main\/othervm\/native -agentlib:fieldmod02 fieldmod002\n+ * @run main\/othervm\/native -agentlib:fieldmod02 fieldmod02\n@@ -46,1 +46,1 @@\n-public class fieldmod002 {\n+public class fieldmod02 {\n@@ -52,1 +52,1 @@\n-            System.err.println(\"Could not load fieldmod002 library\");\n+            System.err.println(\"Could not load fieldmod02 library\");\n@@ -63,1 +63,1 @@\n-        fieldmod002a t = new fieldmod002a();\n+        fieldmod02a t = new fieldmod02a();\n@@ -72,1 +72,1 @@\n-class fieldmod002a {\n+class fieldmod02a {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod02\/fieldmod02.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod002\/fieldmod002.java","status":"renamed"},{"patch":"@@ -0,0 +1,517 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+  jvalue val;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  jboolean is_static;\n+  jvalue val;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticBoolean\", \"Z\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticByte\", \"B\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticShort\", \"S\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticInt\", \"I\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticLong\", \"J\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticFloat\", \"F\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticDouble\", \"D\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticChar\", \"C\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"staticArrInt\", \"[I\", JNI_TRUE, {} },\n+\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceBoolean\", \"Z\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceByte\", \"B\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceShort\", \"S\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceInt\", \"I\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceLong\", \"J\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceFloat\", \"F\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceDouble\", \"D\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceChar\", \"C\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod02;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod02a;\", \"instanceArrInt\", \"[I\", JNI_FALSE, {} }\n+};\n+\n+void printValue(jvalue val, char *sig) {\n+  switch (*sig) {\n+    case 'J':\n+      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n+      break;\n+    case 'F':\n+      printf(\"%.3f\", (double)val.f);\n+      break;\n+    case 'D':\n+      printf(\"%f\", (double)val.d);\n+      break;\n+    case 'L':\n+    case '[':\n+      printf(\"0x%p\", val.l);\n+      break;\n+    case 'Z':\n+      printf(\"0x%x\", val.z);\n+      break;\n+    case 'B':\n+      printf(\"%d\", val.b);\n+      break;\n+    case 'S':\n+      printf(\"%d\", val.s);\n+      break;\n+    case 'C':\n+      printf(\"0x%x\", val.c);\n+      break;\n+    case 'I':\n+      printf(\"%d\", val.i);\n+      break;\n+    default:\n+      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n+      break;\n+  }\n+}\n+\n+int isEqual(JNIEnv *jni, char *sig, jvalue v1, jvalue v2) {\n+  switch (*sig) {\n+    case 'J':\n+      return (v1.j == v2.j);\n+    case 'F':\n+      return (v1.f == v2.f);\n+    case 'D':\n+      return (v1.d == v2.d);\n+    case 'L':\n+    case '[':\n+      return jni->IsSameObject(v1.l, v2.l);\n+    case 'Z':\n+      return (v1.z == v2.z);\n+    case 'B':\n+      return (v1.b == v2.b);\n+    case 'S':\n+      return (v1.s == v2.s);\n+    case 'C':\n+      return (v1.c == v2.c);\n+    case 'I':\n+      return (v1.i == v2.i);\n+    default:\n+      return (1);\n+  }\n+}\n+\n+void JNICALL FieldModification(jvmtiEnv *jvmti, JNIEnv *jni,\n+                               jthread thr, jmethodID method, jlocation location,\n+                               jclass field_klass, jobject obj,\n+                               jfieldID field, char sig, jvalue new_value) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving modification watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  watch.val = new_value;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method, &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+    printf(\">>>  new value: \");\n+    printValue(watch.val, watch.f_sig);\n+    printf(\"\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      if (!isEqual((JNIEnv *)jni, watch.f_sig, watch.val, watches[i].val)) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong new value: \", i);\n+        printValue(watch.val, watch.f_sig);\n+        printf(\", expected: \");\n+        printValue(watches[i].val, watch.f_sig);\n+        printf(\"\\n\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field modification catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldmod02(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldmod02(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldmod02(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_modification_events) {\n+    callbacks.FieldModification = &FieldModification;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_MODIFICATION: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldModification watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_fieldmod02_getReady(JNIEnv *jni, jclass clz) {\n+  jvmtiError err;\n+  jclass cls;\n+  jmethodID ctor;\n+  jintArray arr1, arr2;\n+  jobject obj1, obj2;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_modification_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field modification watches ...\\n\");\n+  }\n+  cls = jni->FindClass(\"fieldmod02a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldmod02a class!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = jni->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = jni->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n+             watches[i].f_name, watches[i].f_sig);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldModificationWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldModificationWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+\n+  ctor = jni->GetMethodID(cls, \"<init>\", \"()V\");\n+  obj1 = jni->NewGlobalRef(jni->NewObject(cls, ctor));\n+  obj2 = jni->NewGlobalRef(jni->NewObject(cls, ctor));\n+  arr1 = (jintArray) jni->NewGlobalRef(jni->NewIntArray((jsize) 1));\n+  arr2 = (jintArray) jni->NewGlobalRef(jni->NewIntArray((jsize) 1));\n+\n+  watches[0].val.z = JNI_TRUE;\n+  watches[1].val.b = 1;\n+  watches[2].val.s = 2;\n+  watches[3].val.i = 3;\n+  watches[4].val.j = 4;\n+  watches[5].val.f = 0.5F;\n+  watches[6].val.d = 0.6;\n+  watches[7].val.c = 0x7;\n+  watches[8].val.l = obj1;\n+  watches[9].val.l = arr1;\n+\n+  watches[10].val.z = JNI_FALSE;\n+  watches[11].val.b = 10;\n+  watches[12].val.s = 20;\n+  watches[13].val.i = 30;\n+  watches[14].val.j = 40;\n+  watches[15].val.f = 0.05F;\n+  watches[16].val.d = 0.06;\n+  watches[17].val.c = 0x70;\n+  watches[18].val.l = obj2;\n+  watches[19].val.l = arr2;\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldmod02_check(JNIEnv *jni,\n+                                                   jclass clz, jobject obj) {\n+  jclass cls;\n+\n+  if (!caps.can_generate_field_modification_events) {\n+    return PASSED;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> modifying fields ...\\n\");\n+  }\n+\n+  cls = jni->FindClass(\"fieldmod02a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldmod02a class!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  jni->SetStaticBooleanField(cls, watches[0].fid, watches[0].val.z);\n+  jni->SetStaticByteField(cls, watches[1].fid, watches[1].val.b);\n+  jni->SetStaticShortField(cls, watches[2].fid, watches[2].val.s);\n+  jni->SetStaticIntField(cls, watches[3].fid, watches[3].val.i);\n+  jni->SetStaticLongField(cls, watches[4].fid, watches[4].val.j);\n+  jni->SetStaticFloatField(cls, watches[5].fid, watches[5].val.f);\n+  jni->SetStaticDoubleField(cls, watches[6].fid, watches[6].val.d);\n+  jni->SetStaticCharField(cls, watches[7].fid, watches[7].val.c);\n+  jni->SetStaticObjectField(cls, watches[8].fid, watches[8].val.l);\n+  jni->SetStaticObjectField(cls, watches[9].fid, watches[9].val.l);\n+\n+  jni->SetBooleanField(obj, watches[10].fid, watches[10].val.z);\n+  jni->SetByteField(obj, watches[11].fid, watches[11].val.b);\n+  jni->SetShortField(obj, watches[12].fid, watches[12].val.s);\n+  jni->SetIntField(obj, watches[13].fid, watches[13].val.i);\n+  jni->SetLongField(obj, watches[14].fid, watches[14].val.j);\n+  jni->SetFloatField(obj, watches[15].fid, watches[15].val.f);\n+  jni->SetDoubleField(obj, watches[16].fid, watches[16].val.d);\n+  jni->SetCharField(obj, watches[17].fid, watches[17].val.c);\n+  jni->SetObjectField(obj, watches[18].fid, watches[18].val.l);\n+  jni->SetObjectField(obj, watches[19].fid, watches[19].val.l);\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field modification events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod02\/libfieldmod02.cpp","additions":517,"deletions":0,"binary":false,"changes":517,"status":"added"},{"patch":"@@ -44,2 +44,2 @@\n- * @compile framepop001a.jasm\n- * @run main\/othervm\/native -agentlib:framepop01 framepop001\n+ * @compile framepop01a.jasm\n+ * @run main\/othervm\/native -agentlib:framepop01 framepop01\n@@ -50,1 +50,1 @@\n-public class framepop001 {\n+public class framepop01 {\n@@ -58,1 +58,1 @@\n-            System.err.println(\"Could not load framepop001 library\");\n+            System.err.println(\"Could not load framepop01 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop01\/framepop01.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop001\/framepop001.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-super public class framepop001a {\n+super public class framepop01a {\n@@ -33,1 +33,1 @@\n-        invokestatic    Method framepop001.chain:\"()V\";\n+        invokestatic    Method framepop01.chain:\"()V\";\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop01\/framepop01a.jasm","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop001\/framepop001a.jasm","status":"renamed"},{"patch":"@@ -51,2 +51,2 @@\n-    { \"Lframepop001;\", \"chain\", \"()V\", 0 },\n-    { \"Lframepop001a;\", \"dummy\", \"()V\", 3 },\n+    { \"Lframepop01;\", \"chain\", \"()V\", 0 },\n+    { \"Lframepop01a;\", \"dummy\", \"()V\", 3 },\n@@ -162,1 +162,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_framepop001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_framepop01(JavaVM *jvm, char *options, void *reserved) {\n@@ -165,1 +165,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_framepop001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_framepop01(JavaVM *jvm, char *options, void *reserved) {\n@@ -168,1 +168,1 @@\n-JNIEXPORT jint JNI_OnLoad_framepop001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_framepop01(JavaVM *jvm, char *options, void *reserved) {\n@@ -225,1 +225,1 @@\n-Java_framepop001_check(JNIEnv *jni, jclass cls) {\n+Java_framepop01_check(JNIEnv *jni, jclass cls) {\n@@ -266,1 +266,1 @@\n-  clz = jni->FindClass(\"framepop001a\");\n+  clz = jni->FindClass(\"framepop01a\");\n@@ -268,1 +268,1 @@\n-    printf(\"Cannot find framepop001a class!\\n\");\n+    printf(\"Cannot find framepop01a class!\\n\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop01\/libframepop01.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop001\/libframepop01.cpp","status":"renamed"},{"patch":"@@ -44,1 +44,1 @@\n- * @run main\/othervm\/native -agentlib:framepop02 framepop002\n+ * @run main\/othervm\/native -agentlib:framepop02 framepop02\n@@ -49,1 +49,1 @@\n-public class framepop002 {\n+public class framepop02 {\n@@ -60,1 +60,1 @@\n-            System.err.println(\"Could not load framepop002 library\");\n+            System.err.println(\"Could not load framepop02 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop02\/framepop02.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop002\/framepop002.java","status":"renamed"},{"patch":"@@ -343,1 +343,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_framepop02(JavaVM *jvm, char *options, void *reserved) {\n@@ -346,1 +346,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_framepop002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_framepop02(JavaVM *jvm, char *options, void *reserved) {\n@@ -349,1 +349,1 @@\n-JNIEXPORT jint JNI_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_framepop02(JavaVM *jvm, char *options, void *reserved) {\n@@ -428,1 +428,1 @@\n-JNIEXPORT void JNICALL Java_framepop002_getReady(JNIEnv *jni, jclass cls) {\n+JNIEXPORT void JNICALL Java_framepop02_getReady(JNIEnv *jni, jclass cls) {\n@@ -453,1 +453,1 @@\n-JNIEXPORT jint JNICALL Java_framepop002_check(JNIEnv *jni, jclass cls) {\n+JNIEXPORT jint JNICALL Java_framepop02_check(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop02\/libframepop02.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop002\/libframepop02.cpp","status":"renamed"},{"patch":"@@ -85,1 +85,1 @@\n-      strcmp(cls_sig, \"Lmentry001;\") == 0) {\n+      strcmp(cls_sig, \"Lmentry01;\") == 0) {\n@@ -144,1 +144,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_mentry001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_mentry01(JavaVM *jvm, char *options, void *reserved) {\n@@ -147,1 +147,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_mentry001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_mentry01(JavaVM *jvm, char *options, void *reserved) {\n@@ -150,1 +150,1 @@\n-JNIEXPORT jint JNI_OnLoad_mentry001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_mentry01(JavaVM *jvm, char *options, void *reserved) {\n@@ -205,1 +205,1 @@\n-Java_mentry001_enable(JNIEnv *jni, jclass cls) {\n+Java_mentry01_enable(JNIEnv *jni, jclass cls) {\n@@ -228,1 +228,1 @@\n-Java_mentry001_check(JNIEnv *jni, jclass cls) {\n+Java_mentry01_check(JNIEnv *jni, jclass cls) {\n@@ -247,1 +247,1 @@\n-Java_mentry001_chain(JNIEnv *jni, jclass cls) {\n+Java_mentry01_chain(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry01\/libmentry01.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry001\/libmentry01.cpp","status":"renamed"},{"patch":"@@ -42,1 +42,1 @@\n- *     Fixed the 5004632 bug.\n+ *     Fixed the 504632 bug.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\/native -agentlib:mentry01 mentry001\n+ * @run main\/othervm\/native -agentlib:mentry01 mentry01\n@@ -50,1 +50,1 @@\n-public class mentry001 {\n+public class mentry01 {\n@@ -58,1 +58,1 @@\n-            System.err.println(\"Could not load mentry001 library\");\n+            System.err.println(\"Could not load mentry01 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry01\/mentry01.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry001\/mentry001.java","status":"renamed"},{"patch":"@@ -62,1 +62,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_mentry002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_mentry02(JavaVM *jvm, char *options, void *reserved) {\n@@ -65,1 +65,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_mentry002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_mentry02(JavaVM *jvm, char *options, void *reserved) {\n@@ -68,1 +68,1 @@\n-JNIEXPORT jint JNI_OnLoad_mentry002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_mentry02(JavaVM *jvm, char *options, void *reserved) {\n@@ -125,1 +125,1 @@\n-Java_mentry002_getReady(JNIEnv *jni, jclass cls, jint i) {\n+Java_mentry02_getReady(JNIEnv *jni, jclass cls, jint i) {\n@@ -167,1 +167,1 @@\n-Java_mentry002_check(JNIEnv *jni, jclass cls) {\n+Java_mentry02_check(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry02\/libmentry02.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry002\/libmentry02.cpp","status":"renamed"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm\/native -agentlib:mentry02 mentry002\n+ * @run main\/othervm\/native -agentlib:mentry02 mentry02\n@@ -47,1 +47,1 @@\n-public class mentry002 {\n+public class mentry02 {\n@@ -56,1 +56,1 @@\n-            System.err.println(\"Could not load mentry002 library\");\n+            System.err.println(\"Could not load mentry02 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry02\/mentry02.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry002\/mentry002.java","status":"renamed"},{"patch":"@@ -51,2 +51,2 @@\n-    { \"Lmexit001a;\", \"chain\", \"()V\", -1 },\n-    { \"Lmexit001a;\", \"dummy\", \"()V\", 3 }\n+    { \"Lmexit01a;\", \"chain\", \"()V\", -1 },\n+    { \"Lmexit01a;\", \"dummy\", \"()V\", 3 }\n@@ -80,1 +80,1 @@\n-      strcmp(cls_sig, \"Lmexit001a;\") == 0) {\n+      strcmp(cls_sig, \"Lmexit01a;\") == 0) {\n@@ -146,1 +146,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_mexit001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_mexit01(JavaVM *jvm, char *options, void *reserved) {\n@@ -149,1 +149,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_mexit001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_mexit01(JavaVM *jvm, char *options, void *reserved) {\n@@ -152,1 +152,1 @@\n-JNIEXPORT jint JNI_OnLoad_mexit001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_mexit01(JavaVM *jvm, char *options, void *reserved) {\n@@ -207,1 +207,1 @@\n-Java_mexit001_init0(JNIEnv *jni, jclass cls) {\n+Java_mexit01_init0(JNIEnv *jni, jclass cls) {\n@@ -229,1 +229,1 @@\n-Java_mexit001_check(JNIEnv *jni, jclass cls) {\n+Java_mexit01_check(JNIEnv *jni, jclass cls) {\n@@ -243,1 +243,1 @@\n-  clz = jni->FindClass(\"mexit001a\");\n+  clz = jni->FindClass(\"mexit01a\");\n@@ -245,1 +245,1 @@\n-    printf(\"Cannot find MethodExit.mexit001a class!\\n\");\n+    printf(\"Cannot find MethodExit.mexit01a class!\\n\");\n@@ -274,1 +274,1 @@\n-Java_mexit001a_chain(JNIEnv *jni, jclass cls) {\n+Java_mexit01a_chain(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit01\/libmexit01.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit001\/libmexit01.cpp","status":"renamed"},{"patch":"@@ -46,2 +46,2 @@\n- * @compile mexit001a.jasm\n- * @run main\/othervm\/native -agentlib:mexit01 mexit001\n+ * @compile mexit01a.jasm\n+ * @run main\/othervm\/native -agentlib:mexit01 mexit01\n@@ -50,1 +50,1 @@\n-public class mexit001 {\n+public class mexit01 {\n@@ -58,1 +58,1 @@\n-            System.err.println(\"Could not load mexit001 library\");\n+            System.err.println(\"Could not load mexit01 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit01\/mexit01.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit001\/mexit001.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-super public class mexit001a {\n+super public class mexit01a {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit01\/mexit01a.jasm","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit001\/mexit001a.jasm","status":"renamed"},{"patch":"@@ -51,2 +51,2 @@\n-    { \"Lmexit002a;\", \"chain\", \"()V\", -1 },\n-    { \"Lmexit002a;\", \"dummy\", \"()V\", 3 }\n+    { \"Lmexit02a;\", \"chain\", \"()V\", -1 },\n+    { \"Lmexit02a;\", \"dummy\", \"()V\", 3 }\n@@ -80,1 +80,1 @@\n-      strcmp(cls_sig, \"Lmexit002a;\") == 0) {\n+      strcmp(cls_sig, \"Lmexit02a;\") == 0) {\n@@ -146,1 +146,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_mexit002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_mexit02(JavaVM *jvm, char *options, void *reserved) {\n@@ -149,1 +149,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_mexit002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_mexit02(JavaVM *jvm, char *options, void *reserved) {\n@@ -152,1 +152,1 @@\n-JNIEXPORT jint JNI_OnLoad_mexit002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_mexit02(JavaVM *jvm, char *options, void *reserved) {\n@@ -207,1 +207,1 @@\n-Java_mexit002_check(JNIEnv *jni, jclass cls) {\n+Java_mexit02_check(JNIEnv *jni, jclass cls) {\n@@ -221,1 +221,1 @@\n-  clz = jni->FindClass(\"mexit002a\");\n+  clz = jni->FindClass(\"mexit02a\");\n@@ -223,1 +223,1 @@\n-    printf(\"Failed to find class \\\"mexit002a\\\"!\\n\");\n+    printf(\"Failed to find class \\\"mexit02a\\\"!\\n\");\n@@ -262,1 +262,1 @@\n-Java_mexit002a_chain(JNIEnv *jni, jclass cls) {\n+Java_mexit02a_chain(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit02\/libmexit02.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit002\/libmexit02.cpp","status":"renamed"},{"patch":"@@ -39,1 +39,1 @@\n- *     The test is the same as mexit001 one. The only difference is\n+ *     The test is the same as mexit01 one. The only difference is\n@@ -47,2 +47,2 @@\n- * @compile mexit002a.jasm\n- * @run main\/othervm\/native -agentlib:mexit02 mexit002\n+ * @compile mexit02a.jasm\n+ * @run main\/othervm\/native -agentlib:mexit02 mexit02\n@@ -53,1 +53,1 @@\n-public class mexit002 {\n+public class mexit02 {\n@@ -61,1 +61,1 @@\n-            System.err.println(\"Could not load mexit002 library\");\n+            System.err.println(\"Could not load mexit02 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit02\/mexit02.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit002\/mexit002.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-super public class mexit002a {\n+super public class mexit02a {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit02\/mexit02a.jasm","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit002\/mexit002a.jasm","status":"renamed"},{"patch":"@@ -222,1 +222,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_mcontenter001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_mcontenter01(JavaVM *jvm, char *options, void *reserved) {\n@@ -225,1 +225,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_mcontenter001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_mcontenter01(JavaVM *jvm, char *options, void *reserved) {\n@@ -228,1 +228,1 @@\n-JNIEXPORT jint JNI_OnLoad_mcontenter001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_mcontenter01(JavaVM *jvm, char *options, void *reserved) {\n@@ -290,1 +290,1 @@\n-JNIEXPORT jint JNICALL Java_mcontenter001_getEventCount\n+JNIEXPORT jint JNICALL Java_mcontenter01_getEventCount\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEnter\/mcontenter01\/libmcontenter01.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEnter\/mcontenter001\/libmcontenter.cpp","status":"renamed"},{"patch":"@@ -48,1 +48,1 @@\n- *      -agentlib:mcontenter mcontenter001\n+ *      -agentlib:mcontenter01 mcontenter01\n@@ -52,1 +52,1 @@\n-public class mcontenter001 extends DebugeeClass {\n+public class mcontenter01 extends DebugeeClass {\n@@ -56,1 +56,1 @@\n-        loadLibrary(\"mcontenter\");\n+        loadLibrary(\"mcontenter01\");\n@@ -62,1 +62,1 @@\n-        int result =  new mcontenter001().runIt();\n+        int result =  new mcontenter01().runIt();\n@@ -73,1 +73,1 @@\n-    mcontenter001Thread thread = null;\n+    mcontenter01Thread thread = null;\n@@ -80,1 +80,1 @@\n-        thread = new mcontenter001Thread(\"Debuggee Thread\");\n+        thread = new mcontenter01Thread(\"Debuggee Thread\");\n@@ -127,1 +127,1 @@\n-class mcontenter001Thread extends Thread {\n+class mcontenter01Thread extends Thread {\n@@ -131,1 +131,1 @@\n-    public mcontenter001Thread(String name) {\n+    public mcontenter01Thread(String name) {\n@@ -137,1 +137,1 @@\n-        mcontenter001.checkStatus(DebugeeClass.TEST_PASSED);\n+        mcontenter01.checkStatus(DebugeeClass.TEST_PASSED);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEnter\/mcontenter01\/mcontenter01.java","additions":9,"deletions":9,"binary":false,"changes":18,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEnter\/mcontenter001\/mcontenter001.java","status":"renamed"},{"patch":"@@ -1,147 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.test.lib.jvmti.DebugeeClass;\n-\n-import java.io.PrintStream;\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MonitorContendedEntered\/mcontentered001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function\n- *         MonitorContendedEntered(jni, thread, object).\n- *     The test checks if the thread and object parameters of the function\n- *     contain expected values for callback when a thread enters a Java language\n- *     monitor after waiting for it to be released by another thread.\n- * COMMENTS\n- *     The test updated to match new JVMTI spec 0.2.90:\n- *     - change signature of agentProc function\n- *       and save JNIEnv pointer now passed as argument.\n- *\n- * @library \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:mcontentered mcontentered001\n- *\/\n-\n-public class mcontentered001 extends DebugeeClass {\n-\n-    \/\/ load native library if required\n-    static {\n-        loadLibrary(\"mcontentered\");\n-    }\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        int result = new mcontentered001().runIt();\n-        if (result != 0) {\n-            throw new RuntimeException(\"Unexpected status: \" + result);\n-        }\n-    }\n-\n-\n-    int status = TEST_PASSED;\n-    long timeout = 0;\n-\n-    \/\/ tested thread\n-    mcontentered001Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt() {\n-\n-        timeout =  60000; \/\/ milliseconds\n-        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n-\n-        thread = new mcontentered001Thread(\"Debuggee Thread\");\n-\n-        synchronized (thread.endingMonitor) {\n-\n-            \/\/ run thread\n-            try {\n-                \/\/ start thread\n-                synchronized (thread.startingMonitor) {\n-                    thread.start();\n-                    thread.startingMonitor.wait(timeout);\n-                }\n-            } catch (InterruptedException e) {\n-                throw new Failure(e);\n-            }\n-\n-            int totalDelay = 0;\n-            while (getEventCount() < 1 && totalDelay < timeout) {\n-                try {\n-                    Thread.sleep(100);\n-                } catch (InterruptedException e) {\n-                    throw new Failure(e);\n-                }\n-                totalDelay += 100;\n-            }\n-\n-            Thread.yield();\n-            System.out.println(\"Thread started\");\n-        }\n-\n-        \/\/ wait for thread finish\n-        try {\n-            thread.join(timeout);\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        System.out.println(\"Sync: thread finished\");\n-        status = checkStatus(status);\n-\n-        return status;\n-    }\n-\n-    private native int getEventCount();\n-}\n-\n-\/* =================================================================== *\/\n-\n-class mcontentered001Thread extends Thread {\n-    public Object startingMonitor = new Object();\n-    public Object endingMonitor = new Object();\n-\n-    public mcontentered001Thread(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-\n-        mcontentered001.checkStatus(DebugeeClass.TEST_PASSED);\n-\n-        \/\/ notify about starting\n-        synchronized (startingMonitor) {\n-            startingMonitor.notify();\n-        }\n-\n-        \/\/ wait until main thread release monitor\n-        synchronized (endingMonitor) {\n-            endingMonitor.notify();\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEntered\/mcontentered001\/mcontentered001.java","additions":0,"deletions":147,"binary":false,"changes":147,"status":"deleted"},{"patch":"@@ -245,1 +245,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_mcontentered001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_mcontentered01(JavaVM *jvm, char *options, void *reserved) {\n@@ -248,1 +248,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_mcontentered001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_mcontentered01(JavaVM *jvm, char *options, void *reserved) {\n@@ -251,1 +251,1 @@\n-JNIEXPORT jint JNI_OnLoad_mcontentered001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_mcontentered01(JavaVM *jvm, char *options, void *reserved) {\n@@ -310,1 +310,1 @@\n-JNIEXPORT jint JNICALL Java_mcontentered001_getEventCount\n+JNIEXPORT jint JNICALL Java_mcontentered01_getEventCount\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEntered\/mcontentered01\/libmcontentered01.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEntered\/mcontentered001\/libmcontentered.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MonitorContendedEntered\/mcontentered001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function\n+ *         MonitorContendedEntered(jni, thread, object).\n+ *     The test checks if the thread and object parameters of the function\n+ *     contain expected values for callback when a thread enters a Java language\n+ *     monitor after waiting for it to be released by another thread.\n+ * COMMENTS\n+ *     The test updated to match new JVMTI spec 0.2.90:\n+ *     - change signature of agentProc function\n+ *       and save JNIEnv pointer now passed as argument.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:mcontentered01 mcontentered01\n+ *\/\n+\n+public class mcontentered01 extends DebugeeClass {\n+\n+    \/\/ load native library if required\n+    static {\n+        loadLibrary(\"mcontentered01\");\n+    }\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        int result = new mcontentered01().runIt();\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+\n+    int status = TEST_PASSED;\n+    long timeout = 0;\n+\n+    \/\/ tested thread\n+    mcontentered01Thread thread = null;\n+\n+    \/\/ run debuggee\n+    public int runIt() {\n+\n+        timeout =  60000; \/\/ milliseconds\n+        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n+\n+        thread = new mcontentered01Thread(\"Debuggee Thread\");\n+\n+        synchronized (thread.endingMonitor) {\n+\n+            \/\/ run thread\n+            try {\n+                \/\/ start thread\n+                synchronized (thread.startingMonitor) {\n+                    thread.start();\n+                    thread.startingMonitor.wait(timeout);\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Failure(e);\n+            }\n+\n+            int totalDelay = 0;\n+            while (getEventCount() < 1 && totalDelay < timeout) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException e) {\n+                    throw new Failure(e);\n+                }\n+                totalDelay += 100;\n+            }\n+\n+            Thread.yield();\n+            System.out.println(\"Thread started\");\n+        }\n+\n+        \/\/ wait for thread finish\n+        try {\n+            thread.join(timeout);\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        System.out.println(\"Sync: thread finished\");\n+        status = checkStatus(status);\n+\n+        return status;\n+    }\n+\n+    private native int getEventCount();\n+}\n+\n+\/* =================================================================== *\/\n+\n+class mcontentered01Thread extends Thread {\n+    public Object startingMonitor = new Object();\n+    public Object endingMonitor = new Object();\n+\n+    public mcontentered01Thread(String name) {\n+        super(name);\n+    }\n+\n+    public void run() {\n+\n+        mcontentered01.checkStatus(DebugeeClass.TEST_PASSED);\n+\n+        \/\/ notify about starting\n+        synchronized (startingMonitor) {\n+            startingMonitor.notify();\n+        }\n+\n+        \/\/ wait until main thread release monitor\n+        synchronized (endingMonitor) {\n+            endingMonitor.notify();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEntered\/mcontentered01\/mcontentered01.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.PrintStream;\n-\n-import jdk.test.lib.jvmti.DebugeeClass;\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MonitorWait\/monitorwait001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function\n- *         MonitorWait(jni, thread, object, timeout).\n- *     The test checks if the thread, object, and timeout parameters of\n- *     the function contain expected values for callback when a thread is\n- *     about to wait on an object.\n- * COMMENTS\n- *     The test updated to match new JVMTI spec 0.2.90:\n- *     - change signature of agentProc function\n- *       and save JNIEnv pointer now passed as argument.\n- *\n- * @library \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:monitorwait monitorwait001\n- *\/\n-\n-\n-\n-public class monitorwait001 extends DebugeeClass {\n-\n-    \/\/ load native library if required\n-    static {\n-        loadLibrary(\"monitorwait\");\n-    }\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        int result = new monitorwait001().runIt();\n-        if (result != 0) {\n-            throw new RuntimeException(\"Unexpected status: \" + result);\n-        }\n-    }\n-\n-\n-    int status = DebugeeClass.TEST_PASSED;\n-    static long timeout = 0;\n-\n-    \/\/ tested thread\n-    monitorwait001Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt() {\n-        timeout = 60000; \/\/TODO fix timeout milliseconds\n-        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n-\n-        thread = new monitorwait001Thread(\"Debuggee Thread\");\n-\n-        \/\/ run thread\n-        try {\n-            \/\/ start thread\n-            synchronized (thread.startingMonitor) {\n-                thread.start();\n-                thread.startingMonitor.wait(timeout);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        Thread.yield();\n-        System.out.println(\"Thread started\");\n-\n-        synchronized (thread.waitingMonitor) {\n-            thread.waitingMonitor.notify();\n-        }\n-\n-        \/\/ wait for thread finish\n-        try {\n-            thread.join(timeout);\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        System.out.println(\"Sync: thread finished\");\n-        status = checkStatus(status);\n-\n-        return status;\n-    }\n-}\n-\n-\/* =================================================================== *\/\n-\n-class monitorwait001Thread extends Thread {\n-    public Object startingMonitor = new Object();\n-    public Object waitingMonitor = new Object();\n-\n-    public monitorwait001Thread(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-        synchronized (waitingMonitor) {\n-\n-            monitorwait001.checkStatus(DebugeeClass.TEST_PASSED);\n-\n-            \/\/ notify about starting\n-            synchronized (startingMonitor) {\n-                startingMonitor.notify();\n-            }\n-\n-            \/\/ wait until main thread notify\n-            try {\n-                waitingMonitor.wait(monitorwait001.timeout);\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWait\/monitorwait001\/monitorwait001.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -221,1 +221,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_monitorwait001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_monitorwait01(JavaVM *jvm, char *options, void *reserved) {\n@@ -224,1 +224,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_monitorwait001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_monitorwait01(JavaVM *jvm, char *options, void *reserved) {\n@@ -227,1 +227,1 @@\n-JNIEXPORT jint JNI_OnLoad_monitorwait001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_monitorwait01(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWait\/monitorwait01\/libmonitorwait.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWait\/monitorwait001\/libmonitorwait.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MonitorWait\/monitorwait001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function\n+ *         MonitorWait(jni, thread, object, timeout).\n+ *     The test checks if the thread, object, and timeout parameters of\n+ *     the function contain expected values for callback when a thread is\n+ *     about to wait on an object.\n+ * COMMENTS\n+ *     The test updated to match new JVMTI spec 0.2.90:\n+ *     - change signature of agentProc function\n+ *       and save JNIEnv pointer now passed as argument.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:monitorwait monitorwait01\n+ *\/\n+\n+\n+\n+public class monitorwait01 extends DebugeeClass {\n+\n+    \/\/ load native library if required\n+    static {\n+        loadLibrary(\"monitorwait\");\n+    }\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        int result = new monitorwait01().runIt();\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+\n+    int status = DebugeeClass.TEST_PASSED;\n+    static long timeout = 0;\n+\n+    \/\/ tested thread\n+    monitorwait01Thread thread = null;\n+\n+    \/\/ run debuggee\n+    public int runIt() {\n+        timeout = 60000; \/\/TODO fix timeout milliseconds\n+        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n+\n+        thread = new monitorwait01Thread(\"Debuggee Thread\");\n+\n+        \/\/ run thread\n+        try {\n+            \/\/ start thread\n+            synchronized (thread.startingMonitor) {\n+                thread.start();\n+                thread.startingMonitor.wait(timeout);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        Thread.yield();\n+        System.out.println(\"Thread started\");\n+\n+        synchronized (thread.waitingMonitor) {\n+            thread.waitingMonitor.notify();\n+        }\n+\n+        \/\/ wait for thread finish\n+        try {\n+            thread.join(timeout);\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        System.out.println(\"Sync: thread finished\");\n+        status = checkStatus(status);\n+\n+        return status;\n+    }\n+}\n+\n+\/* =================================================================== *\/\n+\n+class monitorwait01Thread extends Thread {\n+    public Object startingMonitor = new Object();\n+    public Object waitingMonitor = new Object();\n+\n+    public monitorwait01Thread(String name) {\n+        super(name);\n+    }\n+\n+    public void run() {\n+        synchronized (waitingMonitor) {\n+\n+            monitorwait01.checkStatus(DebugeeClass.TEST_PASSED);\n+\n+            \/\/ notify about starting\n+            synchronized (startingMonitor) {\n+                startingMonitor.notify();\n+            }\n+\n+            \/\/ wait until main thread notify\n+            try {\n+                waitingMonitor.wait(monitorwait01.timeout);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWait\/monitorwait01\/monitorwait01.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.test.lib.jvmti.DebugeeClass;\n-\n-import java.io.PrintStream;\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/MonitorWaited\/monitorwaited001.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function\n- *         MonitorWaited(jni, thread, object, timed_out).\n- *     The test checks if the thread, object, and timed_out parameters of\n- *     the function contain expected values for callback when a thread finishes\n- *     waiting on an object.\n- * COMMENTS\n- *     The test updated to match new JVMTI spec 0.2.90:\n- *     - change signature of agentProc function\n- *       and save JNIEnv pointer now passed as argument.\n- *\n- * @library \/test\/lib\n- * @run main\/othervm\/native\n- *      -agentlib:monitorwaited monitorwaited001\n- *\/\n-\n-\n-\n-public class monitorwaited001 extends DebugeeClass {\n-\n-    \/\/ load native library if required\n-    static {\n-        loadLibrary(\"monitorwaited\");\n-    }\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        int result = new monitorwaited001().runIt();\n-        if (result != 0) {\n-            throw new RuntimeException(\"Unexpected status: \" + result);\n-        }\n-    }\n-\n-\n-    int status = DebugeeClass.TEST_PASSED;\n-    static long timeout = 0;\n-\n-    \/\/ tested thread\n-    monitorwaited001Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt() {\n-        timeout =   60000; \/\/ milliseconds\n-        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n-\n-        thread = new monitorwaited001Thread(\"Debuggee Thread\");\n-\n-        \/\/ run thread\n-        try {\n-            \/\/ start thread\n-            synchronized (thread.startingMonitor) {\n-                thread.start();\n-                thread.startingMonitor.wait(timeout);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        Thread.yield();\n-        System.out.println(\"Thread started\");\n-\n-        synchronized (thread.waitingMonitor) {\n-            thread.waitingMonitor.notify();\n-        }\n-\n-        \/\/ wait for thread finish\n-        try {\n-            thread.join(timeout);\n-        } catch (InterruptedException e) {\n-            throw new Failure(e);\n-        }\n-\n-        System.out.println(\"Sync: thread finished\");\n-        status = checkStatus(status);\n-\n-        return status;\n-    }\n-}\n-\n-\/* =================================================================== *\/\n-\n-class monitorwaited001Thread extends Thread {\n-    public Object startingMonitor = new Object();\n-    public Object waitingMonitor = new Object();\n-\n-    public monitorwaited001Thread(String name) {\n-        super(name);\n-    }\n-\n-    public void run() {\n-        synchronized (waitingMonitor) {\n-\n-            monitorwaited001.checkStatus(DebugeeClass.TEST_PASSED);\n-\n-            \/\/ notify about starting\n-            synchronized (startingMonitor) {\n-                startingMonitor.notify();\n-            }\n-\n-            \/\/ wait until main thread notify\n-            try {\n-                waitingMonitor.wait(monitorwaited001.timeout);\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWaited\/monitorwaited001\/monitorwaited001.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -223,1 +223,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_monitorwaited001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_monitorwaited01(JavaVM *jvm, char *options, void *reserved) {\n@@ -226,1 +226,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_monitorwaited001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_monitorwaited01(JavaVM *jvm, char *options, void *reserved) {\n@@ -229,1 +229,1 @@\n-JNIEXPORT jint JNI_OnLoad_monitorwaited001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_monitorwaited01(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWaited\/monitorwaited01\/libmonitorwaited.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWaited\/monitorwaited001\/libmonitorwaited.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+\n+import java.io.PrintStream;\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MonitorWaited\/monitorwaited001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function\n+ *         MonitorWaited(jni, thread, object, timed_out).\n+ *     The test checks if the thread, object, and timed_out parameters of\n+ *     the function contain expected values for callback when a thread finishes\n+ *     waiting on an object.\n+ * COMMENTS\n+ *     The test updated to match new JVMTI spec 0.2.90:\n+ *     - change signature of agentProc function\n+ *       and save JNIEnv pointer now passed as argument.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:monitorwaited monitorwaited01\n+ *\/\n+\n+\n+\n+public class monitorwaited01 extends DebugeeClass {\n+\n+    \/\/ load native library if required\n+    static {\n+        loadLibrary(\"monitorwaited\");\n+    }\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        int result = new monitorwaited01().runIt();\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+\n+    int status = DebugeeClass.TEST_PASSED;\n+    static long timeout = 0;\n+\n+    \/\/ tested thread\n+    monitorwaited01Thread thread = null;\n+\n+    \/\/ run debuggee\n+    public int runIt() {\n+        timeout =   60000; \/\/ milliseconds\n+        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n+\n+        thread = new monitorwaited01Thread(\"Debuggee Thread\");\n+\n+        \/\/ run thread\n+        try {\n+            \/\/ start thread\n+            synchronized (thread.startingMonitor) {\n+                thread.start();\n+                thread.startingMonitor.wait(timeout);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        Thread.yield();\n+        System.out.println(\"Thread started\");\n+\n+        synchronized (thread.waitingMonitor) {\n+            thread.waitingMonitor.notify();\n+        }\n+\n+        \/\/ wait for thread finish\n+        try {\n+            thread.join(timeout);\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        System.out.println(\"Sync: thread finished\");\n+        status = checkStatus(status);\n+\n+        return status;\n+    }\n+}\n+\n+\/* =================================================================== *\/\n+\n+class monitorwaited01Thread extends Thread {\n+    public Object startingMonitor = new Object();\n+    public Object waitingMonitor = new Object();\n+\n+    public monitorwaited01Thread(String name) {\n+        super(name);\n+    }\n+\n+    public void run() {\n+        synchronized (waitingMonitor) {\n+\n+            monitorwaited01.checkStatus(DebugeeClass.TEST_PASSED);\n+\n+            \/\/ notify about starting\n+            synchronized (startingMonitor) {\n+                startingMonitor.notify();\n+            }\n+\n+            \/\/ wait until main thread notify\n+            try {\n+                waitingMonitor.wait(monitorwaited01.timeout);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWaited\/monitorwaited01\/monitorwaited01.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-    \"Lnativemethbind001$TestedClass;\";\n+    \"Lnativemethbind01$TestedClass;\";\n@@ -146,1 +146,1 @@\n-Java_nativemethbind001_nativeMethod(\n+Java_nativemethbind01_nativeMethod(\n@@ -179,1 +179,1 @@\n-Java_nativemethbind001_check(\n+Java_nativemethbind01_check(\n@@ -200,1 +200,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind01(JavaVM *jvm, char *options, void *reserved) {\n@@ -203,1 +203,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind01(JavaVM *jvm, char *options, void *reserved) {\n@@ -206,1 +206,1 @@\n-JNIEXPORT jint JNI_OnLoad_nativemethbind001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_nativemethbind01(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind01\/libnativemethbind01.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind001\/libnativemethbind01.cpp","status":"renamed"},{"patch":"@@ -51,1 +51,1 @@\n- *      -agentlib:nativemethbind01 nativemethbind001\n+ *      -agentlib:nativemethbind01 nativemethbind01\n@@ -70,1 +70,1 @@\n-public class nativemethbind001 {\n+public class nativemethbind01 {\n@@ -75,1 +75,1 @@\n-            System.err.println(\"Could not load \\\"nativemethbind001\\\" library\");\n+            System.err.println(\"Could not load \\\"nativemethbind01\\\" library\");\n@@ -87,1 +87,1 @@\n-        new nativemethbind001().runThis();\n+        new nativemethbind01().runThis();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind01\/nativemethbind01.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind001\/nativemethbind001.java","status":"renamed"},{"patch":"@@ -130,1 +130,1 @@\n-Java_nativemethbind002_nativeMethod(\n+Java_nativemethbind02_nativeMethod(\n@@ -138,1 +138,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind02(JavaVM *jvm, char *options, void *reserved) {\n@@ -141,1 +141,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind02(JavaVM *jvm, char *options, void *reserved) {\n@@ -144,1 +144,1 @@\n-JNIEXPORT jint JNI_OnLoad_nativemethbind002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_nativemethbind02(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind02\/libnativemethbind02.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind002\/libnativemethbind02.cpp","status":"renamed"},{"patch":"@@ -47,1 +47,1 @@\n- *      -agentlib:nativemethbind02 nativemethbind002\n+ *      -agentlib:nativemethbind02 nativemethbind02\n@@ -60,1 +60,1 @@\n-public class nativemethbind002 {\n+public class nativemethbind02 {\n@@ -65,1 +65,1 @@\n-            System.err.println(\"Could not load \\\"nativemethbind002\\\" library\");\n+            System.err.println(\"Could not load \\\"nativemethbind02\\\" library\");\n@@ -75,1 +75,1 @@\n-        new nativemethbind002().runThis();\n+        new nativemethbind02().runThis();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind02\/nativemethbind02.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind002\/nativemethbind002.java","status":"renamed"},{"patch":"@@ -46,1 +46,1 @@\n-    \"Lnativemethbind003$TestedClass;\";\n+    \"Lnativemethbind03$TestedClass;\";\n@@ -162,1 +162,1 @@\n-Java_nativemethbind003_registerNative(\n+Java_nativemethbind03_registerNative(\n@@ -202,1 +202,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind003(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind03(JavaVM *jvm, char *options, void *reserved) {\n@@ -205,1 +205,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind003(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind03(JavaVM *jvm, char *options, void *reserved) {\n@@ -208,1 +208,1 @@\n-JNIEXPORT jint JNI_OnLoad_nativemethbind003(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_nativemethbind03(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind03\/libnativemethbind03.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind003\/libnativemethbind03.cpp","status":"renamed"},{"patch":"@@ -52,1 +52,1 @@\n- *      -agentlib:nativemethbind03 nativemethbind003\n+ *      -agentlib:nativemethbind03 nativemethbind03\n@@ -67,1 +67,1 @@\n-public class nativemethbind003 {\n+public class nativemethbind03 {\n@@ -72,1 +72,1 @@\n-            System.err.println(\"Could not load \\\"nativemethbind003\\\" library\");\n+            System.err.println(\"Could not load \\\"nativemethbind03\\\" library\");\n@@ -82,1 +82,1 @@\n-        new nativemethbind003().runThis();\n+        new nativemethbind03().runThis();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind03\/nativemethbind03.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind003\/nativemethbind003.java","status":"renamed"},{"patch":"@@ -52,1 +52,1 @@\n-Java_nativemethbind004_nativeMethod(\n+Java_nativemethbind04_nativeMethod(\n@@ -147,1 +147,1 @@\n-    Java_nativemethbind004_check(\n+    Java_nativemethbind04_check(\n@@ -179,1 +179,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind004(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind04(JavaVM *jvm, char *options, void *reserved) {\n@@ -182,1 +182,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind004(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind04(JavaVM *jvm, char *options, void *reserved) {\n@@ -185,1 +185,1 @@\n-JNIEXPORT jint JNI_OnLoad_nativemethbind004(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_nativemethbind04(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind04\/libnativemethbind04.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind004\/libnativemethbind04.cpp","status":"renamed"},{"patch":"@@ -50,1 +50,1 @@\n- *      -agentlib:nativemethbind04 nativemethbind004\n+ *      -agentlib:nativemethbind04 nativemethbind04\n@@ -68,1 +68,1 @@\n-public class nativemethbind004 {\n+public class nativemethbind04 {\n@@ -73,1 +73,1 @@\n-            System.err.println(\"Could not load \\\"nativemethbind004\\\" library\");\n+            System.err.println(\"Could not load \\\"nativemethbind04\\\" library\");\n@@ -84,1 +84,1 @@\n-        new nativemethbind004().runThis();\n+        new nativemethbind04().runThis();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind04\/nativemethbind04.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind004\/nativemethbind004.java","status":"renamed"},{"patch":"@@ -49,1 +49,1 @@\n-    \"Lsinglestep001;\";\n+    \"Lsinglestep01;\";\n@@ -241,1 +241,1 @@\n-Java_singlestep001_check(\n+Java_singlestep01_check(\n@@ -256,1 +256,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_singlestep001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_singlestep01(JavaVM *jvm, char *options, void *reserved) {\n@@ -259,1 +259,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_singlestep001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_singlestep01(JavaVM *jvm, char *options, void *reserved) {\n@@ -262,1 +262,1 @@\n-JNIEXPORT jint JNI_OnLoad_singlestep001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_singlestep01(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep01\/libsinglestep01.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep001\/libsinglestep01.cpp","status":"renamed"},{"patch":"@@ -48,1 +48,1 @@\n- * @run main\/othervm\/native -agentlib:singlestep01 singlestep001\n+ * @run main\/othervm\/native -agentlib:singlestep01 singlestep01\n@@ -67,1 +67,1 @@\n-public class singlestep001 {\n+public class singlestep01 {\n@@ -72,1 +72,1 @@\n-            System.err.println(\"Could not load \\\"singlestep001\\\" library\");\n+            System.err.println(\"Could not load \\\"singlestep01\\\" library\");\n@@ -82,1 +82,1 @@\n-        int result = new singlestep001().runThis();\n+        int result = new singlestep01().runThis();\n@@ -91,1 +91,1 @@\n-        Thread.currentThread().setName(\"singlestep001Thr\");\n+        Thread.currentThread().setName(\"singlestep01Thr\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep01\/singlestep01.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep001\/singlestep001.java","status":"renamed"},{"patch":"@@ -82,1 +82,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_singlestep002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_singlestep02(JavaVM *jvm, char *options, void *reserved) {\n@@ -85,1 +85,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_singlestep002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_singlestep02(JavaVM *jvm, char *options, void *reserved) {\n@@ -88,1 +88,1 @@\n-JNIEXPORT jint JNI_OnLoad_singlestep002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_singlestep02(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep02\/libsinglestep02.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep002\/libsinglestep02.cpp","status":"renamed"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm\/native -agentlib:singlestep02 singlestep002\n+ * @run main\/othervm\/native -agentlib:singlestep02 singlestep02\n@@ -58,1 +58,1 @@\n-public class singlestep002 {\n+public class singlestep02 {\n@@ -64,1 +64,1 @@\n-            System.err.println(\"Could not load \\\"singlestep002\\\" library\");\n+            System.err.println(\"Could not load \\\"singlestep02\\\" library\");\n@@ -72,1 +72,1 @@\n-        new singlestep002().runThis(argv);\n+        new singlestep02().runThis(argv);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep02\/singlestep02.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep002\/singlestep002.java","status":"renamed"},{"patch":"@@ -53,1 +53,1 @@\n-    \"Lsinglestep003;\";\n+    \"Lsinglestep03;\";\n@@ -260,1 +260,1 @@\n-Java_singlestep003_anotherNativeMethod(\n+Java_singlestep03_anotherNativeMethod(\n@@ -267,1 +267,1 @@\n-Java_singlestep003_nativeMethod(\n+Java_singlestep03_nativeMethod(\n@@ -274,1 +274,1 @@\n-  Java_singlestep003_anotherNativeMethod(jni, obj, i);\n+  Java_singlestep03_anotherNativeMethod(jni, obj, i);\n@@ -277,1 +277,1 @@\n-JNIEXPORT jint JNICALL Java_singlestep003_check(\n+JNIEXPORT jint JNICALL Java_singlestep03_check(\n@@ -298,1 +298,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_singlestep003(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_singlestep03(JavaVM *jvm, char *options, void *reserved) {\n@@ -301,1 +301,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_singlestep003(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_singlestep03(JavaVM *jvm, char *options, void *reserved) {\n@@ -304,1 +304,1 @@\n-JNIEXPORT jint JNI_OnLoad_singlestep003(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_singlestep03(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep03\/libsinglestep03.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep003\/libsinglestep03.cpp","status":"renamed"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main\/othervm\/native -agentlib:singlestep03 singlestep003\n+ * @run main\/othervm\/native -agentlib:singlestep03 singlestep03\n@@ -64,1 +64,1 @@\n-public class singlestep003 {\n+public class singlestep03 {\n@@ -69,1 +69,1 @@\n-            System.err.println(\"Could not load \\\"singlestep003\\\" library\");\n+            System.err.println(\"Could not load \\\"singlestep03\\\" library\");\n@@ -82,1 +82,1 @@\n-        int result = new singlestep003().runThis();\n+        int result = new singlestep03().runThis();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep03\/singlestep03.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep003\/singlestep003.java","status":"renamed"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.test.lib.jvmti.DebugeeClass;\n-import java.io.PrintStream;\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/ThreadEnd\/threadend002.\n- * VM Testbase keywords: [quick, jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test exercises JVMTI event callback function THREAD_END.\n- *     The test enables this event during OnLoad phase. The test fails\n- *     if no THREAD_END event is received\n- * COMMENTS\n- *\n- * @library \/test\/lib\n- * @run main\/othervm\/native -agentlib:threadend02=-waittime=5 threadend002\n- *\/\n-\n-public class threadend002 extends DebugeeClass {\n-\n-    \/\/ run test from command line\n-    public static void main(String argv[]) {\n-        int result = run(argv, System.out);\n-        if (result != 0) {\n-            throw new RuntimeException(\"Unexpected status: \" + result);\n-        }\n-    }\n-\n-    \/\/ run test from JCK-compatible environment\n-    public static int run(String argv[], PrintStream out) {\n-        return new threadend002().runIt(argv, out);\n-    }\n-\n-    \/\/ run debuggee\n-    public int runIt(String argv[], PrintStream out) {\n-\n-        int status = threadend002.checkStatus(DebugeeClass.TEST_PASSED);\n-\n-        threadend002Thread thrd = new threadend002Thread();\n-        thrd.start();\n-\n-        try {\n-            thrd.join();\n-        } catch(InterruptedException e) {\n-            System.out.println(\"Unexpected exception \" + e);\n-            e.printStackTrace();\n-            return DebugeeClass.TEST_FAILED;\n-        }\n-\n-        int currStatus = threadend002.checkStatus(DebugeeClass.TEST_PASSED);\n-        if (currStatus != DebugeeClass.TEST_PASSED)\n-            status = currStatus;\n-\n-        return status;\n-    }\n-\n-    class threadend002Thread extends Thread {\n-\n-        public void run() {\n-            System.out.println(\"thread finished\");\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend002\/threadend002.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -72,1 +72,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadend001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadend01(JavaVM *jvm, char *options, void *reserved) {\n@@ -75,1 +75,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadend001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadend01(JavaVM *jvm, char *options, void *reserved) {\n@@ -78,1 +78,1 @@\n-JNIEXPORT jint JNI_OnLoad_threadend001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_threadend01(JavaVM *jvm, char *options, void *reserved) {\n@@ -108,1 +108,1 @@\n-Java_threadend001_getReady(JNIEnv *jni,\n+Java_threadend01_getReady(JNIEnv *jni,\n@@ -136,1 +136,1 @@\n-Java_threadend001_check(JNIEnv *jni, jclass cls) {\n+Java_threadend01_check(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend01\/libthreadend01.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend001\/libthreadend01.cpp","status":"renamed"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main\/othervm\/native -agentlib:threadend01 threadend001\n+ * @run main\/othervm\/native -agentlib:threadend01 threadend01\n@@ -44,1 +44,1 @@\n-public class threadend001 {\n+public class threadend01 {\n@@ -48,1 +48,1 @@\n-    final static String NAME_PREFIX = \"threadend001-\";\n+    final static String NAME_PREFIX = \"threadend01-\";\n@@ -54,1 +54,1 @@\n-            System.err.println(\"Could not load threadend001 library\");\n+            System.err.println(\"Could not load threadend01 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend01\/threadend01.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend001\/threadend001.java","status":"renamed"},{"patch":"@@ -136,1 +136,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadend002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadend02(JavaVM *jvm, char *options, void *reserved) {\n@@ -139,1 +139,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadend002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadend02(JavaVM *jvm, char *options, void *reserved) {\n@@ -142,1 +142,1 @@\n-JNIEXPORT jint JNI_OnLoad_threadend002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_threadend02(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend02\/libthreadend02.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend002\/libthreadend02.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/ThreadEnd\/threadend002.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function THREAD_END.\n+ *     The test enables this event during OnLoad phase. The test fails\n+ *     if no THREAD_END event is received\n+ * COMMENTS\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:threadend02=-waittime=5 threadend02\n+ *\/\n+\n+public class threadend02 extends DebugeeClass {\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        int result = run(argv, System.out);\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+    \/\/ run test from JCK-compatible environment\n+    public static int run(String argv[], PrintStream out) {\n+        return new threadend02().runIt(argv, out);\n+    }\n+\n+    \/\/ run debuggee\n+    public int runIt(String argv[], PrintStream out) {\n+\n+        int status = threadend02.checkStatus(DebugeeClass.TEST_PASSED);\n+\n+        threadend02Thread thrd = new threadend02Thread();\n+        thrd.start();\n+\n+        try {\n+            thrd.join();\n+        } catch(InterruptedException e) {\n+            System.out.println(\"Unexpected exception \" + e);\n+            e.printStackTrace();\n+            return DebugeeClass.TEST_FAILED;\n+        }\n+\n+        int currStatus = threadend02.checkStatus(DebugeeClass.TEST_PASSED);\n+        if (currStatus != DebugeeClass.TEST_PASSED)\n+            status = currStatus;\n+\n+        return status;\n+    }\n+\n+    class threadend02Thread extends Thread {\n+\n+        public void run() {\n+            System.out.println(\"thread finished\");\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend02\/threadend02.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -72,1 +72,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadstart001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadstart01(JavaVM *jvm, char *options, void *reserved) {\n@@ -75,1 +75,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadstart001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadstart01(JavaVM *jvm, char *options, void *reserved) {\n@@ -78,1 +78,1 @@\n-JNIEXPORT jint JNI_OnLoad_threadstart001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_threadstart01(JavaVM *jvm, char *options, void *reserved) {\n@@ -108,1 +108,1 @@\n-Java_threadstart001_getReady(JNIEnv *jni,\n+Java_threadstart01_getReady(JNIEnv *jni,\n@@ -136,1 +136,1 @@\n-Java_threadstart001_check(JNIEnv *jni, jclass cls) {\n+Java_threadstart01_check(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart01\/libthreadstart01.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart001\/libthreadstart01.cpp","status":"renamed"},{"patch":"@@ -41,1 +41,1 @@\n- * @run main\/othervm\/native -agentlib:threadstart01 threadstart001\n+ * @run main\/othervm\/native -agentlib:threadstart01 threadstart01\n@@ -44,1 +44,1 @@\n-public class threadstart001 {\n+public class threadstart01 {\n@@ -48,1 +48,1 @@\n-    final static String NAME_PREFIX = \"threadstart001-\";\n+    final static String NAME_PREFIX = \"threadstart01-\";\n@@ -54,1 +54,1 @@\n-            System.err.println(\"Could not load threadstart001 library\");\n+            System.err.println(\"Could not load threadstart01 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart01\/threadstart01.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart001\/threadstart001.java","status":"renamed"},{"patch":"@@ -440,1 +440,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadstart002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadstart02(JavaVM *jvm, char *options, void *reserved) {\n@@ -443,1 +443,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadstart002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadstart02(JavaVM *jvm, char *options, void *reserved) {\n@@ -446,1 +446,1 @@\n-JNIEXPORT jint JNI_OnLoad_threadstart002(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_threadstart02(JavaVM *jvm, char *options, void *reserved) {\n@@ -523,1 +523,1 @@\n-Java_threadstart002_check(JNIEnv *jni, jclass cls) {\n+Java_threadstart02_check(JNIEnv *jni, jclass cls) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart02\/libthreadstart02.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart002\/libthreadstart02.cpp","status":"renamed"},{"patch":"@@ -63,1 +63,1 @@\n- * @run main\/othervm\/native -agentlib:threadstart02 threadstart002 5\n+ * @run main\/othervm\/native -agentlib:threadstart02 threadstart02 5\n@@ -66,1 +66,1 @@\n-public class threadstart002 {\n+public class threadstart02 {\n@@ -74,1 +74,1 @@\n-        System.err.println(\"Could not load threadstart002 library\");\n+        System.err.println(\"Could not load threadstart02 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart02\/threadstart02.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart002\/threadstart002.java","status":"renamed"},{"patch":"@@ -86,1 +86,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_threadstart003(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadstart03(JavaVM *jvm, char *options, void *reserved) {\n@@ -89,1 +89,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_threadstart003(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadstart03(JavaVM *jvm, char *options, void *reserved) {\n@@ -92,1 +92,1 @@\n-JNIEXPORT jint JNI_OnLoad_threadstart003(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_threadstart03(JavaVM *jvm, char *options, void *reserved) {\n@@ -147,1 +147,1 @@\n-Java_threadstart003_check(JNIEnv *jni,\n+Java_threadstart03_check(JNIEnv *jni,\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart03\/libthreadstart03.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart003\/libthreadstart03.cpp","status":"renamed"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm\/native -agentlib:threadstart03 threadstart003\n+ * @run main\/othervm\/native -agentlib:threadstart03 threadstart03\n@@ -47,1 +47,1 @@\n-public class threadstart003 {\n+public class threadstart03 {\n@@ -56,1 +56,1 @@\n-            System.err.println(\"Could not load threadstart003 library\");\n+            System.err.println(\"Could not load threadstart03 library\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart03\/threadstart03.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart003\/threadstart003.java","status":"renamed"},{"patch":"@@ -105,1 +105,1 @@\n-JNIEXPORT jint JNICALL Agent_OnLoad_vmobjalloc001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnLoad_vmobjalloc01(JavaVM *jvm, char *options, void *reserved) {\n@@ -108,1 +108,1 @@\n-JNIEXPORT jint JNICALL Agent_OnAttach_vmobjalloc001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNICALL Agent_OnAttach_vmobjalloc01(JavaVM *jvm, char *options, void *reserved) {\n@@ -111,1 +111,1 @@\n-JNIEXPORT jint JNI_OnLoad_vmobjalloc001(JavaVM *jvm, char *options, void *reserved) {\n+JNIEXPORT jint JNI_OnLoad_vmobjalloc01(JavaVM *jvm, char *options, void *reserved) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/VMObjectAlloc\/vmobjalloc01\/libvmobjalloc01.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/VMObjectAlloc\/vmobjalloc001\/libvmobjalloc.cpp","status":"renamed"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main\/othervm\/native -agentlib:vmobjalloc vmobjalloc001\n+ * @run main\/othervm\/native -agentlib:vmobjalloc vmobjalloc01\n@@ -50,1 +50,1 @@\n-public class vmobjalloc001 extends DebugeeClass {\n+public class vmobjalloc01 extends DebugeeClass {\n@@ -54,1 +54,1 @@\n-        new vmobjalloc001().runIt();\n+        new vmobjalloc01().runIt();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/VMObjectAlloc\/vmobjalloc01\/vmobjalloc01.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/VMObjectAlloc\/vmobjalloc001\/vmobjalloc001.java","status":"renamed"}]}