{"files":[{"patch":"@@ -151,2 +151,2 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS\n-BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS\n+BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n+BUILD_HOTSPOT_JTREG_EXECUTABLES_CFLAGS := -D__STDC_FORMAT_MACROS -D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS -I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/breakpoint001\/breakpoint001.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/breakpoint001.java","status":"renamed"},{"patch":"@@ -64,1 +64,1 @@\n-static void setBP(jvmtiEnv *jvmti_env, JNIEnv *env, jclass klass) {\n+static void setBP(jvmtiEnv *jvmti, JNIEnv *env, jclass klass) {\n@@ -75,1 +75,1 @@\n-    err = jvmti_env->SetBreakpoint(mid, 0);\n+    err = jvmti->SetBreakpoint(mid, 0);\n@@ -84,1 +84,1 @@\n-ClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread, jclass klass) {\n+ClassLoad(jvmtiEnv *jvmti, JNIEnv *env, jthread thread, jclass klass) {\n@@ -92,1 +92,1 @@\n-    err = jvmti_env->GetClassSignature(klass, &sig, &generic);\n+    err = jvmti->GetClassSignature(klass, &sig, &generic);\n@@ -99,1 +99,1 @@\n-      setBP(jvmti_env, env, klass);\n+      setBP(jvmti, env, klass);\n@@ -107,1 +107,1 @@\n-Breakpoint(jvmtiEnv *jvmti_env, JNIEnv *jni_env, jthread thread,\n+Breakpoint(jvmtiEnv *jvmti, JNIEnv *jni_env, jthread thread,\n@@ -119,1 +119,1 @@\n-  err = jvmti_env->GetThreadInfo(thread, &thr_info);\n+  err = jvmti->GetThreadInfo(thread, &thr_info);\n@@ -148,1 +148,1 @@\n-  err = jvmti_env->GetMethodDeclaringClass(method, &klass);\n+  err = jvmti->GetMethodDeclaringClass(method, &klass);\n@@ -154,1 +154,1 @@\n-  err = jvmti_env->GetClassSignature(klass, &clsSig, &generic);\n+  err = jvmti->GetClassSignature(klass, &clsSig, &generic);\n@@ -171,1 +171,1 @@\n-  err = jvmti_env->GetMethodName(method, &methNam, &methSig, NULL);\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n@@ -187,1 +187,1 @@\n-  err = jvmti_env->Deallocate((unsigned char *) methNam);\n+  err = jvmti->Deallocate((unsigned char *) methNam);\n@@ -193,1 +193,1 @@\n-  err = jvmti_env->Deallocate((unsigned char *) methSig);\n+  err = jvmti->Deallocate((unsigned char *) methSig);\n@@ -203,1 +203,1 @@\n-VMStart(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n+VMStart(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n@@ -212,1 +212,1 @@\n-VMDeath(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n+VMDeath(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/breakpoint001\/libbreakpoint.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"previous_filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Breakpoint\/libbreakpoint.cpp","status":"renamed"},{"patch":"@@ -81,8 +81,0 @@\n-    public static int run(String args[], PrintStream out) {\n-        return new classload001().runIt(args, out);\n-    }\n-\n-    private int runIt(String args[], PrintStream out) {\n-        return check();\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassLoad\/classload001\/classload001.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,2 +95,2 @@\n-static void lock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-  if (jvmti_env->RawMonitorEnter(countLock) != JVMTI_ERROR_NONE) {\n+static void lock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  if (jvmti->RawMonitorEnter(countLock) != JVMTI_ERROR_NONE) {\n@@ -101,2 +101,2 @@\n-static void unlock(jvmtiEnv *jvmti_env, JNIEnv *jni_env) {\n-  if (jvmti_env->RawMonitorExit(countLock) != JVMTI_ERROR_NONE) {\n+static void unlock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  if (jvmti->RawMonitorExit(countLock) != JVMTI_ERROR_NONE) {\n@@ -109,1 +109,1 @@\n-ClassLoad(jvmtiEnv *jvmti_env, JNIEnv *env, jthread thread, jclass klass) {\n+ClassLoad(jvmtiEnv *jvmti, JNIEnv *env, jthread thread, jclass klass) {\n@@ -114,1 +114,1 @@\n-  lock(jvmti_env, env);\n+  lock(jvmti, env);\n@@ -116,1 +116,1 @@\n-  err = jvmti_env->GetClassSignature(klass, &sig, &generic);\n+  err = jvmti->GetClassSignature(klass, &sig, &generic);\n@@ -120,1 +120,1 @@\n-    unlock(jvmti_env, env);\n+    unlock(jvmti, env);\n@@ -142,1 +142,1 @@\n-  unlock(jvmti_env, env);\n+  unlock(jvmti, env);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassLoad\/classload001\/libclassload.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-    static class TestClass implements TestInterface {\n+     static class TestClass implements TestInterface {\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassPrepare\/classprep001\/classprep001.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#include \"jvmti_common.h\"\n+\n+\n@@ -64,103 +67,0 @@\n-const char* TranslateError(jvmtiError err) {\n-  switch (err) {\n-    case JVMTI_ERROR_NONE:\n-      return (\"JVMTI_ERROR_NONE\");\n-    case JVMTI_ERROR_INVALID_THREAD:\n-      return (\"JVMTI_ERROR_INVALID_THREAD\");\n-    case JVMTI_ERROR_INVALID_THREAD_GROUP:\n-      return (\"JVMTI_ERROR_INVALID_THREAD_GROUP\");\n-    case JVMTI_ERROR_INVALID_PRIORITY:\n-      return (\"JVMTI_ERROR_INVALID_PRIORITY\");\n-    case JVMTI_ERROR_THREAD_NOT_SUSPENDED:\n-      return (\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n-    case JVMTI_ERROR_THREAD_SUSPENDED:\n-      return (\"JVMTI_ERROR_THREAD_SUSPENDED\");\n-    case JVMTI_ERROR_THREAD_NOT_ALIVE:\n-      return (\"JVMTI_ERROR_THREAD_NOT_ALIVE\");\n-    case JVMTI_ERROR_INVALID_OBJECT:\n-      return (\"JVMTI_ERROR_INVALID_OBJECT\");\n-    case JVMTI_ERROR_INVALID_CLASS:\n-      return (\"JVMTI_ERROR_INVALID_CLASS\");\n-    case JVMTI_ERROR_CLASS_NOT_PREPARED:\n-      return (\"JVMTI_ERROR_CLASS_NOT_PREPARED\");\n-    case JVMTI_ERROR_INVALID_METHODID:\n-      return (\"JVMTI_ERROR_INVALID_METHODID\");\n-    case JVMTI_ERROR_INVALID_LOCATION:\n-      return (\"JVMTI_ERROR_INVALID_LOCATION\");\n-    case JVMTI_ERROR_INVALID_FIELDID:\n-      return (\"JVMTI_ERROR_INVALID_FIELDID\");\n-    case JVMTI_ERROR_NO_MORE_FRAMES:\n-      return (\"JVMTI_ERROR_NO_MORE_FRAMES\");\n-    case JVMTI_ERROR_OPAQUE_FRAME:\n-      return (\"JVMTI_ERROR_OPAQUE_FRAME\");\n-    case JVMTI_ERROR_TYPE_MISMATCH:\n-      return (\"JVMTI_ERROR_TYPE_MISMATCH\");\n-    case JVMTI_ERROR_INVALID_SLOT:\n-      return (\"JVMTI_ERROR_INVALID_SLOT\");\n-    case JVMTI_ERROR_DUPLICATE:\n-      return (\"JVMTI_ERROR_DUPLICATE\");\n-    case JVMTI_ERROR_NOT_FOUND:\n-      return (\"JVMTI_ERROR_NOT_FOUND\");\n-    case JVMTI_ERROR_INVALID_MONITOR:\n-      return (\"JVMTI_ERROR_INVALID_MONITOR\");\n-    case JVMTI_ERROR_NOT_MONITOR_OWNER:\n-      return (\"JVMTI_ERROR_NOT_MONITOR_OWNER\");\n-    case JVMTI_ERROR_INTERRUPT:\n-      return (\"JVMTI_ERROR_INTERRUPT\");\n-    case JVMTI_ERROR_INVALID_CLASS_FORMAT:\n-      return (\"JVMTI_ERROR_INVALID_CLASS_FORMAT\");\n-    case JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION:\n-      return (\"JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION\");\n-    case JVMTI_ERROR_FAILS_VERIFICATION:\n-      return (\"JVMTI_ERROR_FAILS_VERIFICATION\");\n-    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED:\n-      return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED\");\n-    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED:\n-      return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED\");\n-    case JVMTI_ERROR_INVALID_TYPESTATE:\n-      return (\"JVMTI_ERROR_INVALID_TYPESTATE\");\n-    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED:\n-      return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED\");\n-    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED:\n-      return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED\");\n-    case JVMTI_ERROR_UNSUPPORTED_VERSION:\n-      return (\"JVMTI_ERROR_UNSUPPORTED_VERSION\");\n-    case JVMTI_ERROR_NAMES_DONT_MATCH:\n-      return (\"JVMTI_ERROR_NAMES_DONT_MATCH\");\n-    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED:\n-      return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED\");\n-    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED:\n-      return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED\");\n-    case JVMTI_ERROR_UNMODIFIABLE_CLASS:\n-      return (\"JVMTI_ERROR_UNMODIFIABLE_CLASS\");\n-    case JVMTI_ERROR_NOT_AVAILABLE:\n-      return (\"JVMTI_ERROR_NOT_AVAILABLE\");\n-    case JVMTI_ERROR_MUST_POSSESS_CAPABILITY:\n-      return (\"JVMTI_ERROR_MUST_POSSESS_CAPABILITY\");\n-    case JVMTI_ERROR_NULL_POINTER:\n-      return (\"JVMTI_ERROR_NULL_POINTER\");\n-    case JVMTI_ERROR_ABSENT_INFORMATION:\n-      return (\"JVMTI_ERROR_ABSENT_INFORMATION\");\n-    case JVMTI_ERROR_INVALID_EVENT_TYPE:\n-      return (\"JVMTI_ERROR_INVALID_EVENT_TYPE\");\n-    case JVMTI_ERROR_ILLEGAL_ARGUMENT:\n-      return (\"JVMTI_ERROR_ILLEGAL_ARGUMENT\");\n-    case JVMTI_ERROR_NATIVE_METHOD:\n-      return (\"JVMTI_ERROR_NATIVE_METHOD\");\n-    case JVMTI_ERROR_OUT_OF_MEMORY:\n-      return (\"JVMTI_ERROR_OUT_OF_MEMORY\");\n-    case JVMTI_ERROR_ACCESS_DENIED:\n-      return (\"JVMTI_ERROR_ACCESS_DENIED\");\n-    case JVMTI_ERROR_WRONG_PHASE:\n-      return (\"JVMTI_ERROR_WRONG_PHASE\");\n-    case JVMTI_ERROR_INTERNAL:\n-      return (\"JVMTI_ERROR_INTERNAL\");\n-    case JVMTI_ERROR_UNATTACHED_THREAD:\n-      return (\"JVMTI_ERROR_UNATTACHED_THREAD\");\n-    case JVMTI_ERROR_INVALID_ENVIRONMENT:\n-      return (\"JVMTI_ERROR_INVALID_ENVIRONMENT\");\n-    default:\n-      return (\"<unknown error>\");\n-  }\n-}\n-\n@@ -191,1 +91,1 @@\n-void JNICALL ClassPrepare(jvmtiEnv *jvmti_env, JNIEnv *env,\n+void JNICALL ClassPrepare(jvmtiEnv *jvmti, JNIEnv *env,\n@@ -201,1 +101,1 @@\n-  err = jvmti_env->GetClassSignature(cls, &inf.sig, &generic);\n+  err = jvmti->GetClassSignature(cls, &inf.sig, &generic);\n@@ -208,1 +108,1 @@\n-  err = jvmti_env->GetClassStatus(cls, &inf.status);\n+  err = jvmti->GetClassStatus(cls, &inf.status);\n@@ -214,1 +114,1 @@\n-  err = jvmti_env->GetClassMethods(cls, &inf.mcount, &methods);\n+  err = jvmti->GetClassMethods(cls, &inf.mcount, &methods);\n@@ -221,1 +121,1 @@\n-  err = jvmti_env->GetClassFields(cls, &inf.fcount, &fields);\n+  err = jvmti->GetClassFields(cls, &inf.fcount, &fields);\n@@ -228,1 +128,1 @@\n-  err = jvmti_env->GetImplementedInterfaces(cls,\n+  err = jvmti->GetImplementedInterfaces(cls,\n@@ -248,1 +148,1 @@\n-        err = jvmti_env->GetMethodName(methods[i],\n+        err = jvmti->GetMethodName(methods[i],\n@@ -264,1 +164,1 @@\n-        err = jvmti_env->GetFieldName(cls, fields[i],\n+        err = jvmti->GetFieldName(cls, fields[i],\n@@ -280,1 +180,1 @@\n-        err = jvmti_env->GetClassSignature(\n+        err = jvmti->GetClassSignature(\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ClassPrepare\/classprep001\/libclassprep.cpp","additions":12,"deletions":112,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/Exception\/exception001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function Exception.\n+ *     The test checks if the parameters of the function contain\n+ *     the expected values for the following exceptions thrown by Java methods:\n+ *       - custom class exception001c extending Throwable\n+ *       - ArithmeticException caused by division with zero devisor\n+ *       - IndexOutOfBoundsException caused by using out of range array index\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @compile exception001a.jasm\n+ * @run main\/othervm\/native -agentlib:exception exception001\n+ *\/\n+\n+\n+\n+public class exception001 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"exception\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load exception001 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+        int result = check();\n+        if (result != 0) {\n+            throw new RuntimeException(\"check failed with result \" + result);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception001\/exception001.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* Reassembled from the following Java pattern:\n+ *\n+ * public class exception001a {\n+ *     public static void run() {\n+ *         exception001b t = new exception001b();\n+ *         try {\n+ *             t.meth1();\n+ *         } catch (Throwable e) {}\n+ *         try {\n+ *             t.meth2(0);\n+ *         } catch (Throwable e) {}\n+ *         try {\n+ *             t.meth3(2);\n+ *         } catch (Throwable e) {}\n+ *     }\n+ * }\n+ *\n+ * class exception001b {\n+ *     public static void meth1() throws Throwable {\n+ *         throw new exception001c();\n+ *     }\n+ *\n+ *     public int meth2(int i) throws ArithmeticException {\n+ *         return (10 \/ i);\n+ *     }\n+ *\n+ *     public int meth3(int i) throws IndexOutOfBoundsException {\n+ *         int arr[] = {1};\n+ *         return arr[i];\n+ *     }\n+ * }\n+ *\n+ * class exception001c extends Throwable {\n+ * }\n+ *\n+ *\/\n+\n+super public class exception001a {\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method run:\"()V\" stack 2 locals 2 {\n+        new     class exception001b;\n+        dup;\n+        invokespecial Method exception001b.\"<init>\":\"()V\";\n+        astore_0;\n+    try t0;\n+        invokestatic Method exception001b.meth1:\"()V\";\n+    endtry t0;\n+        goto    L15;\n+    catch t0 java\/lang\/Throwable; \/\/ bci=14\n+        astore_1;\n+    try t1;\n+L15:    aload_0;\n+        iconst_0;\n+        invokevirtual Method exception001b.meth2:\"(I)I\";\n+        pop;\n+    endtry t1;\n+        goto    L25;\n+    catch t1 java\/lang\/Throwable; \/\/ bci=24\n+        astore_1;\n+    try t2;\n+L25:    aload_0;\n+        iconst_2;\n+        invokevirtual Method exception001b.meth3:\"(I)I\";\n+        pop;\n+    endtry t2;\n+        goto    L35;\n+    catch t2 java\/lang\/Throwable; \/\/ bci=34\n+        astore_1;\n+L35:    return;\n+    }\n+\n+}\n+\n+super class exception001b {\n+\n+    Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method meth1:\"()V\"\n+    throws java\/lang\/Throwable\n+    stack 2 locals 0 {\n+        new     class exception001c;\n+        dup;\n+        invokespecial Method exception001c.\"<init>\":\"()V\";\n+        athrow; \/\/ bci=7\n+    }\n+\n+    public Method meth2:\"(I)I\"\n+    throws java\/lang\/ArithmeticException\n+    stack 2 locals 2 {\n+        bipush  10;\n+        iload_1;\n+        idiv;   \/\/ bci=3\n+        ireturn;\n+    }\n+\n+    public Method meth3:\"(I)I\"\n+    throws java\/lang\/IndexOutOfBoundsException\n+    stack 4 locals 3 {\n+        iconst_1;\n+        newarray int;\n+        dup;\n+        iconst_0;\n+        iconst_1;\n+        iastore;\n+        astore_2;\n+        aload_2;\n+        iload_1;\n+        iaload;  \/\/ bci=10\n+        ireturn;\n+    }\n+}\n+\n+super class exception001c extends java\/lang\/Throwable {\n+\n+    Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial Method java\/lang\/Throwable.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception001\/exception001a.jasm","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  char *name;\n+  char *t_cls;\n+  char *t_name;\n+  char *t_sig;\n+  jlocation t_loc;\n+  char *c_cls;\n+  char *c_name;\n+  char *c_sig;\n+  jlocation c_loc;\n+} writable_exceptionInfo;\n+\n+typedef struct {\n+  const char *name;\n+  const char *t_cls;\n+  const char *t_name;\n+  const char *t_sig;\n+  jlocation t_loc;\n+  const char *c_cls;\n+  const char *c_name;\n+  const char *c_sig;\n+  jlocation c_loc;\n+} exceptionInfo;\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_TRUE;\n+static exceptionInfo exs[] = {\n+    { \"Lexception001c;\",\n+        \"Lexception001b;\", \"meth1\", \"()V\", 7,\n+        \"Lexception001a;\", \"run\", \"()V\", 14 },\n+    { \"Ljava\/lang\/ArithmeticException;\",\n+        \"Lexception001b;\", \"meth2\", \"(I)I\", 3,\n+        \"Lexception001a;\", \"run\", \"()V\", 24 },\n+    { \"Ljava\/lang\/ArrayIndexOutOfBoundsException;\",\n+        \"Lexception001b;\", \"meth3\", \"(I)I\", 10,\n+        \"Lexception001a;\", \"run\", \"()V\", 34 }\n+};\n+static int eventsCount = 0;\n+static int eventsExpected = 0;\n+\n+void JNICALL\n+Exception(jvmtiEnv *jvmti, JNIEnv *env, jthread thr,\n+          jmethodID method, jlocation location, jobject exception,\n+          jmethodID catch_method, jlocation catch_location) {\n+  jvmtiError err;\n+  writable_exceptionInfo ex;\n+  jclass cls;\n+  char *generic;\n+  size_t i;\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving Exception info ...\\n\");\n+  }\n+  cls = env->GetObjectClass(exception);\n+  err = jvmti->GetClassSignature(cls, &ex.name, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass#t) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls, &ex.t_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature#t) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &ex.t_name, &ex.t_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName#t) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  ex.t_loc = location;\n+  err = jvmti->GetMethodDeclaringClass(catch_method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass#c) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls, &ex.c_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature#c) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(catch_method,\n+                                 &ex.c_name, &ex.c_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName#c) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  ex.c_loc = catch_location;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> %s\\n\", ex.name);\n+    printf(\">>>   thrown at %s.%s%s:0x%x%08x\\n\",\n+           ex.t_cls, ex.t_name, ex.t_sig,\n+           (jint)(ex.t_loc >> 32), (jint)ex.t_loc);\n+    printf(\">>>    catch at %s.%s%s:0x%x%08x\\n\",\n+           ex.c_cls, ex.c_name, ex.c_sig,\n+           (jint)(ex.c_loc >> 32), (jint)ex.c_loc);\n+    printf(\">>> ... done\\n\");\n+  }\n+  for (i = 0; i < sizeof(exs)\/sizeof(exceptionInfo); i++) {\n+    if (ex.name != NULL && strcmp(ex.name, exs[i].name) == 0\n+        && ex.t_cls != NULL && strcmp(ex.t_cls, exs[i].t_cls) == 0\n+        && ex.t_name != NULL && strcmp(ex.t_name, exs[i].t_name) == 0\n+        && ex.t_sig != NULL && strcmp(ex.t_sig, exs[i].t_sig) == 0\n+        && ex.c_cls != NULL && strcmp(ex.c_cls, exs[i].c_cls) == 0\n+        && ex.c_name != NULL && strcmp(ex.c_name, exs[i].c_name) == 0\n+        && ex.c_sig != NULL && strcmp(ex.c_sig, exs[i].c_sig) == 0\n+        && ex.t_loc == exs[i].t_loc && ex.c_loc == exs[i].c_loc) {\n+      eventsCount++;\n+      break;\n+    }\n+  }\n+  if (i == sizeof(exs)\/sizeof(exceptionInfo)) {\n+    printf(\"Unexpected exception event:\\n\");\n+    printf(\"  %s\\n\", ex.name);\n+    printf(\"    thrown at %s.%s%s:0x%x%08x\\n\",\n+           ex.t_cls, ex.t_name, ex.t_sig,\n+           (jint)(ex.t_loc >> 32), (jint)ex.t_loc);\n+    printf(\"     catch at %s.%s%s:0x%x%08x\\n\",\n+           ex.c_cls, ex.c_name, ex.c_sig,\n+           (jint)(ex.c_loc >> 32), (jint)ex.c_loc);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_exception001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_exception001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_exception001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_exception_events) {\n+    callbacks.Exception = &Exception;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: Exception event is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_exception001_check(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+  jthread thread;\n+  jclass clz;\n+  jmethodID mid;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  if (!caps.can_generate_exception_events) {\n+    return result;\n+  }\n+\n+  clz = env->FindClass(\"exception001c\");\n+  if (clz == NULL) {\n+    printf(\"Cannot find exception001c class!\\n\");\n+    return STATUS_FAILED;\n+  }\n+  clz = env->FindClass(\"exception001b\");\n+  if (clz == NULL) {\n+    printf(\"Cannot find exception001b class!\\n\");\n+    return STATUS_FAILED;\n+  }\n+  clz = env->FindClass(\"exception001a\");\n+  if (clz == NULL) {\n+    printf(\"Cannot find exception001a class!\\n\");\n+    return STATUS_FAILED;\n+  }\n+  mid = env->GetStaticMethodID(clz, \"run\", \"()V\");\n+  if (mid == NULL) {\n+    printf(\"Cannot find method run!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  err = jvmti->GetCurrentThread(&thread);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to get current thread: %s (%d)\\n\", TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_EXCEPTION, thread);\n+  if (err == JVMTI_ERROR_NONE) {\n+    eventsExpected = sizeof(exs)\/sizeof(exceptionInfo);\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_EXCEPTION: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  env->CallStaticVoidMethod(clz, mid);\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_EXCEPTION, thread);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_EXCEPTION: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of exception events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/Exception\/exception001\/libexception.cpp","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/ExceptionCatch\/excatch001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function ExceptionCatch.\n+ *     The test checks if the parameters of the function contain the\n+ *     expected values for the following exceptions thrown by Java methods:\n+ *       - custom class exception001c extending Throwable\n+ *       - ArithmeticException caused by division with zero devisor\n+ *       - IndexOutOfBoundsException caused by using out of range array index\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @compile excatch001a.jasm\n+ * @run main\/othervm\/native -agentlib:excatch excatch001\n+ *\/\n+\n+\n+\n+public class excatch001 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"excatch\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load excatch001 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch001\/excatch001.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* Reassembled from the following Java pattern:\n+ *\n+ * public class excatch001a {\n+ *     public static void run() {\n+ *         excatch001b t = new excatch001b();\n+ *         try {\n+ *             t.meth1();\n+ *         } catch (Throwable e) {}\n+ *         try {\n+ *             t.meth2(0);\n+ *         } catch (Throwable e) {}\n+ *         try {\n+ *             t.meth3(2);\n+ *         } catch (Throwable e) {}\n+ *     }\n+ * }\n+ *\n+ * class excatch001b {\n+ *     public static void meth1() throws Throwable {\n+ *         throw new excatch001c();\n+ *     }\n+ *\n+ *     public int meth2(int i) throws ArithmeticException {\n+ *         return (10 \/ i);\n+ *     }\n+ *\n+ *     public int meth3(int i) throws IndexOutOfBoundsException {\n+ *         int arr[] = {1};\n+ *         return arr[i];\n+ *     }\n+ * }\n+ *\n+ * class excatch001c extends Throwable {\n+ * }\n+ *\n+ *\/\n+\n+super public class excatch001a {\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method run:\"()V\" stack 2 locals 2 {\n+        new     class excatch001b;\n+        dup;\n+        invokespecial Method excatch001b.\"<init>\":\"()V\";\n+        astore_0;\n+    try t0;\n+        invokestatic Method excatch001b.meth1:\"()V\";\n+    endtry t0;\n+        goto    L15;\n+    catch t0 java\/lang\/Throwable; \/\/ bci=14\n+        astore_1;\n+    try t1;\n+L15:    aload_0;\n+        iconst_0;\n+        invokevirtual Method excatch001b.meth2:\"(I)I\";\n+        pop;\n+    endtry t1;\n+        goto    L25;\n+    catch t1 java\/lang\/Throwable; \/\/ bci=24\n+        astore_1;\n+    try t2;\n+L25:    aload_0;\n+        iconst_2;\n+        invokevirtual Method excatch001b.meth3:\"(I)I\";\n+        pop;\n+    endtry t2;\n+        goto    L35;\n+    catch t2 java\/lang\/Throwable; \/\/ bci=34\n+        astore_1;\n+L35:    return;\n+    }\n+\n+}\n+\n+super class excatch001b {\n+\n+    Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial        Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method meth1:\"()V\"\n+    throws java\/lang\/Throwable\n+    stack 2 locals 0 {\n+        new     class excatch001c;\n+        dup;\n+        invokespecial Method excatch001c.\"<init>\":\"()V\";\n+        athrow; \/\/ bci=7\n+    }\n+\n+    public Method meth2:\"(I)I\"\n+    throws java\/lang\/ArithmeticException\n+    stack 2 locals 2 {\n+        bipush  10;\n+        iload_1;\n+        idiv;   \/\/ bci=3\n+        ireturn;\n+    }\n+\n+    public Method meth3:\"(I)I\"\n+    throws java\/lang\/IndexOutOfBoundsException\n+    stack 4 locals 3 {\n+        iconst_1;\n+        newarray int;\n+        dup;\n+        iconst_0;\n+        iconst_1;\n+        iastore;\n+        astore_2;\n+        aload_2;\n+        iload_1;\n+        iaload;  \/\/ bci=10\n+        ireturn;\n+    }\n+}\n+\n+super class excatch001c extends java\/lang\/Throwable {\n+\n+    Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial Method java\/lang\/Throwable.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch001\/excatch001a.jasm","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+    char *name;\n+    char *c_cls;\n+    char *c_name;\n+    char *c_sig;\n+    jlocation c_loc;\n+} writable_exceptionInfo;\n+\n+typedef struct {\n+    const char *name;\n+    const char *c_cls;\n+    const char *c_name;\n+    const char *c_sig;\n+    jlocation c_loc;\n+} exceptionInfo;\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static exceptionInfo exs[] = {\n+  { \"Lexcatch001c;\",\n+    \"Lexcatch001a;\", \"run\", \"()V\", 14 },\n+  { \"Ljava\/lang\/ArithmeticException;\",\n+    \"Lexcatch001a;\", \"run\", \"()V\", 24 },\n+  { \"Ljava\/lang\/ArrayIndexOutOfBoundsException;\",\n+    \"Lexcatch001a;\", \"run\", \"()V\", 34 }\n+};\n+static int eventsCount = 0;\n+static int eventsExpected = 0;\n+\n+void JNICALL\n+ExceptionCatch(jvmtiEnv *jvmti, JNIEnv *env, jthread thr,\n+        jmethodID method, jlocation location, jobject exception) {\n+    jvmtiError err;\n+    jclass cls;\n+    writable_exceptionInfo ex;\n+    char *generic;\n+    size_t i;\n+\n+    if (printdump == JNI_TRUE) {\n+        printf(\">>> retrieving ExceptionCatch info ...\\n\");\n+    }\n+    cls = env->GetObjectClass(exception);\n+    err = jvmti->GetClassSignature(cls, &ex.name, &generic);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(GetClassSignature#e) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        result = STATUS_FAILED;\n+        return;\n+    }\n+    err = jvmti->GetMethodDeclaringClass(method, &cls);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        result = STATUS_FAILED;\n+        return;\n+    }\n+    err = jvmti->GetClassSignature(cls, &ex.c_cls, &generic);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(GetClassSignature#c) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        result = STATUS_FAILED;\n+        return;\n+    }\n+    err = jvmti->GetMethodName(method,\n+        &ex.c_name, &ex.c_sig, &generic);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        result = STATUS_FAILED;\n+        return;\n+    }\n+    ex.c_loc = location;\n+    if (printdump == JNI_TRUE) {\n+        printf(\">>> %s\\n\", ex.name);\n+        printf(\">>>    catch at %s.%s%s:0x%x%08x\\n\",\n+               ex.c_cls, ex.c_name, ex.c_sig,\n+               (jint)(ex.c_loc >> 32), (jint)ex.c_loc);\n+        printf(\">>> ... done\\n\");\n+    }\n+    for (i = 0; i < sizeof(exs)\/sizeof(exceptionInfo); i++) {\n+        if (ex.name != NULL && strcmp(ex.name, exs[i].name) == 0\n+         && ex.c_cls != NULL && strcmp(ex.c_cls, exs[i].c_cls) == 0\n+         && ex.c_name != NULL && strcmp(ex.c_name, exs[i].c_name) == 0\n+         && ex.c_sig != NULL && strcmp(ex.c_sig, exs[i].c_sig) == 0\n+         && ex.c_loc == exs[i].c_loc) {\n+            eventsCount++;\n+            break;\n+        }\n+    }\n+    if (i == sizeof(exs)\/sizeof(exceptionInfo)) {\n+        printf(\"Unexpected exception catch event:\\n\");\n+        printf(\"  %s\\n\", ex.name);\n+        printf(\"     catch at %s.%s%s:0x%x%08x\\n\",\n+               ex.c_cls, ex.c_name, ex.c_sig,\n+               (jint)(ex.c_loc >> 32), (jint)ex.c_loc);\n+        result = STATUS_FAILED;\n+    }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_excatch001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_excatch001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_excatch001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+    jvmtiError err;\n+    jint res;\n+\n+    if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+        printdump = JNI_TRUE;\n+    }\n+\n+    res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+    if (res != JNI_OK || jvmti == NULL) {\n+        printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+        return JNI_ERR;\n+    }\n+\n+    err = jvmti->GetPotentialCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        return JNI_ERR;\n+    }\n+\n+    err = jvmti->AddCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        return JNI_ERR;\n+    }\n+\n+    err = jvmti->GetCapabilities(&caps);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        return JNI_ERR;\n+    }\n+\n+    if (caps.can_generate_exception_events) {\n+        callbacks.ExceptionCatch = &ExceptionCatch;\n+        err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+        if (err != JVMTI_ERROR_NONE) {\n+            printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+                   TranslateError(err), err);\n+            return JNI_ERR;\n+        }\n+    } else {\n+        printf(\"Warning: Exception event is not implemented\\n\");\n+    }\n+\n+    return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_excatch001_check(JNIEnv *env, jclass cls) {\n+    jvmtiError err;\n+    jclass clz;\n+    jmethodID mid;\n+\n+    if (jvmti == NULL) {\n+        printf(\"JVMTI client was not properly loaded!\\n\");\n+        return STATUS_FAILED;\n+    }\n+\n+    if (!caps.can_generate_exception_events) {\n+        return result;\n+    }\n+\n+    clz = env->FindClass(\"excatch001c\");\n+    if (clz == NULL) {\n+        printf(\"Cannot find excatch001c class!\\n\");\n+        return STATUS_FAILED;\n+    }\n+    clz = env->FindClass(\"excatch001b\");\n+    if (clz == NULL) {\n+        printf(\"Cannot find excatch001b class!\\n\");\n+        return STATUS_FAILED;\n+    }\n+    clz = env->FindClass(\"excatch001a\");\n+    if (clz == NULL) {\n+        printf(\"Cannot find excatch001a class!\\n\");\n+        return STATUS_FAILED;\n+    }\n+    mid = env->GetStaticMethodID(clz, \"run\", \"()V\");\n+    if (mid == NULL) {\n+        printf(\"Cannot find method run!\\n\");\n+        return STATUS_FAILED;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+            JVMTI_EVENT_EXCEPTION_CATCH, NULL);\n+    if (err == JVMTI_ERROR_NONE) {\n+        eventsExpected = sizeof(exs)\/sizeof(exceptionInfo);\n+    } else {\n+        printf(\"Failed to enable JVMTI_EVENT_EXCEPTION_CATCH: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        result = STATUS_FAILED;\n+    }\n+\n+    env->CallStaticVoidMethod(clz, mid);\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+            JVMTI_EVENT_EXCEPTION_CATCH, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+        printf(\"Failed to disable JVMTI_EVENT_EXCEPTION_CATCH: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        result = STATUS_FAILED;\n+    }\n+\n+    if (eventsCount != eventsExpected) {\n+        printf(\"Wrong number of exception catch events: %d, expected: %d\\n\",\n+            eventsCount, eventsExpected);\n+        result = STATUS_FAILED;\n+    }\n+    return result;\n+}\n+\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ExceptionCatch\/excatch001\/libexcatch.cpp","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/FieldAccess\/fieldacc001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function FieldAccess.\n+ *     The test checks if the parameters of the function contain the\n+ *     expected values.\n+ * COMMENTS\n+ *     Fixed according to 4669812 bug.\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @compile fieldacc001a.jasm\n+ * @run main\/othervm\/native -agentlib:fieldacc01 fieldacc001\n+ *\/\n+\n+\n+\n+public class fieldacc001 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"fieldacc01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load fieldacc001 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady();\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+        getReady();\n+        fieldacc001a t = new fieldacc001a();\n+        t.run();\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc001\/fieldacc001.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class fieldacc001a {\n+\n+    static Field staticBoolean:Z;\n+    static Field staticByte:B;\n+    static Field staticShort:S;\n+    static Field staticInt:I;\n+    static Field staticLong:J;\n+    static Field staticFloat:F;\n+    static Field staticDouble:D;\n+    static Field staticChar:C;\n+    static Field staticObject:\"Ljava\/lang\/Object;\";\n+    static Field staticArrInt:\"[I\";\n+    Field instanceBoolean:Z;\n+    Field instanceByte:B;\n+    Field instanceShort:S;\n+    Field instanceInt:I;\n+    Field instanceLong:J;\n+    Field instanceFloat:F;\n+    Field instanceDouble:D;\n+    Field instanceChar:C;\n+    Field instanceObject:\"Ljava\/lang\/Object;\";\n+    Field instanceArrInt:\"[I\";\n+\n+    public Method \"<init>\":\"()V\" stack 5 locals 1 {\n+        aload_0;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        aload_0;\n+        iconst_0;\n+        putfield    Field instanceBoolean:\"Z\";\n+        aload_0;\n+        bipush      10;\n+        putfield    Field instanceByte:\"B\";\n+        aload_0;\n+        bipush      20;\n+        putfield    Field instanceShort:\"S\";\n+        aload_0;\n+        bipush      30;\n+        putfield    Field instanceInt:\"I\";\n+        aload_0;\n+        ldc2_w      long 40l;\n+        putfield    Field instanceLong:\"J\";\n+        aload_0;\n+        ldc         float 0.05f;\n+        putfield    Field instanceFloat:\"F\";\n+        aload_0;\n+        ldc2_w      double 0.06d;\n+        putfield    Field instanceDouble:\"D\";\n+        aload_0;\n+        bipush      122;\n+        putfield    Field instanceChar:\"C\";\n+        aload_0;\n+        new class java\/lang\/Object;\n+        dup;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        putfield    Field instanceObject:\"Ljava\/lang\/Object;\";\n+        aload_0;\n+        iconst_2;\n+        newarray    int;\n+        dup;\n+        iconst_0;\n+        bipush      70;\n+        iastore;\n+        dup;\n+        iconst_1;\n+        bipush      80;\n+        iastore;\n+        putfield    Field instanceArrInt:\"[I\";\n+        return;\n+    }\n+\n+    public Method run:\"()I\" stack 4 locals 2 {\n+        iconst_0;\n+        istore_1;\n+        getstatic   Field staticBoolean:\"Z\";    \/\/ bci=2\n+        aload_0;\n+        getfield    Field instanceBoolean:\"Z\";  \/\/ bci=6\n+        if_icmpne   L15;\n+        iinc        1, 1;\n+L15:    getstatic   Field staticByte:\"B\";       \/\/ bci=15\n+        aload_0;\n+        getfield    Field instanceByte:\"B\";     \/\/ bci=19\n+        if_icmpne   L28;\n+        iinc        1, 1;\n+L28:    getstatic   Field staticShort:\"S\";      \/\/ bci=28\n+        aload_0;\n+        getfield    Field instanceShort:\"S\";    \/\/ bci=32\n+        if_icmpne   L41;\n+        iinc        1, 1;\n+L41:    getstatic   Field staticInt:\"I\";        \/\/ bci=41\n+        aload_0;\n+        getfield    Field instanceInt:\"I\";      \/\/ bci=45\n+        if_icmpne   L54;\n+        iinc        1, 1;\n+L54:    getstatic   Field staticLong:\"J\";       \/\/ bci=54\n+        aload_0;\n+        getfield    Field instanceLong:\"J\";     \/\/ bci=58\n+        lcmp;\n+        ifne        L68;\n+        iinc        1, 1;\n+L68:    getstatic   Field staticFloat:\"F\";      \/\/ bci=68\n+        aload_0;\n+        getfield    Field instanceFloat:\"F\";    \/\/ bci=72\n+        fcmpl;\n+        ifne        L82;\n+        iinc        1, 1;\n+L82:    getstatic   Field staticDouble:\"D\";     \/\/ bci=82\n+        aload_0;\n+        getfield    Field instanceDouble:\"D\";   \/\/ bci=86\n+        dcmpl;\n+        ifne    L96;\n+        iinc        1, 1;\n+L96:    getstatic   Field staticChar:\"C\";       \/\/ bci=96\n+        aload_0;\n+        getfield    Field instanceChar:\"C\";     \/\/ bci=100\n+        if_icmpne   L109;\n+        iinc        1, 1;\n+L109:   getstatic   Field staticObject:\"Ljava\/lang\/Object;\"; \/\/ bci=109\n+        aload_0;\n+        getfield    Field instanceObject:\"Ljava\/lang\/Object;\"; \/\/ bci=113\n+        if_acmpne   L122;\n+        iinc        1, 1;\n+L122:   getstatic   Field staticArrInt:\"[I\";    \/\/ bci=122\n+        iconst_0;\n+        iaload;\n+        aload_0;\n+        getfield    Field instanceArrInt:\"[I\";  \/\/ bci=128\n+        iconst_1;\n+        iaload;\n+        if_icmpne   L139;\n+        iinc        1, 1;\n+L139:   iload_1;\n+        ireturn;\n+    }\n+\n+    static Method \"<clinit>\":\"()V\" stack 4 locals 0 {\n+        iconst_1;\n+        putstatic   Field staticBoolean:\"Z\";\n+        iconst_1;\n+        putstatic   Field staticByte:\"B\";\n+        iconst_2;\n+        putstatic   Field staticShort:\"S\";\n+        iconst_3;\n+        putstatic   Field staticInt:\"I\";\n+        ldc2_w      long 4l;\n+        putstatic   Field staticLong:\"J\";\n+        ldc         float 0.5f;\n+        putstatic   Field staticFloat:\"F\";\n+        ldc2_w      double 0.6d;\n+        putstatic   Field staticDouble:\"D\";\n+        bipush      97;\n+        putstatic   Field staticChar:\"C\";\n+        aconst_null;\n+        putstatic   Field staticObject:\"Ljava\/lang\/Object;\";\n+        iconst_2;\n+        newarray    int;\n+        dup;\n+        iconst_0;\n+        bipush      7;\n+        iastore;\n+        dup;\n+        iconst_1;\n+        bipush      8;\n+        iastore;\n+        putstatic   Field staticArrInt:\"[I\";\n+        return;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc001\/fieldacc001a.jasm","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,367 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  jboolean is_static;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 2,\n+        \"Lfieldacc001a;\", \"staticBoolean\", \"Z\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 6,\n+        \"Lfieldacc001a;\", \"instanceBoolean\", \"Z\", JNI_FALSE },\n+    { NULL, \"Lfieldacc001a;\",   \"run\", \"()I\", 15,\n+        \"Lfieldacc001a;\", \"staticByte\", \"B\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 19,\n+        \"Lfieldacc001a;\", \"instanceByte\", \"B\", JNI_FALSE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 28,\n+        \"Lfieldacc001a;\", \"staticShort\", \"S\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 32,\n+        \"Lfieldacc001a;\", \"instanceShort\", \"S\", JNI_FALSE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 41,\n+        \"Lfieldacc001a;\", \"staticInt\", \"I\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 45,\n+        \"Lfieldacc001a;\", \"instanceInt\", \"I\", JNI_FALSE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 54,\n+        \"Lfieldacc001a;\", \"staticLong\", \"J\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 58,\n+        \"Lfieldacc001a;\", \"instanceLong\", \"J\", JNI_FALSE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 68,\n+        \"Lfieldacc001a;\", \"staticFloat\", \"F\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 72,\n+        \"Lfieldacc001a;\", \"instanceFloat\", \"F\", JNI_FALSE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 82,\n+        \"Lfieldacc001a;\", \"staticDouble\", \"D\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 86,\n+        \"Lfieldacc001a;\", \"instanceDouble\", \"D\", JNI_FALSE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 96,\n+        \"Lfieldacc001a;\", \"staticChar\", \"C\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 100,\n+        \"Lfieldacc001a;\", \"instanceChar\", \"C\", JNI_FALSE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 109,\n+        \"Lfieldacc001a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 113,\n+        \"Lfieldacc001a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 122,\n+        \"Lfieldacc001a;\", \"staticArrInt\", \"[I\", JNI_TRUE },\n+    { NULL, \"Lfieldacc001a;\", \"run\", \"()I\", 128,\n+        \"Lfieldacc001a;\", \"instanceArrInt\", \"[I\", JNI_FALSE }\n+};\n+\n+\n+void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *env,\n+                         jthread thr, jmethodID method,\n+                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving access watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+    printf(\">>> ... done\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldacc001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_access_events) {\n+    callbacks.FieldAccess = &FieldAccess;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+\n+JNIEXPORT void JNICALL\n+Java_fieldacc001_getReady(JNIEnv *env, jclass klass) {\n+  jvmtiError err;\n+  jclass cls;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_access_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field access watches ...\\n\");\n+  }\n+  cls = env->FindClass(\"fieldacc001a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldacc001a class!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = env->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = env->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot find field \\\"%s\\\"!\\n\", watches[i].f_name);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldacc001_check(JNIEnv *env, jclass cls) {\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc001\/libfieldacc01.cpp","additions":367,"deletions":0,"binary":false,"changes":367,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/FieldAccess\/fieldacc002.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function FieldAccess.\n+ *     The test checks if the parameters of the function contain the\n+ *     expected values for fields accessed from JNI code.\n+ * COMMENTS\n+ *     Fixed according to 4669812 bug.\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:fieldacc02 fieldacc002\n+ *\/\n+\n+\n+\n+public class fieldacc002 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"fieldacc02\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load fieldacc002 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady();\n+    native static int check(Object obj);\n+\n+    public static void main(String args[]) {\n+        fieldacc002a t = new fieldacc002a();\n+        getReady();\n+        int res = check(t);\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+}\n+\n+class fieldacc002a {\n+    static boolean staticBoolean = true;\n+    static byte staticByte = 1;\n+    static short staticShort = 2;\n+    static int staticInt = 3;\n+    static long staticLong = 4;\n+    static float staticFloat = 0.5F;\n+    static double staticDouble = 0.6;\n+    static char staticChar = '\\u0007';\n+    static Object staticObject = new Object();\n+    static int staticArrInt[] = {8};\n+\n+    boolean instanceBoolean = false;\n+    byte instanceByte = 10;\n+    short instanceShort = 20;\n+    int instanceInt = 30;\n+    long instanceLong = 40;\n+    float instanceFloat = 0.05F;\n+    double instanceDouble = 0.06;\n+    char instanceChar = '\\u0070';\n+    Object instanceObject = new Object();\n+    int instanceArrInt[] = {80};\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc002\/fieldacc002.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  jboolean is_static;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticBoolean\", \"Z\", JNI_TRUE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticByte\", \"B\", JNI_TRUE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticShort\", \"S\", JNI_TRUE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticInt\", \"I\", JNI_TRUE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticLong\", \"J\", JNI_TRUE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticFloat\", \"F\", JNI_TRUE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticDouble\", \"D\", JNI_TRUE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticChar\", \"C\", JNI_TRUE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"staticArrInt\", \"[I\", JNI_TRUE },\n+\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceBoolean\", \"Z\", JNI_FALSE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceByte\", \"B\", JNI_FALSE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceShort\", \"S\", JNI_FALSE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceInt\", \"I\", JNI_FALSE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceLong\", \"J\", JNI_FALSE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceFloat\", \"F\", JNI_FALSE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceDouble\", \"D\", JNI_FALSE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceChar\", \"C\", JNI_FALSE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n+    { NULL, \"Lfieldacc002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldacc002a;\", \"instanceArrInt\", \"[I\", JNI_FALSE }\n+};\n+\n+void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *env,\n+                         jthread thr, jmethodID method,\n+                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving access watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldacc002(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_access_events) {\n+    callbacks.FieldAccess = &FieldAccess;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL Java_fieldacc002_getReady(JNIEnv *env, jclass clz) {\n+  jvmtiError err;\n+  jclass cls;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_access_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field access watches ...\\n\");\n+  }\n+\n+  cls = env->FindClass(\"fieldacc002a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldacc002a class!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = env->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = env->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot find field \\\"%s\\\"!\\n\", watches[i].f_name);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldacc002_check(JNIEnv *env, jclass clz, jobject obj) {\n+  jclass cls;\n+\n+  if (!caps.can_generate_field_access_events) {\n+    return result;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> accessing fields ...\\n\");\n+  }\n+\n+  cls = env->FindClass(\"fieldacc002a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldacc002a class!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  env->GetStaticBooleanField(cls, watches[0].fid);\n+  env->GetStaticByteField(cls, watches[1].fid);\n+  env->GetStaticShortField(cls, watches[2].fid);\n+  env->GetStaticIntField(cls, watches[3].fid);\n+  env->GetStaticLongField(cls, watches[4].fid);\n+  env->GetStaticFloatField(cls, watches[5].fid);\n+  env->GetStaticDoubleField(cls, watches[6].fid);\n+  env->GetStaticCharField(cls, watches[7].fid);\n+  env->GetStaticObjectField(cls, watches[8].fid);\n+  env->GetStaticObjectField(cls, watches[9].fid);\n+\n+  env->GetBooleanField(obj, watches[10].fid);\n+  env->GetByteField(obj, watches[11].fid);\n+  env->GetShortField(obj, watches[12].fid);\n+  env->GetIntField(obj, watches[13].fid);\n+  env->GetLongField(obj, watches[14].fid);\n+  env->GetFloatField(obj, watches[15].fid);\n+  env->GetDoubleField(obj, watches[16].fid);\n+  env->GetCharField(obj, watches[17].fid);\n+  env->GetObjectField(obj, watches[18].fid);\n+  env->GetObjectField(obj, watches[19].fid);\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc002\/libfieldacc02.cpp","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/FieldAccess\/fieldacc003.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function FieldAccess.\n+ *     The test sets access watches on fields which are defined in\n+ *     superclass, then triggers access watch events on these fields\n+ *     and checks if clazz, method, location, field_clazz, field and\n+ *     object parameters the function contain the expected values.\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:fieldacc03 fieldacc003\n+ *\/\n+\n+\n+\n+public class fieldacc003 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"fieldacc03\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load fieldacc003 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady();\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+\n+        \/\/ produce JCK-like exit status.\n+        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n+    }\n+\n+    public static int run(String args[], PrintStream out) {\n+        getReady();\n+        fieldacc003a t = new fieldacc003a();\n+        t.run();\n+        return check();\n+    }\n+}\n+\n+class fieldacc003e {\n+    boolean extendsBoolean = false;\n+    byte extendsByte = 10;\n+    short extendsShort = 20;\n+    int extendsInt = 30;\n+    long extendsLong = 40;\n+    float extendsFloat = 0.05F;\n+    double extendsDouble = 0.06;\n+    char extendsChar = 'D';\n+    Object extendsObject = new Object();\n+    int extendsArrInt[] = {70, 80};\n+}\n+\n+class fieldacc003a extends fieldacc003e {\n+    public int run() {\n+        int i = 0;\n+        if (extendsBoolean == true) i++;\n+        if (extendsByte == 1) i++;\n+        if (extendsShort == 2) i++;\n+        if (extendsInt == 3) i++;\n+        if (extendsLong == 4) i++;\n+        if (extendsFloat == 0.5F) i++;\n+        if (extendsDouble == 0.6) i++;\n+        if (extendsChar == 'C') i++;\n+        if (extendsObject == this) i++;\n+        if (extendsArrInt[1] == 7) i++;\n+        return i;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc003\/fieldacc003.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,346 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  jboolean is_static;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 3,\n+        \"Lfieldacc003a;\", \"extendsBoolean\", \"Z\", JNI_FALSE },\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 14,\n+        \"Lfieldacc003a;\", \"extendsByte\", \"B\", JNI_FALSE },\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 25,\n+        \"Lfieldacc003a;\", \"extendsShort\", \"S\", JNI_FALSE },\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 36,\n+        \"Lfieldacc003a;\", \"extendsInt\", \"I\", JNI_FALSE },\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 47,\n+        \"Lfieldacc003a;\", \"extendsLong\", \"J\", JNI_FALSE },\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 61,\n+        \"Lfieldacc003a;\", \"extendsFloat\", \"F\", JNI_FALSE },\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 74,\n+        \"Lfieldacc003a;\", \"extendsDouble\", \"D\", JNI_FALSE },\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 88,\n+        \"Lfieldacc003a;\", \"extendsChar\", \"C\", JNI_FALSE },\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 100,\n+        \"Lfieldacc003a;\", \"extendsObject\", \"Ljava\/lang\/Object;\", JNI_FALSE },\n+    { NULL, \"Lfieldacc003a;\", \"run\", \"()I\", 111,\n+        \"Lfieldacc003a;\", \"extendsArrInt\", \"[I\", JNI_FALSE }\n+};\n+\n+void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *env,\n+                         jthread thr, jmethodID method,\n+                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving access watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls,  &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+    printf(\">>> ... done\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc003(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc003(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldacc003(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_access_events) {\n+    callbacks.FieldAccess = &FieldAccess;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_fieldacc003_getReady(JNIEnv *env, jclass klass) {\n+  jvmtiError err;\n+  jclass cls;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_access_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field access watches ...\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    cls = env->FindClass(watches[i].f_cls);\n+    if (cls == NULL) {\n+      printf(\"Cannot find %s class!\\n\", watches[i].f_cls);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = env->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = env->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n+             watches[i].f_name, watches[i].f_sig);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldacc003_check(JNIEnv *env, jclass cls) {\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc003\/libfieldacc03.cpp","additions":346,"deletions":0,"binary":false,"changes":346,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/FieldAccess\/fieldacc004.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function FieldAccess.\n+ *     The test sets access watches on fields which are defined in\n+ *     superinterface, then triggers access watch events on these fields\n+ *     and checks if clazz, method, location, field_clazz, field and\n+ *     object parameters of the function contain the expected values.\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:fieldacc04 fieldacc004\n+ *\/\n+\n+\n+public class fieldacc004 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"fieldacc04\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load fieldacc004 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady();\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+\n+        \/\/ produce JCK-like exit status.\n+        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n+    }\n+\n+    public static int run(String args[], PrintStream out) {\n+        getReady();\n+        fieldacc004a t = new fieldacc004a();\n+        t.run();\n+        return check();\n+    }\n+}\n+\n+interface fieldacc004i {\n+    static Object interfaceObject = new Object();\n+    static int interfaceArrInt[] = {1, 2};\n+}\n+\n+class fieldacc004a implements fieldacc004i {\n+    public int run() {\n+        int i = 0;\n+        if (interfaceObject == this) i++;\n+        if (interfaceArrInt[0] == 3) i++;\n+        return i;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc004\/fieldacc004.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  jboolean is_static;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldacc004a;\", \"run\", \"()I\", 2,\n+        \"Lfieldacc004a;\", \"interfaceObject\",\n+        \"Ljava\/lang\/Object;\", JNI_TRUE },\n+    { NULL, \"Lfieldacc004a;\", \"run\", \"()I\", 12,\n+        \"Lfieldacc004a;\", \"interfaceArrInt\",\n+        \"[I\", JNI_TRUE }\n+};\n+\n+void JNICALL FieldAccess(jvmtiEnv *jvmti, JNIEnv *env,\n+                         jthread thr, jmethodID method,\n+                         jlocation location, jclass field_klass, jobject obj, jfieldID field) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving access watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+    printf(\">>> ... done\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field access catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldacc004(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldacc004(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldacc004(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_access_events) {\n+    callbacks.FieldAccess = &FieldAccess;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_ACCESS, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_ACCESS: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldAccess watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_fieldacc004_getReady(JNIEnv *env, jclass klass) {\n+  jvmtiError err;\n+  jclass cls;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_access_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field access watches ...\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    cls = env->FindClass(watches[i].f_cls);\n+    if (cls == NULL) {\n+      printf(\"Cannot find %s class!\\n\", watches[i].f_cls);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = env->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = env->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n+             watches[i].f_name, watches[i].f_sig);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldAccessWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldAccessWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldacc004_check(JNIEnv *env, jclass cls) {\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field access events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldAccess\/fieldacc004\/libfieldacc04.cpp","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/FieldModification\/fieldmod001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras, quarantine]\n+ * VM Testbase comments: 8016181\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function FieldModification.\n+ *     The test checks if the parameters of the function contain the\n+ *     expected values.\n+ * COMMENTS\n+ *     Fixed according to 4669812 bug.\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @compile fieldmod001a.jasm\n+ * @run main\/othervm\/native -agentlib:fieldmod01 fieldmod001\n+ *\/\n+\n+public class fieldmod001 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"fieldmod01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load fieldmod001 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady(Object o1, Object o2, int a1[], int a2[]);\n+    native static int check();\n+\n+    static Object obj1 = new Object();\n+    static Object obj2 = new Object();\n+    static int arr1[] = new int[1];\n+    static int arr2[] = new int[2];\n+\n+    public static void main(String args[]) {\n+        getReady(obj1, obj2, arr1, arr2);\n+        fieldmod001a t = new fieldmod001a();\n+        t.run();\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod001\/fieldmod001.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class fieldmod001a {\n+\n+    static Field staticBoolean:Z;\n+    static Field staticByte:B;\n+    static Field staticShort:S;\n+    static Field staticInt:I;\n+    static Field staticLong:J;\n+    static Field staticFloat:F;\n+    static Field staticDouble:D;\n+    static Field staticChar:C;\n+    static Field staticObject:\"Ljava\/lang\/Object;\";\n+    static Field staticArrInt:\"[I\";\n+    Field instanceBoolean:Z;\n+    Field instanceByte:B;\n+    Field instanceShort:S;\n+    Field instanceInt:I;\n+    Field instanceLong:J;\n+    Field instanceFloat:F;\n+    Field instanceDouble:D;\n+    Field instanceChar:C;\n+    Field instanceObject:\"Ljava\/lang\/Object;\";\n+    Field instanceArrInt:\"[I\";\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public Method run:\"()V\" stack 5 locals 1 {\n+        iconst_1;\n+        putstatic   Field staticBoolean:\"Z\";    \/\/ bci=1\n+        iconst_1;\n+        putstatic   Field staticByte:\"B\";       \/\/ bci=5\n+        iconst_2;\n+        putstatic   Field staticShort:\"S\";      \/\/ bci=9\n+        iconst_3;\n+        putstatic   Field staticInt:\"I\";        \/\/ bci=13\n+        ldc2_w      long 4l;\n+        putstatic   Field staticLong:\"J\";       \/\/ bci=19\n+        ldc         float 0.5f;\n+        putstatic   Field staticFloat:\"F\";      \/\/ bci=24\n+        ldc2_w      double 0.6d;\n+        putstatic   Field staticDouble:\"D\";     \/\/ bci=30\n+        bipush      97;\n+        putstatic   Field staticChar:\"C\";       \/\/ bci=35\n+        getstatic   Field fieldmod001.obj1:\"Ljava\/lang\/Object;\";\n+        putstatic   Field staticObject:\"Ljava\/lang\/Object;\"; \/\/ bci=41\n+        getstatic   Field fieldmod001.arr1:\"[I\";\n+        putstatic   Field staticArrInt:\"[I\";    \/\/ bci=47\n+        aload_0;\n+        iconst_0;\n+        putfield    Field instanceBoolean:\"Z\";  \/\/ bci=52\n+        aload_0;\n+        bipush      10;\n+        putfield    Field instanceByte:\"B\";     \/\/ bci=58\n+        aload_0;\n+        bipush      20;\n+        putfield    Field instanceShort:\"S\";    \/\/ bci=64\n+        aload_0;\n+        bipush      30;\n+        putfield    Field instanceInt:\"I\";      \/\/ bci=70\n+        aload_0;\n+        ldc2_w      long 40l;\n+        putfield    Field instanceLong:\"J\";     \/\/ bci=77\n+        aload_0;\n+        ldc         float 0.05f;\n+        putfield    Field instanceFloat:\"F\";    \/\/ bci=83\n+        aload_0;\n+        ldc2_w      double 0.06d;\n+        putfield    Field instanceDouble:\"D\";   \/\/ bci=90\n+        aload_0;\n+        bipush      122;\n+        putfield    Field instanceChar:\"C\";     \/\/ bci=96\n+        aload_0;\n+        getstatic   Field fieldmod001.obj2:\"Ljava\/lang\/Object;\";\n+        putfield    Field instanceObject:\"Ljava\/lang\/Object;\"; \/\/ bci=103\n+        aload_0;\n+        getstatic   Field fieldmod001.arr2:\"[I\";\n+        putfield    Field instanceArrInt:\"[I\";  \/\/ bci=110\n+        return;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod001\/fieldmod001a.jasm","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,467 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+  jvalue val;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  const jboolean is_static;\n+  jvalue val;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 1,\n+        \"Lfieldmod001a;\", \"staticBoolean\", \"Z\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 5,\n+        \"Lfieldmod001a;\", \"staticByte\", \"B\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 9,\n+        \"Lfieldmod001a;\", \"staticShort\", \"S\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 13,\n+        \"Lfieldmod001a;\", \"staticInt\", \"I\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 19,\n+        \"Lfieldmod001a;\", \"staticLong\", \"J\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 24,\n+        \"Lfieldmod001a;\", \"staticFloat\", \"F\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 30,\n+        \"Lfieldmod001a;\", \"staticDouble\", \"D\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 35,\n+        \"Lfieldmod001a;\", \"staticChar\", \"C\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 41,\n+        \"Lfieldmod001a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 47,\n+        \"Lfieldmod001a;\", \"staticArrInt\", \"[I\", JNI_TRUE, {} },\n+\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 52,\n+        \"Lfieldmod001a;\", \"instanceBoolean\", \"Z\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 58,\n+        \"Lfieldmod001a;\", \"instanceByte\", \"B\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 64,\n+        \"Lfieldmod001a;\", \"instanceShort\", \"S\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 70,\n+        \"Lfieldmod001a;\", \"instanceInt\", \"I\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 77,\n+        \"Lfieldmod001a;\", \"instanceLong\", \"J\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 83,\n+        \"Lfieldmod001a;\", \"instanceFloat\", \"F\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 90,\n+        \"Lfieldmod001a;\", \"instanceDouble\", \"D\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 96,\n+        \"Lfieldmod001a;\", \"instanceChar\", \"C\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 103,\n+        \"Lfieldmod001a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod001a;\", \"run\", \"()V\", 110,\n+        \"Lfieldmod001a;\", \"instanceArrInt\", \"[I\", JNI_FALSE, {} }\n+};\n+\n+void printValue(jvalue val, char *sig) {\n+  switch (*sig) {\n+    case 'J':\n+      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n+      break;\n+    case 'F':\n+      printf(\"%.3f\", (double)val.f);\n+      break;\n+    case 'D':\n+      printf(\"%f\", (double)val.d);\n+      break;\n+    case 'L':\n+    case '[':\n+      printf(\"0x%p\", val.l);\n+      break;\n+    case 'Z':\n+      printf(\"0x%x\", val.z);\n+      break;\n+    case 'B':\n+      printf(\"%d\", val.b);\n+      break;\n+    case 'S':\n+      printf(\"%d\", val.s);\n+      break;\n+    case 'C':\n+      printf(\"0x%x\", val.c);\n+      break;\n+    case 'I':\n+      printf(\"%d\", val.i);\n+      break;\n+    default:\n+      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n+      break;\n+  }\n+}\n+\n+int isEqual(JNIEnv *env, char *sig, jvalue v1, jvalue v2) {\n+  switch (*sig) {\n+    case 'J':\n+      return (v1.j == v2.j);\n+    case 'F':\n+      return (v1.f == v2.f);\n+    case 'D':\n+      return (v1.d == v2.d);\n+    case 'L':\n+    case '[':\n+      return env->IsSameObject(v1.l, v2.l);\n+    case 'Z':\n+      return (v1.z == v2.z);\n+    case 'B':\n+      return (v1.b == v2.b);\n+    case 'S':\n+      return (v1.s == v2.s);\n+    case 'C':\n+      return (v1.c == v2.c);\n+    case 'I':\n+      return (v1.i == v2.i);\n+    default:\n+      return (1);\n+  }\n+}\n+\n+void JNICALL FieldModification(jvmtiEnv *jvmti, JNIEnv *env,\n+                               jthread thr, jmethodID method, jlocation location,\n+                               jclass field_klass, jobject obj,\n+                               jfieldID field, char sig, jvalue new_value) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving modification watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.val = new_value;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method,\n+                                 &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+    printf(\">>>  new value: \");\n+    printValue(watch.val, watch.f_sig);\n+    printf(\"\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      if (!isEqual((JNIEnv *)env, watch.f_sig, watch.val, watches[i].val)) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong new value: \", i);\n+        printValue(watch.val, watch.f_sig);\n+        printf(\", expected: \");\n+        printValue(watches[i].val, watch.f_sig);\n+        printf(\"\\n\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field modification catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldmod001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldmod001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldmod001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_modification_events) {\n+    callbacks.FieldModification = &FieldModification;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_MODIFICATION: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldModification watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_fieldmod001_getReady(JNIEnv *env, jclass klass,\n+                                                      jobject obj1, jobject obj2, jobject arr1, jobject arr2) {\n+  jvmtiError err;\n+  jclass cls;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_modification_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field modification watches ...\\n\");\n+  }\n+  cls = env->FindClass(\"fieldmod001a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldmod001a class!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = env->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = env->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n+             watches[i].f_name, watches[i].f_sig);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldModificationWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldModificationWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+\n+  watches[0].val.z = JNI_TRUE;\n+  watches[1].val.b = 1;\n+  watches[2].val.s = 2;\n+  watches[3].val.i = 3;\n+  watches[4].val.j = 4;\n+  watches[5].val.f = 0.5F;\n+  watches[6].val.d = 0.6;\n+  watches[7].val.c = 0x61;\n+  watches[8].val.l = env->NewGlobalRef(obj1);\n+  watches[9].val.l = env->NewGlobalRef(arr1);\n+\n+  watches[10].val.z = JNI_FALSE;\n+  watches[11].val.b = 10;\n+  watches[12].val.s = 20;\n+  watches[13].val.i = 30;\n+  watches[14].val.j = 40;\n+  watches[15].val.f = 0.05F;\n+  watches[16].val.d = 0.06;\n+  watches[17].val.c = 0x7a;\n+  watches[18].val.l = env->NewGlobalRef(obj2);\n+  watches[19].val.l = env->NewGlobalRef(arr2);\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldmod001_check(JNIEnv *env, jclass cls) {\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field modification events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod001\/libfieldmod01.cpp","additions":467,"deletions":0,"binary":false,"changes":467,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/FieldModification\/fieldmod002.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercise JVMTI event callback function FieldModification.\n+ *     The test checks if the parameters of the function contain the\n+ *     expected values for fields modified from JNI code.\n+ * COMMENTS\n+ *     Fixed according to 4669812 bug.\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:fieldmod02 fieldmod002\n+ *\/\n+\n+\n+public class fieldmod002 {\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"fieldmod02\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load fieldmod002 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady();\n+    native static int check(Object obj);\n+\n+    public static void main(String args[]) {\n+        fieldmod002a t = new fieldmod002a();\n+        getReady();\n+        int res = check(t);\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+}\n+\n+class fieldmod002a {\n+    static boolean staticBoolean;\n+    static byte staticByte;\n+    static short staticShort;\n+    static int staticInt;\n+    static long staticLong;\n+    static float staticFloat;\n+    static double staticDouble;\n+    static char staticChar;\n+    static Object staticObject;\n+    static int staticArrInt[];\n+    boolean instanceBoolean;\n+    byte instanceByte;\n+    short instanceShort;\n+    int instanceInt;\n+    long instanceLong;\n+    float instanceFloat;\n+    double instanceDouble;\n+    char instanceChar;\n+    Object instanceObject;\n+    int instanceArrInt[];\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod002\/fieldmod002.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,517 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  jfieldID fid;\n+  char *m_cls;\n+  char *m_name;\n+  char *m_sig;\n+  jlocation loc;\n+  char *f_cls;\n+  char *f_name;\n+  char *f_sig;\n+  jboolean is_static;\n+  jvalue val;\n+} writable_watch_info;\n+\n+typedef struct {\n+  jfieldID fid;\n+  const char *m_cls;\n+  const char *m_name;\n+  const char *m_sig;\n+  jlocation loc;\n+  const char *f_cls;\n+  const char *f_name;\n+  const char *f_sig;\n+  jboolean is_static;\n+  jvalue val;\n+} watch_info;\n+\n+static jvmtiEnv *jvmti;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsExpected = 0;\n+static int eventsCount = 0;\n+static watch_info watches[] = {\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticBoolean\", \"Z\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticByte\", \"B\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticShort\", \"S\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticInt\", \"I\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticLong\", \"J\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticFloat\", \"F\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticDouble\", \"D\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticChar\", \"C\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticObject\", \"Ljava\/lang\/Object;\", JNI_TRUE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"staticArrInt\", \"[I\", JNI_TRUE, {} },\n+\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceBoolean\", \"Z\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceByte\", \"B\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceShort\", \"S\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceInt\", \"I\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceLong\", \"J\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceFloat\", \"F\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceDouble\", \"D\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceChar\", \"C\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceObject\", \"Ljava\/lang\/Object;\", JNI_FALSE, {} },\n+    { NULL, \"Lfieldmod002;\", \"check\", \"(Ljava\/lang\/Object;)I\", 0,\n+        \"Lfieldmod002a;\", \"instanceArrInt\", \"[I\", JNI_FALSE, {} }\n+};\n+\n+void printValue(jvalue val, char *sig) {\n+  switch (*sig) {\n+    case 'J':\n+      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n+      break;\n+    case 'F':\n+      printf(\"%.3f\", (double)val.f);\n+      break;\n+    case 'D':\n+      printf(\"%f\", (double)val.d);\n+      break;\n+    case 'L':\n+    case '[':\n+      printf(\"0x%p\", val.l);\n+      break;\n+    case 'Z':\n+      printf(\"0x%x\", val.z);\n+      break;\n+    case 'B':\n+      printf(\"%d\", val.b);\n+      break;\n+    case 'S':\n+      printf(\"%d\", val.s);\n+      break;\n+    case 'C':\n+      printf(\"0x%x\", val.c);\n+      break;\n+    case 'I':\n+      printf(\"%d\", val.i);\n+      break;\n+    default:\n+      printf(\"0x%x%08x\", (jint)(val.j >> 32), (jint)val.j);\n+      break;\n+  }\n+}\n+\n+int isEqual(JNIEnv *env, char *sig, jvalue v1, jvalue v2) {\n+  switch (*sig) {\n+    case 'J':\n+      return (v1.j == v2.j);\n+    case 'F':\n+      return (v1.f == v2.f);\n+    case 'D':\n+      return (v1.d == v2.d);\n+    case 'L':\n+    case '[':\n+      return env->IsSameObject(v1.l, v2.l);\n+    case 'Z':\n+      return (v1.z == v2.z);\n+    case 'B':\n+      return (v1.b == v2.b);\n+    case 'S':\n+      return (v1.s == v2.s);\n+    case 'C':\n+      return (v1.c == v2.c);\n+    case 'I':\n+      return (v1.i == v2.i);\n+    default:\n+      return (1);\n+  }\n+}\n+\n+void JNICALL FieldModification(jvmtiEnv *jvmti, JNIEnv *env,\n+                               jthread thr, jmethodID method, jlocation location,\n+                               jclass field_klass, jobject obj,\n+                               jfieldID field, char sig, jvalue new_value) {\n+  jvmtiError err;\n+  jclass cls;\n+  writable_watch_info watch;\n+  char *generic;\n+  size_t i;\n+\n+  eventsCount++;\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving modification watch info ...\\n\");\n+  }\n+  watch.fid = field;\n+  watch.loc = location;\n+  watch.is_static = (obj == NULL) ? JNI_TRUE : JNI_FALSE;\n+  watch.val = new_value;\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls,\n+                                     &watch.m_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method, &watch.m_name, &watch.m_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(field_klass,\n+                                     &watch.f_cls, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFieldName(field_klass, field,\n+                                &watch.f_name, &watch.f_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFieldName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", watch.m_cls);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", watch.m_name, watch.m_sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(watch.loc >> 32), (jint)watch.loc);\n+    printf(\">>>  field cls: \\\"%s\\\"\\n\", watch.f_cls);\n+    printf(\">>>      field: \\\"%s:%s\\\"\\n\", watch.f_name, watch.f_sig);\n+    printf(\">>>     object: 0x%p\\n\", obj);\n+    printf(\">>>  new value: \");\n+    printValue(watch.val, watch.f_sig);\n+    printf(\"\\n\");\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watch.fid == watches[i].fid) {\n+      if (watch.m_cls == NULL ||\n+          strcmp(watch.m_cls, watches[i].m_cls) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong class: \\\"%s\\\", expected: \\\"%s\\\"\\n\",\n+               i, watch.m_cls, watches[i].m_cls);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_name == NULL ||\n+          strcmp(watch.m_name, watches[i].m_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               i, watch.m_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.m_sig == NULL ||\n+          strcmp(watch.m_sig, watches[i].m_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               i, watch.m_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].m_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.loc != watches[i].loc) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+               i, (jint)(watch.loc >> 32), (jint)watch.loc);\n+        printf(\", expected: 0x%x%08x\\n\",\n+               (jint)(watches[i].loc >> 32), (jint)watches[i].loc);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_name == NULL ||\n+          strcmp(watch.f_name, watches[i].f_name) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field name: \\\"%s\\\"\",\n+               i, watch.f_name);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_name);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.f_sig == NULL ||\n+          strcmp(watch.f_sig, watches[i].f_sig) != 0) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field sig: \\\"%s\\\"\",\n+               i, watch.f_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", watches[i].f_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (watch.is_static != watches[i].is_static) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong field type: %s\", i,\n+               (watch.is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        printf(\", expected: %s\\n\",\n+               (watches[i].is_static == JNI_TRUE) ? \"static\" : \"instance\");\n+        result = STATUS_FAILED;\n+      }\n+      if (!isEqual((JNIEnv *)env, watch.f_sig, watch.val, watches[i].val)) {\n+        printf(\"(watch#%\" PRIuPTR \") wrong new value: \", i);\n+        printValue(watch.val, watch.f_sig);\n+        printf(\", expected: \");\n+        printValue(watches[i].val, watch.f_sig);\n+        printf(\"\\n\");\n+        result = STATUS_FAILED;\n+      }\n+      return;\n+    }\n+  }\n+  printf(\"Unexpected field modification catched: 0x%p\\n\", watch.fid);\n+  result = STATUS_FAILED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_fieldmod002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_fieldmod002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_fieldmod002(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_field_modification_events) {\n+    callbacks.FieldModification = &FieldModification;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                          JVMTI_EVENT_FIELD_MODIFICATION, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"Failed to enable JVMTI_EVENT_FIELD_MODIFICATION: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FieldModification watch is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_fieldmod002_getReady(JNIEnv *env, jclass clz) {\n+  jvmtiError err;\n+  jclass cls;\n+  jmethodID ctor;\n+  jintArray arr1, arr2;\n+  jobject obj1, obj2;\n+  size_t i;\n+\n+  if (!caps.can_generate_field_modification_events) {\n+    return;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> setting field modification watches ...\\n\");\n+  }\n+  cls = env->FindClass(\"fieldmod002a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldmod001a class!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  for (i = 0; i < sizeof(watches)\/sizeof(watch_info); i++) {\n+    if (watches[i].is_static == JNI_TRUE) {\n+      watches[i].fid = env->GetStaticFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    } else {\n+      watches[i].fid = env->GetFieldID(\n+          cls, watches[i].f_name, watches[i].f_sig);\n+    }\n+    if (watches[i].fid == NULL) {\n+      printf(\"Cannot get field ID for \\\"%s:%s\\\"\\n\",\n+             watches[i].f_name, watches[i].f_sig);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->SetFieldModificationWatch(cls, watches[i].fid);\n+    if (err == JVMTI_ERROR_NONE) {\n+      eventsExpected++;\n+    } else {\n+      printf(\"(SetFieldModificationWatch#%\" PRIuPTR \") unexpected error: %s (%d)\\n\",\n+             i, TranslateError(err), err);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+\n+  ctor = env->GetMethodID(cls, \"<init>\", \"()V\");\n+  obj1 = env->NewGlobalRef(env->NewObject(cls, ctor));\n+  obj2 = env->NewGlobalRef(env->NewObject(cls, ctor));\n+  arr1 = (jintArray) env->NewGlobalRef(env->NewIntArray((jsize) 1));\n+  arr2 = (jintArray) env->NewGlobalRef(env->NewIntArray((jsize) 1));\n+\n+  watches[0].val.z = JNI_TRUE;\n+  watches[1].val.b = 1;\n+  watches[2].val.s = 2;\n+  watches[3].val.i = 3;\n+  watches[4].val.j = 4;\n+  watches[5].val.f = 0.5F;\n+  watches[6].val.d = 0.6;\n+  watches[7].val.c = 0x7;\n+  watches[8].val.l = obj1;\n+  watches[9].val.l = arr1;\n+\n+  watches[10].val.z = JNI_FALSE;\n+  watches[11].val.b = 10;\n+  watches[12].val.s = 20;\n+  watches[13].val.i = 30;\n+  watches[14].val.j = 40;\n+  watches[15].val.f = 0.05F;\n+  watches[16].val.d = 0.06;\n+  watches[17].val.c = 0x70;\n+  watches[18].val.l = obj2;\n+  watches[19].val.l = arr2;\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_fieldmod002_check(JNIEnv *env,\n+                                                   jclass clz, jobject obj) {\n+  jclass cls;\n+\n+  if (!caps.can_generate_field_modification_events) {\n+    return PASSED;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> modifying fields ...\\n\");\n+  }\n+\n+  cls = env->FindClass(\"fieldmod002a\");\n+  if (cls == NULL) {\n+    printf(\"Cannot find fieldmod001a class!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  env->SetStaticBooleanField(cls, watches[0].fid, watches[0].val.z);\n+  env->SetStaticByteField(cls, watches[1].fid, watches[1].val.b);\n+  env->SetStaticShortField(cls, watches[2].fid, watches[2].val.s);\n+  env->SetStaticIntField(cls, watches[3].fid, watches[3].val.i);\n+  env->SetStaticLongField(cls, watches[4].fid, watches[4].val.j);\n+  env->SetStaticFloatField(cls, watches[5].fid, watches[5].val.f);\n+  env->SetStaticDoubleField(cls, watches[6].fid, watches[6].val.d);\n+  env->SetStaticCharField(cls, watches[7].fid, watches[7].val.c);\n+  env->SetStaticObjectField(cls, watches[8].fid, watches[8].val.l);\n+  env->SetStaticObjectField(cls, watches[9].fid, watches[9].val.l);\n+\n+  env->SetBooleanField(obj, watches[10].fid, watches[10].val.z);\n+  env->SetByteField(obj, watches[11].fid, watches[11].val.b);\n+  env->SetShortField(obj, watches[12].fid, watches[12].val.s);\n+  env->SetIntField(obj, watches[13].fid, watches[13].val.i);\n+  env->SetLongField(obj, watches[14].fid, watches[14].val.j);\n+  env->SetFloatField(obj, watches[15].fid, watches[15].val.f);\n+  env->SetDoubleField(obj, watches[16].fid, watches[16].val.d);\n+  env->SetCharField(obj, watches[17].fid, watches[17].val.c);\n+  env->SetObjectField(obj, watches[18].fid, watches[18].val.l);\n+  env->SetObjectField(obj, watches[19].fid, watches[19].val.l);\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> ... done\\n\");\n+  }\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of field modification events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FieldModification\/fieldmod002\/libfieldmod02.cpp","additions":517,"deletions":0,"binary":false,"changes":517,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/FramePop\/framepop001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function FramePop.\n+ *     The test checks the following:\n+ *       - if clazz, method and frame parameters contain expected values\n+ *         for event generated upon exit from single method in single frame\n+ *         specified in call to NotifyFramePop.\n+ *       - if GetFrameLocation indentifies the executable location\n+ *         in the returning method, immediately prior to the return.\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @compile framepop001a.jasm\n+ * @run main\/othervm\/native -agentlib:framepop01 framepop001\n+ *\/\n+\n+\n+\n+public class framepop001 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"framepop01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load framepop001 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+\n+    public static void chain() {\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop001\/framepop001.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class framepop001a {\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial   Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    public static Method dummy:\"()V\" stack 0 locals 0 {\n+        invokestatic    Method framepop001.chain:\"()V\";\n+        return; \/\/ bci=3\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop001\/framepop001a.jasm","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,297 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  const char *cls_sig;\n+  const char *name;\n+  const char *sig;\n+  jlocation loc;\n+} pop_info;\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static size_t eventsExpected = 0;\n+static size_t eventsCount = 0;\n+static pop_info pops[] = {\n+    { \"Lframepop001;\", \"chain\", \"()V\", 0 },\n+    { \"Lframepop001a;\", \"dummy\", \"()V\", 3 },\n+};\n+\n+void JNICALL Breakpoint(jvmtiEnv *jvmti, JNIEnv *env,\n+                        jthread thr, jmethodID method, jlocation location) {\n+  jvmtiError err;\n+\n+  err = jvmti->NotifyFramePop(thr, 0);\n+  if (err == JVMTI_ERROR_NONE) {\n+    eventsExpected++;\n+  } else {\n+    printf(\"(NotifyFramePop#0) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  err = jvmti->NotifyFramePop(thr, 1);\n+  if (err == JVMTI_ERROR_NONE) {\n+    eventsExpected++;\n+  } else {\n+    printf(\"(NotifyFramePop#1) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+void JNICALL FramePop(jvmtiEnv *jvmti, JNIEnv *env,\n+                      jthread thr, jmethodID method, jboolean wasPopedByException) {\n+  jvmtiError err;\n+  char *cls_sig, *name, *sig, *generic;\n+  jclass cls;\n+  jmethodID mid;\n+  jlocation loc;\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> retrieving frame pop info ...\\n\");\n+  }\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls, &cls_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetMethodName(method, &name, &sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetFrameLocation(thr, 0, &mid, &loc);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n+    printf(\">>>     method: \\\"%s%s\\\"\\n\", name, sig);\n+    printf(\">>>   location: 0x%x%08x\\n\",\n+           (jint)(loc >> 32), (jint)loc);\n+    printf(\">>> ... done\\n\");\n+  }\n+  if (eventsCount < sizeof(pops)\/sizeof(pop_info)) {\n+    if (cls_sig == NULL ||\n+        strcmp(cls_sig, pops[eventsCount].cls_sig) != 0) {\n+      printf(\"(pop#%\" PRIuPTR \") wrong class: \\\"%s\\\"\",\n+             eventsCount, cls_sig);\n+      printf(\", expected: \\\"%s\\\"\\n\", pops[eventsCount].cls_sig);\n+      result = STATUS_FAILED;\n+    }\n+    if (name == NULL ||\n+        strcmp(name, pops[eventsCount].name) != 0) {\n+      printf(\"(pop#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+             eventsCount, name);\n+      printf(\", expected: \\\"%s\\\"\\n\", pops[eventsCount].name);\n+      result = STATUS_FAILED;\n+    }\n+    if (sig == NULL ||\n+        strcmp(sig, pops[eventsCount].sig) != 0) {\n+      printf(\"(pop#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+             eventsCount, sig);\n+      printf(\", expected: \\\"%s\\\"\\n\", pops[eventsCount].sig);\n+      result = STATUS_FAILED;\n+    }\n+    if (loc != pops[eventsCount].loc) {\n+      printf(\"(pop#%\" PRIuPTR \") wrong location: 0x%x%08x\",\n+             eventsCount, (jint)(loc >> 32), (jint)loc);\n+      printf(\", expected: 0x%x\\n\", (jint)pops[eventsCount].loc);\n+      result = STATUS_FAILED;\n+    }\n+  } else {\n+    printf(\"Unexpected frame pop catched:\");\n+    printf(\"     class: \\\"%s\\\"\\n\", cls_sig);\n+    printf(\"    method: \\\"%s%s\\\"\\n\", name, sig);\n+    printf(\"  location: 0x%x%08x\\n\", (jint)(loc >> 32), (jint)loc);\n+    result = STATUS_FAILED;\n+  }\n+  eventsCount++;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_framepop001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_framepop001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_framepop001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_frame_pop_events &&\n+      caps.can_generate_breakpoint_events) {\n+    callbacks.Breakpoint = &Breakpoint;\n+    callbacks.FramePop = &FramePop;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: FramePop or Breakpoint event is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_framepop001_check(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+  jclass clz;\n+  jmethodID mid;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  if (!caps.can_generate_frame_pop_events ||\n+      !caps.can_generate_breakpoint_events) {\n+    return result;\n+  }\n+\n+  mid = env->GetStaticMethodID(cls, \"chain\", \"()V\");\n+  if (mid == 0) {\n+    printf(\"Cannot find Method ID for method chain\\n\");\n+    return STATUS_FAILED;\n+  }\n+  err = jvmti->SetBreakpoint(mid, 0);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to SetBreakpoint: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return STATUS_FAILED;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_FRAME_POP, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to enable JVMTI_EVENT_FRAME_POP event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_BREAKPOINT, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to enable BREAKPOINT event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  clz = env->FindClass(\"framepop001a\");\n+  if (clz == NULL) {\n+    printf(\"Cannot find framepop001a class!\\n\");\n+    result = STATUS_FAILED;\n+    return STATUS_FAILED;\n+  }\n+  mid = env->GetStaticMethodID(clz, \"dummy\", \"()V\");\n+  if (mid == 0) {\n+    printf(\"Cannot find Method ID for method dummy\\n\");\n+    return STATUS_FAILED;\n+  }\n+  env->CallStaticVoidMethod(clz, mid);\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of frame pop events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop001\/libframepop01.cpp","additions":297,"deletions":0,"binary":false,"changes":297,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/FramePop\/framepop002.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function FramePop.\n+ *     The test do some nesting\/recursive calls watching frame pop\n+ *     events to be uniquely identified by thread\/class\/method\/frame_depth.\n+ * COMMENTS\n+ *     The test was created as a result of investigating the following bugs\n+ *     intended to write a regression test:\n+ *     4335224 Bug 4245697 not completely fixed jevent.u.frame.frame incorrect\n+ *     4504077 java: dbx should not hold on to a frameid after thread suspension\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:framepop02 framepop002\n+ *\/\n+\n+\n+\n+public class framepop002 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+    final static int THREADS_LIMIT = 20;\n+    final static int NESTING_DEPTH = 100;\n+    final static String TEST_THREAD_NAME_BASE = \"Test Thread #\";\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"framepop02\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load framepop002 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady();\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+        TestThread[] t = new TestThread[THREADS_LIMIT];\n+        getReady();\n+        for (int i = 0; i < THREADS_LIMIT; i++) {\n+            t[i] = new TestThread(TEST_THREAD_NAME_BASE + i);\n+            t[i].start();\n+        }\n+        for (int i = 0; i < THREADS_LIMIT; i++) {\n+            try {\n+                t[i].join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n+            }\n+        }\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+\n+    static class TestThread extends Thread {\n+        int nestingCount = 0;\n+\n+        \/\/ Constructor\n+        TestThread(String name) {\n+            super(name);\n+        }\n+\n+        public void run() {\n+            if (nestingCount < NESTING_DEPTH) {\n+                nestingCount++;\n+                run();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop002\/framepop002.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,488 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+#define MAX_THREADS 32\n+\n+typedef struct item *item_t;\n+struct item {\n+  item_t next;\n+  jmethodID method;\n+  int depth;\n+} item;\n+\n+typedef struct thr {\n+  jthread thread;\n+  item_t tos;\n+} thr;\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static jrawMonitorID event_lock;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static jboolean watch_events = JNI_FALSE;\n+\n+static int pop_count = 0;\n+static int push_count = 0;\n+static int thr_count = 0;\n+static int max_depth = 0;\n+static thr threads[MAX_THREADS];\n+\n+static volatile int callbacksEnabled = NSK_FALSE;\n+static jrawMonitorID agent_lock;\n+\n+static\n+int isTestThread(jvmtiEnv *jvmti, jthread thr) {\n+  jvmtiError err;\n+  jvmtiThreadInfo inf;\n+  const char* TEST_THREAD_NAME_BASE = \"Test Thread\";\n+\n+  err = jvmti->GetThreadInfo(thr, &inf);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetThreadInfo) unexpected error: %s (%d)\\n\", TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return 0;\n+  }\n+  return strncmp(inf.name, TEST_THREAD_NAME_BASE, strlen(TEST_THREAD_NAME_BASE)) == 0;\n+}\n+\n+static\n+void printInfo(jvmtiEnv *jvmti, jthread thr, jmethodID method, int depth) {\n+  jvmtiError err;\n+  jvmtiThreadInfo inf;\n+  char *clsig, *name, *sig, *generic;\n+  jclass cls;\n+\n+  err = jvmti->GetThreadInfo(thr, &inf);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetThreadInfo) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  err = jvmti->GetClassSignature(cls, &clsig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  err = jvmti->GetMethodName(method, &name, &sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  printf(\"  %s: %s.%s%s, depth = %d\\n\", inf.name, clsig, name, sig, depth);\n+\n+  jvmti->Deallocate((unsigned char *)sig);\n+  jvmti->Deallocate((unsigned char *)name);\n+  jvmti->Deallocate((unsigned char *)clsig);\n+  jvmti->Deallocate((unsigned char *)inf.name);\n+}\n+\n+static\n+void pop(jvmtiEnv *jvmti, JNIEnv *env, jthread thr, jmethodID method, int depth) {\n+  item_t old;\n+  int i, count = 0;\n+\n+  for (i = 0; i < thr_count; i++) {\n+    if (env->IsSameObject(threads[i].thread, thr)) {\n+      break;\n+    }\n+  }\n+\n+  if (i == thr_count) {\n+    watch_events = JNI_FALSE;\n+    printf(\"Unknown thread:\\n\");\n+    printInfo(jvmti, thr, method, depth);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  if (threads[i].tos == NULL) {\n+    watch_events = JNI_FALSE;\n+    printf(\"Stack underflow:\\n\");\n+    printInfo(jvmti, thr, method, depth);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  do {\n+    pop_count++;\n+    old = threads[i].tos;\n+    threads[i].tos = threads[i].tos->next;\n+    if (old->method == method && old->depth == depth) {\n+      free(old);\n+      return;\n+    }\n+    free(old);\n+  } while (threads[i].tos != NULL);\n+\n+  watch_events = JNI_FALSE;\n+  printf(\"Frame pop does not match any entry:\\n\");\n+  printInfo(jvmti, thr, method, depth);\n+  result = STATUS_FAILED;\n+}\n+\n+static\n+void push(JNIEnv *env, jthread thr, jmethodID method, int depth) {\n+  item_t new_item;\n+  int i;\n+\n+  for (i = 0; i < thr_count; i++) {\n+    if (env->IsSameObject(threads[i].thread, thr)) {\n+      break;\n+    }\n+  }\n+\n+  if (i == thr_count) {\n+    thr_count++;\n+    if (thr_count == MAX_THREADS) {\n+      watch_events = JNI_FALSE;\n+      printf(\"Out of threads\\n\");\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    threads[i].thread = env->NewGlobalRef(thr);\n+    threads[i].tos = NULL;\n+  }\n+\n+  new_item = (item_t)malloc(sizeof(item));\n+  if (new_item == NULL) {\n+    watch_events = JNI_FALSE;\n+    printf(\"Out of memory\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  new_item->next = threads[i].tos;\n+  new_item->method = method;\n+  new_item->depth = depth;\n+  threads[i].tos = new_item;\n+  push_count++;\n+  max_depth = (max_depth < depth) ? depth : max_depth;\n+}\n+\n+void JNICALL MethodEntry(jvmtiEnv *jvmti, JNIEnv *env,\n+                         jthread thr, jmethodID method) {\n+  jvmtiError err;\n+  jboolean isNative;\n+  jint frameCount;\n+\n+  if (watch_events == JNI_FALSE) return;\n+\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  if (!callbacksEnabled) {\n+    jvmti->RawMonitorExit(agent_lock);\n+    return;\n+  }\n+\n+  err = jvmti->GetFrameCount(thr, &frameCount);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFrameCount#entry) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    printInfo(jvmti, thr, method, frameCount);\n+    result = STATUS_FAILED;\n+    jvmti->RawMonitorExit(agent_lock);\n+    return;\n+  }\n+\n+  err = jvmti->IsMethodNative(method, &isNative);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(IsMethodNative) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    printInfo(jvmti, thr, method, frameCount);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (isTestThread(jvmti, thr)) {\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>> %sMethod entry\\n>>>\",\n+             (isNative == JNI_TRUE) ? \"Native \" : \"\");\n+      printInfo(jvmti, thr, method, frameCount);\n+    }\n+    if (isNative == JNI_FALSE) {\n+      err = jvmti->RawMonitorEnter(event_lock);\n+      if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        printInfo(jvmti, thr, method, frameCount);\n+        result = STATUS_FAILED;\n+      }\n+      push((JNIEnv *)env, thr, method, frameCount);\n+      err = jvmti->RawMonitorExit(event_lock);\n+      if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        printInfo(jvmti, thr, method, frameCount);\n+        result = STATUS_FAILED;\n+      }\n+      err = jvmti->NotifyFramePop(thr, 0);\n+      if (err != JVMTI_ERROR_NONE) {\n+        printf(\"(NotifyFramePop) unexpected error: %s (%d)\\n\",\n+               TranslateError(err), err);\n+        printInfo(jvmti, thr, method, frameCount);\n+        result = STATUS_FAILED;\n+      }\n+    }\n+  }\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+void JNICALL VMStart(jvmtiEnv *jvmti, JNIEnv* jni_env) {\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  callbacksEnabled = NSK_TRUE;\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+\n+void JNICALL VMDeath(jvmtiEnv *jvmti, JNIEnv* jni_env) {\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  callbacksEnabled = NSK_FALSE;\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+void JNICALL FramePop(jvmtiEnv *jvmti, JNIEnv *env,\n+                      jthread thr, jmethodID method, jboolean wasPopedByException) {\n+  jvmtiError err;\n+  jint frameCount;\n+\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  if (!callbacksEnabled) {\n+    jvmti->RawMonitorExit(agent_lock);\n+    return;\n+  }\n+  err = jvmti->GetFrameCount(thr, &frameCount);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetFrameCount#entry) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    printInfo(jvmti, thr, method, frameCount);\n+    result = STATUS_FAILED;\n+    jvmti->RawMonitorExit(agent_lock);\n+    return;\n+  }\n+\n+  if (isTestThread(jvmti, thr)) {\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>> Frame Pop\\n>>>\");\n+      printInfo(jvmti, thr, method, frameCount);\n+    }\n+    err = jvmti->RawMonitorEnter(event_lock);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      printInfo(jvmti, thr, method, frameCount);\n+      result = STATUS_FAILED;\n+    }\n+    pop(jvmti, (JNIEnv *)env, thr, method, frameCount);\n+    err = jvmti->RawMonitorExit(event_lock);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      printInfo(jvmti, thr, method, frameCount);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_framepop002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_framepop002(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->CreateRawMonitor(\"_event_lock\", &event_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_frame_pop_events &&\n+      caps.can_generate_method_entry_events) {\n+    callbacks.MethodEntry = &MethodEntry;\n+    callbacks.FramePop = &FramePop;\n+    callbacks.VMStart = &VMStart;\n+    callbacks.VMDeath = &VMDeath;\n+\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      return JNI_ERR;\n+    }\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+    if (err != JVMTI_ERROR_NONE) {\n+      return JNI_ERR;\n+    }\n+\n+    if (jvmti->CreateRawMonitor(\"agent_lock\", &agent_lock) != JVMTI_ERROR_NONE) {\n+      return JNI_ERR;\n+    }\n+\n+  } else {\n+    printf(\"Warning: FramePop or MethodEntry event is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL Java_framepop002_getReady(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+\n+  if (!caps.can_generate_frame_pop_events ||\n+      !caps.can_generate_method_entry_events) {\n+    return ;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_METHOD_ENTRY, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_FRAME_POP, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to enable JVMTI_EVENT_FRAME_POP event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  watch_events = JNI_TRUE;\n+}\n+\n+JNIEXPORT jint JNICALL Java_framepop002_check(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+\n+  watch_events = JNI_FALSE;\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_FRAME_POP, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_FRAME_POP event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_METHOD_ENTRY, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\"%d threads, %d method entrys, %d frame pops, max depth = %d\\n\",\n+           thr_count, push_count, pop_count, max_depth);\n+  }\n+\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/FramePop\/framepop002\/libframepop02.cpp","additions":488,"deletions":0,"binary":false,"changes":488,"status":"added"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+\n+extern \"C\" {\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  char *name;\n+  char *sig;\n+  jlocation loc;\n+} writable_entry_info;\n+\n+typedef struct {\n+  const char *name;\n+  const char *sig;\n+  const jlocation loc;\n+} entry_info;\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static size_t eventsExpected = 0;\n+static size_t eventsCount = 0;\n+static entry_info entries[] = {\n+    { \"check\", \"()I\", -1 },\n+    { \"dummy\", \"()V\", 0 },\n+    { \"chain\", \"()V\", -1 }\n+};\n+\n+void JNICALL MethodEntry(jvmtiEnv *jvmti, JNIEnv *env,\n+                         jthread thr, jmethodID method) {\n+  jvmtiError err;\n+  char *cls_sig, *generic;\n+  writable_entry_info entry;\n+  jclass cls;\n+  jmethodID mid;\n+  char buffer[32];\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls, &cls_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (cls_sig != NULL &&\n+      strcmp(cls_sig, \"Lmentry001;\") == 0) {\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>> retrieving method entry info ...\\n\");\n+    }\n+    err = jvmti->GetMethodName(method,\n+                                   &entry.name, &entry.sig, &generic);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->GetFrameLocation(thr, 0, &mid, &entry.loc);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n+      printf(\">>>     method: \\\"%s%s\\\"\\n\", entry.name, entry.sig);\n+      printf(\">>>   location: %s\\n\", jlong_to_string(entry.loc, buffer));\n+      printf(\">>> ... done\\n\");\n+    }\n+    if (eventsCount < sizeof(entries)\/sizeof(entry_info)) {\n+      if (entry.name == NULL ||\n+          strcmp(entry.name, entries[eventsCount].name) != 0) {\n+        printf(\"(entry#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               eventsCount, entry.name);\n+        printf(\", expected: \\\"%s\\\"\\n\", entries[eventsCount].name);\n+        result = STATUS_FAILED;\n+      }\n+      if (entry.sig == NULL ||\n+          strcmp(entry.sig, entries[eventsCount].sig) != 0) {\n+        printf(\"(entry#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               eventsCount, entry.sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", entries[eventsCount].sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (entry.loc != entries[eventsCount].loc) {\n+        printf(\"(entry#%\" PRIuPTR \") wrong location: %s\",\n+               eventsCount, jlong_to_string(entry.loc, buffer));\n+        printf(\", expected: %s\\n\",\n+               jlong_to_string(entries[eventsCount].loc, buffer));\n+        result = STATUS_FAILED;\n+      }\n+    } else {\n+      printf(\"Unexpected method entry catched:\");\n+      printf(\"     class: \\\"%s\\\"\\n\", cls_sig);\n+      printf(\"    method: \\\"%s%s\\\"\\n\", entry.name, entry.sig);\n+      printf(\"  location: %s\\n\", jlong_to_string(entry.loc, buffer));\n+      result = STATUS_FAILED;\n+    }\n+    eventsCount++;\n+  }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_mentry001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_mentry001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_mentry001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_method_entry_events) {\n+    callbacks.MethodEntry = &MethodEntry;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: MethodEntry event is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_mentry001_enable(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+\n+  if (jvmti == NULL) {\n+    return;\n+  }\n+\n+  if (!caps.can_generate_method_entry_events) {\n+    return;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_METHOD_ENTRY, NULL);\n+  if (err == JVMTI_ERROR_NONE) {\n+    eventsExpected = sizeof(entries)\/sizeof(entry_info);\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_mentry001_check(JNIEnv *env, jclass cls) {\n+  jmethodID mid;\n+\n+  mid = env->GetStaticMethodID(cls, \"dummy\", \"()V\");\n+  if (mid == NULL) {\n+    printf(\"Cannot find metod \\\"dummy()\\\"!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  env->CallStaticVoidMethod(cls, mid);\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of MethodEntry events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_mentry001_chain(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  if (!caps.can_generate_method_entry_events) {\n+    return;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_METHOD_ENTRY, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry001\/libmentry01.cpp","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MethodEntry\/mentry001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function MethodEntry.\n+ *     The test checks the following:\n+ *       - if method and frame parameters of the function\n+ *         contain expected values for events generated upon entry\n+ *         of Java and native methods.\n+ *       - if GetFrameLocation indentifies the initial executable\n+ *         location in the method being entered.\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *     Fixed the 5004632 bug.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:mentry01 mentry001\n+ *\/\n+\n+\n+\n+public class mentry001 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"mentry01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load mentry001 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void enable();\n+    native static int check();\n+    native static void chain();\n+\n+    public static void main(String args[]) {\n+        enable();\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+\n+    public static void dummy() {\n+        chain();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry001\/mentry001.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int MethodEntriesExpected = 0;\n+static int MethodExitsExpected = 0;\n+static int MethodEntriesCount = 0;\n+static int MethodExitsCount = 0;\n+static jmethodID mid = NULL;\n+\n+void JNICALL MethodEntry(jvmtiEnv *jvmti, JNIEnv *env,\n+                         jthread thr, jmethodID method) {\n+  if (mid == method) {\n+    MethodEntriesCount++;\n+  }\n+}\n+\n+void JNICALL MethodExit(jvmtiEnv *jvmti, JNIEnv *env,\n+                        jthread thr, jmethodID method,\n+                        jboolean was_poped_by_exc, jvalue return_value) {\n+  if (mid == method) {\n+    MethodExitsCount++;\n+  }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_mentry002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_mentry002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_mentry002(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jint res;\n+  jvmtiError err;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_method_entry_events &&\n+      caps.can_generate_method_exit_events) {\n+    callbacks.MethodEntry = &MethodEntry;\n+    callbacks.MethodExit = &MethodExit;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: MethodEntry or MethodExit event is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_mentry002_getReady(JNIEnv *env, jclass cls, jint i) {\n+  jvmtiError err;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return;\n+  }\n+\n+  if (!caps.can_generate_method_entry_events ||\n+      !caps.can_generate_method_exit_events) {\n+    return;\n+  }\n+\n+  mid = env->GetStaticMethodID(cls, \"emptyMethod\", \"()V\");\n+  if (mid == NULL) {\n+    printf(\"Cannot find Method ID for emptyMethod\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_METHOD_ENTRY, NULL);\n+  if (err == JVMTI_ERROR_NONE) {\n+    MethodEntriesExpected = i;\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_METHOD_ENTRY event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_METHOD_EXIT, NULL);\n+  if (err == JVMTI_ERROR_NONE) {\n+    MethodExitsExpected = i;\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_mentry002_check(JNIEnv *env, jclass cls) {\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> MethodEntry events: %d, MethodExit events: %d\\n\",\n+           MethodEntriesCount, MethodExitsCount);\n+  }\n+  if (MethodEntriesCount != MethodEntriesExpected) {\n+    printf(\"Wrong number of method entry events: %d, expected: %d\\n\",\n+           MethodEntriesCount, MethodEntriesExpected);\n+    result = STATUS_FAILED;\n+  }\n+  if (MethodExitsCount != MethodExitsExpected) {\n+    printf(\"Wrong number of method exit events: %d, expected: %d\\n\",\n+           MethodExitsCount, MethodExitsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry002\/libmentry02.cpp","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MethodEntry\/mentry002.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     Regression test for bug\n+ *         4248826 Method entry\/exit events are not created for empty methods\n+ *         Release summary: 1.0_fcs\n+ *         Hardware version: generic\n+ *         O\/S version (unbundled products): generic\n+ * COMMENTS\n+ *     The test reproduced the bug on winNT 1.0fcs-E build.\n+ *     Ported from JVMDI test \/nsk\/regression\/b4248826.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:mentry02 mentry002\n+ *\/\n+\n+\n+public class mentry002 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+    final static int MAX_LOOP = 100;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"mentry02\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load mentry002 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady(int i);\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+        int count;\n+\n+        getReady(MAX_LOOP);\n+\n+        for(int i = 0; i < MAX_LOOP; i++) {\n+            emptyMethod();\n+        }\n+\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+\n+    public static void emptyMethod() {}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodEntry\/mentry002\/mentry002.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  const char *cls_sig;\n+  const char *name;\n+  const char *sig;\n+  jlocation loc;\n+} method_location_info;\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_TRUE;\n+static size_t eventsExpected = 0;\n+static size_t eventsCount = 0;\n+static method_location_info exits[] = {\n+    { \"Lmexit001a;\", \"chain\", \"()V\", -1 },\n+    { \"Lmexit001a;\", \"dummy\", \"()V\", 3 }\n+};\n+\n+void JNICALL MethodExit(jvmtiEnv *jvmti, JNIEnv *env,\n+                        jthread thr, jmethodID method,\n+                        jboolean was_poped_by_exc, jvalue return_value) {\n+  jvmtiError err;\n+  char *cls_sig, *name, *sig, *generic;\n+  jclass cls;\n+  jmethodID mid;\n+  jlocation loc;\n+  char buffer[32];\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls, &cls_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (cls_sig != NULL &&\n+      strcmp(cls_sig, \"Lmexit001a;\") == 0) {\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>> retrieving method exit info ...\\n\");\n+    }\n+    err = jvmti->GetMethodName(method,\n+                                   &name, &sig, &generic);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->GetFrameLocation(thr, 0, &mid, &loc);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n+      printf(\">>>     method: \\\"%s%s\\\"\\n\", name, sig);\n+      printf(\">>>   location: %s\\n\", jlong_to_string(loc, buffer));\n+      printf(\">>> ... done\\n\");\n+    }\n+    if (eventsCount < sizeof(exits)\/sizeof(method_location_info)) {\n+      if (cls_sig == NULL ||\n+          strcmp(cls_sig, exits[eventsCount].cls_sig) != 0) {\n+        printf(\"(exit#%\" PRIuPTR \") wrong class: \\\"%s\\\"\",\n+               eventsCount, cls_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].cls_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (name == NULL ||\n+          strcmp(name, exits[eventsCount].name) != 0) {\n+        printf(\"(exit#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               eventsCount, name);\n+        printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].name);\n+        result = STATUS_FAILED;\n+      }\n+      if (sig == NULL ||\n+          strcmp(sig, exits[eventsCount].sig) != 0) {\n+        printf(\"(exit#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               eventsCount, sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (loc != exits[eventsCount].loc) {\n+        printf(\"(exit#%\" PRIuPTR \") wrong location: %s\",\n+               eventsCount, jlong_to_string(loc, buffer));\n+        printf(\", expected: %s\\n\",\n+               jlong_to_string(exits[eventsCount].loc, buffer));\n+        result = STATUS_FAILED;\n+      }\n+    } else {\n+      printf(\"Unexpected method exit catched:\");\n+      printf(\"     class: \\\"%s\\\"\\n\", cls_sig);\n+      printf(\"    method: \\\"%s%s\\\"\\n\", name, sig);\n+      printf(\"  location: %s\\n\", jlong_to_string(loc, buffer));\n+      result = STATUS_FAILED;\n+    }\n+    eventsCount++;\n+  }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_mexit001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_mexit001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_mexit001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_method_exit_events) {\n+    callbacks.MethodExit = &MethodExit;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: MethodExit event is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_mexit001_init0(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_METHOD_EXIT, NULL);\n+  if (err == JVMTI_ERROR_NONE) {\n+    eventsExpected = sizeof(exits)\/sizeof(method_location_info);\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  \/\/ TODO: should we return result instead?\n+  return PASSED;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_mexit001_check(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+  jclass clz;\n+  jmethodID mid;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  if (!caps.can_generate_method_exit_events) {\n+    return result;\n+  }\n+\n+  clz = env->FindClass(\"mexit001a\");\n+  if (clz == NULL) {\n+    printf(\"Cannot find MethodExit.mexit001a class!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  mid = env->GetStaticMethodID(clz, \"dummy\", \"()V\");\n+  if (mid == NULL) {\n+    printf(\"Cannot find metod \\\"dummy()\\\"!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  env->CallStaticVoidMethod(clz, mid);\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_METHOD_EXIT, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of MethodExit events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_mexit001a_chain(JNIEnv *env, jclass cls) {\n+  printf(\"Executing chain()\\n\");\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit001\/libmexit01.cpp","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MethodExit\/mexit001.\n+ * VM Testbase keywords: [jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function MethodExit.\n+ *     The test checks the following:\n+ *       - if method and frame parameters of the function\n+ *         contain expected values for events generated upon exit\n+ *         from Java and native methods.\n+ *       - if GetFrameLocation indentifies the executable location\n+ *         in the returning method, immediately prior to the return.\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *     Fixed the 5004632 bug.\n+ *\n+ * @library \/test\/lib\n+ * @compile mexit001a.jasm\n+ * @run main\/othervm\/native -agentlib:mexit01 mexit001\n+ *\/\n+\n+public class mexit001 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"mexit01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load mexit001 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static int check();\n+    native static int init0();\n+\n+    public static void main(String args[]) {\n+        init0();\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit001\/mexit001.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class mexit001a {\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial   Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static native Method chain:\"()V\";\n+\n+    public static Method dummy:\"()V\" stack 0 locals 0 {\n+        invokestatic    Method chain:\"()V\";\n+        return; \/\/ bci=3\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit001\/mexit001a.jasm","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+* Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+*\n+* This code is free software; you can redistribute it and\/or modify it\n+* under the terms of the GNU General Public License version 2 only, as\n+* published by the Free Software Foundation.\n+*\n+* This code is distributed in the hope that it will be useful, but WITHOUT\n+* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+* version 2 for more details (a copy is included in the LICENSE file that\n+* accompanied this code).\n+*\n+* You should have received a copy of the GNU General Public License version\n+* 2 along with this work; if not, write to the Free Software Foundation,\n+* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+*\n+* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+* or visit www.oracle.com if you need additional information or have any\n+* questions.\n+*\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  const char *cls_sig;\n+  const char *name;\n+  const char *sig;\n+  jlocation loc;\n+} method_location_info;\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static size_t eventsExpected = 0;\n+static size_t eventsCount = 0;\n+static method_location_info exits[] = {\n+    { \"Lmexit002a;\", \"chain\", \"()V\", -1 },\n+    { \"Lmexit002a;\", \"dummy\", \"()V\", 3 }\n+};\n+\n+void JNICALL MethodExit(jvmtiEnv *jvmti, JNIEnv *env,\n+                        jthread thr, jmethodID method,\n+                        jboolean was_poped_by_exc, jvalue return_value) {\n+  jvmtiError err;\n+  char *cls_sig, *name, *sig, *generic;\n+  jclass cls;\n+  jmethodID mid;\n+  jlocation loc;\n+  char buffer[32];\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls, &cls_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (cls_sig != NULL &&\n+      strcmp(cls_sig, \"Lmexit002a;\") == 0) {\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>> retrieving method exit info ...\\n\");\n+    }\n+    err = jvmti->GetMethodName(method,\n+                                   &name, &sig, &generic);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->GetFrameLocation(thr, 0, &mid, &loc);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n+      printf(\">>>     method: \\\"%s%s\\\"\\n\", name, sig);\n+      printf(\">>>   location: %s\\n\", jlong_to_string(loc, buffer));\n+      printf(\">>> ... done\\n\");\n+    }\n+    if (eventsCount < sizeof(exits)\/sizeof(method_location_info)) {\n+      if (cls_sig == NULL ||\n+          strcmp(cls_sig, exits[eventsCount].cls_sig) != 0) {\n+        printf(\"(exit#%\" PRIuPTR \") wrong class: \\\"%s\\\"\",\n+               eventsCount, cls_sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].cls_sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (name == NULL ||\n+          strcmp(name, exits[eventsCount].name) != 0) {\n+        printf(\"(exit#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+               eventsCount, name);\n+        printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].name);\n+        result = STATUS_FAILED;\n+      }\n+      if (sig == NULL ||\n+          strcmp(sig, exits[eventsCount].sig) != 0) {\n+        printf(\"(exit#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+               eventsCount, sig);\n+        printf(\", expected: \\\"%s\\\"\\n\", exits[eventsCount].sig);\n+        result = STATUS_FAILED;\n+      }\n+      if (loc != exits[eventsCount].loc) {\n+        printf(\"(exit#%\" PRIuPTR \") wrong location: %s\",\n+               eventsCount, jlong_to_string(loc, buffer));\n+        printf(\", expected: %s\\n\",\n+               jlong_to_string(exits[eventsCount].loc, buffer));\n+        result = STATUS_FAILED;\n+      }\n+    } else {\n+      printf(\"Unexpected method exit catched:\");\n+      printf(\"     class: \\\"%s\\\"\\n\", cls_sig);\n+      printf(\"    method: \\\"%s%s\\\"\\n\", name, sig);\n+      printf(\"  location: %s\\n\", jlong_to_string(loc, buffer));\n+      result = STATUS_FAILED;\n+    }\n+    eventsCount++;\n+  }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_mexit002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_mexit002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_mexit002(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_method_exit_events) {\n+    callbacks.MethodExit = &MethodExit;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: MethodExit event is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_mexit002_check(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+  jclass clz;\n+  jmethodID mid;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  if (!caps.can_generate_method_exit_events) {\n+    return result;\n+  }\n+\n+  clz = env->FindClass(\"mexit002a\");\n+  if (clz == NULL) {\n+    printf(\"Failed to find class \\\"mexit002a\\\"!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  mid = env->GetStaticMethodID(clz, \"dummy\", \"()V\");\n+  if (mid == NULL) {\n+    printf(\"Failed to get method \\\"dummy\\\"!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_METHOD_EXIT, NULL);\n+  if (err == JVMTI_ERROR_NONE) {\n+    eventsExpected = sizeof(exits)\/sizeof(method_location_info);\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  env->CallStaticVoidMethod(clz, mid);\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_METHOD_EXIT, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of method exit events: %\" PRIuPTR \", expected: %\" PRIuPTR \"\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_mexit002a_chain(JNIEnv *env, jclass cls) {\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> about to exit method chain ...\\n\");\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit002\/libmexit02.cpp","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MethodExit\/mexit002.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function MethodExit.\n+ *     The test checks the following:\n+ *       - if clazz, method and frame parameters of the function\n+ *         contain expected values for events generated upon exit\n+ *         from Java and native methods.\n+ *       - if GetFrameLocation indentifies the executable location\n+ *         in the returning method, immediately prior to the return.\n+ *     The test is the same as mexit001 one. The only difference is\n+ *     the METHOD_EXIT event enable is moved from method chain()\n+ *     to method check().\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *     Fixed the 5004632 bug.\n+ *\n+ * @library \/test\/lib\n+ * @compile mexit002a.jasm\n+ * @run main\/othervm\/native -agentlib:mexit02 mexit002\n+ *\/\n+\n+\n+\n+public class mexit002 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"mexit02\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load mexit002 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static int check();\n+\n+    public static void main(String args[]) {\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit002\/mexit002.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class mexit002a {\n+\n+    public Method \"<init>\":\"()V\" stack 1 locals 1 {\n+        aload_0;\n+        invokespecial   Method java\/lang\/Object.\"<init>\":\"()V\";\n+        return;\n+    }\n+\n+    static native Method chain:\"()V\";\n+\n+    public static Method dummy:\"()V\" stack 0 locals 0 {\n+        invokestatic    Method chain:\"()V\";\n+        return; \/\/ bci=3\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/mexit002\/mexit002a.jasm","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.locks.LockSupport;\n+\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:MethodExitVThread MethodExitVThreadTest\n+ *\/\n+\n+public class MethodExitVThreadTest {\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"MethodExitVThread\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load MethodExitVThread library\");\n+            System.err.println(\"java.library.path:\" + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    final static AtomicInteger result = new AtomicInteger(0);\n+    native static int check();\n+    native static int init0();\n+\n+    final static long NUM_OF_TASKS = 100_000;\n+    public static void main(String args[]) throws InterruptedException {\n+\n+        ArrayList<Thread> threads = new ArrayList<>();\n+        for (int i = 0; i < NUM_OF_TASKS; i++) {\n+            Runnable task = new Task();\n+            \/\/Thread tested = Thread.newThread(\"tested\", Thread.VIRTUAL, task);\n+            Thread thread = new Thread(task, \"tested\");\n+            threads.add(thread);\n+            thread.start();\n+        }\n+\n+        for (Thread thread: threads) {\n+            thread.join();\n+        }\n+        \/*\n+        if (result.get() != NUM_OF_TASKS * 3) {\n+            throw new RuntimeException(\"Check() returned \" + result);\n+        }\n+        *\/\n+    }\n+\n+    static void method1() {\n+\n+    }\n+\n+    static void method2() {\n+\n+    }\n+\n+    static class Task implements Runnable {\n+\n+        @Override\n+        public void run() {\n+            init0();\n+            method1();\n+            LockSupport.parkNanos(10);\n+            method2();\n+            result.addAndGet(check());\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/vthread\/MethodExitVThreadTest.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,243 @@\n+\/*\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+typedef struct {\n+  const char *cls_sig;\n+  const char *name;\n+  const char *sig;\n+  jlocation loc;\n+} method_location_info;\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_TRUE;\n+static jint eventsCount = 0;\n+\n+\n+static method_location_info expected_exits[] = {\n+    { \"LMethodExitVThreadTest;\", \"init0\", \"()I\", -1 },\n+    { \"LMethodExitVThreadTest;\", \"method1\", \"()V\", 0 },\n+    { \"LMethodExitVThreadTest;\", \"method2\", \"()V\", 0 }\n+};\n+\n+void JNICALL MethodExit(jvmtiEnv *jvmti, JNIEnv *env,\n+                        jthread thr, jmethodID method,\n+                        jboolean was_poped_by_exc, jvalue return_value) {\n+  jvmtiError err;\n+  char *cls_sig, *name, *sig, *generic;\n+  jclass cls;\n+  jmethodID mid;\n+  jlocation loc;\n+  char buffer[32];\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &cls);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  err = jvmti->GetClassSignature(cls, &cls_sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+  if (cls_sig != NULL && strcmp(cls_sig, \"LMethodExitVThreadTest;\") == 0) {\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>> retrieving method exit info ...\\n\");\n+    }\n+    err = jvmti->GetMethodName(method,\n+                                   &name, &sig, &generic);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    err = jvmti->GetFrameLocation(thr, 0, &mid, &loc);\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      result = STATUS_FAILED;\n+      return;\n+    }\n+    if (printdump == JNI_TRUE) {\n+      printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n+      printf(\">>>     method: \\\"%s%s\\\"\\n\", name, sig);\n+      printf(\">>>   location: %s\\n\", jlong_to_string(loc, buffer));\n+      printf(\">>> ... done\\n\");\n+    }\n+    \/*\n+    if (cls_sig == NULL ||\n+        strcmp(cls_sig, expected_exits[eventsCount].cls_sig) != 0) {\n+      printf(\"(exit#%\" PRIuPTR \") wrong class: \\\"%s\\\"\",\n+             eventsCount, cls_sig);\n+      printf(\", expected: \\\"%s\\\"\\n\", expected_exits[eventsCount].cls_sig);\n+      result = STATUS_FAILED;\n+    }\n+    if (name == NULL ||\n+        strcmp(name, expected_exits[eventsCount].name) != 0) {\n+      printf(\"(exit#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n+             eventsCount, name);\n+      printf(\", expected: \\\"%s\\\"\\n\", expected_exits[eventsCount].name);\n+      result = STATUS_FAILED;\n+    }\n+    if (sig == NULL ||\n+        strcmp(sig, expected_exits[eventsCount].sig) != 0) {\n+      printf(\"(exit#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n+             eventsCount, sig);\n+      printf(\", expected: \\\"%s\\\"\\n\", expected_exits[eventsCount].sig);\n+      result = STATUS_FAILED;\n+    }\n+    if (loc != expected_exits[eventsCount].loc) {\n+      printf(\"(exit#%\" PRIuPTR \") wrong location: %s\",\n+             eventsCount, jlong_to_string(loc, buffer));\n+      printf(\", expected: %s\\n\",\n+             jlong_to_string(expected_exits[eventsCount].loc, buffer));\n+      result = STATUS_FAILED;\n+    }*\/\n+    eventsCount++;\n+  }\n+}\n+\n+jint Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  memset(&caps, 0, sizeof(caps));\n+ \/\/ caps.can_support_virtual_threads = 1;\n+  caps.can_generate_method_exit_events = 1;\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (caps.can_generate_method_exit_events) {\n+    callbacks.MethodExit = &MethodExit;\n+    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+    if (err != JVMTI_ERROR_NONE) {\n+      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+             TranslateError(err), err);\n+      return JNI_ERR;\n+    }\n+  } else {\n+    printf(\"Warning: MethodExit event is not implemented\\n\");\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_MethodExitVThreadTest_init0(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+  jthread thread;\n+  if (jvmti == NULL) {\n+    env->FatalError(\"JVMTI client was not properly loaded!\");\n+  }\n+\n+\n+  err = jvmti->GetCurrentThread(&thread);\n+  if (err != JVMTI_ERROR_NONE) {\n+    env->FatalError(\"Error in GetCurrentThread.\");\n+  }\n+\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_METHOD_EXIT, thread);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    env->FatalError(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event.\");\n+  }\n+\n+  \/\/ TODO: should we return result instead?\n+  return PASSED;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_MethodExitVThreadTest_check(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+  jthread thread;\n+\n+  if (jvmti == NULL) {\n+    env->FatalError(\"JVMTI client was not properly loaded!\");\n+  }\n+\n+  if (!caps.can_generate_method_exit_events) {\n+    env->FatalError(\"Error method exit is not supported.\");\n+  }\n+\n+  err = jvmti->GetCurrentThread(&thread);\n+  if (err != JVMTI_ERROR_NONE) {\n+    env->FatalError(\"Error in GetCurrentThread.\");\n+  }\n+\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_METHOD_EXIT, thread);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    env->FatalError(\"Failed to disable JVMTI_EVENT_METHOD_EXIT event.\");\n+  }\n+  return eventsCount;\n+}\n+\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/vthread\/libMethodExitVThread.cpp","additions":243,"deletions":0,"binary":false,"changes":243,"status":"added"},{"patch":"@@ -0,0 +1,302 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <jni.h>\n+#include <jvmti.h>\n+\n+#include \"jvmti_common.h\"\n+#include \"jvmti_thread.h\"\n+\n+\n+extern \"C\" {\n+\n+\/* ========================================================================== *\/\n+\n+\/* scaffold objects *\/\n+static JNIEnv *jni = NULL;\n+static jvmtiEnv *jvmti = NULL;\n+static jlong timeout = 0;\n+\n+\/* test objects *\/\n+static jthread thread = NULL;\n+static jobject object = NULL;\n+static volatile int eventsCount = 0;\n+\n+\/* ========================================================================== *\/\n+\n+void JNICALL\n+MonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv *jni, jthread thr, jobject obj) {\n+\n+  printf(\"MonitorContendedEnter event:\\n\\tthread: %p, object: %p\\n\",thr, obj);\n+\n+  if (thread == NULL) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+\/* check if event is for tested thread and for tested object *\/\n+  if (jni->IsSameObject(thread, thr) &&\n+      jni->IsSameObject(object, obj)) {\n+    eventsCount++;\n+    printf(\"Increasing eventCount to %d\\n\", eventsCount);\n+  }\n+}\n+\n+\/* ========================================================================== *\/\n+\n+static int prepare() {\n+  const char *THREAD_NAME = \"Debuggee Thread\";\n+  jclass klass = NULL;\n+  jfieldID field = NULL;\n+  jvmtiThreadInfo info;\n+  jthread *threads = NULL;\n+  jint threads_count = 0;\n+  jvmtiError err;\n+  int i;\n+\n+  printf(\"Prepare: find tested thread\\n\");\n+\n+  \/* get all live threads *\/\n+  err = jvmti->GetAllThreads(&threads_count, &threads);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return NSK_FALSE;\n+  }\n+\n+  if (!(threads_count > 0 && threads != NULL)) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* find tested thread *\/\n+  for (i = 0; i < threads_count; i++) {\n+    if (threads[i] == NULL) {\n+      return NSK_FALSE;\n+    }\n+\n+    \/* get thread information *\/\n+    err = jvmti->GetThreadInfo(threads[i], &info);\n+    if (err != JVMTI_ERROR_NONE) {\n+      return NSK_FALSE;\n+    }\n+\n+    NSK_DISPLAY3(\"    thread #%d (%s): %p\\n\", i, info.name, threads[i]);\n+\n+    \/* find by name *\/\n+    if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+      thread = threads[i];\n+    }\n+  }\n+\n+  \/* deallocate threads list *\/\n+  err = jvmti->Deallocate((unsigned char *) threads);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return NSK_FALSE;\n+  }\n+\n+  if (thread == NULL) {\n+    NSK_COMPLAIN0(\"Debuggee thread not found\");\n+    return NSK_FALSE;\n+  }\n+\n+  \/* make thread accessable for a long time *\/\n+  thread = jni->NewGlobalRef(thread);\n+  if (thread == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get tested thread class *\/\n+  klass = jni->GetObjectClass(thread);\n+  if (klass == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get tested thread field 'endingMonitor' *\/\n+  field = jni->GetFieldID(klass, \"endingMonitor\", \"Ljava\/lang\/Object;\");\n+  if (field == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get 'endingMonitor' object *\/\n+  object = jni->GetObjectField(thread, field);\n+  if (object == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* make object accessable for a long time *\/\n+  object = jni->NewGlobalRef(object);\n+  if (object == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* enable MonitorContendedEnter event *\/\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Prepare: 11\\n\");\n+    return NSK_FALSE;\n+  }\n+  return NSK_TRUE;\n+}\n+\n+static int clean() {\n+  jvmtiError err;\n+  printf(\"Disabling events\\n\");\n+  \/* disable MonitorContendedEnter event *\/\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_MONITOR_CONTENDED_ENTER,\n+                                        NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    nsk_jvmti_setFailStatus();\n+  }\n+\n+  return NSK_TRUE;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent algorithm\n+ *\/\n+static void JNICALL\n+agentProc(jvmtiEnv *jvmti, JNIEnv *agentJNI, void *arg) {\n+  jni = agentJNI;\n+\n+  \/* wait for initial sync *\/\n+  if (!nsk_jvmti_waitForSync(timeout)) {\n+    return;\n+  }\n+\n+  if (!prepare()) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+  \/* clear events count *\/\n+  eventsCount = 0;\n+\n+  \/* resume debugee to catch MonitorContendedEnter event *\/\n+  if (!((nsk_jvmti_resumeSync() == NSK_TRUE) && (nsk_jvmti_waitForSync(timeout) ==NSK_TRUE))) {\n+    return;\n+  }\n+  NSK_DISPLAY1(\"Number of MonitorContendedEnter events: %d\\n\", eventsCount);\n+\n+  if (eventsCount == 0) {\n+    NSK_COMPLAIN0(\"No any MonitorContendedEnter event\\n\");\n+    nsk_jvmti_setFailStatus();\n+  }\n+\n+  if (!clean()) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+\/* resume debugee after last sync *\/\n+  if (!nsk_jvmti_resumeSync())\n+    return;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent library initialization\n+ *\/\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_mcontenter001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_mcontenter001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_mcontenter001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  timeout = 60000; \/\/TODO fix\n+  NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int) timeout);\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = init_agent_data(jvmti, &agent_data);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_generate_monitor_events) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.MonitorContendedEnter = &MonitorContendedEnter;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  \/* register agent proc and arg *\/\n+  nsk_jvmti_setAgentProc(agentProc, NULL);\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Java_mcontenter001_getEventCount\n+    (JNIEnv *env, jobject obj) {\n+  return eventsCount;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEnter\/mcontenter001\/libmcontenter.cpp","additions":302,"deletions":0,"binary":false,"changes":302,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MonitorContendedEnter\/mcontenter001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function\n+ *         MonitorContendedEnter(jni_env, thread, object).\n+ *     The test checks if the thread and object parameters of the function\n+ *     contain expected values for callback when a thread is attemping\n+ *     to enter a Java language monitor already acquired by another thread.\n+ * COMMENTS\n+ *     The test updated to match new JVMTI spec 0.2.90:\n+ *     - change signature of agentProc function\n+ *       and save JNIEnv pointer now passed as argument.\n+ *     1000 ms of sleep added to main thread to reduce probability of bad racing.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:mcontenter mcontenter001\n+ *\/\n+\n+\n+public class mcontenter001 extends DebugeeClass {\n+\n+    \/\/ load native library if required\n+    static {\n+        loadLibrary(\"mcontenter\");\n+    }\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        \/\/ JCK-compatible exit\n+        int result =  new mcontenter001().runIt();\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+\n+    int status = DebugeeClass.TEST_PASSED;\n+    long timeout = 0;\n+\n+    \/\/ tested thread\n+    mcontenter001Thread thread = null;\n+\n+    \/\/ run debuggee\n+    public int runIt() {\n+        timeout = 60000; \/\/ milliseconds TODO fix\n+        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n+\n+        thread = new mcontenter001Thread(\"Debuggee Thread\");\n+\n+        synchronized (thread.endingMonitor) {\n+\n+            \/\/ run thread\n+            try {\n+                \/\/ start thread\n+                synchronized (thread.startingMonitor) {\n+                    thread.start();\n+                    thread.startingMonitor.wait(timeout);\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Failure(e);\n+            }\n+\n+            int totalDelay = 0;\n+            while (getEventCount() < 1 && totalDelay < timeout) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException e) {\n+                    throw new Failure(e);\n+                }\n+                totalDelay += 100;\n+            }\n+\n+            Thread.yield();\n+            System.out.println(\"Thread started\");\n+        }\n+\n+        \/\/ wait for thread finish\n+        try {\n+            thread.join(timeout);\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        System.out.println(\"Sync: thread finished\");\n+        status = checkStatus(status);\n+\n+        return status;\n+    }\n+\n+    private native int getEventCount();\n+}\n+\n+\n+\n+class mcontenter001Thread extends Thread {\n+    public Object startingMonitor = new Object();\n+    public Object endingMonitor = new Object();\n+\n+    public mcontenter001Thread(String name) {\n+        super(name);\n+    }\n+\n+    public void run() {\n+\n+        mcontenter001.checkStatus(DebugeeClass.TEST_PASSED);\n+\n+        \/\/ notify about starting\n+        synchronized (startingMonitor) {\n+            startingMonitor.notify();\n+        }\n+\n+        \/\/ wait until main thread release monitor\n+        synchronized (endingMonitor) {\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEnter\/mcontenter001\/mcontenter001.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,322 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+#include \"jvmti_thread.h\"\n+\n+extern \"C\" {\n+\n+\/* ========================================================================== *\/\n+\n+\/* scaffold objects *\/\n+static JNIEnv *jni = NULL;\n+static jvmtiEnv *jvmti = NULL;\n+static jlong timeout = 0;\n+\n+\/* test objects *\/\n+static jthread thread = NULL;\n+static jobject object = NULL;\n+static volatile int eventsCount = 0;\n+\n+\/* ========================================================================== *\/\n+\n+\/* Check GetPotentialCapabilities function\n+ *\/\n+void JNICALL\n+MonitorContendedEntered(jvmtiEnv *jvmti, JNIEnv *jni, jthread thr, jobject obj) {\n+\n+  NSK_DISPLAY2(\"MonitorContendedEntered event:\\n\\tthread: %p, object: %p\\n\",\n+               thr, obj);\n+\n+  if (thread == NULL) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+\/* check if event is for tested thread and for tested object *\/\n+  if (jni->IsSameObject(thread, thr) &&\n+      jni->IsSameObject(object, obj))\n+    eventsCount++;\n+}\n+\n+void JNICALL\n+MonitorContendedEnter(jvmtiEnv *jvmti, JNIEnv *jni, jthread thr, jobject obj) {\n+\n+  NSK_DISPLAY2(\"MonitorContendedEnter event:\\n\\tthread: %p, object: %p\\n\",\n+               thr, obj);\n+\n+  if (thread == NULL) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+\/* check if event is for tested thread and for tested object *\/\n+  if (jni->IsSameObject(thread, thr) &&\n+      jni->IsSameObject(object, obj))\n+    eventsCount++;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+static int prepare() {\n+  const char *THREAD_NAME = \"Debuggee Thread\";\n+  jclass klass = NULL;\n+  jfieldID field = NULL;\n+  jvmtiThreadInfo info;\n+  jthread *threads = NULL;\n+  jint threads_count = 0;\n+  jvmtiError err;\n+  int i;\n+\n+  NSK_DISPLAY0(\"Prepare: find tested thread\\n\");\n+\n+  \/* get all live threads *\/\n+  err = jvmti->GetAllThreads(&threads_count, &threads);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return NSK_FALSE;\n+  }\n+  if (!(threads_count > 0 && threads != NULL)) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* find tested thread *\/\n+  for (i = 0; i < threads_count; i++) {\n+    if (threads[i] == NULL) {\n+      return NSK_FALSE;\n+    }\n+\n+    \/* get thread information *\/\n+    err = jvmti->GetThreadInfo(threads[i], &info);\n+    if (err != JVMTI_ERROR_NONE) {\n+      return NSK_FALSE;\n+    }\n+\n+    NSK_DISPLAY3(\"    thread #%d (%s): %p\\n\", i, info.name, threads[i]);\n+\n+    \/* find by name *\/\n+    if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+      thread = threads[i];\n+    }\n+  }\n+\n+  if (thread == NULL) {\n+    NSK_COMPLAIN0(\"Debuggee thread not found\");\n+    return NSK_FALSE;\n+  }\n+\n+  \/* deallocate threads list *\/\n+  err = jvmti->Deallocate((unsigned char *) threads);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return NSK_FALSE;\n+  }\n+\n+  if (thread == NULL) {\n+    NSK_COMPLAIN0(\"Debuggee thread not found\");\n+    return NSK_FALSE;\n+  }\n+\n+  \/* make thread accessable for a long time *\/\n+  thread = jni->NewGlobalRef(thread);\n+  if (thread == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get tested thread class *\/\n+  klass = jni->GetObjectClass(thread);\n+  if (klass == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get tested thread field 'endingMonitor' *\/\n+  field = jni->GetFieldID(klass, \"endingMonitor\", \"Ljava\/lang\/Object;\");\n+  if (field == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get 'endingMonitor' object *\/\n+  object = jni->GetObjectField(thread, field);\n+  if (object == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* make object accessable for a long time *\/\n+  object = jni->NewGlobalRef(object);\n+  if (object == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* enable MonitorContendedEntered event *\/\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTERED, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Prepare: 11\\n\");\n+    return NSK_FALSE;\n+  }\n+\n+  \/* enable MonitorContendedEnter event *\/\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_CONTENDED_ENTER, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Prepare: 11\\n\");\n+    return NSK_FALSE;\n+  }\n+\n+  return NSK_TRUE;\n+}\n+\n+static int clean() {\n+  jvmtiError err;\n+  \/* disable MonitorContendedEntered event *\/\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,JVMTI_EVENT_MONITOR_CONTENDED_ENTERED,NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    nsk_jvmti_setFailStatus();\n+  }\n+  return NSK_TRUE;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent algorithm\n+ *\/\n+static void JNICALL\n+agentProc(jvmtiEnv *jvmti, JNIEnv *agentJNI, void *arg) {\n+  jni = agentJNI;\n+\n+\/* wait for initial sync *\/\n+  if (!nsk_jvmti_waitForSync(timeout))\n+    return;\n+\n+  if (!prepare()) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+  \/* clear events count *\/\n+  eventsCount = 0;\n+\n+  \/* resume debugee to catch MonitorContendedEntered event *\/\n+  if (!((nsk_jvmti_resumeSync() == NSK_TRUE) && (nsk_jvmti_waitForSync(timeout) ==NSK_TRUE))) {\n+    return;\n+  }\n+\n+  NSK_DISPLAY1(\"Number of MonitorContendedEntered events: %d\\n\", eventsCount);\n+\n+  if (eventsCount == 0) {\n+    NSK_COMPLAIN0(\"No any MonitorContendedEntered event\\n\");\n+    nsk_jvmti_setFailStatus();\n+  }\n+\n+  if (!clean()) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+\/* resume debugee after last sync *\/\n+  if (!nsk_jvmti_resumeSync())\n+    return;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent library initialization\n+ *\/\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_mcontentered001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_mcontentered001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_mcontentered001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  timeout = 60000; \/\/TODO fix\n+  NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int) timeout);\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = init_agent_data(jvmti, &agent_data);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.MonitorContendedEntered = &MonitorContendedEntered;\n+  callbacks.MonitorContendedEnter = &MonitorContendedEnter;\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  \/* register agent proc and arg *\/\n+  nsk_jvmti_setAgentProc(agentProc, NULL);\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Java_mcontentered001_getEventCount\n+    (JNIEnv *env, jobject obj) {\n+  return eventsCount;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEntered\/mcontentered001\/libmcontentered.cpp","additions":322,"deletions":0,"binary":false,"changes":322,"status":"added"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MonitorContendedEntered\/mcontentered001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function\n+ *         MonitorContendedEntered(jni_env, thread, object).\n+ *     The test checks if the thread and object parameters of the function\n+ *     contain expected values for callback when a thread enters a Java language\n+ *     monitor after waiting for it to be released by another thread.\n+ * COMMENTS\n+ *     The test updated to match new JVMTI spec 0.2.90:\n+ *     - change signature of agentProc function\n+ *       and save JNIEnv pointer now passed as argument.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:mcontentered mcontentered001\n+ *\/\n+\n+public class mcontentered001 extends DebugeeClass {\n+\n+    \/\/ load native library if required\n+    static {\n+        loadLibrary(\"mcontentered\");\n+    }\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        int result = new mcontentered001().runIt();\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+\n+    int status = TEST_PASSED;\n+    long timeout = 0;\n+\n+    \/\/ tested thread\n+    mcontentered001Thread thread = null;\n+\n+    \/\/ run debuggee\n+    public int runIt() {\n+\n+        timeout =  60000; \/\/ milliseconds\n+        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n+\n+        thread = new mcontentered001Thread(\"Debuggee Thread\");\n+\n+        synchronized (thread.endingMonitor) {\n+\n+            \/\/ run thread\n+            try {\n+                \/\/ start thread\n+                synchronized (thread.startingMonitor) {\n+                    thread.start();\n+                    thread.startingMonitor.wait(timeout);\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Failure(e);\n+            }\n+\n+            int totalDelay = 0;\n+            while (getEventCount() < 1 && totalDelay < timeout) {\n+                try {\n+                    Thread.sleep(100);\n+                } catch (InterruptedException e) {\n+                    throw new Failure(e);\n+                }\n+                totalDelay += 100;\n+            }\n+\n+            Thread.yield();\n+            System.out.println(\"Thread started\");\n+        }\n+\n+        \/\/ wait for thread finish\n+        try {\n+            thread.join(timeout);\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        System.out.println(\"Sync: thread finished\");\n+        status = checkStatus(status);\n+\n+        return status;\n+    }\n+\n+    private native int getEventCount();\n+}\n+\n+\/* =================================================================== *\/\n+\n+class mcontentered001Thread extends Thread {\n+    public Object startingMonitor = new Object();\n+    public Object endingMonitor = new Object();\n+\n+    public mcontentered001Thread(String name) {\n+        super(name);\n+    }\n+\n+    public void run() {\n+\n+        mcontentered001.checkStatus(DebugeeClass.TEST_PASSED);\n+\n+        \/\/ notify about starting\n+        synchronized (startingMonitor) {\n+            startingMonitor.notify();\n+        }\n+\n+        \/\/ wait until main thread release monitor\n+        synchronized (endingMonitor) {\n+            endingMonitor.notify();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorContendedEntered\/mcontentered001\/mcontentered001.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+#include \"jvmti_thread.h\"\n+\n+\n+extern \"C\" {\n+\n+\/* ========================================================================== *\/\n+\n+\/* scaffold objects *\/\n+static JNIEnv *jni = NULL;\n+static jvmtiEnv *jvmti = NULL;\n+static jlong timeout = 0;\n+\n+\/* test objects *\/\n+static jthread thread = NULL;\n+static jobject object = NULL;\n+static volatile int eventsCount = 0;\n+\n+\/* ========================================================================== *\/\n+\n+void JNICALL\n+MonitorWait(jvmtiEnv *jvmti, JNIEnv *jni, jthread thr, jobject obj, jlong tout) {\n+\n+  printf(\"MonitorWait event:\\n\\tthread: %p, object: %p, timeout: %d\\n\", thr, obj, (int) tout);\n+\n+  if (thread == NULL) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+\/* check if event is for tested thread and for tested object *\/\n+  if (jni->IsSameObject(thread, thr) &&\n+      jni->IsSameObject(object, obj)) {\n+    eventsCount++;\n+    if (tout != timeout) {\n+      NSK_COMPLAIN1(\"Unexpected timeout value: %d\\n\", (int) tout);\n+      nsk_jvmti_setFailStatus();\n+    }\n+  }\n+}\n+\n+\/* ========================================================================== *\/\n+\n+static int prepare() {\n+  const char *THREAD_NAME = \"Debuggee Thread\";\n+  jclass klass = NULL;\n+  jfieldID field = NULL;\n+  jvmtiThreadInfo info;\n+  jthread *threads = NULL;\n+  jint threads_count = 0;\n+  jvmtiError err;\n+  int i;\n+\n+  printf(\"Prepare: find tested thread\\n\");\n+\n+  \/* get all live threads *\/\n+  err = jvmti->GetAllThreads(&threads_count, &threads);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return NSK_FALSE;\n+  }\n+\n+  if (!(threads_count > 0 && threads != NULL)) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* find tested thread *\/\n+  for (i = 0; i < threads_count; i++) {\n+    if (threads[i] == NULL) {\n+      return NSK_FALSE;\n+    }\n+\n+    \/* get thread information *\/\n+    err = jvmti->GetThreadInfo(threads[i], &info);\n+    if (err != JVMTI_ERROR_NONE) {\n+      return NSK_FALSE;\n+    }\n+\n+    NSK_DISPLAY3(\"    thread #%d (%s): %p\\n\", i, info.name, threads[i]);\n+\n+    \/* find by name *\/\n+    if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+      thread = threads[i];\n+    }\n+  }\n+\n+  \/* deallocate threads list *\/\n+  err = jvmti->Deallocate((unsigned char *) threads);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return NSK_FALSE;\n+  }\n+\n+  if (thread == NULL) {\n+    NSK_COMPLAIN0(\"Debuggee thread not found\");\n+    return NSK_FALSE;\n+  }\n+\n+  \/* make thread accessable for a long time *\/\n+  thread = jni->NewGlobalRef(thread);\n+  if (thread == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get tested thread class *\/\n+  klass = jni->GetObjectClass(thread);\n+  if (klass == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get tested thread field 'waitingMonitor' *\/\n+  field = jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\");\n+  if (field == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get 'endingMonitor' object *\/\n+  object = jni->GetObjectField(thread, field);\n+  if (object == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* make object accessable for a long time *\/\n+  object = jni->NewGlobalRef(object);\n+  if (object == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* enable MonitorWait event *\/\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAIT, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Prepare: 11\\n\");\n+    return NSK_FALSE;\n+  }\n+  return NSK_TRUE;\n+}\n+\n+static int clean() {\n+  jvmtiError err;\n+  \/* disable MonitorWait event *\/\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_MONITOR_WAIT,\n+                                        NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    nsk_jvmti_setFailStatus();\n+  }\n+  return NSK_TRUE;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent algorithm\n+ *\/\n+static void JNICALL\n+agentProc(jvmtiEnv *jvmti, JNIEnv *agentJNI, void *arg) {\n+  jni = agentJNI;\n+\n+\/* wait for initial sync *\/\n+  if (!nsk_jvmti_waitForSync(timeout))\n+    return;\n+\n+  if (!prepare()) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+  \/* clear events count *\/\n+  eventsCount = 0;\n+\n+  \/* resume debugee to catch MonitorWait event *\/\n+  if (!((nsk_jvmti_resumeSync() == NSK_TRUE) && (nsk_jvmti_waitForSync(timeout) ==NSK_TRUE))) {\n+    return;\n+  }\n+\n+  NSK_DISPLAY1(\"Number of MonitorWait events: %d\\n\", eventsCount);\n+\n+  if (eventsCount == 0) {\n+    NSK_COMPLAIN0(\"No any MonitorWait event\\n\");\n+    nsk_jvmti_setFailStatus();\n+  }\n+\n+  if (!clean()) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+\/* resume debugee after last sync *\/\n+  if (!nsk_jvmti_resumeSync())\n+    return;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent library initialization\n+ *\/\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_monitorwait001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_monitorwait001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_monitorwait001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  timeout = 60000; \/\/TODO fix\n+  NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int) timeout);\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = init_agent_data(jvmti, &agent_data);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_generate_monitor_events) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.MonitorWait = &MonitorWait;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  \/* register agent proc and arg *\/\n+  nsk_jvmti_setAgentProc(agentProc, NULL);\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWait\/monitorwait001\/libmonitorwait.cpp","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MonitorWait\/monitorwait001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function\n+ *         MonitorWait(jni_env, thread, object, timeout).\n+ *     The test checks if the thread, object, and timeout parameters of\n+ *     the function contain expected values for callback when a thread is\n+ *     about to wait on an object.\n+ * COMMENTS\n+ *     The test updated to match new JVMTI spec 0.2.90:\n+ *     - change signature of agentProc function\n+ *       and save JNIEnv pointer now passed as argument.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:monitorwait monitorwait001\n+ *\/\n+\n+\n+\n+public class monitorwait001 extends DebugeeClass {\n+\n+    \/\/ load native library if required\n+    static {\n+        loadLibrary(\"monitorwait\");\n+    }\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        int result = new monitorwait001().runIt();\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+\n+    int status = DebugeeClass.TEST_PASSED;\n+    static long timeout = 0;\n+\n+    \/\/ tested thread\n+    monitorwait001Thread thread = null;\n+\n+    \/\/ run debuggee\n+    public int runIt() {\n+        timeout = 60000; \/\/TODO fix timeout milliseconds\n+        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n+\n+        thread = new monitorwait001Thread(\"Debuggee Thread\");\n+\n+        \/\/ run thread\n+        try {\n+            \/\/ start thread\n+            synchronized (thread.startingMonitor) {\n+                thread.start();\n+                thread.startingMonitor.wait(timeout);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        Thread.yield();\n+        System.out.println(\"Thread started\");\n+\n+        synchronized (thread.waitingMonitor) {\n+            thread.waitingMonitor.notify();\n+        }\n+\n+        \/\/ wait for thread finish\n+        try {\n+            thread.join(timeout);\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        System.out.println(\"Sync: thread finished\");\n+        status = checkStatus(status);\n+\n+        return status;\n+    }\n+}\n+\n+\/* =================================================================== *\/\n+\n+class monitorwait001Thread extends Thread {\n+    public Object startingMonitor = new Object();\n+    public Object waitingMonitor = new Object();\n+\n+    public monitorwait001Thread(String name) {\n+        super(name);\n+    }\n+\n+    public void run() {\n+        synchronized (waitingMonitor) {\n+\n+            monitorwait001.checkStatus(DebugeeClass.TEST_PASSED);\n+\n+            \/\/ notify about starting\n+            synchronized (startingMonitor) {\n+                startingMonitor.notify();\n+            }\n+\n+            \/\/ wait until main thread notify\n+            try {\n+                waitingMonitor.wait(monitorwait001.timeout);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWait\/monitorwait001\/monitorwait001.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+#include \"jvmti_thread.h\"\n+\n+\n+extern \"C\" {\n+\n+\/* ========================================================================== *\/\n+\n+\/* scaffold objects *\/\n+static JNIEnv *jni = NULL;\n+static jvmtiEnv *jvmti = NULL;\n+static jlong timeout = 0;\n+\n+\/* test objects *\/\n+static jthread thread = NULL;\n+static jobject object = NULL;\n+static volatile int eventsCount = 0;\n+\n+\/* ========================================================================== *\/\n+\n+void JNICALL\n+MonitorWaited(jvmtiEnv *jvmti, JNIEnv *jni,\n+              jthread thr, jobject obj, jboolean timed_out) {\n+\n+  NSK_DISPLAY3(\"MonitorWaited event:\\n\\tthread: %p, object: %p, timed_out: %s\\n\",\n+               thr, obj, (timed_out == JNI_TRUE) ? \"true\" : \"false\");\n+\n+  if (thread == NULL) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+\n+\/* check if event is for tested thread and for tested object *\/\n+  if (jni->IsSameObject(thread, thr) &&\n+      jni->IsSameObject(object, obj)) {\n+    eventsCount++;\n+    if (timed_out == JNI_TRUE) {\n+      NSK_COMPLAIN0(\"Unexpected timed_out value: true\\n\");\n+      nsk_jvmti_setFailStatus();\n+    }\n+  }\n+}\n+\n+\/* ========================================================================== *\/\n+\n+static int prepare() {\n+  const char *THREAD_NAME = \"Debuggee Thread\";\n+  jclass klass = NULL;\n+  jfieldID field = NULL;\n+  jvmtiThreadInfo info;\n+  jthread *threads = NULL;\n+  jint threads_count = 0;\n+  jvmtiError err;\n+  int i;\n+\n+  NSK_DISPLAY0(\"Prepare: find tested thread\\n\");\n+\n+  \/* get all live threads *\/\n+  err = jvmti->GetAllThreads(&threads_count, &threads);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return NSK_FALSE;\n+  }\n+\n+  if (!(threads_count > 0 && threads != NULL)) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* find tested thread *\/\n+  for (i = 0; i < threads_count; i++) {\n+    if (threads[i] == NULL)\n+      return NSK_FALSE;\n+\n+    \/* get thread information *\/\n+    err = jvmti->GetThreadInfo(threads[i], &info);\n+    if (err != JVMTI_ERROR_NONE) {\n+      return NSK_FALSE;\n+    }\n+\n+    NSK_DISPLAY3(\"    thread #%d (%s): %p\\n\", i, info.name, threads[i]);\n+\n+    \/* find by name *\/\n+    if (info.name != NULL && (strcmp(info.name, THREAD_NAME) == 0)) {\n+      thread = threads[i];\n+    }\n+  }\n+\n+  \/* deallocate threads list *\/\n+  err = jvmti->Deallocate((unsigned char *) threads);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return NSK_FALSE;\n+  }\n+\n+  if (thread == NULL) {\n+    NSK_COMPLAIN0(\"Debuggee thread not found\");\n+    return NSK_FALSE;\n+  }\n+\n+  \/* make thread accessable for a long time *\/\n+  thread = jni->NewGlobalRef(thread);\n+  if (thread == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get tested thread class *\/\n+  klass = jni->GetObjectClass(thread);\n+  if (klass == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get tested thread field 'waitingMonitor' *\/\n+  field = jni->GetFieldID(klass, \"waitingMonitor\", \"Ljava\/lang\/Object;\");\n+  if (field == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* get 'endingMonitor' object *\/\n+  object = jni->GetObjectField(thread, field);\n+  if (object == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* make object accessable for a long time *\/\n+  object = jni->NewGlobalRef(object);\n+  if (object == NULL) {\n+    return NSK_FALSE;\n+  }\n+\n+  \/* enable MonitorWait event *\/\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_MONITOR_WAITED, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Prepare: 11\\n\");\n+    return NSK_FALSE;\n+  }\n+  return NSK_TRUE;\n+}\n+\n+static int clean() {\n+  jvmtiError err;\n+  \/* disable MonitorWaited event *\/\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_MONITOR_WAITED,\n+                                        NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    nsk_jvmti_setFailStatus();\n+  }\n+  return NSK_TRUE;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent algorithm\n+ *\/\n+static void JNICALL\n+agentProc(jvmtiEnv *jvmti, JNIEnv *agentJNI, void *arg) {\n+  jni = agentJNI;\n+\n+\/* wait for initial sync *\/\n+  if (!nsk_jvmti_waitForSync(timeout))\n+    return;\n+\n+  if (!prepare()) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+  \/* clear events count *\/\n+  eventsCount = 0;\n+\n+  \/* resume debugee to catch MonitorWaited event *\/\n+  if (!((nsk_jvmti_resumeSync() == NSK_TRUE) && (nsk_jvmti_waitForSync(timeout) == NSK_TRUE))) {\n+    return;\n+  }\n+\n+  NSK_DISPLAY1(\"Number of MonitorWaited events: %d\\n\", eventsCount);\n+\n+  if (eventsCount == 0) {\n+    NSK_COMPLAIN0(\"No any MonitorWaited event\\n\");\n+    nsk_jvmti_setFailStatus();\n+  }\n+\n+  if (!clean()) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+\/* resume debugee after last sync *\/\n+  if (!nsk_jvmti_resumeSync())\n+    return;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent library initialization\n+ *\/\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_monitorwaited001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_monitorwaited001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_monitorwaited001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  timeout = 60000; \/\/TODO fix\n+  NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int) timeout);\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = init_agent_data(jvmti, &agent_data);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetPotentialCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetPotentialCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_generate_monitor_events) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.MonitorWaited = &MonitorWaited;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  \/* register agent proc and arg *\/\n+  nsk_jvmti_setAgentProc(agentProc, NULL);\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWaited\/monitorwaited001\/libmonitorwaited.cpp","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+\n+import java.io.PrintStream;\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/MonitorWaited\/monitorwaited001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function\n+ *         MonitorWaited(jni_env, thread, object, timed_out).\n+ *     The test checks if the thread, object, and timed_out parameters of\n+ *     the function contain expected values for callback when a thread finishes\n+ *     waiting on an object.\n+ * COMMENTS\n+ *     The test updated to match new JVMTI spec 0.2.90:\n+ *     - change signature of agentProc function\n+ *       and save JNIEnv pointer now passed as argument.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:monitorwaited monitorwaited001\n+ *\/\n+\n+\n+\n+public class monitorwaited001 extends DebugeeClass {\n+\n+    \/\/ load native library if required\n+    static {\n+        loadLibrary(\"monitorwaited\");\n+    }\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        int result = new monitorwaited001().runIt();\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+\n+    int status = DebugeeClass.TEST_PASSED;\n+    static long timeout = 0;\n+\n+    \/\/ tested thread\n+    monitorwaited001Thread thread = null;\n+\n+    \/\/ run debuggee\n+    public int runIt() {\n+        timeout =   60000; \/\/ milliseconds\n+        System.out.println(\"Timeout = \" + timeout + \" msc.\");\n+\n+        thread = new monitorwaited001Thread(\"Debuggee Thread\");\n+\n+        \/\/ run thread\n+        try {\n+            \/\/ start thread\n+            synchronized (thread.startingMonitor) {\n+                thread.start();\n+                thread.startingMonitor.wait(timeout);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        Thread.yield();\n+        System.out.println(\"Thread started\");\n+\n+        synchronized (thread.waitingMonitor) {\n+            thread.waitingMonitor.notify();\n+        }\n+\n+        \/\/ wait for thread finish\n+        try {\n+            thread.join(timeout);\n+        } catch (InterruptedException e) {\n+            throw new Failure(e);\n+        }\n+\n+        System.out.println(\"Sync: thread finished\");\n+        status = checkStatus(status);\n+\n+        return status;\n+    }\n+}\n+\n+\/* =================================================================== *\/\n+\n+class monitorwaited001Thread extends Thread {\n+    public Object startingMonitor = new Object();\n+    public Object waitingMonitor = new Object();\n+\n+    public monitorwaited001Thread(String name) {\n+        super(name);\n+    }\n+\n+    public void run() {\n+        synchronized (waitingMonitor) {\n+\n+            monitorwaited001.checkStatus(DebugeeClass.TEST_PASSED);\n+\n+            \/\/ notify about starting\n+            synchronized (startingMonitor) {\n+                startingMonitor.notify();\n+            }\n+\n+            \/\/ wait until main thread notify\n+            try {\n+                waitingMonitor.wait(monitorwaited001.timeout);\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MonitorWaited\/monitorwaited001\/monitorwaited001.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -0,0 +1,274 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define STATUS_FAILED 2\n+#define PASSED 0\n+\n+\/* tested methods *\/\n+#define METH_NUM 2\n+static const char *METHODS[][2] = {\n+    { \"nativeMethod\", \"(Z)V\" },\n+    { \"anotherNativeMethod\", \"()V\" },\n+};\n+\n+\/* event counters for the tested methods and expected numbers\n+   of the events *\/\n+static volatile int bindEv[][2] = {\n+    { 0, 1 },\n+    { 0, 1 }\n+};\n+\n+static const char *CLASS_SIG =\n+    \"Lnativemethbind001$TestedClass;\";\n+\n+static volatile jint result = PASSED;\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+static jrawMonitorID countLock;\n+\n+static void lock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorEnter(countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni_env->FatalError(\"failed to enter a raw monitor\\n\");\n+  }\n+}\n+\n+static void unlock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorExit(countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni_env->FatalError(\"failed to exit a raw monitor\\n\");\n+  }\n+}\n+\n+\/** callback functions **\/\n+void JNICALL\n+NativeMethodBind(jvmtiEnv *jvmti, JNIEnv* jni_env, jthread thread,\n+                 jmethodID method, void *addr, void **new_addr) {\n+  jvmtiPhase phase;\n+  char *methNam, *methSig;\n+  int i;\n+  jvmtiError err;\n+\n+  lock(jvmti, jni_env);\n+\n+  printf(\">>>> NativeMethodBind event received\\n\");\n+\n+  err = jvmti->GetPhase(&phase);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\">>>> Error getting phase\\n\");\n+    result = STATUS_FAILED;\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+  if (phase != JVMTI_PHASE_START && phase != JVMTI_PHASE_LIVE) {\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    printf(\"TEST FAILED: unable to get method name during NativeMethodBind callback\\n\\n\");\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+  printf(\"method: \\\"%s %s\\\"\\n\", methNam, methSig);\n+\n+  for (i=0; i<METH_NUM; i++) {\n+    if ((strcmp(methNam,METHODS[i][0]) == 0) &&\n+        (strcmp(methSig,METHODS[i][1]) == 0)) {\n+      bindEv[i][0]++;\n+\n+      printf(\n+          \"CHECK PASSED: NativeMethodBind event received for the method:\\n\"\n+          \"\\t\\\"%s\\\" as expected\\n\",\n+          methNam);\n+      break;\n+    }\n+  }\n+\n+  err = jvmti->Deallocate((unsigned char*) methNam);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    printf(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+  }\n+  err =  jvmti->Deallocate((unsigned char*) methSig);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    printf(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n+  }\n+\n+  printf(\"<<<<\\n\\n\");\n+\n+  unlock(jvmti, jni_env);\n+}\n+\/************************\/\n+\n+\/* dummy method used only to provoke NativeMethodBind event *\/\n+static void JNICALL\n+anotherNativeMethod(JNIEnv *env, jobject obj) {\n+  NSK_DISPLAY0(\"inside the anotherNativeMethod()\\n\");\n+}\n+\n+\/* dummy method used only to provoke NativeMethodBind event *\/\n+JNIEXPORT void JNICALL\n+Java_nativemethbind001_nativeMethod(\n+    JNIEnv *env, jobject obj, jboolean registerNative) {\n+  jclass testedCls = NULL;\n+  JNINativeMethod meth;\n+\n+  NSK_DISPLAY0(\"Inside the nativeMethod()\\n\");\n+\n+  if (registerNative == JNI_TRUE) {\n+    NSK_DISPLAY1(\"Finding class \\\"%s\\\" ...\\n\", CLASS_SIG);\n+    testedCls = env->FindClass(CLASS_SIG);\n+    if (testedCls == NULL) {\n+      result = STATUS_FAILED;\n+      NSK_COMPLAIN1(\"TEST FAILURE: unable to find class \\\"%s\\\"\\n\\n\",\n+                    CLASS_SIG);\n+      return;\n+    }\n+\n+    meth.name = (char *) METHODS[1][0];\n+    meth.signature = (char *) METHODS[1][1];\n+    meth.fnPtr = (void *) &anotherNativeMethod;\n+\n+    NSK_DISPLAY3(\"Calling RegisterNatives() with \\\"%s %s\\\"\\n\"\n+                 \"\\tfor class \\\"%s\\\" ...\\n\",\n+                 METHODS[1][0], METHODS[1][1], CLASS_SIG);\n+    if (env->RegisterNatives(testedCls, &meth, 1) != 0) {\n+      result = STATUS_FAILED;\n+      NSK_COMPLAIN3(\"TEST FAILURE: unable to RegisterNatives() \\\"%s %s\\\" for class \\\"%s\\\"\\n\\n\",\n+                    METHODS[1][0], METHODS[1][1], CLASS_SIG);\n+    }\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_nativemethbind001_check(\n+    JNIEnv *env, jobject obj) {\n+  int i;\n+\n+  for (i=0; i<METH_NUM; i++)\n+    if (bindEv[i][0] == bindEv[i][1]) {\n+      NSK_DISPLAY2(\"CHECK PASSED: %d NativeMethodBind event(s) for the method \\\"%s\\\" as expected\\n\",\n+                   bindEv[i][0], METHODS[i][0]);\n+    }\n+    else {\n+      result = STATUS_FAILED;\n+      NSK_COMPLAIN3(\n+          \"TEST FAILED: wrong number of NativeMethodBind events for the method \\\"%s\\\":\\n\"\n+          \"got: %d\\texpected: %d\\n\\n\",\n+          METHODS[i][0], bindEv[i][0], bindEv[i][1]);\n+    }\n+\n+  return result;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_nativemethbind001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+  jint res;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  \/* create a raw monitor *\/\n+  err = jvmti->CreateRawMonitor(\"_counter_lock\", &countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  \/* add capability to generate compiled method events *\/\n+  memset(&caps, 0, sizeof(jvmtiCapabilities));\n+  caps.can_generate_native_method_bind_events = 1;\n+\n+  \/\/ TODO Fix!!\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_generate_native_method_bind_events) {\n+    printf(\"Warning: generation of native method bind events is not implemented\\n\");\n+  }\n+\n+  \/* set event callback *\/\n+  printf(\"setting event callbacks ...\\n\");\n+  (void) memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.NativeMethodBind = &NativeMethodBind;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE)\n+    return JNI_ERR;\n+\n+  printf(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                                        JVMTI_EVENT_NATIVE_METHOD_BIND,\n+                                                        NULL);\n+  if (err != JVMTI_ERROR_NONE){\n+      return JNI_ERR;\n+  }\n+  printf(\"enabling the events done\\n\\n\");\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind001\/libnativemethbind01.cpp","additions":274,"deletions":0,"binary":false,"changes":274,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/NativeMethodBind\/nativemethbind001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test exercises the JVMTI event NativeMethodBind.\n+ *     It verifies that the event will be properly sent:\n+ *         - for the native method called for the first time\n+ *         - when the JNI RegisterNatives() is called.\n+ *     The test works as follows. The java part invokes the native method\n+ *     'nativeMethod()' twice. At the first time that method registers\n+ *     another native method 'anotherNativeMethod()' for the dummy class\n+ *     'TestedClass'. Registration is made through the JNI RegisterNatives()\n+ *     call. Being invoked at the second time, the nativeMethod() just returns.\n+ *     In accordance with the spec, it is expected that the NativeMethodBind\n+ *     will be generated only one time for the nativeMethod(), and only one\n+ *     time for the anotherNativeMethod().\n+ * COMMENTS\n+ *     The test has been fixed due to the bug 4967116.\n+ *     Fixed the 4995867 bug.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:nativemethbind01 nativemethbind001\n+ *\/\n+\n+\n+\/**\n+ * This test exercises the JVMTI event <code>NativeMethodBind<\/code>.\n+ * <br>It verifies that the event will be properly sent:\n+ * <li>for the native method called for the first time\n+ * <li>when the JNI RegisterNatives() is called.<p>\n+ * The test works as follows. The java part invokes the native method\n+ * <code>nativeMethod()<\/code> twice. At the first time that method\n+ * registers another native method <code>anotherNativeMethod()<\/code> for\n+ * the dummy class <code>TestedClass<\/code>. Registration is made through\n+ * the JNI RegisterNatives() call. Being invoked at the second time, the\n+ * nativeMethod() just returns.<br>\n+ * In accordance with the spec, it is expected that the NativeMethodBind\n+ * will be generated only one time for the nativeMethod(), and only one\n+ * time for the anotherNativeMethod().\n+ *\/\n+public class nativemethbind001 {\n+    static {\n+        try {\n+            System.loadLibrary(\"nativemethbind01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load \\\"nativemethbind001\\\" library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native void nativeMethod(boolean registerNative);\n+\n+    native int check();\n+\n+    public static void main(String[] argv) {\n+        new nativemethbind001().runThis();\n+    }\n+\n+    private void runThis() {\n+        System.out.println(\"\\nCalling native methods ...\\n\");\n+\n+        \/\/ dummy method used to provoke the NativeMethodBind event\n+        nativeMethod(true);\n+\n+        \/\/ call one more time to provoke the wrong NativeMethodBind\n+        \/\/ event\n+        nativeMethod(false);\n+\n+        int result = check();\n+        if (result != 0) {\n+            throw new RuntimeException(\"runThis() returned \" + result);\n+        }\n+    }\n+\n+   \/**\n+    * Dummy class used only to register native method\n+    * <code>anotherNativeMethod<\/code> with it\n+    *\/\n+    class TestedClass {\n+        native void anotherNativeMethod();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind001\/nativemethbind001.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define STATUS_FAILED 2\n+#define PASSED 0\n+\n+\/* counter for the wrong NativeMethodBind events\n+   received during non-start or non-live phase *\/\n+static volatile int wrongBindEv = 0;\n+\n+static volatile jint result = PASSED;\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+static jrawMonitorID countLock;\n+\n+static void lock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorEnter(countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni_env->FatalError(\"failed to enter a raw monitor\\n\");\n+  }\n+}\n+\n+static void unlock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorExit(countLock);\n+    if (err != JVMTI_ERROR_NONE) {\n+      jni_env->FatalError(\"failed to exit a raw monitor\\n\");\n+    }\n+}\n+\n+\/** callback functions **\/\n+void JNICALL\n+NativeMethodBind(jvmtiEnv *jvmti, JNIEnv* jni_env, jthread thread,\n+jmethodID method, void *addr, void **new_addr) {\n+  jvmtiPhase phase;\n+  jvmtiError err;\n+  char *methNam = NULL, *methSig = NULL;\n+\n+  lock(jvmti, jni_env);\n+  err = jvmti->GetPhase(&phase);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\">>>> Error getting phase\\n\");\n+    result = STATUS_FAILED;\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+  if (phase != JVMTI_PHASE_LIVE && phase != JVMTI_PHASE_START) {\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    printf(\"TEST FAILED: unable to get method name during NativeMethodBind callback\\n\\n\");\n+    unlock(jvmti, jni_env);\n+    return;\n+  } else {\n+    NSK_DISPLAY2(\"NativeMethodBind received for \\\"%s %s\\\"\\n\",\n+                 methNam, methSig);\n+  }\n+\n+  if (methNam != NULL) {\n+    err = jvmti->Deallocate((unsigned char *) methNam);\n+    if (err != JVMTI_ERROR_NONE) {\n+      result = STATUS_FAILED;\n+      printf(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+    }\n+  }\n+\n+  if (methSig != NULL) {\n+    err = jvmti->Deallocate((unsigned char *) methSig);\n+    if (err != JVMTI_ERROR_NONE) {\n+      result = STATUS_FAILED;\n+      printf(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n+    }\n+  }\n+\n+  unlock(jvmti, jni_env);\n+}\n+\n+void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv *env) {\n+NSK_DISPLAY0(\"VMDeath event received\\n\");\n+\n+if (wrongBindEv != 0) {\n+NSK_COMPLAIN1(\n+\"TEST FAILED: there are %d NativeMethodBind events\\n\"\n+\"sent during non-start or non-live phase of the VM execution\\n\",\n+wrongBindEv);\n+}\n+\n+if (result == STATUS_FAILED)\n+exit(95 + STATUS_FAILED);\n+}\n+\/************************\/\n+\n+\/* dummy method used only to provoke NativeMethodBind events *\/\n+JNIEXPORT jint JNICALL\n+Java_nativemethbind002_nativeMethod(\n+    JNIEnv *env, jobject obj) {\n+  NSK_DISPLAY0(\"inside the nativeMethod()\\n\\n\");\n+\n+  return PASSED;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_nativemethbind002(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+  jint res;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+\n+  \/* create a raw monitor *\/\n+  err = jvmti->CreateRawMonitor(\"_counter_lock\", &countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  \/* add capability to generate compiled method events *\/\n+  memset(&caps, 0, sizeof(jvmtiCapabilities));\n+  caps.can_generate_native_method_bind_events = 1;\n+  \/\/ TODO Fix!!\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  if (!caps.can_generate_native_method_bind_events)\n+    NSK_DISPLAY0(\"Warning: generation of native method bind events is not implemented\\n\");\n+\n+  \/* set event callback *\/\n+  NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n+  (void) memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.NativeMethodBind = &NativeMethodBind;\n+  callbacks.VMDeath = &VMDeath;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE)\n+    return JNI_ERR;\n+\n+  NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                                        JVMTI_EVENT_NATIVE_METHOD_BIND,\n+                                                        NULL);\n+  if (err != JVMTI_ERROR_NONE){\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                                        JVMTI_EVENT_VM_DEATH,\n+                                                        NULL);\n+  if (err != JVMTI_ERROR_NONE){\n+    return JNI_ERR;\n+  }\n+  NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind002\/libnativemethbind02.cpp","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/NativeMethodBind\/nativemethbind002.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test exercises the JVMTI event NativeMethodBind.\n+ *     It verifies that the events will be sent only during the start\n+ *     and live phase of VM execution.\n+ *     The test works as follows. The NativeMethodBind event is enabled\n+ *     on 'OnLoad' phase. Then the VM phase is checked from the\n+ *     NativeMethodBind callback to be start or live one. The java part\n+ *     calls the dummy native method 'nativeMethod' on exit in order to\n+ *     provoke the NativeMethodBind event near the dead phase.\n+ * COMMENTS\n+ *     Fixed the 4995867 bug.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:nativemethbind02 nativemethbind002\n+ *\/\n+\n+\/**\n+ * This test exercises the JVMTI event <code>NativeMethodBind<\/code>.\n+ * <br>It verifies that the events will be sent only during the start\n+ * and live phase of VM execution.<br>\n+ * The test works as follows. The NativeMethodBind event is enabled on\n+ * <code>OnLoad<\/code> phase. Then the VM phase is checked from the\n+ * NativeMethodBind callback to be start or live one. The java part calls\n+ * the dummy native method <code>nativeMethod<\/code> on exit in order to\n+ * provoke the NativeMethodBind event near the dead phase.\n+ *\/\n+public class nativemethbind002 {\n+    static {\n+        try {\n+            System.loadLibrary(\"nativemethbind02\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load \\\"nativemethbind002\\\" library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native int nativeMethod();\n+\n+    public static void main(String[] argv) {\n+        new nativemethbind002().runThis();\n+    }\n+\n+    private void runThis() {\n+\n+        System.out.println(\"\\nCalling a native method ...\\n\");\n+\n+        \/\/ dummy methods used to provoke the NativeMethodBind event\n+        \/\/ near the dead phase\n+        int result = nativeMethod();\n+        if (result != 0) {\n+            throw new RuntimeException(\"runThis() returned \" + result);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind002\/nativemethbind002.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define STATUS_FAILED 2\n+#define PASSED 0\n+\n+\/* tested method *\/\n+static const char *METHODS[] = {\n+    \"nativeMethod\", \"()V\"\n+};\n+\n+\/* event counter for the tested method and expected number\n+   of the events *\/\n+static volatile int bindEv[] = {\n+    0, 1\n+};\n+\n+static const char *CLASS_SIG =\n+    \"Lnativemethbind003$TestedClass;\";\n+\n+static volatile jint result = PASSED;\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+static jrawMonitorID countLock;\n+\n+static void lock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorEnter(countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni_env->FatalError(\"failed to enter a raw monitor\\n\");\n+  }\n+}\n+\n+static void unlock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorExit(countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni_env->FatalError(\"failed to exit a raw monitor\\n\");\n+  }\n+}\n+\n+\/** callback functions **\/\n+void JNICALL\n+NativeMethodBind(jvmtiEnv *jvmti, JNIEnv *jni_env, jthread thread,\n+                 jmethodID method, void *addr, void **new_addr) {\n+  jvmtiPhase phase;\n+  jvmtiError err;\n+  char *methNam, *methSig;\n+\n+  lock(jvmti, jni_env);\n+\n+  NSK_DISPLAY0(\">>>> NativeMethodBind event received\\n\");\n+\n+  err = jvmti->GetPhase(&phase);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\">>>> Error getting phase\\n\");\n+    result = STATUS_FAILED;\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+  if (phase != JVMTI_PHASE_LIVE && phase != JVMTI_PHASE_START) {\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during NativeMethodBind callback\\n\\n\");\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+  if ((strcmp(methNam, METHODS[0]) == 0) &&\n+      (strcmp(methSig, METHODS[1]) == 0)) {\n+    bindEv[0]++;\n+\n+    NSK_DISPLAY2(\"\\tmethod: \\\"%s %s\\\"\\n\", methNam, methSig);\n+  }\n+\n+  if (methNam != NULL) {\n+    err = jvmti->Deallocate((unsigned char *) methNam);\n+    if (err != JVMTI_ERROR_NONE) {\n+      result = STATUS_FAILED;\n+      printf(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+    }\n+  }\n+\n+  if (methSig != NULL) {\n+    err = jvmti->Deallocate((unsigned char *) methSig);\n+    if (err != JVMTI_ERROR_NONE) {\n+      result = STATUS_FAILED;\n+      printf(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n+    }\n+  }\n+\n+  NSK_DISPLAY0(\"<<<<\\n\\n\");\n+\n+  unlock(jvmti, jni_env);\n+}\n+\n+void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv *env) {\n+  NSK_DISPLAY0(\"VMDeath event received\\n\");\n+\n+  if (bindEv[0] != bindEv[1]) {\n+    result = STATUS_FAILED;\n+    printf(\n+        \"TEST FAILED: wrong NativeMethodBind events\\n\"\n+        \"\\tfor tested method \\\"%s %s\\\" bound with \\\"%s\\\":\\n\"\n+        \"\\tgot: %d\\texpected: %d\\n\\n\",\n+        METHODS[0], METHODS[1], CLASS_SIG, bindEv[0], bindEv[1]);\n+  } else {\n+    NSK_DISPLAY4(\n+        \"CHECK PASSED: %d NativeMethodBind event(s)\\n\"\n+        \"\\tfor tested method \\\"%s %s\\\" bound with \\\"%s\\\"\\n\"\n+        \"\\tas expected\\n\",\n+        bindEv[0], METHODS[0], METHODS[1], CLASS_SIG);\n+  }\n+\n+  if (result == STATUS_FAILED)\n+    exit(95 + STATUS_FAILED);\n+}\n+\/************************\/\n+\n+\/* dummy method used only to provoke NativeMethodBind event *\/\n+static void JNICALL\n+nativeMethod(JNIEnv *env, jobject obj) {\n+  NSK_DISPLAY0(\"inside the nativeMethod()\\n\");\n+}\n+\n+\/* dummy method used only to provoke NativeMethodBind event *\/\n+JNIEXPORT void JNICALL\n+Java_nativemethbind003_registerNative(\n+    JNIEnv *env, jobject obj) {\n+  jclass testedCls = NULL;\n+  JNINativeMethod meth;\n+\n+  NSK_DISPLAY1(\"Inside the registerNative()\\n\"\n+               \"Finding class \\\"%s\\\" ...\\n\",\n+               CLASS_SIG);\n+  testedCls = env->FindClass(CLASS_SIG);\n+  if (testedCls == NULL) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN1(\"TEST FAILURE: unable to find class \\\"%s\\\"\\n\\n\",\n+                  CLASS_SIG);\n+    return;\n+  }\n+\n+  meth.name = (char *) METHODS[0];\n+  meth.signature = (char *) METHODS[1];\n+  meth.fnPtr = (void *) nativeMethod;\n+\n+  NSK_DISPLAY3(\n+      \"Calling RegisterNatives() with \\\"%s %s\\\"\\n\"\n+      \"\\tfor class \\\"%s\\\" ...\\n\",\n+      METHODS[0], METHODS[1], CLASS_SIG);\n+  if (env->RegisterNatives(testedCls, &meth, 1) != 0) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN3(\"TEST FAILURE: unable to RegisterNatives() \\\"%s %s\\\" for class \\\"%s\\\"\\n\\n\",\n+                  METHODS[0], METHODS[1], CLASS_SIG);\n+  }\n+\n+  NSK_DISPLAY1(\"Calling UnregisterNatives() for class \\\"%s\\\" ...\\n\",\n+               CLASS_SIG);\n+  if (env->UnregisterNatives(testedCls) != 0) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN3(\"TEST FAILURE: unable to UnregisterNatives() \\\"%c %c\\\" for class \\\"%s\\\"\\n\\n\",\n+                  METHODS[1][0], METHODS[1][1], CLASS_SIG);\n+  }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind003(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind003(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_nativemethbind003(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+  jint res;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+\n+  \/* create a raw monitor *\/\n+  err = jvmti->CreateRawMonitor(\"_counter_lock\", &countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+\n+  \/* add capability to generate compiled method events *\/\n+  memset(&caps, 0, sizeof(jvmtiCapabilities));\n+  caps.can_generate_native_method_bind_events = 1;\n+  \/\/ TODO Fix!!\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_generate_native_method_bind_events)\n+    NSK_DISPLAY0(\"Warning: generation of native method bind events is not implemented\\n\");\n+\n+  \/* set event callback *\/\n+  NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n+  (void) memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.NativeMethodBind = &NativeMethodBind;\n+  callbacks.VMDeath = &VMDeath;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE)\n+    return JNI_ERR;\n+\n+  NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_NATIVE_METHOD_BIND,\n+                                        NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_VM_DEATH,\n+                                        NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind003\/libnativemethbind03.cpp","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+\n+import java.io.*;\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/NativeMethodBind\/nativemethbind003.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test exercises the JVMTI event NativeMethodBind.\n+ *     It verifies that the event will not be sent when the native\n+ *     method is unbound.\n+ *     The test works as follows. The java part invokes the native method\n+ *     'registerNative()' which registers native method 'nativeMethod()'\n+ *     for the dummy class 'TestedClass' and then unregisters it.\n+ *     Registration\/unregistration is made through the JNI\n+ *     RegisterNatives()\/UnregisterNatives() calls.\n+ *     In accordance with the spec, it is expected that the NativeMethodBind\n+ *     will be generated only one time for the nativeMethod().\n+ * COMMENTS\n+ *     The test has been fixed due to the bug 4967116.\n+ *     Fixed the 4995867 bug.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:nativemethbind03 nativemethbind003\n+ *\/\n+\n+\/**\n+ * This test exercises the JVMTI event <code>NativeMethodBind<\/code>.\n+ * <br>It verifies that the event will not be sent when the native\n+ * method is unbound.<p>\n+ * The test works as follows. The java part invokes the native method\n+ * <code>registerNative()<\/code> which registers native method\n+ * <code>nativeMethod()<\/code> for the dummy class <code>TestedClass<\/code>\n+ * and then unregisters it. Registration\/unregistration is made through\n+ * the JNI RegisterNatives()\/UnregisterNatives() calls.<br>\n+ * In accordance with the spec, it is expected that the NativeMethodBind\n+ * will be generated only one time for the nativeMethod().\n+ *\/\n+public class nativemethbind003 {\n+    static {\n+        try {\n+            System.loadLibrary(\"nativemethbind03\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load \\\"nativemethbind003\\\" library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native void registerNative();\n+\n+    public static void main(String[] argv) {\n+        new nativemethbind003().runThis();\n+    }\n+\n+    private void runThis() {\n+        \/\/ register native method 'nativeMethod' with 'TestedClass'\n+        registerNative();\n+    }\n+\n+   \/**\n+    * Dummy class used only to register\/unregister native method\n+    * <code>nativeMethod<\/code> with it\n+    *\/\n+    class TestedClass {\n+        native void nativeMethod();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind003\/nativemethbind003.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define STATUS_FAILED 2\n+#define PASSED 0\n+\n+\/* tested method *\/\n+static const char *METHOD[] = {\n+    \"nativeMethod\", \"()V\"\n+};\n+\n+\/* counter for the original method calls *\/\n+static volatile int origCalls = 0;\n+\/* counter for the redirected method calls *\/\n+static volatile int redirCalls = 0;\n+\n+static volatile jint result = PASSED;\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+static jrawMonitorID countLock;\n+\n+\/* method to be redirected used to check the native method redirection\n+   through the NativeMethodBind event *\/\n+JNIEXPORT void JNICALL\n+Java_nativemethbind004_nativeMethod(\n+    JNIEnv *env, jobject obj) {\n+origCalls++;\n+NSK_DISPLAY1(\"inside the nativeMethod(): calls=%d\\n\",\n+origCalls);\n+}\n+\n+\/* redirected method used to check the native method redirection\n+   through the NativeMethodBind event *\/\n+static void JNICALL\n+redirNativeMethod(JNIEnv *env, jobject obj) {\n+redirCalls++;\n+NSK_DISPLAY1(\"inside the redirNativeMethod(): calls=%d\\n\",\n+redirCalls);\n+}\n+\n+static void lock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorEnter(countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni_env->FatalError(\"failed to enter a raw monitor\\n\");\n+  }\n+}\n+\n+static void unlock(jvmtiEnv *jvmti, JNIEnv *jni_env) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorExit(countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni_env->FatalError(\"failed to exit a raw monitor\\n\");\n+  }\n+}\n+\n+\/** callback functions **\/\n+void JNICALL\n+NativeMethodBind(jvmtiEnv *jvmti, JNIEnv* jni_env, jthread thread,\n+jmethodID method, void *addr, void **new_addr) {\n+jvmtiPhase phase;\n+  jvmtiError err;\n+\n+char *methNam, *methSig;\n+lock(jvmti, jni_env);\n+\n+NSK_DISPLAY0(\">>>> NativeMethodBind event received\\n\");\n+\n+  err = jvmti->GetPhase(&phase);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\">>>> Error getting phase\\n\");\n+    result = STATUS_FAILED;\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+if (phase != JVMTI_PHASE_LIVE && phase != JVMTI_PHASE_START) {\n+unlock(jvmti, jni_env);\n+return;\n+}\n+\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    printf(\"TEST FAILED: unable to get method name during NativeMethodBind callback\\n\\n\");\n+    unlock(jvmti, jni_env);\n+    return;\n+  }\n+\n+if ((strcmp(methNam,METHOD[0]) == 0) &&\n+(strcmp(methSig,METHOD[1]) == 0)) {\n+NSK_DISPLAY4(\"\\tmethod: \\\"%s %s\\\"\\nRedirecting the method address from 0x%p to 0x%p ...\\n\",\n+methNam, methSig, addr, (void*) redirNativeMethod);\n+\n+*new_addr = (void*) redirNativeMethod;\n+}\n+\n+  if (methNam != NULL) {\n+    err = jvmti->Deallocate((unsigned char *) methNam);\n+    if (err != JVMTI_ERROR_NONE) {\n+      result = STATUS_FAILED;\n+      printf(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+    }\n+  }\n+\n+  if (methSig != NULL) {\n+    err = jvmti->Deallocate((unsigned char *) methSig);\n+    if (err != JVMTI_ERROR_NONE) {\n+      result = STATUS_FAILED;\n+      printf(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n+    }\n+  }\n+NSK_DISPLAY0(\"<<<<\\n\\n\");\n+\n+unlock(jvmti, jni_env);\n+}\n+\/************************\/\n+\n+JNIEXPORT jint JNICALL\n+    Java_nativemethbind004_check(\n+    JNIEnv *env, jobject obj) {\n+\n+if (origCalls == 0) {\n+NSK_DISPLAY0(\n+\"CHECK PASSED: original nativeMethod() to be redirected\\n\"\n+\"\\thas not been invoked as expected\\n\");\n+} else {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN1(\n+\"TEST FAILED: nativeMethod() has not been redirected by the NativeMethodBind:\\n\"\n+\"\\t%d calls\\texpected: 0\\n\\n\",\n+origCalls);\n+}\n+\n+if (redirCalls == 1) {\n+NSK_DISPLAY1(\n+\"CHECK PASSED: nativeMethod() has been redirected by the NativeMethodBind:\\n\"\n+\"\\t%d calls of redirected method as expected\\n\",\n+redirCalls);\n+} else {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN1(\n+\"TEST FAILED: nativeMethod() has not been redirected by the NativeMethodBind:\\n\"\n+\"\\t%d calls of redirected method\\texpected: 1\\n\\n\",\n+redirCalls);\n+}\n+\n+return result;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_nativemethbind004(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_nativemethbind004(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_nativemethbind004(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+  jint res;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  \/* create a raw monitor *\/\n+  err = jvmti->CreateRawMonitor(\"_counter_lock\", &countLock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  \/* add capability to generate compiled method events *\/\n+  memset(&caps, 0, sizeof(jvmtiCapabilities));\n+  caps.can_generate_native_method_bind_events = 1;\n+\n+  \/\/ TODO Fix!!\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  if (!caps.can_generate_native_method_bind_events)\n+    NSK_DISPLAY0(\"Warning: generation of native method bind events is not implemented\\n\");\n+\n+  \/* set event callback *\/\n+  printf(\"setting event callbacks ...\\n\");\n+  (void) memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.NativeMethodBind = &NativeMethodBind;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE)\n+    return JNI_ERR;\n+\n+  printf(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_NATIVE_METHOD_BIND,\n+                                        NULL);\n+  if (err != JVMTI_ERROR_NONE){\n+    return JNI_ERR;\n+  }\n+  printf(\"enabling the events done\\n\\n\");\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind004\/libnativemethbind04.cpp","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/NativeMethodBind\/nativemethbind004.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test exercises the JVMTI event NativeMethodBind.\n+ *     It verifies that binding native method can be redirected during\n+ *     the event callback.\n+ *     The test works as follows. An agent part enables the NativeMethodBind\n+ *     generation. Then the java part invokes the native method 'nativeMethod()'\n+ *     which leads to the NativeMethodBind generation. In NativeMethodBind\n+ *     callback incoming address of the nativeMethod() is changed to the\n+ *     address of another native method 'redirNativeMethod()'. Both functions\n+ *     nativeMethod() and redirNativeMethod() count their calls.\n+ *     In accordance with the spec, the nativeMethod() should not be invoked\n+ *     and the redirNativeMethod() should be invoked once.\n+ * COMMENTS\n+ *     The test has been fixed due to the bug 4967116.\n+ *     Fixed the 4995867 bug.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native\n+ *      -agentlib:nativemethbind04 nativemethbind004\n+ *\/\n+\n+\n+\/**\n+ * This test exercises the JVMTI event <code>NativeMethodBind<\/code>.\n+ * <br>It verifies that binding native method can be redirected during\n+ * the event callback.<p>\n+ * The test works as follows. An agent part enables the NativeMethodBind\n+ * generation. Then the java part invokes the native method\n+ * <code>nativeMethod()<\/code> which leads to the NativeMethodBind generation.\n+ * In NativeMethodBind callback incoming address of the nativeMethod() is\n+ * changed to the address of another native method\n+ * <code>redirNativeMethod()<\/code>.\n+ * Both functions nativeMethod() and redirNativeMethod() count their calls.<br>\n+ * In accordance with the spec, the nativeMethod() should not be invoked\n+ * and the redirNativeMethod() should be invoked once.\n+ *\/\n+public class nativemethbind004 {\n+    static {\n+        try {\n+            System.loadLibrary(\"nativemethbind04\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load \\\"nativemethbind004\\\" library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native void nativeMethod();\n+    native int check();\n+\n+    public static void main(String[] argv) {\n+        new nativemethbind004().runThis();\n+    }\n+\n+    private void runThis() {\n+        \/\/ invoke native method to be redirected\n+        nativeMethod();\n+\n+        int res = check();\n+        if (res != 0) {\n+            throw new RuntimeException(\"Check() returned \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/NativeMethodBind\/nativemethbind004\/nativemethbind004.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,347 @@\n+\/*\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define STATUS_FAILED 2\n+#define PASSED 0\n+\n+#define METH_NUM 2\n+\n+static const char *METHODS[] = {\n+    \"bpMethod\",\n+    \"runThis\"\n+};\n+\n+static const char *METHOD_SIGS[] = {\n+    \"()V\",\n+    \"()I\"\n+};\n+\n+static volatile long stepEv[] = { 0, 0 };\n+\n+static const char *CLASS_SIG =\n+    \"Lsinglestep001;\";\n+\n+static volatile jint result = PASSED;\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+\n+static volatile int callbacksEnabled = NSK_FALSE;\n+static jrawMonitorID agent_lock;\n+\n+static void setBP(jvmtiEnv *jvmti, JNIEnv *env, jclass klass) {\n+  jmethodID mid;\n+  jvmtiError err;\n+\n+  mid = env->GetMethodID(klass, METHODS[0], METHOD_SIGS[0]);\n+  if (mid == NULL) {\n+    env->FatalError(\"failed to get ID for the java method\\n\");\n+  }\n+\n+  printf(\"Setting breakpoint....\");\n+  err = jvmti->SetBreakpoint(mid, 0);\n+  if (err != JVMTI_ERROR_NONE) {\n+    env->FatalError(\"failed to set breakpoint\\n\");\n+  }\n+}\n+\n+\/** callback functions **\/\n+void JNICALL\n+ClassLoad(jvmtiEnv *jvmti, JNIEnv *env, jthread thread, jclass klass) {\n+  char *sig, *generic;\n+  jvmtiError err;\n+\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  if (callbacksEnabled) {\n+    err = jvmti->GetClassSignature(klass, &sig, &generic);\n+    if (err != JVMTI_ERROR_NONE) {\n+      env->FatalError(\"failed to obtain a class signature\\n\");\n+    }\n+    if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n+      NSK_DISPLAY1(\n+          \"ClassLoad event received for the class \\\"%s\\\"\\n\"\n+          \"\\tsetting breakpoint ...\\n\",\n+          sig);\n+      setBP(jvmti, env, klass);\n+    }\n+  }\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+void JNICALL\n+Breakpoint(jvmtiEnv *jvmti, JNIEnv *env, jthread thr, jmethodID method,\n+           jlocation loc) {\n+  jclass klass;\n+  char *sig, *generic;\n+  jvmtiError err;\n+\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  if (!callbacksEnabled) {\n+    jvmti->RawMonitorExit(agent_lock);\n+    return;\n+  }\n+\n+  NSK_DISPLAY0(\"Breakpoint event received\\n\");\n+  err = jvmti->GetMethodDeclaringClass(method, &klass);\n+  if (err != JVMTI_ERROR_NONE) {\n+    NSK_COMPLAIN0(\"TEST FAILURE: unable to get method declaring class\\n\\n\");\n+  }\n+\n+  err = jvmti->GetClassSignature(klass, &sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    env->FatalError(\"Breakpoint: failed to obtain a class signature\\n\");\n+  }\n+\n+  if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n+    NSK_DISPLAY1(\"method declaring class \\\"%s\\\"\\n\\tenabling SingleStep events ...\\n\", sig);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, thr);\n+    if (err != JVMTI_ERROR_NONE) {\n+      result = STATUS_FAILED;\n+      NSK_COMPLAIN0(\"TEST FAILURE: cannot enable SingleStep events\\n\\n\");\n+    }\n+  } else {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN1(\"TEST FAILURE: unexpected breakpoint event in method of class \\\"%s\\\"\\n\\n\",\n+                  sig);\n+  }\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+void JNICALL\n+SingleStep(jvmtiEnv *jvmti, JNIEnv* jni_env, jthread thread,\n+           jmethodID method, jlocation location) {\n+  jclass klass;\n+  char *sig, *generic, *methNam, *methSig;\n+  jvmtiError err;\n+\n+  if (result == STATUS_FAILED) {\n+    return;\n+  }\n+\n+  NSK_DISPLAY0(\">>>> SingleStep event received\\n\");\n+\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during SingleStep callback\\n\\n\");\n+    return;\n+  }\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &klass);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to get method declaring class during SingleStep callback\\n\\n\");\n+    return;\n+  }\n+\n+  err = jvmti->GetClassSignature(klass, &sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to obtain a class signature during SingleStep callback\\n\\n\");\n+    return;\n+  }\n+\n+  if (sig != NULL) {\n+    NSK_DISPLAY3(\n+        \"\\tmethod name: \\\"%s\\\"\\n\"\n+        \"\\tsignature: \\\"%s\\\"\\n\"\n+        \"\\tmethod declaring class: \\\"%s\\\"\\n\",\n+        methNam, methSig, sig);\n+\n+    if (stepEv[1] == 1) {\n+      result = STATUS_FAILED;\n+      NSK_COMPLAIN0(\"TEST FAILED: SingleStep event received after disabling the event generation\\n\\n\");\n+    }\n+    else if ((strcmp(methNam,METHODS[0]) == 0) &&\n+        (strcmp(methSig,METHOD_SIGS[0]) == 0) &&\n+        (strcmp(sig,CLASS_SIG) == 0)) {\n+      stepEv[0]++;\n+      NSK_DISPLAY1(\"CHECK PASSED: SingleStep event received for the method \\\"%s\\\" as expected\\n\",\n+                   methNam);\n+    }\n+    else if ((strcmp(methNam,METHODS[1]) == 0) &&\n+        (strcmp(methSig,METHOD_SIGS[1]) == 0) &&\n+        (strcmp(sig,CLASS_SIG) == 0)) {\n+      stepEv[1]++;\n+      NSK_DISPLAY1(\n+          \"CHECK PASSED: SingleStep event received for the method \\\"%s\\\" as expected\\n\"\n+          \"\\tdisabling the event generation\\n\",\n+          methNam);\n+      err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, thread);\n+      if (err != JVMTI_ERROR_NONE) {\n+        result = STATUS_FAILED;\n+        NSK_COMPLAIN0(\"TEST FAILED: cannot disable SingleStep events\\n\\n\");\n+      }\n+    }\n+  }\n+\n+  err = jvmti->Deallocate((unsigned char*) methNam);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+  }\n+  err = jvmti->Deallocate((unsigned char*) methSig);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n+  }\n+\n+  NSK_DISPLAY0(\"<<<<\\n\\n\");\n+}\n+\n+void JNICALL\n+VMStart(jvmtiEnv *jvmti, JNIEnv* jni_env) {\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  callbacksEnabled = NSK_TRUE;\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv* jni_env) {\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  callbacksEnabled = NSK_FALSE;\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\/************************\/\n+\n+JNIEXPORT jint JNICALL\n+Java_singlestep001_check(\n+    JNIEnv *env, jobject obj) {\n+  int i;\n+\n+  for (i=0; i<METH_NUM; i++)\n+    if (stepEv[i] == 0) {\n+      result = STATUS_FAILED;\n+      NSK_COMPLAIN1(\"TEST FAILED: no SingleStep events for the method \\\"%s\\\"\\n\\n\",\n+                    METHODS[i]);\n+    }\n+\n+  return result;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_singlestep001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_singlestep001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_singlestep001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+  jint res;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+  \/* add capability to generate compiled method events *\/\n+  memset(&caps, 0, sizeof(jvmtiCapabilities));\n+  caps.can_generate_breakpoint_events = 1;\n+  caps.can_generate_single_step_events = 1;\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_generate_single_step_events)\n+    NSK_DISPLAY0(\"Warning: generation of single step events is not implemented\\n\");\n+\n+  \/* set event callback *\/\n+  NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n+  (void) memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.ClassLoad = &ClassLoad;\n+  callbacks.Breakpoint = &Breakpoint;\n+  callbacks.SingleStep = &SingleStep;\n+  callbacks.VMStart = &VMStart;\n+  callbacks.VMDeath = &VMDeath;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+\n+  NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n+\n+  err = jvmti->CreateRawMonitor(\"agent lock\", &agent_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep001\/libsinglestep01.cpp","additions":347,"deletions":0,"binary":false,"changes":347,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.*;\n+\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/SingleStep\/singlestep001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, onload_only_caps, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test exercises the JVMTI event SingleStep.\n+ *     It verifies that this event can be enabled and disabled during\n+ *     program execution.\n+ *     The test works as follows. Breakpoint is set at special method\n+ *     'bpMethod()'. Upon reaching the breakpoint, agent enables SingleStep\n+ *     event generation. All the received events are counted. When the\n+ *     method 'bpMethod()' is leaved and accordingly, the program returns\n+ *     to the calling method 'runThis()', the agent disables the event\n+ *     generation.\n+ *     At least one SingleStep  event must be received for the each method\n+ *     mentioned above. Also after disabling the event no more events\n+ *     must be received.\n+ * COMMENTS\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:singlestep01 singlestep001\n+ *\/\n+\n+\n+\n+\/**\n+ * This test exercises the JVMTI event <code>SingleStep<\/code>.\n+ * <br>It verifies that this event can be enabled and disabled\n+ * during program execution.<br>\n+ * The test works as follows. Breakpoint is set at special method\n+ * <code>bpMethod()<\/code>. Upon reaching the breakpoint, agent\n+ * enables <code>SingleStep<\/code> event generation. All the received\n+ * events are counted. When the method <code>bpMethod()<\/code> is\n+ * leaved and accordingly, the program returns to the calling method\n+ * <code>runThis()<\/code>, the agent disables the event generation.<br>\n+ * At least one <code>SingleStep<\/code> event must be received for\n+ * the each methods mentioned above. Also after disabling the event\n+ * no more event must be received.\n+ *\/\n+public class singlestep001 {\n+    static {\n+        try {\n+            System.loadLibrary(\"singlestep01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load \\\"singlestep001\\\" library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native int check();\n+\n+    public static void main(String[] argv) {\n+        int result = new singlestep001().runThis();\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+    private int runThis() {\n+\n+\n+        Thread.currentThread().setName(\"singlestep001Thr\");\n+\n+        System.out.println(\"\\nReaching a breakpoint method ...\\n\");\n+        bpMethod();\n+        System.out.println(\"The breakpoint method leaved ...\");\n+\n+        return check();\n+    }\n+\n+    \/**\n+     * dummy method used only to reach breakpoint set in the agent\n+     *\/\n+    private void bpMethod() {\n+        int dummyVar = 0;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep001\/singlestep001.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define STATUS_FAILED 2\n+#define PASSED 0\n+\n+static volatile jint result = PASSED;\n+static volatile long wrongStepEv = 0;\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+static jvmtiCapabilities caps;\n+\n+\/** callback functions **\/\n+void JNICALL\n+SingleStep(jvmtiEnv *jvmti, JNIEnv* jni_env, jthread thread,\n+           jmethodID method, jlocation location) {\n+  jvmtiPhase phase;\n+  jvmtiError err;\n+\n+\n+  err = jvmti->GetPhase(&phase);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to obtain phase of the VM execution during SingleStep callback\\n\\n\");\n+  }\n+  else {\n+    if (phase != JVMTI_PHASE_LIVE) {\n+      wrongStepEv++;\n+      result = STATUS_FAILED;\n+      NSK_COMPLAIN1(\"TEST FAILED: SingleStep event received during non-live phase %s\\n\",\n+                    TranslatePhase(phase));\n+    }\n+  }\n+}\n+\n+void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv *env) {\n+  NSK_DISPLAY0(\"VMDeath event received\\n\");\n+\n+  if (wrongStepEv != 0) {\n+    printf(\n+        \"TEST FAILED: there are %ld SingleStep events\\n\"\n+        \"sent during non-live phase of the VM execution\\n\",\n+        wrongStepEv);\n+  }\n+\n+  if (result == STATUS_FAILED)\n+    exit(95 + STATUS_FAILED);\n+}\n+\/************************\/\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_singlestep002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_singlestep002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_singlestep002(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  \/* add capability to generate compiled method events *\/\n+  memset(&caps, 0, sizeof(jvmtiCapabilities));\n+  caps.can_generate_single_step_events = 1;\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  if (!caps.can_generate_single_step_events)\n+    NSK_DISPLAY0(\"Warning: generation of single step events is not implemented\\n\");\n+\n+  \/* set event callback *\/\n+  NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n+  (void) memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.SingleStep = &SingleStep;\n+  callbacks.VMDeath = &VMDeath;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep002\/libsinglestep02.cpp","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+import java.io.*;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/SingleStep\/singlestep002.\n+ * VM Testbase keywords: [jpda, jvmti, onload_only_caps, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test exercises the JVMTI event SingleStep.\n+ *     It verifies that this event s sent only during the live phase\n+ *     of VM execution.\n+ *     The test works as follows. The tested event is enabled in the\n+ *     'OnLoad' phase. Then all received SingleStep events is checked\n+ *     to be sent only during the live phase via the GetPhase() call.\n+ * COMMENTS\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:singlestep02 singlestep002\n+ *\/\n+\n+\n+\n+\n+\/**\n+ * This test exercises the JVMTI event <code>SingleStep<\/code>.\n+ * <br>It verifies that this event is sent only during the live\n+ * phase of VM execution.<br>\n+ * The test works as follows. The tested event is enabled in the\n+ * <code>OnLoad<\/code> phase. Then all received <code>SingleStep<\/code>\n+ * events is checked to be sent only during the live phase via\n+ * the <code>GetPhase()<\/code> call.\n+ *\/\n+public class singlestep002 {\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"singlestep02\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load \\\"singlestep002\\\" library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    public static void main(String[] argv) {\n+        new singlestep002().runThis(argv);\n+    }\n+\n+    private int runThis(String argv[]) {\n+        return DebugeeClass.TEST_PASSED;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep002\/singlestep002.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,389 @@\n+\/*\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+extern \"C\" {\n+\n+#define STATUS_FAILED 2\n+#define PASSED 0\n+\n+\/* tested methods *\/\n+#define METH_NUM 4\n+static const char *METHODS[][2] = {\n+    { \"bpMethod\", \"()V\" },\n+    { \"nativeMethod\", \"()V\" },\n+    { \"anotherNativeMethod\", \"(I)V\" },\n+    { \"runThis\", \"()I\" }\n+};\n+\n+\/* event counters for the tested methods and expected numbers\n+ of the events *\/\n+static volatile long stepEv[][2] = {\n+    { 0, 1 },\n+    { 0, 0 },\n+    { 0, 0 },\n+    { 0, 1 }\n+};\n+\n+static const char *CLASS_SIG =\n+    \"Lsinglestep003;\";\n+\n+static volatile jint result = PASSED;\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+\n+static volatile int callbacksEnabled = NSK_FALSE;\n+static jrawMonitorID agent_lock;\n+\n+static void setBP(jvmtiEnv *jvmti, JNIEnv *env, jclass klass) {\n+  jmethodID mid;\n+  jvmtiError err;\n+\n+  mid = env->GetMethodID(klass, METHODS[0][0], METHODS[0][1]);\n+  if (mid == NULL) {\n+    env->FatalError(\"failed to get ID for the java method\\n\");\n+  }\n+\n+  err = jvmti->SetBreakpoint(mid, 0);\n+  if (err != JVMTI_ERROR_NONE) {\n+    env->FatalError(\"failed to set breakpoint\\n\");\n+  }\n+}\n+\n+\/** callback functions **\/\n+void JNICALL\n+ClassLoad(jvmtiEnv *jvmti, JNIEnv *env, jthread thread, jclass klass) {\n+  char *sig, *generic;\n+  jvmtiError err;\n+\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  if (!callbacksEnabled) {\n+    jvmti->RawMonitorExit(agent_lock);\n+    return;\n+  }\n+\n+  err = jvmti->GetClassSignature(klass, &sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    env->FatalError(\"failed to obtain a class signature\\n\");\n+  }\n+\n+  if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n+    NSK_DISPLAY1(\n+        \"ClassLoad event received for the class \\\"%s\\\"\\n\"\n+        \"\\tsetting breakpoint ...\\n\",\n+        sig);\n+    setBP(jvmti, env, klass);\n+  }\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+void JNICALL\n+VMStart(jvmtiEnv *jvmti, JNIEnv* jni_env) {\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  callbacksEnabled = NSK_TRUE;\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+\n+void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv* jni_env) {\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  callbacksEnabled = NSK_FALSE;\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+void JNICALL\n+Breakpoint(jvmtiEnv *jvmti, JNIEnv *env, jthread thr, jmethodID method,\n+           jlocation loc) {\n+  jclass klass;\n+  char *sig, *generic;\n+  jvmtiError err;\n+\n+  jvmti->RawMonitorEnter(agent_lock);\n+\n+  if (!callbacksEnabled) {\n+    jvmti->RawMonitorExit(agent_lock);\n+    return;\n+  }\n+\n+  NSK_DISPLAY0(\"Breakpoint event received\\n\");\n+  err = jvmti->GetMethodDeclaringClass(method, &klass);\n+  if (err != JVMTI_ERROR_NONE) {\n+    NSK_COMPLAIN0(\"TEST FAILURE: unable to get method declaring class\\n\\n\");\n+  }\n+\n+  err = jvmti->GetClassSignature(klass, &sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    env->FatalError(\"Breakpoint: failed to obtain a class signature\\n\");\n+  }\n+\n+\n+  if (sig != NULL && (strcmp(sig, CLASS_SIG) == 0)) {\n+    NSK_DISPLAY1(\"method declaring class \\\"%s\\\"\\n\\tenabling SingleStep events ...\\n\",\n+                 sig);\n+    err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_SINGLE_STEP, thr);\n+    if (err != JVMTI_ERROR_NONE) {\n+      result = STATUS_FAILED;\n+      NSK_COMPLAIN0(\"TEST FAILURE: cannot enable SingleStep events\\n\\n\");\n+    }\n+  } else {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN1(\"TEST FAILURE: unexpected breakpoint event in method of class \\\"%s\\\"\\n\\n\",\n+                  sig);\n+  }\n+\n+  jvmti->RawMonitorExit(agent_lock);\n+}\n+\n+void JNICALL\n+SingleStep(jvmtiEnv *jvmti, JNIEnv* jni_env, jthread thread,\n+           jmethodID method, jlocation location) {\n+  jvmtiError err;\n+  jclass klass;\n+  char *sig, *generic, *methNam, *methSig;\n+  int i;\n+\n+  if (result == STATUS_FAILED) {\n+    return;\n+  }\n+\n+  NSK_DISPLAY0(\">>>> SingleStep event received\\n\");\n+\n+  err = jvmti->GetMethodName(method, &methNam, &methSig, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to get method name during SingleStep callback\\n\\n\");\n+    return;\n+  }\n+\n+  err = jvmti->GetMethodDeclaringClass(method, &klass);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to get method declaring class during SingleStep callback\\n\\n\");\n+    return;\n+  }\n+\n+  err = jvmti->GetClassSignature(klass, &sig, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to obtain a class signature during SingleStep callback\\n\\n\");\n+    return;\n+  }\n+\n+\n+  if (sig != NULL) {\n+    if (stepEv[METH_NUM-1][0] == 1) {\n+      result = STATUS_FAILED;\n+      NSK_COMPLAIN0(\"TEST FAILED: SingleStep event received after disabling the event generation\\n\\n\");\n+      return;\n+    }\n+\n+    for (i=0; i<METH_NUM; i++) {\n+      if ((strcmp(methNam,METHODS[i][0]) == 0) &&\n+          (strcmp(methSig,METHODS[i][1]) == 0) &&\n+          (strcmp(sig,CLASS_SIG) == 0)) {\n+        stepEv[i][0]++;\n+\n+        if (stepEv[i][1] == 1) {\n+          NSK_DISPLAY3(\n+              \"CHECK PASSED: SingleStep event received for the method:\\n\"\n+              \"\\t \\\"%s %s\\\" of class \\\"%s\\\"\\n\"\n+              \"\\tas expected\\n\",\n+              methNam, methSig, sig);\n+        } else {\n+          result = STATUS_FAILED;\n+          printf(\n+              \"TEST FAILED: SingleStep event received for the method:\\n\"\n+              \"\\t \\\"%s %s\\\" of class \\\"%s\\\"\\n\",\n+              methNam, methSig, sig);\n+        }\n+\n+        if (i == (METH_NUM-1)) {\n+          NSK_DISPLAY0(\"Disabling the single step event generation\\n\");\n+          err = jvmti->SetEventNotificationMode(JVMTI_DISABLE, JVMTI_EVENT_SINGLE_STEP, thread);\n+          if (err != JVMTI_ERROR_NONE) {\n+            result = STATUS_FAILED;\n+            NSK_COMPLAIN0(\"TEST FAILED: cannot disable SingleStep events\\n\\n\");\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  err = jvmti->Deallocate((unsigned char*) methNam);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method name\\n\\n\");\n+  }\n+  err = jvmti->Deallocate((unsigned char*) methSig);\n+  if (err != JVMTI_ERROR_NONE) {\n+    result = STATUS_FAILED;\n+    NSK_COMPLAIN0(\"TEST FAILED: unable to deallocate memory pointed to method signature\\n\\n\");\n+  }\n+\n+  NSK_DISPLAY0(\"<<<<\\n\\n\");\n+}\n+\/************************\/\n+\n+\/* dummy method used only to provoke SingleStep events *\/\n+JNIEXPORT void JNICALL\n+Java_singlestep003_anotherNativeMethod(\n+    JNIEnv *env, jobject obj, jint i) {\n+  NSK_DISPLAY0(\"inside the anotherNativeMethod()\\n\\n\");\n+}\n+\n+\/* dummy method used only to provoke SingleStep events *\/\n+JNIEXPORT void JNICALL\n+Java_singlestep003_nativeMethod(\n+    JNIEnv *env, jobject obj) {\n+  jint i = 0;\n+\n+  NSK_DISPLAY0(\"inside the nativeMethod()\\n\\n\");\n+  i++;\n+\n+  Java_singlestep003_anotherNativeMethod(env, obj, i);\n+}\n+\n+JNIEXPORT jint JNICALL Java_singlestep003_check(\n+    JNIEnv *env, jobject obj) {\n+  int i;\n+\n+  for (i=0; i<METH_NUM; i++)\n+    if (stepEv[i][0] == 0) {\n+      if (stepEv[i][1] == 0) {\n+        NSK_DISPLAY1(\"CHECK PASSED: no SingleStep events for the method \\\"%s\\\" as expected\\n\\n\",\n+                     METHODS[i][0]);\n+      }\n+      else {\n+        result = STATUS_FAILED;\n+        NSK_COMPLAIN1(\"TEST FAILED: no SingleStep events for the method \\\"%s\\\"\\n\\n\",\n+                      METHODS[i][0]);\n+      }\n+    }\n+\n+  return result;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_singlestep003(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_singlestep003(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_singlestep003(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiCapabilities caps;\n+  jvmtiError err;\n+  jint res;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  \/* add capability to generate compiled method events *\/\n+  memset(&caps, 0, sizeof(jvmtiCapabilities));\n+  caps.can_generate_breakpoint_events = 1;\n+  caps.can_generate_single_step_events = 1;\n+  err = jvmti->AddCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  err = jvmti->GetCapabilities(&caps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+  if (!caps.can_generate_single_step_events)\n+    NSK_DISPLAY0(\"Warning: generation of single step events is not implemented\\n\");\n+\n+  \/* set event callback *\/\n+  NSK_DISPLAY0(\"setting event callbacks ...\\n\");\n+  (void) memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.ClassLoad = &ClassLoad;\n+  callbacks.Breakpoint = &Breakpoint;\n+  callbacks.SingleStep = &SingleStep;\n+  callbacks.VMStart = &VMStart;\n+  callbacks.VMDeath = &VMDeath;\n+\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  NSK_DISPLAY0(\"setting event callbacks done\\nenabling JVMTI events ...\\n\");\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_START, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_CLASS_LOAD, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_BREAKPOINT, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  NSK_DISPLAY0(\"enabling the events done\\n\\n\");\n+\n+  err = jvmti->CreateRawMonitor(\"agent lock\", &agent_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep003\/libsinglestep03.cpp","additions":389,"deletions":0,"binary":false,"changes":389,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/SingleStep\/singlestep003.\n+ * VM Testbase keywords: [quick, jpda, jvmti, onload_only_caps, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This test exercises the JVMTI event SingleStep.\n+ *     It verifies that no single step event will be generated from\n+ *     within native methods.\n+ *     The test works as follows. Breakpoint is set at special method\n+ *     'bpMethod()'. Upon reaching the breakpoint, agent enables\n+ *     SingleStep event generation and checks the events. The java part\n+ *     calls native method 'nativeMethod()' which calls another native\n+ *     'anotherNativeMethod()' in order to provoke the SingleStep events\n+ *     from within native methods. When 'bpMethod()' is leaved and\n+ *     accordingly, the program returns to the calling method 'runThis()',\n+ *     the agent disables the event generation.\n+ * COMMENTS\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:singlestep03 singlestep003\n+ *\/\n+\n+\/**\n+ * This test exercises the JVMTI event <code>SingleStep<\/code>.\n+ * <br>It verifies that no single step event will be generated from\n+ * within native methods.<br>\n+ * The test works as follows. Breakpoint is set at special method\n+ * <code>bpMethod()<\/code>. Upon reaching the breakpoint, agent\n+ * enables <code>SingleStep<\/code> event generation and checks the\n+ * events. The java part calls native method <code>nativeMethod()<\/code>\n+ * which calls another native <code>anotherNativeMethod()<\/code>\n+ * in order to provoke the SingleStep events from within native\n+ * methods. When <code>bpMethod()<\/code> is leaved and accordingly,\n+ * the program returns to the calling method <code>runThis()<\/code>,\n+ * the agent disables the event generation.\n+ *\/\n+public class singlestep003 {\n+    static {\n+        try {\n+            System.loadLibrary(\"singlestep03\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load \\\"singlestep003\\\" library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native void nativeMethod();\n+    native void anotherNativeMethod(int i);\n+\n+    native int check();\n+\n+    public static void main(String[] argv) {\n+        int result = new singlestep003().runThis();\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+    private int runThis() {\n+\n+        System.out.println(\"\\nReaching a breakpoint method ...\\n\");\n+        bpMethod();\n+        System.out.println(\"The breakpoint method leaved ...\");\n+\n+        return check();\n+    }\n+\n+    \/**\n+     * dummy method used to reach breakpoint, enable the SingleStep\n+     * event in the agent and provoke SingleStep for native method\n+     *\/\n+    private void bpMethod() {\n+        nativeMethod();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/SingleStep\/singlestep003\/singlestep003.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsCount = 0;\n+static int eventsExpected = 0;\n+static const char *prefix = NULL;\n+\n+void JNICALL ThreadEnd(jvmtiEnv *jvmti, JNIEnv *env, jthread thread) {\n+  jvmtiError err;\n+  jvmtiThreadInfo inf;\n+  char name[32];\n+\n+  err = jvmti->GetThreadInfo(thread, &inf);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetThreadInfo#%d) unexpected error: %s (%d)\\n\",\n+           eventsCount, TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> %s\\n\", inf.name);\n+  }\n+  if (inf.name != NULL && strstr(inf.name, prefix) == inf.name) {\n+    eventsCount++;\n+    sprintf(name, \"%s%d\", prefix, eventsCount);\n+    if (inf.name == NULL || strcmp(name, inf.name) != 0) {\n+      printf(\"(#%d) wrong thread name: \\\"%s\\\"\",\n+             eventsCount, inf.name);\n+      printf(\", expected: \\\"%s\\\"\\n\", name);\n+      result = STATUS_FAILED;\n+    }\n+  }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadend001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadend001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_threadend001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  callbacks.ThreadEnd = &ThreadEnd;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_threadend001_getReady(JNIEnv *env,\n+                                               jclass cls, jint i, jstring name) {\n+  jvmtiError err;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return;\n+  }\n+\n+  prefix = env->GetStringUTFChars(name, NULL);\n+  if (prefix == NULL) {\n+    printf(\"Failed to copy UTF-8 string!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_THREAD_END, NULL);\n+  if (err == JVMTI_ERROR_NONE) {\n+    eventsExpected = i;\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_THREAD_END: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_threadend001_check(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_THREAD_END, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_THREAD_END: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of thread end events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend001\/libthreadend01.cpp","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/ThreadEnd\/threadend001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function ThreadEnd.\n+ *     The test checks if the event is ganerated by a terminating\n+ *     thread after its initial method has finished execution.\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:threadend01 threadend001\n+ *\/\n+\n+\n+public class threadend001 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+    final static int THREADS_LIMIT = 100;\n+    final static String NAME_PREFIX = \"threadend001-\";\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"threadend01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load threadend001 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady(int i, String name);\n+    native static int check();\n+\n+    static volatile int thrCount = THREADS_LIMIT;\n+\n+    public static void main(String args[]) {\n+        int result = run(args, System.out);\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+    public static int run(String args[], PrintStream out) {\n+        TestThread t = new TestThread(NAME_PREFIX + thrCount);\n+        getReady(THREADS_LIMIT, NAME_PREFIX);\n+        t.start();\n+        try {\n+            t.join();\n+        } catch (InterruptedException e) {\n+            throw new Error(\"Unexpected: \" + e);\n+        }\n+        return check();\n+    }\n+\n+    static class TestThread extends Thread {\n+        public TestThread(String name) {\n+            super(name);\n+        }\n+        public void run() {\n+            thrCount--;\n+            if (thrCount > 0) {\n+                TestThread t = new TestThread(NAME_PREFIX + thrCount);\n+                t.start();\n+                try {\n+                    t.join();\n+                } catch (InterruptedException e) {\n+                    throw new Error(\"Unexpected: \" + e);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend001\/threadend001.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+#include \"jvmti_thread.h\"\n+\n+\n+extern \"C\" {\n+\n+\/* ============================================================================= *\/\n+\n+\/* scaffold objects *\/\n+static jvmtiEnv *jvmti = NULL;\n+static jlong timeout = 0;\n+\n+static int eventCount = 0;\n+\n+\/* ============================================================================= *\/\n+\n+JNIEXPORT void JNICALL\n+cbThreadEnd(jvmtiEnv* jvmti, JNIEnv* jni_env, jthread thread) {\n+\n+  eventCount++;\n+}\n+\n+\/* ============================================================================= *\/\n+\n+static int\n+enableEvent(jvmtiEventMode enable, jvmtiEvent event) {\n+  jvmtiError err;\n+\n+  if (enable == JVMTI_ENABLE) {\n+    NSK_DISPLAY1(\"enabling %s\\n\", TranslateEvent(event));\n+  } else {\n+    NSK_DISPLAY1(\"disabling %s\\n\", TranslateEvent(event));\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(enable, event, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    nsk_jvmti_setFailStatus();\n+    return NSK_FALSE;\n+  }\n+\n+  return NSK_TRUE;\n+}\n+\n+\/* ============================================================================= *\/\n+\n+int checkEvents() {\n+\n+  int result = NSK_TRUE;\n+\n+  if (eventCount == 0) {\n+    nsk_jvmti_setFailStatus();\n+    NSK_COMPLAIN0(\"Number of THREAD_END events must be greater than 0\\n\");\n+    nsk_jvmti_setFailStatus();\n+    result = NSK_FALSE;\n+  }\n+\n+  return result;\n+}\n+\n+\/* ============================================================================= *\/\n+\n+static int\n+setCallBacks() {\n+  jvmtiError err;\n+  jvmtiEventCallbacks eventCallbacks;\n+  memset(&eventCallbacks, 0, sizeof(eventCallbacks));\n+\n+  eventCallbacks.ThreadEnd = cbThreadEnd;\n+\n+  err = jvmti->SetEventCallbacks(&eventCallbacks, sizeof(eventCallbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    return NSK_FALSE;\n+  }\n+\n+  return NSK_TRUE;\n+}\n+\n+\/* ============================================================================= *\/\n+\n+\/** Agent algorithm. *\/\n+static void JNICALL\n+agentProc(jvmtiEnv* jvmti, JNIEnv* agentJNI, void* arg) {\n+\n+  NSK_DISPLAY0(\"Wait for debuggee to become ready\\n\");\n+  if (!nsk_jvmti_waitForSync(timeout))\n+    return;\n+\n+  NSK_DISPLAY0(\"Let debuggee to continue\\n\");\n+  if (!nsk_jvmti_resumeSync())\n+    return;\n+\n+  if (!nsk_jvmti_waitForSync(timeout))\n+    return;\n+\n+  if (!checkEvents()) {\n+    nsk_jvmti_setFailStatus();\n+  }\n+\n+  NSK_DISPLAY0(\"Let debuggee to finish\\n\");\n+  if (!nsk_jvmti_resumeSync())\n+    return;\n+\n+}\n+\n+\/* ============================================================================= *\/\n+\n+\/** Agent library initialization. *\/\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadend002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadend002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_threadend002(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  timeout = 60 * 1000; \/\/ TODO change timeout\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+\n+  err = init_agent_data(jvmti, &agent_data);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  if (!setCallBacks()) {\n+    return JNI_ERR;\n+  }\n+\n+  if (!enableEvent(JVMTI_ENABLE, JVMTI_EVENT_THREAD_END)) {\n+    NSK_COMPLAIN0(\"Events could not be enabled\");\n+    nsk_jvmti_setFailStatus();\n+    return JNI_ERR;\n+  }\n+\n+  nsk_jvmti_setAgentProc(agentProc, NULL);\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend002\/libthreadend02.cpp","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/ThreadEnd\/threadend002.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function THREAD_END.\n+ *     The test enables this event during OnLoad phase. The test fails\n+ *     if no THREAD_END event is received\n+ * COMMENTS\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:threadend02=-waittime=5 threadend002\n+ *\/\n+\n+public class threadend002 extends DebugeeClass {\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        int result = run(argv, System.out);\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+    \/\/ run test from JCK-compatible environment\n+    public static int run(String argv[], PrintStream out) {\n+        return new threadend002().runIt(argv, out);\n+    }\n+\n+    \/\/ run debuggee\n+    public int runIt(String argv[], PrintStream out) {\n+\n+        int status = threadend002.checkStatus(DebugeeClass.TEST_PASSED);\n+\n+        threadend002Thread thrd = new threadend002Thread();\n+        thrd.start();\n+\n+        try {\n+            thrd.join();\n+        } catch(InterruptedException e) {\n+            System.out.println(\"Unexpected exception \" + e);\n+            e.printStackTrace();\n+            return DebugeeClass.TEST_FAILED;\n+        }\n+\n+        int currStatus = threadend002.checkStatus(DebugeeClass.TEST_PASSED);\n+        if (currStatus != DebugeeClass.TEST_PASSED)\n+            status = currStatus;\n+\n+        return status;\n+    }\n+\n+    class threadend002Thread extends Thread {\n+\n+        public void run() {\n+            System.out.println(\"thread finished\");\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadEnd\/threadend002\/threadend002.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static int eventsCount = 0;\n+static int eventsExpected = 0;\n+static const char *prefix = NULL;\n+\n+void JNICALL ThreadStart(jvmtiEnv *jvmti, JNIEnv *env, jthread thread) {\n+  jvmtiError err;\n+  jvmtiThreadInfo inf;\n+  char name[32];\n+\n+  err = jvmti->GetThreadInfo(thread, &inf);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetThreadInfo#%d) unexpected error: %s (%d)\\n\",\n+           eventsCount, TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> %s\\n\", inf.name);\n+  }\n+  if (inf.name != NULL && strstr(inf.name, prefix) == inf.name) {\n+    sprintf(name, \"%s%d\", prefix, eventsCount);\n+    if (strcmp(name, inf.name) != 0) {\n+      printf(\"(#%d) wrong thread name: \\\"%s\\\"\",\n+             eventsCount, inf.name);\n+      printf(\", expected: \\\"%s\\\"\\n\", name);\n+      result = STATUS_FAILED;\n+    }\n+    eventsCount++;\n+  }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadstart001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadstart001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_threadstart001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint  Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  callbacks.ThreadStart = &ThreadStart;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_threadstart001_getReady(JNIEnv *env,\n+                                                   jclass cls, jint i, jstring name) {\n+  jvmtiError err;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return;\n+  }\n+\n+  prefix = env->GetStringUTFChars(name, NULL);\n+  if (prefix == NULL) {\n+    printf(\"Failed to copy UTF-8 string!\\n\");\n+    result = STATUS_FAILED;\n+    return;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_THREAD_START, NULL);\n+  if (err == JVMTI_ERROR_NONE) {\n+    eventsExpected = i;\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_THREAD_START: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_threadstart001_check(JNIEnv *env, jclass cls) {\n+  jvmtiError err;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_THREAD_START, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_THREAD_START: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (eventsCount != eventsExpected) {\n+    printf(\"Wrong number of thread start events: %d, expected: %d\\n\",\n+           eventsCount, eventsExpected);\n+    result = STATUS_FAILED;\n+  }\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart001\/libthreadstart01.cpp","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/ThreadStart\/threadstart001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras, quarantine]\n+ * VM Testbase comments: 8016181\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function ThreadStart.\n+ *     The test checks if the event is ganerated by a new\n+ *     thread before its initial method executes.\n+ * COMMENTS\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:threadstart01 threadstart001\n+ *\/\n+\n+public class threadstart001 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+    final static int THREADS_LIMIT = 100;\n+    final static String NAME_PREFIX = \"threadstart001-\";\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"threadstart01\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load threadstart001 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static void getReady(int i, String name);\n+    native static int check();\n+\n+    static volatile int thrCount = 0;\n+\n+    public static void main(String args[]) {\n+        int result = run(args, System.out);\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+    public static int run(String args[], PrintStream out) {\n+        TestThread t = new TestThread(NAME_PREFIX + thrCount);\n+        getReady(THREADS_LIMIT, NAME_PREFIX);\n+        t.start();\n+        try {\n+            t.join();\n+        } catch (InterruptedException e) {\n+            throw new Error(\"Unexpected: \" + e);\n+        }\n+        return check();\n+    }\n+\n+    static class TestThread extends Thread {\n+        public TestThread(String name) {\n+            super(name);\n+        }\n+        public void run() {\n+            thrCount++;\n+            if (thrCount < THREADS_LIMIT) {\n+                TestThread t = new TestThread(NAME_PREFIX + thrCount);\n+                t.start();\n+                try {\n+                    t.join();\n+                } catch (InterruptedException e) {\n+                    throw new Error(\"Unexpected: \" + e);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart001\/threadstart001.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,542 @@\n+\/*\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+\n+extern \"C\" {\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+#define WAIT_TIME 20000\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiCapabilities caps;\n+static jvmtiEventCallbacks callbacks;\n+\/* volatile variables *\/\n+static jrawMonitorID agent_start_lock, thr_start_lock, thr_resume_lock, thr_event_lock;\n+static volatile jthread agent_thread = NULL;\n+static volatile jboolean terminate_debug_agent = JNI_FALSE;\n+static volatile jboolean debug_agent_timed_out = JNI_FALSE;\n+static volatile jboolean debug_agent_started = JNI_FALSE;\n+static volatile jthread next_thread = NULL;\n+static jvmtiThreadInfo inf;\n+static volatile int eventsCount = 0;\n+static volatile jint result = PASSED;\n+\n+\/*\n+    The agent runs special debugger agent (debug_agent) in a separate thread\n+    that operates on behalf of other threads.\n+    Upon receiving ThreadStart event, the debugger agent:\n+    - suspends the new thread\n+    - calls jni_DeleteGlobalRef with a jnienv * for that new thread\n+    - resumes the new thread\n+    Then the thread suspend status is checked in ThreadStart callback.\n+\n+    The following monitors are used to synchronize debugger thread with other\n+    threads:\n+    1. agent_start_lock\n+       used to notify VMInit callback as well as ThreadStart callback\n+       that agent thread has been started.\n+    2. thr_event_lock\n+       used to guarantee that only one ThreadStart event is proceeded at\n+       the time.\n+    3. thr_start_lock\n+       used to notify agent thread that new thread has been started.\n+    4. thr_resume_lock\n+       used to notify ThreadStart callback that agent thread finished\n+       suspending and resuming the thread.\n+\n+    So, the threads behaves as following:\n+\n+VMInit                  | debug_agent                 |   ThreadStart\n+-------------------------------------------------------------------------\n+                        |                             |\n+ agent_start_lock.enter |                             | agent_start_lock.enter\n+                        |                             |\n+ ... create debug_agent | ... start                   |  while (!debug_agent)\n+ agent_start_lock.wait  |                             |    agent_start_lock.wait\n+                        | agent_start_lock.enter      |\n+                        | agent_start_lock.notifyAll  |\n+                        | agent_start_lock.exit       |\n+ agent_start_lock.exit  |                             |  agent_start_lock.exit\n+                        |                             |\n+                        |                             |  thr_event_lock.enter\n+                        |                             |\n+                        | thr_start_lock.enter        |  thr_start_lock.enter\n+                        | if (!next_thread)           |  thr_resume_lock.enter\n+                        |     thr_start_lock.wait     |\n+                        |                             |  ... next_thread = ...\n+                        |                             |  thr_start_lock.notify\n+                        |                             |  thr_start_lock.exit\n+                        |                             |\n+                        | ... suspend new thread      |  thr_resume_lock.wait\n+                        | ... resume new thread       |\n+                        |                             |\n+                        | thr_resume_lock.enter       |\n+                        | thr_resume_lock.notify      |\n+                        | thr_resume_lock.exit        |\n+                        |                             |  ... check next_thread state\n+                        |                             |  thr_resume_lock.exit\n+                        | thr_start_lock.exit         |\n+                                                      | thr_event_lock.exit\n+\n+\n+*\/\n+\n+\/\/ TODO replace\n+static jint NSK_JVMTI_VERIFY(jvmtiError err) {\n+  return (err == JVMTI_ERROR_NONE);\n+}\n+\n+static void JNICALL\n+debug_agent(jvmtiEnv* jvmti, JNIEnv* jni, void *p) {\n+JNIEnv *env = jni;\n+jint thrStat;\n+jobject temp;\n+\n+\/* Notify VMInit callback as well as ThreadStart callback (if any)\n+ * that agent thread has been started\n+ *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(agent_start_lock))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"[agent] failed to acquire agent_start_lock\\n\");\n+}\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorNotifyAll(agent_start_lock))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"[agent] failed to notify about agent_start_lock\\n\");\n+}\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(agent_start_lock))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"[agent] failed to release agent_start_lock\\n\");\n+}\n+\n+NSK_DISPLAY0(\">>> [agent] agent created\\n\");\n+\n+debug_agent_started = JNI_TRUE;\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(thr_start_lock))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"[agent] failed to enter thr_start_lock\\n\");\n+}\n+\n+while (terminate_debug_agent != JNI_TRUE) {\n+\n+if (next_thread == NULL) {\n+\/* wait till new thread will be created and started *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorWait(thr_start_lock, (jlong)0))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"[agent] Failed while waiting thr_start_lock\\n\");\n+}\n+}\n+\n+if (next_thread != NULL) {\n+\/* hmm, why NewGlobalRef is called one more time???\n+ * next_thread = env->NewGlobalRef(next_thread);\n+ *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->SuspendThread(next_thread))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN1(\"[agent] Failed to suspend thread#%d\\n\", eventsCount);\n+}\n+\n+NSK_DISPLAY2(\">>> [agent] thread#%d %s suspended ...\\n\", eventsCount, inf.name);\n+\n+\/* these dummy calls provoke VM to hang *\/\n+temp = env->NewGlobalRef(next_thread);\n+env->DeleteGlobalRef(temp);\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->ResumeThread(next_thread))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN1(\"[agent] Failed to resume thread#%d\\n\", eventsCount);\n+}\n+\n+NSK_DISPLAY2(\">>> [agent] thread#%d %s resumed ...\\n\", eventsCount, inf.name);\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->GetThreadState(next_thread, &thrStat))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN1(\"[agent] Failed to get thread state for thread#%d\\n\", eventsCount);\n+}\n+\n+NSK_DISPLAY3(\">>> [agent] %s threadState=%s (%x)\\n\",\n+inf.name, TranslateState(thrStat), thrStat);\n+\n+if (thrStat & JVMTI_THREAD_STATE_SUSPENDED) {\n+NSK_COMPLAIN1(\"[agent] \\\"%s\\\" was not resumed\\n\", inf.name);\n+env->FatalError(\"[agent] could not recover\");\n+}\n+\n+env->DeleteGlobalRef(next_thread);\n+next_thread = NULL;\n+\n+\/* Notify ThreadStart callback that thread has been resumed *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(thr_resume_lock))) {\n+NSK_COMPLAIN0(\"[agent] Failed to acquire thr_resume_lock\\n\");\n+result = STATUS_FAILED;\n+}\n+\n+debug_agent_timed_out = JNI_FALSE;\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorNotify(thr_resume_lock))) {\n+NSK_COMPLAIN0(\"[agent] Failed to notifing about thr_resume_lock\\n\");\n+result = STATUS_FAILED;\n+}\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(thr_resume_lock))) {\n+NSK_COMPLAIN0(\"[agent] Failed to release thr_resume_lock\\n\");\n+result = STATUS_FAILED;\n+}\n+}\n+}\n+\n+\/*\n+ * We don't call RawMonitorExit(thr_start_lock) in the loop so we don't\n+ * lose any notify calls.\n+ *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(thr_start_lock))) {\n+NSK_COMPLAIN0(\"[agent] Failed to release thr_start_lock\\n\");\n+result = STATUS_FAILED;\n+}\n+\n+NSK_DISPLAY0(\">>> [agent] done.\\n\");\n+}\n+\n+void JNICALL ThreadStart(jvmtiEnv *jvmti, JNIEnv *env, jthread thread) {\n+jint thrStat;\n+jvmtiPhase phase;\n+\n+NSK_DISPLAY0(\">>> [ThreadStart hook] start\\n\");\n+\n+\/* skip if thread is 'agent thread' *\/\n+if (env->IsSameObject(agent_thread, thread) == JNI_TRUE) {\n+NSK_DISPLAY0(\">>> [ThreadStart hook] skip agent thread\\n\");\n+NSK_DISPLAY0(\">>> [ThreadStart hook] end\\n\");\n+return;\n+}\n+\n+\/* wait till agent thread is started\n+ * (otherwise can fail while waiting on thr_resume_thread due to timeout)\n+ *\/\n+if (debug_agent_started != JNI_TRUE) {\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(agent_start_lock))) {\n+NSK_COMPLAIN0(\"[ThreadStart hook] Failed to acquire agent_start_lock\\n\");\n+result = STATUS_FAILED;\n+}\n+\n+while (debug_agent_started != JNI_TRUE) {\n+NSK_DISPLAY1(\">>> [ThreadStart hook] waiting %dms for agent thread to start\\n\", WAIT_TIME);\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorWait(agent_start_lock, (jlong)WAIT_TIME))) {\n+NSK_COMPLAIN0(\"[ThreadStart hook] Failed to wait for agent_start_lock\\n\");\n+result = STATUS_FAILED;\n+}\n+}\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(agent_start_lock))) {\n+NSK_COMPLAIN0(\"[ThreadStart hook] Failed to release agent_start_lock\\n\");\n+result = STATUS_FAILED;\n+}\n+}\n+\n+\n+\/* get JVMTI phase *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->GetPhase(&phase))) {\n+NSK_COMPLAIN0(\"[ThreadStart hook] Failed to get JVMTI phase\\n\");\n+result = STATUS_FAILED;\n+}\n+\n+\/* Acquire event lock,\n+ * so only one StartThread callback could be proceeded at the time\n+ *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(thr_event_lock))) {\n+NSK_COMPLAIN0(\"[ThreadStart hook] Failed to acquire thr_event_lock\\n\");\n+result = STATUS_FAILED;\n+}\n+\n+{\n+\/* Get thread name *\/\n+inf.name = (char*) \"UNKNOWN\";\n+if (phase == JVMTI_PHASE_LIVE) {\n+\/* GetThreadInfo may only be called during the live phase *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->GetThreadInfo(thread, &inf))) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] Failed to get thread infor for thread#%d\\n\", eventsCount);\n+result = STATUS_FAILED;\n+}\n+}\n+\n+NSK_DISPLAY2(\">>> [ThreadStart hook] thread#%d: %s\\n\", eventsCount, inf.name);\n+\n+\/* Acquire thr_start_lock *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(thr_start_lock))) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to acquire thr_start_lock\\n\", eventsCount);\n+result = STATUS_FAILED;\n+}\n+\n+\/* Acquire thr_resume_lock before we release thr_start_lock to prevent\n+ * debug agent from notifying us before we are ready.\n+*\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(thr_resume_lock))) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to acquire thr_resume_lock\\n\", eventsCount);\n+result = STATUS_FAILED;\n+}\n+\n+\/* Store thread *\/\n+next_thread = env->NewGlobalRef(thread);\n+debug_agent_timed_out = JNI_TRUE;\n+\n+\/* Notify agent thread about new started thread and let agent thread to work with it *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorNotify(thr_start_lock))) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to notify about thr_start_lock\\n\", eventsCount);\n+result = STATUS_FAILED;\n+}\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(thr_start_lock))) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to release thr_start_lock\\n\", eventsCount);\n+result = STATUS_FAILED;\n+}\n+\n+\/* Wait till this started thread will be resumed by agent thread *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorWait(thr_resume_lock, (jlong)WAIT_TIME))) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed while waiting for thr_resume_lock\\n\", eventsCount);\n+result = STATUS_FAILED;\n+}\n+\n+if (debug_agent_timed_out == JNI_TRUE) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] \\\"%s\\\": debug agent timed out\\n\", inf.name);\n+env->FatalError(\"[ThreadStart hook] could not recover\");\n+}\n+\n+\/* Release thr_resume_lock lock *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(thr_resume_lock))) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] thread#%d failed to release thr_resume_lock\\n\", eventsCount);\n+result = STATUS_FAILED;\n+}\n+\n+\/* check that thread is not in SUSPENDED state *\/\n+if (!NSK_JVMTI_VERIFY(jvmti->GetThreadState(thread, &thrStat))) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] Failed to get thread state for thread#%d\\n\", eventsCount);\n+result = STATUS_FAILED;\n+}\n+\n+NSK_DISPLAY2(\">>> [ThreadStart hook] threadState=%s (%x)\\n\",\n+TranslateState(thrStat), thrStat);\n+\n+if (thrStat & JVMTI_THREAD_STATE_SUSPENDED) {\n+NSK_COMPLAIN1(\"[ThreadStart hook] \\\"%s\\\" was self-suspended\\n\", inf.name);\n+env->FatalError(\"[ThreadStart hook] could not recover\");\n+}\n+\n+eventsCount++;\n+}\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(thr_event_lock))) {\n+NSK_COMPLAIN0(\"[ThreadStart hook] Failed to release thr_event_lock\\n\");\n+result = STATUS_FAILED;\n+}\n+\n+NSK_DISPLAY0(\">>> [ThreadStart hook] end\\n\");\n+}\n+\n+void JNICALL VMInit(jvmtiEnv *jvmti, JNIEnv *env, jthread thr) {\n+jclass cls = NULL;\n+jmethodID mid = NULL;\n+\n+NSK_DISPLAY0(\">>> VMInit event: start\\n\");\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_THREAD_START, NULL))) {\n+NSK_COMPLAIN0(\"TEST FAILED: failed to enable JVMTI_EVENT_THREAD_START\\n\");\n+return;\n+}\n+\n+\/* Start agent thread *\/\n+cls = env->FindClass(\"java\/lang\/Thread\");\n+if (cls == NULL) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"TEST FAILED: Cannot start agent thread: FindClass() failed\\n\");\n+return;\n+}\n+\n+mid = env->GetMethodID(cls, \"<init>\", \"()V\");\n+if (mid == NULL) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"TEST FAILED: Cannot start agent thread: GetMethodID() failed\\n\");\n+return;\n+}\n+\n+agent_thread = env->NewObject(cls, mid);\n+if (agent_thread == NULL) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"Cannot start agent thread: NewObject() failed\\n\");\n+return;\n+}\n+\n+agent_thread = (jthread) env->NewGlobalRef(agent_thread);\n+if (agent_thread == NULL) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"Cannot create global reference for agent_thread\\n\");\n+return;\n+}\n+\n+\/*\n+ * Grab agent_start_lock before launching debug_agent to prevent\n+ * debug_agent from notifying us before we are ready.\n+ *\/\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorEnter(agent_start_lock))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"TEST FAILED: failed to enter agent_start_lock\\n\");\n+}\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RunAgentThread(agent_thread, debug_agent, NULL, JVMTI_THREAD_NORM_PRIORITY))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"TEST FAILED: failed to create agent thread\\n\");\n+}\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorWait(agent_start_lock, (jlong)0))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"TEST FAILED: failed to wait agent_start_lock\\n\");\n+}\n+\n+if (!NSK_JVMTI_VERIFY(jvmti->RawMonitorExit(agent_start_lock))) {\n+result = STATUS_FAILED;\n+NSK_COMPLAIN0(\"TEST FAILED: failed to exit agent_start_lock\\n\");\n+}\n+\n+NSK_DISPLAY0(\">>> VMInit event: end\\n\");\n+}\n+\n+void JNICALL VMDeath(jvmtiEnv *jvmti, JNIEnv *env) {\n+NSK_DISPLAY0(\">>> VMDeath event\\n\");\n+\n+terminate_debug_agent = JNI_TRUE;\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadstart002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadstart002(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_threadstart002(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jint res;\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+\n+  if (!NSK_JVMTI_VERIFY(jvmti->GetPotentialCapabilities(&caps))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to get potential capabilities\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  if (!NSK_JVMTI_VERIFY(jvmti->AddCapabilities(&caps))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to add capabilities during agent load\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  if (!NSK_JVMTI_VERIFY(jvmti->GetCapabilities(&caps))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to get capabilities\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  if (!caps.can_suspend) {\n+    NSK_DISPLAY0(\"WARNING: suspend\/resume is not implemented\\n\");\n+  }\n+\n+  \/* create raw monitors *\/\n+  if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_agent_start_lock\", &agent_start_lock))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to create agent_start_lock\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_thr_event_lock\", &thr_event_lock))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to create thr_event_lock\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_thr_start_lock\", &thr_start_lock))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to create thr_start_lock\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  if (!NSK_JVMTI_VERIFY(jvmti->CreateRawMonitor(\"_thr_resume_lock\", &thr_resume_lock))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to create thr_resume_lock\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  callbacks.VMInit = &VMInit;\n+  callbacks.VMDeath = &VMDeath;\n+  callbacks.ThreadStart = &ThreadStart;\n+\n+  if (!NSK_JVMTI_VERIFY(jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks)))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to set event callbacks\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_INIT, NULL))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to enable JVMTI_EVENT_VM_INIT\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_DEATH, NULL))) {\n+    NSK_COMPLAIN0(\"TEST FAILED: failed to enable JVMTI_EVENT_VM_DEATH\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_threadstart002_check(JNIEnv *env, jclass cls) {\n+  if (eventsCount == 0) {\n+    NSK_COMPLAIN0(\"None of thread start events!\\n\");\n+    result = STATUS_FAILED;\n+  }\n+\n+  NSK_DISPLAY1(\">>> total of thread start events: %d\\n\", eventsCount);\n+\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart002\/libthreadstart02.cpp","additions":542,"deletions":0,"binary":false,"changes":542,"status":"added"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/ThreadStart\/threadstart002.\n+ * VM Testbase keywords: [quick, jpda, jvmti, onload_only_logic, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     This is a regression test for the following bug:\n+ *         4432884 jdbx does not work with jdk 1.3.1 starting with\n+ *                 rc1 build 19 onwards\n+ *     The test runs a debugger agent in a separate thread that operates\n+ *     on behalf of other threads, so when it gets a ThreadStart event,\n+ *     the debugger agent suspends the new thread and then\n+ *     calls jni_DeleteGlobalRef with a jnienv * for that new thread.\n+ *     Then the test resumes the new thread and checks the thread\n+ *     suspend status.\n+ * COMMENTS\n+ *     The test reproduces the bug on Solsparc with JDK 1.3.1-b19\n+ *     with the following output:\n+ *     java version \"1.3.1-rc1\"\n+ *     Java(TM) 2 Runtime Environment, Standard Edition (build 1.3.1-rc1-b19)\n+ *     Java HotSpot(TM) Client VM (build 1.3.1-rc1-b19, interpreted mode)\n+ *     >>> debug agent created\n+ *     >>> thread 0: Signal Dispatcher\n+ *     >>> Signal Dispatcher suspended ...\n+ *     >>> ... resumed\n+ *     >>> agent: threadStatus=ffffffff, suspendStatus=1\n+ *     \"Signal Dispatcher\" did not resume\n+ *     FATAL ERROR in native method: could not recover\n+ *     Exit Code: 1\n+ *     Fixed according to 4668512 bug,\n+ *     Ported from JVMDI.\n+ *     Modified due to fix of the RFE\n+ *     5001769 TEST_RFE: remove usage of deprecated GetThreadStatus function\n+ *     Fixed according to 6221885 test bug.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:threadstart02 threadstart002 5\n+ *\/\n+\n+public class threadstart002 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+\n+    static {\n+    try {\n+        System.loadLibrary(\"threadstart02\");\n+    } catch (UnsatisfiedLinkError ule) {\n+        System.err.println(\"Could not load threadstart002 library\");\n+        System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+        throw ule;\n+    }\n+    }\n+\n+    native static int check();\n+\n+    public static int waitTime = 2;\n+\n+    public static void main(String args[]) {\n+        int result = run(args, System.out);\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+    public static int run(String args[], PrintStream out) {\n+        if (args.length > 0) {\n+            try {\n+                int i  = Integer.parseInt(args[0]);\n+                waitTime = i;\n+            } catch (NumberFormatException ex) {\n+                out.println(\"# Wrong argument \\\"\" + args[0]\n+                    + \"\\\", the default value is used\");\n+            }\n+        }\n+        out.println(\"# Waiting time = \" + waitTime + \" mins\");\n+\n+        TestThread t = new TestThread(\"TestThread_1\");\n+        t.start();\n+\n+        try {\n+            t.join(waitTime * 60000);\n+        } catch (InterruptedException e) {\n+            throw new Error(\"Unexpected: \" + e);\n+        }\n+\n+        return check();\n+    }\n+\n+    static class TestThread extends Thread {\n+\n+        TestThread(String name) {\n+            super(name);\n+        }\n+\n+        public void run() {\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart002\/threadstart002.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <jvmti.h>\n+#include \"jvmti_common.h\"\n+\n+\n+extern \"C\" {\n+\n+\n+#define PASSED 0\n+#define STATUS_FAILED 2\n+#define WAIT_TIME 1000\n+\n+static jvmtiEnv *jvmti = NULL;\n+static jvmtiEventCallbacks callbacks;\n+static jint result = PASSED;\n+static jboolean printdump = JNI_FALSE;\n+static jrawMonitorID wait_lock;\n+static const char *threadName = NULL;\n+static int startsCount = 0;\n+static int startsExpected = 0;\n+static int endsCount = 0;\n+static int endsExpected = 0;\n+\n+void JNICALL ThreadStart(jvmtiEnv *jvmti, JNIEnv *env, jthread thread) {\n+  jvmtiError err;\n+  jvmtiThreadInfo inf;\n+\n+  err = jvmti->GetThreadInfo(thread, &inf);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetThreadInfo, start) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> start: %s\\n\", inf.name);\n+  }\n+  if (inf.name != NULL && strcmp(inf.name, threadName) == 0) {\n+    startsCount++;\n+  }\n+}\n+\n+void JNICALL ThreadEnd(jvmtiEnv *jvmti, JNIEnv *env, jthread thread) {\n+  jvmtiError err;\n+  jvmtiThreadInfo inf;\n+\n+  err = jvmti->GetThreadInfo(thread, &inf);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(GetThreadInfo, end) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> end: %s\\n\", inf.name);\n+  }\n+  if (inf.name != NULL && strcmp(inf.name, threadName) == 0) {\n+    endsCount++;\n+  }\n+}\n+\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_threadstart003(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_threadstart003(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_threadstart003(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiError err;\n+  jint res;\n+\n+  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n+    printdump = JNI_TRUE;\n+  }\n+\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  callbacks.ThreadStart = &ThreadStart;\n+  callbacks.ThreadEnd = &ThreadEnd;\n+  err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return JNI_ERR;\n+  }\n+\n+  return JNI_OK;\n+}\n+\n+static void JNICALL\n+threadProc(jvmtiEnv* jvmti, JNIEnv* jni, void *unused) {\n+  jvmtiError err;\n+\n+  err = jvmti->RawMonitorEnter(wait_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  err = jvmti->RawMonitorNotify(wait_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RawMonitorNotify) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  err = jvmti->RawMonitorExit(wait_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_threadstart003_check(JNIEnv *env,\n+                                                jclass cls, jthread thr, jstring name) {\n+  jvmtiError err;\n+\n+  if (jvmti == NULL) {\n+    printf(\"JVMTI client was not properly loaded!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  threadName = env->GetStringUTFChars(name, NULL);\n+  if (threadName == NULL) {\n+    printf(\"Failed to copy UTF-8 string!\\n\");\n+    return STATUS_FAILED;\n+  }\n+\n+  err = jvmti->CreateRawMonitor(\"_wait_lock\", &wait_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(CreateRawMonitor) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    return STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_THREAD_START, NULL);\n+  if (err == JVMTI_ERROR_NONE) {\n+    startsExpected = 1;\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_THREAD_START: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                        JVMTI_EVENT_THREAD_END, NULL);\n+  if (err == JVMTI_ERROR_NONE) {\n+    endsExpected = 1;\n+  } else {\n+    printf(\"Failed to enable JVMTI_EVENT_THREAD_END: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (printdump == JNI_TRUE) {\n+    printf(\">>> starting agent thread ...\\n\");\n+  }\n+  err = jvmti->RawMonitorEnter(wait_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  err = jvmti->RunAgentThread(thr, threadProc,\n+                              NULL, JVMTI_THREAD_MAX_PRIORITY);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RunAgentThread) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  err = jvmti->RawMonitorWait(wait_lock, 0);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RawMonitorWait) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  err = jvmti->RawMonitorExit(wait_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  err = jvmti->RawMonitorEnter(wait_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RawMonitorEnter) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  \/\/ Wait for up to 3 seconds for the thread end event\n+  {\n+    int i;\n+    for (i = 0; i < 3 ; i++) {\n+      err = jvmti->RawMonitorWait(wait_lock, (jlong)WAIT_TIME);\n+      if (endsCount == endsExpected || err != JVMTI_ERROR_NONE) {\n+        break;\n+      }\n+    }\n+  }\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RawMonitorWait) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+  err = jvmti->RawMonitorExit(wait_lock);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"(RawMonitorExit) unexpected error: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_THREAD_START, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_THREAD_START: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_THREAD_END, NULL);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"Failed to disable JVMTI_EVENT_THREAD_END: %s (%d)\\n\",\n+           TranslateError(err), err);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (startsCount != startsExpected) {\n+    printf(\"Wrong number of thread start events: %d, expected: %d\\n\",\n+           startsCount, startsExpected);\n+    result = STATUS_FAILED;\n+  }\n+\n+  if (endsCount != endsExpected) {\n+    printf(\"Wrong number of thread end events: %d, expected: %d\\n\",\n+           endsCount, endsExpected);\n+    result = STATUS_FAILED;\n+  }\n+\n+  return result;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart003\/libthreadstart03.cpp","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/ThreadStart\/threadstart003.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     Regression test for bug\n+ *         4266590 Thread start events are sent from the wrong thread\n+ *         Release summary: kestrel\n+ *         Hardware version: generic\n+ *         O\/S version (unbundled products): generic\n+ * COMMENTS\n+ *     The test reproduced the bug on winNT 1.3.0-E build.\n+ *     Ported from JVMDI.\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:threadstart03 threadstart003\n+ *\/\n+\n+\n+public class threadstart003 {\n+\n+    final static int JCK_STATUS_BASE = 95;\n+    final static String ThreadName = \"testedThread\";\n+\n+    static {\n+        try {\n+            System.loadLibrary(\"threadstart03\");\n+        } catch (UnsatisfiedLinkError ule) {\n+            System.err.println(\"Could not load threadstart003 library\");\n+            System.err.println(\"java.library.path:\"\n+                + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+    }\n+\n+    native static int check(Thread thr, String name);\n+\n+    public static void main(String args[]) {\n+        int result = run(args, System.out);\n+        if (result != 0) {\n+            throw new RuntimeException(\"Unexpected status: \" + result);\n+        }\n+    }\n+\n+    public static int run(String args[], PrintStream out) {\n+        return check(new Thread(ThreadName), ThreadName);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/ThreadStart\/threadstart003\/threadstart003.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+#include \"jvmti_common.h\"\n+#include \"jvmti_thread.h\"\n+\n+\n+extern \"C\" {\n+\n+\/* ========================================================================== *\/\n+\n+\/* scaffold objects *\/\n+static jlong timeout = 0;\n+\n+\/* test objects *\/\n+static int eventsCount = 0;\n+\n+\/* ========================================================================== *\/\n+\n+\/* check if any VMObjectAlloc events received *\/\n+static int checkVMObjectAllocEvents() {\n+\n+  NSK_DISPLAY1(\"VMObjectAlloc events received: %d\\n\", eventsCount);\n+\n+  if (eventsCount == 0) {\n+    NSK_DISPLAY0(\"# WARNING: no VMObjectAlloc events\\n\");\n+    NSK_DISPLAY0(\"#    (VM might not allocate such objects at all)\\n\");\n+  }\n+\n+  return NSK_TRUE;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+JNIEXPORT void JNICALL\n+VMObjectAlloc(jvmtiEnv *jvmti, JNIEnv* jni, jthread thread, jobject object,\n+              jclass object_klass, jlong size) {\n+  char *signature, *generic;\n+  jvmtiError err;\n+\n+  eventsCount++;\n+\n+  err = jvmti->GetClassSignature(object_klass, &signature, &generic);\n+  if (err != JVMTI_ERROR_NONE) {\n+    nsk_jvmti_setFailStatus();\n+    return;\n+  }\n+\n+  NSK_DISPLAY2(\"VMObjectAlloc: \\\"%s\\\", size=%ld\\n\", signature, (long)size);\n+\n+  if (signature != NULL)\n+    jvmti->Deallocate((unsigned char*)signature);\n+\n+  if (generic != NULL)\n+    jvmti->Deallocate((unsigned char*)generic);\n+\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent algorithm *\/\n+static void JNICALL\n+agentProc(jvmtiEnv* jvmti, JNIEnv* jni, void* arg) {\n+\n+  \/* wait for debuggee start *\/\n+  if (!nsk_jvmti_waitForSync(timeout))\n+    return;\n+\n+  \/* testcase #1: check if any VMObjectAlloc events received*\/\n+  NSK_DISPLAY0(\"Testcase #1: check if any VMObjectAlloc events received\\n\");\n+  if (!checkVMObjectAllocEvents())\n+    nsk_jvmti_setFailStatus();\n+\n+  \/* resume debugee after last sync *\/\n+  if (!nsk_jvmti_resumeSync())\n+    return;\n+}\n+\n+\/* ========================================================================== *\/\n+\n+\/* agent library initialization *\/\n+#ifdef STATIC_BUILD\n+JNIEXPORT jint JNICALL Agent_OnLoad_vmobjalloc001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNICALL Agent_OnAttach_vmobjalloc001(JavaVM *jvm, char *options, void *reserved) {\n+    return Agent_Initialize(jvm, options, reserved);\n+}\n+JNIEXPORT jint JNI_OnLoad_vmobjalloc001(JavaVM *jvm, char *options, void *reserved) {\n+    return JNI_VERSION_1_8;\n+}\n+#endif\n+jint Agent_Initialize(JavaVM *jvm, char *options, void *reserved) {\n+  jvmtiEnv* jvmti = NULL;\n+  jvmtiCapabilities caps;\n+  jvmtiEventCallbacks callbacks;\n+  jvmtiError err;\n+  jint res;\n+\n+  timeout = 60000; \/\/ TODO Fix timeout\n+  NSK_DISPLAY1(\"Timeout: %d msc\\n\", (int)timeout);\n+\n+  \/* create JVMTI environment *\/\n+  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n+  if (res != JNI_OK || jvmti == NULL) {\n+    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n+    return JNI_ERR;\n+  }\n+\n+  err = init_agent_data(jvmti, &agent_data);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+\n+  memset(&caps, 0, sizeof(caps));\n+  caps.can_generate_vm_object_alloc_events = 1;\n+  if (jvmti->AddCapabilities(&caps) != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  memset(&callbacks, 0, sizeof(callbacks));\n+  callbacks.VMObjectAlloc= &VMObjectAlloc;\n+  if (jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks) != JVMTI_ERROR_NONE)) {\n+    return JNI_ERR;\n+  }\n+\n+  \/* enable VMObjectAlloc event *\/\n+  if (jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_VM_OBJECT_ALLOC, NULL) != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+\n+  \/* register agent proc and arg *\/\n+  nsk_jvmti_setAgentProc(agentProc, NULL);\n+\n+  return JNI_OK;\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+\n+JNIEXPORT jint JNICALL Agent_OnAttach(JavaVM *jvm, char *options, void *reserved) {\n+  return Agent_Initialize(jvm, options, reserved);\n+}\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/VMObjectAlloc\/vmobjalloc001\/libvmobjalloc.cpp","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+import jdk.test.lib.jvmti.DebugeeClass;\n+\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/jvmti\/VMObjectAlloc\/vmobjalloc001.\n+ * VM Testbase keywords: [quick, jpda, jvmti, noras]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test exercises JVMTI event callback function VMObjectAlloc.\n+ *     The test enables the event and counts a number of received events.\n+ *     There is no guarantee that VM allocates any special objects, so if\n+ *     no JVMTI_EVENT_VM_OBJECT_ALLOC has been received then the test\n+ *     just prints warning message and passes anyway.\n+ * COMMENTS\n+ *     Fixed the 5001806 bug.\n+ *     Modified due to fix of the bug\n+ *     5010571 TEST_BUG: jvmti tests with VMObjectAlloc callbacks should\n+ *             be adjusted to new spec\n+ *\n+ * @library \/test\/lib\n+ * @run main\/othervm\/native -agentlib:vmobjalloc vmobjalloc001\n+ *\/\n+\n+public class vmobjalloc001 extends DebugeeClass {\n+\n+    \/\/ run test from command line\n+    public static void main(String argv[]) {\n+        new vmobjalloc001().runIt();\n+    }\n+\n+    int status = TEST_PASSED;\n+\n+    \/\/ run debuggee\n+    public void runIt() {\n+\n+        System.out.println(\"Sync: debuggee started\");\n+        int result = checkStatus(status);\n+        if (result != 0) {\n+            throw new RuntimeException(\"checkStatus() returned \" + result);\n+        }\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/VMObjectAlloc\/vmobjalloc001\/vmobjalloc001.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -49,1 +49,1 @@\n-    NSK_DISPLAY2(\"MonitorContendedEnter event:\\n\\tthread: %p, object: %p\\n\",\n+    printf(\"MonitorContendedEnter event:\\n\\tthread: %p, object: %p\\n\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/MonitorContendedEnter\/mcontenter001\/mcontenter001.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.jvmti;\n+\n+\/**\n+ * Base class for debuggee class in JVMTI tests.\n+ *\n+ * <p>This class provides method checkStatus(int) which is used for\n+ * synchronization between agent and debuggee class.<\/p>\n+ *\n+ * @see #checkStatus(int)\n+ *\/\n+public class DebugeeClass {\n+\n+    public static final int TEST_PASSED = 0;\n+    public static final int TEST_FAILED = 2;\n+\n+    \/**\n+     * This method is used for synchronization status between agent and debuggee class.\n+     *\/\n+    public synchronized static native int checkStatus(int status);\n+\n+    \/**\n+     * Reset agent data to prepare for another run.\n+     *\/\n+    public synchronized static native void resetAgentData();\n+\n+    \/**\n+     * This method is used to load library with native methods implementation, if needed.\n+     *\/\n+    public static void loadLibrary(String name) {\n+        try {\n+            System.loadLibrary(name);\n+        } catch (UnsatisfiedLinkError e) {\n+            System.err.println(\"# ERROR: Could not load native library: \" + name);\n+            System.err.println(\"# java.library.path: \"\n+                                + System.getProperty(\"java.library.path\"));\n+            throw e;\n+        }\n+    }\n+\n+    public static void safeSleep(long millis) {\n+        try {\n+            Thread.sleep(millis);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e.getMessage());\n+        }\n+    }\n+\n+    public class Failure extends RuntimeException {\n+        public Failure() {\n+        }\n+\n+        public Failure(Throwable cause) {\n+            super(cause);\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/DebugeeClass.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,380 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef JVMTI_COMMON_H\n+#define JVMTI_COMMON_H\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include <string.h>\n+#include <ctype.h>\n+\n+#define NSK_TRUE 1\n+#define NSK_FALSE 0\n+\n+#define NSK_DISPLAY0 printf\n+#define NSK_DISPLAY1 printf\n+#define NSK_DISPLAY2 printf\n+#define NSK_DISPLAY3 printf\n+#define NSK_DISPLAY4 printf\n+\n+\n+#define NSK_COMPLAIN0 printf\n+#define NSK_COMPLAIN1 printf\n+#define NSK_COMPLAIN3 printf\n+\n+extern \"C\" {\n+\n+char *jlong_to_string(jlong value, char *string) {\n+  char buffer[32];\n+  char *pbuf, *pstr;\n+\n+  pstr = string;\n+  if (value == 0) {\n+    *pstr++ = '0';\n+  } else {\n+    if (value < 0) {\n+      *pstr++ = '-';\n+      value = -value;\n+    }\n+    pbuf = buffer;\n+    while (value != 0) {\n+      *pbuf++ = '0' + (char)(value % 10);\n+      value = value \/ 10;\n+    }\n+    while (pbuf != buffer) {\n+      *pstr++ = *--pbuf;\n+    }\n+  }\n+  *pstr = '\\0';\n+\n+  return string;\n+}\n+\n+static void check_jvmti_status(JNIEnv* jni, jvmtiError err, const char* msg) {\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"check_jvmti_status: JVMTI function returned error: %d\\n\", err);\n+    jni->FatalError(msg);\n+  }\n+}\n+\n+const char* TranslateState(jint flags) {\n+    static char str[15 * 20];\n+\n+    if (flags == 0)\n+        return \"<none>\";\n+\n+    str[0] = '\\0';\n+\n+    if (flags & JVMTI_THREAD_STATE_ALIVE) {\n+        strcat(str, \" ALIVE\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_TERMINATED) {\n+        strcat(str, \" TERMINATED\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_RUNNABLE) {\n+        strcat(str, \" RUNNABLE\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_WAITING) {\n+        strcat(str, \" WAITING\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_WAITING_INDEFINITELY) {\n+        strcat(str, \" WAITING_INDEFINITELY\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT) {\n+        strcat(str, \" WAITING_WITH_TIMEOUT\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_SLEEPING) {\n+        strcat(str, \" SLEEPING\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_IN_OBJECT_WAIT) {\n+        strcat(str, \" IN_OBJECT_WAIT\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_PARKED) {\n+        strcat(str, \" PARKED\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER) {\n+        strcat(str, \" BLOCKED_ON_MONITOR_ENTER\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_SUSPENDED) {\n+        strcat(str, \" SUSPENDED\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_INTERRUPTED) {\n+        strcat(str, \" INTERRUPTED\");\n+    }\n+\n+    if (flags & JVMTI_THREAD_STATE_IN_NATIVE) {\n+        strcat(str, \" IN_NATIVE\");\n+    }\n+\n+    return str;\n+}\n+\n+const char* TranslateEvent(jvmtiEvent event_type) {\n+    switch (event_type) {\n+    case JVMTI_EVENT_VM_INIT:\n+        return (\"JVMTI_EVENT_VM_INIT\");\n+    case JVMTI_EVENT_VM_DEATH:\n+        return (\"JVMTI_EVENT_VM_DEATH\");\n+    case JVMTI_EVENT_THREAD_START:\n+        return (\"JVMTI_EVENT_THREAD_START\");\n+    case JVMTI_EVENT_THREAD_END:\n+        return (\"JVMTI_EVENT_THREAD_END\");\n+    case JVMTI_EVENT_CLASS_FILE_LOAD_HOOK:\n+        return (\"JVMTI_EVENT_CLASS_FILE_LOAD_HOOK\");\n+    case JVMTI_EVENT_CLASS_LOAD:\n+        return (\"JVMTI_EVENT_CLASS_LOAD\");\n+    case JVMTI_EVENT_CLASS_PREPARE:\n+        return (\"JVMTI_EVENT_CLASS_PREPARE\");\n+    case JVMTI_EVENT_VM_START:\n+        return (\"JVMTI_EVENT_VM_START\");\n+    case JVMTI_EVENT_EXCEPTION:\n+        return (\"JVMTI_EVENT_EXCEPTION\");\n+    case JVMTI_EVENT_EXCEPTION_CATCH:\n+        return (\"JVMTI_EVENT_EXCEPTION_CATCH\");\n+    case JVMTI_EVENT_SINGLE_STEP:\n+        return (\"JVMTI_EVENT_SINGLE_STEP\");\n+    case JVMTI_EVENT_FRAME_POP:\n+        return (\"JVMTI_EVENT_FRAME_POP\");\n+    case JVMTI_EVENT_BREAKPOINT:\n+        return (\"JVMTI_EVENT_BREAKPOINT\");\n+    case JVMTI_EVENT_FIELD_ACCESS:\n+        return (\"JVMTI_EVENT_FIELD_ACCESS\");\n+    case JVMTI_EVENT_FIELD_MODIFICATION:\n+        return (\"JVMTI_EVENT_FIELD_MODIFICATION\");\n+    case JVMTI_EVENT_METHOD_ENTRY:\n+        return (\"JVMTI_EVENT_METHOD_ENTRY\");\n+    case JVMTI_EVENT_METHOD_EXIT:\n+        return (\"JVMTI_EVENT_METHOD_EXIT\");\n+    case JVMTI_EVENT_NATIVE_METHOD_BIND:\n+        return (\"JVMTI_EVENT_NATIVE_METHOD_BIND\");\n+    case JVMTI_EVENT_COMPILED_METHOD_LOAD:\n+        return (\"JVMTI_EVENT_COMPILED_METHOD_LOAD\");\n+    case JVMTI_EVENT_COMPILED_METHOD_UNLOAD:\n+        return (\"JVMTI_EVENT_COMPILED_METHOD_UNLOAD\");\n+    case JVMTI_EVENT_DYNAMIC_CODE_GENERATED:\n+        return (\"JVMTI_EVENT_DYNAMIC_CODE_GENERATED\");\n+    case JVMTI_EVENT_DATA_DUMP_REQUEST:\n+        return (\"JVMTI_EVENT_DATA_DUMP_REQUEST\");\n+    case JVMTI_EVENT_MONITOR_WAIT:\n+        return (\"JVMTI_EVENT_MONITOR_WAIT\");\n+    case JVMTI_EVENT_MONITOR_WAITED:\n+        return (\"JVMTI_EVENT_MONITOR_WAITED\");\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTER:\n+        return (\"JVMTI_EVENT_MONITOR_CONTENDED_ENTER\");\n+    case JVMTI_EVENT_MONITOR_CONTENDED_ENTERED:\n+        return (\"JVMTI_EVENT_MONITOR_CONTENDED_ENTERED\");\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_START:\n+        return (\"JVMTI_EVENT_GARBAGE_COLLECTION_START\");\n+    case JVMTI_EVENT_GARBAGE_COLLECTION_FINISH:\n+        return (\"JVMTI_EVENT_GARBAGE_COLLECTION_FINISH\");\n+    case JVMTI_EVENT_OBJECT_FREE:\n+        return (\"JVMTI_EVENT_OBJECT_FREE\");\n+    case JVMTI_EVENT_VM_OBJECT_ALLOC:\n+        return (\"JVMTI_EVENT_VM_OBJECT_ALLOC\");\n+    default:\n+        return (\"<unknown event>\");\n+    }\n+}\n+\n+const char* TranslateError(jvmtiError err) {\n+    switch (err) {\n+    case JVMTI_ERROR_NONE:\n+        return (\"JVMTI_ERROR_NONE\");\n+    case JVMTI_ERROR_INVALID_THREAD:\n+        return (\"JVMTI_ERROR_INVALID_THREAD\");\n+    case JVMTI_ERROR_INVALID_THREAD_GROUP:\n+        return (\"JVMTI_ERROR_INVALID_THREAD_GROUP\");\n+    case JVMTI_ERROR_INVALID_PRIORITY:\n+        return (\"JVMTI_ERROR_INVALID_PRIORITY\");\n+    case JVMTI_ERROR_THREAD_NOT_SUSPENDED:\n+        return (\"JVMTI_ERROR_THREAD_NOT_SUSPENDED\");\n+    case JVMTI_ERROR_THREAD_SUSPENDED:\n+        return (\"JVMTI_ERROR_THREAD_SUSPENDED\");\n+    case JVMTI_ERROR_THREAD_NOT_ALIVE:\n+        return (\"JVMTI_ERROR_THREAD_NOT_ALIVE\");\n+    case JVMTI_ERROR_INVALID_OBJECT:\n+        return (\"JVMTI_ERROR_INVALID_OBJECT\");\n+    case JVMTI_ERROR_INVALID_CLASS:\n+        return (\"JVMTI_ERROR_INVALID_CLASS\");\n+    case JVMTI_ERROR_CLASS_NOT_PREPARED:\n+        return (\"JVMTI_ERROR_CLASS_NOT_PREPARED\");\n+    case JVMTI_ERROR_INVALID_METHODID:\n+        return (\"JVMTI_ERROR_INVALID_METHODID\");\n+    case JVMTI_ERROR_INVALID_LOCATION:\n+        return (\"JVMTI_ERROR_INVALID_LOCATION\");\n+    case JVMTI_ERROR_INVALID_FIELDID:\n+        return (\"JVMTI_ERROR_INVALID_FIELDID\");\n+    case JVMTI_ERROR_NO_MORE_FRAMES:\n+        return (\"JVMTI_ERROR_NO_MORE_FRAMES\");\n+    case JVMTI_ERROR_OPAQUE_FRAME:\n+        return (\"JVMTI_ERROR_OPAQUE_FRAME\");\n+    case JVMTI_ERROR_TYPE_MISMATCH:\n+        return (\"JVMTI_ERROR_TYPE_MISMATCH\");\n+    case JVMTI_ERROR_INVALID_SLOT:\n+        return (\"JVMTI_ERROR_INVALID_SLOT\");\n+    case JVMTI_ERROR_DUPLICATE:\n+        return (\"JVMTI_ERROR_DUPLICATE\");\n+    case JVMTI_ERROR_NOT_FOUND:\n+        return (\"JVMTI_ERROR_NOT_FOUND\");\n+    case JVMTI_ERROR_INVALID_MONITOR:\n+        return (\"JVMTI_ERROR_INVALID_MONITOR\");\n+    case JVMTI_ERROR_NOT_MONITOR_OWNER:\n+        return (\"JVMTI_ERROR_NOT_MONITOR_OWNER\");\n+    case JVMTI_ERROR_INTERRUPT:\n+        return (\"JVMTI_ERROR_INTERRUPT\");\n+    case JVMTI_ERROR_INVALID_CLASS_FORMAT:\n+        return (\"JVMTI_ERROR_INVALID_CLASS_FORMAT\");\n+    case JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION:\n+        return (\"JVMTI_ERROR_CIRCULAR_CLASS_DEFINITION\");\n+    case JVMTI_ERROR_FAILS_VERIFICATION:\n+        return (\"JVMTI_ERROR_FAILS_VERIFICATION\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_ADDED\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_SCHEMA_CHANGED\");\n+    case JVMTI_ERROR_INVALID_TYPESTATE:\n+        return (\"JVMTI_ERROR_INVALID_TYPESTATE\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_HIERARCHY_CHANGED\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_DELETED\");\n+    case JVMTI_ERROR_UNSUPPORTED_VERSION:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_VERSION\");\n+    case JVMTI_ERROR_NAMES_DONT_MATCH:\n+        return (\"JVMTI_ERROR_NAMES_DONT_MATCH\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_CLASS_MODIFIERS_CHANGED\");\n+    case JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED:\n+        return (\"JVMTI_ERROR_UNSUPPORTED_REDEFINITION_METHOD_MODIFIERS_CHANGED\");\n+    case JVMTI_ERROR_UNMODIFIABLE_CLASS:\n+        return (\"JVMTI_ERROR_UNMODIFIABLE_CLASS\");\n+    case JVMTI_ERROR_NOT_AVAILABLE:\n+        return (\"JVMTI_ERROR_NOT_AVAILABLE\");\n+    case JVMTI_ERROR_MUST_POSSESS_CAPABILITY:\n+        return (\"JVMTI_ERROR_MUST_POSSESS_CAPABILITY\");\n+    case JVMTI_ERROR_NULL_POINTER:\n+        return (\"JVMTI_ERROR_NULL_POINTER\");\n+    case JVMTI_ERROR_ABSENT_INFORMATION:\n+        return (\"JVMTI_ERROR_ABSENT_INFORMATION\");\n+    case JVMTI_ERROR_INVALID_EVENT_TYPE:\n+        return (\"JVMTI_ERROR_INVALID_EVENT_TYPE\");\n+    case JVMTI_ERROR_ILLEGAL_ARGUMENT:\n+        return (\"JVMTI_ERROR_ILLEGAL_ARGUMENT\");\n+    case JVMTI_ERROR_NATIVE_METHOD:\n+        return (\"JVMTI_ERROR_NATIVE_METHOD\");\n+    case JVMTI_ERROR_OUT_OF_MEMORY:\n+        return (\"JVMTI_ERROR_OUT_OF_MEMORY\");\n+    case JVMTI_ERROR_ACCESS_DENIED:\n+        return (\"JVMTI_ERROR_ACCESS_DENIED\");\n+    case JVMTI_ERROR_WRONG_PHASE:\n+        return (\"JVMTI_ERROR_WRONG_PHASE\");\n+    case JVMTI_ERROR_INTERNAL:\n+        return (\"JVMTI_ERROR_INTERNAL\");\n+    case JVMTI_ERROR_UNATTACHED_THREAD:\n+        return (\"JVMTI_ERROR_UNATTACHED_THREAD\");\n+    case JVMTI_ERROR_INVALID_ENVIRONMENT:\n+        return (\"JVMTI_ERROR_INVALID_ENVIRONMENT\");\n+    default:\n+        return (\"<unknown error>\");\n+    }\n+}\n+\n+const char* TranslatePhase(jvmtiPhase phase) {\n+    switch (phase) {\n+    case JVMTI_PHASE_ONLOAD:\n+        return (\"JVMTI_PHASE_ONLOAD\");\n+    case JVMTI_PHASE_PRIMORDIAL:\n+        return (\"JVMTI_PHASE_PRIMORDIAL\");\n+    case JVMTI_PHASE_START:\n+        return (\"JVMTI_PHASE_START\");\n+    case JVMTI_PHASE_LIVE:\n+        return (\"JVMTI_PHASE_LIVE\");\n+    case JVMTI_PHASE_DEAD:\n+        return (\"JVMTI_PHASE_DEAD\");\n+    default:\n+        return (\"<unknown phase>\");\n+    }\n+}\n+\n+const char* TranslateRootKind(jvmtiHeapRootKind root) {\n+    switch (root) {\n+    case JVMTI_HEAP_ROOT_JNI_GLOBAL:\n+        return (\"JVMTI_HEAP_ROOT_JNI_GLOBAL\");\n+    case JVMTI_HEAP_ROOT_JNI_LOCAL:\n+        return (\"JVMTI_HEAP_ROOT_JNI_LOCAL\");\n+    case JVMTI_HEAP_ROOT_SYSTEM_CLASS:\n+        return (\"JVMTI_HEAP_ROOT_SYSTEM_CLASS\");\n+    case JVMTI_HEAP_ROOT_MONITOR:\n+        return (\"JVMTI_HEAP_ROOT_MONITOR\");\n+    case JVMTI_HEAP_ROOT_STACK_LOCAL:\n+        return (\"JVMTI_HEAP_ROOT_STACK_LOCAL\");\n+    case JVMTI_HEAP_ROOT_THREAD:\n+        return (\"JVMTI_HEAP_ROOT_THREAD\");\n+    case JVMTI_HEAP_ROOT_OTHER:\n+        return (\"JVMTI_HEAP_ROOT_OTHER\");\n+    default:\n+        return (\"<unknown root kind>\");\n+    }\n+}\n+\n+const char* TranslateObjectRefKind(jvmtiObjectReferenceKind ref) {\n+    switch (ref) {\n+    case JVMTI_REFERENCE_CLASS:\n+        return (\"JVMTI_REFERENCE_CLASS\");\n+    case JVMTI_REFERENCE_FIELD:\n+        return (\"JVMTI_REFERENCE_FIELD\");\n+    case JVMTI_REFERENCE_ARRAY_ELEMENT:\n+        return (\"JVMTI_REFERENCE_ARRAY_ELEMENT\");\n+    case JVMTI_REFERENCE_CLASS_LOADER:\n+        return (\"JVMTI_REFERENCE_CLASS_LOADER\");\n+    case JVMTI_REFERENCE_SIGNERS:\n+        return (\"JVMTI_REFERENCE_SIGNERS\");\n+    case JVMTI_REFERENCE_PROTECTION_DOMAIN:\n+        return (\"JVMTI_REFERENCE_PROTECTION_DOMAIN\");\n+    case JVMTI_REFERENCE_INTERFACE:\n+        return (\"JVMTI_REFERENCE_INTERFACE\");\n+    case JVMTI_REFERENCE_STATIC_FIELD:\n+        return (\"JVMTI_REFERENCE_STATIC_FIELD\");\n+    case JVMTI_REFERENCE_CONSTANT_POOL:\n+        return (\"JVMTI_REFERENCE_CONSTANT_POOL\");\n+    default:\n+        return (\"<unknown reference kind>\");\n+    }\n+}\n+\n+}\n+\n+#endif\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_common.h","additions":380,"deletions":0,"binary":false,"changes":380,"status":"added"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef JVMTI_THREAD_H\n+#define JVMTI_THREAD_H\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdarg.h>\n+#include <string.h>\n+#include <ctype.h>\n+\n+\n+\n+#ifdef _WIN32\n+\n+#define LL \"I64\"\n+#include <STDDEF.H>\n+\n+#else \/\/ !_WIN32\n+\n+#include <stdint.h>\n+\n+#ifdef _LP64\n+#define LL \"l\"\n+#else\n+#define LL \"ll\"\n+#endif\n+\n+#endif \/\/ !_WIN32\n+\n+\n+extern \"C\" {\n+\n+\n+#define NSK_STATUS_PASSED       0\n+#define NSK_STATUS_FAILED       2\n+\n+static jvmtiEnv* agent_jvmti_env = NULL;\n+static JNIEnv* agent_jni_env = NULL;\n+\n+static volatile int currentAgentStatus = NSK_STATUS_PASSED;\n+\n+static jthread agentThread = NULL;\n+static jvmtiStartFunction agentThreadProc = NULL;\n+static void* agentThreadArg = NULL;\n+\n+void nsk_jvmti_setFailStatus() {\n+  currentAgentStatus = NSK_STATUS_FAILED;\n+}\n+\n+jint nsk_jvmti_getStatus() {\n+  return currentAgentStatus;\n+}\n+\n+typedef enum { NEW, RUNNABLE, WAITING, SUSPENDED, TERMINATED } thread_state_t;\n+\n+typedef struct agent_data_t {\n+  volatile thread_state_t thread_state;\n+  int last_debuggee_status;\n+  jrawMonitorID monitor;\n+} agent_data_t;\n+\n+int nsk_jvmti_setAgentProc(jvmtiStartFunction proc, void* arg) {\n+  agentThreadProc = proc;\n+  agentThreadArg = arg;\n+  return NSK_TRUE;\n+}\n+\n+static agent_data_t agent_data;\n+\n+\n+static jvmtiError init_agent_data(jvmtiEnv *jvmti_env, agent_data_t *data) {\n+  data->thread_state = NEW;\n+  data->last_debuggee_status = NSK_STATUS_PASSED;\n+  agent_jvmti_env = jvmti_env;\n+  return jvmti_env->CreateRawMonitor(\"agent_data_monitor\", &data->monitor);\n+}\n+\n+jint createRawMonitor(jvmtiEnv *env, const char *name, jrawMonitorID *monitor) {\n+  jvmtiError error = env->CreateRawMonitor(name, monitor);\n+  if (error != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  return JNI_OK;\n+}\n+\n+void exitOnError(jvmtiError error) {\n+  if (error != JVMTI_ERROR_NONE) {\n+    exit(error);\n+  }\n+}\n+\n+void rawMonitorEnter(jvmtiEnv *env, jrawMonitorID monitor) {\n+  jvmtiError error = env->RawMonitorEnter(monitor);\n+  exitOnError(error);\n+}\n+\n+void rawMonitorExit(jvmtiEnv *env, jrawMonitorID monitor) {\n+  jvmtiError error = env->RawMonitorExit(monitor);\n+  exitOnError(error);\n+}\n+\n+void rawMonitorNotify(jvmtiEnv *env, jrawMonitorID monitor) {\n+  jvmtiError error = env->RawMonitorNotify(monitor);\n+  exitOnError(error);\n+}\n+\n+void rawMonitorWait(jvmtiEnv *env, jrawMonitorID monitor, jlong millis) {\n+  jvmtiError error = env->RawMonitorWait(monitor, millis);\n+  exitOnError(error);\n+}\n+\n+\n+\/** Wait for sync point with Java code. *\/\n+int nsk_jvmti_waitForSync(jlong timeout) {\n+  static const int inc_timeout = 1000;\n+\n+  jlong t = 0;\n+  int result = NSK_TRUE;\n+\n+  rawMonitorEnter(agent_jvmti_env, agent_data.monitor);\n+\n+  agent_data.thread_state = WAITING;\n+\n+  \/* SP2.2-n - notify agent is waiting and wait *\/\n+  \/* SP4.1-n - notify agent is waiting and wait *\/\n+  rawMonitorNotify(agent_jvmti_env, agent_data.monitor);\n+\n+  while (agent_data.thread_state == WAITING) {\n+    \/* SP3.2-w - wait to start test *\/\n+    \/* SP6.2-w - wait to end test *\/\n+    rawMonitorWait(agent_jvmti_env, agent_data.monitor, inc_timeout);\n+\n+    if (timeout == 0) continue;\n+\n+    t += inc_timeout;\n+\n+    if (t >= timeout) break;\n+  }\n+\n+  if (agent_data.thread_state == WAITING) {\n+      NSK_COMPLAIN1(\"No status sync occured for timeout: %\" LL \"d ms\\n\", timeout);\n+    nsk_jvmti_setFailStatus();\n+    result = NSK_FALSE;\n+  }\n+\n+  rawMonitorExit(agent_jvmti_env, agent_data.monitor);\n+\n+  return result;\n+}\n+\n+\/** Resume java code suspended on sync point. *\/\n+int nsk_jvmti_resumeSync() {\n+  int result;\n+  rawMonitorEnter(agent_jvmti_env, agent_data.monitor);\n+\n+  if (agent_data.thread_state == SUSPENDED) {\n+    result = NSK_TRUE;\n+    agent_data.thread_state = RUNNABLE;\n+    \/* SP5.2-n - notify suspend done *\/\n+    \/* SP7.2-n - notify agent end *\/\n+    rawMonitorNotify(agent_jvmti_env, agent_data.monitor);\n+  }\n+  else {\n+    NSK_COMPLAIN0(\"Debuggee was not suspended on status sync\\n\");\n+    nsk_jvmti_setFailStatus();\n+    result = NSK_FALSE;\n+  }\n+\n+  rawMonitorExit(agent_jvmti_env, agent_data.monitor);\n+  return NSK_TRUE;\n+}\n+\n+\/* ============================================================================= *\/\n+static void set_agent_thread_state(thread_state_t value) {\n+  rawMonitorEnter(agent_jvmti_env, agent_data.monitor);\n+  agent_data.thread_state = value;\n+  rawMonitorNotify(agent_jvmti_env, agent_data.monitor);\n+  rawMonitorExit(agent_jvmti_env, agent_data.monitor);\n+}\n+\n+\/** Wrapper for user agent thread. *\/\n+static void JNICALL\n+agentThreadWrapper(jvmtiEnv* jvmti_env, JNIEnv* agentJNI, void* arg) {\n+  agent_jni_env = agentJNI;\n+\n+  \/* run user agent proc *\/\n+  {\n+    set_agent_thread_state(RUNNABLE);\n+\n+    \/\/ TODO was NSK_TRACE\n+    (*agentThreadProc)(jvmti_env, agentJNI, agentThreadArg);\n+\n+    set_agent_thread_state(TERMINATED);\n+  }\n+\n+  \/* finalize agent thread *\/\n+  {\n+    \/* gelete global ref for agent thread *\/\n+    agentJNI->DeleteGlobalRef(agentThread);\n+    agentThread = NULL;\n+  }\n+}\n+\n+\n+\/** Start wrapper for user agent thread. *\/\n+static jthread startAgentThreadWrapper(JNIEnv *jni_env, jvmtiEnv* jvmti_env) {\n+  const jint  THREAD_PRIORITY = JVMTI_THREAD_MAX_PRIORITY;\n+  const char* THREAD_NAME = \"JVMTI agent thread\";\n+  const char* THREAD_CLASS_NAME = \"java\/lang\/Thread\";\n+  const char* THREAD_CTOR_NAME = \"<init>\";\n+  const char* THREAD_CTOR_SIGNATURE = \"(Ljava\/lang\/String;)V\";\n+\n+  jobject threadName = NULL;\n+  jclass threadClass = NULL;\n+  jmethodID threadCtor = NULL;\n+  jobject threadObject = NULL;\n+  jobject threadGlobalRef = NULL;\n+  jvmtiError err;\n+\n+  threadClass = jni_env->FindClass(THREAD_CLASS_NAME);\n+  if (threadClass == NULL) {\n+    return NULL;\n+  }\n+\n+  threadCtor = jni_env->GetMethodID(threadClass, THREAD_CTOR_NAME, THREAD_CTOR_SIGNATURE);\n+  if (threadCtor == NULL) {\n+    return NULL;\n+  }\n+\n+  threadName = jni_env->NewStringUTF(THREAD_NAME);\n+  if (threadName == NULL) {\n+    return NULL;\n+  }\n+\n+  threadObject = jni_env->NewObject(threadClass, threadCtor, threadName);\n+  if (threadObject == NULL) {\n+    return NULL;\n+  }\n+\n+  threadGlobalRef = jni_env->NewGlobalRef(threadObject);\n+  if (threadGlobalRef == NULL) {\n+    jni_env->DeleteLocalRef(threadObject);\n+    return NULL;\n+  }\n+  agentThread = (jthread)threadGlobalRef;\n+\n+  err = jvmti_env->RunAgentThread(agentThread, &agentThreadWrapper, agentThreadArg, THREAD_PRIORITY);\n+  if (err != JVMTI_ERROR_NONE) {\n+    jni_env->DeleteGlobalRef(threadGlobalRef);\n+    jni_env->DeleteLocalRef(threadObject);\n+    return NULL;\n+  }\n+  return agentThread;\n+}\n+\n+\/** Run registered user agent thread via wrapper. *\/\n+static jthread nsk_jvmti_runAgentThread(JNIEnv *jni_env, jvmtiEnv* jvmti_env) {\n+  \/* start agent thread wrapper *\/\n+  jthread thread = startAgentThreadWrapper(jni_env, jvmti_env);\n+  if (thread == NULL) {\n+    nsk_jvmti_setFailStatus();\n+    return NULL;\n+  }\n+\n+  return thread;\n+}\n+\n+\/** Sync point called from Java code. *\/\n+static jint syncDebuggeeStatus(JNIEnv* jni_env, jvmtiEnv* jvmti_env, jint debuggeeStatus) {\n+  jint result = NSK_STATUS_FAILED;\n+\n+  printf(\"Data %p %p\\n\", jvmti_env, agent_data.monitor);\n+  rawMonitorEnter(jvmti_env, agent_data.monitor);\n+\n+  \/* save last debugee status *\/\n+  agent_data.last_debuggee_status = debuggeeStatus;\n+\n+  \/* we don't enter if-stmt in second call *\/\n+  if (agent_data.thread_state == NEW) {\n+    if (nsk_jvmti_runAgentThread(jni_env, jvmti_env) == NULL)\n+      goto monitor_exit_and_return;\n+\n+    \/* SP2.2-w - wait for agent thread *\/\n+    while (agent_data.thread_state == NEW) {\n+      rawMonitorWait(jvmti_env, agent_data.monitor, 0);\n+    }\n+  }\n+\n+  \/* wait for sync permit *\/\n+  \/* we don't enter loop in first call *\/\n+  while (agent_data.thread_state != WAITING && agent_data.thread_state != TERMINATED) {\n+    \/* SP4.2-w - second wait for agent thread *\/\n+    rawMonitorWait(jvmti_env, agent_data.monitor, 0);\n+  }\n+\n+  if (agent_data.thread_state != TERMINATED) {\n+    agent_data.thread_state = SUSPENDED;\n+    \/* SP3.2-n - notify to start test *\/\n+    \/* SP6.2-n - notify to end test *\/\n+    rawMonitorNotify(jvmti_env, agent_data.monitor);\n+  } else {\n+    NSK_COMPLAIN0(\"Debuggee status sync aborted because agent thread has finished\\n\");\n+    goto monitor_exit_and_return;\n+  }\n+\n+  \/* update status from debuggee *\/\n+  if (debuggeeStatus != NSK_STATUS_PASSED) {\n+    printf(\"FAIL: Status is %d\\n\", debuggeeStatus);\n+    nsk_jvmti_setFailStatus();\n+  }\n+\n+  while (agent_data.thread_state == SUSPENDED) {\n+    \/* SP5.2-w - wait while testing *\/\n+    \/* SP7.2 - wait for agent end *\/\n+    rawMonitorWait(jvmti_env, agent_data.monitor, 0);\n+  }\n+\n+  agent_data.last_debuggee_status = nsk_jvmti_getStatus();\n+  result = agent_data.last_debuggee_status;\n+\n+  monitor_exit_and_return:\n+  rawMonitorExit(jvmti_env, agent_data.monitor);\n+  return result;\n+}\n+\n+\/** Native function for Java code to provide sync point. *\/\n+JNIEXPORT jint JNICALL\n+Java_jdk_test_lib_jvmti_DebugeeClass_checkStatus(JNIEnv* jni_env, jclass cls, jint debuggeeStatus) {\n+  jint status;\n+  \/\/ TODO NSK_TRACE\n+  status = syncDebuggeeStatus(jni_env, agent_jvmti_env, debuggeeStatus);\n+  return status;\n+}\n+\n+}\n+\n+#endif\n","filename":"test\/lib\/jdk\/test\/lib\/jvmti\/jvmti_thread.h","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"}]}