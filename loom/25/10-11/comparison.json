{"files":[{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.ArrayList;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.locks.LockSupport;\n-\n-\n-\/*\n- * @test\n- * @library \/test\/lib\n- * @run main\/othervm\/native -agentlib:MethodExitVThread MethodExitVThreadTest\n- *\/\n-\n-public class MethodExitVThreadTest {\n-\n-    static {\n-        try {\n-            System.loadLibrary(\"MethodExitVThread\");\n-        } catch (UnsatisfiedLinkError ule) {\n-            System.err.println(\"Could not load MethodExitVThread library\");\n-            System.err.println(\"java.library.path:\" + System.getProperty(\"java.library.path\"));\n-            throw ule;\n-        }\n-    }\n-\n-    final static AtomicInteger result = new AtomicInteger(0);\n-    native static int check();\n-    native static int init0();\n-\n-    final static long NUM_OF_TASKS = 100_000;\n-    public static void main(String args[]) throws InterruptedException {\n-\n-        ArrayList<Thread> threads = new ArrayList<>();\n-        for (int i = 0; i < NUM_OF_TASKS; i++) {\n-            Runnable task = new Task();\n-            \/\/Thread tested = Thread.newThread(\"tested\", Thread.VIRTUAL, task);\n-            Thread thread = new Thread(task, \"tested\");\n-            threads.add(thread);\n-            thread.start();\n-        }\n-\n-        for (Thread thread: threads) {\n-            thread.join();\n-        }\n-        \/*\n-        if (result.get() != NUM_OF_TASKS * 3) {\n-            throw new RuntimeException(\"Check() returned \" + result);\n-        }\n-        *\/\n-    }\n-\n-    static void method1() {\n-\n-    }\n-\n-    static void method2() {\n-\n-    }\n-\n-    static class Task implements Runnable {\n-\n-        @Override\n-        public void run() {\n-            init0();\n-            method1();\n-            LockSupport.parkNanos(10);\n-            method2();\n-            result.addAndGet(check());\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/vthread\/MethodExitVThreadTest.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,243 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdio.h>\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-\n-extern \"C\" {\n-\n-\n-#define PASSED 0\n-#define STATUS_FAILED 2\n-\n-typedef struct {\n-  const char *cls_sig;\n-  const char *name;\n-  const char *sig;\n-  jlocation loc;\n-} method_location_info;\n-\n-static jvmtiEnv *jvmti = NULL;\n-static jvmtiCapabilities caps;\n-static jvmtiEventCallbacks callbacks;\n-static jint result = PASSED;\n-static jboolean printdump = JNI_TRUE;\n-static jint eventsCount = 0;\n-\n-\n-static method_location_info expected_exits[] = {\n-    { \"LMethodExitVThreadTest;\", \"init0\", \"()I\", -1 },\n-    { \"LMethodExitVThreadTest;\", \"method1\", \"()V\", 0 },\n-    { \"LMethodExitVThreadTest;\", \"method2\", \"()V\", 0 }\n-};\n-\n-void JNICALL MethodExit(jvmtiEnv *jvmti, JNIEnv *jni,\n-                        jthread thr, jmethodID method,\n-                        jboolean was_poped_by_exc, jvalue return_value) {\n-  jvmtiError err;\n-  char *cls_sig, *name, *sig, *generic;\n-  jclass cls;\n-  jmethodID mid;\n-  jlocation loc;\n-  char buffer[32];\n-\n-  err = jvmti->GetMethodDeclaringClass(method, &cls);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetMethodDeclaringClass) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  err = jvmti->GetClassSignature(cls, &cls_sig, &generic);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetClassSignature) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    result = STATUS_FAILED;\n-    return;\n-  }\n-  if (cls_sig != NULL && strcmp(cls_sig, \"LMethodExitVThreadTest;\") == 0) {\n-    if (printdump == JNI_TRUE) {\n-      printf(\">>> retrieving method exit info ...\\n\");\n-    }\n-    err = jvmti->GetMethodName(method,\n-                                   &name, &sig, &generic);\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"(GetMethodName) unexpected error: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      result = STATUS_FAILED;\n-      return;\n-    }\n-    err = jvmti->GetFrameLocation(thr, 0, &mid, &loc);\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"(GetFrameLocation) unexpected error: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      result = STATUS_FAILED;\n-      return;\n-    }\n-    if (printdump == JNI_TRUE) {\n-      printf(\">>>      class: \\\"%s\\\"\\n\", cls_sig);\n-      printf(\">>>     method: \\\"%s%s\\\"\\n\", name, sig);\n-      printf(\">>>   location: %s\\n\", jlong_to_string(loc, buffer));\n-      printf(\">>> ... done\\n\");\n-    }\n-    \/*\n-    if (cls_sig == NULL ||\n-        strcmp(cls_sig, expected_exits[eventsCount].cls_sig) != 0) {\n-      printf(\"(exit#%\" PRIuPTR \") wrong class: \\\"%s\\\"\",\n-             eventsCount, cls_sig);\n-      printf(\", expected: \\\"%s\\\"\\n\", expected_exits[eventsCount].cls_sig);\n-      result = STATUS_FAILED;\n-    }\n-    if (name == NULL ||\n-        strcmp(name, expected_exits[eventsCount].name) != 0) {\n-      printf(\"(exit#%\" PRIuPTR \") wrong method name: \\\"%s\\\"\",\n-             eventsCount, name);\n-      printf(\", expected: \\\"%s\\\"\\n\", expected_exits[eventsCount].name);\n-      result = STATUS_FAILED;\n-    }\n-    if (sig == NULL ||\n-        strcmp(sig, expected_exits[eventsCount].sig) != 0) {\n-      printf(\"(exit#%\" PRIuPTR \") wrong method sig: \\\"%s\\\"\",\n-             eventsCount, sig);\n-      printf(\", expected: \\\"%s\\\"\\n\", expected_exits[eventsCount].sig);\n-      result = STATUS_FAILED;\n-    }\n-    if (loc != expected_exits[eventsCount].loc) {\n-      printf(\"(exit#%\" PRIuPTR \") wrong location: %s\",\n-             eventsCount, jlong_to_string(loc, buffer));\n-      printf(\", expected: %s\\n\",\n-             jlong_to_string(expected_exits[eventsCount].loc, buffer));\n-      result = STATUS_FAILED;\n-    }*\/\n-    eventsCount++;\n-  }\n-}\n-\n-jint Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  jvmtiError err;\n-  jint res;\n-\n-  if (options != NULL && strcmp(options, \"printdump\") == 0) {\n-    printdump = JNI_TRUE;\n-  }\n-\n-  res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_1_1);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    printf(\"Wrong result of a valid call to GetEnv!\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  memset(&caps, 0, sizeof(caps));\n- \/\/ caps.can_support_virtual_threads = 1;\n-  caps.can_generate_method_exit_events = 1;\n-\n-  err = jvmti->AddCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(AddCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  err = jvmti->GetCapabilities(&caps);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"(GetCapabilities) unexpected error: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    return JNI_ERR;\n-  }\n-\n-  if (caps.can_generate_method_exit_events) {\n-    callbacks.MethodExit = &MethodExit;\n-    err = jvmti->SetEventCallbacks(&callbacks, sizeof(callbacks));\n-    if (err != JVMTI_ERROR_NONE) {\n-      printf(\"(SetEventCallbacks) unexpected error: %s (%d)\\n\",\n-             TranslateError(err), err);\n-      return JNI_ERR;\n-    }\n-  } else {\n-    printf(\"Warning: MethodExit event is not implemented\\n\");\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_MethodExitVThreadTest_init0(JNIEnv *jni, jclass cls) {\n-  jvmtiError err;\n-  jthread thread;\n-  if (jvmti == NULL) {\n-    jni->FatalError(\"JVMTI client was not properly loaded!\");\n-  }\n-\n-\n-  err = jvmti->GetCurrentThread(&thread);\n-  if (err != JVMTI_ERROR_NONE) {\n-    jni->FatalError(\"Error in GetCurrentThread.\");\n-  }\n-\n-\n-  err = jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n-                                        JVMTI_EVENT_METHOD_EXIT, thread);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    jni->FatalError(\"Failed to enable JVMTI_EVENT_METHOD_EXIT event.\");\n-  }\n-\n-  \/\/ TODO: should we return result instead?\n-  return PASSED;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_MethodExitVThreadTest_check(JNIEnv *jni, jclass cls) {\n-  jvmtiError err;\n-  jthread thread;\n-\n-  if (jvmti == NULL) {\n-    jni->FatalError(\"JVMTI client was not properly loaded!\");\n-  }\n-\n-  if (!caps.can_generate_method_exit_events) {\n-    jni->FatalError(\"Error method exit is not supported.\");\n-  }\n-\n-  err = jvmti->GetCurrentThread(&thread);\n-  if (err != JVMTI_ERROR_NONE) {\n-    jni->FatalError(\"Error in GetCurrentThread.\");\n-  }\n-\n-\n-  err = jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n-                                        JVMTI_EVENT_METHOD_EXIT, thread);\n-  if (err != JVMTI_ERROR_NONE) {\n-    printf(\"Failed to disable JVMTI_EVENT_METHOD_EXIT event: %s (%d)\\n\",\n-           TranslateError(err), err);\n-    jni->FatalError(\"Failed to disable JVMTI_EVENT_METHOD_EXIT event.\");\n-  }\n-  return eventsCount;\n-}\n-\n-\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/events\/MethodExit\/vthread\/libMethodExitVThread.cpp","additions":0,"deletions":243,"binary":false,"changes":243,"status":"deleted"}]}