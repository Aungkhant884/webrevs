{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -73,1 +74,1 @@\n-intptr_t* ContinuationEntry::entry_fp() const {\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n@@ -77,1 +78,1 @@\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n@@ -96,1 +97,1 @@\n-void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* entry) {\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* entry) {\n@@ -101,1 +102,1 @@\n-void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n","filename":"src\/hotspot\/cpu\/aarch64\/continuationHelper_aarch64.inline.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -36,1 +37,1 @@\n-frame ContinuationEntry::to_frame() const {\n+inline frame ContinuationEntry::to_frame() const {\n@@ -41,1 +42,1 @@\n-intptr_t* ContinuationEntry::entry_fp() const {\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n@@ -46,1 +47,1 @@\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n","filename":"src\/hotspot\/cpu\/arm\/continuationHelper_arm.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -36,1 +37,1 @@\n-frame ContinuationEntry::to_frame() const {\n+inline frame ContinuationEntry::to_frame() const {\n@@ -41,1 +42,1 @@\n-intptr_t* ContinuationEntry::entry_fp() const {\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n@@ -46,1 +47,1 @@\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n","filename":"src\/hotspot\/cpu\/ppc\/continuationHelper_ppc.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -36,1 +37,1 @@\n-frame ContinuationEntry::to_frame() const {\n+inline frame ContinuationEntry::to_frame() const {\n@@ -41,1 +42,1 @@\n-intptr_t* ContinuationEntry::entry_fp() const {\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n@@ -46,1 +47,1 @@\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n","filename":"src\/hotspot\/cpu\/s390\/continuationHelper_s390.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -62,1 +63,1 @@\n-intptr_t* ContinuationEntry::entry_fp() const {\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n@@ -66,1 +67,1 @@\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n@@ -79,1 +80,1 @@\n-void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* entry) {\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* entry) {\n@@ -84,1 +85,1 @@\n-void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+inline void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n","filename":"src\/hotspot\/cpu\/x86\/continuationHelper_x86.inline.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/continuation_x86.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -36,1 +37,1 @@\n-frame ContinuationEntry::to_frame() const {\n+inline frame ContinuationEntry::to_frame() const {\n@@ -41,1 +42,1 @@\n-intptr_t* ContinuationEntry::entry_fp() const {\n+inline intptr_t* ContinuationEntry::entry_fp() const {\n@@ -46,1 +47,1 @@\n-void ContinuationEntry::update_register_map(RegisterMap* map) const {\n+inline void ContinuationEntry::update_register_map(RegisterMap* map) const {\n","filename":"src\/hotspot\/cpu\/zero\/continuationHelper_zero.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stacktrace\/jfrStackTrace.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/share\/prims\/stackwalk.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -49,0 +50,1 @@\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n@@ -233,6 +235,0 @@\n-static oop get_continuation(JavaThread* thread) {\n-  assert(thread != nullptr, \"\");\n-  assert(thread->threadObj() != nullptr, \"\");\n-  return java_lang_Thread::continuation(thread->threadObj());\n-}\n-\n@@ -278,246 +274,0 @@\n-NOINLINE static void flush_stack_processing(JavaThread* thread, intptr_t* sp) {\n-  log_develop_trace(continuations)(\"flush_stack_processing\");\n-  for (StackFrameStream fst(thread, true, true); fst.current()->sp() <= sp; fst.next()) {\n-    ;\n-  }\n-}\n-\n-inline void maybe_flush_stack_processing(JavaThread* thread, intptr_t* sp) {\n-  StackWatermark* sw;\n-  uintptr_t watermark;\n-  if ((sw = StackWatermarkSet::get(thread, StackWatermarkKind::gc)) != nullptr\n-        && (watermark = sw->watermark()) != 0\n-        && watermark <= (uintptr_t)sp) {\n-    flush_stack_processing(thread, sp);\n-  }\n-}\n-\n-inline void maybe_flush_stack_processing(JavaThread* thread, const ContinuationEntry* entry) {\n-  maybe_flush_stack_processing(thread, (intptr_t*)((uintptr_t)entry->entry_sp() + ContinuationEntry::size()));\n-}\n-\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\/\/ Intermediary to the jdk.internal.vm.Continuation objects and ContinuationEntry\n-\/\/ This object is created when we begin a operation for a continuation, and is destroyed when the operation completes.\n-\/\/ Contents are read from the Java object at the entry points of this module, and written at exit or calls into Java\n-\/\/ It also serves as a custom NoSafepointVerifier\n-class ContinuationWrapper : public StackObj {\n-private:\n-  JavaThread* const  _thread;   \/\/ Thread being frozen\/thawed\n-  ContinuationEntry* _entry;\n-  \/\/ These oops are managed by SafepointOp\n-  oop                _continuation;  \/\/ jdk.internal.vm.Continuation instance\n-  stackChunkOop      _tail;\n-\n-#if CONT_JFR \/\/ Profiling data for the JFR event\n-  short _e_size;\n-  short _e_num_interpreted_frames;\n-#endif\n-\n-  ContinuationWrapper(const ContinuationWrapper& cont); \/\/ no copy constructor\n-\n-private:\n-  DEBUG_ONLY(Thread* _current_thread;)\n-  friend class SafepointOp;\n-\n-  void disallow_safepoint() {\n-    #ifdef ASSERT\n-      assert(_continuation != nullptr, \"\");\n-      _current_thread = Thread::current();\n-      if (_current_thread->is_Java_thread()) {\n-        JavaThread::cast(_current_thread)->inc_no_safepoint_count();\n-      }\n-    #endif\n-  }\n-\n-  void allow_safepoint() {\n-    #ifdef ASSERT\n-      \/\/ we could have already allowed safepoints in done\n-      if (_continuation != nullptr && _current_thread->is_Java_thread()) {\n-        JavaThread::cast(_current_thread)->dec_no_safepoint_count();\n-      }\n-    #endif\n-  }\n-\n-public:\n-  void done() {\n-    allow_safepoint(); \/\/ must be done first\n-    _continuation = nullptr;\n-    _tail = (stackChunkOop)badOop;\n-  }\n-\n-  class SafepointOp : public StackObj {\n-    ContinuationWrapper& _cont;\n-    Handle _conth;\n-  public:\n-    SafepointOp(Thread* current, ContinuationWrapper& cont)\n-      : _cont(cont), _conth(current, cont._continuation) {\n-      _cont.allow_safepoint();\n-    }\n-    ~SafepointOp() { \/\/ reload oops\n-      _cont._continuation = _conth();\n-      if (_cont._tail != nullptr) {\n-        _cont._tail = jdk_internal_vm_Continuation::tail(_cont._continuation);\n-      }\n-      _cont.disallow_safepoint();\n-    }\n-  };\n-\n-public:\n-  ~ContinuationWrapper() { allow_safepoint(); }\n-\n-  ContinuationWrapper(JavaThread* thread, oop continuation);\n-  ContinuationWrapper(oop continuation);\n-  ContinuationWrapper(const RegisterMap* map);\n-\n-  JavaThread* thread() const         { return _thread; }\n-  oop continuation()                 { return _continuation; }\n-  stackChunkOop tail() const         { return _tail; }\n-  void set_tail(stackChunkOop chunk) { _tail = chunk; }\n-\n-  oop parent()                   { return jdk_internal_vm_Continuation::parent(_continuation); }\n-  bool is_preempted()            { return jdk_internal_vm_Continuation::is_preempted(_continuation); }\n-  void set_preempted(bool value) { jdk_internal_vm_Continuation::set_preempted(_continuation, value); }\n-  void read()                    { _tail  = jdk_internal_vm_Continuation::tail(_continuation); }\n-  void write() {\n-    assert(oopDesc::is_oop(_continuation), \"bad oop\");\n-    assert(oopDesc::is_oop_or_null(_tail), \"bad oop\");\n-    jdk_internal_vm_Continuation::set_tail(_continuation, _tail);\n-  }\n-\n-  NOT_PRODUCT(intptr_t hash()    { return Thread::current()->is_Java_thread() ? _continuation->identity_hash() : -1; })\n-\n-  ContinuationEntry* entry() const { return _entry; }\n-  bool is_mounted()   const { return _entry != nullptr; }\n-  intptr_t* entrySP() const { return _entry->entry_sp(); }\n-  intptr_t* entryFP() const { return _entry->entry_fp(); }\n-  address   entryPC() const { return _entry->entry_pc(); }\n-  int argsize()       const { assert(_entry->argsize() >= 0, \"\"); return _entry->argsize(); }\n-  void set_argsize(int value) { _entry->set_argsize(value); }\n-\n-  bool is_empty() const { return last_nonempty_chunk() == nullptr; }\n-  const frame last_frame();\n-\n-  stackChunkOop last_nonempty_chunk() const { return nonempty_chunk(_tail); }\n-  inline stackChunkOop nonempty_chunk(stackChunkOop chunk) const;\n-  stackChunkOop find_chunk_by_address(void* p) const;\n-\n-#if CONT_JFR\n-  inline void record_interpreted_frame() { _e_num_interpreted_frames++; }\n-  inline void record_size_copied(int size) { _e_size += size << LogBytesPerWord; }\n-  template<typename Event> void post_jfr_event(Event *e, JavaThread* jt);\n-#endif\n-\n-#ifdef ASSERT\n-  inline bool is_entry_frame(const frame& f);\n-  bool chunk_invariant(outputStream* st);\n-#endif\n-};\n-\n-ContinuationWrapper::ContinuationWrapper(JavaThread* thread, oop continuation)\n-  : _thread(thread), _entry(thread->last_continuation()), _continuation(continuation)\n-#if CONT_JFR\n-  , _e_size(0), _e_num_interpreted_frames(0)\n-#endif\n-  {\n-  assert(oopDesc::is_oop(_continuation),\n-         \"Invalid continuation object: \" INTPTR_FORMAT, p2i((void*)_continuation));\n-  assert(_continuation == _entry->cont_oop(), \"cont: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \"\n-         INTPTR_FORMAT, p2i((oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n-  disallow_safepoint();\n-  read();\n-}\n-\n-ContinuationWrapper::ContinuationWrapper(oop continuation)\n-  : _thread(nullptr), _entry(nullptr), _continuation(continuation)\n-#if CONT_JFR\n-  , _e_size(0), _e_num_interpreted_frames(0)\n-#endif\n-  {\n-  assert(oopDesc::is_oop(_continuation),\n-         \"Invalid continuation object: \" INTPTR_FORMAT, p2i((void*)_continuation));\n-  disallow_safepoint();\n-  read();\n-}\n-\n-ContinuationWrapper::ContinuationWrapper(const RegisterMap* map)\n-  : _thread(map->thread()),\n-    _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())),\n-    _continuation(map->stack_chunk()->cont())\n-#if CONT_JFR\n-  , _e_size(0), _e_num_interpreted_frames(0)\n-#endif\n-  {\n-  assert(oopDesc::is_oop(_continuation),\"Invalid cont: \" INTPTR_FORMAT, p2i((void*)_continuation));\n-  assert(_entry == nullptr || _continuation == _entry->cont_oop(),\n-    \"cont: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \" INTPTR_FORMAT,\n-    p2i( (oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n-  disallow_safepoint();\n-  read();\n-}\n-\n-const frame ContinuationWrapper::last_frame() {\n-  stackChunkOop chunk = last_nonempty_chunk();\n-  if (chunk == nullptr) {\n-    return frame();\n-  }\n-  return StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame();\n-}\n-\n-inline stackChunkOop ContinuationWrapper::nonempty_chunk(stackChunkOop chunk) const {\n-  while (chunk != nullptr && chunk->is_empty()) {\n-    chunk = chunk->parent();\n-  }\n-  return chunk;\n-}\n-\n-stackChunkOop ContinuationWrapper::find_chunk_by_address(void* p) const {\n-  for (stackChunkOop chunk = tail(); chunk != nullptr; chunk = chunk->parent()) {\n-    if (chunk->is_in_chunk(p)) {\n-      assert(chunk->is_usable_in_chunk(p), \"\");\n-      return chunk;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-#if CONT_JFR\n-template<typename Event> void ContinuationWrapper::post_jfr_event(Event* e, JavaThread* jt) {\n-  if (e->should_commit()) {\n-    log_develop_trace(continuations)(\"JFR event: iframes: %d size: %d\", _e_num_interpreted_frames, _e_size);\n-    e->set_carrierThread(JFR_JVM_THREAD_ID(jt));\n-    e->set_contClass(_continuation->klass());\n-    e->set_numIFrames(_e_num_interpreted_frames);\n-    e->set_size(_e_size);\n-    e->commit();\n-  }\n-}\n-#endif\n-\n-#ifdef ASSERT\n-inline bool ContinuationWrapper::is_entry_frame(const frame& f) {\n-  return f.sp() == entrySP();\n-}\n-\n-bool ContinuationWrapper::chunk_invariant(outputStream* st) {\n-  \/\/ only the topmost chunk can be empty\n-  if (_tail == nullptr) {\n-    return true;\n-  }\n-\n-  int i = 1;\n-  for (stackChunkOop chunk = _tail->parent(); chunk != nullptr; chunk = chunk->parent()) {\n-    if (chunk->is_empty()) {\n-      assert(chunk != _tail, \"\");\n-      st->print_cr(\"i: %d\", i);\n-      chunk->print_on(true, st);\n-      return false;\n-    }\n-    i++;\n-  }\n-  return true;\n-}\n-#endif \/\/ ASSERT\n-\n@@ -1061,1 +811,1 @@\n-  maybe_flush_stack_processing(_thread, entry);\n+  entry->flush_stack_processing(_thread);\n@@ -1966,1 +1716,1 @@\n-  oop oopCont = get_continuation(current);\n+  oop oopCont = current->get_continuation();\n@@ -2076,1 +1826,1 @@\n-  assert(continuation == get_continuation(thread), \"\");\n+  assert(continuation == thread->get_continuation(), \"\");\n@@ -2769,1 +2519,1 @@\n-  assert(oopCont == get_continuation(thread), \"\");\n+  assert(oopCont == thread->get_continuation(), \"\");\n@@ -2944,23 +2694,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-int ContinuationEntry::return_pc_offset = 0;\n-nmethod* ContinuationEntry::continuation_enter = nullptr;\n-address ContinuationEntry::return_pc = nullptr;\n-\n-void ContinuationEntry::set_enter_nmethod(nmethod* nm) {\n-  assert(return_pc_offset != 0, \"\");\n-  continuation_enter = nm;\n-  return_pc = nm->code_begin() + return_pc_offset;\n-}\n-\n-ContinuationEntry* ContinuationEntry::from_frame(const frame& f) {\n-  assert(Continuation::is_continuation_enterSpecial(f), \"\");\n-  return (ContinuationEntry*)f.unextended_sp();\n-}\n-\n-void ContinuationEntry::flush_stack_processing(JavaThread* thread) const {\n-  maybe_flush_stack_processing(thread, this);\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -2968,37 +2695,0 @@\n-bool ContinuationEntry::assert_entry_frame_laid_out(JavaThread* thread) {\n-  assert(thread->has_last_Java_frame(), \"Wrong place to use this assertion\");\n-\n-  ContinuationEntry* entry =\n-    Continuation::get_continuation_entry_for_continuation(thread, get_continuation(thread));\n-  assert(entry != nullptr, \"\");\n-\n-  intptr_t* unextended_sp = entry->entry_sp();\n-  intptr_t* sp;\n-  if (entry->argsize() > 0) {\n-    sp = entry->bottom_sender_sp();\n-  } else {\n-    sp = unextended_sp;\n-    bool interpreted_bottom = false;\n-    RegisterMap map(thread, false, false, false);\n-    frame f;\n-    for (f = thread->last_frame();\n-         !f.is_first_frame() && f.sp() <= unextended_sp && !Continuation::is_continuation_enterSpecial(f);\n-         f = f.sender(&map)) {\n-      interpreted_bottom = f.is_interpreted_frame();\n-    }\n-    assert(Continuation::is_continuation_enterSpecial(f), \"\");\n-    sp = interpreted_bottom ? f.sp() : entry->bottom_sender_sp();\n-  }\n-\n-  assert(sp != nullptr, \"\");\n-  assert(sp <= entry->entry_sp(), \"\");\n-  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n-\n-  if (pc != StubRoutines::cont_returnBarrier()) {\n-    CodeBlob* cb = pc != nullptr ? CodeCache::find_blob(pc) : nullptr;\n-    assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n-  }\n-\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":6,"deletions":316,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"oops\/access.hpp\"\n@@ -127,117 +126,0 @@\n-\/\/ Metadata stored in the continuation entry frame\n-class ContinuationEntry {\n-public:\n-#ifdef ASSERT\n-  int cookie;\n-  static ByteSize cookie_offset() { return byte_offset_of(ContinuationEntry, cookie); }\n-  void verify_cookie() { assert(this->cookie == 0x1234, \"\"); }\n-#endif\n-\n-public:\n-  static int return_pc_offset; \/\/ friend gen_continuation_enter\n-  static void set_enter_nmethod(nmethod* nm); \/\/ friend SharedRuntime::generate_native_wrapper\n-\n-private:\n-  static nmethod* continuation_enter;\n-  static address return_pc;\n-\n-private:\n-  ContinuationEntry* _parent;\n-  oopDesc* _cont;\n-  oopDesc* _chunk;\n-  int _flags;\n-  int _argsize;\n-  intptr_t* _parent_cont_fastpath;\n-  int _parent_held_monitor_count;\n-  uint _pin_count;\n-\n-public:\n-  static ByteSize parent_offset()   { return byte_offset_of(ContinuationEntry, _parent); }\n-  static ByteSize cont_offset()     { return byte_offset_of(ContinuationEntry, _cont); }\n-  static ByteSize chunk_offset()    { return byte_offset_of(ContinuationEntry, _chunk); }\n-  static ByteSize flags_offset()    { return byte_offset_of(ContinuationEntry, _flags); }\n-  static ByteSize argsize_offset()  { return byte_offset_of(ContinuationEntry, _argsize); }\n-  static ByteSize pin_count_offset(){ return byte_offset_of(ContinuationEntry, _pin_count); }\n-  static ByteSize parent_cont_fastpath_offset()      { return byte_offset_of(ContinuationEntry, _parent_cont_fastpath); }\n-  static ByteSize parent_held_monitor_count_offset() { return byte_offset_of(ContinuationEntry, _parent_held_monitor_count); }\n-\n-  static void setup_oopmap(OopMap* map) {\n-    map->set_oop(VMRegImpl::stack2reg(in_bytes(cont_offset())  \/ VMRegImpl::stack_slot_size));\n-    map->set_oop(VMRegImpl::stack2reg(in_bytes(chunk_offset()) \/ VMRegImpl::stack_slot_size));\n-  }\n-\n-public:\n-  static size_t size() { return align_up((int)sizeof(ContinuationEntry), 2*wordSize); }\n-\n-  ContinuationEntry* parent() const { return _parent; }\n-\n-  static address entry_pc() { return return_pc; }\n-  intptr_t* entry_sp() const { return (intptr_t*)this; }\n-  inline intptr_t* entry_fp() const;\n-\n-  int argsize() const { return _argsize; }\n-  void set_argsize(int value) { _argsize = value; }\n-\n-  bool is_pinned() { return _pin_count > 0; }\n-  bool pin() {\n-    if (_pin_count == UINT_MAX) return false;\n-    _pin_count++;\n-    return true;\n-  }\n-  bool unpin() {\n-    if (_pin_count == 0) return false;\n-    _pin_count--;\n-    return true;\n-  }\n-\n-  intptr_t* parent_cont_fastpath() const { return _parent_cont_fastpath; }\n-  void set_parent_cont_fastpath(intptr_t* x) { _parent_cont_fastpath = x; }\n-\n-  static ContinuationEntry* from_frame(const frame& f);\n-  frame to_frame() const;\n-  void update_register_map(RegisterMap* map) const;\n-  void flush_stack_processing(JavaThread* thread) const;\n-\n-  intptr_t* bottom_sender_sp() const {\n-    intptr_t* sp = entry_sp() - argsize();\n-#ifdef _LP64\n-    sp = align_down(sp, frame::frame_alignment);\n-#endif\n-    return sp;\n-  }\n-\n-  oop cont_oop() const {\n-    oop snapshot = _cont;\n-    return NativeAccess<>::oop_load(&snapshot);\n-  }\n-\n-  oop scope()     const { return Continuation::continuation_scope(cont_oop()); }\n-\n-  oop cont_raw()  const { return _cont; }\n-  oop chunk_raw() const { return _chunk; }\n-\n-  bool is_virtual_thread() const { return _flags != 0; }\n-\n-  static oop cont_oop_or_null(const ContinuationEntry* ce) {\n-    return ce == nullptr ? nullptr : ce->cont_oop();\n-  }\n-\n-#ifndef PRODUCT\n-  void describe(FrameValues& values, int frame_no) const {\n-    address usp = (address)this;\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_offset())),    \"parent\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::cont_offset())),      \"continuation\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::flags_offset())),     \"flags\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::chunk_offset())),     \"chunk\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::argsize_offset())),   \"argsize\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::pin_count_offset())), \"pin_count\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_cont_fastpath_offset())),      \"parent fastpath\");\n-    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_held_monitor_count_offset())), \"parent held monitor count\");\n-  }\n-#endif\n-\n-#ifdef ASSERT\n-  static bool assert_entry_frame_laid_out(JavaThread* thread);\n-#endif\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/continuation.hpp","additions":0,"deletions":118,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+int ContinuationEntry::return_pc_offset = 0;\n+nmethod* ContinuationEntry::continuation_enter = nullptr;\n+address ContinuationEntry::return_pc = nullptr;\n+\n+void ContinuationEntry::set_enter_nmethod(nmethod* nm) {\n+  assert(return_pc_offset != 0, \"must already be generated\");\n+  continuation_enter = nm;\n+  return_pc = nm->code_begin() + return_pc_offset;\n+}\n+\n+ContinuationEntry* ContinuationEntry::from_frame(const frame& f) {\n+  assert(Continuation::is_continuation_enterSpecial(f), \"\");\n+  return (ContinuationEntry*)f.unextended_sp();\n+}\n+\n+NOINLINE static void flush_stack_processing(JavaThread* thread, intptr_t* sp) {\n+  log_develop_trace(continuations)(\"flush_stack_processing\");\n+  for (StackFrameStream fst(thread, true, true); fst.current()->sp() <= sp; fst.next()) {\n+    ;\n+  }\n+}\n+\n+inline void maybe_flush_stack_processing(JavaThread* thread, intptr_t* sp) {\n+  StackWatermark* sw;\n+  uintptr_t watermark;\n+  if ((sw = StackWatermarkSet::get(thread, StackWatermarkKind::gc)) != nullptr\n+        && (watermark = sw->watermark()) != 0\n+        && watermark <= (uintptr_t)sp) {\n+    flush_stack_processing(thread, sp);\n+  }\n+}\n+\n+void ContinuationEntry::flush_stack_processing(JavaThread* thread) const {\n+  maybe_flush_stack_processing(thread, (intptr_t*)((uintptr_t)entry_sp() + ContinuationEntry::size()));\n+}\n+\n+void ContinuationEntry::setup_oopmap(OopMap* map) {\n+  map->set_oop(VMRegImpl::stack2reg(in_bytes(cont_offset())  \/ VMRegImpl::stack_slot_size));\n+  map->set_oop(VMRegImpl::stack2reg(in_bytes(chunk_offset()) \/ VMRegImpl::stack_slot_size));\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+#ifdef ASSERT\n+bool ContinuationEntry::assert_entry_frame_laid_out(JavaThread* thread) {\n+  assert(thread->has_last_Java_frame(), \"Wrong place to use this assertion\");\n+\n+  ContinuationEntry* entry =\n+    Continuation::get_continuation_entry_for_continuation(thread, thread->get_continuation());\n+  assert(entry != nullptr, \"\");\n+\n+  intptr_t* unextended_sp = entry->entry_sp();\n+  intptr_t* sp;\n+  if (entry->argsize() > 0) {\n+    sp = entry->bottom_sender_sp();\n+  } else {\n+    sp = unextended_sp;\n+    bool interpreted_bottom = false;\n+    RegisterMap map(thread, false, false, false);\n+    frame f;\n+    for (f = thread->last_frame();\n+         !f.is_first_frame() && f.sp() <= unextended_sp && !Continuation::is_continuation_enterSpecial(f);\n+         f = f.sender(&map)) {\n+      interpreted_bottom = f.is_interpreted_frame();\n+    }\n+    assert(Continuation::is_continuation_enterSpecial(f), \"\");\n+    sp = interpreted_bottom ? f.sp() : entry->bottom_sender_sp();\n+  }\n+\n+  assert(sp != nullptr, \"\");\n+  assert(sp <= entry->entry_sp(), \"\");\n+  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+\n+  if (pc != StubRoutines::cont_returnBarrier()) {\n+    CodeBlob* cb = pc != nullptr ? CodeCache::find_blob(pc) : nullptr;\n+    assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+  }\n+\n+  return true;\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.cpp","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_RUNTIME_CONTINUATIONENTRY_HPP\n+#define SHARE_VM_RUNTIME_CONTINUATIONENTRY_HPP\n+\n+#include \"oops\/access.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+\n+class nmethod;\n+class RegisterMap;\n+class OopMap;\n+class JavaThread;\n+\n+\/\/ Metadata stored in the continuation entry frame\n+class ContinuationEntry {\n+public:\n+#ifdef ASSERT\n+  int cookie;\n+  static ByteSize cookie_offset() { return byte_offset_of(ContinuationEntry, cookie); }\n+  void verify_cookie() { assert(this->cookie == 0x1234, \"\"); }\n+#endif\n+\n+public:\n+  static int return_pc_offset; \/\/ friend gen_continuation_enter\n+  static void set_enter_nmethod(nmethod* nm); \/\/ friend SharedRuntime::generate_native_wrapper\n+\n+private:\n+  static nmethod* continuation_enter;\n+  static address return_pc;\n+\n+private:\n+  ContinuationEntry* _parent;\n+  oopDesc* _cont;\n+  oopDesc* _chunk;\n+  int _flags;\n+  int _argsize;\n+  intptr_t* _parent_cont_fastpath;\n+  int _parent_held_monitor_count;\n+  uint _pin_count;\n+\n+public:\n+  static ByteSize parent_offset()   { return byte_offset_of(ContinuationEntry, _parent); }\n+  static ByteSize cont_offset()     { return byte_offset_of(ContinuationEntry, _cont); }\n+  static ByteSize chunk_offset()    { return byte_offset_of(ContinuationEntry, _chunk); }\n+  static ByteSize flags_offset()    { return byte_offset_of(ContinuationEntry, _flags); }\n+  static ByteSize argsize_offset()  { return byte_offset_of(ContinuationEntry, _argsize); }\n+  static ByteSize pin_count_offset(){ return byte_offset_of(ContinuationEntry, _pin_count); }\n+  static ByteSize parent_cont_fastpath_offset()      { return byte_offset_of(ContinuationEntry, _parent_cont_fastpath); }\n+  static ByteSize parent_held_monitor_count_offset() { return byte_offset_of(ContinuationEntry, _parent_held_monitor_count); }\n+\n+  static void setup_oopmap(OopMap* map);\n+\n+public:\n+  static size_t size() { return align_up((int)sizeof(ContinuationEntry), 2*wordSize); }\n+\n+  ContinuationEntry* parent() const { return _parent; }\n+\n+  static address entry_pc() { return return_pc; }\n+  intptr_t* entry_sp() const { return (intptr_t*)this; }\n+  inline intptr_t* entry_fp() const;\n+\n+  int argsize() const { return _argsize; }\n+  void set_argsize(int value) { _argsize = value; }\n+\n+  bool is_pinned() { return _pin_count > 0; }\n+  bool pin() {\n+    if (_pin_count == UINT_MAX) return false;\n+    _pin_count++;\n+    return true;\n+  }\n+  bool unpin() {\n+    if (_pin_count == 0) return false;\n+    _pin_count--;\n+    return true;\n+  }\n+\n+  intptr_t* parent_cont_fastpath() const { return _parent_cont_fastpath; }\n+  void set_parent_cont_fastpath(intptr_t* x) { _parent_cont_fastpath = x; }\n+\n+  static ContinuationEntry* from_frame(const frame& f);\n+  frame to_frame() const;\n+  void update_register_map(RegisterMap* map) const;\n+  void flush_stack_processing(JavaThread* thread) const;\n+\n+  intptr_t* bottom_sender_sp() const {\n+    intptr_t* sp = entry_sp() - argsize();\n+#ifdef _LP64\n+    sp = align_down(sp, frame::frame_alignment);\n+#endif\n+    return sp;\n+  }\n+\n+  oop cont_oop() const {\n+    oop snapshot = _cont;\n+    return NativeAccess<>::oop_load(&snapshot);\n+  }\n+\n+  oop scope()     const { return Continuation::continuation_scope(cont_oop()); }\n+\n+  oop cont_raw()  const { return _cont; }\n+  oop chunk_raw() const { return _chunk; }\n+\n+  bool is_virtual_thread() const { return _flags != 0; }\n+\n+  static oop cont_oop_or_null(const ContinuationEntry* ce) {\n+    return ce == nullptr ? nullptr : ce->cont_oop();\n+  }\n+\n+#ifndef PRODUCT\n+  void describe(FrameValues& values, int frame_no) const {\n+    address usp = (address)this;\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_offset())),    \"parent\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::cont_offset())),      \"continuation\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::flags_offset())),     \"flags\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::chunk_offset())),     \"chunk\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::argsize_offset())),   \"argsize\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::pin_count_offset())), \"pin_count\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_cont_fastpath_offset())),      \"parent fastpath\");\n+    values.describe(frame_no, (intptr_t*)(usp + in_bytes(ContinuationEntry::parent_held_monitor_count_offset())), \"parent held monitor count\");\n+  }\n+#endif\n+\n+#ifdef ASSERT\n+  static bool assert_entry_frame_laid_out(JavaThread* thread);\n+#endif\n+};\n+\n+#endif \/\/ SHARE_VM_RUNTIME_CONTINUATIONENTRY_HPP\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+class ContinuationEntry;\n","filename":"src\/hotspot\/share\/runtime\/continuationHelper.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/stackChunkOop.inline.hpp\"\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.hpp\"\n+#include \"runtime\/continuationHelper.inline.hpp\"\n+#include \"runtime\/continuationWrapper.inline.hpp\"\n+#include \"runtime\/stackChunkFrameStream.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+ContinuationWrapper::ContinuationWrapper(JavaThread* thread, oop continuation)\n+  : _thread(thread), _entry(thread->last_continuation()), _continuation(continuation),\n+    _e_size(0), _e_num_interpreted_frames(0)\n+  {\n+  assert(oopDesc::is_oop(_continuation),\n+         \"Invalid continuation object: \" INTPTR_FORMAT, p2i((void*)_continuation));\n+  assert(_continuation == _entry->cont_oop(), \"cont: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \"\n+         INTPTR_FORMAT, p2i((oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n+  disallow_safepoint();\n+  read();\n+}\n+\n+ContinuationWrapper::ContinuationWrapper(oop continuation)\n+  : _thread(nullptr), _entry(nullptr), _continuation(continuation),\n+    _e_size(0), _e_num_interpreted_frames(0)\n+  {\n+  assert(oopDesc::is_oop(_continuation),\n+         \"Invalid continuation object: \" INTPTR_FORMAT, p2i((void*)_continuation));\n+  disallow_safepoint();\n+  read();\n+}\n+\n+ContinuationWrapper::ContinuationWrapper(const RegisterMap* map)\n+  : _thread(map->thread()),\n+    _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())),\n+    _continuation(map->stack_chunk()->cont()),\n+    _e_size(0), _e_num_interpreted_frames(0)\n+  {\n+  assert(oopDesc::is_oop(_continuation),\"Invalid cont: \" INTPTR_FORMAT, p2i((void*)_continuation));\n+  assert(_entry == nullptr || _continuation == _entry->cont_oop(),\n+    \"cont: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \" INTPTR_FORMAT,\n+    p2i( (oopDesc*)_continuation), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n+  disallow_safepoint();\n+  read();\n+}\n+\n+const frame ContinuationWrapper::last_frame() {\n+  stackChunkOop chunk = last_nonempty_chunk();\n+  if (chunk == nullptr) {\n+    return frame();\n+  }\n+  return StackChunkFrameStream<ChunkFrames::Mixed>(chunk).to_frame();\n+}\n+\n+stackChunkOop ContinuationWrapper::find_chunk_by_address(void* p) const {\n+  for (stackChunkOop chunk = tail(); chunk != nullptr; chunk = chunk->parent()) {\n+    if (chunk->is_in_chunk(p)) {\n+      assert(chunk->is_usable_in_chunk(p), \"\");\n+      return chunk;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+template<typename Event> void ContinuationWrapper::post_jfr_event(Event* e, JavaThread* jt) {\n+  if (e->should_commit()) {\n+    log_develop_trace(continuations)(\"JFR event: iframes: %d size: %d\", _e_num_interpreted_frames, _e_size);\n+    e->set_carrierThread(JFR_JVM_THREAD_ID(jt));\n+    e->set_contClass(_continuation->klass());\n+    e->set_numIFrames(_e_num_interpreted_frames);\n+    e->set_size(_e_size);\n+    e->commit();\n+  }\n+}\n+\n+#ifndef PRODUCT\n+intptr_t ContinuationWrapper::hash() {\n+  return Thread::current()->is_Java_thread() ? _continuation->identity_hash() : -1;\n+}\n+#endif\n+\n+#ifdef ASSERT\n+bool ContinuationWrapper::is_entry_frame(const frame& f) {\n+  return f.sp() == entrySP();\n+}\n+\n+bool ContinuationWrapper::chunk_invariant(outputStream* st) {\n+  \/\/ only the topmost chunk can be empty\n+  if (_tail == nullptr) {\n+    return true;\n+  }\n+\n+  int i = 1;\n+  for (stackChunkOop chunk = _tail->parent(); chunk != nullptr; chunk = chunk->parent()) {\n+    if (chunk->is_empty()) {\n+      assert(chunk != _tail, \"\");\n+      st->print_cr(\"i: %d\", i);\n+      chunk->print_on(true, st);\n+      return false;\n+    }\n+    i++;\n+  }\n+  return true;\n+}\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.cpp","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_RUNTIME_CONTINUATIONWRAPPER_HPP\n+#define SHARE_VM_RUNTIME_CONTINUATIONWRAPPER_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/stackChunkOop.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/\/ Intermediary to the jdk.internal.vm.Continuation objects and ContinuationEntry\n+\/\/ This object is created when we begin a operation for a continuation, and is destroyed when the operation completes.\n+\/\/ Contents are read from the Java object at the entry points of this module, and written at exit or calls into Java\n+\/\/ It also serves as a custom NoSafepointVerifier\n+class ContinuationWrapper : public StackObj {\n+private:\n+  JavaThread* const  _thread;   \/\/ Thread being frozen\/thawed\n+  ContinuationEntry* _entry;\n+  \/\/ These oops are managed by SafepointOp\n+  oop                _continuation;  \/\/ jdk.internal.vm.Continuation instance\n+  stackChunkOop      _tail;\n+\n+  short _e_size;\n+  short _e_num_interpreted_frames;\n+\n+  ContinuationWrapper(const ContinuationWrapper& cont); \/\/ no copy constructor\n+\n+private:\n+  DEBUG_ONLY(Thread* _current_thread;)\n+  friend class SafepointOp;\n+\n+  void disallow_safepoint() {\n+    #ifdef ASSERT\n+      assert(_continuation != nullptr, \"\");\n+      _current_thread = Thread::current();\n+      if (_current_thread->is_Java_thread()) {\n+        JavaThread::cast(_current_thread)->inc_no_safepoint_count();\n+      }\n+    #endif\n+  }\n+\n+  void allow_safepoint() {\n+    #ifdef ASSERT\n+      \/\/ we could have already allowed safepoints in done\n+      if (_continuation != nullptr && _current_thread->is_Java_thread()) {\n+        JavaThread::cast(_current_thread)->dec_no_safepoint_count();\n+      }\n+    #endif\n+  }\n+\n+public:\n+  void done() {\n+    allow_safepoint(); \/\/ must be done first\n+    _continuation = nullptr;\n+    _tail = (stackChunkOop)badOop;\n+  }\n+\n+  class SafepointOp : public StackObj {\n+    ContinuationWrapper& _cont;\n+    Handle _conth;\n+  public:\n+    SafepointOp(Thread* current, ContinuationWrapper& cont)\n+      : _cont(cont), _conth(current, cont._continuation) {\n+      _cont.allow_safepoint();\n+    }\n+    ~SafepointOp() { \/\/ reload oops\n+      _cont._continuation = _conth();\n+      if (_cont._tail != nullptr) {\n+        _cont._tail = jdk_internal_vm_Continuation::tail(_cont._continuation);\n+      }\n+      _cont.disallow_safepoint();\n+    }\n+  };\n+\n+public:\n+  ~ContinuationWrapper() { allow_safepoint(); }\n+\n+  ContinuationWrapper(JavaThread* thread, oop continuation);\n+  ContinuationWrapper(oop continuation);\n+  ContinuationWrapper(const RegisterMap* map);\n+\n+  JavaThread* thread() const         { return _thread; }\n+  oop continuation()                 { return _continuation; }\n+  stackChunkOop tail() const         { return _tail; }\n+  void set_tail(stackChunkOop chunk) { _tail = chunk; }\n+\n+  inline oop parent();\n+  inline bool is_preempted();\n+  inline void set_preempted(bool value);\n+  inline void read();\n+  inline void write();\n+\n+  NOT_PRODUCT(intptr_t hash();)\n+\n+  ContinuationEntry* entry() const { return _entry; }\n+  bool is_mounted()   const { return _entry != nullptr; }\n+  intptr_t* entrySP() const { return _entry->entry_sp(); }\n+  intptr_t* entryFP() const { return _entry->entry_fp(); }\n+  address   entryPC() const { return _entry->entry_pc(); }\n+  int argsize()       const { assert(_entry->argsize() >= 0, \"\"); return _entry->argsize(); }\n+  void set_argsize(int value) { _entry->set_argsize(value); }\n+\n+  bool is_empty() const { return last_nonempty_chunk() == nullptr; }\n+  const frame last_frame();\n+\n+  stackChunkOop last_nonempty_chunk() const { return nonempty_chunk(_tail); }\n+  inline stackChunkOop nonempty_chunk(stackChunkOop chunk) const;\n+  stackChunkOop find_chunk_by_address(void* p) const;\n+\n+  inline void record_interpreted_frame() { _e_num_interpreted_frames++; }\n+  inline void record_size_copied(int size) { _e_size += size << LogBytesPerWord; }\n+  template<typename Event> void post_jfr_event(Event *e, JavaThread* jt);\n+\n+#ifdef ASSERT\n+  bool is_entry_frame(const frame& f);\n+  bool chunk_invariant(outputStream* st);\n+#endif\n+};\n+\n+#endif \/\/ SHARE_VM_RUNTIME_CONTINUATIONWRAPPER_HPP\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.hpp","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_VM_RUNTIME_CONTINUATIONWRAPPER_INLINE_HPP\n+#define SHARE_VM_RUNTIME_CONTINUATIONWRAPPER_INLINE_HPP\n+\n+#include \"runtime\/continuationWrapper.hpp\"\n+\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+inline oop ContinuationWrapper::parent() {\n+  return jdk_internal_vm_Continuation::parent(_continuation);\n+}\n+\n+inline bool ContinuationWrapper::is_preempted() {\n+  return jdk_internal_vm_Continuation::is_preempted(_continuation);\n+}\n+\n+inline void ContinuationWrapper::set_preempted(bool value) {\n+  jdk_internal_vm_Continuation::set_preempted(_continuation, value);\n+}\n+\n+inline void ContinuationWrapper::read() {\n+  _tail  = jdk_internal_vm_Continuation::tail(_continuation);\n+}\n+\n+inline void ContinuationWrapper::write() {\n+  assert(oopDesc::is_oop(_continuation), \"bad oop\");\n+  assert(oopDesc::is_oop_or_null(_tail), \"bad oop\");\n+  jdk_internal_vm_Continuation::set_tail(_continuation, _tail);\n+}\n+\n+inline stackChunkOop ContinuationWrapper::nonempty_chunk(stackChunkOop chunk) const {\n+  while (chunk != nullptr && chunk->is_empty()) {\n+    chunk = chunk->parent();\n+  }\n+  return chunk;\n+}\n+\n+#endif \/\/ SHARE_VM_RUNTIME_CONTINUATIONWRAPPER_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/continuationWrapper.inline.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -81,0 +81,2 @@\n+#include \"runtime\/continuationEntry.hpp\"\n+#include \"runtime\/continuationHelper.inline.hpp\"\n@@ -2491,0 +2493,6 @@\n+oop JavaThread::get_continuation() const {\n+  assert(threadObj() != nullptr, \"must be set\");\n+  return java_lang_Thread::continuation(threadObj());\n+}\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1189,0 +1189,1 @@\n+  oop get_continuation() const;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+class ContinuationEntry;\n","filename":"src\/hotspot\/share\/runtime\/vframe.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}