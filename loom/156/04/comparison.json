{"files":[{"patch":"@@ -121,3 +121,0 @@\n-  oop cont_raw()  const { return _cont; }\n-  oop chunk_raw() const { return _chunk; }\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -272,0 +272,1 @@\n+#ifdef ASSERT\n@@ -278,1 +279,0 @@\n-#ifdef ASSERT\n@@ -337,1 +337,0 @@\n-  CONT_JFR_ONLY(FreezeThawJfrInfo _jfr_info;)\n@@ -340,0 +339,1 @@\n+  const intptr_t * const _frame_sp;\n@@ -341,1 +341,1 @@\n-  intptr_t *_bottom_address;\n+  intptr_t* _bottom_address;\n@@ -346,0 +346,12 @@\n+  intptr_t* _cont_stack_top;\n+  intptr_t* _cont_stack_bottom;\n+  int _cont_size;\n+\n+  CONT_JFR_ONLY(FreezeThawJfrInfo _jfr_info;)\n+\n+#ifdef ASSERT\n+  intptr_t* _orig_chunk_sp;\n+  int _is_chunk_available_size;\n+  bool _empty;\n+#endif\n+\n@@ -351,1 +363,1 @@\n-  inline FreezeBase(JavaThread* thread, ContinuationWrapper& cont, bool preempt);\n+  inline FreezeBase(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp);\n@@ -355,0 +367,1 @@\n+  void freeze_fast_existing_chunk();\n@@ -359,0 +372,2 @@\n+  inline int is_chunk_available_for_fast_freeze();\n+\n@@ -361,0 +376,1 @@\n+  void freeze_fast_init_cont_data(intptr_t* frame_sp);\n@@ -398,0 +414,4 @@\n+\n+protected:\n+  void freeze_fast_copy(stackChunkOop chunk, int chunk_start_sp);\n+  bool freeze_fast_new_chunk(stackChunkOop chunk);\n@@ -406,2 +426,2 @@\n-  inline Freeze(JavaThread* thread, ContinuationWrapper& cont, bool preempt)\n-    : FreezeBase(thread, cont, preempt) {}\n+  inline Freeze(JavaThread* thread, ContinuationWrapper& cont, intptr_t* frame_sp)\n+    : FreezeBase(thread, cont, frame_sp) {}\n@@ -409,7 +429,1 @@\n-  inline bool is_chunk_available_for_fast_freeze(intptr_t* frame_sp\n-#ifdef ASSERT\n-    , int* out_size = nullptr\n-#endif\n-  );\n-  template <bool chunk_available> freeze_result try_freeze_fast(intptr_t* sp);\n-  template <bool chunk_available> bool freeze_fast(intptr_t* frame_sp);\n+  freeze_result try_freeze_fast();\n@@ -421,2 +435,2 @@\n-FreezeBase::FreezeBase(JavaThread* thread, ContinuationWrapper& cont, bool preempt) :\n-    _thread(thread), _cont(cont), _barriers(false), _preempt(preempt) {\n+FreezeBase::FreezeBase(JavaThread* thread, ContinuationWrapper& cont, intptr_t* frame_sp) :\n+    _thread(thread), _cont(cont), _barriers(false), _preempt(false), _frame_sp(frame_sp) {\n@@ -445,0 +459,13 @@\n+\n+  assert(_cont.chunk_invariant(), \"\");\n+  assert(!Interpreter::contains(_cont.entryPC()), \"\");\n+  assert(StubRoutines::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n+\n+  \/\/ properties of the continuation on the stack; all sizes are in words\n+  _cont_stack_top    = frame_sp + frame::metadata_words; \/\/ we add metadata_words to skip the doYield stub frame\n+  _cont_stack_bottom = _cont.entrySP() - ContinuationHelper::frame_align_words(_cont.argsize()); \/\/ see alignment in thaw\n+  _cont_size = _cont_stack_bottom - _cont_stack_top;\n+\n+  log_develop_trace(continuations)(\"freeze size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n+    _cont_size, _cont.argsize(), p2i(_cont_stack_top), p2i(_cont_stack_bottom));\n+  assert(_cont_size > 0, \"\");\n@@ -476,3 +503,3 @@\n-template <bool chunk_available>\n-freeze_result Freeze<ConfigT>::try_freeze_fast(intptr_t* sp) {\n-  if (freeze_fast<chunk_available>(sp)) {\n+freeze_result Freeze<ConfigT>::try_freeze_fast() {\n+  stackChunkOop chunk = allocate_chunk(_cont_size + frame::metadata_words);\n+  if (freeze_fast_new_chunk(chunk)) {\n@@ -497,6 +524,1 @@\n-template <typename ConfigT>\n-bool Freeze<ConfigT>::is_chunk_available_for_fast_freeze(intptr_t* frame_sp\n-#ifdef ASSERT\n-    , int* out_size\n-#endif\n-  ) {\n+int FreezeBase::is_chunk_available_for_fast_freeze() {\n@@ -506,1 +528,1 @@\n-    return false;\n+    return 0;\n@@ -511,4 +533,0 @@\n-  intptr_t* const stack_top     = frame_sp + frame::metadata_words;\n-  intptr_t* const stack_bottom  = _cont.entrySP() - ContinuationHelper::frame_align_words(_cont.argsize());\n-\n-  int size = stack_bottom - stack_top; \/\/ in words\n@@ -516,0 +534,1 @@\n+  int ret_size = _cont_size;\n@@ -518,1 +537,1 @@\n-    size -= _cont.argsize();\n+    ret_size -= _cont.argsize();\n@@ -520,1 +539,0 @@\n-  assert(size > 0, \"\");\n@@ -522,1 +540,1 @@\n-  bool available = chunk_sp - frame::metadata_words >= size;\n+  bool available = chunk_sp - frame::metadata_words >= ret_size;\n@@ -524,3 +542,2 @@\n-    available, _cont.argsize(), size, p2i(stack_top), p2i(stack_bottom));\n-  DEBUG_ONLY(if (out_size != nullptr) *out_size = size;)\n-  return available;\n+    available, _cont.argsize(), ret_size, p2i(_cont_stack_top), p2i(_cont_stack_bottom));\n+  return available ? ret_size : 0;\n@@ -529,10 +546,34 @@\n-template <typename ConfigT>\n-template <bool chunk_available>\n-bool Freeze<ConfigT>::freeze_fast(intptr_t* frame_sp) {\n-  assert(_cont.chunk_invariant(), \"\");\n-  assert(!Interpreter::contains(_cont.entryPC()), \"\");\n-  assert(StubRoutines::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n-\n-  \/\/ properties of the continuation on the stack; all sizes are in words\n-  intptr_t* const cont_stack_top    = frame_sp + frame::metadata_words; \/\/ we add metadata_words to skip the doYield stub frame\n-  intptr_t* const cont_stack_bottom = _cont.entrySP() - ContinuationHelper::frame_align_words(_cont.argsize()); \/\/ see alignment in thaw\n+void FreezeBase::freeze_fast_existing_chunk() {\n+  stackChunkOop chunk = _cont.tail();\n+  DEBUG_ONLY(_orig_chunk_sp = chunk->sp_address();)\n+\n+  DEBUG_ONLY(_is_chunk_available_size = is_chunk_available_for_fast_freeze();)\n+  assert(_is_chunk_available_size > 0, \"\");\n+\n+  if (chunk->sp() < chunk->stack_size()) { \/\/ we are copying into a non-empty chunk\n+    DEBUG_ONLY(_empty = false;)\n+    assert(chunk->sp() < (chunk->stack_size() - chunk->argsize()), \"\");\n+    assert(*(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+\n+    \/\/ the chunk's sp before the freeze, adjusted to point beyond the stack-passed arguments in the topmost frame\n+    const int chunk_start_sp = chunk->sp() + _cont.argsize(); \/\/ we overlap; we'll overwrite the chunk's top frame's callee arguments\n+    assert(chunk_start_sp <= chunk->stack_size(), \"sp not pointing into stack\");\n+\n+    \/\/ increase max_size by what we're freezing minus the overlap\n+    chunk->set_max_size(chunk->max_size() + _cont_size - _cont.argsize());\n+\n+    intptr_t* const bottom_sp = _cont_stack_bottom - _cont.argsize();\n+    assert(bottom_sp == _bottom_address, \"\");\n+    \/\/ Because the chunk isn't empty, we know there's a caller in the chunk, therefore the bottom-most frame\n+    \/\/ should have a return barrier (installed back when we thawed it).\n+    assert(*(address*)(bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(),\n+           \"should be the continuation return barrier\");\n+    \/\/ We copy the fp from the chunk back to the stack because it contains some caller data,\n+    \/\/ including, possibly, an oop that might have gone stale since we thawed.\n+    patch_stack_pd(bottom_sp, chunk->sp_address());\n+    \/\/ we don't patch the return pc at this time, so as not to make the stack unwalkable for async walks\n+\n+    freeze_fast_copy(chunk, chunk_start_sp);\n+  } else { \/\/ the chunk is empty\n+    DEBUG_ONLY(_empty = true;)\n+    const int chunk_start_sp = chunk->sp();\n@@ -540,1 +581,1 @@\n-  const int cont_size = cont_stack_bottom - cont_stack_top;\n+    assert(chunk_start_sp == chunk->stack_size(), \"\");\n@@ -542,3 +583,2 @@\n-  log_develop_trace(continuations)(\"freeze_fast size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n-    cont_size, _cont.argsize(), p2i(cont_stack_top), p2i(cont_stack_bottom));\n-  assert(cont_size > 0, \"\");\n+    chunk->set_max_size(_cont_size);\n+    chunk->set_argsize(_cont.argsize());\n@@ -546,7 +586,3 @@\n-#ifdef ASSERT\n-  bool empty = true;\n-  int is_chunk_available_size;\n-  bool is_chunk_available0 = is_chunk_available_for_fast_freeze(frame_sp, &is_chunk_available_size);\n-  intptr_t* orig_chunk_sp = nullptr;\n-  CONT_JFR_ONLY(bool chunk_is_allocated = false;)\n-#endif\n+    freeze_fast_copy(chunk, chunk_start_sp);\n+  }\n+}\n@@ -554,46 +590,3 @@\n-  stackChunkOop chunk = _cont.tail();\n-  int chunk_start_sp; \/\/ the chunk's sp before the freeze, adjusted to point beyond the stack-passed arguments in the topmost frame\n-  if (chunk_available) { \/\/ LIKELY\n-    DEBUG_ONLY(orig_chunk_sp = chunk->sp_address();)\n-\n-    assert(is_chunk_available0, \"\");\n-\n-    if (chunk->sp() < chunk->stack_size()) { \/\/ we are copying into a non-empty chunk\n-      DEBUG_ONLY(empty = false;)\n-      assert(chunk->sp() < (chunk->stack_size() - chunk->argsize()), \"\");\n-      assert(*(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n-\n-      chunk_start_sp = chunk->sp() + _cont.argsize(); \/\/ we overlap; we'll overwrite the chunk's top frame's callee arguments\n-      assert(chunk_start_sp <= chunk->stack_size(), \"sp not pointing into stack\");\n-\n-      \/\/ increase max_size by what we're freezing minus the overlap\n-      chunk->set_max_size(chunk->max_size() + cont_size - _cont.argsize());\n-\n-      intptr_t* const bottom_sp = cont_stack_bottom - _cont.argsize();\n-      assert(bottom_sp == _bottom_address, \"\");\n-      \/\/ Because the chunk isn't empty, we know there's a caller in the chunk, therefore the bottom-most frame\n-      \/\/ should have a return barrier (installed back when we thawed it).\n-      assert(*(address*)(bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(),\n-             \"should be the continuation return barrier\");\n-      \/\/ We copy the fp from the chunk back to the stack because it contains some caller data,\n-      \/\/ including, possibly, an oop that might have gone stale since we thawed.\n-      patch_stack_pd(bottom_sp, chunk->sp_address());\n-      \/\/ we don't patch the return pc at this time, so as not to make the stack unwalkable for async walks\n-    } else { \/\/ the chunk is empty\n-      chunk_start_sp = chunk->sp();\n-\n-      assert(chunk_start_sp == chunk->stack_size(), \"\");\n-\n-      chunk->set_max_size(cont_size);\n-      chunk->set_argsize(_cont.argsize());\n-    }\n-  } else { \/\/ no chunk; allocate\n-    assert(_thread->thread_state() == _thread_in_vm, \"\");\n-    assert(!is_chunk_available_for_fast_freeze(frame_sp), \"\");\n-    assert(_thread->cont_fastpath(), \"\");\n-\n-    chunk = allocate_chunk(cont_size + frame::metadata_words);\n-    if (UNLIKELY(chunk == nullptr || !_thread->cont_fastpath() || _barriers)) { \/\/ OOME\/probably humongous\n-      log_develop_trace(continuations)(\"Retrying slow. Barriers: %d\", _barriers);\n-      return false;\n-    }\n+bool FreezeBase::freeze_fast_new_chunk(stackChunkOop chunk) {\n+  DEBUG_ONLY(_empty = true;)\n+  DEBUG_ONLY(_is_chunk_available_size = is_chunk_available_for_fast_freeze();)\n@@ -601,2 +594,3 @@\n-    chunk->set_max_size(cont_size);\n-    chunk->set_argsize(_cont.argsize());\n+  assert(_is_chunk_available_size == 0, \"\");\n+  assert(_thread->thread_state() == _thread_in_vm, \"\");\n+  assert(_thread->cont_fastpath(), \"\");\n@@ -604,4 +598,2 @@\n-    \/\/ in a fresh chunk, we freeze *with* the bottom-most frame's stack arguments.\n-    \/\/ They'll then be stored twice: in the chunk and in the parent chunk's top frame\n-    chunk_start_sp = cont_size + frame::metadata_words;\n-    assert(chunk_start_sp == chunk->stack_size(), \"\");\n+  \/\/ Install new chunk\n+  _cont.set_tail(chunk);\n@@ -609,2 +601,3 @@\n-    DEBUG_ONLY(CONT_JFR_ONLY(chunk_is_allocated = true;))\n-    DEBUG_ONLY(orig_chunk_sp = chunk->start_address() + chunk_start_sp;)\n+  if (UNLIKELY(chunk == nullptr || !_thread->cont_fastpath() || _barriers)) { \/\/ OOME\/probably humongous\n+    log_develop_trace(continuations)(\"Retrying slow. Barriers: %d\", _barriers);\n+    return false;\n@@ -613,0 +606,17 @@\n+  chunk->set_max_size(_cont_size);\n+  chunk->set_argsize(_cont.argsize());\n+\n+  \/\/ in a fresh chunk, we freeze *with* the bottom-most frame's stack arguments.\n+  \/\/ They'll then be stored twice: in the chunk and in the parent chunk's top frame\n+  const int chunk_start_sp = _cont_size + frame::metadata_words;\n+  assert(chunk_start_sp == chunk->stack_size(), \"\");\n+\n+  DEBUG_ONLY(CONT_JFR_ONLY(chunk_is_allocated = true;))\n+  DEBUG_ONLY(_orig_chunk_sp = chunk->start_address() + chunk_start_sp;)\n+\n+  freeze_fast_copy(chunk, chunk_start_sp);\n+\n+  return true;\n+}\n+\n+void FreezeBase::freeze_fast_copy(stackChunkOop chunk, int chunk_start_sp) {\n@@ -628,1 +638,1 @@\n-  assert(chunk_start_sp >= cont_size, \"no room in the chunk\");\n+  assert(chunk_start_sp >= _cont_size, \"no room in the chunk\");\n@@ -630,2 +640,2 @@\n-  const int chunk_new_sp = chunk_start_sp - cont_size; \/\/ the chunk's new sp, after freeze\n-  assert(!is_chunk_available0 || orig_chunk_sp - (chunk->start_address() + chunk_new_sp) == is_chunk_available_size, \"\");\n+  const int chunk_new_sp = chunk_start_sp - _cont_size; \/\/ the chunk's new sp, after freeze\n+  assert(!(_is_chunk_available_size > 0) || _orig_chunk_sp - (chunk->start_address() + chunk_new_sp) == _is_chunk_available_size, \"\");\n@@ -634,1 +644,1 @@\n-  assert(empty || *(address*)(orig_chunk_sp - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+  assert(_empty || *(address*)(_orig_chunk_sp - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n@@ -638,1 +648,1 @@\n-  intptr_t* from = cont_stack_top - frame::metadata_words;\n+  intptr_t* from = _cont_stack_top - frame::metadata_words;\n@@ -640,1 +650,1 @@\n-  copy_to_chunk(from, to, cont_size + frame::metadata_words);\n+  copy_to_chunk(from, to, _cont_size + frame::metadata_words);\n@@ -644,2 +654,2 @@\n-  intptr_t* chunk_bottom_sp = chunk_top + cont_size - _cont.argsize();\n-  assert(empty || *(address*)(chunk_bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(), \"\");\n+  intptr_t* chunk_bottom_sp = chunk_top + _cont_size - _cont.argsize();\n+  assert(_empty || *(address*)(chunk_bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(), \"\");\n@@ -651,1 +661,1 @@\n-  chunk->set_pc(*(address*)(cont_stack_top - frame::sender_sp_ret_address_offset()));\n+  chunk->set_pc(*(address*)(_cont_stack_top - frame::sender_sp_ret_address_offset()));\n@@ -675,2 +685,0 @@\n-\n-  return true;\n@@ -896,0 +904,3 @@\n+    \/\/ Install new chunk\n+    _cont.set_tail(chunk);\n+\n@@ -1251,2 +1262,0 @@\n-\n-  _cont.set_tail(chunk);\n@@ -1380,1 +1389,1 @@\n-  oop oopCont = get_continuation(current);\n+  oop oopCont = entry->cont_oop();\n@@ -1397,1 +1406,1 @@\n-  Freeze<ConfigT> fr(current, cont, false);\n+  Freeze<ConfigT> freeze(current, cont, sp);\n@@ -1399,4 +1408,4 @@\n-  bool fast = can_freeze_fast(current);\n-  if (fast && fr.is_chunk_available_for_fast_freeze(sp)) {\n-    freeze_result res = fr.template try_freeze_fast<true>(sp);\n-    assert(res == freeze_ok, \"\");\n+  volatile bool fast = can_freeze_fast(current);\n+  volatile int  chunk_av_size = freeze.is_chunk_available_for_fast_freeze();\n+  if (fast && chunk_av_size > 0) {\n+    freeze.freeze_fast_existing_chunk();\n@@ -1414,1 +1423,3 @@\n-    fr.set_jvmti_event_collector(&jsoaec);\n+    freeze.set_jvmti_event_collector(&jsoaec);\n+\n+    freeze_result res = fast ? freeze.try_freeze_fast() : freeze.freeze_slow();\n@@ -1416,2 +1427,0 @@\n-    freeze_result res = fast ? fr.template try_freeze_fast<false>(sp)\n-                             : fr.freeze_slow();\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":141,"deletions":132,"binary":false,"changes":273,"status":"modified"}]}