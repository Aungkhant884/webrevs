{"files":[{"patch":"@@ -167,0 +167,6 @@\n+static inline bool is_stack_chunk_class(const Symbol* class_name,\n+                                        const ClassLoaderData* loader_data) {\n+  return (class_name == vmSymbols::jdk_internal_vm_StackChunk() &&\n+          loader_data->is_the_null_class_loader_data());\n+}\n+\n@@ -446,1 +452,1 @@\n-    } else if (class_name == vmSymbols::jdk_internal_vm_StackChunk()) {\n+    } else if (is_stack_chunk_class(class_name, loader_data)) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -122,3 +122,0 @@\n-  oop cont_raw()  const { return _cont; }\n-  oop chunk_raw() const { return _chunk; }\n-\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -272,0 +272,1 @@\n+#ifdef ASSERT\n@@ -278,1 +279,0 @@\n-#ifdef ASSERT\n@@ -337,1 +337,0 @@\n-  CONT_JFR_ONLY(FreezeThawJfrInfo _jfr_info;)\n@@ -340,0 +339,3 @@\n+  const intptr_t * const _frame_sp; \/\/ Top frame sp for this freeze\n+\n+  intptr_t* _bottom_address;\n@@ -341,1 +343,2 @@\n-  intptr_t *_bottom_address;\n+  int _freeze_size; \/\/ total size of all frames plus metadata in words.\n+  int _total_align_size;\n@@ -343,2 +346,10 @@\n-  int _size; \/\/ total size of all frames plus metadata in words.\n-  int _align_size;\n+  intptr_t* _cont_stack_top;\n+  intptr_t* _cont_stack_bottom;\n+\n+  CONT_JFR_ONLY(FreezeThawJfrInfo _jfr_info;)\n+\n+#ifdef ASSERT\n+  intptr_t* _orig_chunk_sp;\n+  int _fast_freeze_size;\n+  bool _empty;\n+#endif\n@@ -351,1 +362,1 @@\n-  inline FreezeBase(JavaThread* thread, ContinuationWrapper& cont, bool preempt);\n+  inline FreezeBase(JavaThread* thread, ContinuationWrapper& cont, intptr_t* sp);\n@@ -355,0 +366,1 @@\n+  void freeze_fast_existing_chunk();\n@@ -359,0 +371,2 @@\n+  inline int size_if_fast_freeze_available();\n+\n@@ -361,0 +375,1 @@\n+  void freeze_fast_init_cont_data(intptr_t* frame_sp);\n@@ -371,0 +386,2 @@\n+  int cont_size() { return _cont_stack_bottom - _cont_stack_top; }\n+\n@@ -398,0 +415,4 @@\n+\n+protected:\n+  void freeze_fast_copy(stackChunkOop chunk, int chunk_start_sp);\n+  bool freeze_fast_new_chunk(stackChunkOop chunk);\n@@ -406,2 +427,2 @@\n-  inline Freeze(JavaThread* thread, ContinuationWrapper& cont, bool preempt)\n-    : FreezeBase(thread, cont, preempt) {}\n+  inline Freeze(JavaThread* thread, ContinuationWrapper& cont, intptr_t* frame_sp)\n+    : FreezeBase(thread, cont, frame_sp) {}\n@@ -409,7 +430,1 @@\n-  inline bool is_chunk_available_for_fast_freeze(intptr_t* frame_sp\n-#ifdef ASSERT\n-    , int* out_size = nullptr\n-#endif\n-  );\n-  template <bool chunk_available> freeze_result try_freeze_fast(intptr_t* sp);\n-  template <bool chunk_available> bool freeze_fast(intptr_t* frame_sp);\n+  freeze_result try_freeze_fast();\n@@ -421,2 +436,2 @@\n-FreezeBase::FreezeBase(JavaThread* thread, ContinuationWrapper& cont, bool preempt) :\n-    _thread(thread), _cont(cont), _barriers(false), _preempt(preempt) {\n+FreezeBase::FreezeBase(JavaThread* thread, ContinuationWrapper& cont, intptr_t* frame_sp) :\n+    _thread(thread), _cont(cont), _barriers(false), _preempt(false), _frame_sp(frame_sp) {\n@@ -445,0 +460,12 @@\n+\n+  assert(_cont.chunk_invariant(), \"\");\n+  assert(!Interpreter::contains(_cont.entryPC()), \"\");\n+  assert(StubRoutines::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n+\n+  \/\/ properties of the continuation on the stack; all sizes are in words\n+  _cont_stack_top    = frame_sp + frame::metadata_words; \/\/ we add metadata_words to skip the doYield stub frame\n+  _cont_stack_bottom = _cont.entrySP() - ContinuationHelper::frame_align_words(_cont.argsize()); \/\/ see alignment in thaw\n+\n+  log_develop_trace(continuations)(\"freeze size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n+    cont_size(), _cont.argsize(), p2i(_cont_stack_top), p2i(_cont_stack_bottom));\n+  assert(cont_size() > 0, \"\");\n@@ -448,2 +475,2 @@\n-  _size = 0;\n-  _align_size = 0;\n+  _freeze_size = 0;\n+  _total_align_size = 0;\n@@ -476,3 +503,9 @@\n-template <bool chunk_available>\n-freeze_result Freeze<ConfigT>::try_freeze_fast(intptr_t* sp) {\n-  if (freeze_fast<chunk_available>(sp)) {\n+freeze_result Freeze<ConfigT>::try_freeze_fast() {\n+  assert(_thread->thread_state() == _thread_in_vm, \"\");\n+  assert(_thread->cont_fastpath(), \"\");\n+\n+  DEBUG_ONLY(_fast_freeze_size = size_if_fast_freeze_available();)\n+  assert(_fast_freeze_size == 0, \"\");\n+\n+  stackChunkOop chunk = allocate_chunk(cont_size() + frame::metadata_words);\n+  if (freeze_fast_new_chunk(chunk)) {\n@@ -496,7 +529,2 @@\n-\/\/ returns true iff there's room in the chunk for a fast, compiled-frame-only freeze\n-template <typename ConfigT>\n-bool Freeze<ConfigT>::is_chunk_available_for_fast_freeze(intptr_t* frame_sp\n-#ifdef ASSERT\n-    , int* out_size\n-#endif\n-  ) {\n+\/\/ Returns size needed if the continuation fits, otherwise 0.\n+int FreezeBase::size_if_fast_freeze_available() {\n@@ -506,1 +534,1 @@\n-    return false;\n+    return 0;\n@@ -509,1 +537,0 @@\n-  \/\/ assert(CodeCache::find_blob(*(address*)(frame_sp - SENDER_SP_RET_ADDRESS_OFFSET)) == StubRoutines::cont_doYield_stub(), \"\"); -- fails on Windows\n@@ -511,4 +538,0 @@\n-  intptr_t* const stack_top     = frame_sp + frame::metadata_words;\n-  intptr_t* const stack_bottom  = _cont.entrySP() - ContinuationHelper::frame_align_words(_cont.argsize());\n-\n-  int size = stack_bottom - stack_top; \/\/ in words\n@@ -516,0 +539,1 @@\n+  int total_size_needed = cont_size();\n@@ -518,1 +542,1 @@\n-    size -= _cont.argsize();\n+    total_size_needed -= _cont.argsize();\n@@ -520,1 +544,0 @@\n-  assert(size > 0, \"\");\n@@ -522,5 +545,4 @@\n-  bool available = chunk_sp - frame::metadata_words >= size;\n-  log_develop_trace(continuations)(\"chunk available: %d size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n-    available, _cont.argsize(), size, p2i(stack_top), p2i(stack_bottom));\n-  DEBUG_ONLY(if (out_size != nullptr) *out_size = size;)\n-  return available;\n+  bool available = chunk_sp - frame::metadata_words >= total_size_needed;\n+  log_develop_trace(continuations)(\"chunk available: %s size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n+    available ? \"yes\" : \"no\" , total_size_needed, _cont.argsize(), p2i(_cont_stack_top), p2i(_cont_stack_bottom));\n+  return available ? total_size_needed : 0;\n@@ -529,6 +551,34 @@\n-template <typename ConfigT>\n-template <bool chunk_available>\n-bool Freeze<ConfigT>::freeze_fast(intptr_t* frame_sp) {\n-  assert(_cont.chunk_invariant(), \"\");\n-  assert(!Interpreter::contains(_cont.entryPC()), \"\");\n-  assert(StubRoutines::cont_doYield_stub()->frame_size() == frame::metadata_words, \"\");\n+void FreezeBase::freeze_fast_existing_chunk() {\n+  stackChunkOop chunk = _cont.tail();\n+  DEBUG_ONLY(_orig_chunk_sp = chunk->sp_address();)\n+\n+  DEBUG_ONLY(_fast_freeze_size = size_if_fast_freeze_available();)\n+  assert(_fast_freeze_size > 0, \"\");\n+\n+  if (chunk->sp() < chunk->stack_size()) { \/\/ we are copying into a non-empty chunk\n+    DEBUG_ONLY(_empty = false;)\n+    assert(chunk->sp() < (chunk->stack_size() - chunk->argsize()), \"\");\n+    assert(*(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+\n+    \/\/ the chunk's sp before the freeze, adjusted to point beyond the stack-passed arguments in the topmost frame\n+    const int chunk_start_sp = chunk->sp() + _cont.argsize(); \/\/ we overlap; we'll overwrite the chunk's top frame's callee arguments\n+    assert(chunk_start_sp <= chunk->stack_size(), \"sp not pointing into stack\");\n+\n+    \/\/ increase max_size by what we're freezing minus the overlap\n+    chunk->set_max_size(chunk->max_size() + cont_size() - _cont.argsize());\n+\n+    intptr_t* const bottom_sp = _cont_stack_bottom - _cont.argsize();\n+    assert(bottom_sp == _bottom_address, \"\");\n+    \/\/ Because the chunk isn't empty, we know there's a caller in the chunk, therefore the bottom-most frame\n+    \/\/ should have a return barrier (installed back when we thawed it).\n+    assert(*(address*)(bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(),\n+           \"should be the continuation return barrier\");\n+    \/\/ We copy the fp from the chunk back to the stack because it contains some caller data,\n+    \/\/ including, possibly, an oop that might have gone stale since we thawed.\n+    patch_stack_pd(bottom_sp, chunk->sp_address());\n+    \/\/ we don't patch the return pc at this time, so as not to make the stack unwalkable for async walks\n+\n+    freeze_fast_copy(chunk, chunk_start_sp);\n+  } else { \/\/ the chunk is empty\n+    DEBUG_ONLY(_empty = true;)\n+    const int chunk_start_sp = chunk->sp();\n@@ -536,3 +586,1 @@\n-  \/\/ properties of the continuation on the stack; all sizes are in words\n-  intptr_t* const cont_stack_top    = frame_sp + frame::metadata_words; \/\/ we add metadata_words to skip the doYield stub frame\n-  intptr_t* const cont_stack_bottom = _cont.entrySP() - ContinuationHelper::frame_align_words(_cont.argsize()); \/\/ see alignment in thaw\n+    assert(chunk_start_sp == chunk->stack_size(), \"\");\n@@ -540,1 +588,2 @@\n-  const int cont_size = cont_stack_bottom - cont_stack_top;\n+    chunk->set_max_size(cont_size());\n+    chunk->set_argsize(_cont.argsize());\n@@ -542,3 +591,3 @@\n-  log_develop_trace(continuations)(\"freeze_fast size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n-    cont_size, _cont.argsize(), p2i(cont_stack_top), p2i(cont_stack_bottom));\n-  assert(cont_size > 0, \"\");\n+    freeze_fast_copy(chunk, chunk_start_sp);\n+  }\n+}\n@@ -546,7 +595,2 @@\n-#ifdef ASSERT\n-  bool empty = true;\n-  int is_chunk_available_size;\n-  bool is_chunk_available0 = is_chunk_available_for_fast_freeze(frame_sp, &is_chunk_available_size);\n-  intptr_t* orig_chunk_sp = nullptr;\n-  CONT_JFR_ONLY(bool chunk_is_allocated = false;)\n-#endif\n+bool FreezeBase::freeze_fast_new_chunk(stackChunkOop chunk) {\n+  DEBUG_ONLY(_empty = true;)\n@@ -554,46 +598,2 @@\n-  stackChunkOop chunk = _cont.tail();\n-  int chunk_start_sp; \/\/ the chunk's sp before the freeze, adjusted to point beyond the stack-passed arguments in the topmost frame\n-  if (chunk_available) { \/\/ LIKELY\n-    DEBUG_ONLY(orig_chunk_sp = chunk->sp_address();)\n-\n-    assert(is_chunk_available0, \"\");\n-\n-    if (chunk->sp() < chunk->stack_size()) { \/\/ we are copying into a non-empty chunk\n-      DEBUG_ONLY(empty = false;)\n-      assert(chunk->sp() < (chunk->stack_size() - chunk->argsize()), \"\");\n-      assert(*(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n-\n-      chunk_start_sp = chunk->sp() + _cont.argsize(); \/\/ we overlap; we'll overwrite the chunk's top frame's callee arguments\n-      assert(chunk_start_sp <= chunk->stack_size(), \"sp not pointing into stack\");\n-\n-      \/\/ increase max_size by what we're freezing minus the overlap\n-      chunk->set_max_size(chunk->max_size() + cont_size - _cont.argsize());\n-\n-      intptr_t* const bottom_sp = cont_stack_bottom - _cont.argsize();\n-      assert(bottom_sp == _bottom_address, \"\");\n-      \/\/ Because the chunk isn't empty, we know there's a caller in the chunk, therefore the bottom-most frame\n-      \/\/ should have a return barrier (installed back when we thawed it).\n-      assert(*(address*)(bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(),\n-             \"should be the continuation return barrier\");\n-      \/\/ We copy the fp from the chunk back to the stack because it contains some caller data,\n-      \/\/ including, possibly, an oop that might have gone stale since we thawed.\n-      patch_stack_pd(bottom_sp, chunk->sp_address());\n-      \/\/ we don't patch the return pc at this time, so as not to make the stack unwalkable for async walks\n-    } else { \/\/ the chunk is empty\n-      chunk_start_sp = chunk->sp();\n-\n-      assert(chunk_start_sp == chunk->stack_size(), \"\");\n-\n-      chunk->set_max_size(cont_size);\n-      chunk->set_argsize(_cont.argsize());\n-    }\n-  } else { \/\/ no chunk; allocate\n-    assert(_thread->thread_state() == _thread_in_vm, \"\");\n-    assert(!is_chunk_available_for_fast_freeze(frame_sp), \"\");\n-    assert(_thread->cont_fastpath(), \"\");\n-\n-    chunk = allocate_chunk(cont_size + frame::metadata_words);\n-    if (UNLIKELY(chunk == nullptr || !_thread->cont_fastpath() || _barriers)) { \/\/ OOME\/probably humongous\n-      log_develop_trace(continuations)(\"Retrying slow. Barriers: %d\", _barriers);\n-      return false;\n-    }\n+  \/\/ Install new chunk\n+  _cont.set_tail(chunk);\n@@ -601,2 +601,4 @@\n-    chunk->set_max_size(cont_size);\n-    chunk->set_argsize(_cont.argsize());\n+  if (UNLIKELY(chunk == nullptr || !_thread->cont_fastpath() || _barriers)) { \/\/ OOME\/probably humongous\n+    log_develop_trace(continuations)(\"Retrying slow. Barriers: %d\", _barriers);\n+    return false;\n+  }\n@@ -604,4 +606,2 @@\n-    \/\/ in a fresh chunk, we freeze *with* the bottom-most frame's stack arguments.\n-    \/\/ They'll then be stored twice: in the chunk and in the parent chunk's top frame\n-    chunk_start_sp = cont_size + frame::metadata_words;\n-    assert(chunk_start_sp == chunk->stack_size(), \"\");\n+  chunk->set_max_size(cont_size());\n+  chunk->set_argsize(_cont.argsize());\n@@ -609,3 +609,4 @@\n-    DEBUG_ONLY(CONT_JFR_ONLY(chunk_is_allocated = true;))\n-    DEBUG_ONLY(orig_chunk_sp = chunk->start_address() + chunk_start_sp;)\n-  }\n+  \/\/ in a fresh chunk, we freeze *with* the bottom-most frame's stack arguments.\n+  \/\/ They'll then be stored twice: in the chunk and in the parent chunk's top frame\n+  const int chunk_start_sp = cont_size() + frame::metadata_words;\n+  assert(chunk_start_sp == chunk->stack_size(), \"\");\n@@ -613,0 +614,9 @@\n+  DEBUG_ONLY(CONT_JFR_ONLY(chunk_is_allocated = true;))\n+  DEBUG_ONLY(_orig_chunk_sp = chunk->start_address() + chunk_start_sp;)\n+\n+  freeze_fast_copy(chunk, chunk_start_sp);\n+\n+  return true;\n+}\n+\n+void FreezeBase::freeze_fast_copy(stackChunkOop chunk, int chunk_start_sp) {\n@@ -628,1 +638,1 @@\n-  assert(chunk_start_sp >= cont_size, \"no room in the chunk\");\n+  assert(chunk_start_sp >= cont_size(), \"no room in the chunk\");\n@@ -630,2 +640,2 @@\n-  const int chunk_new_sp = chunk_start_sp - cont_size; \/\/ the chunk's new sp, after freeze\n-  assert(!is_chunk_available0 || orig_chunk_sp - (chunk->start_address() + chunk_new_sp) == is_chunk_available_size, \"\");\n+  const int chunk_new_sp = chunk_start_sp - cont_size(); \/\/ the chunk's new sp, after freeze\n+  assert(!(_fast_freeze_size > 0) || _orig_chunk_sp - (chunk->start_address() + chunk_new_sp) == _fast_freeze_size, \"\");\n@@ -634,1 +644,1 @@\n-  assert(empty || *(address*)(orig_chunk_sp - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n+  assert(_empty || *(address*)(_orig_chunk_sp - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"\");\n@@ -638,1 +648,1 @@\n-  intptr_t* from = cont_stack_top - frame::metadata_words;\n+  intptr_t* from = _cont_stack_top - frame::metadata_words;\n@@ -640,1 +650,1 @@\n-  copy_to_chunk(from, to, cont_size + frame::metadata_words);\n+  copy_to_chunk(from, to, cont_size() + frame::metadata_words);\n@@ -644,2 +654,2 @@\n-  intptr_t* chunk_bottom_sp = chunk_top + cont_size - _cont.argsize();\n-  assert(empty || *(address*)(chunk_bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(), \"\");\n+  intptr_t* chunk_bottom_sp = chunk_top + cont_size() - _cont.argsize();\n+  assert(_empty || *(address*)(chunk_bottom_sp-frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(), \"\");\n@@ -651,1 +661,1 @@\n-  chunk->set_pc(*(address*)(cont_stack_top - frame::sender_sp_ret_address_offset()));\n+  chunk->set_pc(*(address*)(_cont_stack_top - frame::sender_sp_ret_address_offset()));\n@@ -675,2 +685,0 @@\n-\n-  return true;\n@@ -778,1 +786,1 @@\n-  _size += fsize;\n+  _freeze_size += fsize;\n@@ -821,1 +829,1 @@\n-    p2i(_bottom_address), _frames, _size << LogBytesPerWord, argsize);\n+    p2i(_bottom_address), _frames, _freeze_size << LogBytesPerWord, argsize);\n@@ -834,1 +842,1 @@\n-  _size += frame::metadata_words; \/\/ for top frame's metadata\n+  _freeze_size += frame::metadata_words; \/\/ for top frame's metadata\n@@ -853,1 +861,1 @@\n-  log_develop_trace(continuations)(\"finalize _size: %d overlap: %d unextended_sp: %d\", _size, overlap, unextended_sp);\n+  log_develop_trace(continuations)(\"finalize _size: %d overlap: %d unextended_sp: %d\", _freeze_size, overlap, unextended_sp);\n@@ -855,2 +863,2 @@\n-  _size -= overlap;\n-  assert(_size >= 0, \"\");\n+  _freeze_size -= overlap;\n+  assert(_freeze_size >= 0, \"\");\n@@ -860,1 +868,1 @@\n-  assert(chunk != nullptr || unextended_sp < _size, \"\");\n+  assert(chunk != nullptr || unextended_sp < _freeze_size, \"\");\n@@ -863,2 +871,2 @@\n-  assert(!_barriers || (unextended_sp >= _size && chunk->is_empty()),\n-    \"unextended_sp: %d size: %d is_empty: %d\", unextended_sp, _size, chunk->is_empty());\n+  assert(!_barriers || (unextended_sp >= _freeze_size && chunk->is_empty()),\n+    \"unextended_sp: %d size: %d is_empty: %d\", unextended_sp, _freeze_size, chunk->is_empty());\n@@ -867,1 +875,1 @@\n-  if (unextended_sp < _size || chunk->is_gc_mode() || (!_barriers && chunk->requires_barriers())) {\n+  if (unextended_sp < _freeze_size || chunk->is_gc_mode() || (!_barriers && chunk->requires_barriers())) {\n@@ -876,1 +884,1 @@\n-          chunk->requires_barriers(), _size, chunk->sp() - frame::metadata_words);\n+          chunk->requires_barriers(), _freeze_size, chunk->sp() - frame::metadata_words);\n@@ -881,1 +889,1 @@\n-    _size += overlap; \/\/ we're allocating a new chunk, so no overlap\n+    _freeze_size += overlap; \/\/ we're allocating a new chunk, so no overlap\n@@ -884,1 +892,1 @@\n-    chunk = allocate_chunk_slow(_size);\n+    chunk = allocate_chunk_slow(_freeze_size);\n@@ -889,0 +897,3 @@\n+    \/\/ Install new chunk\n+    _cont.set_tail(chunk);\n+\n@@ -899,1 +910,1 @@\n-      _size += overlap;\n+      _freeze_size += overlap;\n@@ -917,1 +928,1 @@\n-  chunk->set_max_size(chunk->max_size() + _size - frame::metadata_words);\n+  chunk->set_max_size(chunk->max_size() + _freeze_size - frame::metadata_words);\n@@ -928,2 +939,2 @@\n-  assert(chunk->is_in_chunk(_last_write - _size),\n-    \"last_write-size: \" INTPTR_FORMAT \" start: \" INTPTR_FORMAT, p2i(_last_write-_size), p2i(chunk->start_address()));\n+  assert(chunk->is_in_chunk(_last_write - _freeze_size),\n+    \"last_write-size: \" INTPTR_FORMAT \" start: \" INTPTR_FORMAT, p2i(_last_write-_freeze_size), p2i(chunk->start_address()));\n@@ -1003,1 +1014,1 @@\n-    frame_method->name_and_sig_as_C_string(), _size, fsize, argsize);\n+    frame_method->name_and_sig_as_C_string(), _freeze_size, fsize, argsize);\n@@ -1017,1 +1028,1 @@\n-  _align_size += frame::align_wiggle; \/\/ add alignment room for internal interpreted frame alignment om AArch64\n+  _total_align_size += frame::align_wiggle; \/\/ add alignment room for internal interpreted frame alignment om AArch64\n@@ -1050,1 +1061,1 @@\n-                             _size, fsize, argsize);\n+                             _freeze_size, fsize, argsize);\n@@ -1071,1 +1082,1 @@\n-    _align_size += frame::align_wiggle; \/\/ See Thaw::align\n+    _total_align_size += frame::align_wiggle; \/\/ See Thaw::align\n@@ -1088,1 +1099,1 @@\n-    f.cb()->name(), _size, fsize, p2i(frame_sp), p2i(frame_sp+fsize));\n+    f.cb()->name(), _freeze_size, fsize, p2i(frame_sp), p2i(frame_sp+fsize));\n@@ -1092,1 +1103,1 @@\n-  _size += fsize;\n+  _freeze_size += fsize;\n@@ -1140,1 +1151,1 @@\n-  chunk->set_max_size(chunk->max_size() + _align_size);\n+  chunk->set_max_size(chunk->max_size() + _total_align_size);\n@@ -1241,2 +1252,0 @@\n-\n-  _cont.set_tail(chunk);\n@@ -1340,1 +1349,1 @@\n-  oop oopCont = get_continuation(current);\n+  oop oopCont = entry->cont_oop();\n@@ -1360,1 +1369,1 @@\n-  Freeze<ConfigT> fr(current, cont, false);\n+  Freeze<ConfigT> freeze(current, cont, sp);\n@@ -1368,3 +1377,2 @@\n-  if (fast && fr.is_chunk_available_for_fast_freeze(sp)) {\n-    freeze_result res = fr.template try_freeze_fast<true>(sp);\n-    assert(res == freeze_ok, \"\");\n+  if (fast && freeze.size_if_fast_freeze_available() > 0) {\n+    freeze.freeze_fast_existing_chunk();\n@@ -1382,1 +1390,3 @@\n-    fr.set_jvmti_event_collector(&jsoaec);\n+    freeze.set_jvmti_event_collector(&jsoaec);\n+\n+    freeze_result res = fast ? freeze.try_freeze_fast() : freeze.freeze_slow();\n@@ -1384,2 +1394,0 @@\n-    freeze_result res = fast ? fr.template try_freeze_fast<false>(sp)\n-                             : fr.freeze_slow();\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":170,"deletions":162,"binary":false,"changes":332,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.vm;\n+\n+public class StackChunk {\n+    int i;\n+    int j;\n+    String myName;\n+    public StackChunk() {\n+        System.out.println(\"Constructor called\");\n+        myName = \"StackChunk\";\n+        i = 55;\n+        j = 66;\n+    }\n+    public void print() {\n+        System.out.println(\"My name is \" + myName);\n+    }\n+    public int getI() { return i; }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/StackChunk.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test StackChunkClassLoaderTest\n+ * @summary Test that a different jdk.internal.vm.StackChunk can be loaded by non-null class loader\n+ * @library \/test\/lib\n+ * @compile StackChunk.java\n+ * @run main\/othervm StackChunkClassLoaderTest\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.io.FileInputStream;\n+import java.io.File;\n+\n+public class StackChunkClassLoaderTest extends ClassLoader {\n+\n+    public String loaderName;\n+\n+    StackChunkClassLoaderTest(String name) {\n+        this.loaderName = name;\n+    }\n+\n+    \/\/ Get data for pre-compiled class file to load.\n+    public byte[] getClassData(String name) {\n+        try {\n+            String classDir = System.getProperty(\"test.classes\");\n+            String tempName = name.replaceAll(\"\\\\.\", \"\/\");\n+            return new FileInputStream(classDir + File.separator + tempName + \".class\").readAllBytes();\n+        } catch (Exception e) {\n+              return null;\n+        }\n+    }\n+\n+    public Class loadClass(String name) throws ClassNotFoundException {\n+        if (!name.contains(\"StackChunk\")) {\n+            return super.loadClass(name);\n+        }\n+\n+        byte[] data = getClassData(name);\n+        System.out.println(\"name is \" + name);\n+        return defineClass(name, data, 0, data.length);\n+    }\n+\n+  public static void main(java.lang.String[] unused) throws Exception {\n+      ClassLoader cl = new StackChunkClassLoaderTest(\"StackChunkClassLoaderTest\");\n+      Class<?> c = Class.forName(\"jdk.internal.vm.StackChunk\", true, cl);\n+      Object obj = c.getDeclaredConstructor().newInstance();\n+      System.gc();\n+      java.lang.reflect.Method m = c.getMethod(\"print\");\n+      m.invoke(obj);\n+      Method mi = c.getMethod(\"getI\");\n+      Object val = mi.invoke(obj);\n+      if (((Integer)val).intValue() != 55) {\n+          throw new RuntimeException(\"Test failed, StackChunk object corrupt\");\n+      }\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/vthread\/StackChunkClassLoaderTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.concurrent.ThreadFactory;\n@@ -37,3 +38,2 @@\n- * @compile --enable-preview -source ${jdk.version} HeapMonitorVMEventsTest.java\n- * @run main\/othervm\/native --enable-preview\n- *                          -XX:+UnlockDiagnosticVMOptions\n+ * @compile HeapMonitorVMEventsTest.java\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions\n@@ -119,3 +119,2 @@\n-        Thread t = Thread.ofVirtual().start(() -> {\n-                compareSampledAndVM();\n-            });\n+        Thread t = virtualThreadFactory().newThread(HeapMonitorVMEventsTest::compareSampledAndVM);\n+        t.start();\n@@ -127,0 +126,13 @@\n+\n+  private static ThreadFactory virtualThreadFactory() {\n+    try {\n+        Object builder = Thread.class.getMethod(\"ofVirtual\").invoke(null);\n+        Class<?> clazz = Class.forName(\"java.lang.Thread$Builder\");\n+        java.lang.reflect.Method factory = clazz.getMethod(\"factory\");\n+        return (ThreadFactory) factory.invoke(builder);\n+    } catch (RuntimeException | Error e) {\n+        throw e;\n+    } catch (Exception e) {\n+        throw new RuntimeException(e);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HeapMonitor\/MyPackage\/HeapMonitorVMEventsTest.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"}]}