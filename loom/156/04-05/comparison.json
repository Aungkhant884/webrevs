{"files":[{"patch":"@@ -339,1 +339,1 @@\n-  const intptr_t * const _frame_sp;\n+  const intptr_t * const _frame_sp; \/\/ Top frame sp for this freeze\n@@ -343,2 +343,2 @@\n-  int _size; \/\/ total size of all frames plus metadata in words.\n-  int _align_size;\n+  int _freeze_size; \/\/ total size of all frames plus metadata in words.\n+  int _total_align_size;\n@@ -348,1 +348,0 @@\n-  int _cont_size;\n@@ -354,1 +353,1 @@\n-  int _is_chunk_available_size;\n+  int _fast_freeze_size;\n@@ -372,1 +371,1 @@\n-  inline int is_chunk_available_for_fast_freeze();\n+  inline int size_if_fast_freeze_available();\n@@ -387,0 +386,2 @@\n+  int cont_size() { return _cont_stack_bottom - _cont_stack_top; }\n+\n@@ -467,1 +468,0 @@\n-  _cont_size = _cont_stack_bottom - _cont_stack_top;\n@@ -470,2 +470,2 @@\n-    _cont_size, _cont.argsize(), p2i(_cont_stack_top), p2i(_cont_stack_bottom));\n-  assert(_cont_size > 0, \"\");\n+    cont_size(), _cont.argsize(), p2i(_cont_stack_top), p2i(_cont_stack_bottom));\n+  assert(cont_size() > 0, \"\");\n@@ -475,2 +475,2 @@\n-  _size = 0;\n-  _align_size = 0;\n+  _freeze_size = 0;\n+  _total_align_size = 0;\n@@ -504,1 +504,1 @@\n-  stackChunkOop chunk = allocate_chunk(_cont_size + frame::metadata_words);\n+  stackChunkOop chunk = allocate_chunk(cont_size() + frame::metadata_words);\n@@ -523,2 +523,2 @@\n-\/\/ returns true iff there's room in the chunk for a fast, compiled-frame-only freeze\n-int FreezeBase::is_chunk_available_for_fast_freeze() {\n+\/\/ Returns size needed if the continuation fits, otherwise 0.\n+int FreezeBase::size_if_fast_freeze_available() {\n@@ -531,1 +531,0 @@\n-  \/\/ assert(CodeCache::find_blob(*(address*)(frame_sp - SENDER_SP_RET_ADDRESS_OFFSET)) == StubRoutines::cont_doYield_stub(), \"\"); -- fails on Windows\n@@ -534,1 +533,1 @@\n-  int ret_size = _cont_size;\n+  int total_size_needed = cont_size();\n@@ -537,1 +536,1 @@\n-    ret_size -= _cont.argsize();\n+    total_size_needed -= _cont.argsize();\n@@ -540,4 +539,4 @@\n-  bool available = chunk_sp - frame::metadata_words >= ret_size;\n-  log_develop_trace(continuations)(\"chunk available: %d size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n-    available, _cont.argsize(), ret_size, p2i(_cont_stack_top), p2i(_cont_stack_bottom));\n-  return available ? ret_size : 0;\n+  bool available = chunk_sp - frame::metadata_words >= total_size_needed;\n+  log_develop_trace(continuations)(\"chunk available: %s size: %d argsize: %d top: \" INTPTR_FORMAT \" bottom: \" INTPTR_FORMAT,\n+    available ? \"yes\" : \"no\" , total_size_needed, _cont.argsize(), p2i(_cont_stack_top), p2i(_cont_stack_bottom));\n+  return available ? total_size_needed : 0;\n@@ -550,2 +549,2 @@\n-  DEBUG_ONLY(_is_chunk_available_size = is_chunk_available_for_fast_freeze();)\n-  assert(_is_chunk_available_size > 0, \"\");\n+  DEBUG_ONLY(_fast_freeze_size = size_if_fast_freeze_available();)\n+  assert(_fast_freeze_size > 0, \"\");\n@@ -563,1 +562,1 @@\n-    chunk->set_max_size(chunk->max_size() + _cont_size - _cont.argsize());\n+    chunk->set_max_size(chunk->max_size() + cont_size() - _cont.argsize());\n@@ -583,1 +582,1 @@\n-    chunk->set_max_size(_cont_size);\n+    chunk->set_max_size(cont_size());\n@@ -592,1 +591,1 @@\n-  DEBUG_ONLY(_is_chunk_available_size = is_chunk_available_for_fast_freeze();)\n+  DEBUG_ONLY(_fast_freeze_size = size_if_fast_freeze_available();)\n@@ -594,1 +593,1 @@\n-  assert(_is_chunk_available_size == 0, \"\");\n+  assert(_fast_freeze_size == 0, \"\");\n@@ -606,1 +605,1 @@\n-  chunk->set_max_size(_cont_size);\n+  chunk->set_max_size(cont_size());\n@@ -611,1 +610,1 @@\n-  const int chunk_start_sp = _cont_size + frame::metadata_words;\n+  const int chunk_start_sp = cont_size() + frame::metadata_words;\n@@ -638,1 +637,1 @@\n-  assert(chunk_start_sp >= _cont_size, \"no room in the chunk\");\n+  assert(chunk_start_sp >= cont_size(), \"no room in the chunk\");\n@@ -640,2 +639,2 @@\n-  const int chunk_new_sp = chunk_start_sp - _cont_size; \/\/ the chunk's new sp, after freeze\n-  assert(!(_is_chunk_available_size > 0) || _orig_chunk_sp - (chunk->start_address() + chunk_new_sp) == _is_chunk_available_size, \"\");\n+  const int chunk_new_sp = chunk_start_sp - cont_size(); \/\/ the chunk's new sp, after freeze\n+  assert(!(_fast_freeze_size > 0) || _orig_chunk_sp - (chunk->start_address() + chunk_new_sp) == _fast_freeze_size, \"\");\n@@ -650,1 +649,1 @@\n-  copy_to_chunk(from, to, _cont_size + frame::metadata_words);\n+  copy_to_chunk(from, to, cont_size() + frame::metadata_words);\n@@ -654,1 +653,1 @@\n-  intptr_t* chunk_bottom_sp = chunk_top + _cont_size - _cont.argsize();\n+  intptr_t* chunk_bottom_sp = chunk_top + cont_size() - _cont.argsize();\n@@ -793,1 +792,1 @@\n-  _size += fsize;\n+  _freeze_size += fsize;\n@@ -836,1 +835,1 @@\n-    p2i(_bottom_address), _frames, _size << LogBytesPerWord, argsize);\n+    p2i(_bottom_address), _frames, _freeze_size << LogBytesPerWord, argsize);\n@@ -849,1 +848,1 @@\n-  _size += frame::metadata_words; \/\/ for top frame's metadata\n+  _freeze_size += frame::metadata_words; \/\/ for top frame's metadata\n@@ -868,1 +867,1 @@\n-  log_develop_trace(continuations)(\"finalize _size: %d overlap: %d unextended_sp: %d\", _size, overlap, unextended_sp);\n+  log_develop_trace(continuations)(\"finalize _size: %d overlap: %d unextended_sp: %d\", _freeze_size, overlap, unextended_sp);\n@@ -870,2 +869,2 @@\n-  _size -= overlap;\n-  assert(_size >= 0, \"\");\n+  _freeze_size -= overlap;\n+  assert(_freeze_size >= 0, \"\");\n@@ -875,1 +874,1 @@\n-  assert(chunk != nullptr || unextended_sp < _size, \"\");\n+  assert(chunk != nullptr || unextended_sp < _freeze_size, \"\");\n@@ -878,2 +877,2 @@\n-  assert(!_barriers || (unextended_sp >= _size && chunk->is_empty()),\n-    \"unextended_sp: %d size: %d is_empty: %d\", unextended_sp, _size, chunk->is_empty());\n+  assert(!_barriers || (unextended_sp >= _freeze_size && chunk->is_empty()),\n+    \"unextended_sp: %d size: %d is_empty: %d\", unextended_sp, _freeze_size, chunk->is_empty());\n@@ -882,1 +881,1 @@\n-  if (unextended_sp < _size || chunk->is_gc_mode() || (!_barriers && chunk->requires_barriers())) {\n+  if (unextended_sp < _freeze_size || chunk->is_gc_mode() || (!_barriers && chunk->requires_barriers())) {\n@@ -891,1 +890,1 @@\n-          chunk->requires_barriers(), _size, chunk->sp() - frame::metadata_words);\n+          chunk->requires_barriers(), _freeze_size, chunk->sp() - frame::metadata_words);\n@@ -896,1 +895,1 @@\n-    _size += overlap; \/\/ we're allocating a new chunk, so no overlap\n+    _freeze_size += overlap; \/\/ we're allocating a new chunk, so no overlap\n@@ -899,1 +898,1 @@\n-    chunk = allocate_chunk_slow(_size);\n+    chunk = allocate_chunk_slow(_freeze_size);\n@@ -917,1 +916,1 @@\n-      _size += overlap;\n+      _freeze_size += overlap;\n@@ -935,1 +934,1 @@\n-  chunk->set_max_size(chunk->max_size() + _size - frame::metadata_words);\n+  chunk->set_max_size(chunk->max_size() + _freeze_size - frame::metadata_words);\n@@ -946,2 +945,2 @@\n-  assert(chunk->is_in_chunk(_last_write - _size),\n-    \"last_write-size: \" INTPTR_FORMAT \" start: \" INTPTR_FORMAT, p2i(_last_write-_size), p2i(chunk->start_address()));\n+  assert(chunk->is_in_chunk(_last_write - _freeze_size),\n+    \"last_write-size: \" INTPTR_FORMAT \" start: \" INTPTR_FORMAT, p2i(_last_write-_freeze_size), p2i(chunk->start_address()));\n@@ -1021,1 +1020,1 @@\n-    frame_method->name_and_sig_as_C_string(), _size, fsize, argsize);\n+    frame_method->name_and_sig_as_C_string(), _freeze_size, fsize, argsize);\n@@ -1035,1 +1034,1 @@\n-  _align_size += frame::align_wiggle; \/\/ add alignment room for internal interpreted frame alignment om AArch64\n+  _total_align_size += frame::align_wiggle; \/\/ add alignment room for internal interpreted frame alignment om AArch64\n@@ -1068,1 +1067,1 @@\n-                             _size, fsize, argsize);\n+                             _freeze_size, fsize, argsize);\n@@ -1089,1 +1088,1 @@\n-    _align_size += frame::align_wiggle; \/\/ See Thaw::align\n+    _total_align_size += frame::align_wiggle; \/\/ See Thaw::align\n@@ -1106,1 +1105,1 @@\n-    f.cb()->name(), _size, fsize, p2i(frame_sp), p2i(frame_sp+fsize));\n+    f.cb()->name(), _freeze_size, fsize, p2i(frame_sp), p2i(frame_sp+fsize));\n@@ -1110,1 +1109,1 @@\n-  _size += fsize;\n+  _freeze_size += fsize;\n@@ -1161,1 +1160,1 @@\n-  chunk->set_max_size(chunk->max_size() + _align_size);\n+  chunk->set_max_size(chunk->max_size() + _total_align_size);\n@@ -1408,3 +1407,2 @@\n-  volatile bool fast = can_freeze_fast(current);\n-  volatile int  chunk_av_size = freeze.is_chunk_available_for_fast_freeze();\n-  if (fast && chunk_av_size > 0) {\n+  bool fast = can_freeze_fast(current);\n+  if (fast && freeze.size_if_fast_freeze_available() > 0) {\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":59,"deletions":61,"binary":false,"changes":120,"status":"modified"}]}