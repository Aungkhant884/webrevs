{"files":[{"patch":"@@ -3360,1 +3360,1 @@\n-    assert(objs->length() == ScopedCacheSize * 2 + 2, \"wrong length\");\n+    assert(objs->length() == ScopedCacheSize * 2, \"wrong length\");\n@@ -3370,1 +3370,1 @@\n-    assert(objs->length() == ScopedCacheSize * 2 + 2, \"wrong length\");\n+    assert(objs->length() == ScopedCacheSize * 2, \"wrong length\");\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,388 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.util.concurrent.Callable;\n+\n+\/**\n+ * TBD\n+ *\n+ * @param <T> TBD\n+ *\/\n+public final class Scoped<T> {\n+\n+    final @Stable Class<? super T> type;\n+    final @Stable int hash;\n+\n+    \/\/ Is this scope-local value inheritable? We could handle this by\n+    \/\/ making Scoped an abstract base class and scopeLocalBindings() a\n+    \/\/ virtual method, but that seems a little excessive.\n+    final @Stable boolean isInheritable;\n+\n+    public final int hashCode() { return hash; }\n+\n+    static class Binding<T> {\n+        final Scoped<T> key;\n+        final T value;\n+        final Binding<?> prev;\n+\n+        private static final Object NIL = new Object();\n+\n+        Binding(Scoped<T> key, T value, Binding<?> prev) {\n+            key.type.cast(value);\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n+        }\n+\n+        final T get() {\n+            return value;\n+        }\n+\n+        final Scoped<T> getKey() {\n+            return key;\n+        }\n+\n+        Object find(Scoped<?> key) {\n+            for (Binding<?> b = this; b != null; b = b.prev) {\n+                if (b.getKey() == key) {\n+                    Object value = b.get();\n+                    return value;\n+                }\n+            }\n+            return NIL;\n+        }\n+    }\n+\n+    private Scoped(Class<? super T> type, boolean isInheritable) {\n+        this.isInheritable = isInheritable;\n+        this.type = type;\n+        this.hash = generateKey();\n+    }\n+\n+    \/**\n+     * TBD\n+     *\n+     * @param <T>   TBD\n+     * @param <U>   TBD\n+     * @param type TBD\n+     * @return TBD\n+     *\/\n+    public static <U,T extends U> Scoped<T> forType(Class<U> type) {\n+        return new Scoped<T>(type, false);\n+    }\n+\n+    \/**\n+     * TBD\n+     *\n+     * @param <T>   TBD\n+     * @param <U>   TBD\n+     * @param type TBD\n+     * @return TBD\n+     *\/\n+    public static <U,T extends U> Scoped<T> inheritableForType(Class<U> type) {\n+        return new Scoped<T>(type, true);\n+    }\n+\n+    private final Binding<?> scopeLocalBindings() {\n+        Thread currentThread = Thread.currentThread();\n+        return isInheritable\n+                ? currentThread.inheritableScopeLocalBindings\n+                : currentThread.noninheritableScopeLocalBindings;\n+    }\n+\n+    private final void setScopeLocalBindings(Binding<?> bindings) {\n+        Thread currentThread = Thread.currentThread();\n+        if (isInheritable) {\n+            currentThread.inheritableScopeLocalBindings = bindings;\n+        } else {\n+            currentThread.noninheritableScopeLocalBindings = bindings;\n+        }\n+    }\n+\n+    \/**\n+     * TBD\n+     *\n+     * @return TBD\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean isBound() {\n+        var bindings = scopeLocalBindings();\n+        if (bindings == null) {\n+            return false;\n+        }\n+        return (bindings.find(this) != Binding.NIL);\n+    }\n+\n+    \/**\n+     * TBD\n+     *\n+     * @return TBD\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    T slowGet() {\n+        var bindings = scopeLocalBindings();\n+        if (bindings == null) {\n+            throw new RuntimeException(\"unbound\");\n+        }\n+        for (var b = bindings; b != null; b = b.prev) {\n+            if (b.getKey() == this) {\n+                return(T)b.get();\n+            }\n+        }\n+        throw new RuntimeException(\"unbound\");\n+    }\n+\n+    \/**\n+     * TBD\n+     *\n+     * @return TBD\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = Thread.scopedCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.TABLE_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.TABLE_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n+    }\n+\n+    \/**\n+     * TBD\n+     *\n+     * @param r TBD\n+     * @param value   TBD\n+     *\/\n+    public void runWithBinding(T value, Runnable r) {\n+        Binding<?> top = scopeLocalBindings();\n+        Cache.update(this, value);\n+        try {\n+            setScopeLocalBindings(new Binding<T>(this, value, top));\n+            r.run();\n+        } finally {\n+            \/\/ assert(top == Thread.currentThread().scopeLocalBindings.prev);\n+            setScopeLocalBindings(top);\n+            Cache.remove(this);\n+        }\n+    }\n+\n+    \/**\n+     * TBD\n+     *\n+     * @param <T>   TBD\n+     * @param <X>   TBD\n+     * @param r TBD\n+     * @param value TBD\n+     * @return TBD\n+     * @throws Exception TBD\n+     *\/\n+    public <X> X callWithBinding(T value, Callable<X> r) throws Exception {\n+        Binding<?> top = scopeLocalBindings();\n+        Cache.update(this, value);\n+        try {\n+            setScopeLocalBindings(new Binding<T>(this, value, top));\n+            return r.call();\n+        } finally {\n+            setScopeLocalBindings(top);\n+            Cache.remove(this);\n+        }\n+    }\n+\n+    private static class Cache {\n+\n+        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n+        static final int TABLE_SIZE = 1 << INDEX_BITS;\n+        static final int TABLE_MASK = TABLE_SIZE - 1;\n+\n+        static void put(Scoped<?> key, Object value) {\n+            if (Thread.scopedCache() == null) {\n+                Thread.setScopedCache(new Object[TABLE_SIZE * 2]);\n+            }\n+            setKeyAndObjectAt(chooseVictim(Thread.currentCarrierThread(), key.hashCode()), key, value);\n+        }\n+\n+        private static final void update(Object key, Object value) {\n+            Object[] objects;\n+            if ((objects = Thread.scopedCache()) != null) {\n+\n+                int k1 = key.hashCode() & TABLE_MASK;\n+                if (getKey(objects, k1) == key) {\n+                    setKeyAndObjectAt(k1, key, value);\n+                }\n+                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n+                if (getKey(objects, k2) == key) {\n+                    setKeyAndObjectAt(k2, key, value);\n+                }\n+            }\n+        }\n+\n+        private static final void remove(Object key) {\n+            Object[] objects;\n+            if ((objects = Thread.scopedCache()) != null) {\n+\n+                int k1 = key.hashCode() & TABLE_MASK;\n+                if (getKey(objects, k1) == key) {\n+                    setKeyAndObjectAt(k1, null, null);\n+                }\n+                int k2 = (key.hashCode() >> INDEX_BITS) & TABLE_MASK;\n+                if (getKey(objects, k2) == key) {\n+                    setKeyAndObjectAt(k2, null, null);\n+                }\n+            }\n+        }\n+\n+        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n+            Thread.scopedCache()[n * 2] = key;\n+            Thread.scopedCache()[n * 2 + 1] = value;\n+        }\n+\n+        private static Object getKey(Object[] objs, long hash) {\n+            int n = (int) (hash & TABLE_MASK);\n+            return objs[n * 2];\n+        }\n+\n+        private static void setKey(Object[] objs, long hash, Object key) {\n+            int n = (int) (hash & TABLE_MASK);\n+            objs[n * 2] = key;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n+        final Object getKey(int n) {\n+            return Thread.scopedCache()[n * 2];\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")  \/\/ one map has entries for all types <T>\n+        private static Object getObject(int n) {\n+            return Thread.scopedCache()[n * 2 + 1];\n+        }\n+\n+        private static int chooseVictim(Thread thread, int hash) {\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            int k1 = hash & TABLE_MASK;\n+            int k2 = (hash >> INDEX_BITS) & TABLE_MASK;\n+            int tmp = thread.victims;\n+            thread.victims = (tmp << 31) | (tmp >>> 1);\n+            return (tmp & 1) == 0 ? k1 : k2;\n+        }\n+\n+        public static void invalidate() {\n+            Thread.setScopedCache(null);\n+        }\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes are\n+    \/\/ different.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while ((x & Cache.TABLE_MASK)\n+                == ((x >>> Cache.INDEX_BITS) & Cache.TABLE_MASK));\n+        return (nextKey = x);\n+    }\n+\n+    \/**\n+     * TBD\n+     *\/\n+     public static final class Snapshot {\n+        private final Binding<?> bindings;\n+\n+        \/**\n+         * TBD\n+         * @return TBD\n+         *\/\n+        private Snapshot() {\n+            bindings = Thread.currentThread().inheritableScopeLocalBindings;\n+        }\n+\n+        \/**\n+         * TBD\n+         * @param r TBD\n+         *\/\n+        @SuppressWarnings(\"rawtypes\")\n+        public void runWithSnapshot(Runnable r) {\n+            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+            var cache = Thread.scopedCache();\n+            Cache.invalidate();\n+            try {\n+                Thread.currentThread().inheritableScopeLocalBindings = bindings;\n+                r.run();\n+            } finally {\n+                Thread.currentThread().inheritableScopeLocalBindings = prev;\n+                Thread.setScopedCache(cache);\n+            }\n+        }\n+\n+        \/**\n+         * @param r TBD\n+         * @param <T> type\n+         * @return T tbd\n+         * @throws Exception TBD\n+         *\/\n+        public <T> T callWithSnapshot(Callable<T> r) throws Exception {\n+            var prev = Thread.currentThread().inheritableScopeLocalBindings;\n+            var cache = Thread.scopedCache();\n+            Cache.invalidate();\n+            try {\n+                Thread.currentThread().inheritableScopeLocalBindings = bindings;\n+                return r.call();\n+            } finally {\n+                Thread.currentThread().inheritableScopeLocalBindings = prev;\n+                Thread.setScopedCache(cache);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * TBD\n+     * @return TBD\n+     *\/\n+    public static final Snapshot snapshot() {\n+        return new Snapshot();\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Scoped.java","additions":388,"deletions":0,"binary":false,"changes":388,"status":"added"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Red Hat, Inc. and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang;\n-\n-\/**\n- * TBD\n- *\/\n-public class ScopedAlreadyBoundException extends RuntimeException {\n-    @java.io.Serial\n-    static final long serialVersionUID = -9106475100367583963L;\n-\n-    \/**\n-     * Constructs a new exception with the specified detail message.\n-     * @param   message   the detail message. The detail message is saved for\n-     *          later retrieval by the {@link #getMessage()} method.\n-     *\/\n-    public ScopedAlreadyBoundException(String message) {\n-        super(message);\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedAlreadyBoundException.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -176,0 +176,9 @@\n+\n+    \/\/ A simple (not very) random string of bits to use when evicting\n+    \/\/ cache entries.\n+    int victims\n+        = 0b1100_1001_0000_1111_1101_1010_1010_0010;\n+\n+    Scoped.Binding<?> noninheritableScopeLocalBindings;\n+    Scoped.Binding<?> inheritableScopeLocalBindings;\n+\n@@ -576,0 +585,2 @@\n+        this.inheritableScopeLocalBindings = parent.inheritableScopeLocalBindings;\n+\n@@ -619,0 +630,2 @@\n+        this.inheritableScopeLocalBindings = parent.inheritableScopeLocalBindings;\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}