{"files":[{"patch":"@@ -529,1 +529,2 @@\n-  JavaThread* const _thread;\n+  JavaThread* const _current;  \/\/ Current thread\n+  JavaThread* const _thread;   \/\/ Thread being frozen\/thawed\n@@ -548,1 +549,2 @@\n-  ContMirror(JavaThread* thread, oop cont); \/\/ does not automatically read the continuation object\n+  \/\/ does not automatically read the continuation object\n+  ContMirror(JavaThread* current, JavaThread* thread, oop cont);\n@@ -593,1 +595,1 @@\n-  address last_pc() { return last_nonempty_chunk()->pc(); } \n+  address last_pc() { return last_nonempty_chunk()->pc(); }\n@@ -691,2 +693,2 @@\n-ContMirror::ContMirror(JavaThread* thread, oop cont)\n- : _thread(thread), _entry(thread->last_continuation()), _cont(cont),\n+ContMirror::ContMirror(JavaThread* current, JavaThread* thread, oop cont)\n+ : _current(current), _thread(thread), _entry(thread->last_continuation()), _cont(cont),\n@@ -697,0 +699,2 @@\n+\n+  assert(current == JavaThread::current(), \"should be\");\n@@ -698,1 +702,2 @@\n-  assert (_cont == _entry->cont_oop(), \"mirror: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \" INTPTR_FORMAT, p2i((oopDesc*)_cont), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n+  assert (_cont == _entry->cont_oop(), \"mirror: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \"\n+          INTPTR_FORMAT, p2i((oopDesc*)_cont), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n@@ -702,1 +707,1 @@\n- : _thread(nullptr), _entry(nullptr), _cont(cont),\n+ : _current(nullptr), _thread(nullptr), _entry(nullptr), _cont(cont),\n@@ -713,1 +718,4 @@\n- : _thread(map->thread()), _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())), _cont(map->stack_chunk()->cont()),\n+ : _current(nullptr),\n+   _thread(map->thread()),\n+   _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())),\n+   _cont(map->stack_chunk()->cont()),\n@@ -718,0 +726,1 @@\n+\n@@ -735,1 +744,1 @@\n-  \/\/   if (_tail != nullptr) _tail->print_on(tty);  \n+  \/\/   if (_tail != nullptr) _tail->print_on(tty);\n@@ -942,1 +951,1 @@\n-    return ((sw = StackWatermarkSet::get(_thread, StackWatermarkKind::gc)) != nullptr \n+    return ((sw = StackWatermarkSet::get(_thread, StackWatermarkKind::gc)) != nullptr\n@@ -958,1 +967,1 @@\n-    assert (_last_write == to + size, \"Missed a spot: _last_write: \" INTPTR_FORMAT \" to+size: \" INTPTR_FORMAT \" stack_size: %d _last_write offset: %ld to+size: %ld\", \n+    assert (_last_write == to + size, \"Missed a spot: _last_write: \" INTPTR_FORMAT \" to+size: \" INTPTR_FORMAT \" stack_size: %d _last_write offset: %ld to+size: %ld\",\n@@ -1093,1 +1102,1 @@\n-      \n+\n@@ -1110,1 +1119,1 @@\n-      \n+\n@@ -1128,1 +1137,1 @@\n-      \n+\n@@ -1201,1 +1210,0 @@\n-   assert (_thread->thread_state() == _thread_in_vm, \"\");\n@@ -1216,1 +1224,1 @@\n-    \n+\n@@ -1228,1 +1236,1 @@\n-  \n+\n@@ -1374,1 +1382,1 @@\n-    \n+\n@@ -1434,1 +1442,1 @@\n-    \n+\n@@ -1473,1 +1481,1 @@\n-      \n+\n@@ -1499,1 +1507,1 @@\n-    \n+\n@@ -1522,1 +1530,1 @@\n-    \n+\n@@ -1838,1 +1846,3 @@\n-  assert (!preempt || current->thread_state() == _thread_in_vm || current->thread_state() == _thread_blocked \/*|| current->thread_state() == _thread_in_native*\/, \"thread_state: %d %s\", current->thread_state(), current->thread_state_name());\n+  assert (!preempt || current->thread_state() == _thread_in_vm || current->thread_state() == _thread_blocked\n+          \/*|| current->thread_state() == _thread_in_native*\/,\n+          \"thread_state: %d %s\", current->thread_state(), current->thread_state_name());\n@@ -1842,1 +1852,3 @@\n-    p2i(current->last_continuation()->entry_sp()), p2i(current->last_continuation()->entry_fp()), p2i(current->last_continuation()->entry_pc()));\n+                             p2i(current->last_continuation()->entry_sp()),\n+                             p2i(current->last_continuation()->entry_fp()),\n+                             p2i(current->last_continuation()->entry_pc()));\n@@ -1858,1 +1870,1 @@\n-  ContMirror cont(current, oopCont);\n+  ContMirror cont(preempt ? JavaThread::current() : current, current, oopCont);\n@@ -1873,1 +1885,1 @@\n-  \n+\n@@ -1875,1 +1887,0 @@\n-    assert (current->thread_state() == _thread_in_vm, \"\");\n@@ -1888,1 +1899,1 @@\n-  \n+\n@@ -1899,0 +1910,1 @@\n+  assert(current == JavaThread::current(), \"must be current thread except for preempt\");\n@@ -2164,1 +2176,1 @@\n-    return    !_barriers \n+    return    !_barriers\n@@ -2181,1 +2193,1 @@\n-    \n+\n@@ -2236,1 +2248,1 @@\n-      \n+\n@@ -2240,1 +2252,1 @@\n-      \n+\n@@ -2371,1 +2383,1 @@\n-    \n+\n@@ -2402,1 +2414,1 @@\n-  \n+\n@@ -2453,1 +2465,1 @@\n-    \n+\n@@ -2465,1 +2477,1 @@\n-    \n+\n@@ -2473,1 +2485,1 @@\n-  \n+\n@@ -2520,1 +2532,1 @@\n-    \n+\n@@ -2653,1 +2665,1 @@\n-    \n+\n@@ -2772,1 +2784,1 @@\n-  ContMirror cont(thread, oopCont);\n+  ContMirror cont(thread, thread, oopCont);\n@@ -3078,1 +3090,1 @@\n-  \n+\n@@ -3097,1 +3109,1 @@\n- \n+\n@@ -3175,0 +3187,1 @@\n+  assert(_current == JavaThread::current(), \"should be current\");\n@@ -3177,1 +3190,1 @@\n-  HeapWord* start = _thread->tlab().allocate(size_in_words);\n+  HeapWord* start = _current->tlab().allocate(size_in_words);\n@@ -3180,10 +3193,0 @@\n-  } else {\n-    assert (_thread == Thread::current(), \"\");\n-    \/\/HandleMark hm(_thread);\n-    Handle conth(_thread, _cont);\n-    \/\/ uint64_t counter = SafepointSynchronize::safepoint_counter();\n-    stackChunkOop result = (stackChunkOop)allocator.allocate();\n-    \/\/if (!SafepointSynchronize::is_same_safepoint(counter)) {\n-      post_safepoint(conth);\n-    \/\/}\n-    return result;\n@@ -3191,0 +3194,6 @@\n+\n+  \/\/HandleMark hm(_current);\n+  Handle conth(_current, _cont);\n+  stackChunkOop result = (stackChunkOop)allocator.allocate();\n+  post_safepoint(conth);\n+  return result;\n@@ -3210,36 +3219,3 @@\n-  JavaThread* thread = JavaThread::thread_from_jni_environment(env);\n-\n-  class ForceYieldClosure : public HandshakeClosure {\n-    jobject _jcont;\n-    jint _result;\n-\n-    bool can_be_processed_by(Thread* thread) {\n-      return thread->is_Java_thread();\n-    }\n-\n-    void do_thread(Thread* th) {\n-      \/\/ assert (th == Thread::current(), \"\"); -- the handshake can be carried out by a VM thread (see HandshakeState::process_by_vmthread)\n-      assert (th->is_Java_thread(), \"\");\n-      guarantee (Thread::current()->is_Java_thread(), \"Thread: %s\", Thread::current()->name());\n-      JavaThread* thread = (JavaThread*)th;\n-\n-      \/\/ tty->print_cr(\">>> ForceYieldClosure thread\");\n-      \/\/ thread->print_on(tty);\n-      \/\/ if (thread != Thread::current()) {\n-      \/\/   tty->print_cr(\">>> current thread\");\n-      \/\/   Thread::current()->print_on(tty);\n-      \/\/ }\n-\n-      oop oopCont = JNIHandles::resolve_non_null(_jcont);\n-      _result = Continuation::try_force_yield(thread, oopCont);\n-    }\n-\n-  public:\n-    ForceYieldClosure(jobject jcont) : HandshakeClosure(\"ContinuationForceYieldClosure\"), _jcont(jcont), _result(-1) {}\n-    jint result() const { return _result; }\n-  };\n-  ForceYieldClosure fyc(jcont);\n-\n-  \/\/ tty->print_cr(\"TRY_FORCE_YIELD0\");\n-  \/\/ thread->print();\n-  \/\/ tty->print_cr(\"\");\n+  JavaThread* current = JavaThread::thread_from_jni_environment(env);\n+  assert(current == JavaThread::current(), \"should be\");\n+  jint result = -1; \/\/ no continuation (should have enum)\n@@ -3250,1 +3226,7 @@\n-    Handshake::execute(&fyc, target);\n+    assert(target != current, \"should be different threads\");\n+    \/\/ Suspend the target thread and freeze it.\n+    if (target->block_suspend(current)) {\n+      oop oopCont = JNIHandles::resolve_non_null(jcont);\n+      result = Continuation::try_force_yield(target, oopCont);\n+      target->continue_resume(current);\n+    }\n@@ -3252,2 +3234,1 @@\n-\n-  return fyc.result();\n+  return result;\n@@ -3573,1 +3554,1 @@\n-  \n+\n@@ -3585,1 +3566,1 @@\n-  \n+\n@@ -3593,1 +3574,1 @@\n-  \n+\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":76,"deletions":95,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -409,0 +409,1 @@\n+  _caller(nullptr),\n@@ -611,1 +612,1 @@\n-  while (is_suspended()) {\n+  while (is_suspended_or_blocked()) {\n@@ -633,3 +634,2 @@\n-bool HandshakeState::suspend_with_handshake() {\n-  if (_handshakee->is_exiting() ||\n-     _handshakee->threadObj() == NULL) {\n+bool HandshakeState::suspend_with_handshake(JavaThread* caller) {\n+  if (_handshakee->is_exiting()) {\n@@ -639,0 +639,3 @@\n+  bool should_block = caller != nullptr;\n+  bool should_suspend = caller == nullptr;\n+\n@@ -640,3 +643,2 @@\n-    if (is_suspended()) {\n-      \/\/ Target is already suspended.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n+    if ((is_suspended() && should_suspend) || (is_blocked() && should_block)) {\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended or blocked\", p2i(_handshakee));\n@@ -644,1 +646,1 @@\n-    } else {\n+    } else if (should_suspend) {\n@@ -650,0 +652,7 @@\n+    } else {\n+      assert(should_block, \"should block\");\n+      \/\/ Target is going to wake up and leave blocking.\n+      \/\/ Let's just stop the thread from doing that.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-blocked\", p2i(_handshakee));\n+      set_caller_thread(caller);\n+      return true;\n@@ -652,2 +661,1 @@\n-  \/\/ no suspend request\n-  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n+\n@@ -655,2 +663,10 @@\n-  \/\/ from this point.\n-  set_suspended(true);\n+  \/\/ or blocked from this point.\n+  if (should_suspend) {\n+    \/\/ no suspend request\n+    assert(!is_suspended(), \"cannot be suspended without a request\");\n+    set_suspended(true);\n+  } else {\n+    assert(!is_blocked(), \"cannot be blocked without a request\");\n+    set_caller_thread(caller);\n+  }\n+\n@@ -666,1 +682,2 @@\n-  bool _did_suspend;\n+  JavaThread* _caller;\n+  bool        _did_suspend;\n@@ -668,1 +685,1 @@\n-  SuspendThreadHandshake() : HandshakeClosure(\"SuspendThread\"), _did_suspend(false) {}\n+  SuspendThreadHandshake(JavaThread* caller) : HandshakeClosure(\"SuspendThread\"), _caller(caller), _did_suspend(false) {}\n@@ -671,1 +688,1 @@\n-    _did_suspend = target->handshake_state()->suspend_with_handshake();\n+    _did_suspend = target->handshake_state()->suspend_with_handshake(_caller);\n@@ -677,1 +694,1 @@\n-  SuspendThreadHandshake st;\n+  SuspendThreadHandshake st(nullptr);\n@@ -696,0 +713,30 @@\n+\n+\/\/ One thread blocks execution of another thread until it resumes it.  This is similar to\n+\/\/ suspend, and much of the code is shared but it's a separate state from being suspended.\n+\/\/ The commonality is that the thread is self-suspended and that thread waits for both\n+\/\/ conditions to clear.\n+bool HandshakeState::block_suspend(JavaThread* caller) {\n+  assert(caller == JavaThread::current(), \"caller must be current thread\");\n+\n+  SuspendThreadHandshake st(caller);\n+  Handshake::execute(&st, _handshakee);\n+  bool suspended = st.did_suspend();\n+  return suspended;\n+}\n+\n+bool HandshakeState::continue_resume(JavaThread* caller) {\n+  assert(caller == JavaThread::current(), \"caller must be current thread\");\n+\n+  \/\/ If caller is non-null only resume blocked thread if it's the caller\n+  if (!is_blocked() || caller_thread() != caller) {\n+    return false;\n+  }\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  assert(is_blocked() && caller_thread() == caller,\n+         \"this is the only thread that can continue this thread\");\n+\n+  \/\/ Resume the thread.\n+  set_caller_thread(nullptr); \/\/ !is_blocked()\n+  _lock.notify();\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":63,"deletions":16,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+\n@@ -91,0 +92,3 @@\n+  \/\/ Caller of suspension.  Only the caller can resume the thread.\n+  JavaThread* _caller;\n+\n@@ -166,1 +170,2 @@\n-  bool suspend_with_handshake();\n+  bool suspend_with_handshake(JavaThread* caller);\n+\n@@ -171,1 +176,1 @@\n-  bool is_suspended()                       { return Atomic::load(&_suspended); }\n+  bool is_suspended() const                 { return Atomic::load(&_suspended); }\n@@ -176,0 +181,7 @@\n+  void set_caller_thread(JavaThread* caller){ return Atomic::store(&_caller, caller); }\n+  JavaThread* caller_thread() const         { return Atomic::load(&_caller); }\n+\n+  \/\/ \"blocked\" is short for saying \"suspended by caller\"\n+  bool is_blocked() const                   { return caller_thread() != nullptr; }\n+  bool is_suspended_or_blocked() const      { return is_suspended() || is_blocked(); }\n+\n@@ -178,0 +190,3 @@\n+\n+  bool block_suspend(JavaThread* caller);\n+  bool continue_resume(JavaThread* caller);\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -116,1 +116,2 @@\n-  assert(thread->thread_state() != _thread_blocked, \"Must not be\");\n+  \/\/ the suspended target is blocked tho\n+  \/\/ assert(thread->thread_state() != _thread_blocked, \"Must not be\");\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1719,1 +1719,1 @@\n-    log_develop_trace(jvmcont)(\"handle_special_runtime_exit_condition is_cont_force_yield: %d check_asyncs: %d\", is_cont_force_yield(), check_asyncs);\n+    log_develop_trace(jvmcont)(\"force_yield_if_preempted: is_cont_force_yield\");\n@@ -1721,4 +1721,2 @@\n-    if (true || check_asyncs) { \/\/ TODO: we should probably be even more selective than that\n-      \/\/ we need this only for interpreted frames -- for compiled frames we install a return barrier on the safepoint stub in Continuation::try_force_yield\n-      StubRoutines::cont_jump_from_sp_C()();\n-    }\n+    assert(thread_state() == _thread_in_Java, \"can only continue from Java state\");\n+    StubRoutines::cont_jump_from_sp_C()();\n@@ -1826,0 +1824,19 @@\n+bool JavaThread::block_suspend(JavaThread* caller) {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, no suspension\", p2i(this));\n+    return false;\n+  }\n+  return this->handshake_state()->block_suspend(caller);\n+}\n+\n+bool JavaThread::continue_resume(JavaThread* caller) {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, nothing to resume\", p2i(this));\n+    return false;\n+  }\n+  return this->handshake_state()->continue_resume(caller);\n+}\n+\n+\n@@ -2191,0 +2208,1 @@\n+  print_owned_locks_on(st);\n@@ -2340,1 +2358,1 @@\n-\/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier. \n+\/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier.\n@@ -2346,1 +2364,1 @@\n-    \n+\n@@ -2489,1 +2507,1 @@\n-  \n+\n@@ -3950,1 +3968,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":26,"deletions":9,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1205,2 +1205,3 @@\n-  bool java_suspend(); \/\/ higher-level suspension logic called by the public APIs\n-  bool java_resume();  \/\/ higher-level resume logic called by the public APIs\n+  \/\/ higher-level suspension\/resume logic called by the public APIs\n+  bool java_suspend();\n+  bool java_resume();\n@@ -1209,0 +1210,5 @@\n+  \/\/ lower-level blocking logic called by the JVM.  The caller suspends this\n+  \/\/ thread, does something, and then releases it.\n+  bool block_suspend(JavaThread* caller);\n+  bool continue_resume(JavaThread* caller);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Timing controller, might need bigger barriers\n+class Control : public AllStatic {\n+  static bool _suspend_done;\n+  static bool _block_done;\n+ public:\n+  static bool suspend_done() { return Atomic::load(&_suspend_done); }\n+  static bool block_done() { return Atomic::load(&_block_done); }\n+  static void set_suspend_done() { Atomic::store(&_suspend_done, true); }\n+  static void set_block_done() { Atomic::store(&_block_done, true); }\n+};\n+\n+bool Control::_suspend_done = false;\n+bool Control::_block_done = false;\n+\n+class BlockeeThread : public JavaTestThread {\n+  public:\n+  BlockeeThread(Semaphore* post) : JavaTestThread(post) {}\n+  virtual ~BlockeeThread() {}\n+  void main_run() {\n+    while (!Control::suspend_done()) {\n+      ThreadBlockInVM tbivm(this);\n+    }\n+  }\n+};\n+\n+class BlockingThread : public JavaTestThread {\n+  JavaThread* _target;\n+  public:\n+  BlockingThread(Semaphore* post, JavaThread* target) : JavaTestThread(post), _target(target) {}\n+  virtual ~BlockingThread() {}\n+  void main_run() {\n+    int print_count = 0;\n+    \/\/ Suspend the target thread and check its state\n+    while (!Control::block_done()) {\n+      ASSERT_LT(print_count++, 100) << \"Blocking thread - never suspended\";\n+      if (_target->block_suspend(this)) {\n+        tty->print_cr(\"Block succeeded\");\n+        Control::set_block_done();\n+        os::naked_short_sleep(10);\n+         while (!Control::suspend_done()) {\n+           ASSERT_EQ(_target->thread_state(), _thread_blocked) << \"should be blocked\";\n+        }\n+        _target->continue_resume(this);\n+        tty->print_cr(\"Release succeeded\");\n+      }\n+    }\n+  }\n+};\n+\n+class SuspendingThread : public JavaTestThread {\n+  JavaThread* _target;\n+  public:\n+  SuspendingThread(Semaphore* post, JavaThread* target) : JavaTestThread(post), _target(target) {}\n+  virtual ~SuspendingThread() {}\n+  void main_run() {\n+    int print_count = 0;\n+    int test_count = 0;\n+    \/\/ Suspend the target thread and resume it\n+    while (test_count < 100) {\n+      ASSERT_LT(print_count++, 100) << \"Suspending thread - never suspended\";\n+      if (_target->java_suspend()) {\n+        ASSERT_EQ(_target->thread_state(), _thread_blocked) << \"should be blocked\";\n+        _target->java_resume();\n+        test_count++;\n+      }\n+    }\n+    \/\/ Still blocked until Blocking thread resumes the thread\n+    ASSERT_EQ(_target->thread_state(), _thread_blocked) << \"should still be blocked\";\n+    Control::set_suspend_done();\n+  }\n+};\n+\n+\/\/ This guy should fail, then pass.\n+class AnotherBlockingThread : public JavaTestThread {\n+  JavaThread* _target;\n+  public:\n+  AnotherBlockingThread(Semaphore* post, JavaThread* target) : JavaTestThread(post), _target(target) {}\n+  virtual ~AnotherBlockingThread() {}\n+  void main_run() {\n+    bool done = false;\n+    \/\/ Suspend the target thread and check its state\n+    while (!Control::block_done()) {\n+      os::naked_short_sleep(10);\n+    }\n+    while (!done) {\n+      if (_target->block_suspend(this)) {\n+        ASSERT_EQ(Control::suspend_done(), true) << \"should only pass if Blocking thread releases the block\";\n+        tty->print_cr(\"Other Block succeeded\");\n+        _target->continue_resume(this);\n+        tty->print_cr(\"Other Release succeeded\");\n+        done = true;\n+      }\n+    }\n+  }\n+};\n+\n+#define TEST_THREAD_COUNT 4\n+\n+class DriverSuspendThread : public JavaTestThread {\n+public:\n+  Semaphore _done;\n+  DriverSuspendThread(Semaphore* post) : JavaTestThread(post) { };\n+  virtual ~DriverSuspendThread(){}\n+\n+  void main_run() {\n+    Semaphore done(0);\n+\n+    BlockeeThread* target = new BlockeeThread(&done);\n+    BlockingThread* bt = new BlockingThread(&done, target);\n+    SuspendingThread* st = new SuspendingThread(&done, target);\n+    AnotherBlockingThread* obt = new AnotherBlockingThread(&done, target);\n+\n+    target->doit();\n+    bt->doit();\n+    st->doit();\n+    obt->doit();\n+\n+    for (int i = 0; i < TEST_THREAD_COUNT; i++) {\n+      done.wait();\n+    }\n+  }\n+};\n+\n+TEST_VM(ThreadSuspend, test_thread_suspend) {\n+  mt_test_doer<DriverSuspendThread>();\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_suspend.cpp","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+* @run testng\/othervm -XX:-UseTLAB -Xint Preempt\n@@ -37,2 +38,0 @@\n-\/\/ - Add tests for additional safepoint types\n-\/\/ - Add tests with -XX:-ThreadLocalHandshakes\n","filename":"test\/jdk\/java\/lang\/Continuation\/Preempt.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}