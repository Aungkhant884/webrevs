{"files":[{"patch":"@@ -534,1 +534,1 @@\n-  JavaThread* const _thread;\n+  JavaThread* const _thread;   \/\/ Thread being frozen\/thawed\n@@ -547,1 +547,1 @@\n-  stackChunkOop allocate_stack_chunk(int stack_size);\n+  stackChunkOop allocate_stack_chunk(int stack_size, bool is_preempt);\n@@ -553,1 +553,2 @@\n-  ContMirror(JavaThread* thread, oop cont); \/\/ does not automatically read the continuation object\n+  \/\/ does not automatically read the continuation object\n+  ContMirror(JavaThread* thread, oop cont);\n@@ -598,1 +599,1 @@\n-  address last_pc() { return last_nonempty_chunk()->pc(); } \n+  address last_pc() { return last_nonempty_chunk()->pc(); }\n@@ -702,0 +703,1 @@\n+\n@@ -703,1 +705,2 @@\n-  assert (_cont == _entry->cont_oop(), \"mirror: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \" INTPTR_FORMAT, p2i((oopDesc*)_cont), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n+  assert (_cont == _entry->cont_oop(), \"mirror: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \"\n+          INTPTR_FORMAT, p2i((oopDesc*)_cont), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n@@ -718,1 +721,3 @@\n- : _thread(map->thread()), _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())), _cont(map->stack_chunk()->cont()),\n+ : _thread(map->thread()),\n+   _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())),\n+   _cont(map->stack_chunk()->cont()),\n@@ -723,0 +728,1 @@\n+\n@@ -740,1 +746,1 @@\n-  \/\/   if (_tail != nullptr) _tail->print_on(tty);  \n+  \/\/   if (_tail != nullptr) _tail->print_on(tty);\n@@ -948,1 +954,1 @@\n-    return ((sw = StackWatermarkSet::get(_thread, StackWatermarkKind::gc)) != nullptr \n+    return ((sw = StackWatermarkSet::get(_thread, StackWatermarkKind::gc)) != nullptr\n@@ -964,1 +970,1 @@\n-    assert (_last_write == to + size, \"Missed a spot: _last_write: \" INTPTR_FORMAT \" to+size: \" INTPTR_FORMAT \" stack_size: %d _last_write offset: %ld to+size: %ld\", \n+    assert (_last_write == to + size, \"Missed a spot: _last_write: \" INTPTR_FORMAT \" to+size: \" INTPTR_FORMAT \" stack_size: %d _last_write offset: %ld to+size: %ld\",\n@@ -1099,1 +1105,1 @@\n-      \n+\n@@ -1116,1 +1122,1 @@\n-      \n+\n@@ -1134,1 +1140,1 @@\n-      \n+\n@@ -1207,1 +1213,0 @@\n-   assert (_thread->thread_state() == _thread_in_vm, \"\");\n@@ -1222,1 +1227,1 @@\n-    \n+\n@@ -1234,1 +1239,1 @@\n-  \n+\n@@ -1383,1 +1388,1 @@\n-    \n+\n@@ -1443,1 +1448,1 @@\n-    \n+\n@@ -1482,1 +1487,1 @@\n-      \n+\n@@ -1508,1 +1513,1 @@\n-    \n+\n@@ -1533,1 +1538,1 @@\n-    \n+\n@@ -1676,1 +1681,1 @@\n-    stackChunkOop chunk = _cont.allocate_stack_chunk(size);\n+    stackChunkOop chunk = _cont.allocate_stack_chunk(size, _preempt);\n@@ -1824,1 +1829,1 @@\n-static inline int freeze_epilog(JavaThread* thread, ContMirror& cont) {\n+static inline int freeze_epilog(JavaThread* thread, ContMirror& cont, bool preempt) {\n@@ -1830,1 +1835,3 @@\n-  StackWatermarkSet::after_unwind(thread);\n+  if (!preempt) {\n+    StackWatermarkSet::after_unwind(thread);\n+  }\n@@ -1839,1 +1846,1 @@\n-static int freeze_epilog(JavaThread* thread, ContMirror& cont, freeze_result res) {\n+static int freeze_epilog(JavaThread* thread, ContMirror& cont, freeze_result res, bool preempt) {\n@@ -1848,1 +1855,1 @@\n-  return freeze_epilog(thread, cont);\n+  return freeze_epilog(thread, cont, preempt);\n@@ -1861,1 +1868,3 @@\n-  assert (!preempt || current->thread_state() == _thread_in_vm || current->thread_state() == _thread_blocked \/*|| current->thread_state() == _thread_in_native*\/, \"thread_state: %d %s\", current->thread_state(), current->thread_state_name());\n+  assert (!preempt || current->thread_state() == _thread_in_vm || current->thread_state() == _thread_blocked\n+          \/*|| current->thread_state() == _thread_in_native*\/,\n+          \"thread_state: %d %s\", current->thread_state(), current->thread_state_name());\n@@ -1865,1 +1874,3 @@\n-    p2i(current->last_continuation()->entry_sp()), p2i(current->last_continuation()->entry_fp()), p2i(current->last_continuation()->entry_pc()));\n+                             p2i(current->last_continuation()->entry_sp()),\n+                             p2i(current->last_continuation()->entry_fp()),\n+                             p2i(current->last_continuation()->entry_pc()));\n@@ -1896,1 +1907,1 @@\n-  \n+\n@@ -1898,1 +1909,0 @@\n-    assert (current->thread_state() == _thread_in_vm, \"\");\n@@ -1901,1 +1911,1 @@\n-    return freeze_epilog(current, cont, res);\n+    return freeze_epilog(current, cont, res, preempt);\n@@ -1911,1 +1921,1 @@\n-  \n+\n@@ -1913,1 +1923,1 @@\n-    return freeze_epilog(current, cont);\n+    return freeze_epilog(current, cont, preempt);\n@@ -1922,0 +1932,1 @@\n+  assert(current == JavaThread::current(), \"must be current thread except for preempt\");\n@@ -1924,1 +1935,1 @@\n-    return freeze_epilog(current, cont, res);\n+    return freeze_epilog(current, cont, res, preempt);\n@@ -2189,1 +2200,1 @@\n-    return    !_barriers \n+    return    !_barriers\n@@ -2206,1 +2217,1 @@\n-    \n+\n@@ -2261,1 +2272,1 @@\n-      \n+\n@@ -2265,1 +2276,1 @@\n-      \n+\n@@ -2396,1 +2407,1 @@\n-    \n+\n@@ -2411,1 +2422,1 @@\n-    \n+\n@@ -2428,1 +2439,1 @@\n-  \n+\n@@ -2479,1 +2490,1 @@\n-    \n+\n@@ -2491,1 +2502,1 @@\n-    \n+\n@@ -2499,1 +2510,1 @@\n-  \n+\n@@ -2546,1 +2557,1 @@\n-    \n+\n@@ -2671,1 +2682,1 @@\n-    \n+\n@@ -2682,1 +2693,1 @@\n-    \n+\n@@ -3106,1 +3117,1 @@\n-  \n+\n@@ -3125,1 +3136,1 @@\n- \n+\n@@ -3198,1 +3209,1 @@\n-stackChunkOop ContMirror::allocate_stack_chunk(int stack_size) {\n+stackChunkOop ContMirror::allocate_stack_chunk(int stack_size, bool is_preempt) {\n@@ -3203,0 +3214,2 @@\n+  assert(is_preempt || _thread == JavaThread::current(), \"should be current\");\n+  JavaThread* current = is_preempt ? JavaThread::current() : _thread;\n@@ -3205,1 +3218,1 @@\n-  HeapWord* start = _thread->tlab().allocate(size_in_words);\n+  HeapWord* start = current->tlab().allocate(size_in_words);\n@@ -3208,10 +3221,0 @@\n-  } else {\n-    assert (_thread == Thread::current(), \"\");\n-    \/\/HandleMark hm(_thread);\n-    Handle conth(_thread, _cont);\n-    \/\/ uint64_t counter = SafepointSynchronize::safepoint_counter();\n-    stackChunkOop result = (stackChunkOop)allocator.allocate();\n-    \/\/if (!SafepointSynchronize::is_same_safepoint(counter)) {\n-      post_safepoint(conth);\n-    \/\/}\n-    return result;\n@@ -3219,0 +3222,6 @@\n+\n+  \/\/HandleMark hm(current);\n+  Handle conth(current, _cont);\n+  stackChunkOop result = (stackChunkOop)allocator.allocate();\n+  post_safepoint(conth);\n+  return result;\n@@ -3238,36 +3247,3 @@\n-  JavaThread* thread = JavaThread::thread_from_jni_environment(env);\n-\n-  class ForceYieldClosure : public HandshakeClosure {\n-    jobject _jcont;\n-    jint _result;\n-\n-    bool can_be_processed_by(Thread* thread) {\n-      return thread->is_Java_thread();\n-    }\n-\n-    void do_thread(Thread* th) {\n-      \/\/ assert (th == Thread::current(), \"\"); -- the handshake can be carried out by a VM thread (see HandshakeState::process_by_vmthread)\n-      assert (th->is_Java_thread(), \"\");\n-      guarantee (Thread::current()->is_Java_thread(), \"Thread: %s\", Thread::current()->name());\n-      JavaThread* thread = (JavaThread*)th;\n-\n-      \/\/ tty->print_cr(\">>> ForceYieldClosure thread\");\n-      \/\/ thread->print_on(tty);\n-      \/\/ if (thread != Thread::current()) {\n-      \/\/   tty->print_cr(\">>> current thread\");\n-      \/\/   Thread::current()->print_on(tty);\n-      \/\/ }\n-\n-      oop oopCont = JNIHandles::resolve_non_null(_jcont);\n-      _result = Continuation::try_force_yield(thread, oopCont);\n-    }\n-\n-  public:\n-    ForceYieldClosure(jobject jcont) : HandshakeClosure(\"ContinuationForceYieldClosure\"), _jcont(jcont), _result(-1) {}\n-    jint result() const { return _result; }\n-  };\n-  ForceYieldClosure fyc(jcont);\n-\n-  \/\/ tty->print_cr(\"TRY_FORCE_YIELD0\");\n-  \/\/ thread->print();\n-  \/\/ tty->print_cr(\"\");\n+  JavaThread* current = JavaThread::thread_from_jni_environment(env);\n+  assert(current == JavaThread::current(), \"should be\");\n+  jint result = -1; \/\/ no continuation (should have enum)\n@@ -3278,1 +3254,7 @@\n-    Handshake::execute(&fyc, target);\n+    assert(target != current, \"should be different threads\");\n+    \/\/ Suspend the target thread and freeze it.\n+    if (target->block_suspend(current)) {\n+      oop oopCont = JNIHandles::resolve_non_null(jcont);\n+      result = Continuation::try_force_yield(target, oopCont);\n+      target->continue_resume(current);\n+    }\n@@ -3280,2 +3262,1 @@\n-\n-  return fyc.result();\n+  return result;\n@@ -3601,1 +3582,1 @@\n-  \n+\n@@ -3613,1 +3594,1 @@\n-  \n+\n@@ -3621,1 +3602,1 @@\n-  \n+\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":83,"deletions":102,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -411,0 +411,1 @@\n+  _caller(nullptr),\n@@ -607,1 +608,1 @@\n-  while (is_suspended()) {\n+  while (is_suspended_or_blocked()) {\n@@ -629,3 +630,4 @@\n-bool HandshakeState::suspend_with_handshake() {\n-  if (_handshakee->is_exiting() ||\n-     _handshakee->threadObj() == NULL) {\n+bool HandshakeState::suspend_with_handshake(JavaThread* caller) {\n+  \/\/ This tested for _handshakee->threadObj() != NULL as well, but the test doesn't work\n+  \/\/ for that.  TODO: can you suspend a thread during initialization ?\n+  if (_handshakee->is_exiting()) {\n@@ -635,0 +637,3 @@\n+  bool should_block = caller != nullptr;\n+  bool should_suspend = caller == nullptr;\n+\n@@ -636,3 +641,2 @@\n-    if (is_suspended()) {\n-      \/\/ Target is already suspended.\n-      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended\", p2i(_handshakee));\n+    if ((is_suspended() && should_suspend) || (is_blocked() && should_block)) {\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already suspended or blocked\", p2i(_handshakee));\n@@ -640,1 +644,1 @@\n-    } else {\n+    } else if (should_suspend) {\n@@ -646,0 +650,7 @@\n+    } else {\n+      assert(should_block, \"should block\");\n+      \/\/ Target is going to wake up and leave blocking.\n+      \/\/ Let's just stop the thread from doing that.\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" re-blocked\", p2i(_handshakee));\n+      set_caller_thread(caller);\n+      return true;\n@@ -648,2 +659,1 @@\n-  \/\/ no suspend request\n-  assert(!is_suspended(), \"cannot be suspended without a suspend request\");\n+\n@@ -651,2 +661,10 @@\n-  \/\/ from this point.\n-  set_suspended(true);\n+  \/\/ or blocked from this point.\n+  if (should_suspend) {\n+    \/\/ no suspend request\n+    assert(!is_suspended(), \"cannot be suspended without a request\");\n+    set_suspended(true);\n+  } else {\n+    assert(!is_blocked(), \"cannot be blocked without a request\");\n+    set_caller_thread(caller);\n+  }\n+\n@@ -662,1 +680,2 @@\n-  bool _did_suspend;\n+  JavaThread* _caller;\n+  bool        _did_suspend;\n@@ -664,1 +683,1 @@\n-  SuspendThreadHandshake() : HandshakeClosure(\"SuspendThread\"), _did_suspend(false) {}\n+  SuspendThreadHandshake(JavaThread* caller) : HandshakeClosure(\"SuspendThread\"), _caller(caller), _did_suspend(false) {}\n@@ -667,1 +686,1 @@\n-    _did_suspend = target->handshake_state()->suspend_with_handshake();\n+    _did_suspend = target->handshake_state()->suspend_with_handshake(_caller);\n@@ -673,1 +692,1 @@\n-  SuspendThreadHandshake st;\n+  SuspendThreadHandshake st(nullptr);\n@@ -692,0 +711,30 @@\n+\n+\/\/ One thread blocks execution of another thread until it resumes it.  This is similar to\n+\/\/ suspend, and much of the code is shared but it's a separate state from being suspended.\n+\/\/ The commonality is that the thread is self-suspended and that thread waits for both\n+\/\/ conditions to clear.\n+bool HandshakeState::block_suspend(JavaThread* caller) {\n+  assert(caller == JavaThread::current(), \"caller must be current thread\");\n+\n+  SuspendThreadHandshake st(caller);\n+  Handshake::execute(&st, _handshakee);\n+  bool suspended = st.did_suspend();\n+  return suspended;\n+}\n+\n+bool HandshakeState::continue_resume(JavaThread* caller) {\n+  assert(caller == JavaThread::current(), \"caller must be current thread\");\n+\n+  \/\/ If caller is non-null only resume blocked thread if it's the caller\n+  if (!is_blocked() || caller_thread() != caller) {\n+    return false;\n+  }\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  assert(is_blocked() && caller_thread() == caller,\n+         \"this is the only thread that can continue this thread\");\n+\n+  \/\/ Resume the thread.\n+  set_caller_thread(nullptr); \/\/ !is_blocked()\n+  _lock.notify();\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":65,"deletions":16,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+\n@@ -92,0 +93,3 @@\n+  \/\/ Caller of suspension.  Only the caller can resume the thread.\n+  JavaThread* _caller;\n+\n@@ -157,1 +161,2 @@\n-  bool suspend_with_handshake();\n+  bool suspend_with_handshake(JavaThread* caller);\n+\n@@ -162,1 +167,1 @@\n-  bool is_suspended()                       { return Atomic::load(&_suspended); }\n+  bool is_suspended() const                 { return Atomic::load(&_suspended); }\n@@ -167,0 +172,7 @@\n+  void set_caller_thread(JavaThread* caller){ return Atomic::store(&_caller, caller); }\n+  JavaThread* caller_thread() const         { return Atomic::load(&_caller); }\n+\n+  \/\/ \"blocked\" is short for saying \"suspended by caller\"\n+  bool is_blocked() const                   { return caller_thread() != nullptr; }\n+  bool is_suspended_or_blocked() const      { return is_suspended() || is_blocked(); }\n+\n@@ -169,0 +181,3 @@\n+\n+  bool block_suspend(JavaThread* caller);\n+  bool continue_resume(JavaThread* caller);\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1721,1 +1721,1 @@\n-    log_develop_trace(jvmcont)(\"handle_special_runtime_exit_condition is_cont_force_yield: %d check_asyncs: %d\", is_cont_force_yield(), check_asyncs);\n+    log_develop_trace(jvmcont)(\"force_yield_if_preempted: is_cont_force_yield\");\n@@ -1723,4 +1723,3 @@\n-    if (true || check_asyncs) { \/\/ TODO: we should probably be even more selective than that\n-      \/\/ we need this only for interpreted frames -- for compiled frames we install a return barrier on the safepoint stub in Continuation::try_force_yield\n-      StubRoutines::cont_jump_from_sp_C()();\n-    }\n+    assert(thread_state() == _thread_in_Java, \"can only continue from Java state\");\n+    StackWatermarkSet::after_unwind(this);\n+    StubRoutines::cont_jump_from_sp_C()();\n@@ -1828,0 +1827,19 @@\n+bool JavaThread::block_suspend(JavaThread* caller) {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, no suspension\", p2i(this));\n+    return false;\n+  }\n+  return this->handshake_state()->block_suspend(caller);\n+}\n+\n+bool JavaThread::continue_resume(JavaThread* caller) {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, nothing to resume\", p2i(this));\n+    return false;\n+  }\n+  return this->handshake_state()->continue_resume(caller);\n+}\n+\n+\n@@ -2193,0 +2211,1 @@\n+  print_owned_locks_on(st);\n@@ -2342,1 +2361,1 @@\n-\/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier. \n+\/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier.\n@@ -2348,1 +2367,1 @@\n-    \n+\n@@ -2491,1 +2510,1 @@\n-  \n+\n@@ -3952,1 +3971,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":27,"deletions":9,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1203,2 +1203,3 @@\n-  bool java_suspend(); \/\/ higher-level suspension logic called by the public APIs\n-  bool java_resume();  \/\/ higher-level resume logic called by the public APIs\n+  \/\/ higher-level suspension\/resume logic called by the public APIs\n+  bool java_suspend();\n+  bool java_resume();\n@@ -1207,0 +1208,5 @@\n+  \/\/ lower-level blocking logic called by the JVM.  The caller suspends this\n+  \/\/ thread, does something, and then releases it.\n+  bool block_suspend(JavaThread* caller);\n+  bool continue_resume(JavaThread* caller);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"threadHelper.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ Timing controller, might need bigger barriers\n+class Control : public AllStatic {\n+  static bool _suspend_done;\n+  static bool _block_done;\n+ public:\n+  static bool suspend_done() { return Atomic::load(&_suspend_done); }\n+  static bool block_done() { return Atomic::load(&_block_done); }\n+  static void set_suspend_done() { Atomic::store(&_suspend_done, true); }\n+  static void set_block_done() { Atomic::store(&_block_done, true); }\n+};\n+\n+bool Control::_suspend_done = false;\n+bool Control::_block_done = false;\n+\n+class BlockeeThread : public JavaTestThread {\n+  public:\n+  BlockeeThread(Semaphore* post) : JavaTestThread(post) {}\n+  virtual ~BlockeeThread() {}\n+  void main_run() {\n+    while (!Control::suspend_done()) {\n+      ThreadBlockInVM tbivm(this);\n+    }\n+  }\n+};\n+\n+class BlockingThread : public JavaTestThread {\n+  JavaThread* _target;\n+  public:\n+  BlockingThread(Semaphore* post, JavaThread* target) : JavaTestThread(post), _target(target) {}\n+  virtual ~BlockingThread() {}\n+  void main_run() {\n+    int print_count = 0;\n+    \/\/ Suspend the target thread and check its state\n+    while (!Control::block_done()) {\n+      ASSERT_LT(print_count++, 100) << \"Blocking thread - never suspended\";\n+      if (_target->block_suspend(this)) {\n+        tty->print_cr(\"Block succeeded\");\n+        Control::set_block_done();\n+        os::naked_short_sleep(10);\n+         while (!Control::suspend_done()) {\n+           ASSERT_EQ(_target->thread_state(), _thread_blocked) << \"should be blocked\";\n+        }\n+        _target->continue_resume(this);\n+        tty->print_cr(\"Release succeeded\");\n+      }\n+    }\n+  }\n+};\n+\n+class SuspendingThread : public JavaTestThread {\n+  JavaThread* _target;\n+  public:\n+  SuspendingThread(Semaphore* post, JavaThread* target) : JavaTestThread(post), _target(target) {}\n+  virtual ~SuspendingThread() {}\n+  void main_run() {\n+    int print_count = 0;\n+    int test_count = 0;\n+    \/\/ Suspend the target thread and resume it\n+    while (test_count < 100) {\n+      ASSERT_LT(print_count++, 100) << \"Suspending thread - never suspended\";\n+      if (_target->java_suspend()) {\n+        ASSERT_EQ(_target->thread_state(), _thread_blocked) << \"should be blocked\";\n+        _target->java_resume();\n+        test_count++;\n+      }\n+    }\n+    \/\/ Still blocked until Blocking thread resumes the thread\n+    ASSERT_EQ(_target->thread_state(), _thread_blocked) << \"should still be blocked\";\n+    Control::set_suspend_done();\n+  }\n+};\n+\n+\/\/ This guy should fail, then pass.\n+class AnotherBlockingThread : public JavaTestThread {\n+  JavaThread* _target;\n+  public:\n+  AnotherBlockingThread(Semaphore* post, JavaThread* target) : JavaTestThread(post), _target(target) {}\n+  virtual ~AnotherBlockingThread() {}\n+  void main_run() {\n+    bool done = false;\n+    \/\/ Suspend the target thread and check its state\n+    while (!Control::block_done()) {\n+      os::naked_short_sleep(10);\n+    }\n+    while (!done) {\n+      if (_target->block_suspend(this)) {\n+        ASSERT_EQ(Control::suspend_done(), true) << \"should only pass if Blocking thread releases the block\";\n+        tty->print_cr(\"Other Block succeeded\");\n+        _target->continue_resume(this);\n+        tty->print_cr(\"Other Release succeeded\");\n+        done = true;\n+      }\n+    }\n+  }\n+};\n+\n+#define TEST_THREAD_COUNT 4\n+\n+class DriverSuspendThread : public JavaTestThread {\n+public:\n+  Semaphore _done;\n+  DriverSuspendThread(Semaphore* post) : JavaTestThread(post) { };\n+  virtual ~DriverSuspendThread(){}\n+\n+  void main_run() {\n+    Semaphore done(0);\n+\n+    BlockeeThread* target = new BlockeeThread(&done);\n+    BlockingThread* bt = new BlockingThread(&done, target);\n+    SuspendingThread* st = new SuspendingThread(&done, target);\n+    AnotherBlockingThread* obt = new AnotherBlockingThread(&done, target);\n+\n+    target->doit();\n+    bt->doit();\n+    st->doit();\n+    obt->doit();\n+\n+    for (int i = 0; i < TEST_THREAD_COUNT; i++) {\n+      done.wait();\n+    }\n+  }\n+};\n+\n+TEST_VM(ThreadSuspend, test_thread_suspend) {\n+  mt_test_doer<DriverSuspendThread>();\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_suspend.cpp","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+* @run testng\/othervm -XX:-UseTLAB -Xint Preempt\n@@ -37,2 +38,0 @@\n-\/\/ - Add tests for additional safepoint types\n-\/\/ - Add tests with -XX:-ThreadLocalHandshakes\n","filename":"test\/jdk\/java\/lang\/Continuation\/Preempt.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}