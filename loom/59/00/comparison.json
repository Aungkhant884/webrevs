{"files":[{"patch":"@@ -50,0 +50,1 @@\n+import java.util.concurrent.ThreadPoolExecutor;\n@@ -260,0 +261,21 @@\n+\n+    final private void ScheduleContinuation() {\n+        Thread carrier = Thread.currentCarrierThread();\n+        Thread current = Thread.currentThread();\n+        boolean switchToCarrier = Thread.currentThread().isVirtual() && (scheduler instanceof ThreadPoolExecutor);\n+\n+        if (switchToCarrier) {\n+            \/\/switch to carrier thread\n+            carrier.setCurrentThread(carrier);\n+        }\n+\n+        try {\n+            scheduler.execute(runContinuation);\n+        } finally {\n+            if (switchToCarrier) {\n+               \/\/ switch back to virtual thread\n+               carrier.setCurrentThread(current);\n+            }\n+        }\n+    }\n+\n@@ -270,1 +292,1 @@\n-                scheduler.execute(runContinuation);\n+                ScheduleContinuation();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ *\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation. THL A29 Limited designates\n+ * this particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License version 2 for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License along\n+ * with this program; if not, write to the Free Software Foundation, Inc.,\n+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng ParkWithFixedThreadPool\n+ * @summary Test virtual thread park when scheduler is fixed thread pool\n+ *\/\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.*;\n+import java.util.concurrent.locks.LockSupport;\n+import static org.testng.Assert.*;\n+import org.testng.annotations.Test;\n+\n+public class ParkWithFixedThreadPool {\n+    @Test\n+    public static void multipleThreadPoolParkTest() throws Exception {\n+        ExecutorService executor = Executors.newFixedThreadPool(8);\n+        int vt_count = 300;\n+        Thread[] vts = new Thread[vt_count];\n+        Runnable target = new Runnable() {\n+            public void run() {\n+                int myIndex = -1;\n+                for (int i = 0; i < vt_count; i++) {\n+                    if (vts[i] == Thread.currentThread()) {\n+                        myIndex = i;\n+                        break;\n+                    }\n+                }\n+\n+                if (myIndex > 0) {\n+                    LockSupport.unpark(vts[myIndex - 1]);\n+                }\n+\n+                if (myIndex != (vt_count - 1)) {\n+                    LockSupport.park();\n+                }\n+            }\n+        };\n+        ThreadFactory f = Thread.ofVirtual().scheduler(executor).name(\"vt\", 0).factory();\n+        for (int i = 0; i < vt_count; i++) {\n+            vts[i] = f.newThread(target);\n+        }\n+        for (int i = 0; i < vt_count; i++) {\n+            vts[i].start();\n+        }\n+\n+        for (int i = 0; i < vt_count; i++) {\n+            vts[i].join();\n+        }\n+        executor.shutdown();\n+        executor.awaitTermination(Long.MAX_VALUE, TimeUnit.NANOSECONDS);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ParkWithFixedThreadPool.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"}]}