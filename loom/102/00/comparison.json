{"files":[{"patch":"@@ -1896,0 +1896,1 @@\n+    case GCCause::_codecache_GC_threshold:  return true;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -817,6 +817,8 @@\n-  if (CodeCache::is_marking_cycle_active()) {\n-    \/\/ It's possible that a preceding initiating young GC decided\n-    \/\/ that there is no need to do any concurrent marking. In that\n-    \/\/ case, no remark was ever run. Yet the liveness information\n-    \/\/ was indeed complete. We finish it here.\n-    CodeCache::finish_marking_cycle();\n+  if (!CodeCache::is_marking_cycle_active()) {\n+    \/\/ This is the normal case when we do not call collect when a\n+    \/\/ concurrent mark is ongoing. We then start a new code marking\n+    \/\/ cycle. If, on the other hand, a concurrent mark is ongoing, we\n+    \/\/ will be conservative and use the last code marking cycle. Code\n+    \/\/ caches marked between the two concurrent marks will live a bit\n+    \/\/ longer than needed.\n+    CodeCache::start_marking_cycle();\n@@ -824,1 +826,0 @@\n-  CodeCache::start_marking_cycle();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -191,7 +191,8 @@\n-  if (CodeCache::is_marking_cycle_active()) {\n-    \/\/ It's possible that a preceding concurrent cycle is not yet\n-    \/\/ finished, and has aborted. That marking cycle might have had\n-    \/\/ incomplete marking information, but we can still finish that\n-    \/\/ cycle, as we will do a full STW cycle before releasing the\n-    \/\/ safepoint.\n-    CodeCache::finish_marking_cycle();\n+  if (!CodeCache::is_marking_cycle_active()) {\n+    \/\/ This is the normal case when we do not call collect when a\n+    \/\/ concurrent mark is ongoing. We then start a new code marking\n+    \/\/ cycle. If, on the other hand, a concurrent mark is ongoing, we\n+    \/\/ will be conservative and use the last code marking cycle. Code\n+    \/\/ caches marked between the two concurrent marks will live a bit\n+    \/\/ longer than needed.\n+    CodeCache::start_marking_cycle();\n@@ -199,1 +200,0 @@\n-  CodeCache::start_marking_cycle();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1083,0 +1083,1 @@\n+               (cause == GCCause::_codecache_GC_threshold) ||\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -374,59 +374,0 @@\n-void CollectedHeap::collect_for_codecache() {\n-  uint loop_count = 0;\n-  uint gc_count = 0;\n-  uint full_gc_count = 0;\n-\n-  assert(!Heap_lock->owned_by_self(), \"Should not be holding the Heap_lock\");\n-\n-  do {\n-    if (GCLocker::is_active_and_needs_gc()) {\n-      \/\/ If the GCLocker is active, just expand and allocate.\n-      \/\/ If that does not succeed, wait if this thread is not\n-      \/\/ in a critical section itself.\n-      JavaThread* jthr = JavaThread::current();\n-      if (!jthr->in_critical()) {\n-        \/\/ Wait for JNI critical section to be exited\n-        GCLocker::stall_until_clear();\n-        \/\/ The GC invoked by the last thread leaving the critical\n-        \/\/ section will be a young collection and a full collection\n-        \/\/ is (currently) needed for unloading classes so continue\n-        \/\/ to the next iteration to get a full GC.\n-        continue;\n-      } else {\n-        if (CheckJNICalls) {\n-          fatal(\"Possible deadlock due to allocating while\"\n-                \" in jni critical section\");\n-        }\n-        return;\n-      }\n-    }\n-\n-    {  \/\/ Need lock to get self consistent gc_count's\n-      MutexLocker ml(Heap_lock);\n-      gc_count      = Universe::heap()->total_collections();\n-      full_gc_count = Universe::heap()->total_full_collections();\n-    }\n-\n-    \/\/ Generate a VM operation\n-    VM_CollectForCodeCacheAllocation op(gc_count,\n-                                        full_gc_count,\n-                                        GCCause::_codecache_GC_threshold);\n-    VMThread::execute(&op);\n-\n-    \/\/ If GC was locked out, try again. Check before checking success because the\n-    \/\/ prologue could have succeeded and the GC still have been locked out.\n-    if (op.gc_locked()) {\n-      continue;\n-    }\n-\n-    if (op.prologue_succeeded()) {\n-      return;\n-    }\n-    loop_count++;\n-    if ((QueuedAllocationWarningCount > 0) &&\n-        (loop_count % QueuedAllocationWarningCount == 0)) {\n-      log_warning(gc, ergo)(\"collect_for_codecache() retries %d times\", loop_count);\n-    }\n-  } while (true);  \/\/ Until a GC is done\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":60,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -375,3 +375,0 @@\n-  \/\/ Continuation support\n-  virtual void collect_for_codecache();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -268,24 +268,0 @@\n-VM_CollectForCodeCacheAllocation::VM_CollectForCodeCacheAllocation(uint gc_count_before,\n-                                                                   uint full_gc_count_before,\n-                                                                   GCCause::Cause gc_cause)\n-    : VM_GC_Operation(gc_count_before, gc_cause, full_gc_count_before, true) {\n-}\n-\n-void VM_CollectForCodeCacheAllocation::doit() {\n-  SvcGCMarker sgcm(SvcGCMarker::FULL);\n-\n-  CollectedHeap* heap = Universe::heap();\n-  GCCauseSetter gccs(heap, _gc_cause);\n-\n-  log_debug(gc)(\"Full GC for CodeCache\");\n-\n-  \/\/ Don't clear the soft refs yet.\n-  heap->collect_as_vm_thread(GCCause::_codecache_GC_threshold);\n-\n-  log_debug(gc)(\"After GC for CodeCache\");\n-\n-  if (GCLocker::is_active_and_needs_gc()) {\n-    set_gc_locked();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -247,10 +247,0 @@\n-class VM_CollectForCodeCacheAllocation: public VM_GC_Operation {\n-public:\n-  VM_CollectForCodeCacheAllocation(uint gc_count_before,\n-                                   uint full_gc_count_before,\n-                                   GCCause::Cause gc_cause);\n-\n-  virtual VMOp_Type type() const { return VMOp_CollectForCodeCacheAllocation; }\n-  virtual void doit();\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcVMOperations.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,5 +174,0 @@\n-void ZCollectedHeap::collect_for_codecache() {\n-  \/\/ Start synchronous GC\n-  collect(GCCause::_codecache_GC_threshold);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,3 +77,0 @@\n-  \/\/ Continuation support\n-  virtual void collect_for_codecache();\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-    Universe::heap()->collect_for_codecache();\n+    Universe::heap()->collect(GCCause::_codecache_GC_threshold);\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}