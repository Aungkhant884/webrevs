{"files":[{"patch":"@@ -603,4 +603,4 @@\n-    objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));\n-    objArrayHandle frames_array_h(THREAD, fa);\n-    Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));\n-    Handle cont_h(THREAD, JNIHandles::resolve_non_null(cont));\n+  objArrayOop fa = objArrayOop(JNIHandles::resolve_non_null(frames));\n+  objArrayHandle frames_array_h(THREAD, fa);\n+  Handle stackStream_h(THREAD, JNIHandles::resolve_non_null(stackStream));\n+  Handle cont_h(THREAD, JNIHandles::resolve_non_null(cont));\n@@ -608,1 +608,1 @@\n-    StackWalk::setContinuation(stackStream_h, anchor, frames_array_h, cont_h, THREAD);\n+  StackWalk::setContinuation(stackStream_h, anchor, frames_array_h, cont_h, THREAD);\n@@ -3113,1 +3113,1 @@\n-  assert(jthread != NULL, \"no current thread!\");\n+  assert(jthread != NULL, \"no current carrier thread!\");\n@@ -3192,1 +3192,1 @@\n-                                   jobject theCache))\n+                                       jobject theCache))\n@@ -3944,1 +3944,1 @@\n-  JvmtiVTMTDisabler::start_VTMT(vthread, true);\n+  JvmtiVTMTDisabler::start_VTMT(vthread, \/* is_mount *\/ true);\n@@ -3968,1 +3968,1 @@\n-  JvmtiVTMTDisabler::finish_VTMT(vthread, true);\n+  JvmtiVTMTDisabler::finish_VTMT(vthread, \/* is_mount *\/ true);\n@@ -4018,1 +4018,1 @@\n-  JvmtiVTMTDisabler::start_VTMT(vthread, false);\n+  JvmtiVTMTDisabler::start_VTMT(vthread, \/* is_mount *\/ false);\n@@ -4039,1 +4039,1 @@\n-  JvmtiVTMTDisabler::finish_VTMT(vthread, false);\n+  JvmtiVTMTDisabler::finish_VTMT(vthread, \/* is_mount *\/ false);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1736,0 +1736,1 @@\n+        Virtual threads that are currently suspended do not change state.\n@@ -1740,1 +1741,0 @@\n-        Virtual threads that are currently suspended do not change state.\n@@ -1864,0 +1864,1 @@\n+        Virtual threads that are currently resumed do not change state.\n@@ -1868,1 +1869,0 @@\n-        Virtual threads that are currently resumed do not change state.\n@@ -5825,1 +5825,1 @@\n-      The <code>GetLocalXXX<\/code> functions may be to used retrieve the value of\n+      The <code>GetLocalXXX<\/code> functions may be used to retrieve the value of\n@@ -12978,1 +12978,1 @@\n-      Virtual thread start events are generated before its initial method executes.\n+      A virtual thread start event is generated before its initial method executes.\n@@ -13011,1 +13011,1 @@\n-      Virtual thread end events are generated after its initial method has finished execution.\n+      A virtual thread end event is generated after its initial method has finished execution.\n@@ -13041,1 +13041,1 @@\n-      Virtual thread mount events are generated before its method continue to execute on the mounted thread.\n+      A virtual thread mount event is generated before its method continue to execute on the mounted thread.\n@@ -13072,1 +13072,1 @@\n-      Virtual thread unmount events are generated when the virtual thread is about to be unmounted from the carrier thread.\n+      A virtual thread unmount event is generated when the virtual thread is about to be unmounted from the carrier thread.\n","filename":"src\/hotspot\/share\/prims\/jvmti.xml","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -150,2 +150,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -155,1 +153,0 @@\n-  oop thread_obj = NULL;\n@@ -157,0 +154,2 @@\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n@@ -161,1 +160,1 @@\n-    err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+    jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -185,0 +184,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -204,2 +204,0 @@\n-    JavaThread* java_thread = NULL;\n-    oop thread_obj = NULL;\n@@ -209,0 +207,2 @@\n+    JavaThread* java_thread = NULL;\n+    oop thread_obj = NULL;\n@@ -588,2 +588,0 @@\n-    JavaThread* java_thread = NULL;\n-    oop thread_obj = NULL;\n@@ -592,0 +590,2 @@\n+    JavaThread* java_thread = NULL;\n+    oop thread_obj = NULL;\n@@ -855,0 +855,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -859,2 +860,0 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n@@ -864,0 +863,2 @@\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n@@ -866,0 +867,3 @@\n+    \/\/ We got an error code so we don't have a JavaThread*, but only\n+    \/\/ return an error from here if the error is not because the thread\n+    \/\/ is a virtual thread.\n@@ -869,1 +873,0 @@\n-  \/\/ Support for virtual thread\n@@ -925,0 +928,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -929,0 +933,2 @@\n+\n+  jvmtiError err;\n@@ -931,2 +937,0 @@\n-  jvmtiError err;\n-\n@@ -943,1 +947,1 @@\n-      err = suspend_thread(thread_oop, java_thread, true, NULL); \/\/ single suspend\n+      err = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, NULL);\n@@ -948,1 +952,1 @@\n-  err = suspend_thread(thread_oop, current, true, NULL); \/\/ single suspend\n+  err = suspend_thread(thread_oop, current, \/* single_suspend *\/ true, NULL);\n@@ -983,1 +987,1 @@\n-      results[i] = suspend_thread(thread_oop, java_thread, true, NULL); \/\/ single suspend\n+      results[i] = suspend_thread(thread_oop, java_thread, \/* single_suspend *\/ true, NULL);\n@@ -990,1 +994,1 @@\n-    results[self_idx] = suspend_thread(self_tobj(), current, true, NULL); \/\/ single suspend\n+    results[self_idx] = suspend_thread(self_tobj(), current, \/* single_suspend *\/ true, NULL);\n@@ -1016,1 +1020,1 @@\n-    \/\/ Collect threads from except_list which resumed status must be restored.\n+    \/\/ Collect threads from except_list for which resumed status must be restored.\n@@ -1021,1 +1025,1 @@\n-          \/\/ is resumed, so its resumed status must be restored\n+          \/\/ is not suspended, so its resumed status must be restored\n@@ -1036,1 +1040,1 @@\n-      ) {\n+         ) {\n@@ -1041,1 +1045,1 @@\n-        suspend_thread(vt_oop, java_thread, false, NULL); \/\/ suspend all mode\n+        suspend_thread(vt_oop, java_thread, \/* single_suspend *\/ false, NULL);\n@@ -1046,1 +1050,1 @@\n-    \/\/ Restore resumed state for threads from except list that were resumed before.\n+    \/\/ Restore resumed state for threads from except list that were not suspended before.\n@@ -1058,1 +1062,1 @@\n-    suspend_thread(self_tobj(), current, false, NULL); \/\/ suspend all\n+    suspend_thread(self_tobj(), current, \/* single_suspend *\/ false, NULL);\n@@ -1064,0 +1068,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1066,2 +1071,0 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_oop = NULL;\n@@ -1071,0 +1074,2 @@\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n@@ -1075,1 +1080,1 @@\n-  err = resume_thread(thread_oop, java_thread, true); \/\/ single suspend\n+  err = resume_thread(thread_oop, java_thread, \/* single_resume *\/ true);\n@@ -1099,1 +1104,1 @@\n-    results[i] = resume_thread(thread_oop, java_thread, true); \/\/ single suspend\n+    results[i] = resume_thread(thread_oop, java_thread, \/* single_resume *\/ true);\n@@ -1119,1 +1124,1 @@\n-  \/\/ Collect threads from except_list which suspended status must be restored.\n+  \/\/ Collect threads from except_list for which suspended status must be restored.\n@@ -1140,1 +1145,1 @@\n-      resume_thread(vt_oop, java_thread, false); \/\/ suspend all\n+      resume_thread(vt_oop, java_thread, \/* single_resume *\/ false);\n@@ -1170,0 +1175,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1173,2 +1179,0 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n@@ -1180,0 +1184,2 @@\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n@@ -1185,1 +1191,0 @@\n-  \/\/ Support for virtual threads\n@@ -1187,0 +1192,1 @@\n+    \/\/ For virtual threads we have to call into Java to interrupt:\n@@ -1210,0 +1216,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1253,1 +1260,0 @@\n-  \/\/ Support for virtual threads\n@@ -1308,1 +1314,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1313,1 +1319,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n@@ -1315,1 +1320,0 @@\n-  JavaThread* java_thread = NULL;\n@@ -1317,1 +1321,0 @@\n-  oop thread_oop = NULL;\n@@ -1323,1 +1326,0 @@\n-\n@@ -1327,1 +1329,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n@@ -1333,1 +1337,0 @@\n-  \/\/ Support for virtual threads\n@@ -1335,1 +1338,1 @@\n-    \/\/ there is no monitor info to collect if target virtual thread is unmounted\n+    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n@@ -1384,1 +1387,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1389,1 +1392,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n@@ -1391,1 +1393,0 @@\n-  JavaThread* java_thread = NULL;\n@@ -1393,1 +1394,0 @@\n-  oop thread_oop = NULL;\n@@ -1402,1 +1402,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n@@ -1408,1 +1410,0 @@\n-  \/\/ Support for virtual threads\n@@ -1410,1 +1411,1 @@\n-    \/\/ there is no monitor info to collect if target virtual thread is unmounted\n+    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n@@ -1461,1 +1462,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1465,1 +1466,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n@@ -1467,1 +1467,0 @@\n-  JavaThread* java_thread = NULL;\n@@ -1469,1 +1468,0 @@\n-  oop thread_oop = NULL;\n@@ -1474,1 +1472,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n+  JavaThread* java_thread = NULL;\n+  oop thread_oop = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_oop);\n@@ -1479,1 +1479,0 @@\n-  \/\/ Support for virtual threads\n@@ -1481,1 +1480,1 @@\n-    \/\/ there is no monitor info to collect if target virtual thread is unmounted\n+    \/\/ There is no monitor info to collect if target virtual thread is unmounted.\n@@ -1483,1 +1482,1 @@\n-      GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, true); \/\/ is_virtual\n+      GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, \/* is_virtual *\/ true);\n@@ -1497,1 +1496,1 @@\n-    err = get_current_contended_monitor(calling_thread, java_thread, monitor_ptr, false);\n+    err = get_current_contended_monitor(calling_thread, java_thread, monitor_ptr, \/* is_virtual *\/ false);\n@@ -1500,1 +1499,1 @@\n-    GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, false); \/\/ !is_virtual\n+    GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr, \/* is_virtual *\/ false);\n@@ -1508,0 +1507,1 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1533,0 +1533,1 @@\n+    \/\/ No support for virtual threads.\n@@ -1600,1 +1601,0 @@\n-  ThreadPriority max_priority;\n@@ -1602,0 +1602,1 @@\n+  ThreadPriority max_priority;\n@@ -1605,1 +1606,0 @@\n-  max_priority = java_lang_ThreadGroup::maxPriority(group_obj());\n@@ -1607,0 +1607,5 @@\n+  max_priority = java_lang_ThreadGroup::maxPriority(group_obj());\n+\n+  info_ptr->is_daemon    = is_daemon;\n+  info_ptr->max_priority = max_priority;\n+  info_ptr->parent       = jni_reference(parent_group);\n@@ -1616,4 +1621,0 @@\n-  info_ptr->parent       = jni_reference(parent_group);\n-  info_ptr->max_priority = max_priority;\n-  info_ptr->is_daemon    = is_daemon;\n-\n@@ -1673,1 +1674,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1679,2 +1680,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1683,1 +1682,0 @@\n-  oop thread_obj = NULL;\n@@ -1688,1 +1686,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1693,1 +1693,0 @@\n-  \/\/ Support for virtual threads\n@@ -1695,1 +1694,1 @@\n-    if (java_thread == NULL) { \/\/ target virtual thread is unmounted\n+    if (java_thread == NULL) {  \/\/ Target virtual thread is unmounted.\n@@ -1757,0 +1756,1 @@\n+\n@@ -1765,10 +1765,8 @@\n-    \/\/ Support for virtual threads\n-    if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-      if (java_thread == NULL) { \/\/ target virtual thread is unmounted\n-        ResourceMark rm(current_thread);\n-        MultipleStackTracesCollector collector(this, max_frame_count);\n-        collector.fill_frames(thread, java_thread, thread_obj);\n-        collector.allocate_and_fill_stacks(1);\n-        *stack_info_ptr = collector.stack_info();\n-        return collector.result();\n-      }\n+    if (java_lang_VirtualThread::is_instance(thread_obj) && java_thread == NULL) {\n+      \/\/ Target virtual thread is unmounted.\n+      ResourceMark rm(current_thread);\n+      MultipleStackTracesCollector collector(this, max_frame_count);\n+      collector.fill_frames(thread, java_thread, thread_obj);\n+      collector.allocate_and_fill_stacks(\/* thread_count *\/ 1);\n+      *stack_info_ptr = collector.stack_info();\n+      return collector.result();\n@@ -1796,1 +1794,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1800,2 +1798,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1804,1 +1800,0 @@\n-  oop thread_obj = NULL;\n@@ -1809,1 +1804,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1814,1 +1811,0 @@\n-  \/\/ Support for virtual threads\n@@ -1816,1 +1812,1 @@\n-    if (java_thread == NULL) { \/\/ target virtual thread is unmounted\n+    if (java_thread == NULL) {  \/\/ Target virtual thread is unmounted.\n@@ -1840,1 +1836,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1843,2 +1839,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1847,1 +1841,0 @@\n-  oop thread_obj = NULL;\n@@ -1855,1 +1848,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1860,1 +1855,0 @@\n-  \/\/ Support for virtual threads\n@@ -1862,0 +1856,1 @@\n+    \/\/ No support for virtual threads (yet).\n@@ -1888,1 +1883,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1894,2 +1889,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1898,1 +1891,0 @@\n-  oop thread_obj = NULL;\n@@ -1903,1 +1895,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1908,1 +1902,0 @@\n-  \/\/ Support for virtual threads\n@@ -1910,1 +1903,1 @@\n-    if (java_thread == NULL) { \/\/ target virtual thread is unmounted\n+    if (java_thread == NULL) {  \/\/ Target virtual thread is unmounted.\n@@ -1938,1 +1931,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n@@ -1940,2 +1932,0 @@\n-  JavaThread* java_thread = NULL;\n-  oop thread_obj = NULL;\n@@ -1945,1 +1935,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1954,12 +1946,5 @@\n-  \/\/ Support for virtual threads\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-    if (java_thread == NULL) {\n-      \/\/ java_thread is NULL if virtual thread is unmounted\n-      JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread, thread_handle);\n-      if (state == NULL) {\n-        return JVMTI_ERROR_THREAD_NOT_ALIVE;\n-      }\n-      MutexLocker mu(JvmtiThreadState_lock);\n-      int frame_number = state->count_frames() - depth;\n-      state->env_thread_state(this)->set_frame_pop(frame_number);\n-      return JVMTI_ERROR_NONE;\n+  if (java_lang_VirtualThread::is_instance(thread_obj) && java_thread == NULL) {\n+    \/\/ Virtual thread is unmounted.\n+    JvmtiThreadState *state = JvmtiThreadState::state_for(java_thread, thread_handle);\n+    if (state == NULL) {\n+      return JVMTI_ERROR_THREAD_NOT_ALIVE;\n@@ -1967,0 +1952,4 @@\n+    MutexLocker mu(JvmtiThreadState_lock);\n+    int frame_number = state->count_frames() - depth;\n+    state->env_thread_state(this)->set_frame_pop(frame_number);\n+    return JVMTI_ERROR_NONE;\n@@ -1989,1 +1978,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -1998,1 +1987,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2007,1 +1996,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2016,1 +2005,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2025,1 +2014,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2034,1 +2023,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2212,1 +2201,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2217,2 +2206,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2225,1 +2212,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2227,0 +2213,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2228,1 +2216,0 @@\n-    \/\/ Support for virtual threads\n@@ -2239,0 +2226,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2253,1 +2241,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2258,2 +2246,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2266,1 +2252,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2268,0 +2253,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2269,1 +2256,0 @@\n-    \/\/ Support for virtual threads\n@@ -2280,0 +2266,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2295,1 +2282,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2300,2 +2287,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2308,1 +2293,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2310,0 +2294,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2311,1 +2297,0 @@\n-    \/\/ Support for virtual threads\n@@ -2322,0 +2307,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2337,1 +2323,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2342,2 +2328,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2350,1 +2334,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2352,0 +2335,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2353,1 +2338,0 @@\n-    \/\/ Support for virtual threads\n@@ -2364,0 +2348,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2379,1 +2364,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2384,2 +2369,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2392,1 +2375,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2394,0 +2376,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2395,1 +2379,0 @@\n-    \/\/ Support for virtual threads\n@@ -2406,0 +2389,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2421,1 +2405,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2426,2 +2410,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2434,1 +2416,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2436,0 +2417,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2437,1 +2420,0 @@\n-    \/\/ Support for virtual threads\n@@ -2448,0 +2430,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2463,1 +2446,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2467,2 +2450,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2475,1 +2456,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2479,0 +2459,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2480,1 +2462,0 @@\n-    \/\/ Support for virtual threads\n@@ -2488,0 +2469,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2500,1 +2482,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2504,2 +2486,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2512,1 +2492,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2516,0 +2495,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2517,1 +2498,0 @@\n-    \/\/ Support for virtual threads\n@@ -2525,0 +2505,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2537,1 +2518,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2541,2 +2522,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2549,1 +2528,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2553,0 +2531,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2554,1 +2534,0 @@\n-    \/\/ Support for virtual threads\n@@ -2562,0 +2541,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2574,1 +2554,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2578,2 +2558,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2586,1 +2564,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2590,0 +2567,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2591,1 +2570,0 @@\n-    \/\/ Support for virtual threads\n@@ -2599,0 +2577,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -2611,1 +2590,1 @@\n-\/\/ Threads_lock NOT held\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n@@ -2615,2 +2594,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -2623,1 +2600,0 @@\n-  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2627,0 +2603,2 @@\n+  jvmtiError err = JVMTI_ERROR_NONE;\n+  oop thread_obj = JNIHandles::resolve_external_guard(thread);\n@@ -2628,1 +2606,0 @@\n-    \/\/ Support for virtual threads\n@@ -2636,0 +2613,1 @@\n+    JavaThread* java_thread = NULL;\n@@ -3872,1 +3850,1 @@\n-  \/\/ Surprizingly the GetCurrentThreadCpuTime is used by non-JavaThread's.\n+  \/\/ Surprisingly the GetCurrentThreadCpuTime is used by non-JavaThread's.\n@@ -3875,0 +3853,1 @@\n+      \/\/ No support for virtual threads (yet).\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":159,"deletions":180,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -618,1 +618,1 @@\n-\/\/ return JavaThread if virtual thread is mounted, NULL otherwise\n+\/\/ Return JavaThread if virtual thread is mounted, NULL otherwise.\n@@ -622,1 +622,0 @@\n-    \/\/ can be NULL\n@@ -628,1 +627,1 @@\n-  assert(cont != NULL, \"virtual thread continuation must not be NULL\");\n+  assert(cont != NULL, \"must be\");\n@@ -637,1 +636,1 @@\n-    return jvf; \/\/ no frames to skip\n+    return jvf;  \/\/ No frames to skip.\n@@ -639,1 +638,1 @@\n-  \/\/ find jvf with a method annotated with @JvmtiMountTransition\n+  \/\/ Find jvf with a method annotated with @JvmtiMountTransition.\n@@ -641,2 +640,2 @@\n-    if (jvf->method()->jvmti_mount_transition()) { \/\/ cannot actually appear in an unmounted continuation; they're never frozen.\n-      jvf = jvf->java_sender(); \/\/ skip annotated method\n+    if (jvf->method()->jvmti_mount_transition()) {  \/\/ Cannot actually appear in an unmounted continuation; they're never frozen.\n+      jvf = jvf->java_sender();  \/\/ Skip annotated method.\n@@ -648,1 +647,1 @@\n-    \/\/ skip frame above annotated method\n+    \/\/ Skip frame above annotated method.\n@@ -715,1 +714,1 @@\n-    \/\/ get most state bits\n+    \/\/ Get most state bits.\n@@ -744,1 +743,1 @@\n-    \/\/ If virtual thread is blocked on a monitor eneter the BLOCKED_ON_MONITOR_ENTER bit\n+    \/\/ If virtual thread is blocked on a monitor enter the BLOCKED_ON_MONITOR_ENTER bit\n@@ -750,1 +749,1 @@\n-    \/\/ this call can trigger a safepoint, so thread_oop must not be used after it\n+    \/\/ This call can trigger a safepoint, so thread_oop must not be used after it.\n@@ -770,1 +769,1 @@\n-  ThreadsListEnumerator tle(current_thread, true);\n+  ThreadsListEnumerator tle(current_thread, \/* include_jvmti_agent_threads *\/ true);\n@@ -791,2 +790,2 @@\n-  int ngroups  = java_lang_ThreadGroup::ngroups(group_hdl());\n-  int nweaks  = java_lang_ThreadGroup::nweaks(group_hdl());\n+  int ngroups = java_lang_ThreadGroup::ngroups(group_hdl());\n+  int nweaks = java_lang_ThreadGroup::nweaks(group_hdl());\n@@ -800,1 +799,0 @@\n-    \/\/ strongly reachable subgroups\n@@ -802,0 +800,1 @@\n+      \/\/ Strongly reachable subgroups:\n@@ -810,1 +809,0 @@\n-    \/\/ weakly reachable subgroups\n@@ -812,0 +810,1 @@\n+      \/\/ Weakly reachable subgroups:\n@@ -848,1 +847,1 @@\n-  RegisterMap  reg_map(java_thread, true, true);\n+  RegisterMap  reg_map(java_thread, \/* update_map *\/ true, \/* process_frames *\/ true);\n@@ -850,2 +849,1 @@\n-  for (javaVFrame *jvf = java_thread->last_java_vframe(&reg_map);\n-       jvf != NULL;\n+  for (javaVFrame *jvf = java_thread->last_java_vframe(&reg_map); jvf != NULL;\n@@ -936,2 +934,1 @@\n-         jvf != NULL;\n-         jvf = jvf->java_sender()) {\n+         jvf != NULL; jvf = jvf->java_sender()) {\n@@ -967,2 +964,2 @@\n-      \/\/ add locked objects for this frame into list\n-      err = get_locked_objects_in_frame(calling_thread, java_thread, jvf, owned_monitors_list, depth-1);\n+      \/\/ Add locked objects for this frame into list.\n+      err = get_locked_objects_in_frame(calling_thread, java_thread, jvf, owned_monitors_list, depth - 1);\n@@ -1090,1 +1087,1 @@\n-        \/\/ start_depth is deeper than the stack depth\n+        \/\/ start_depth is deeper than the stack depth.\n@@ -1094,1 +1091,1 @@\n-      \/\/ we are referencing the starting depth based on the oldest\n+      \/\/ We are referencing the starting depth based on the oldest\n@@ -1096,1 +1093,1 @@\n-      \/\/ optimize to limit the number of times that java_sender() is called\n+      \/\/ Optimize to limit the number of times that java_sender() is called.\n@@ -1109,1 +1106,1 @@\n-        \/\/ previous pointer is exactly where we want to start\n+        \/\/ Previous pointer is exactly where we want to start.\n@@ -1112,1 +1109,1 @@\n-        \/\/ we need to back up further to get to the right place\n+        \/\/ We need to back up further to get to the right place.\n@@ -1114,1 +1111,1 @@\n-          \/\/ the -start_depth is greater than the stack depth\n+          \/\/ The -start_depth is greater than the stack depth.\n@@ -1117,1 +1114,1 @@\n-        \/\/ j now is the number of frames on the stack starting with\n+        \/\/ j is now the number of frames on the stack starting with\n@@ -1119,1 +1116,1 @@\n-        \/\/ the stack that many, the result is -start_depth frames\n+        \/\/ the stack that many, and the result is -start_depth frames\n@@ -1141,3 +1138,0 @@\n-#ifdef ASSERT\n-  uint32_t debug_bits = 0;\n-#endif\n@@ -1152,1 +1146,1 @@\n-    RegisterMap reg_map(java_thread, true, false); \/\/ don't process frames\n+    RegisterMap reg_map(java_thread, \/* update_map *\/ true, \/* process_frames *\/ false);\n@@ -1390,1 +1384,1 @@\n-      Handle     th(current_thread, get_vthread_or_thread_oop(owning_thread));\n+      Handle th(current_thread, get_vthread_or_thread_oop(owning_thread));\n@@ -1522,0 +1516,1 @@\n+\/\/ java_thread - protected by ThreadsListHandle\n@@ -1590,0 +1585,1 @@\n+\/\/ java_thread - protected by ThreadsListHandle\n@@ -1591,1 +1587,1 @@\n-JvmtiEnvBase::resume_thread(oop thread_oop, JavaThread* java_thread, bool single_suspend) {\n+JvmtiEnvBase::resume_thread(oop thread_oop, JavaThread* java_thread, bool single_resume) {\n@@ -1598,1 +1594,1 @@\n-    if (single_suspend) {\n+    if (single_resume) {\n@@ -1604,1 +1600,1 @@\n-      \/\/ A non-NULL java_thread is always passed in the !single_suspend case.\n+      \/\/ A non-NULL java_thread is always passed in the !single_resume case.\n@@ -1635,1 +1631,1 @@\n-    assert(single_suspend || is_virtual, \"ResumeAllVirtualThreads should never resume non-virtual threads\");\n+    assert(single_resume || is_virtual, \"ResumeAllVirtualThreads should never resume non-virtual threads\");\n@@ -1691,1 +1687,0 @@\n-\n@@ -1717,1 +1712,0 @@\n-  \/\/ Support for virtual threads\n@@ -1900,0 +1894,2 @@\n+\/\/ thread - NOT protected by ThreadsListHandle and NOT pre-checked\n+\n@@ -1902,2 +1898,0 @@\n-  jvmtiError err = JVMTI_ERROR_NONE;\n-  JavaThread* java_thread = NULL;\n@@ -1906,1 +1900,0 @@\n-  oop thread_obj = NULL;\n@@ -1911,1 +1904,3 @@\n-  err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n+  JavaThread* java_thread = NULL;\n+  oop thread_obj = NULL;\n+  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n@@ -1916,1 +1911,0 @@\n-  \/\/ Support for virtual threads\n@@ -1918,0 +1912,1 @@\n+    \/\/ No support for virtual threads (yet).\n@@ -2267,1 +2262,1 @@\n-    RegisterMap reg_map(java_thread, true, true);\n+    RegisterMap reg_map(java_thread, \/* update_map *\/ true, \/* process_frames *\/ true);\n@@ -2287,1 +2282,1 @@\n-      java_thread->is_handshake_safe_for(current_thread),\n+         java_thread->is_handshake_safe_for(current_thread),\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":44,"deletions":49,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  static jvmtiError resume_thread(oop thread_oop, JavaThread* java_thread, bool single_suspend);\n+  static jvmtiError resume_thread(oop thread_oop, JavaThread* java_thread, bool single_resume);\n@@ -179,1 +179,1 @@\n-  \/\/ If there is a virtual thread mounted to the JavaThread* then\n+  \/\/ If there is a virtual thread mounted on the JavaThread* then\n@@ -385,1 +385,1 @@\n-                          GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list);\n+                                GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -285,1 +285,1 @@\n-      return; \/\/ _completed remains false\n+      return; \/\/ _completed remains false.\n@@ -291,1 +291,1 @@\n-      \/\/ jvf can be NULL, when the native enterSpecial frame is on the top\n+      \/\/ jvf can be NULL, when the native enterSpecial frame is on the top.\n@@ -378,1 +378,0 @@\n-    \/\/ Check for an unmounted virual thread case.\n@@ -380,0 +379,1 @@\n+      \/\/ Handle the unmounted virtual thread case.\n@@ -386,1 +386,0 @@\n-      \/\/ do nothing if virtual thread has been already terminated\n@@ -388,0 +387,1 @@\n+        \/\/ Do nothing if virtual thread has been already terminated.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-      return; \/\/ the pending flag has been already cleared, so bail out\n+      return;  \/\/ The pending flag has been already cleared, so bail out.\n@@ -216,1 +216,1 @@\n-    state->set_pending_interp_only_mode(false); \/\/ clear the pending flag\n+    state->set_pending_interp_only_mode(false);  \/\/ Clear the pending flag.\n@@ -355,1 +355,1 @@\n-    return; \/\/ an EnterInterpOnlyModeClosure handshake is already pending for execution\n+    return;  \/\/ An EnterInterpOnlyModeClosure handshake is already pending for execution.\n@@ -357,1 +357,1 @@\n-  \/\/ this flag will be cleared in EnterInterpOnlyModeClosure handshake\n+  \/\/ This flag will be cleared in EnterInterpOnlyModeClosure handshake.\n@@ -360,1 +360,1 @@\n-    return; \/\/ EnterInterpOnlyModeClosure will be executed right after mount\n+    return;  \/\/ EnterInterpOnlyModeClosure will be executed right after mount.\n@@ -377,1 +377,1 @@\n-    state->set_pending_interp_only_mode(false); \/\/ just clear the pending flag\n+    state->set_pending_interp_only_mode(false);  \/\/ Just clear the pending flag.\n@@ -575,1 +575,0 @@\n-    \/\/ pointer to JavaThread can be NULL for unmouted virtual thread\n@@ -577,1 +576,2 @@\n-      \/\/ update the JavaThread cached value for thread-specific should_post_on_exceptions value\n+      \/\/ The JavaThread for carrier or mounted virtual thread case.\n+      \/\/ Update the cached value for thread-specific should_post_on_exceptions value.\n@@ -766,1 +766,1 @@\n-  \/\/ mask to clear normal event bits\n+  \/\/ Mask to clear normal event bits.\n@@ -768,1 +768,1 @@\n-  \/\/ avoid cleaning extension event bits\n+  \/\/ Avoid cleaning extension event bits.\n@@ -890,1 +890,4 @@\n-  if (thread == NULL && thread_oop_h() == NULL) { \/\/ thread can be NULL for unmounted virtual trheads\n+  if (thread == NULL && thread_oop_h() == NULL) {\n+    \/\/ NULL thread and NULL thread_oop now indicate setting globally instead\n+    \/\/ of setting thread specific since NULL thread by itself means an\n+    \/\/ unmounted virtual thread.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":14,"deletions":11,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1891,1 +1891,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,3 +41,3 @@\n-\/*\n- * Extension Functions\n- *\/\n+\/\/\n+\/\/ Extension Functions\n+\/\/\n@@ -172,1 +172,1 @@\n-  \/\/ register our extension functions\n+  \/\/ Register our extension functions.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -493,1 +493,1 @@\n-    \/\/ Just to check index boundaries\n+    \/\/ Just to check index boundaries.\n@@ -650,1 +650,1 @@\n-      \/\/ continuation can't be unmounted at this point (it was checked\/reported in get_java_vframe)\n+      \/\/ Continuation can't be unmounted at this point (it was checked\/reported in get_java_vframe).\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -386,1 +386,1 @@\n-\/\/ VM operation to get or set virtual thread local\n+\/\/ VM operation to get or set virtual thread local.\n@@ -395,1 +395,1 @@\n-  \/\/ Constructor for non-object getter\n+  \/\/ Constructor for non-object getter.\n@@ -398,1 +398,1 @@\n-  \/\/ Constructor for object or non-object setter\n+  \/\/ Constructor for object or non-object setter.\n@@ -402,1 +402,1 @@\n-  \/\/ Constructor for object getter\n+  \/\/ Constructor for object getter.\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,1 +274,1 @@\n-  \/\/ special case for virtual thread events\n+  \/\/ Special case for virtual thread events.\n","filename":"src\/hotspot\/share\/prims\/jvmtiManageCapabilities.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,0 @@\n-  \/\/ thread can be NULL if virtual thread is unmounted\n@@ -122,1 +121,0 @@\n-    \/\/ set this as the state for the thread only if thread_oop is current thread->jvmti_vthread()\n@@ -124,0 +122,2 @@\n+      \/\/ The JavaThread for carrier or mounted virtual thread case.\n+      \/\/ Set this only if thread_oop is current thread->jvmti_vthread().\n@@ -213,1 +213,3 @@\n-\/* Virtual Threads Mount Transition (VTMT) mechanism *\/\n+\/\/\n+\/\/ Virtual Threads Mount Transition (VTMT) mechanism\n+\/\/\n@@ -215,1 +217,1 @@\n-\/\/ VTMT can not be disabled while this counter is positive\n+\/\/ VTMT cannot be disabled while this counter is positive.\n@@ -221,1 +223,1 @@\n-\/\/ there is an active suspender or resumer\n+\/\/ There is an active suspender or resumer.\n@@ -232,1 +234,1 @@\n-    \/\/ Handshake with target\n+    \/\/ Handshake with target.\n@@ -241,1 +243,1 @@\n-    return; \/\/ detached thread, can be a call from Agent_OnLoad\n+    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n@@ -249,1 +251,1 @@\n-    return; \/\/ detached thread, can be a call from Agent_OnLoad\n+    return;  \/\/ Detached thread, can be a call from Agent_OnLoad.\n@@ -263,2 +265,2 @@\n-    while (_SR_mode) { \/\/ suspender or resumer is a JvmtiVTMTDisabler monopolist\n-      ml.wait(10); \/\/ wait while there is an active suspender or resumer\n+    while (_SR_mode) {  \/\/ suspender or resumer is a JvmtiVTMTDisabler monopolist\n+      ml.wait(10);  \/\/ Wait while there is an active suspender or resumer.\n@@ -269,1 +271,1 @@\n-        ml.wait(10); \/\/ wait while there is any active jvmtiVTMTDisabler\n+        ml.wait(10);  \/\/ Wait while there is any active jvmtiVTMTDisabler.\n@@ -275,1 +277,1 @@\n-    \/\/ Debug version fails and print diagnostic information\n+    \/\/ Debug version fails and prints diagnostic information.\n@@ -292,1 +294,1 @@\n-    assert(false, \"stuck in JvmtiVTMTDisabler::disable_VTMT\");\n+    fatal(\"stuck in JvmtiVTMTDisabler::disable_VTMT\");\n@@ -304,1 +306,1 @@\n-    if (_is_SR) { \/\/ disabler is suspender or resumer\n+    if (_is_SR) {  \/\/ Disabler is suspender or resumer.\n@@ -330,1 +332,1 @@\n-  int64_t thread_id = java_lang_Thread::thread_id(vth()); \/\/ cannot use oops while blocked\n+  int64_t thread_id = java_lang_Thread::thread_id(vth());  \/\/ Cannot use oops while blocked.\n@@ -349,1 +351,1 @@\n-        \/\/ block while transitions are disabled or there are suspend requests\n+        \/\/ Block while transitions are disabled or there are suspend requests.\n@@ -354,1 +356,1 @@\n-        continue; \/\/ ~ThreadBlockInVM has handshake-based suspend point\n+        continue;  \/\/ ~ThreadBlockInVM has handshake-based suspend point.\n@@ -360,1 +362,1 @@\n-  \/\/ enter VTMT section\n+  \/\/ Enter VTMT section.\n@@ -372,1 +374,1 @@\n-    assert(false, \"stuck in JvmtiVTMTDisabler::start_VTMT\");\n+    fatal(\"stuck in JvmtiVTMTDisabler::start_VTMT\");\n@@ -392,1 +394,1 @@\n-  \/\/ unblock waiting VTMT disablers\n+  \/\/ Unblock waiting VTMT disablers.\n@@ -404,1 +406,1 @@\n-      \/\/ block while there are suspend requests\n+      \/\/ Block while there are suspend requests.\n@@ -408,1 +410,1 @@\n-        \/\/ block while there are suspend requests\n+        \/\/ Block while there are suspend requests.\n@@ -417,1 +419,3 @@\n-\/* Virtual Threads Suspend\/Resume management *\/\n+\/\/\n+\/\/ Virtual Threads Suspend\/Resume management\n+\/\/\n@@ -527,1 +531,1 @@\n-  assert(is_interp_only_mode(), \"leaving interp only when mode not one\");\n+  assert(is_interp_only_mode(), \"leaving interp only when not in interp only mode\");\n@@ -529,0 +533,1 @@\n+    \/\/ Unmounted virtual thread updates the saved value.\n@@ -549,1 +554,1 @@\n-        thread->is_handshake_safe_for(current_thread),\n+           thread->is_handshake_safe_for(current_thread),\n@@ -551,1 +556,1 @@\n-    if (!thread->has_last_Java_frame()) return 0;  \/\/ no Java frames\n+    if (!thread->has_last_Java_frame()) return 0;  \/\/ No Java frames.\n@@ -553,1 +558,1 @@\n-    RegisterMap reg_map(thread, false, false, true);\n+    RegisterMap reg_map(thread, \/* update_map *\/ false, \/* process_frames *\/ false, \/* walk_cont *\/ true);\n@@ -784,1 +789,1 @@\n-  _thread_saved = NULL; \/\/ common case;\n+  _thread_saved = NULL;  \/\/ Common case.\n@@ -799,1 +804,0 @@\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.cpp","additions":33,"deletions":29,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-  if (thread_oop == NULL) { \/\/ then thread should not be NULL (see assert above)\n+  if (thread_oop == NULL) {  \/\/ Then thread should not be NULL (see assert above).\n@@ -87,1 +87,1 @@\n-  \/\/ in a case of unmounted virtual thread the thread can be NULL\n+  \/\/ In a case of unmounted virtual thread the thread can be NULL.\n@@ -91,1 +91,1 @@\n-    \/\/ don't add a JvmtiThreadState to a thread that is exiting\n+    \/\/ Don't add a JvmtiThreadState to a thread that is exiting.\n@@ -95,2 +95,2 @@\n-    \/\/ check if java_lang_Thread already has a link to the JvmtiThreadState\n-    if (thread_oop != NULL) { \/\/ thread_oop can be NULL at early VMStart\n+    \/\/ Check if java_lang_Thread already has a link to the JvmtiThreadState.\n+    if (thread_oop != NULL) {  \/\/ thread_oop can be NULL during early VMStart.\n@@ -99,1 +99,1 @@\n-    if (state == NULL) { \/\/ need to create state\n+    if (state == NULL) {  \/\/ Need to create state.\n@@ -108,1 +108,1 @@\n-  \/\/ in a case of unmounted virtual thread the thread can be NULL\n+  \/\/ In a case of unmounted virtual thread the thread can be NULL.\n@@ -136,1 +136,1 @@\n-  \/\/ save interp_only_mode\n+  \/\/ Save thread's interp_only_mode.\n@@ -138,1 +138,1 @@\n-  state->set_thread(NULL); \/\/ it is to make sure stale _thread value is never used\n+  state->set_thread(NULL);  \/\/ Make sure stale _thread value is never used.\n@@ -142,1 +142,1 @@\n-  \/\/ restore thread interp_only_mode\n+  \/\/ Restore thread's interp_only_mode.\n@@ -145,1 +145,1 @@\n-  \/\/ make continuation to notice the interp_only_mode change\n+  \/\/ Make continuation notice the interp_only_mode change.\n@@ -148,1 +148,1 @@\n-  \/\/ bind JavaThread to JvmtiThreadState\n+  \/\/ Bind JavaThread to JvmtiThreadState.\n@@ -152,1 +152,1 @@\n-    \/\/ bind to JavaThread\n+    \/\/ Bind to JavaThread.\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.inline.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiTrace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiUtil.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}