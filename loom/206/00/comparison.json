{"files":[{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -556,0 +557,7 @@\n+\n+  if (ObjectMonitorMode::java()) {\n+    \/\/ for now always pick 'slow-path' as JOM will do quick\/slow determination\n+    testptr(objReg, objReg);\n+    return;\n+  }\n+\n@@ -756,0 +764,7 @@\n+\n+  if (ObjectMonitorMode::java()) {\n+    \/\/ for now always pick 'slow-path' as JOM will do quick\/slow determination\n+    testptr(objReg, objReg);\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2196,2 +2196,4 @@\n-  profile_call(rax);\n-  profile_arguments_type(rax, rbx, LP64_ONLY(r13) NOT_LP64(rsi), false);\n+  if (!ObjectMonitorMode::java()) {\n+    profile_call(rax);\n+    profile_arguments_type(rax, rbx, LP64_ONLY(r13) NOT_LP64(rsi), false);\n+  }\n@@ -2266,2 +2268,4 @@\n-  profile_call(rax);\n-  profile_arguments_type(rax, rbx, LP64_ONLY(r13) NOT_LP64(rsi), false);\n+  if (!ObjectMonitorMode::java()) {\n+    profile_call(rax);\n+    profile_arguments_type(rax, rbx, LP64_ONLY(r13) NOT_LP64(rsi), false);\n+  }\n@@ -2320,2 +2324,4 @@\n-  profile_call(rax);\n-  profile_arguments_type(rax, rbx, LP64_ONLY(r13) NOT_LP64(rsi), false);\n+  if (!ObjectMonitorMode::java()) {\n+    profile_call(rax);\n+    profile_arguments_type(rax, rbx, LP64_ONLY(r13) NOT_LP64(rsi), false);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2450,1 +2450,5 @@\n-    __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C)));\n+    if (ObjectMonitorMode::java()) {\n+      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C_block)));\n+    } else {\n+      __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C)));\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -4441,2 +4441,4 @@\n-    __ profile_call(rax);\n-    __ profile_arguments_type(rax, rbx, rbcp, false);\n+    if (!ObjectMonitorMode::java()) {\n+      __ profile_call(rax);\n+      __ profile_arguments_type(rax, rbx, rbcp, false);\n+    }\n@@ -4616,2 +4618,4 @@\n-    __ profile_call(rax);\n-    __ profile_arguments_type(rax, rbx, rbcp, false);\n+    if (!ObjectMonitorMode::java()) {\n+      __ profile_call(rax);\n+      __ profile_arguments_type(rax, rbx, rbcp, false);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+  void              set_method(ciMethod *m) { _method = m; }\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3510,0 +3510,16 @@\n+\n+  if (ObjectMonitorMode::java()) {\n+\n+#ifdef ASSERT\n+    \/\/ For some reason, we sometimes end up with dead locals that must be killed\n+    \/\/ before we call add_safepoint_edges.\n+    if (!dead_locals_are_killed()) {\n+      kill_dead_locals();\n+    }\n+#endif \/\/ASSERT\n+\n+    \/\/ This will set the jvms pointer in the unlock node\n+    \/\/ In JOM mode we want unlock to behave like lock.\n+    add_safepoint_edges(unlock);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-  \/\/ Slow-path call\n+ \/\/ Slow-path call\n@@ -2038,1 +2038,4 @@\n-      if (alock->jvms() != nullptr) {\n+\n+      \/\/ The above statement is no longer true therefore, we should\n+      \/\/ use a more explicit check for node type.\n+      if (alock->is_Lock()) {\n@@ -2261,0 +2264,1 @@\n+  CallNode *call = nullptr;\n@@ -2262,3 +2266,10 @@\n-  CallNode *call = make_slow_call((CallNode *) unlock, OptoRuntime::complete_monitor_exit_Type(),\n-                                  CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C),\n-                                  \"complete_monitor_unlocking_C\", slow_path, obj, box, thread);\n+  \/\/ If JOM is used we don't want to create a CallLeafNode for our slow call.\n+  if (ObjectMonitorMode::java()) {\n+    call = make_slow_call((CallNode *)unlock, OptoRuntime::complete_monitor_exit_Type(),\n+                          OptoRuntime::complete_monitor_unlocking_Java(),\n+                          nullptr, slow_path, obj, box, thread);\n+  } else {\n+    call = make_slow_call((CallNode *)unlock, OptoRuntime::complete_monitor_exit_Type(),\n+                          CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C),\n+                          \"complete_monitor_unlocking_C\", slow_path, obj, box, thread);\n+  }\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -1121,1 +1122,1 @@\n-      kit.set_jvms(ex_jvms);\n+\n@@ -1126,0 +1127,15 @@\n+        \/\/ Ensure that the jvms object has a method pointer inorder to\n+        \/\/ avoid asserts.\n+        if (ObjectMonitorMode::java()) {\n+          if (!ex_jvms->has_method()){\n+            ex_jvms->set_method(method());\n+          } else {\n+            \/\/ We reach here when _invokeinterface gets parsed.\n+            \/\/ This is most likely because ex_jvms->method() is the caller and\n+            \/\/ this->method() is the callee.\n+\n+            \/\/assert(ex_jvms->method() == method(), \"They should be the same.\");\n+          }\n+        }\n+        kit.set_jvms(ex_jvms);\n+\n@@ -1137,0 +1153,2 @@\n+      } else {\n+        kit.set_jvms(ex_jvms);\n@@ -1138,0 +1156,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+address OptoRuntime::_complete_monitor_unlocking_Java             = nullptr;\n@@ -164,0 +165,1 @@\n+  gen(env, _complete_monitor_unlocking_Java, complete_monitor_exit_Type   , SharedRuntime::complete_monitor_unlocking_C_block, 0, false, false);\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  static address _complete_monitor_unlocking_Java;\n@@ -212,0 +213,1 @@\n+  static address complete_monitor_unlocking_Java()       { return _complete_monitor_unlocking_Java; }\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3004,6 +3004,6 @@\n-    \/\/  TieredStopAtLevel=1;\n-#ifndef C2_PATCH\n-    set_mode_flags(_int);\n-#else\n-    \/\/set_mode_flags(_int);\n-#endif\n+\n+    \/\/ JOM is currently only supported by the interpreter and C2\n+    \/\/ \"high-only\" compilation mode will ensure that all compilation\n+    \/\/ happens in C2.\n+    FLAG_SET_CMDLINE(CompilationMode, \"high-only\");\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2239,1 +2239,1 @@\n-  if (!SafepointSynchronize::is_synchronizing()) {\n+  if (!SafepointSynchronize::is_synchronizing() && !ObjectMonitorMode::java()) {\n@@ -2242,0 +2242,3 @@\n+    \/\/ Also, only when we're not using JOM since the quick enter logic\n+    \/\/ is implemented in the java call.\n+\n@@ -2252,1 +2255,7 @@\n-  ObjectSynchronizer::enter(h_obj, lock, current);\n+\n+  if (ObjectMonitorMode::java()) {\n+    ObjectSynchronizer::java_enter(h_obj, current);\n+  } else {\n+    ObjectSynchronizer::enter(h_obj, lock, current);\n+  }\n+\n@@ -2274,1 +2283,10 @@\n-  ObjectSynchronizer::exit(obj, lock, current);\n+\n+  if (ObjectMonitorMode::java()) {\n+    JRT_BLOCK_NO_ASYNC\n+    Handle h_obj(THREAD, obj);\n+    ObjectSynchronizer::java_exit(obj, current);\n+    assert(!HAS_PENDING_EXCEPTION, \"Should have no exception here\");\n+    JRT_BLOCK_END\n+  } else {\n+    ObjectSynchronizer::exit(obj, lock, current);\n+  }\n@@ -2283,0 +2301,7 @@\n+\/\/ Handles the uncommon cases of monitor unlocking in compiled code\n+\/\/ This can't be a leaf because of the need for object handle.\n+JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_unlocking_C_block(oopDesc* obj, BasicLock* lock, JavaThread* current))\n+  assert(current == JavaThread::current(), \"pre-condition\");\n+  SharedRuntime::monitor_exit_helper(obj, lock, current);\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -501,0 +501,1 @@\n+  static void complete_monitor_unlocking_C_block(oopDesc* obj, BasicLock* lock, JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -543,0 +543,6 @@\n+void ObjectSynchronizer::java_exit(oop obj, JavaThread* current) {\n+  assert(ObjectMonitorMode::java(), \"must be\");\n+  Handle h_obj(current, obj);\n+  java_exit(h_obj, current);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -194,0 +194,1 @@\n+  static void java_exit(oop obj, JavaThread* current);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}