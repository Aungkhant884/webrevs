{"files":[{"patch":"@@ -38,1 +38,1 @@\n-  address pc = *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET);\n+  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n@@ -421,1 +421,1 @@\n-  *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET) = pc;\n+  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n","filename":"src\/hotspot\/cpu\/aarch64\/continuation_aarch64.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -402,0 +402,4 @@\n+inline int frame::sender_sp_ret_address_offset() {\n+  return frame::sender_sp_offset - frame::return_addr_offset;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1330,0 +1330,4 @@\n+\n+void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n+  fatal(\"Continuation.doYield intrinsic is not implemented on this platform\");\n+}\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRGenerator_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_CONTINUATION_ARM_INLINE_HPP\n+#define CPU_ARM_CONTINUATION_ARM_INLINE_HPP\n+\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n+#include \"runtime\/frame.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+\n+\/\/ TODO: Implement\n+const int ContinuationHelper::frame_metadata = 0;\n+const int ContinuationHelper::align_wiggle = 0;\n+\n+#ifdef ASSERT\n+bool Frame::assert_frame_laid_out(frame f) {\n+  Unimplemented();\n+  return false;\n+}\n+#endif\n+\n+inline intptr_t** Frame::callee_link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind>\n+static inline intptr_t* real_fp(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind> \/\/ TODO: maybe do the same CRTP trick with Interpreted and Compiled as with hframe\n+static inline intptr_t** link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address* Interpreted::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool relative>\n+void Interpreted::patch_sender_sp(frame& f, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline address* Frame::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address Frame::real_pc(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void Frame::patch_pc(const frame& f, address pc) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* Interpreted::frame_top(const frame& f, InterpreterOopMap* mask) { \/\/ inclusive; this will be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool relative>\n+inline intptr_t* Interpreted::frame_bottom(const frame& f) { \/\/ exclusive; this will not be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline intptr_t* Interpreted::frame_top(const frame& f, int callee_argsize, bool callee_interpreted) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind, typename RegisterMapT>\n+inline void ContinuationHelper::update_register_map(RegisterMapT* map, const frame& f) {\n+  Unimplemented();\n+}\n+\n+template<typename RegisterMapT>\n+inline void ContinuationHelper::update_register_map_with_callee(RegisterMapT* map, const frame& f) {\n+  Unimplemented();\n+}\n+\n+inline void ContinuationHelper::push_pd(const frame& f) {\n+  Unimplemented();\n+}\n+\n+\/\/ creates the yield stub frame faster than JavaThread::last_frame\n+inline frame ContinuationHelper::last_frame(JavaThread* thread) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+frame ContinuationEntry::to_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+void ContinuationEntry::update_register_map(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+  Unimplemented();\n+}\n+\n+void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::set_top_frame_metadata_pd(const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Freeze<ConfigT>::align_bottom(intptr_t* bottom, int argsize) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind>\n+inline frame Freeze<ConfigT>::sender(const frame& f) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind> frame Freeze<ConfigT>::new_hframe(frame& f, frame& caller) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::relativize_interpreted_frame_metadata(const frame& f, const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+template <typename FKind, bool bottom>\n+inline void Freeze<ConfigT>::patch_pd(frame& hf, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::patch_chunk_pd(intptr_t* vsp, intptr_t* hsp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline frame Thaw<ConfigT>::new_entry_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind> frame Thaw<ConfigT>::new_frame(const frame& hf, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Thaw<ConfigT>::align(const frame& hf, intptr_t* vsp, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind, bool bottom>\n+inline void Thaw<ConfigT>::patch_pd(frame& f, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+intptr_t* Thaw<ConfigT>::push_interpreter_return_frame(intptr_t* sp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+void Thaw<ConfigT>::patch_chunk_pd(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::prefetch_chunk_pd(void* start, int size) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Thaw<ConfigT>::align_chunk(intptr_t* vsp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+#endif \/\/ CPU_ARM_CONTINUATION_ARM_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/arm\/continuation_arm.inline.hpp","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -251,5 +251,0 @@\n-int frame::frame_size(RegisterMap* map) const {\n-  frame sender = this->sender(map);\n-  return sender.sp() - sp();\n-}\n-\n@@ -282,1 +277,6 @@\n-BasicObjectLock* frame::interpreter_frame_monitor_end() const {\n+\/\/ Pointer beyond the \"oldest\/deepest\" BasicObjectLock on stack.\n+template BasicObjectLock* frame::interpreter_frame_monitor_end<true>() const;\n+template BasicObjectLock* frame::interpreter_frame_monitor_end<false>() const;\n+\n+template <bool relative>\n+inline BasicObjectLock* frame::interpreter_frame_monitor_end() const {\n@@ -402,0 +402,1 @@\n+template <bool stub>\n@@ -445,1 +446,1 @@\n-    return sender_for_compiled_frame(map);\n+    return sender_for_compiled_frame<false>(map);\n@@ -550,0 +551,2 @@\n+template intptr_t* frame::interpreter_frame_tos_at<false>(jint offset) const;\n+template intptr_t* frame::interpreter_frame_tos_at<true >(jint offset) const;\n@@ -551,1 +554,2 @@\n-intptr_t* frame::interpreter_frame_tos_at(jint offset) const {\n+template <bool relative>\n+inline intptr_t* frame::interpreter_frame_tos_at(jint offset) const {\n@@ -579,0 +583,3 @@\n+void frame::describe_top_pd(FrameValues& values) {\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -93,0 +93,2 @@\n+  const ImmutableOopMap* get_oop_map() const;\n+\n@@ -113,0 +115,3 @@\n+  template <typename RegisterMapT>\n+  static void update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr);\n+\n@@ -121,0 +126,3 @@\n+  template <bool relative = false>\n+  inline intptr_t* interpreter_frame_last_sp() const;\n+\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,4 @@\n+inline frame::frame(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n@@ -173,0 +177,1 @@\n+template <bool relative>\n@@ -198,0 +203,1 @@\n+template <bool relative>\n@@ -214,1 +220,1 @@\n-  oop* result_adr = (oop*) map->location(R0->as_VMReg());\n+  oop* result_adr = (oop*) map->location(R0->as_VMReg(), (intptr_t*) NULL);\n@@ -220,1 +226,1 @@\n-  oop* result_adr = (oop*) map->location(R0->as_VMReg());\n+  oop* result_adr = (oop*) map->location(R0->as_VMReg(), (intptr_t*) NULL);\n@@ -225,0 +231,52 @@\n+inline int frame::frame_size() const {\n+  return sender_sp() - sp();\n+}\n+\n+inline const ImmutableOopMap* frame::get_oop_map() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::compiled_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+}\n+\n+inline int frame::interpreted_frame_num_oops(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool relative>\n+inline intptr_t* frame::interpreter_frame_last_sp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::sender_sp_ret_address_offset() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <typename RegisterMapT>\n+void frame::update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr) {\n+  Unimplemented();\n+}\n+\n+inline void frame::set_unextended_sp(intptr_t* value) {\n+  Unimplemented();\n+}\n+\n+inline int frame::offset_unextended_sp() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::set_offset_unextended_sp(int value) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":60,"deletions":2,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ARM_INSTANCESTACKCHUNKKLASS_ARM_INLINE_HPP\n+#define CPU_ARM_INSTANCESTACKCHUNKKLASS_ARM_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+int InstanceStackChunkKlass::metadata_words() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+int InstanceStackChunkKlass::align_wiggle()   {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+#ifdef ASSERT\n+template <bool mixed>\n+inline bool StackChunkFrameStream<mixed>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <bool mixed>\n+inline frame StackChunkFrameStream<mixed>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <bool mixed>\n+inline address StackChunkFrameStream<mixed>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+intptr_t* StackChunkFrameStream<mixed>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline void StackChunkFrameStream<mixed>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<true>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<false>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <bool mixed>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<mixed>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_ARM_INSTANCESTACKCHUNKKLASS_ARM_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/arm\/instanceStackChunkKlass_arm.inline.hpp","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -435,0 +435,31 @@\n+class NativePostCallNop: public NativeInstruction {\n+public:\n+  bool check() const { Unimplemented(); return false; }\n+  int displacement() const { Unimplemented(); return 0; }\n+  void patch(jint diff) { Unimplemented(); }\n+  void make_deopt() { Unimplemented(); }\n+};\n+\n+inline NativePostCallNop* nativePostCallNop_at(address address) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+class NativeDeoptInstruction: public NativeInstruction {\n+public:\n+  address instruction_address() const       { Unimplemented(); return NULL; }\n+  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+\n+  void  verify() { Unimplemented(); }\n+\n+  static bool is_deopt_at(address instr) {\n+    Unimplemented();\n+    return false;\n+  }\n+\n+  \/\/ MT-safe patching\n+  static void insert(address code_pos) {\n+    Unimplemented();\n+  }\n+};\n+\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    return location(base_reg->next(slot_idx));\n+    return location(base_reg->next(slot_idx), (intptr_t*) NULL);\n","filename":"src\/hotspot\/cpu\/arm\/registerMap_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3089,1 +3089,1 @@\n-void StubGenerator_generate(CodeBuffer* code, bool all) {\n+void StubGenerator_generate(CodeBuffer* code, int phase) {\n@@ -3093,1 +3093,1 @@\n-  StubGenerator g(code, all);\n+  StubGenerator g(code, phase);\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -731,0 +731,5 @@\n+address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1382,0 +1382,4 @@\n+\n+void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n+  fatal(\"Continuation.doYield intrinsic is not implemented on this platform\");\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRGenerator_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_CONTINUATION_PPC_INLINE_HPP\n+#define CPU_PPC_CONTINUATION_PPC_INLINE_HPP\n+\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n+#include \"runtime\/frame.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+\n+\/\/ TODO: Implement\n+const int ContinuationHelper::frame_metadata = 0;\n+const int ContinuationHelper::align_wiggle = 0;\n+\n+#ifdef ASSERT\n+bool Frame::assert_frame_laid_out(frame f) {\n+  Unimplemented();\n+  return false;\n+}\n+#endif\n+\n+inline intptr_t** Frame::callee_link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind>\n+static inline intptr_t* real_fp(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind> \/\/ TODO: maybe do the same CRTP trick with Interpreted and Compiled as with hframe\n+static inline intptr_t** link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address* Interpreted::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool relative>\n+void Interpreted::patch_sender_sp(frame& f, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline address* Frame::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address Frame::real_pc(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void Frame::patch_pc(const frame& f, address pc) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* Interpreted::frame_top(const frame& f, InterpreterOopMap* mask) { \/\/ inclusive; this will be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool relative>\n+inline intptr_t* Interpreted::frame_bottom(const frame& f) { \/\/ exclusive; this will not be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline intptr_t* Interpreted::frame_top(const frame& f, int callee_argsize, bool callee_interpreted) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind, typename RegisterMapT>\n+inline void ContinuationHelper::update_register_map(RegisterMapT* map, const frame& f) {\n+  Unimplemented();\n+}\n+\n+template<typename RegisterMapT>\n+inline void ContinuationHelper::update_register_map_with_callee(RegisterMapT* map, const frame& f) {\n+  Unimplemented();\n+}\n+\n+inline void ContinuationHelper::push_pd(const frame& f) {\n+  Unimplemented();\n+}\n+\n+\/\/ creates the yield stub frame faster than JavaThread::last_frame\n+inline frame ContinuationHelper::last_frame(JavaThread* thread) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+frame ContinuationEntry::to_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+void ContinuationEntry::update_register_map(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+  Unimplemented();\n+}\n+\n+void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::set_top_frame_metadata_pd(const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Freeze<ConfigT>::align_bottom(intptr_t* bottom, int argsize) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind>\n+inline frame Freeze<ConfigT>::sender(const frame& f) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind> frame Freeze<ConfigT>::new_hframe(frame& f, frame& caller) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::relativize_interpreted_frame_metadata(const frame& f, const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+template <typename FKind, bool bottom>\n+inline void Freeze<ConfigT>::patch_pd(frame& hf, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::patch_chunk_pd(intptr_t* vsp, intptr_t* hsp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline frame Thaw<ConfigT>::new_entry_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind> frame Thaw<ConfigT>::new_frame(const frame& hf, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Thaw<ConfigT>::align(const frame& hf, intptr_t* vsp, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind, bool bottom>\n+inline void Thaw<ConfigT>::patch_pd(frame& f, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+intptr_t* Thaw<ConfigT>::push_interpreter_return_frame(intptr_t* sp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+void Thaw<ConfigT>::patch_chunk_pd(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::prefetch_chunk_pd(void* start, int size) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Thaw<ConfigT>::align_chunk(intptr_t* vsp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+#endif \/\/ CPU_PPC_CONTINUATION_PPC_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/continuation_ppc.inline.hpp","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -222,0 +222,1 @@\n+template <bool stub>\n@@ -261,1 +262,1 @@\n-    return sender_for_compiled_frame(map);\n+    return sender_for_compiled_frame<false>(map);\n@@ -377,0 +378,4 @@\n+\n+void frame::describe_top_pd(FrameValues& values) {\n+  Unimplemented();\n+}\n@@ -391,0 +396,17 @@\n+\n+\/\/ Pointer beyond the \"oldest\/deepest\" BasicObjectLock on stack.\n+template BasicObjectLock* frame::interpreter_frame_monitor_end<true>() const;\n+template BasicObjectLock* frame::interpreter_frame_monitor_end<false>() const;\n+\n+template <bool relative>\n+inline BasicObjectLock* frame::interpreter_frame_monitor_end() const {\n+  return (BasicObjectLock*) get_ijava_state()->monitors;\n+}\n+\n+template intptr_t* frame::interpreter_frame_tos_at<false>(jint offset) const;\n+template intptr_t* frame::interpreter_frame_tos_at<true >(jint offset) const;\n+\n+template <bool relative>\n+inline intptr_t* frame::interpreter_frame_tos_at(jint offset) const {\n+  return &interpreter_frame_tos_address()[offset];\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -382,0 +382,2 @@\n+  const ImmutableOopMap* get_oop_map() const;\n+\n@@ -383,1 +385,0 @@\n-  inline frame(intptr_t* sp);\n@@ -403,0 +404,6 @@\n+  template <bool relative = false>\n+  inline intptr_t* interpreter_frame_last_sp() const;\n+\n+  template <typename RegisterMapT>\n+  static void update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr);\n+\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-inline int frame::frame_size(RegisterMap* map) const {\n+inline int frame::frame_size() const {\n@@ -142,5 +142,0 @@\n-\/\/ Pointer beyond the \"oldest\/deepest\" BasicObjectLock on stack.\n-inline BasicObjectLock* frame::interpreter_frame_monitor_end() const {\n-  return (BasicObjectLock*) get_ijava_state()->monitors;\n-}\n-\n@@ -179,0 +174,1 @@\n+template <bool relative>\n@@ -184,0 +180,1 @@\n+template <bool relative>\n@@ -188,4 +185,0 @@\n-inline intptr_t* frame::interpreter_frame_tos_at(jint offset) const {\n-  return &interpreter_frame_tos_address()[offset];\n-}\n-\n@@ -217,1 +210,1 @@\n-  return *((oop*)map->location(R3->as_VMReg()));\n+  return *((oop*)map->location(R3->as_VMReg(), (intptr_t*) NULL));\n@@ -221,1 +214,49 @@\n-  *((oop*)map->location(R3->as_VMReg())) = obj;\n+  *((oop*)map->location(R3->as_VMReg(), (intptr_t*) NULL)) = obj;\n+}\n+\n+inline const ImmutableOopMap* frame::get_oop_map() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::compiled_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+}\n+\n+inline int frame::interpreted_frame_num_oops(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool relative>\n+inline intptr_t* frame::interpreter_frame_last_sp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::sender_sp_ret_address_offset() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <typename RegisterMapT>\n+void frame::update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr) {\n+  Unimplemented();\n+}\n+\n+inline void frame::set_unextended_sp(intptr_t* value) {\n+  Unimplemented();\n+}\n+\n+inline int frame::offset_unextended_sp() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::set_offset_unextended_sp(int value) {\n+  Unimplemented();\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":53,"deletions":12,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_PPC_INSTANCESTACKCHUNKKLASS_PPC_INLINE_HPP\n+#define CPU_PPC_INSTANCESTACKCHUNKKLASS_PPC_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+int InstanceStackChunkKlass::metadata_words() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+int InstanceStackChunkKlass::align_wiggle()   {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+#ifdef ASSERT\n+template <bool mixed>\n+inline bool StackChunkFrameStream<mixed>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <bool mixed>\n+inline frame StackChunkFrameStream<mixed>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <bool mixed>\n+inline address StackChunkFrameStream<mixed>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+intptr_t* StackChunkFrameStream<mixed>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline void StackChunkFrameStream<mixed>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<true>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<false>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <bool mixed>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<mixed>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_PPC_INSTANCESTACKCHUNKKLASS_PPC_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/instanceStackChunkKlass_ppc.inline.hpp","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -506,0 +506,31 @@\n+class NativePostCallNop: public NativeInstruction {\n+public:\n+  bool check() const { Unimplemented(); return false; }\n+  int displacement() const { Unimplemented(); return 0; }\n+  void patch(jint diff) { Unimplemented(); }\n+  void make_deopt() { Unimplemented(); }\n+};\n+\n+inline NativePostCallNop* nativePostCallNop_at(address address) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+class NativeDeoptInstruction: public NativeInstruction {\n+public:\n+  address instruction_address() const       { Unimplemented(); return NULL; }\n+  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+\n+  void  verify() { Unimplemented(); }\n+\n+  static bool is_deopt_at(address instr) {\n+    Unimplemented();\n+    return false;\n+  }\n+\n+  \/\/ MT-safe patching\n+  static void insert(address code_pos) {\n+    Unimplemented();\n+  }\n+};\n+\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    return location(base_reg->next(slot_idx));\n+    return location(base_reg->next(slot_idx), (intptr_t*)NULL);\n","filename":"src\/hotspot\/cpu\/ppc\/registerMap_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4670,1 +4670,1 @@\n-void StubGenerator_generate(CodeBuffer* code, bool all) {\n+void StubGenerator_generate(CodeBuffer* code, int phase) {\n@@ -4674,1 +4674,1 @@\n-  StubGenerator g(code, all);\n+  StubGenerator g(code, phase);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -479,0 +479,5 @@\n+address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1184,0 +1184,4 @@\n+\n+void LIRGenerator::do_continuation_doYield(Intrinsic* x) {\n+  fatal(\"Continuation.doYield intrinsic is not implemented on this platform\");\n+}\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRGenerator_s390.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_CONTINUATION_S390_INLINE_HPP\n+#define CPU_S390_CONTINUATION_S390_INLINE_HPP\n+\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n+#include \"runtime\/frame.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+\n+\/\/ TODO: Implement\n+const int ContinuationHelper::frame_metadata = 0;\n+const int ContinuationHelper::align_wiggle = 0;\n+\n+#ifdef ASSERT\n+bool Frame::assert_frame_laid_out(frame f) {\n+  Unimplemented();\n+  return false;\n+}\n+#endif\n+\n+inline intptr_t** Frame::callee_link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind>\n+static inline intptr_t* real_fp(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind> \/\/ TODO: maybe do the same CRTP trick with Interpreted and Compiled as with hframe\n+static inline intptr_t** link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address* Interpreted::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool relative>\n+void Interpreted::patch_sender_sp(frame& f, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline address* Frame::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address Frame::real_pc(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void Frame::patch_pc(const frame& f, address pc) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* Interpreted::frame_top(const frame& f, InterpreterOopMap* mask) { \/\/ inclusive; this will be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool relative>\n+inline intptr_t* Interpreted::frame_bottom(const frame& f) { \/\/ exclusive; this will not be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline intptr_t* Interpreted::frame_top(const frame& f, int callee_argsize, bool callee_interpreted) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind, typename RegisterMapT>\n+inline void ContinuationHelper::update_register_map(RegisterMapT* map, const frame& f) {\n+  Unimplemented();\n+}\n+\n+template<typename RegisterMapT>\n+inline void ContinuationHelper::update_register_map_with_callee(RegisterMapT* map, const frame& f) {\n+  Unimplemented();\n+}\n+\n+inline void ContinuationHelper::push_pd(const frame& f) {\n+  Unimplemented();\n+}\n+\n+\/\/ creates the yield stub frame faster than JavaThread::last_frame\n+inline frame ContinuationHelper::last_frame(JavaThread* thread) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+frame ContinuationEntry::to_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+void ContinuationEntry::update_register_map(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+  Unimplemented();\n+}\n+\n+void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::set_top_frame_metadata_pd(const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Freeze<ConfigT>::align_bottom(intptr_t* bottom, int argsize) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind>\n+inline frame Freeze<ConfigT>::sender(const frame& f) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind> frame Freeze<ConfigT>::new_hframe(frame& f, frame& caller) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::relativize_interpreted_frame_metadata(const frame& f, const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+template <typename FKind, bool bottom>\n+inline void Freeze<ConfigT>::patch_pd(frame& hf, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::patch_chunk_pd(intptr_t* vsp, intptr_t* hsp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline frame Thaw<ConfigT>::new_entry_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind> frame Thaw<ConfigT>::new_frame(const frame& hf, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Thaw<ConfigT>::align(const frame& hf, intptr_t* vsp, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind, bool bottom>\n+inline void Thaw<ConfigT>::patch_pd(frame& f, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+intptr_t* Thaw<ConfigT>::push_interpreter_return_frame(intptr_t* sp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+void Thaw<ConfigT>::patch_chunk_pd(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::prefetch_chunk_pd(void* start, int size) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Thaw<ConfigT>::align_chunk(intptr_t* vsp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+#endif \/\/ CPU_S390_CONTINUATION_S390_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/s390\/continuation_s390.inline.hpp","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -233,0 +233,1 @@\n+template <bool stub>\n@@ -275,1 +276,1 @@\n-    return sender_for_compiled_frame(map);\n+    return sender_for_compiled_frame<false>(map);\n@@ -631,0 +632,3 @@\n+void frame::describe_top_pd(FrameValues& values) {\n+  Unimplemented();\n+}\n@@ -637,0 +641,18 @@\n+\n+\/\/ Pointer beyond the \"oldest\/deepest\" BasicObjectLock on stack.\n+template BasicObjectLock* frame::interpreter_frame_monitor_end<true>() const;\n+template BasicObjectLock* frame::interpreter_frame_monitor_end<false>() const;\n+\n+template <bool relative>\n+inline BasicObjectLock* frame::interpreter_frame_monitor_end() const {\n+  return interpreter_frame_monitors();\n+}\n+\n+template intptr_t* frame::interpreter_frame_tos_at<false>(jint offset) const;\n+template intptr_t* frame::interpreter_frame_tos_at<true >(jint offset) const;\n+\n+template <bool relative>\n+inline intptr_t* frame::interpreter_frame_tos_at(jint offset) const {\n+  return &interpreter_frame_tos_address()[offset];\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -464,0 +464,1 @@\n+  const ImmutableOopMap* get_oop_map() const;\n@@ -468,1 +469,0 @@\n-  inline frame(intptr_t* sp);\n@@ -489,0 +489,5 @@\n+  template <bool relative = false>\n+  inline intptr_t* interpreter_frame_last_sp() const;\n+\n+  template <typename RegisterMapT>\n+  static void update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr);\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-inline int frame::frame_size(RegisterMap* map) const {\n+inline int frame::frame_size() const {\n@@ -171,0 +171,1 @@\n+template <bool relative>\n@@ -175,5 +176,0 @@\n-inline intptr_t* frame::interpreter_frame_tos_at(jint offset) const {\n-  return &interpreter_frame_tos_address()[offset];\n-}\n-\n-\n@@ -209,0 +205,1 @@\n+template <bool relative>\n@@ -228,4 +225,0 @@\n-inline BasicObjectLock * frame::interpreter_frame_monitor_end() const {\n-  return interpreter_frame_monitors();\n-}\n-\n@@ -280,1 +273,1 @@\n-  return *((oop*) map->location(Z_R2->as_VMReg()));  \/\/ R2 is return register.\n+  return *((oop*) map->location(Z_R2->as_VMReg(), (intptr_t*) NULL));  \/\/ R2 is return register.\n@@ -284,1 +277,1 @@\n-  *((oop*) map->location(Z_R2->as_VMReg())) = obj;  \/\/ R2 is return register.\n+  *((oop*) map->location(Z_R2->as_VMReg(), (intptr_t*) NULL)) = obj;  \/\/ R2 is return register.\n@@ -291,0 +284,48 @@\n+inline const ImmutableOopMap* frame::get_oop_map() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::compiled_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+}\n+\n+inline int frame::interpreted_frame_num_oops(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool relative>\n+inline intptr_t* frame::interpreter_frame_last_sp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::sender_sp_ret_address_offset() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <typename RegisterMapT>\n+void frame::update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr) {\n+  Unimplemented();\n+}\n+\n+inline void frame::set_unextended_sp(intptr_t* value) {\n+  Unimplemented();\n+}\n+\n+inline int frame::offset_unextended_sp() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::set_offset_unextended_sp(int value) {\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.inline.hpp","additions":53,"deletions":12,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_S390_INSTANCESTACKCHUNKKLASS_S390_INLINE_HPP\n+#define CPU_S390_INSTANCESTACKCHUNKKLASS_S390_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+int InstanceStackChunkKlass::metadata_words() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+int InstanceStackChunkKlass::align_wiggle()   {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+#ifdef ASSERT\n+template <bool mixed>\n+inline bool StackChunkFrameStream<mixed>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <bool mixed>\n+inline frame StackChunkFrameStream<mixed>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <bool mixed>\n+inline address StackChunkFrameStream<mixed>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+intptr_t* StackChunkFrameStream<mixed>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline void StackChunkFrameStream<mixed>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<true>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<false>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <bool mixed>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<mixed>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_S390_INSTANCESTACKCHUNKKLASS_S390_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/s390\/instanceStackChunkKlass_s390.inline.hpp","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -657,0 +657,31 @@\n+class NativePostCallNop: public NativeInstruction {\n+public:\n+  bool check() const { Unimplemented(); return false; }\n+  int displacement() const { Unimplemented(); return 0; }\n+  void patch(jint diff) { Unimplemented(); }\n+  void make_deopt() { Unimplemented(); }\n+};\n+\n+inline NativePostCallNop* nativePostCallNop_at(address address) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+class NativeDeoptInstruction: public NativeInstruction {\n+public:\n+  address instruction_address() const       { Unimplemented(); return NULL; }\n+  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+\n+  void  verify() { Unimplemented(); }\n+\n+  static bool is_deopt_at(address instr) {\n+    Unimplemented();\n+    return false;\n+  }\n+\n+  \/\/ MT-safe patching\n+  static void insert(address code_pos) {\n+    Unimplemented();\n+  }\n+};\n+\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    return location(base_reg->next(slot_idx));\n+    return location(base_reg->next(slot_idx), (intptr_t*) NULL);\n","filename":"src\/hotspot\/cpu\/s390\/registerMap_s390.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2452,2 +2452,2 @@\n-void StubGenerator_generate(CodeBuffer* code, bool all) {\n-  StubGenerator g(code, all);\n+void StubGenerator_generate(CodeBuffer* code, int phase) {\n+  StubGenerator g(code, phase);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -485,0 +485,5 @@\n+address TemplateInterpreterGenerator::generate_Continuation_doYield_entry(void) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  address pc = *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET);\n+  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n@@ -410,1 +410,1 @@\n-  *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET) = pc;\n+  *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n","filename":"src\/hotspot\/cpu\/x86\/continuation_x86.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -392,0 +392,4 @@\n+inline int frame::sender_sp_ret_address_offset() {\n+  return frame::sender_sp_offset - frame::return_addr_offset;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_CONTINUATION_ZERO_INLINE_HPP\n+#define CPU_ZERO_CONTINUATION_ZERO_INLINE_HPP\n+\n+#include \"oops\/instanceStackChunkKlass.inline.hpp\"\n+#include \"runtime\/frame.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+\n+\/\/ TODO: Implement\n+const int ContinuationHelper::frame_metadata = 0;\n+const int ContinuationHelper::align_wiggle = 0;\n+\n+#ifdef ASSERT\n+bool Frame::assert_frame_laid_out(frame f) {\n+  Unimplemented();\n+  return false;\n+}\n+#endif\n+\n+inline intptr_t** Frame::callee_link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind>\n+static inline intptr_t* real_fp(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind> \/\/ TODO: maybe do the same CRTP trick with Interpreted and Compiled as with hframe\n+static inline intptr_t** link_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address* Interpreted::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool relative>\n+void Interpreted::patch_sender_sp(frame& f, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+inline address* Frame::return_pc_address(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline address Frame::real_pc(const frame& f) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline void Frame::patch_pc(const frame& f, address pc) {\n+  Unimplemented();\n+}\n+\n+inline intptr_t* Interpreted::frame_top(const frame& f, InterpreterOopMap* mask) { \/\/ inclusive; this will be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool relative>\n+inline intptr_t* Interpreted::frame_bottom(const frame& f) { \/\/ exclusive; this will not be copied with the frame\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline intptr_t* Interpreted::frame_top(const frame& f, int callee_argsize, bool callee_interpreted) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template<typename FKind, typename RegisterMapT>\n+inline void ContinuationHelper::update_register_map(RegisterMapT* map, const frame& f) {\n+  Unimplemented();\n+}\n+\n+template<typename RegisterMapT>\n+inline void ContinuationHelper::update_register_map_with_callee(RegisterMapT* map, const frame& f) {\n+  Unimplemented();\n+}\n+\n+inline void ContinuationHelper::push_pd(const frame& f) {\n+  Unimplemented();\n+}\n+\n+\/\/ creates the yield stub frame faster than JavaThread::last_frame\n+inline frame ContinuationHelper::last_frame(JavaThread* thread) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+frame ContinuationEntry::to_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+void ContinuationEntry::update_register_map(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n+  Unimplemented();\n+}\n+\n+void ContinuationHelper::set_anchor_pd(JavaFrameAnchor* anchor, intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::set_top_frame_metadata_pd(const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Freeze<ConfigT>::align_bottom(intptr_t* bottom, int argsize) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind>\n+inline frame Freeze<ConfigT>::sender(const frame& f) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind> frame Freeze<ConfigT>::new_hframe(frame& f, frame& caller) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::relativize_interpreted_frame_metadata(const frame& f, const frame& hf) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+template <typename FKind, bool bottom>\n+inline void Freeze<ConfigT>::patch_pd(frame& hf, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Freeze<ConfigT>::patch_chunk_pd(intptr_t* vsp, intptr_t* hsp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline frame Thaw<ConfigT>::new_entry_frame() {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind> frame Thaw<ConfigT>::new_frame(const frame& hf, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Thaw<ConfigT>::align(const frame& hf, intptr_t* vsp, frame& caller, bool bottom) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+template<typename FKind, bool bottom>\n+inline void Thaw<ConfigT>::patch_pd(frame& f, const frame& caller) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+intptr_t* Thaw<ConfigT>::push_interpreter_return_frame(intptr_t* sp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <typename ConfigT>\n+void Thaw<ConfigT>::patch_chunk_pd(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline void Thaw<ConfigT>::prefetch_chunk_pd(void* start, int size) {\n+  Unimplemented();\n+}\n+\n+template <typename ConfigT>\n+inline intptr_t* Thaw<ConfigT>::align_chunk(intptr_t* vsp) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+#endif \/\/ CPU_ZERO_CONTINUATION_ZERO_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/zero\/continuation_zero.inline.hpp","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -101,1 +101,6 @@\n-BasicObjectLock* frame::interpreter_frame_monitor_end() const {\n+\/\/ Pointer beyond the \"oldest\/deepest\" BasicObjectLock on stack.\n+template BasicObjectLock* frame::interpreter_frame_monitor_end<true>() const;\n+template BasicObjectLock* frame::interpreter_frame_monitor_end<false>() const;\n+\n+template <bool relative>\n+inline BasicObjectLock* frame::interpreter_frame_monitor_end() const {\n@@ -184,6 +189,2 @@\n-int frame::frame_size(RegisterMap* map) const {\n-#ifdef PRODUCT\n-  ShouldNotCallThis();\n-#endif \/\/ PRODUCT\n-  return 0; \/\/ make javaVFrame::print_value work\n-}\n+template intptr_t* frame::interpreter_frame_tos_at<false>(jint offset) const;\n+template intptr_t* frame::interpreter_frame_tos_at<true >(jint offset) const;\n@@ -191,0 +192,1 @@\n+template <bool relative>\n@@ -386,0 +388,4 @@\n+void frame::describe_top_pd(FrameValues& values) {\n+\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+ const ImmutableOopMap* get_oop_map() const;\n+\n@@ -76,0 +78,8 @@\n+  inline address* sender_pc_addr() const;\n+\n+  template <bool relative = false>\n+  inline intptr_t* interpreter_frame_last_sp() const;\n+\n+  template <typename RegisterMapT>\n+  static void update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr);\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,0 +43,4 @@\n+inline frame::frame(intptr_t* sp) {\n+  Unimplemented();\n+}\n+\n@@ -114,0 +118,1 @@\n+template <bool relative>\n@@ -127,0 +132,1 @@\n+template <bool relative>\n@@ -166,0 +172,60 @@\n+inline const ImmutableOopMap* frame::get_oop_map() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::compiled_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+}\n+\n+inline int frame::interpreted_frame_num_oops(InterpreterOopMap* mask) const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool relative>\n+inline intptr_t* frame::interpreter_frame_last_sp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+inline int frame::sender_sp_ret_address_offset() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <typename RegisterMapT>\n+void frame::update_map_with_saved_link(RegisterMapT* map, intptr_t** link_addr) {\n+  Unimplemented();\n+}\n+\n+inline void frame::set_unextended_sp(intptr_t* value) {\n+  Unimplemented();\n+}\n+\n+inline int frame::offset_unextended_sp() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void frame::set_offset_unextended_sp(int value) {\n+  Unimplemented();\n+}\n+\n+inline int frame::frame_size() const {\n+#ifdef PRODUCT\n+  ShouldNotCallThis();\n+#endif \/\/ PRODUCT\n+  return 0; \/\/ make javaVFrame::print_value work\n+}\n+\n+inline address* frame::sender_pc_addr() const {\n+  ShouldNotCallThis();\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/frame_zero.inline.hpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_ZERO_INSTANCESTACKCHUNKKLASS_ZERO_INLINE_HPP\n+#define CPU_ZERO_INSTANCESTACKCHUNKKLASS_ZERO_INLINE_HPP\n+\n+#include \"interpreter\/oopMapCache.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+\n+int InstanceStackChunkKlass::metadata_words() {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+int InstanceStackChunkKlass::align_wiggle()   {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+#ifdef ASSERT\n+template <bool mixed>\n+inline bool StackChunkFrameStream<mixed>::is_in_frame(void* p0) const {\n+  Unimplemented();\n+  return true;\n+}\n+#endif\n+\n+template <bool mixed>\n+inline frame StackChunkFrameStream<mixed>::to_frame() const {\n+  Unimplemented();\n+  return frame();\n+}\n+\n+template <bool mixed>\n+inline address StackChunkFrameStream<mixed>::get_pc() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::fp() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::derelativize(int offset) const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline intptr_t* StackChunkFrameStream<mixed>::unextended_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+intptr_t* StackChunkFrameStream<mixed>::next_sp_for_interpreter_frame() const {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+template <bool mixed>\n+inline void StackChunkFrameStream<mixed>::next_for_interpreter_frame() {\n+  Unimplemented();\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_size() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_stack_argsize() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+template <bool mixed>\n+inline int StackChunkFrameStream<mixed>::interpreter_frame_num_oops() const {\n+  Unimplemented();\n+  return 0;\n+}\n+\n+inline void stackChunkOopDesc::relativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+inline void stackChunkOopDesc::derelativize_frame_pd(frame& fr) const {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<true>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template<>\n+template<>\n+inline void StackChunkFrameStream<false>::update_reg_map_pd(RegisterMap* map) {\n+  Unimplemented();\n+}\n+\n+template <bool mixed>\n+template <typename RegisterMapT>\n+inline void StackChunkFrameStream<mixed>::update_reg_map_pd(RegisterMapT* map) {}\n+\n+\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+class SmallRegisterMap {\n+public:\n+  static constexpr SmallRegisterMap* instance = nullptr;\n+private:\n+  static void assert_is_rfp(VMReg r) PRODUCT_RETURN\n+                                     DEBUG_ONLY({ Unimplemented(); })\n+public:\n+  \/\/ as_RegisterMap is used when we didn't want to templatize and abstract over RegisterMap type to support SmallRegisterMap\n+  \/\/ Consider enhancing SmallRegisterMap to support those cases\n+  const RegisterMap* as_RegisterMap() const { return nullptr; }\n+  RegisterMap* as_RegisterMap() { return nullptr; }\n+\n+  RegisterMap* copy_to_RegisterMap(RegisterMap* map, intptr_t* sp) const {\n+    Unimplemented();\n+    return map;\n+  }\n+\n+  SmallRegisterMap() {}\n+\n+  SmallRegisterMap(const RegisterMap* map) {\n+    Unimplemented();\n+  }\n+\n+  inline address location(VMReg reg, intptr_t* sp) const {\n+    Unimplemented();\n+    return NULL;\n+  }\n+\n+  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+\n+  JavaThread* thread() const {\n+  #ifndef ASSERT\n+    guarantee (false, \"\");\n+  #endif\n+    return nullptr;\n+  }\n+\n+  bool update_map()    const { return false; }\n+  bool walk_cont()     const { return false; }\n+  bool include_argument_oops() const { return false; }\n+  void set_include_argument_oops(bool f)  {}\n+  bool in_cont()       const { return false; }\n+  stackChunkHandle stack_chunk() const { return stackChunkHandle(); }\n+\n+#ifdef ASSERT\n+  bool should_skip_missing() const  { return false; }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n+    Unimplemented();\n+    return NULL;\n+  }\n+  void print() const { print_on(tty); }\n+  void print_on(outputStream* st) const { st->print_cr(\"Small register map\"); }\n+#endif\n+};\n+\n+#endif \/\/ CPU_ZERO_INSTANCESTACKCHUNKKLASS_ZERO_INLINE_HPP\n","filename":"src\/hotspot\/cpu\/zero\/instanceStackChunkKlass_zero.inline.hpp","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -214,0 +214,31 @@\n+class NativePostCallNop: public NativeInstruction {\n+public:\n+  bool check() const { Unimplemented(); return false; }\n+  int displacement() const { Unimplemented(); return 0; }\n+  void patch(jint diff) { Unimplemented(); }\n+  void make_deopt() { Unimplemented(); }\n+};\n+\n+inline NativePostCallNop* nativePostCallNop_at(address address) {\n+  Unimplemented();\n+  return NULL;\n+}\n+\n+class NativeDeoptInstruction: public NativeInstruction {\n+public:\n+  address instruction_address() const       { Unimplemented(); return NULL; }\n+  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+\n+  void  verify() { Unimplemented(); }\n+\n+  static bool is_deopt_at(address instr) {\n+    Unimplemented();\n+    return false;\n+  }\n+\n+  \/\/ MT-safe patching\n+  static void insert(address code_pos) {\n+    Unimplemented();\n+  }\n+};\n+\n","filename":"src\/hotspot\/cpu\/zero\/nativeInst_zero.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    return location(base_reg->next(slot_idx));\n+    return location(base_reg->next(slot_idx), (intptr_t*) NULL);\n","filename":"src\/hotspot\/cpu\/zero\/registerMap_zero.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -309,2 +309,2 @@\n-void StubGenerator_generate(CodeBuffer* code, bool all) {\n-  StubGenerator g(code, all);\n+void StubGenerator_generate(CodeBuffer* code, int phase) {\n+  StubGenerator g(code, phase);\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,2 +125,1 @@\n-        \/\/ Don't do this on SPARC float registers as they can be individually addressed\n-        if (!vmReg->is_stack() SPARC_ONLY(&& !vmReg->is_FloatRegister())) {\n+        if (!vmReg->is_stack()) {\n","filename":"src\/hotspot\/share\/compiler\/oopMap.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-#include \"oops\/method.hpp\"\n@@ -61,0 +60,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -787,0 +787,1 @@\n+#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n@@ -788,0 +789,3 @@\n+#else\n+    Unimplemented();\n+#endif\n@@ -807,0 +811,1 @@\n+#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n@@ -808,0 +813,4 @@\n+#else\n+      Unimplemented();\n+      _top = 0;\n+#endif\n@@ -815,0 +824,1 @@\n+#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n@@ -816,0 +826,4 @@\n+#else\n+        Unimplemented();\n+        _next = 0;\n+#endif\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"code\/codeCache.hpp\"\n+#include \"code\/codeCache.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n@@ -107,0 +108,4 @@\n+#else\n+  Unimplemented();\n+  HeapWord* start = NULL;\n+#endif\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,2 +79,0 @@\n-#define SENDER_SP_RET_ADDRESS_OFFSET (frame::sender_sp_offset - frame::return_addr_offset)\n-\n@@ -659,1 +657,1 @@\n-  address pc = *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET);\n+  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n@@ -1090,1 +1088,1 @@\n-        assert (*(address*)(chunk->sp_address() - SENDER_SP_RET_ADDRESS_OFFSET) == chunk->pc(), \"chunk->sp_address() - SENDER_SP_RET_ADDRESS_OFFSET: %p *(address*)(chunk->sp_address() - SENDER_SP_RET_ADDRESS_OFFSET): %p chunk->pc(): %p\", chunk->sp_address() - SENDER_SP_RET_ADDRESS_OFFSET, *(address*)(chunk->sp_address() - SENDER_SP_RET_ADDRESS_OFFSET), chunk->pc());\n+        assert (*(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"chunk->sp_address() - frame::sender_sp_ret_address_offset(): %p *(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()): %p chunk->pc(): %p\", chunk->sp_address() - frame::sender_sp_ret_address_offset(), *(address*)(chunk->sp_address() - frame::sender_sp_ret_address_offset()), chunk->pc());\n@@ -1102,1 +1100,1 @@\n-        assert (*(address*)(bottom_sp - SENDER_SP_RET_ADDRESS_OFFSET) == StubRoutines::cont_returnBarrier(), \"\");\n+        assert (*(address*)(bottom_sp - frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(), \"\");\n@@ -1172,1 +1170,1 @@\n-    assert (empty || *(address*)(orig_chunk_sp - SENDER_SP_RET_ADDRESS_OFFSET) == chunk->pc(), \"corig_chunk_sp - SENDER_SP_RET_ADDRESS_OFFSET: %p *(address*)(orig_chunk_sp - SENDER_SP_RET_ADDRESS_OFFSET): %p chunk->pc(): %p\", orig_chunk_sp - SENDER_SP_RET_ADDRESS_OFFSET, *(address*)(orig_chunk_sp - SENDER_SP_RET_ADDRESS_OFFSET), chunk->pc());\n+    assert (empty || *(address*)(orig_chunk_sp - frame::sender_sp_ret_address_offset()) == chunk->pc(), \"corig_chunk_sp - frame::sender_sp_ret_address_offset(): %p *(address*)(orig_chunk_sp - SENDER_SP_RET_ADDRESS_OFFSET): %p chunk->pc(): %p\", orig_chunk_sp - frame::sender_sp_ret_address_offset(), *(address*)(orig_chunk_sp - frame::sender_sp_ret_address_offset()), chunk->pc());\n@@ -1181,3 +1179,3 @@\n-    log_develop_trace(jvmcont)(\"freeze_fast patching return address at: \" INTPTR_FORMAT \" to: \" INTPTR_FORMAT, p2i(chunk_bottom_sp - SENDER_SP_RET_ADDRESS_OFFSET), p2i(chunk->pc()));\n-    assert (empty || *(address*)(chunk_bottom_sp - SENDER_SP_RET_ADDRESS_OFFSET) == StubRoutines::cont_returnBarrier(), \"\");\n-    *(address*)(chunk_bottom_sp - SENDER_SP_RET_ADDRESS_OFFSET) = chunk->pc();\n+    log_develop_trace(jvmcont)(\"freeze_fast patching return address at: \" INTPTR_FORMAT \" to: \" INTPTR_FORMAT, p2i(chunk_bottom_sp - frame::sender_sp_ret_address_offset()), p2i(chunk->pc()));\n+    assert (empty || *(address*)(chunk_bottom_sp - frame::sender_sp_ret_address_offset()) == StubRoutines::cont_returnBarrier(), \"\");\n+    *(address*)(chunk_bottom_sp - frame::sender_sp_ret_address_offset()) = chunk->pc();\n@@ -1188,1 +1186,1 @@\n-    chunk->set_pc(*(address*)(top - SENDER_SP_RET_ADDRESS_OFFSET));\n+    chunk->set_pc(*(address*)(top - frame::sender_sp_ret_address_offset()));\n@@ -1289,0 +1287,1 @@\n+#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n@@ -1290,0 +1289,3 @@\n+#else\n+    Unimplemented();\n+#endif\n@@ -1548,0 +1550,1 @@\n+#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n@@ -1553,0 +1556,3 @@\n+#else\n+    Unimplemented();\n+#endif\n@@ -2004,0 +2010,1 @@\n+#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n@@ -2005,0 +2012,3 @@\n+#else\n+    Unimplemented();\n+#endif\n@@ -2363,1 +2373,1 @@\n-        address top_pc = *(address*)(hsp + size - SENDER_SP_RET_ADDRESS_OFFSET);\n+        address top_pc = *(address*)(hsp + size - frame::sender_sp_ret_address_offset());\n@@ -2394,1 +2404,1 @@\n-    DEBUG_ONLY(address pc = *(address*)(bottom_sp - SENDER_SP_RET_ADDRESS_OFFSET);)\n+    DEBUG_ONLY(address pc = *(address*)(bottom_sp - frame::sender_sp_ret_address_offset());)\n@@ -2437,2 +2447,2 @@\n-    *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET) = pc;\n-    log_develop_trace(jvmcont)(\"thaw_fast is_last: %d sp: \" INTPTR_FORMAT \" patching pc at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, is_last, p2i(sp), p2i(sp - SENDER_SP_RET_ADDRESS_OFFSET), p2i(pc));\n+    *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n+    log_develop_trace(jvmcont)(\"thaw_fast is_last: %d sp: \" INTPTR_FORMAT \" patching pc at \" INTPTR_FORMAT \" to \" INTPTR_FORMAT, is_last, p2i(sp), p2i(sp - frame::sender_sp_ret_address_offset()), p2i(pc));\n@@ -2502,1 +2512,1 @@\n-      assert (f.pc() == *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET), \"\");\n+      assert (f.pc() == *(address*)(sp - frame::sender_sp_ret_address_offset()), \"\");\n@@ -2829,1 +2839,1 @@\n-    *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET) = pc;\n+    *(address*)(sp - frame::sender_sp_ret_address_offset()) = pc;\n@@ -2896,1 +2906,1 @@\n-  address pc0 = *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET);\n+  address pc0 = *(address*)(sp - frame::sender_sp_ret_address_offset());\n@@ -3675,1 +3685,1 @@\n-  address pc = *(address*)(sp - SENDER_SP_RET_ADDRESS_OFFSET);\n+  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":28,"deletions":18,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -126,0 +126,2 @@\n+  static int sender_sp_ret_address_offset();\n+\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}