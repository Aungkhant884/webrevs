{"files":[{"patch":"@@ -1,319 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_AOT_AOTCOMPILEDMETHOD_HPP\n-#define SHARE_AOT_AOTCOMPILEDMETHOD_HPP\n-\n-#include \"code\/codeCache.hpp\"\n-#include \"code\/compiledIC.hpp\"\n-#include \"code\/compiledMethod.hpp\"\n-#include \"code\/pcDesc.hpp\"\n-#include \"code\/relocInfo.hpp\"\n-\n-class AOTCodeHeap;\n-\n-class aot_metadata {\n-private:\n-  int _size;\n-  int _code_size;\n-  int _entry;\n-  int _verified_entry;\n-  int _exception_handler_offset;\n-  int _deopt_handler_offset;\n-  int _deopt_mh_handler_offset;\n-  int _stubs_offset;\n-  int _frame_size;\n-  \/\/ location in frame (offset for sp) that deopt can store the original\n-  \/\/ pc during a deopt.\n-  int _orig_pc_offset;\n-  int _unsafe_access;\n-\n-  int _pc_desc_begin;\n-  int _scopes_begin;\n-  int _reloc_begin;\n-  int _exception_table_begin;\n-  int _nul_chk_table_begin;\n-  int _oopmap_begin;\n-  address at_offset(size_t offset) const { return ((address) this) + offset; }\n-public:\n-  int code_size() const { return _code_size; }\n-  int frame_size() const { return _frame_size \/ HeapWordSize; }\n-  PcDesc *scopes_pcs_begin() const { return (PcDesc *) at_offset(_pc_desc_begin); }\n-  PcDesc *scopes_pcs_end() const { return (PcDesc *) at_offset(_scopes_begin); }\n-  address scopes_data_begin() const { return at_offset(_scopes_begin); }\n-  address scopes_data_end() const { return at_offset(_reloc_begin); }\n-  relocInfo* relocation_begin() const { return (relocInfo*) at_offset(_reloc_begin); }\n-  relocInfo* relocation_end() const { return (relocInfo*) at_offset(_exception_table_begin); }\n-  address handler_table_begin   () const { return at_offset(_exception_table_begin); }\n-  address handler_table_end() const { return at_offset(_nul_chk_table_begin); }\n-\n-  address nul_chk_table_begin() const { return at_offset(_nul_chk_table_begin); }\n-  address nul_chk_table_end() const { return at_offset(_oopmap_begin); }\n-\n-  ImmutableOopMapSet* oopmap_set() const { return (ImmutableOopMapSet*) at_offset(_oopmap_begin); }\n-\n-  address consts_begin() const { return at_offset(_size); }\n-  address consts_end() const { return at_offset(_size); }\n-  int stub_offset() const { return _stubs_offset; }\n-  int entry_offset() const { return _entry; }\n-  int verified_entry_offset() const { return _verified_entry; }\n-  int exception_handler_offset() const { return _exception_handler_offset; }\n-  int deopt_handler_offset() const { return _deopt_handler_offset; }\n-  int deopt_mh_handler_offset() const { return _deopt_mh_handler_offset; }\n-  int orig_pc_offset() const { return _orig_pc_offset; }\n-\n-  int handler_table_size() const { return handler_table_end() - handler_table_begin(); }\n-  int nul_chk_table_size() const { return nul_chk_table_end() - nul_chk_table_begin(); }\n-  bool has_unsafe_access() const { return _unsafe_access != 0; }\n-\n-};\n-\n-\/*\n- * Use this for AOTCompiledMethods since a lot of the fields in CodeBlob gets the same\n- * value when they come from AOT. code_begin == content_begin, etc... *\/\n-class AOTCompiledMethodLayout : public CodeBlobLayout {\n-public:\n-  AOTCompiledMethodLayout(address code_begin, address code_end, address relocation_begin, address relocation_end) :\n-    CodeBlobLayout(\n-        code_begin, \/\/ code_begin\n-        code_end, \/\/ code_end\n-        code_begin, \/\/ content_begin\n-        code_end, \/\/ content_end\n-        code_end, \/\/ data_end\n-        relocation_begin, \/\/ relocation_begin\n-        relocation_end\n-        ) {\n-    }\n-};\n-\n-class AOTCompiledMethod : public CompiledMethod, public CHeapObj<mtCode> {\n-private:\n-  address       _code;\n-  aot_metadata* _meta;\n-  Metadata**    _metadata_got;\n-  jlong*        _state_adr; \/\/ Address of cell to indicate aot method state (in_use or not_entrant)\n-  AOTCodeHeap*  _heap;    \/\/ code heap which has this method\n-  const char*   _name;    \/\/ For stub: \"AOT Stub<name>\" for stub,\n-                          \/\/ For nmethod: \"<u2_size>Ljava\/lang\/ThreadGroup;<u2_size>addUnstarted<u2_size>()V\"\n-  const int _metadata_size; \/\/ size of _metadata_got\n-  const int _aot_id;\n-  const int _method_index;\n-  oop _oop;  \/\/ method()->method_holder()->klass_holder()\n-\n-  bool make_not_entrant_helper(int new_state);\n-\n- public:\n-  using CHeapObj<mtCode>::operator new;\n-  using CHeapObj<mtCode>::operator delete;\n-\n-  int method_index() const { return _method_index; }\n-  void set_oop(oop o) { _oop = o; }\n-\n-  AOTCompiledMethod(address code, Method* method, aot_metadata* meta, address metadata_got, int metadata_size, jlong* state_adr, AOTCodeHeap* heap, const char* name, int method_index, int aot_id) :\n-    CompiledMethod(method, name, compiler_jvmci, \/\/ AOT code is generated by JVMCI compiler\n-        AOTCompiledMethodLayout(code, code + meta->code_size(), (address) meta->relocation_begin(), (address) meta->relocation_end()),\n-        0 \/* frame_complete_offset *\/, meta->frame_size() \/* frame_size *\/, meta->oopmap_set(), false \/* caller_must_gc_arguments *\/,\n-        method != NULL \/* compiled *\/),\n-    _code(code),\n-    _meta(meta),\n-    _metadata_got((Metadata**) metadata_got),\n-    _state_adr(state_adr),\n-    _heap(heap),\n-    _name(name),\n-    _metadata_size(metadata_size),\n-    _aot_id(aot_id),\n-    _method_index(method_index) {\n-\n-    _is_far_code = CodeCache::is_far_target(code) ||\n-                   CodeCache::is_far_target(code + meta->code_size());\n-    _exception_cache = NULL;\n-\n-    _scopes_data_begin = (address) _meta->scopes_data_begin();\n-    _deopt_handler_begin = (address) _code + _meta->deopt_handler_offset();\n-    if (_meta->deopt_mh_handler_offset() != -1) {\n-      _deopt_mh_handler_begin = (address) _code + _meta->deopt_mh_handler_offset();\n-    } else {\n-      _deopt_mh_handler_begin = (address) this;\n-    }\n-\n-    _pc_desc_container.reset_to(scopes_pcs_begin());\n-\n-    \/\/ Mark the AOTCompiledMethod as in_use\n-    *_state_adr = nmethod::in_use;\n-    set_has_unsafe_access(_meta->has_unsafe_access());\n-    _oop = NULL;\n-  }\n-\n-  virtual bool is_aot() const { return true; }\n-  virtual bool is_runtime_stub() const { return is_aot_runtime_stub(); }\n-\n-  virtual bool is_locked_by_vm() const { return false; }\n-\n-  int state() const { return *_state_adr; }\n-\n-  \/\/ Non-virtual for speed\n-  bool _is_alive() const { return state() < unloaded; }\n-\n-  virtual bool is_zombie() const { return state() == zombie; }\n-  virtual bool is_unloaded() const { return state() == unloaded; }\n-  virtual bool is_not_entrant() const { return state() == not_entrant ||\n-                                                 state() == not_used; }\n-  virtual bool is_alive() const { return _is_alive(); }\n-  virtual bool is_in_use() const { return state() == in_use; }\n-\n-  virtual bool is_unloading() { return false; }\n-\n-  address exception_begin() const { return (address) _code + _meta->exception_handler_offset(); }\n-\n-  virtual const char* name() const { return _name; }\n-\n-  virtual int compile_id() const { return _aot_id; }\n-\n-  void print_on(outputStream* st) const;\n-  void print_on(outputStream* st, const char* msg) const;\n-  void print() const;\n-\n-  virtual void print_value_on(outputStream *stream) const;\n-  virtual void print_block_comment(outputStream *stream, address block_begin) const { }\n-  virtual void verify() {}\n-\n-  virtual int comp_level() const { return CompLevel_aot; }\n-  virtual address verified_entry_point() const { return _code + _meta->verified_entry_offset(); }\n-  virtual void log_identity(xmlStream* stream) const;\n-  virtual void log_state_change() const;\n-  virtual bool make_entrant();\n-  virtual bool make_not_entrant() { return make_not_entrant_helper(not_entrant); }\n-  virtual bool make_not_used() { return make_not_entrant_helper(not_used); }\n-  virtual address entry_point() const { return _code + _meta->entry_offset(); }\n-  virtual bool make_zombie() { ShouldNotReachHere(); return false; }\n-  virtual bool is_osr_method() const { return false; }\n-  virtual int osr_entry_bci() const { ShouldNotReachHere(); return -1; }\n-  \/\/ AOT compiled methods do not get into zombie state\n-  virtual bool can_convert_to_zombie() { return false; }\n-\n-  virtual bool is_dependent_on_method(Method* dependee) { return true; }\n-\n-  virtual void clear_inline_caches();\n-\n-  virtual void print_pcs() {}\n-\n-  virtual address scopes_data_end() const { return _meta->scopes_data_end(); }\n-\n-  virtual oop oop_at(int index) const;\n-  virtual Metadata* metadata_at(int index) const;\n-\n-  virtual PcDesc* scopes_pcs_begin() const { return _meta->scopes_pcs_begin(); }\n-  virtual PcDesc* scopes_pcs_end() const { return _meta->scopes_pcs_end(); }\n-\n-  virtual address handler_table_begin() const { return _meta->handler_table_begin(); }\n-  virtual address handler_table_end() const { return _meta->handler_table_end(); }\n-\n-  virtual address nul_chk_table_begin() const { return _meta->nul_chk_table_begin(); }\n-  virtual address nul_chk_table_end() const { return _meta->nul_chk_table_end(); }\n-\n-  virtual address consts_begin() const { return _meta->consts_begin(); }\n-  virtual address consts_end() const { return _meta->consts_end(); }\n-\n-  virtual address stub_begin() const { return code_begin() + _meta->stub_offset(); }\n-  virtual address stub_end() const { return code_end(); }\n-\n-  virtual oop* oop_addr_at(int index) const { ShouldNotReachHere(); return NULL; }\n-  virtual Metadata** metadata_addr_at(int index) const { ShouldNotReachHere(); return NULL; }\n-\n-  virtual void metadata_do(MetadataClosure* f);\n-\n-  int orig_pc_offset() { return _meta->orig_pc_offset(); }\n-  \n-  bool metadata_got_contains(Metadata **p) {\n-    return p >= &_metadata_got[0] && p < &_metadata_got[_metadata_size];\n-  }\n-\n-  Metadata** metadata_begin() const { return &_metadata_got[0] ; }\n-  Metadata** metadata_end()   const { return &_metadata_got[_metadata_size] ; }\n-  const char* compile_kind() const { return \"AOT\"; }\n-\n-  int get_state() const {\n-    return (int) (*_state_adr);\n-  }\n-\n-  \/\/ inlined and non-virtual for AOTCodeHeap::oops_do\n-  void do_oops(OopClosure* f) {\n-    assert(_is_alive(), \"\");\n-    if (_oop != NULL) {\n-      f->do_oop(&_oop);\n-    }\n-#if 0\n-    metadata_oops_do(metadata_begin(), metadata_end(), f);\n-#endif\n-  }\n-\n-  virtual void do_unloading(bool unloading_occurred);\n-\n-protected:\n-  \/\/ AOT compiled methods are not flushed\n-  void flush() {};\n-\n-  NativeCallWrapper* call_wrapper_at(address call) const;\n-  NativeCallWrapper* call_wrapper_before(address return_pc) const;\n-  address call_instruction_address(address pc) const;\n-\n-  CompiledStaticCall* compiledStaticCall_at(Relocation* call_site) const;\n-  CompiledStaticCall* compiledStaticCall_at(address addr) const;\n-  CompiledStaticCall* compiledStaticCall_before(address addr) const;\n-private:\n-  bool is_aot_runtime_stub() const { return _method == NULL; }\n-};\n-\n-class PltNativeCallWrapper: public NativeCallWrapper {\n-private:\n-  NativePltCall* _call;\n-\n-public:\n-  PltNativeCallWrapper(NativePltCall* call) : _call(call) {}\n-\n-  virtual address destination() const { return _call->destination(); }\n-  virtual address instruction_address() const { return _call->instruction_address(); }\n-  virtual address next_instruction_address() const { return _call->next_instruction_address(); }\n-  virtual address return_address() const { return _call->return_address(); }\n-  virtual address get_resolve_call_stub(bool is_optimized) const { return _call->plt_resolve_call(); }\n-  virtual void set_destination_mt_safe(address dest) { _call->set_destination_mt_safe(dest); }\n-  virtual void set_to_interpreted(const methodHandle& method, CompiledICInfo& info);\n-  virtual void verify() const { _call->verify(); }\n-  virtual void verify_resolve_call(address dest) const;\n-\n-  virtual bool is_call_to_interpreted(address dest) const { return (dest == _call->plt_c2i_stub()); }\n-  \/\/ TODO: assume for now that patching of aot code (got cell) is safe.\n-  virtual bool is_safe_for_patching() const { return true; }\n-\n-  virtual NativeInstruction* get_load_instruction(virtual_call_Relocation* r) const;\n-\n-  virtual void *get_data(NativeInstruction* instruction) const {\n-    return (void*)((NativeLoadGot*) instruction)->data();\n-  }\n-\n-  virtual void set_data(NativeInstruction* instruction, intptr_t data) {\n-    ((NativeLoadGot*) instruction)->set_data(data);\n-  }\n-};\n-\n-#endif \/\/ SHARE_AOT_AOTCOMPILEDMETHOD_HPP\n","filename":"src\/hotspot\/share\/aot\/aotCompiledMethod.hpp","additions":0,"deletions":319,"binary":false,"changes":319,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_AOT_COMPILEDIC_AOT_HPP\n-#define SHARE_AOT_COMPILEDIC_AOT_HPP\n-\n-#include \"code\/compiledIC.hpp\"\n-#include \"code\/nativeInst.hpp\"\n-#include \"interpreter\/linkResolver.hpp\"\n-#include \"oops\/compiledICHolder.hpp\"\n-\n-class CompiledPltStaticCall: public CompiledStaticCall {\n-  friend class CompiledIC;\n-  friend class PltNativeCallWrapper;\n-\n-  \/\/ Also used by CompiledIC\n-  void set_to_interpreted(const methodHandle& callee, address entry);\n-\n-  address instruction_address() const { return _call->instruction_address(); }\n-  void set_destination_mt_safe(address dest) { _call->set_destination_mt_safe(dest); }\n-\n-  NativePltCall* _call;\n-\n-  CompiledPltStaticCall(NativePltCall* call) : _call(call) {}\n-\n- public:\n-\n-  inline static CompiledPltStaticCall* before(address return_addr) {\n-    CompiledPltStaticCall* st = new CompiledPltStaticCall(nativePltCall_before(return_addr));\n-    st->verify();\n-    return st;\n-  }\n-\n-  static inline CompiledPltStaticCall* at(address native_call) {\n-    CompiledPltStaticCall* st = new CompiledPltStaticCall(nativePltCall_at(native_call));\n-    st->verify();\n-    return st;\n-  }\n-\n-  address end_of_call() const { return _call->return_address(); }\n-\n-  static inline CompiledPltStaticCall* at(Relocation* call_site) {\n-    return at(call_site->addr());\n-  }\n-\n-  \/\/ Delegation\n-  address destination() const { return _call->destination(); }\n-\n-  virtual bool is_call_to_interpreted() const;\n-\n-  \/\/ Stub support\n-  address find_stub();\n-  static void set_stub_to_clean(static_stub_Relocation* static_stub);\n-\n-  \/\/ Misc.\n-  void print()  PRODUCT_RETURN;\n-  void verify() PRODUCT_RETURN;\n-\n- protected:\n-  virtual address resolve_call_stub() const { return _call->plt_resolve_call(); }\n-  virtual void set_to_far(const methodHandle& callee, address entry) { set_to_compiled(entry); }\n-  virtual const char* name() const { return \"CompiledPltStaticCall\"; }\n-};\n-\n-#endif \/\/ SHARE_AOT_COMPILEDIC_AOT_HPP\n","filename":"src\/hotspot\/share\/aot\/compiledIC_aot.hpp","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -370,2 +370,0 @@\n-compiler\/aot\/fingerprint\/SelfChangedCDS.java\n-compiler\/aot\/verification\/ClassAndLibraryNotMatchTest.java\n@@ -596,26 +594,2 @@\n-## JVMCI\/AOT\/Graal tests. Need to re-review when start fixing support of JVMCI\/Graal.\n-\n-compiler\/aot\/TestHeapBase.java\n-compiler\/aot\/TestHeapBase.java\n-compiler\/aot\/cli\/MultipleAOTLibraryTest.java\n-compiler\/aot\/cli\/MultipleAOTLibraryTest.java\n-compiler\/aot\/cli\/SingleAOTLibraryTest.java\n-compiler\/aot\/cli\/SingleAOTLibraryTest.java\n-compiler\/aot\/cli\/SingleAOTOptionTest.java\n-compiler\/aot\/cli\/SingleAOTOptionTest.java\n-compiler\/aot\/cli\/jaotc\/AtFileTest.java\n-compiler\/aot\/cli\/jaotc\/AtFileTest.java\n-compiler\/aot\/cli\/jaotc\/CompileAbsoluteDirectoryTest.java\n-compiler\/aot\/cli\/jaotc\/CompileAbsoluteDirectoryTest.java\n-compiler\/aot\/cli\/jaotc\/CompileClassTest.java\n-compiler\/aot\/cli\/jaotc\/CompileClassTest.java\n-compiler\/aot\/cli\/jaotc\/CompileClassWithDebugTest.java\n-compiler\/aot\/cli\/jaotc\/CompileClassWithDebugTest.java\n-compiler\/aot\/cli\/jaotc\/CompileDirectoryTest.java\n-compiler\/aot\/cli\/jaotc\/CompileDirectoryTest.java\n-compiler\/aot\/cli\/jaotc\/CompileJarTest.java\n-compiler\/aot\/cli\/jaotc\/CompileJarTest.java\n-compiler\/aot\/cli\/jaotc\/ListOptionTest.java\n-compiler\/aot\/cli\/jaotc\/ListOptionTest.java\n-compiler\/aot\/cli\/jaotc\/ListOptionWrongFileTest.java\n-compiler\/aot\/cli\/jaotc\/ListOptionWrongFileTest.java\n+## JVMCI\/Graal tests. Need to re-review when start fixing support of JVMCI\/Graal.\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-vthread.txt","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"}]}