{"files":[{"patch":"@@ -529,1 +529,2 @@\n-  JavaThread* const _thread;\n+  JavaThread* const _current;  \/\/ Current thread\n+  JavaThread* const _thread;   \/\/ Thread being frozen\/thawed\n@@ -548,1 +549,2 @@\n-  ContMirror(JavaThread* thread, oop cont); \/\/ does not automatically read the continuation object\n+  \/\/ does not automatically read the continuation object\n+  ContMirror(JavaThread* current, JavaThread* thread, oop cont);\n@@ -593,1 +595,1 @@\n-  address last_pc() { return last_nonempty_chunk()->pc(); } \n+  address last_pc() { return last_nonempty_chunk()->pc(); }\n@@ -691,2 +693,2 @@\n-ContMirror::ContMirror(JavaThread* thread, oop cont)\n- : _thread(thread), _entry(thread->last_continuation()), _cont(cont),\n+ContMirror::ContMirror(JavaThread* current, JavaThread* thread, oop cont)\n+ : _current(current), _thread(thread), _entry(thread->last_continuation()), _cont(cont),\n@@ -697,0 +699,2 @@\n+\n+  assert(current == JavaThread::current(), \"should be\");\n@@ -698,1 +702,2 @@\n-  assert (_cont == _entry->cont_oop(), \"mirror: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \" INTPTR_FORMAT, p2i((oopDesc*)_cont), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n+  assert (_cont == _entry->cont_oop(), \"mirror: \" INTPTR_FORMAT \" entry: \" INTPTR_FORMAT \" entry_sp: \"\n+          INTPTR_FORMAT, p2i((oopDesc*)_cont), p2i((oopDesc*)_entry->cont_oop()), p2i(entrySP()));\n@@ -702,1 +707,1 @@\n- : _thread(nullptr), _entry(nullptr), _cont(cont),\n+ : _current(nullptr), _thread(nullptr), _entry(nullptr), _cont(cont),\n@@ -713,1 +718,4 @@\n- : _thread(map->thread()), _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())), _cont(map->stack_chunk()->cont()),\n+ : _current(nullptr),\n+   _thread(map->thread()),\n+   _entry(Continuation::get_continuation_entry_for_continuation(_thread, map->stack_chunk()->cont())),\n+   _cont(map->stack_chunk()->cont()),\n@@ -718,0 +726,1 @@\n+\n@@ -735,1 +744,1 @@\n-  \/\/   if (_tail != nullptr) _tail->print_on(tty);  \n+  \/\/   if (_tail != nullptr) _tail->print_on(tty);\n@@ -942,1 +951,1 @@\n-    return ((sw = StackWatermarkSet::get(_thread, StackWatermarkKind::gc)) != nullptr \n+    return ((sw = StackWatermarkSet::get(_thread, StackWatermarkKind::gc)) != nullptr\n@@ -958,1 +967,1 @@\n-    assert (_last_write == to + size, \"Missed a spot: _last_write: \" INTPTR_FORMAT \" to+size: \" INTPTR_FORMAT \" stack_size: %d _last_write offset: %ld to+size: %ld\", \n+    assert (_last_write == to + size, \"Missed a spot: _last_write: \" INTPTR_FORMAT \" to+size: \" INTPTR_FORMAT \" stack_size: %d _last_write offset: %ld to+size: %ld\",\n@@ -1093,1 +1102,1 @@\n-      \n+\n@@ -1110,1 +1119,1 @@\n-      \n+\n@@ -1128,1 +1137,1 @@\n-      \n+\n@@ -1201,1 +1210,0 @@\n-   assert (_thread->thread_state() == _thread_in_vm, \"\");\n@@ -1216,1 +1224,1 @@\n-    \n+\n@@ -1228,1 +1236,1 @@\n-  \n+\n@@ -1374,1 +1382,1 @@\n-    \n+\n@@ -1434,1 +1442,1 @@\n-    \n+\n@@ -1473,1 +1481,1 @@\n-      \n+\n@@ -1499,1 +1507,1 @@\n-    \n+\n@@ -1522,1 +1530,1 @@\n-    \n+\n@@ -1838,1 +1846,3 @@\n-  assert (!preempt || current->thread_state() == _thread_in_vm || current->thread_state() == _thread_blocked \/*|| current->thread_state() == _thread_in_native*\/, \"thread_state: %d %s\", current->thread_state(), current->thread_state_name());\n+  assert (!preempt || current->thread_state() == _thread_blocked\n+          \/*|| current->thread_state() == _thread_in_native*\/,\n+          \"thread_state: %d %s\", current->thread_state(), current->thread_state_name());\n@@ -1842,1 +1852,3 @@\n-    p2i(current->last_continuation()->entry_sp()), p2i(current->last_continuation()->entry_fp()), p2i(current->last_continuation()->entry_pc()));\n+                             p2i(current->last_continuation()->entry_sp()),\n+                             p2i(current->last_continuation()->entry_fp()),\n+                             p2i(current->last_continuation()->entry_pc()));\n@@ -1858,1 +1870,1 @@\n-  ContMirror cont(current, oopCont);\n+  ContMirror cont(preempt ? JavaThread::current() : current, current, oopCont);\n@@ -1873,1 +1885,1 @@\n-  \n+\n@@ -1875,1 +1887,1 @@\n-    assert (current->thread_state() == _thread_in_vm, \"\");\n+    assert (current->thread_state() == _thread_blocked, \"\");\n@@ -1888,2 +1900,1 @@\n-  \n-    \/\/ if (UNLIKELY(preempt)) cont.set_preempted(true);\n+\n@@ -1899,0 +1910,1 @@\n+  assert(current == JavaThread::current(), \"must be current thread except for preempt\");\n@@ -1965,4 +1977,0 @@\n-  \/\/ if (Thread::current()->is_VM_thread() && thread->thread_state() == _thread_blocked) {\n-  \/\/   log_develop_trace(jvmcont)(\"is_safe_to_preempt: thread blocked\");\n-  \/\/   return false;\n-  \/\/ }\n@@ -2163,1 +2171,1 @@\n-    return    !_barriers \n+    return    !_barriers\n@@ -2180,1 +2188,1 @@\n-    \n+\n@@ -2235,1 +2243,1 @@\n-      \n+\n@@ -2239,1 +2247,1 @@\n-      \n+\n@@ -2370,1 +2378,1 @@\n-    \n+\n@@ -2401,1 +2409,1 @@\n-  \n+\n@@ -2452,1 +2460,1 @@\n-    \n+\n@@ -2464,1 +2472,1 @@\n-    \n+\n@@ -2472,1 +2480,1 @@\n-  \n+\n@@ -2519,1 +2527,1 @@\n-    \n+\n@@ -2652,1 +2660,1 @@\n-    \n+\n@@ -2771,1 +2779,1 @@\n-  ContMirror cont(thread, oopCont);\n+  ContMirror cont(thread, thread, oopCont);\n@@ -3077,1 +3085,1 @@\n-  \n+\n@@ -3096,1 +3104,1 @@\n- \n+\n@@ -3174,0 +3182,1 @@\n+  assert(_current == JavaThread::current(), \"should be current\");\n@@ -3176,1 +3185,1 @@\n-  HeapWord* start = _thread->tlab().allocate(size_in_words);\n+  HeapWord* start = _current->tlab().allocate(size_in_words);\n@@ -3179,10 +3188,0 @@\n-  } else {\n-    assert (_thread == Thread::current(), \"\");\n-    \/\/HandleMark hm(_thread);\n-    Handle conth(_thread, _cont);\n-    \/\/ uint64_t counter = SafepointSynchronize::safepoint_counter();\n-    stackChunkOop result = (stackChunkOop)allocator.allocate();\n-    \/\/if (!SafepointSynchronize::is_same_safepoint(counter)) {\n-      post_safepoint(conth);\n-    \/\/}\n-    return result;\n@@ -3190,0 +3189,6 @@\n+\n+  \/\/HandleMark hm(_current);\n+  Handle conth(_current, _cont);\n+  stackChunkOop result = (stackChunkOop)allocator.allocate();\n+  post_safepoint(conth);\n+  return result;\n@@ -3210,35 +3215,2 @@\n-\n-  class ForceYieldClosure : public HandshakeClosure {\n-    jobject _jcont;\n-    jint _result;\n-\n-    bool can_be_processed_by(Thread* thread) {\n-      return thread->is_Java_thread();\n-    }\n-\n-    void do_thread(Thread* th) {\n-      \/\/ assert (th == Thread::current(), \"\"); -- the handshake can be carried out by a VM thread (see HandshakeState::process_by_vmthread)\n-      assert (th->is_Java_thread(), \"\");\n-      guarantee (Thread::current()->is_Java_thread(), \"Thread: %s\", Thread::current()->name());\n-      JavaThread* thread = (JavaThread*)th;\n-\n-      \/\/ tty->print_cr(\">>> ForceYieldClosure thread\");\n-      \/\/ thread->print_on(tty);\n-      \/\/ if (thread != Thread::current()) {\n-      \/\/   tty->print_cr(\">>> current thread\");\n-      \/\/   Thread::current()->print_on(tty);\n-      \/\/ }\n-\n-      oop oopCont = JNIHandles::resolve_non_null(_jcont);\n-      _result = Continuation::try_force_yield(thread, oopCont);\n-    }\n-\n-  public:\n-    ForceYieldClosure(jobject jcont) : HandshakeClosure(\"ContinuationForceYieldClosure\"), _jcont(jcont), _result(-1) {}\n-    jint result() const { return _result; }\n-  };\n-  ForceYieldClosure fyc(jcont);\n-\n-  \/\/ tty->print_cr(\"TRY_FORCE_YIELD0\");\n-  \/\/ thread->print();\n-  \/\/ tty->print_cr(\"\");\n+  assert(thread == JavaThread::current(), \"should be\");\n+  jint result = -1; \/\/ no continuation (should have enum)\n@@ -3249,1 +3221,6 @@\n-    Handshake::execute(&fyc, target);\n+    \/\/ Suspend the target thread and freeze it.\n+    if (target->java_suspend(thread)) {\n+      oop oopCont = JNIHandles::resolve_non_null(jcont);\n+      result = Continuation::try_force_yield(target, oopCont);\n+      target->java_resume(thread);\n+    }\n@@ -3251,2 +3228,1 @@\n-\n-  return fyc.result();\n+  return result;\n@@ -3256,1 +3232,0 @@\n-\n@@ -3571,1 +3546,1 @@\n-  \n+\n@@ -3583,1 +3558,1 @@\n-  \n+\n@@ -3591,1 +3566,1 @@\n-  \n+\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":75,"deletions":100,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -409,0 +409,1 @@\n+  _caller(nullptr),\n@@ -619,1 +620,1 @@\n-  while (is_suspended()) {\n+  while (is_suspended_or_frozen()) {\n@@ -641,1 +642,1 @@\n-bool HandshakeState::suspend_with_handshake() {\n+bool HandshakeState::suspend_with_handshake(JavaThread* caller) {\n@@ -652,0 +653,3 @@\n+    } else if (is_frozen()) {\n+      log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" already frozen\", p2i(_handshakee));\n+      return false;\n@@ -656,1 +660,1 @@\n-      set_suspended(true);\n+      set_suspended_or_frozen(caller);\n@@ -664,1 +668,1 @@\n-  set_suspended(true);\n+  set_suspended_or_frozen(caller);\n@@ -674,1 +678,2 @@\n-  bool _did_suspend;\n+  JavaThread* _caller;\n+  bool        _did_suspend;\n@@ -676,1 +681,1 @@\n-  SuspendThreadHandshake() : HandshakeClosure(\"SuspendThread\"), _did_suspend(false) {}\n+  SuspendThreadHandshake(JavaThread* caller) : HandshakeClosure(\"SuspendThread\"), _caller(caller), _did_suspend(false) {}\n@@ -679,1 +684,1 @@\n-    _did_suspend = target->handshake_state()->suspend_with_handshake();\n+    _did_suspend = target->handshake_state()->suspend_with_handshake(_caller);\n@@ -684,2 +689,2 @@\n-bool HandshakeState::suspend() {\n-  SuspendThreadHandshake st;\n+bool HandshakeState::suspend(JavaThread* caller) {\n+  SuspendThreadHandshake st(caller);\n@@ -687,1 +692,2 @@\n-  return st.did_suspend();\n+  bool suspended = st.did_suspend();\n+  return suspended;\n@@ -690,2 +696,2 @@\n-bool HandshakeState::resume() {\n-  if (!is_suspended()) {\n+bool HandshakeState::resume(JavaThread* caller) {\n+  if (!is_suspended_or_frozen()) {\n@@ -699,0 +705,6 @@\n+\n+  \/\/ If caller is non-null only resume frozen thread if it's the caller\n+  if (caller_thread() == caller) {\n+    set_caller_thread(nullptr); \/\/ !is_frozen()\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -92,0 +92,3 @@\n+  \/\/ Caller of suspension.  Only the caller can resume the thread.\n+  JavaThread* _caller;\n+\n@@ -170,1 +173,1 @@\n-  bool suspend_with_handshake();\n+  bool suspend_with_handshake(JavaThread* caller);\n@@ -175,1 +178,1 @@\n-  bool is_suspended()                       { return Atomic::load(&_suspended); }\n+  bool is_suspended() const                 { return Atomic::load(&_suspended); }\n@@ -180,2 +183,13 @@\n-  bool suspend();\n-  bool resume();\n+  void set_caller_thread(JavaThread* caller){ return Atomic::store(&_caller, caller); }\n+  JavaThread* caller_thread() const         { return Atomic::load(&_caller); }\n+  bool is_frozen() const                    { return caller_thread() != nullptr; }\n+  bool is_suspended_or_frozen() const       { return is_suspended() || is_frozen(); }\n+\n+  void set_suspended_or_frozen(JavaThread* caller) {\n+    set_suspended(true);\n+    \/\/ if the caller is non-null, this sets frozen as well.\n+    set_caller_thread(caller);\n+  }\n+\n+  bool suspend(JavaThread* caller);\n+  bool resume(JavaThread* caller);\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -116,1 +116,2 @@\n-  assert(thread->thread_state() != _thread_blocked, \"Must not be\");\n+  \/\/ the suspended target is blocked tho\n+  \/\/ assert(thread->thread_state() != _thread_blocked, \"Must not be\");\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1804,1 +1804,1 @@\n-bool JavaThread::java_suspend() {\n+bool JavaThread::java_suspend(JavaThread* caller) {\n@@ -1813,1 +1813,1 @@\n-  return this->handshake_state()->suspend();\n+  return this->handshake_state()->suspend(caller);\n@@ -1816,1 +1816,1 @@\n-bool JavaThread::java_resume() {\n+bool JavaThread::java_resume(JavaThread* caller) {\n@@ -1822,1 +1822,1 @@\n-  return this->handshake_state()->resume();\n+  return this->handshake_state()->resume(caller);\n@@ -2339,1 +2339,1 @@\n-\/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier. \n+\/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier.\n@@ -2345,1 +2345,1 @@\n-    \n+\n@@ -2488,1 +2488,1 @@\n-  \n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1030,1 +1030,1 @@\n-    \n+\n@@ -1032,1 +1032,1 @@\n-    \n+\n@@ -1148,1 +1148,1 @@\n-    \n+\n@@ -1183,2 +1183,2 @@\n-  bool java_suspend(); \/\/ higher-level suspension logic called by the public APIs\n-  bool java_resume();  \/\/ higher-level resume logic called by the public APIs\n+  bool java_suspend(JavaThread* caller = nullptr); \/\/ higher-level suspension logic called by the public APIs\n+  bool java_resume(JavaThread* caller = nullptr);  \/\/ higher-level resume logic called by the public APIs\n@@ -1543,1 +1543,1 @@\n-  \/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier. \n+  \/\/ Rebind JVMTI thread state from carrier to virtual or from virtual to carrier.\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+* @run testng\/othervm -XX:-UseTLAB -Xint Preempt\n@@ -37,2 +38,0 @@\n-\/\/ - Add tests for additional safepoint types\n-\/\/ - Add tests with -XX:-ThreadLocalHandshakes\n","filename":"test\/jdk\/java\/lang\/Continuation\/Preempt.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}