{"files":[{"patch":"@@ -288,0 +288,2 @@\n+  assert(!obj->is_stackChunk(), \"do not archive stack chunks\");\n+\n@@ -303,1 +305,1 @@\n-    obj->copy_disjoint(cast_from_oop<HeapWord*>(archived_oop), len);\n+    Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(obj), cast_from_oop<HeapWord*>(archived_oop), len);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,3 @@\n-  obj->copy_conjoint(destination, size);\n+  Copy::aligned_conjoint_words(obj_addr, destination, size);\n+\n+  \/\/ There is no need to transform stack chunks - marking already did that.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -489,1 +489,1 @@\n-  old->copy_disjoint(obj_ptr, word_sz);\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), obj_ptr, word_sz);\n@@ -530,0 +530,2 @@\n+    ContinuationGCSupport::transform_stack_chunk(obj);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"utilities\/copy.hpp\"\n@@ -246,1 +248,4 @@\n-  o->copy_disjoint(cast_from_oop<HeapWord*>(new_obj), new_obj_size);\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(o), cast_from_oop<HeapWord*>(new_obj), new_obj_size);\n+  \/\/ Parallel GC claims with a release - so other threads might access this object\n+  \/\/ after claiming and they should see the \"completed\" object.\n+  ContinuationGCSupport::transform_stack_chunk(new_obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -740,1 +740,2 @@\n-    old->copy_disjoint(cast_from_oop<HeapWord*>(obj), s);\n+    Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), cast_from_oop<HeapWord*>(obj), s);\n+    ContinuationGCSupport::transform_stack_chunk(obj);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1232,15 +1232,0 @@\n-\n-oop GenCollectedHeap::handle_failed_promotion(Generation* old_gen,\n-                                              oop obj,\n-                                              size_t obj_size) {\n-  guarantee(old_gen == _old_gen, \"We only get here with an old generation\");\n-  assert(obj_size == obj->size(), \"bad obj_size passed in\");\n-  HeapWord* result = NULL;\n-\n-  result = old_gen->expand_and_allocate(obj_size, false);\n-\n-  if (result != NULL) {\n-    obj->copy_disjoint(result, obj_size);\n-  }\n-  return cast_to_oop(result);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -158,2 +158,2 @@\n-oop Generation::promote(oop obj, size_t obj_size) {\n-  assert(obj_size == obj->size(), \"bad obj_size passed in\");\n+oop Generation::promote(oop old, size_t obj_size) {\n+  assert(obj_size == old->size(), \"bad obj_size passed in\");\n@@ -168,6 +168,6 @@\n-  if (result != NULL) {\n-    obj->copy_disjoint(result, obj_size);\n-    return cast_to_oop(result);\n-  } else {\n-    GenCollectedHeap* gch = GenCollectedHeap::heap();\n-    return gch->handle_failed_promotion(this, obj, obj_size);\n+  if (result == NULL) {\n+    \/\/ Promotion of obj into gen failed.  Try to expand and allocate.\n+    result = expand_and_allocate(obj_size, false);\n+    if (result == NULL) {\n+      return NULL;\n+    }\n@@ -175,0 +175,6 @@\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), result, obj_size);\n+  oop obj = cast_to_oop<HeapWord*>(result);\n+\n+  \/\/ Transform object.\n+  ContinuationGCSupport::transform_stack_chunk(obj);\n+  return obj;\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.cpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -557,3 +557,6 @@\n-      cast_to_oop(cur_obj)->copy_conjoint(compaction_top, size);\n-      cast_to_oop(compaction_top)->init_mark();\n-      assert(cast_to_oop(compaction_top)->klass() != NULL, \"should have a class\");\n+      Copy::aligned_conjoint_words(cur_obj, compaction_top, size);\n+      oop new_obj = cast_to_oop(compaction_top);\n+\n+      ContinuationGCSupport::transform_stack_chunk(new_obj);\n+      new_obj->init_mark();\n+      assert(new_obj->klass() != NULL, \"should have a class\");\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/continuationGCSupport.hpp\"\n@@ -843,1 +844,1 @@\n-      p->copy_conjoint(compact_to, size);\n+      Copy::aligned_conjoint_words(compact_from, compact_to, size);\n@@ -845,0 +846,2 @@\n+\n+      ContinuationGCSupport::transform_stack_chunk(new_obj);\n@@ -956,2 +959,2 @@\n-      old_obj->copy_conjoint(heap->get_region(new_start)->bottom(),\n-                             words_size);\n+      Copy::aligned_conjoint_words(r->bottom(), heap->get_region(new_start)->bottom(), words_size);\n+      ContinuationGCSupport::transform_stack_chunk(cast_to_oop<HeapWord*>(r->bottom()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/continuationGCSupport.inline.hpp\"\n@@ -333,1 +334,1 @@\n-  p->copy_disjoint(copy, size);\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n@@ -337,0 +338,2 @@\n+  ContinuationGCSupport::transform_stack_chunk(copy_val);\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  ZOop::from_address(from)->copy_disjoint((HeapWord*)to, bytes_to_words(size));\n+  Copy::aligned_disjoint_words((HeapWord*)from, (HeapWord*)to, bytes_to_words(size));\n@@ -54,1 +54,1 @@\n-    ZOop::from_address(from)->copy_conjoint((HeapWord*)to, bytes_to_words(size));\n+    Copy::aligned_conjoint_words((HeapWord*)from, (HeapWord*)to, bytes_to_words(size));\n","filename":"src\/hotspot\/share\/gc\/z\/zUtils.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-#include \"utilities\/copy.hpp\"\n@@ -87,27 +86,0 @@\n-size_t InstanceStackChunkKlass::copy(oop obj, HeapWord* to_addr, size_t word_size, bool disjoint) {\n-  assert(obj->is_stackChunk(), \"Wrong object type\");\n-\n-  HeapWord* from_addr = cast_from_oop<HeapWord*>(obj);\n-\n-  disjoint ? Copy::aligned_disjoint_words(from_addr, to_addr, word_size)\n-           : Copy::aligned_conjoint_words(from_addr, to_addr, word_size);\n-\n-  \/\/ Build bitmap\n-  stackChunkOop to_chunk = (stackChunkOop) cast_to_oop(to_addr);\n-  if (!to_chunk->has_bitmap()) {\n-    build_bitmap(to_chunk);\n-  } else {\n-    assert(to_chunk->is_gc_mode(), \"Should be set when bitmaps were built\");\n-  }\n-\n-  return word_size;\n-}\n-\n-void InstanceStackChunkKlass::copy_disjoint(oop obj, HeapWord* to, size_t word_size) {\n-  copy(obj, to, word_size, true \/* disjoint *\/);\n-}\n-\n-void InstanceStackChunkKlass::copy_conjoint(oop obj, HeapWord* to, size_t word_size) {\n-  copy(obj, to, word_size, false \/* disjoint *\/);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -143,3 +143,0 @@\n-  virtual void copy_disjoint(oop obj, HeapWord* to, size_t word_size) override;\n-  virtual void copy_conjoint(oop obj, HeapWord* to, size_t word_size) override;\n-\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-#include \"utilities\/copy.hpp\"\n@@ -714,8 +713,0 @@\n-void Klass::copy_disjoint(oop obj, HeapWord* to, size_t word_size) {\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(obj), to, word_size);\n-}\n-\n-void Klass::copy_conjoint(oop obj, HeapWord* to, size_t word_size) {\n-  Copy::aligned_conjoint_words(cast_from_oop<HeapWord*>(obj), to, word_size);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -597,3 +597,0 @@\n-  virtual void copy_disjoint(oop obj, HeapWord* to, size_t word_size);\n-  virtual void copy_conjoint(oop obj, HeapWord* to, size_t word_size);\n-\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"utilities\/copy.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,4 +109,0 @@\n-  \/\/ Copies the object\n-  inline void copy_disjoint(HeapWord* to, size_t word_size);\n-  inline void copy_conjoint(HeapWord* to, size_t word_size);\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"utilities\/copy.hpp\"\n@@ -386,20 +385,0 @@\n-void oopDesc::copy_disjoint(HeapWord* to, size_t word_size) {\n-  assert(word_size == (size_t)size() || size_might_change(), \"\");\n-  int lh = klass()->layout_helper();\n-  if (lh > Klass::_lh_neutral_value && Klass::layout_helper_needs_slow_path(lh)) {\n-    klass()->copy_disjoint(this, to, word_size);\n-  } else {\n-    Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(this), to, word_size);\n-  }\n-}\n-\n-void oopDesc::copy_conjoint(HeapWord* to, size_t word_size) {\n-  assert(word_size == (size_t)size() || size_might_change(), \"\");\n-  int lh = klass()->layout_helper();\n-  if (lh > Klass::_lh_neutral_value && Klass::layout_helper_needs_slow_path(lh)) {\n-    klass()->copy_conjoint(this, to, word_size);\n-  } else {\n-    Copy::aligned_conjoint_words(cast_from_oop<HeapWord*>(this), to, word_size);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"}]}