{"files":[{"patch":"@@ -333,1 +333,5 @@\n-    __ unlock_object(x15, x14, x10, *stub->entry());\n+    if (UseHeavyMonitors) {\n+      __ j(*stub->entry());\n+    } else {\n+      __ unlock_object(x15, x14, x10, *stub->entry());\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2305,30 +2305,34 @@\n-    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-    __ ori(tmp, disp_hdr, markWord::unlocked_value);\n-\n-    \/\/ Initialize the box. (Must happen before we update the object mark!)\n-    __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-    \/\/ Compare object markWord with an unlocked value (tmp) and if\n-    \/\/ equal exchange the stack address of our box with object markWord.\n-    \/\/ On failure disp_hdr contains the possibly locked markWord.\n-    __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64, Assembler::aq,\n-               Assembler::rl, \/*result*\/disp_hdr);\n-    __ mv(flag, zr);\n-    __ beq(disp_hdr, tmp, cont); \/\/ prepare zero flag and goto cont if we won the cas\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-    \/\/ object, will have now locked it will continue at label cont\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if the owner is self by comparing the value in the\n-    \/\/ markWord of object (disp_hdr) with the stack pointer.\n-    __ sub(disp_hdr, disp_hdr, sp);\n-    __ li(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n-    \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto cont,\n-    \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n-    \/\/ recursive lock.\n-    __ andr(tmp\/*==0?*\/, disp_hdr, tmp);\n-    __ sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    __ mv(flag, tmp); \/\/ we can use the value of tmp as the result here\n+    if (!UseHeavyMonitors) {\n+      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+      __ ori(tmp, disp_hdr, markWord::unlocked_value);\n+\n+      \/\/ Initialize the box. (Must happen before we update the object mark!)\n+      __ sd(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+      \/\/ Compare object markWord with an unlocked value (tmp) and if\n+      \/\/ equal exchange the stack address of our box with object markWord.\n+      \/\/ On failure disp_hdr contains the possibly locked markWord.\n+      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/tmp, \/*new value*\/box, Assembler::int64, Assembler::aq,\n+                 Assembler::rl, \/*result*\/disp_hdr);\n+      __ mv(flag, zr);\n+      __ beq(disp_hdr, tmp, cont); \/\/ prepare zero flag and goto cont if we won the cas\n+\n+      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+      \/\/ object, will have now locked it will continue at label cont\n+      \/\/ We did not see an unlocked object so try the fast recursive case.\n+\n+      \/\/ Check if the owner is self by comparing the value in the\n+      \/\/ markWord of object (disp_hdr) with the stack pointer.\n+      __ sub(disp_hdr, disp_hdr, sp);\n+      __ li(tmp, (intptr_t) (~(os::vm_page_size()-1) | (uintptr_t)markWord::lock_mask_in_place));\n+      \/\/ If (mark & lock_mask) == 0 and mark - sp < page_size, we are stack-locking and goto cont,\n+      \/\/ hence we can store 0 as the displaced header in the box, which indicates that it is a\n+      \/\/ recursive lock.\n+      __ andr(tmp\/*==0?*\/, disp_hdr, tmp);\n+      __ sd(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+      __ mv(flag, tmp); \/\/ we can use the value of tmp as the result here\n+    } else {\n+      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow-path\n+    }\n@@ -2381,2 +2385,3 @@\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    __ ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    if (!UseHeavyMonitors) {\n+      \/\/ Find the lock address and load the displaced header from the stack.\n+      __ ld(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n@@ -2384,3 +2389,4 @@\n-    \/\/ If the displaced header is 0, we have a recursive unlock.\n-    __ mv(flag, disp_hdr);\n-    __ beqz(disp_hdr, cont);\n+      \/\/ If the displaced header is 0, we have a recursive unlock.\n+      __ mv(flag, disp_hdr);\n+      __ beqz(disp_hdr, cont);\n+    }\n@@ -2393,7 +2399,11 @@\n-    \/\/ Check if it is still a light weight lock, this is true if we\n-    \/\/ see the stack address of the basicLock in the markWord of the\n-    \/\/ object.\n-\n-    __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64, Assembler::relaxed,\n-               Assembler::rl, \/*result*\/tmp);\n-    __ xorr(flag, box, tmp); \/\/ box == tmp if cas succeeds\n+    if (!UseHeavyMonitors) {\n+      \/\/ Check if it is still a light weight lock, this is true if we\n+      \/\/ see the stack address of the basicLock in the markWord of the\n+      \/\/ object.\n+  \n+      __ cmpxchg(\/*memory address*\/oop, \/*expected value*\/box, \/*new value*\/disp_hdr, Assembler::int64, Assembler::relaxed,\n+                 Assembler::rl, \/*result*\/tmp);\n+      __ xorr(flag, box, tmp); \/\/ box == tmp if cas succeeds\n+    } else {\n+      __ mv(flag, 1); \/\/ Set non-zero flag to indicate 'failure' -> take slow path\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":52,"deletions":42,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1520,6 +1520,13 @@\n-    \/\/ Load (object->mark() | 1) into swap_reg % x10\n-    __ ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n-    __ ori(swap_reg, t0, 1);\n-\n-    \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n-    __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n+    if (!UseHeavyMonitors) {\n+      \/\/ Load (object->mark() | 1) into swap_reg % x10\n+      __ ld(t0, Address(obj_reg, oopDesc::mark_offset_in_bytes()));\n+      __ ori(swap_reg, t0, 1);\n+\n+      \/\/ Save (object->mark() | 1) into BasicLock's displaced header\n+      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n+\n+      \/\/ src -> dest if dest == x10 else x10 <- dest\n+      {\n+        Label here;\n+        __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, lock_done, \/*fallthrough*\/NULL);\n+      }\n@@ -1527,4 +1534,17 @@\n-    \/\/ src -> dest if dest == x10 else x10 <- dest\n-    {\n-      Label here;\n-      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, lock_done, \/*fallthrough*\/NULL);\n+      \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n+      \/\/  1) (mark & 3) == 0, and\n+      \/\/  2) sp <= mark < mark + os::pagesize()\n+      \/\/ These 3 tests can be done by evaluating the following\n+      \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n+      \/\/ assuming both stack pointer and pagesize have their\n+      \/\/ least significant 2 bits clear.\n+      \/\/ NOTE: the oopMark is in swap_reg % 10 as the result of cmpxchg\n+\n+      __ sub(swap_reg, swap_reg, sp);\n+      __ andi(swap_reg, swap_reg, 3 - os::vm_page_size());\n+\n+      \/\/ Save the test result, for recursive case, the result is zero\n+      __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n+      __ bnez(swap_reg, slow_path_lock);\n+    } else {\n+      __ j(slow_path_lock);\n@@ -1533,16 +1553,0 @@\n-    \/\/ Test if the oopMark is an obvious stack pointer, i.e.,\n-    \/\/  1) (mark & 3) == 0, and\n-    \/\/  2) sp <= mark < mark + os::pagesize()\n-    \/\/ These 3 tests can be done by evaluating the following\n-    \/\/ expression: ((mark - sp) & (3 - os::vm_page_size())),\n-    \/\/ assuming both stack pointer and pagesize have their\n-    \/\/ least significant 2 bits clear.\n-    \/\/ NOTE: the oopMark is in swap_reg % 10 as the result of cmpxchg\n-\n-    __ sub(swap_reg, swap_reg, sp);\n-    __ andi(swap_reg, swap_reg, 3 - os::vm_page_size());\n-\n-    \/\/ Save the test result, for recursive case, the result is zero\n-    __ sd(swap_reg, Address(lock_reg, mark_word_offset));\n-    __ bnez(swap_reg, slow_path_lock);\n-\n@@ -1550,1 +1554,0 @@\n-\n@@ -1637,1 +1640,4 @@\n-    \/\/ Simple recursive lock?\n+    if (!UseHeavyMonitors) {\n+      \/\/ Simple recursive lock?\n+      __ ld(t0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n+      __ beqz(t0, done);\n@@ -1639,7 +1645,4 @@\n-    __ ld(t0, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-    __ beqz(t0, done);\n-\n-    \/\/ Must save x10 if if it is live now because cmpxchg must use it\n-    if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n-      save_native_result(masm, ret_type, stack_slots);\n-    }\n+      \/\/ Must save x10 if if it is live now because cmpxchg must use it\n+      if (ret_type != T_FLOAT && ret_type != T_DOUBLE && ret_type != T_VOID) {\n+        save_native_result(masm, ret_type, stack_slots);\n+      }\n@@ -1648,4 +1651,4 @@\n-    \/\/ get address of the stack lock\n-    __ la(x10, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n-    \/\/  get old displaced header\n-    __ ld(old_hdr, Address(x10, 0));\n+      \/\/ get address of the stack lock\n+      __ la(x10, Address(sp, lock_slot_offset * VMRegImpl::stack_slot_size));\n+      \/\/  get old displaced header\n+      __ ld(old_hdr, Address(x10, 0));\n@@ -1653,4 +1656,7 @@\n-    \/\/ Atomic swap old header if oop still contains the stack lock\n-    Label succeed;\n-    __ cmpxchg_obj_header(x10, old_hdr, obj_reg, t0, succeed, &slow_path_unlock);\n-    __ bind(succeed);\n+      \/\/ Atomic swap old header if oop still contains the stack lock\n+      Label succeed;\n+      __ cmpxchg_obj_header(x10, old_hdr, obj_reg, t0, succeed, &slow_path_unlock);\n+      __ bind(succeed);\n+    } else {\n+      __ j(slow_path_unlock);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":49,"deletions":43,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2025,1 +2025,1 @@\n-#if !defined(X86) && !defined(AARCH64) && !defined(PPC64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(PPC64) && !defined(RISCV64)\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -421,1 +421,1 @@\n-#if defined(X86) || defined(AARCH64) || defined(PPC64)\n+#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64)\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\"\n+ * @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\" | os.arch == \"ppc64\" | os.arch == \"ppc64le\" | os.arch == \"riscv64\"\n","filename":"test\/jdk\/java\/util\/concurrent\/ConcurrentHashMap\/MapLoops.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}