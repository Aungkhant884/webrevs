{"files":[{"patch":"@@ -367,1 +367,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -295,1 +295,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-                                                   false \/* is_cae *\/, $res$$Register);   \n+                                                   false \/* is_cae *\/, $res$$Register);\n@@ -197,1 +197,1 @@\n-  ins_pipe(pipe_slow); \n+  ins_pipe(pipe_slow);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shenandoah\/shenandoah_riscv64.ad","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n-    }  \n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/z_riscv64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -418,1 +418,0 @@\n-\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -9696,1 +9696,1 @@\n-         %}    \n+         %}\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -448,1 +448,1 @@\n-    __ minmax_FD_v(as_VectorRegister($dst$$reg),   \n+    __ minmax_FD_v(as_VectorRegister($dst$$reg),\n@@ -1070,1 +1070,1 @@\n-                          true \/* is_double *\/, false \/* is_min *\/); \n+                          true \/* is_double *\/, false \/* is_min *\/);\n@@ -1087,1 +1087,1 @@\n-                          false \/* is_double *\/, true \/* is_min *\/); \n+                          false \/* is_double *\/, true \/* is_min *\/);\n@@ -1102,1 +1102,1 @@\n-                          true \/* is_double *\/, true \/* is_min *\/); \n+                          true \/* is_double *\/, true \/* is_min *\/);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_vext.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n@@ -32,1 +29,0 @@\n-#include \"runtime\/stubCodeGenerator.hpp\"\n@@ -39,75 +35,1 @@\n-#include <sys\/auxv.h>\n-#include <asm\/hwcap.h>\n-\n-#ifndef COMPAT_HWCAP_ISA_I\n-#define COMPAT_HWCAP_ISA_I  (1 << ('I' - 'A'))\n-#endif\n-\n-#ifndef COMPAT_HWCAP_ISA_M\n-#define COMPAT_HWCAP_ISA_M  (1 << ('M' - 'A'))\n-#endif\n-\n-#ifndef COMPAT_HWCAP_ISA_A\n-#define COMPAT_HWCAP_ISA_A  (1 << ('A' - 'A'))\n-#endif\n-\n-#ifndef COMPAT_HWCAP_ISA_F\n-#define COMPAT_HWCAP_ISA_F  (1 << ('F' - 'A'))\n-#endif\n-\n-#ifndef COMPAT_HWCAP_ISA_D\n-#define COMPAT_HWCAP_ISA_D  (1 << ('D' - 'A'))\n-#endif\n-\n-#ifndef COMPAT_HWCAP_ISA_C\n-#define COMPAT_HWCAP_ISA_C  (1 << ('C' - 'A'))\n-#endif\n-\n-#ifndef COMPAT_HWCAP_ISA_V\n-#define COMPAT_HWCAP_ISA_V  (1 << ('V' - 'A'))\n-#endif\n-\n-#ifndef COMPAT_HWCAP_ISA_B\n-#define COMPAT_HWCAP_ISA_B  (1 << ('B' - 'A'))\n-#endif\n-\n-int VM_Version::_initial_vector_length = 0;\n-address VM_Version::_checkvext_fault_pc = NULL;\n-address VM_Version::_checkvext_continuation_pc = NULL;\n-\n-static BufferBlob* stub_blob;\n-static const int stub_size = 550;\n-\n-extern \"C\" {\n-  typedef int (*getPsrInfo_stub_t)();\n-}\n-static getPsrInfo_stub_t getPsrInfo_stub = NULL;\n-\n-\n-class VM_Version_StubGenerator: public StubCodeGenerator {\n- public:\n-\n-  VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}\n-  ~VM_Version_StubGenerator() {}\n-\n-  address generate_getPsrInfo(address* fault_pc, address* continuation_pc) {\n-    StubCodeMark mark(this, \"VM_Version\", \"getPsrInfo_stub\");\n-#   define __ _masm->\n-    address start = __ pc();\n-\n-    __ enter();\n-\n-    __ mv(x10, zr);\n-    \/\/ read vlenb from CSR_VLENB, may sigill\n-    *fault_pc = __ pc();\n-    __ csrr(x10, CSR_VLENB);\n-\n-    *continuation_pc = __ pc();\n-    __ leave();\n-    __ ret();\n-\n-#   undef __\n-\n-    return start;\n-  }\n-};\n+uint32_t VM_Version::_initial_vector_length = 0;\n@@ -184,19 +106,2 @@\n-  if (!FLAG_IS_DEFAULT(UseVExt) && UseVExt) {\n-    \/\/ try to read vector register VLENB, if success, rvv is supported\n-    \/\/ otherwise, csrr will trigger sigill\n-    ResourceMark rm;\n-\n-    stub_blob = BufferBlob::create(\"getPsrInfo_stub\", stub_size);\n-    if (stub_blob == NULL) {\n-      vm_exit_during_initialization(\"Unable to allocate getPsrInfo_stub\");\n-    }\n-\n-    CodeBuffer c(stub_blob);\n-    VM_Version_StubGenerator g(&c);\n-    getPsrInfo_stub = CAST_TO_FN_PTR(getPsrInfo_stub_t,\n-                                     g.generate_getPsrInfo(&VM_Version::_checkvext_fault_pc, &VM_Version::_checkvext_continuation_pc));\n-    _initial_vector_length = getPsrInfo_stub();\n-  }\n-\n-  if (!_initial_vector_length) {\n-    if (UseVExt) {\n+  if (UseVExt) {\n+    if (!(_features & CPU_V)) {\n@@ -205,0 +110,3 @@\n+    } else {\n+      \/\/ read vector length from vector CSR vlenb\n+      _initial_vector_length = get_current_vector_length();\n@@ -206,2 +114,0 @@\n-  } else if (FLAG_IS_DEFAULT(UseVExt)) {\n-    UseVExt = true;\n@@ -262,0 +168,1 @@\n+  get_cpu_info();\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":7,"deletions":100,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -42,3 +42,0 @@\n-  static bool is_checkvext_fault(address pc) {\n-    return pc != NULL && pc == _checkvext_fault_pc;\n-  }\n@@ -46,4 +43,10 @@\n-  static address continuation_for_checkvext_fault(address pc) {\n-    assert(_checkvext_continuation_pc != NULL, \"not initialized\");\n-    return _checkvext_continuation_pc;\n-  }\n+  enum Feature_Flag {\n+#define CPU_FEATURE_FLAGS(decl)               \\\n+    decl(A,            \"A\",            0)     \\\n+    decl(B,            \"B\",            1)     \\\n+    decl(C,            \"C\",            2)     \\\n+    decl(D,            \"D\",            3)     \\\n+    decl(F,            \"F\",            5)     \\\n+    decl(I,            \"I\",            8)     \\\n+    decl(M,            \"M\",           12)     \\\n+    decl(V,            \"V\",           21)\n@@ -51,2 +54,4 @@\n-  static address _checkvext_fault_pc;\n-  static address _checkvext_continuation_pc;\n+#define DECLARE_CPU_FEATURE_FLAG(id, name, bit) CPU_##id = (1 << bit),\n+    CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_FLAG)\n+#undef DECLARE_CPU_FEATURE_FLAG\n+  };\n@@ -55,1 +60,1 @@\n-  static int _initial_vector_length;\n+  static uint32_t _initial_vector_length;\n@@ -57,0 +62,2 @@\n+  static void get_cpu_info();\n+  static uint32_t get_current_vector_length();\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-\n-\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/assembler_linux_riscv.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,6 +205,0 @@\n-    if (sig == SIGILL && VM_Version::is_checkvext_fault(pc)) {\n-      os::Posix::ucontext_set_pc(uc, VM_Version::continuation_for_checkvext_fault(pc));\n-      return true;\n-    }\n-\n-\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -93,1 +93,0 @@\n-\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/thread_linux_riscv.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"asm\/register.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+#include <asm\/hwcap.h>\n+#include <sys\/auxv.h>\n+\n+#ifndef HWCAP_ISA_I\n+#define HWCAP_ISA_I  (1 << ('I' - 'A'))\n+#endif\n+\n+#ifndef HWCAP_ISA_M\n+#define HWCAP_ISA_M  (1 << ('M' - 'A'))\n+#endif\n+\n+#ifndef HWCAP_ISA_A\n+#define HWCAP_ISA_A  (1 << ('A' - 'A'))\n+#endif\n+\n+#ifndef HWCAP_ISA_F\n+#define HWCAP_ISA_F  (1 << ('F' - 'A'))\n+#endif\n+\n+#ifndef HWCAP_ISA_D\n+#define HWCAP_ISA_D  (1 << ('D' - 'A'))\n+#endif\n+\n+#ifndef HWCAP_ISA_C\n+#define HWCAP_ISA_C  (1 << ('C' - 'A'))\n+#endif\n+\n+#ifndef HWCAP_ISA_V\n+#define HWCAP_ISA_V  (1 << ('V' - 'A'))\n+#endif\n+\n+#ifndef HWCAP_ISA_B\n+#define HWCAP_ISA_B  (1 << ('B' - 'A'))\n+#endif\n+\n+#define read_csr(csr)                                           \\\n+({                                                              \\\n+        register unsigned long __v;                             \\\n+        __asm__ __volatile__ (\"csrr %0, %1\"                     \\\n+                              : \"=r\" (__v)                      \\\n+                              : \"i\" (csr)                       \\\n+                              : \"memory\");                      \\\n+        __v;                                                    \\\n+})\n+\n+uint32_t VM_Version::get_current_vector_length() {\n+  assert(_features & CPU_V, \"should not call this\");\n+  return (uint32_t)read_csr(CSR_VLENB);\n+}\n+\n+void VM_Version::get_cpu_info() {\n+\n+  uint64_t auxv = getauxval(AT_HWCAP);\n+\n+  static_assert(CPU_A == HWCAP_ISA_A, \"Flag CPU_A must follow Linux HWCAP\");\n+  static_assert(CPU_B == HWCAP_ISA_B, \"Flag CPU_B must follow Linux HWCAP\");\n+  static_assert(CPU_C == HWCAP_ISA_C, \"Flag CPU_C must follow Linux HWCAP\");\n+  static_assert(CPU_D == HWCAP_ISA_D, \"Flag CPU_D must follow Linux HWCAP\");\n+  static_assert(CPU_F == HWCAP_ISA_F, \"Flag CPU_F must follow Linux HWCAP\");\n+  static_assert(CPU_I == HWCAP_ISA_I, \"Flag CPU_I must follow Linux HWCAP\");\n+  static_assert(CPU_M == HWCAP_ISA_M, \"Flag CPU_M must follow Linux HWCAP\");\n+  static_assert(CPU_V == HWCAP_ISA_V, \"Flag CPU_V must follow Linux HWCAP\");\n+  _features = auxv & (\n+      HWCAP_ISA_A |\n+      HWCAP_ISA_D |\n+      HWCAP_ISA_F |\n+      HWCAP_ISA_I |\n+      HWCAP_ISA_M |\n+      HWCAP_ISA_V);\n+}\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}