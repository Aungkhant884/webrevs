{"files":[{"patch":"@@ -2854,0 +2854,474 @@\n+#ifdef COMPILER2\n+  class MontgomeryMultiplyGenerator : public MacroAssembler {\n+\n+    Register Pa_base, Pb_base, Pn_base, Pm_base, inv, Rlen, Ra, Rb, Rm, Rn,\n+      Pa, Pb, Pn, Pm, Rhi_ab, Rlo_ab, Rhi_mn, Rlo_mn, tmp, tmp1, tmp2, Ri, Rj;\n+\n+    RegSet _toSave;\n+    bool _squaring;\n+\n+  public:\n+    MontgomeryMultiplyGenerator (Assembler *as, bool squaring)\n+      : MacroAssembler(as->code()), _squaring(squaring) {\n+\n+      \/\/ Register allocation\n+\n+      Register reg = c_rarg0;\n+      Pa_base = reg;       \/\/ Argument registers\n+      if (squaring) {\n+        Pb_base = Pa_base;\n+      } else {\n+        Pb_base = ++reg;\n+      }\n+      Pn_base = ++reg;\n+      Rlen= ++reg;\n+      inv = ++reg;\n+      Pm_base = ++reg;\n+\n+                        \/\/ Working registers:\n+      Ra =  ++reg;      \/\/ The current digit of a, b, n, and m.\n+      Rb =  ++reg;\n+      Rm =  ++reg;\n+      Rn =  ++reg;\n+\n+      Pa =  ++reg;      \/\/ Pointers to the current\/next digit of a, b, n, and m.\n+      Pb =  ++reg;\n+      Pm =  ++reg;\n+      Pn =  ++reg;\n+\n+      tmp  =  ++reg;    \/\/ Three registers which form a\n+      tmp1 =  ++reg;    \/\/ triple-precision accumuator.\n+      tmp2 =  ++reg;\n+\n+      Ri =  x6;         \/\/ Inner and outer loop indexes.\n+      Rj =  x7;\n+\n+      Rhi_ab = x28;     \/\/ Product registers: low and high parts\n+      Rlo_ab = x29;     \/\/ of a*b and m*n.\n+      Rhi_mn = x30;\n+      Rlo_mn = x31;\n+\n+      \/\/ x18 and up are callee-saved.\n+      _toSave = RegSet::range(x18, reg) + Pm_base;\n+    }\n+\n+  private:\n+    void save_regs() {\n+      push_reg(_toSave, sp);\n+    }\n+\n+    void restore_regs() {\n+      pop_reg(_toSave, sp);\n+    }\n+\n+    template <typename T>\n+    void unroll_2(Register count, T block) {\n+      Label loop, end, odd;\n+      beqz(count, end);\n+      andi(t0, count, 0x1);\n+      bnez(t0, odd);\n+      align(16);\n+      bind(loop);\n+      (this->*block)();\n+      bind(odd);\n+      (this->*block)();\n+      addi(count, count, -2);\n+      bgtz(count, loop);\n+      bind(end);\n+    }\n+\n+    template <typename T>\n+    void unroll_2(Register count, T block, Register d, Register s, Register tmp) {\n+      Label loop, end, odd;\n+      beqz(count, end);\n+      andi(tmp, count, 0x1);\n+      bnez(tmp, odd);\n+      align(16);\n+      bind(loop);\n+      (this->*block)(d, s, tmp);\n+      bind(odd);\n+      (this->*block)(d, s, tmp);\n+      addi(count, count, -2);\n+      bgtz(count, loop);\n+      bind(end);\n+    }\n+\n+    void pre1(RegisterOrConstant i) {\n+      block_comment(\"pre1\");\n+      \/\/ Pa = Pa_base;\n+      \/\/ Pb = Pb_base + i;\n+      \/\/ Pm = Pm_base;\n+      \/\/ Pn = Pn_base + i;\n+      \/\/ Ra = *Pa;\n+      \/\/ Rb = *Pb;\n+      \/\/ Rm = *Pm;\n+      \/\/ Rn = *Pn;\n+      if (i.is_register()) {\n+        slli(t0, i.as_register(), LogBytesPerWord);\n+      } else {\n+        mv(t0, i.as_constant());\n+        slli(t0, t0, LogBytesPerWord);\n+      }\n+\n+      mv(Pa, Pa_base);\n+      add(Pb, Pb_base, t0);\n+      mv(Pm, Pm_base);\n+      add(Pn, Pn_base, t0);\n+\n+      ld(Ra, Address(Pa));\n+      ld(Rb, Address(Pb));\n+      ld(Rm, Address(Pm));\n+      ld(Rn, Address(Pn));\n+\n+      \/\/ Zero the m*n result.\n+      mv(Rhi_mn, zr);\n+      mv(Rlo_mn, zr);\n+    }\n+\n+    \/\/ The core multiply-accumulate step of a Montgomery\n+    \/\/ multiplication.  The idea is to schedule operations as a\n+    \/\/ pipeline so that instructions with long latencies (loads and\n+    \/\/ multiplies) have time to complete before their results are\n+    \/\/ used.  This most benefits in-order implementations of the\n+    \/\/ architecture but out-of-order ones also benefit.\n+    void step() {\n+      block_comment(\"step\");\n+      \/\/ MACC(Ra, Rb, tmp, tmp1, tmp2);\n+      \/\/ Ra = *++Pa;\n+      \/\/ Rb = *--Pb;\n+      mulhu(Rhi_ab, Ra, Rb);\n+      mul(Rlo_ab, Ra, Rb);\n+      addi(Pa, Pa, wordSize);\n+      ld(Ra, Address(Pa));\n+      addi(Pb, Pb, -wordSize);\n+      ld(Rb, Address(Pb));\n+      acc(Rhi_mn, Rlo_mn, tmp, tmp1, tmp2); \/\/ The pending m*n from the\n+                                            \/\/ previous iteration.\n+      \/\/ MACC(Rm, Rn, tmp, tmp1, tmp2);\n+      \/\/ Rm = *++Pm;\n+      \/\/ Rn = *--Pn;\n+      mulhu(Rhi_mn, Rm, Rn);\n+      mul(Rlo_mn, Rm, Rn);\n+      addi(Pm, Pm, wordSize);\n+      ld(Rm, Address(Pm));\n+      addi(Pn, Pn, -wordSize);\n+      ld(Rn, Address(Pn));\n+      acc(Rhi_ab, Rlo_ab, tmp, tmp1, tmp2);\n+    }\n+\n+    void post1() {\n+      block_comment(\"post1\");\n+\n+      \/\/ MACC(Ra, Rb, tmp, tmp1, tmp2);\n+      \/\/ Ra = *++Pa;\n+      \/\/ Rb = *--Pb;\n+      mulhu(Rhi_ab, Ra, Rb);\n+      mul(Rlo_ab, Ra, Rb);\n+      acc(Rhi_mn, Rlo_mn, tmp, tmp1, tmp2);  \/\/ The pending m*n\n+      acc(Rhi_ab, Rlo_ab, tmp, tmp1, tmp2);\n+\n+      \/\/ *Pm = Rm = tmp * inv;\n+      mul(Rm, tmp, inv);\n+      sd(Rm, Address(Pm));\n+\n+      \/\/ MACC(Rm, Rn, tmp, tmp1, tmp2);\n+      \/\/ tmp = tmp1; tmp1 = tmp2; tmp2 = 0;\n+      mulhu(Rhi_mn, Rm, Rn);\n+\n+#ifndef PRODUCT\n+      \/\/ assert(m[i] * n[0] + tmp == 0, \"broken Montgomery multiply\");\n+      {\n+        mul(Rlo_mn, Rm, Rn);\n+        add(Rlo_mn, tmp, Rlo_mn);\n+        Label ok;\n+        beqz(Rlo_mn, ok);\n+        stop(\"broken Montgomery multiply\");\n+        bind(ok);\n+      }\n+#endif\n+      \/\/ We have very carefully set things up so that\n+      \/\/ m[i]*n[0] + tmp == 0 (mod b), so we don't have to calculate\n+      \/\/ the lower half of Rm * Rn because we know the result already:\n+      \/\/ it must be -tmp.  tmp + (-tmp) must generate a carry iff\n+      \/\/ tmp != 0.  So, rather than do a mul and an cad we just set\n+      \/\/ the carry flag iff tmp is nonzero.\n+      \/\/\n+      \/\/ mul(Rlo_mn, Rm, Rn);\n+      \/\/ cad(zr, tmp, Rlo_mn);\n+      addi(t0, tmp, -1);\n+      sltu(t0, t0, tmp); \/\/ Set carry iff tmp is nonzero\n+      cadc(tmp, tmp1, Rhi_mn, t0);\n+      adc(tmp1, tmp2, zr, t0);\n+      mv(tmp2, zr);\n+    }\n+\n+    void pre2(Register i, Register len) {\n+      block_comment(\"pre2\");\n+      \/\/ Pa = Pa_base + i-len;\n+      \/\/ Pb = Pb_base + len;\n+      \/\/ Pm = Pm_base + i-len;\n+      \/\/ Pn = Pn_base + len;\n+\n+      sub(Rj, i, len);\n+      \/\/ Rj == i-len\n+\n+      \/\/ Ra as temp register\n+      slli(Ra, Rj, LogBytesPerWord);\n+      add(Pa, Pa_base, Ra);\n+      add(Pm, Pm_base, Ra);\n+      slli(Ra, len, LogBytesPerWord);\n+      add(Pb, Pb_base, Ra);\n+      add(Pn, Pn_base, Ra);\n+\n+      \/\/ Ra = *++Pa;\n+      \/\/ Rb = *--Pb;\n+      \/\/ Rm = *++Pm;\n+      \/\/ Rn = *--Pn;\n+      add(Pa, Pa, wordSize);\n+      ld(Ra, Address(Pa));\n+      add(Pb, Pb, -wordSize);\n+      ld(Rb, Address(Pb));\n+      add(Pm, Pm, wordSize);\n+      ld(Rm, Address(Pm));\n+      add(Pn, Pn, -wordSize);\n+      ld(Rn, Address(Pn));\n+\n+      mv(Rhi_mn, zr);\n+      mv(Rlo_mn, zr);\n+    }\n+\n+    void post2(Register i, Register len) {\n+      block_comment(\"post2\");\n+      sub(Rj, i, len);\n+\n+      cad(tmp, tmp, Rlo_mn, t0); \/\/ The pending m*n, low part\n+\n+      \/\/ As soon as we know the least significant digit of our result,\n+      \/\/ store it.\n+      \/\/ Pm_base[i-len] = tmp;\n+      \/\/ Rj as temp register\n+      slli(Rj, Rj, LogBytesPerWord);\n+      add(Rj, Pm_base, Rj);\n+      sd(tmp, Address(Rj));\n+\n+      \/\/ tmp = tmp1; tmp1 = tmp2; tmp2 = 0;\n+      cadc(tmp, tmp1, Rhi_mn, t0); \/\/ The pending m*n, high part\n+      adc(tmp1, tmp2, zr, t0);\n+      mv(tmp2, zr);\n+    }\n+\n+    \/\/ A carry in tmp after Montgomery multiplication means that we\n+    \/\/ should subtract multiples of n from our result in m.  We'll\n+    \/\/ keep doing that until there is no carry.\n+    void normalize(Register len) {\n+      block_comment(\"normalize\");\n+      \/\/ while (tmp)\n+      \/\/   tmp = sub(Pm_base, Pn_base, tmp, len);\n+      Label loop, post, again;\n+      Register cnt = tmp1, i = tmp2; \/\/ Re-use registers; we're done with them now\n+      beqz(tmp, post); {\n+        bind(again); {\n+          mv(i, zr);\n+          mv(cnt, len);\n+          slli(Rn, i, LogBytesPerWord);\n+          add(Rm, Pm_base, Rn);\n+          ld(Rm, Address(Rm));\n+          add(Rn, Pn_base, Rn);\n+          ld(Rn, Address(Rn));\n+          li(t0, 1); \/\/ set carry flag, i.e. no borrow\n+          align(16);\n+          bind(loop); {\n+            \/\/ csbc(Rm, Rm, Rn);\n+            notr(Rn, Rn);\n+            add(Rm, Rm, t0);\n+            add(Rm, Rm, Rn);\n+            sltu(t0, Rm, Rn);\n+            slli(Rn, i, LogBytesPerWord); \/\/ Rn as temp register\n+            add(Rn, Pm_base, Rn);\n+            sd(Rm, Address(Rn));\n+            add(i, i, 1);\n+            slli(Rn, i, LogBytesPerWord);\n+            add(Rm, Pm_base, Rn);\n+            ld(Rm, Address(Rm));\n+            add(Rn, Pn_base, Rn);\n+            ld(Rn, Address(Rn));\n+            sub(cnt, cnt, 1);\n+          } bnez(cnt, loop);\n+          \/\/ sbc(tmp, tmp, zr);\n+          addi(tmp, tmp, -1);\n+          add(tmp, tmp, t0);\n+        } bnez(tmp, again);\n+      } bind(post);\n+    }\n+\n+    \/\/ Move memory at s to d, reversing words.\n+    \/\/    Increments d to end of copied memory\n+    \/\/    Destroys tmp1, tmp2\n+    \/\/    Preserves len\n+    \/\/    Leaves s pointing to the address which was in d at start\n+    void reverse(Register d, Register s, Register len, Register tmp1, Register tmp2) {\n+      assert(tmp1 < x28 && tmp2 < x28, \"register corruption\");\n+\n+      slli(tmp1, len, LogBytesPerWord);\n+      add(s, s, tmp1);\n+      mv(tmp1, len);\n+      unroll_2(tmp1,  &MontgomeryMultiplyGenerator::reverse1, d, s, tmp2);\n+      slli(tmp1, len, LogBytesPerWord);\n+      sub(s, d, tmp1);\n+    }\n+    \/\/ [63...0] -> [31...0][63...32]\n+    void reverse1(Register d, Register s, Register tmp) {\n+      addi(s, s, -wordSize);\n+      ld(tmp, Address(s));\n+      ror_imm(tmp, tmp, 32, t0);\n+      sd(tmp, Address(d));\n+      addi(d, d, wordSize);\n+    }\n+\n+    \/\/ use t0 as carry\n+    void acc(Register Rhi, Register Rlo,\n+             Register tmp, Register tmp1, Register tmp2) {\n+      cad(tmp, tmp, Rlo, t0);\n+      cadc(tmp1, tmp1, Rhi, t0);\n+      adc(tmp2, tmp2, zr, t0);\n+    }\n+\n+  public:\n+    \/**\n+     * Fast Montgomery multiplication.  The derivation of the\n+     * algorithm is in A Cryptographic Library for the Motorola\n+     * DSP56000, Dusse and Kaliski, Proc. EUROCRYPT 90, pp. 230-237.\n+     *\n+     * Arguments:\n+     *\n+     * Inputs for multiplication:\n+     *   c_rarg0   - int array elements a\n+     *   c_rarg1   - int array elements b\n+     *   c_rarg2   - int array elements n (the modulus)\n+     *   c_rarg3   - int length\n+     *   c_rarg4   - int inv\n+     *   c_rarg5   - int array elements m (the result)\n+     *\n+     * Inputs for squaring:\n+     *   c_rarg0   - int array elements a\n+     *   c_rarg1   - int array elements n (the modulus)\n+     *   c_rarg2   - int length\n+     *   c_rarg3   - int inv\n+     *   c_rarg4   - int array elements m (the result)\n+     *\n+     *\/\n+    address generate_multiply() {\n+      Label argh, nothing;\n+      bind(argh);\n+      stop(\"MontgomeryMultiply total_allocation must be <= 8192\");\n+\n+      align(CodeEntryAlignment);\n+      address entry = pc();\n+\n+      beqz(Rlen, nothing);\n+\n+      enter();\n+\n+      \/\/ Make room.\n+      li(Ra, 512);\n+      bgt(Rlen, Ra, argh);\n+      slli(Ra, Rlen, exact_log2(4 * sizeof(jint)));\n+      sub(Ra, sp, Ra);\n+      andi(sp, Ra, -2 * wordSize);\n+\n+      srliw(Rlen, Rlen, 1);  \/\/ length in longwords = len\/2\n+\n+      {\n+        \/\/ Copy input args, reversing as we go.  We use Ra as a\n+        \/\/ temporary variable.\n+        reverse(Ra, Pa_base, Rlen, Ri, Rj);\n+        if (!_squaring)\n+          reverse(Ra, Pb_base, Rlen, Ri, Rj);\n+        reverse(Ra, Pn_base, Rlen, Ri, Rj);\n+      }\n+\n+      \/\/ Push all call-saved registers and also Pm_base which we'll need\n+      \/\/ at the end.\n+      save_regs();\n+\n+#ifndef PRODUCT\n+      \/\/ assert(inv * n[0] == -1UL, \"broken inverse in Montgomery multiply\");\n+      {\n+        ld(Rn, Address(Pn_base));\n+        mul(Rlo_mn, Rn, inv);\n+        li(t0, -1);\n+        Label ok;\n+        beq(Rlo_mn, t0, ok);\n+        stop(\"broken inverse in Montgomery multiply\");\n+        bind(ok);\n+      }\n+#endif\n+\n+      mv(Pm_base, Ra);\n+\n+      mv(tmp, zr);\n+      mv(tmp1, zr);\n+      mv(tmp2, zr);\n+\n+      block_comment(\"for (int i = 0; i < len; i++) {\");\n+      mv(Ri, zr); {\n+        Label loop, end;\n+        bge(Ri, Rlen, end);\n+\n+        bind(loop);\n+        pre1(Ri);\n+\n+        block_comment(\"  for (j = i; j; j--) {\"); {\n+          mv(Rj, Ri);\n+          unroll_2(Rj, &MontgomeryMultiplyGenerator::step);\n+        } block_comment(\"  } \/\/ j\");\n+\n+        post1();\n+        addw(Ri, Ri, 1);\n+        blt(Ri, Rlen, loop);\n+        bind(end);\n+        block_comment(\"} \/\/ i\");\n+      }\n+\n+      block_comment(\"for (int i = len; i < 2*len; i++) {\");\n+      mv(Ri, Rlen); {\n+        Label loop, end;\n+        slli(Rj, Rlen, 1); \/\/ Rj as temp register\n+        bge(Ri, Rj, end);\n+\n+        bind(loop);\n+        pre2(Ri, Rlen);\n+\n+        block_comment(\"  for (j = len*2-i-1; j; j--) {\"); {\n+          slliw(Rj, Rlen, 1);\n+          subw(Rj, Rj, Ri);\n+          subw(Rj, Rj, 1);\n+          unroll_2(Rj, &MontgomeryMultiplyGenerator::step);\n+        } block_comment(\"  } \/\/ j\");\n+\n+        post2(Ri, Rlen);\n+        addw(Ri, Ri, 1);\n+        slli(Rj, Rlen, 1);\n+        blt(Ri, Rj, loop);\n+        bind(end);\n+      }\n+      block_comment(\"} \/\/ i\");\n+\n+\n+      normalize(Rlen);\n+\n+      mv(Ra, Pm_base);  \/\/ Save Pm_base in Ra\n+      restore_regs();  \/\/ Restore caller's Pm_base\n+\n+      \/\/ Copy our result into caller's Pm_base\n+      reverse(Pm_base, Ra, Rlen, Ri, Rj);\n+\n+      leave();\n+      bind(nothing);\n+      ret();\n+\n+      return entry;\n+    }\n+  };\n+#endif \/\/ COMPILER2\n+\n@@ -3036,0 +3510,6 @@\n+\n+    if (UseMontgomeryMultiplyIntrinsic) {\n+      StubCodeMark mark(this, \"StubRoutines\", \"montgomeryMultiply\");\n+      MontgomeryMultiplyGenerator g(_masm, \/*squaring*\/false);\n+      StubRoutines::_montgomeryMultiply = g.generate_multiply();\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":480,"deletions":0,"binary":false,"changes":480,"status":"modified"},{"patch":"@@ -202,0 +202,4 @@\n+\n+  if (FLAG_IS_DEFAULT(UseMontgomeryMultiplyIntrinsic)) {\n+    FLAG_SET_DEFAULT(UseMontgomeryMultiplyIntrinsic, true);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}