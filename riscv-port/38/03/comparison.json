{"files":[{"patch":"@@ -3097,0 +3097,473 @@\n+\n+\/\/ add two unsigned input and output carry\n+void MacroAssembler::cad(Register dst, Register src1, Register src2, Register carry)\n+{\n+  assert_different_registers(dst, carry);\n+  assert_different_registers(dst, src2);\n+  add(dst, src1, src2);\n+  sltu(carry, dst, src2);\n+}\n+\n+\/\/ add two input with carry\n+void MacroAssembler::adc(Register dst, Register src1, Register src2, Register carry)\n+{\n+  assert_different_registers(dst, carry);\n+  add(dst, src1, src2);\n+  add(dst, dst, carry);\n+}\n+\n+\/\/ add two unsigned input with carry and output carry\n+void MacroAssembler::cadc(Register dst, Register src1, Register src2, Register carry)\n+{\n+  assert_different_registers(dst, src2);\n+  adc(dst, src1, src2, carry);\n+  sltu(carry, dst, src2);\n+}\n+\n+\/\/ rotate right with shift bits\n+void MacroAssembler::ror(Register dst, Register src, uint32_t shift, Register tmp)\n+{\n+  assert_different_registers(dst, tmp);\n+  assert_different_registers(src, tmp);\n+  assert(shift <= 64, \"shift amount must be <= 64\");\n+  slli(tmp, src, 64 - shift);\n+  srli(dst, src, shift);\n+  orr(dst, dst, tmp);\n+}\n+\n+void MacroAssembler::add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,\n+                                     Register src1, Register src2, Register carry)\n+{\n+  cad(dest_lo, dest_lo, src1, carry);\n+  add(dest_hi, dest_hi, carry);\n+  cad(dest_lo, dest_lo, src2, carry);\n+  add(final_dest_hi, dest_hi, carry);\n+}\n+\n+\/**\n+ * Multiply 32 bit by 32 bit first loop.\n+ *\/\n+void MacroAssembler::multiply_32_x_32_loop(Register x, Register xstart, Register x_xstart,\n+                                           Register y, Register y_idx, Register z,\n+                                           Register carry, Register product,\n+                                           Register idx, Register kdx)\n+{\n+  \/\/ jlong carry, x[], y[], z[];\n+  \/\/ for (int idx=ystart, kdx=ystart+1+xstart; idx >= 0; idx--, kdx--) {\n+  \/\/     long product = y[idx] * x[xstart] + carry;\n+  \/\/     z[kdx] = (int)product;\n+  \/\/     carry = product >>> 32;\n+  \/\/ }\n+  \/\/ z[xstart] = (int)carry;\n+\n+  Label L_first_loop, L_first_loop_exit;\n+  blez(idx, L_first_loop_exit);\n+\n+  slli(t0, xstart, LogBytesPerInt);\n+  add(t0, x, t0);\n+  lwu(x_xstart, Address(t0, 0));\n+\n+  bind(L_first_loop);\n+  sub(idx, idx, 1);\n+  slli(t0, idx, LogBytesPerInt);\n+  add(t0, y, t0);\n+  lwu(y_idx, Address(t0, 0));\n+  mul(product, x_xstart, y_idx);\n+  add(product, product, carry);\n+  srli(carry, product, 32);\n+  sub(kdx, kdx, 1);\n+  slli(t0, kdx, LogBytesPerInt);\n+  add(t0, z, t0);\n+  sw(product, Address(t0, 0));\n+  bgtz(idx, L_first_loop);\n+\n+  bind(L_first_loop_exit);\n+}\n+\n+\/**\n+ * Multiply 64 bit by 64 bit first loop.\n+ *\/\n+void MacroAssembler::multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,\n+                                           Register y, Register y_idx, Register z,\n+                                           Register carry, Register product,\n+                                           Register idx, Register kdx)\n+{\n+  \/\/\n+  \/\/  jlong carry, x[], y[], z[];\n+  \/\/  for (int idx=ystart, kdx=ystart+1+xstart; idx >= 0; idx--, kdx--) {\n+  \/\/    huge_128 product = y[idx] * x[xstart] + carry;\n+  \/\/    z[kdx] = (jlong)product;\n+  \/\/    carry  = (jlong)(product >>> 64);\n+  \/\/  }\n+  \/\/  z[xstart] = carry;\n+  \/\/\n+\n+  Label L_first_loop, L_first_loop_exit;\n+  Label L_one_x, L_one_y, L_multiply;\n+\n+  sub(xstart, xstart, 1);\n+  bltz(xstart, L_one_x);\n+\n+  slli(t0, xstart, LogBytesPerInt);\n+  add(t0, x, t0);\n+  ld(x_xstart, Address(t0, 0));\n+  ror(x_xstart, x_xstart, 32); \/\/ convert big-endian to little-endian\n+\n+  bind(L_first_loop);\n+  sub(idx, idx, 1);\n+  bltz(idx, L_first_loop_exit);\n+  sub(idx, idx, 1);\n+  bltz(idx, L_one_y);\n+\n+  slli(t0, idx, LogBytesPerInt);\n+  add(t0, y, t0);\n+  ld(y_idx, Address(t0, 0));\n+  ror(y_idx, y_idx, 32); \/\/ convert big-endian to little-endian\n+  bind(L_multiply);\n+\n+  mulhu(t0, x_xstart, y_idx);\n+  mul(product, x_xstart, y_idx);\n+  cad(product, product, carry, t1);\n+  adc(carry, t0, zr, t1);\n+\n+  sub(kdx, kdx, 2);\n+  ror(product, product, 32); \/\/ back to big-endian\n+  slli(t0, kdx, LogBytesPerInt);\n+  add(t0, z, t0);\n+  sd(product, Address(t0, 0));\n+\n+  j(L_first_loop);\n+\n+  bind(L_one_y);\n+  lwu(y_idx, Address(y, 0));\n+  j(L_multiply);\n+\n+  bind(L_one_x);\n+  lwu(x_xstart, Address(x, 0));\n+  j(L_first_loop);\n+\n+  bind(L_first_loop_exit);\n+}\n+\n+\/**\n+ * Multiply 128 bit by 128 bit. Unrolled inner loop.\n+ *\n+ *\/\n+void MacroAssembler::multiply_128_x_128_loop(Register y, Register z,\n+                                             Register carry, Register carry2,\n+                                             Register idx, Register jdx,\n+                                             Register yz_idx1, Register yz_idx2,\n+                                             Register tmp, Register tmp3, Register tmp4,\n+                                             Register tmp6, Register product_hi)\n+{\n+  \/\/   jlong carry, x[], y[], z[];\n+  \/\/   int kdx = xstart+1;\n+  \/\/   for (int idx=ystart-2; idx >= 0; idx -= 2) { \/\/ Third loop\n+  \/\/     huge_128 tmp3 = (y[idx+1] * product_hi) + z[kdx+idx+1] + carry;\n+  \/\/     jlong carry2  = (jlong)(tmp3 >>> 64);\n+  \/\/     huge_128 tmp4 = (y[idx]   * product_hi) + z[kdx+idx] + carry2;\n+  \/\/     carry  = (jlong)(tmp4 >>> 64);\n+  \/\/     z[kdx+idx+1] = (jlong)tmp3;\n+  \/\/     z[kdx+idx] = (jlong)tmp4;\n+  \/\/   }\n+  \/\/   idx += 2;\n+  \/\/   if (idx > 0) {\n+  \/\/     yz_idx1 = (y[idx] * product_hi) + z[kdx+idx] + carry;\n+  \/\/     z[kdx+idx] = (jlong)yz_idx1;\n+  \/\/     carry  = (jlong)(yz_idx1 >>> 64);\n+  \/\/   }\n+  \/\/\n+\n+  Label L_third_loop, L_third_loop_exit, L_post_third_loop_done;\n+\n+  srli(jdx, idx, 2);\n+\n+  bind(L_third_loop);\n+\n+  sub(jdx, jdx, 1);\n+  bltz(jdx, L_third_loop_exit);\n+  sub(idx, idx, 4);\n+\n+  slli(t0, idx, LogBytesPerInt);\n+  add(t0, y, t0);\n+  ld(yz_idx2, Address(t0, 0));\n+  ld(yz_idx1, Address(t0, wordSize));\n+\n+  slli(t0, idx, LogBytesPerInt);\n+  add(tmp6, z, t0);\n+\n+  ror(yz_idx1, yz_idx1, 32); \/\/ convert big-endian to little-endian\n+  ror(yz_idx2, yz_idx2, 32);\n+\n+  ld(t1, Address(tmp6, 0));\n+  ld(t0, Address(tmp6, wordSize));\n+\n+  mul(tmp3, product_hi, yz_idx1); \/\/  yz_idx1 * product_hi -> tmp4:tmp3\n+  mulhu(tmp4, product_hi, yz_idx1);\n+\n+  ror(t0, t0, 32, tmp); \/\/ convert big-endian to little-endian\n+  ror(t1, t1, 32, tmp);\n+\n+  mul(tmp, product_hi, yz_idx2); \/\/  yz_idx2 * product_hi -> carry2:tmp\n+  mulhu(carry2, product_hi, yz_idx2);\n+\n+  cad(tmp3, tmp3, carry, carry);\n+  adc(tmp4, tmp4, zr, carry);\n+  cad(tmp3, tmp3, t0, t0);\n+  cadc(tmp4, tmp4, tmp, t0);\n+  adc(carry, carry2, zr, t0);\n+  cad(tmp4, tmp4, t1, carry2);\n+  adc(carry, carry, zr, carry2);\n+\n+  ror(tmp3, tmp3, 32); \/\/ convert little-endian to big-endian\n+  ror(tmp4, tmp4, 32);\n+  sd(tmp4, Address(tmp6, 0));\n+  sd(tmp3, Address(tmp6, wordSize));\n+\n+  j(L_third_loop);\n+\n+  bind(L_third_loop_exit);\n+\n+  andi(idx, idx, 0x3);\n+  beqz(idx, L_post_third_loop_done);\n+\n+  Label L_check_1;\n+  sub(idx, idx, 2);\n+  bltz(idx, L_check_1);\n+\n+  slli(t0, idx, LogBytesPerInt);\n+  add(t0, y, t0);\n+  ld(yz_idx1, Address(t0, 0));\n+  ror(yz_idx1, yz_idx1, 32);\n+\n+  mul(tmp3, product_hi, yz_idx1); \/\/  yz_idx1 * product_hi -> tmp4:tmp3\n+  mulhu(tmp4, product_hi, yz_idx1);\n+\n+  slli(t0, idx, LogBytesPerInt);\n+  add(t0, z, t0);\n+  ld(yz_idx2, Address(t0, 0));\n+  ror(yz_idx2, yz_idx2, 32, tmp);\n+\n+  add2_with_carry(carry, tmp4, tmp3, carry, yz_idx2, tmp);\n+\n+  ror(tmp3, tmp3, 32, tmp);\n+  sd(tmp3, Address(t0, 0));\n+\n+  bind(L_check_1);\n+\n+  andi(idx, idx, 0x1);\n+  sub(idx, idx, 1);\n+  bltz(idx, L_post_third_loop_done);\n+  slli(t0, idx, LogBytesPerInt);\n+  add(t0, y, t0);\n+  lwu(tmp4, Address(t0, 0));\n+  mul(tmp3, tmp4, product_hi); \/\/  tmp4 * product_hi -> carry2:tmp3\n+  mulhu(carry2, tmp4, product_hi);\n+\n+  slli(t0, idx, LogBytesPerInt);\n+  add(t0, z, t0);\n+  lwu(tmp4, Address(t0, 0));\n+\n+  add2_with_carry(carry2, carry2, tmp3, tmp4, carry, t0);\n+\n+  slli(t0, idx, LogBytesPerInt);\n+  add(t0, z, t0);\n+  sw(tmp3, Address(t0, 0));\n+\n+  slli(t0, carry2, 32);\n+  srli(carry, tmp3, 32);\n+  orr(carry, carry, t0);\n+\n+  bind(L_post_third_loop_done);\n+}\n+\n+\/**\n+ * Code for BigInteger::multiplyToLen() intrinsic.\n+ *\n+ * x10: x\n+ * x11: xlen\n+ * x12: y\n+ * x13: ylen\n+ * x14: z\n+ * x15: zlen\n+ * x16: tmp1\n+ * x17: tmp2\n+ * x7:  tmp3\n+ * x28: tmp4\n+ * x29: tmp5\n+ * x30: tmp6\n+ * x31: tmp7\n+ *\/\n+void MacroAssembler::multiply_to_len(Register x, Register xlen, Register y, Register ylen,\n+                                     Register z, Register zlen,\n+                                     Register tmp1, Register tmp2, Register tmp3, Register tmp4,\n+                                     Register tmp5, Register tmp6, Register product_hi)\n+{\n+  assert_different_registers(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6);\n+\n+  const Register idx = tmp1;\n+  const Register kdx = tmp2;\n+  const Register xstart = tmp3;\n+\n+  const Register y_idx = tmp4;\n+  const Register carry = tmp5;\n+  const Register product = xlen;\n+  const Register x_xstart = zlen; \/\/ reuse register\n+\n+  mv(idx, ylen); \/\/ idx = ylen;\n+  mv(kdx, zlen); \/\/ kdx = xlen+ylen;\n+  mv(carry, zr); \/\/ carry = 0;\n+\n+  Label L_multiply_64_x_64_loop, L_done;\n+\n+  sub(xstart, xlen, 1);\n+  bltz(xstart, L_done);\n+\n+  const Register jdx = tmp1;\n+\n+  \/\/ Check if x and y are both 8-byte aligned.\n+  orr(t0, xlen, ylen);\n+  andi(t0, t0, 0x1);\n+  beqz(t0, L_multiply_64_x_64_loop);\n+\n+  multiply_32_x_32_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);\n+  slli(t0, xstart, LogBytesPerInt);\n+  add(t0, z, t0);\n+  sw(carry, Address(t0, 0));\n+\n+  Label L_second_loop_unaligned;\n+  bind(L_second_loop_unaligned);\n+  mv(carry, zr);\n+  mv(jdx, ylen);\n+  sub(xstart, xstart, 1);\n+  bltz(xstart, L_done);\n+  sub(sp, sp, 2 * wordSize);\n+  sd(z, Address(sp, 0));\n+  sd(zr, Address(sp, wordSize));\n+  slli(t0, xstart, LogBytesPerInt);\n+  add(t0, z, t0);\n+  addi(z, t0, 4);\n+  slli(t0, xstart, LogBytesPerInt);\n+  add(t0, x, t0);\n+  lwu(product, Address(t0, 0));\n+  Label L_third_loop, L_third_loop_exit;\n+\n+  blez(jdx, L_third_loop_exit);\n+\n+  bind(L_third_loop);\n+  sub(jdx, jdx, 1);\n+  slli(t0, jdx, LogBytesPerInt);\n+  add(t0, y, t0);\n+  lwu(t0, Address(t0, 0));\n+  mul(t1, t0, product);\n+  add(t0, t1, carry);\n+  slli(t1, jdx, LogBytesPerInt);\n+  add(tmp6, z, t1);\n+  lwu(t1, Address(tmp6, 0));\n+  add(t0, t0, t1);\n+  sw(t0, Address(tmp6, 0));\n+  srli(carry, t0, 32);\n+  bgtz(jdx, L_third_loop);\n+\n+  bind(L_third_loop_exit);\n+  ld(z, Address(sp, 0));\n+  addi(sp, sp, 2 * wordSize);\n+  slli(t0, xstart, LogBytesPerInt);\n+  add(t0, z, t0);\n+  sw(carry, Address(t0, 0));\n+\n+  j(L_second_loop_unaligned);\n+\n+  bind(L_multiply_64_x_64_loop);\n+  multiply_64_x_64_loop(x, xstart, x_xstart, y, y_idx, z, carry, product, idx, kdx);\n+\n+  Label L_second_loop_aligned;\n+  beqz(kdx, L_second_loop_aligned);\n+\n+  Label L_carry;\n+  sub(kdx, kdx, 1);\n+  beqz(kdx, L_carry);\n+\n+  slli(t0, kdx, LogBytesPerInt);\n+  add(t0, z, t0);\n+  sw(carry, Address(t0, 0));\n+  srli(carry, carry, 32);\n+  sub(kdx, kdx, 1);\n+\n+  bind(L_carry);\n+  slli(t0, kdx, LogBytesPerInt);\n+  add(t0, z, t0);\n+  sw(carry, Address(t0, 0));\n+\n+  \/\/ Second and third (nested) loops.\n+  \/\/\n+  \/\/ for (int i = xstart-1; i >= 0; i--) { \/\/ Second loop\n+  \/\/   carry = 0;\n+  \/\/   for (int jdx=ystart, k=ystart+1+i; jdx >= 0; jdx--, k--) { \/\/ Third loop\n+  \/\/     long product = (y[jdx] & LONG_MASK) * (x[i] & LONG_MASK) +\n+  \/\/                    (z[k] & LONG_MASK) + carry;\n+  \/\/     z[k] = (int)product;\n+  \/\/     carry = product >>> 32;\n+  \/\/   }\n+  \/\/   z[i] = (int)carry;\n+  \/\/ }\n+  \/\/\n+  \/\/ i = xlen, j = tmp1, k = tmp2, carry = tmp5, x[i] = product_hi\n+\n+  bind(L_second_loop_aligned);\n+  mv(carry, zr); \/\/ carry = 0;\n+  mv(jdx, ylen); \/\/ j = ystart+1\n+\n+  sub(xstart, xstart, 1); \/\/ i = xstart-1;\n+  bltz(xstart, L_done);\n+\n+  sub(sp, sp, 4 * wordSize);\n+  sd(z, Address(sp, 0));\n+\n+  Label L_last_x;\n+  slli(t0, xstart, LogBytesPerInt);\n+  add(t0, z, t0);\n+  addi(z, t0, 4);\n+  sub(xstart, xstart, 1); \/\/ i = xstart-1;\n+  bltz(xstart, L_last_x);\n+\n+  slli(t0, xstart, LogBytesPerInt);\n+  add(t0, x, t0);\n+  ld(product_hi, Address(t0, 0));\n+  ror(product_hi, product_hi, 32); \/\/ convert big-endian to little-endian\n+\n+  Label L_third_loop_prologue;\n+  bind(L_third_loop_prologue);\n+\n+  sd(ylen, Address(sp, wordSize));\n+  sd(x, Address(sp, 2 * wordSize));\n+  sd(xstart, Address(sp, 3 * wordSize));\n+  multiply_128_x_128_loop(y, z, carry, x, jdx, ylen, product,\n+                          tmp2, x_xstart, tmp3, tmp4, tmp6, product_hi);\n+  ld(z, Address(sp, 0));\n+  ld(ylen, Address(sp, wordSize));\n+  ld(x, Address(sp, 2 * wordSize));\n+  ld(xlen, Address(sp, 3 * wordSize)); \/\/ copy old xstart -> xlen\n+  addi(sp, sp, 4 * wordSize);\n+\n+  addi(tmp3, xlen, 1);\n+  slli(t0, tmp3, LogBytesPerInt);\n+  add(t0, z, t0);\n+  sw(carry, Address(t0, 0));\n+\n+  sub(tmp3, tmp3, 1);\n+  bltz(tmp3, L_done);\n+\n+  srli(carry, carry, 32);\n+  slli(t0, tmp3, LogBytesPerInt);\n+  add(t0, z, t0);\n+  sw(carry, Address(t0, 0));\n+  j(L_second_loop_aligned);\n+\n+  \/\/ Next infrequent code is moved outside loops.\n+  bind(L_last_x);\n+  lwu(product_hi, Address(x, 0));\n+  j(L_third_loop_prologue);\n+\n+  bind(L_done);\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":473,"deletions":0,"binary":false,"changes":473,"status":"modified"},{"patch":"@@ -652,0 +652,24 @@\n+  void cad(Register dst, Register src1, Register src2, Register carry);\n+  void cadc(Register dst, Register src1, Register src2, Register carry);\n+  void adc(Register dst, Register src1, Register src2, Register carry);\n+  void add2_with_carry(Register final_dest_hi, Register dest_hi, Register dest_lo,\n+                       Register src1, Register src2, Register carry);\n+  void ror(Register dst, Register src, uint32_t imm, Register tmp = t0);\n+  void multiply_32_x_32_loop(Register x, Register xstart, Register x_xstart,\n+                             Register y, Register y_idx, Register z,\n+                             Register carry, Register product,\n+                             Register idx, Register kdx);\n+  void multiply_64_x_64_loop(Register x, Register xstart, Register x_xstart,\n+                             Register y, Register y_idx, Register z,\n+                             Register carry, Register product,\n+                             Register idx, Register kdx);\n+  void multiply_128_x_128_loop(Register y, Register z,\n+                               Register carry, Register carry2,\n+                               Register idx, Register jdx,\n+                               Register yz_idx1, Register yz_idx2,\n+                               Register tmp, Register tmp3, Register tmp4,\n+                               Register tmp6, Register product_hi);\n+  void multiply_to_len(Register x, Register xlen, Register y, Register ylen,\n+                       Register z, Register zlen,\n+                       Register tmp1, Register tmp2, Register tmp3, Register tmp4,\n+                       Register tmp5, Register tmp6, Register product_hi);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2796,0 +2796,73 @@\n+\n+  \/**\n+   *  Arguments:\n+   *\n+   *  Input:\n+   *    c_rarg0   - x address\n+   *    c_rarg1   - x length\n+   *    c_rarg2   - y address\n+   *    c_rarg3   - y length\n+   *    c_rarg4   - z address\n+   *    c_rarg5   - z length\n+   *\/\n+  address generate_multiplyToLen()\n+  {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"multiplyToLen\");\n+    address entry = __ pc();\n+\n+    const Register x     = x10;\n+    const Register xlen  = x11;\n+    const Register y     = x12;\n+    const Register ylen  = x13;\n+    const Register z     = x14;\n+    const Register zlen  = x15;\n+\n+    const Register tmp1  = x16;\n+    const Register tmp2  = x17;\n+    const Register tmp3  = x7;\n+    const Register tmp4  = x28;\n+    const Register tmp5  = x29;\n+    const Register tmp6  = x30;\n+    const Register tmp7  = x31;\n+\n+    BLOCK_COMMENT(\"Entry:\");\n+    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n+    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+    __ ret();\n+\n+    return entry;\n+  }\n+\n+  address generate_squareToLen()\n+  {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"squareToLen\");\n+    address entry = __ pc();\n+\n+    const Register x     = x10;\n+    const Register xlen  = x11;\n+    const Register z     = x12;\n+    const Register zlen  = x13;\n+    const Register y     = x14; \/\/ == x\n+    const Register ylen  = x15; \/\/ == xlen\n+\n+    const Register tmp1  = x16;\n+    const Register tmp2  = x17;\n+    const Register tmp3  = x7;\n+    const Register tmp4  = x28;\n+    const Register tmp5  = x29;\n+    const Register tmp6  = x30;\n+    const Register tmp7  = x31;\n+\n+    BLOCK_COMMENT(\"Entry:\");\n+    __ enter();\n+    __ mv(y, x);\n+    __ mv(ylen, xlen);\n+    __ multiply_to_len(x, xlen, y, ylen, z, zlen, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7);\n+    __ leave();\n+    __ ret();\n+\n+    return entry;\n+  }\n@@ -2972,0 +3045,8 @@\n+\n+    if (UseMultiplyToLenIntrinsic) {\n+      StubRoutines::_multiplyToLen = generate_multiplyToLen();\n+    }\n+\n+    if (UseSquareToLenIntrinsic) {\n+      StubRoutines::_squareToLen = generate_squareToLen();\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -186,0 +186,8 @@\n+\n+  if (FLAG_IS_DEFAULT(UseMultiplyToLenIntrinsic)) {\n+    FLAG_SET_DEFAULT(UseMultiplyToLenIntrinsic, true);\n+  }\n+\n+  if (FLAG_IS_DEFAULT(UseSquareToLenIntrinsic)) {\n+    FLAG_SET_DEFAULT(UseSquareToLenIntrinsic, true);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}