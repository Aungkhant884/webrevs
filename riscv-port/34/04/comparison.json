{"files":[{"patch":"@@ -83,0 +83,5 @@\n+  CHECK_CEXT_AND_COMPRESSIBLE(is_imm_in_range(imm, 6, 0) && Rd != x0) {\n+    c_li(Rd, imm);\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -258,0 +258,1 @@\n+  #include \"assembler_riscv_c.hpp\"\n@@ -382,1 +383,5 @@\n-    emit_int32(0);\n+    CHECK_CEXT() {\n+      emit_int16(0);\n+    } else {\n+      emit_int32(0);\n+    }\n@@ -385,2 +390,2 @@\n-\/\/ Rigster Instruction\n-#define INSN(NAME, op, funct3, funct7)                          \\\n+\/\/ Register Instruction\n+#define INSN(NAME, op, funct3, funct7, C)                       \\\n@@ -388,0 +393,1 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs1, Rs2)                    \\\n@@ -398,28 +404,28 @@\n-  INSN(add,   0b0110011, 0b000, 0b0000000);\n-  INSN(sub,   0b0110011, 0b000, 0b0100000);\n-  INSN(andr,  0b0110011, 0b111, 0b0000000);\n-  INSN(orr,   0b0110011, 0b110, 0b0000000);\n-  INSN(xorr,  0b0110011, 0b100, 0b0000000);\n-  INSN(sll,   0b0110011, 0b001, 0b0000000);\n-  INSN(sra,   0b0110011, 0b101, 0b0100000);\n-  INSN(srl,   0b0110011, 0b101, 0b0000000);\n-  INSN(slt,   0b0110011, 0b010, 0b0000000);\n-  INSN(sltu,  0b0110011, 0b011, 0b0000000);\n-  INSN(addw,  0b0111011, 0b000, 0b0000000);\n-  INSN(subw,  0b0111011, 0b000, 0b0100000);\n-  INSN(sllw,  0b0111011, 0b001, 0b0000000);\n-  INSN(sraw,  0b0111011, 0b101, 0b0100000);\n-  INSN(srlw,  0b0111011, 0b101, 0b0000000);\n-  INSN(mul,   0b0110011, 0b000, 0b0000001);\n-  INSN(mulh,  0b0110011, 0b001, 0b0000001);\n-  INSN(mulhsu,0b0110011, 0b010, 0b0000001);\n-  INSN(mulhu, 0b0110011, 0b011, 0b0000001);\n-  INSN(mulw,  0b0111011, 0b000, 0b0000001);\n-  INSN(div,   0b0110011, 0b100, 0b0000001);\n-  INSN(divu,  0b0110011, 0b101, 0b0000001);\n-  INSN(divw,  0b0111011, 0b100, 0b0000001);\n-  INSN(divuw, 0b0111011, 0b101, 0b0000001);\n-  INSN(rem,   0b0110011, 0b110, 0b0000001);\n-  INSN(remu,  0b0110011, 0b111, 0b0000001);\n-  INSN(remw,  0b0111011, 0b110, 0b0000001);\n-  INSN(remuw, 0b0111011, 0b111, 0b0000001);\n+  INSN(add,   0b0110011, 0b000, 0b0000000, COMPRESSIBLE);\n+  INSN(sub,   0b0110011, 0b000, 0b0100000, COMPRESSIBLE);\n+  INSN(andr,  0b0110011, 0b111, 0b0000000, COMPRESSIBLE);\n+  INSN(orr,   0b0110011, 0b110, 0b0000000, COMPRESSIBLE);\n+  INSN(xorr,  0b0110011, 0b100, 0b0000000, COMPRESSIBLE);\n+  INSN(sll,   0b0110011, 0b001, 0b0000000, NOT_COMPRESSIBLE);\n+  INSN(sra,   0b0110011, 0b101, 0b0100000, NOT_COMPRESSIBLE);\n+  INSN(srl,   0b0110011, 0b101, 0b0000000, NOT_COMPRESSIBLE);\n+  INSN(slt,   0b0110011, 0b010, 0b0000000, NOT_COMPRESSIBLE);\n+  INSN(sltu,  0b0110011, 0b011, 0b0000000, NOT_COMPRESSIBLE);\n+  INSN(addw,  0b0111011, 0b000, 0b0000000, COMPRESSIBLE);\n+  INSN(subw,  0b0111011, 0b000, 0b0100000, COMPRESSIBLE);\n+  INSN(sllw,  0b0111011, 0b001, 0b0000000, NOT_COMPRESSIBLE);\n+  INSN(sraw,  0b0111011, 0b101, 0b0100000, NOT_COMPRESSIBLE);\n+  INSN(srlw,  0b0111011, 0b101, 0b0000000, NOT_COMPRESSIBLE);\n+  INSN(mul,   0b0110011, 0b000, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(mulh,  0b0110011, 0b001, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(mulhsu,0b0110011, 0b010, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(mulhu, 0b0110011, 0b011, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(mulw,  0b0111011, 0b000, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(div,   0b0110011, 0b100, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(divu,  0b0110011, 0b101, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(divw,  0b0111011, 0b100, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(divuw, 0b0111011, 0b101, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(rem,   0b0110011, 0b110, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(remu,  0b0110011, 0b111, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(remw,  0b0111011, 0b110, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(remuw, 0b0111011, 0b111, 0b0000001, NOT_COMPRESSIBLE);\n@@ -437,1 +443,1 @@\n-#define INSN(NAME, op, funct3)                                                                     \\\n+#define INSN(NAME, op, funct3, C)                                                                  \\\n@@ -439,1 +445,0 @@\n-    unsigned insn = 0;                                                                             \\\n@@ -441,0 +446,2 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs, offset)                                                     \\\n+    unsigned insn = 0;                                                                             \\\n@@ -494,7 +501,7 @@\n-  INSN(lb,  0b0000011, 0b000);\n-  INSN(lbu, 0b0000011, 0b100);\n-  INSN(ld,  0b0000011, 0b011);\n-  INSN(lh,  0b0000011, 0b001);\n-  INSN(lhu, 0b0000011, 0b101);\n-  INSN(lw,  0b0000011, 0b010);\n-  INSN(lwu, 0b0000011, 0b110);\n+  INSN(lb,  0b0000011, 0b000, NOT_COMPRESSIBLE);\n+  INSN(lbu, 0b0000011, 0b100, NOT_COMPRESSIBLE);\n+  INSN(lh,  0b0000011, 0b001, NOT_COMPRESSIBLE);\n+  INSN(lhu, 0b0000011, 0b101, NOT_COMPRESSIBLE);\n+  INSN(lw,  0b0000011, 0b010, COMPRESSIBLE);\n+  INSN(lwu, 0b0000011, 0b110, NOT_COMPRESSIBLE);\n+  INSN(ld,  0b0000011, 0b011, COMPRESSIBLE);\n@@ -504,1 +511,1 @@\n-#define INSN(NAME, op, funct3)                                                                     \\\n+#define INSN(NAME, op, funct3, C)                                                                  \\\n@@ -506,1 +513,0 @@\n-    unsigned insn = 0;                                                                             \\\n@@ -508,0 +514,2 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs, offset)                                                     \\\n+    unsigned insn = 0;                                                                             \\\n@@ -553,2 +561,2 @@\n-  INSN(flw, 0b0000111, 0b010);\n-  INSN(fld, 0b0000111, 0b011);\n+  INSN(flw, 0b0000111, 0b010, NOT_COMPRESSIBLE);\n+  INSN(fld, 0b0000111, 0b011, COMPRESSIBLE);\n@@ -557,1 +565,1 @@\n-#define INSN(NAME, op, funct3)                                                                           \\\n+#define INSN(NAME, op, funct3, C)                                                                        \\\n@@ -559,1 +567,0 @@\n-    unsigned insn = 0;                                                                                   \\\n@@ -561,0 +568,2 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rs1, Rs2, offset)                                                         \\\n+    unsigned insn = 0;                                                                                   \\\n@@ -586,6 +595,6 @@\n-  INSN(beq,  0b1100011, 0b000);\n-  INSN(bge,  0b1100011, 0b101);\n-  INSN(bgeu, 0b1100011, 0b111);\n-  INSN(blt,  0b1100011, 0b100);\n-  INSN(bltu, 0b1100011, 0b110);\n-  INSN(bne,  0b1100011, 0b001);\n+  INSN(beq,  0b1100011, 0b000, COMPRESSIBLE);\n+  INSN(bne,  0b1100011, 0b001, COMPRESSIBLE);\n+  INSN(bge,  0b1100011, 0b101, NOT_COMPRESSIBLE);\n+  INSN(bgeu, 0b1100011, 0b111, NOT_COMPRESSIBLE);\n+  INSN(blt,  0b1100011, 0b100, NOT_COMPRESSIBLE);\n+  INSN(bltu, 0b1100011, 0b110, NOT_COMPRESSIBLE);\n@@ -609,1 +618,1 @@\n-#define INSN(NAME, REGISTER, op, funct3)                                                                    \\\n+#define INSN(NAME, REGISTER, op, funct3, C)                                                                 \\\n@@ -611,1 +620,0 @@\n-    unsigned insn = 0;                                                                                      \\\n@@ -613,0 +621,2 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rs1, Rs2, offset)                                                            \\\n+    unsigned insn = 0;                                                                                      \\\n@@ -628,6 +638,6 @@\n-  INSN(sb,  Register,      0b0100011, 0b000);\n-  INSN(sh,  Register,      0b0100011, 0b001);\n-  INSN(sw,  Register,      0b0100011, 0b010);\n-  INSN(sd,  Register,      0b0100011, 0b011);\n-  INSN(fsw, FloatRegister, 0b0100111, 0b010);\n-  INSN(fsd, FloatRegister, 0b0100111, 0b011);\n+  INSN(sb,  Register,      0b0100011, 0b000, NOT_COMPRESSIBLE);\n+  INSN(sh,  Register,      0b0100011, 0b001, NOT_COMPRESSIBLE);\n+  INSN(sw,  Register,      0b0100011, 0b010, COMPRESSIBLE);\n+  INSN(sd,  Register,      0b0100011, 0b011, COMPRESSIBLE);\n+  INSN(fsw, FloatRegister, 0b0100111, 0b010, NOT_COMPRESSIBLE);\n+  INSN(fsd, FloatRegister, 0b0100111, 0b011, COMPRESSIBLE);\n@@ -760,1 +770,1 @@\n-#define INSN(NAME, op)                                                                        \\\n+#define INSN(NAME, op, C)                                                                     \\\n@@ -762,1 +772,0 @@\n-    unsigned insn = 0;                                                                        \\\n@@ -764,0 +773,2 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rd, offset)                                                    \\\n+    unsigned insn = 0;                                                                        \\\n@@ -789,1 +800,1 @@\n-  INSN(jal, 0b1101111);\n+  INSN(jal, 0b1101111, COMPRESSIBLE);\n@@ -795,1 +806,1 @@\n-#define INSN(NAME, op, funct)                                                              \\\n+#define INSN(NAME, op, funct, C)                                                           \\\n@@ -797,1 +808,0 @@\n-    unsigned insn = 0;                                                                     \\\n@@ -799,0 +809,2 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs, offset)                                             \\\n+    unsigned insn = 0;                                                                     \\\n@@ -808,1 +820,1 @@\n-  INSN(jalr, 0b1100111, 0b000);\n+  INSN(jalr, 0b1100111, 0b000, COMPRESSIBLE);\n@@ -831,1 +843,1 @@\n-#define INSN(NAME, op, funct3, funct7)                      \\\n+#define INSN(NAME, op, funct3, funct7, C)                   \\\n@@ -833,0 +845,1 @@\n+    EMIT_MAY_COMPRESS(C, NAME)                              \\\n@@ -842,3 +855,3 @@\n-  INSN(fence_i, 0b0001111, 0b001, 0b000000000000);\n-  INSN(ecall,   0b1110011, 0b000, 0b000000000000);\n-  INSN(ebreak,  0b1110011, 0b000, 0b000000000001);\n+  INSN(fence_i, 0b0001111, 0b001, 0b000000000000, NOT_COMPRESSIBLE);\n+  INSN(ecall,   0b1110011, 0b000, 0b000000000000, NOT_COMPRESSIBLE);\n+  INSN(ebreak,  0b1110011, 0b000, 0b000000000001, COMPRESSIBLE);\n@@ -940,1 +953,1 @@\n-#define INSN(NAME, op, funct3)                                                              \\\n+#define INSN(NAME, op, funct3, C)                                                           \\\n@@ -943,0 +956,1 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs1, imm)                                                \\\n@@ -952,6 +966,6 @@\n-  INSN(addi,  0b0010011, 0b000);\n-  INSN(slti,  0b0010011, 0b010);\n-  INSN(addiw, 0b0011011, 0b000);\n-  INSN(and_imm12,  0b0010011, 0b111);\n-  INSN(ori,   0b0010011, 0b110);\n-  INSN(xori,  0b0010011, 0b100);\n+  INSN(addi,      0b0010011, 0b000, COMPRESSIBLE);\n+  INSN(slti,      0b0010011, 0b010, NOT_COMPRESSIBLE);\n+  INSN(addiw,     0b0011011, 0b000, COMPRESSIBLE);\n+  INSN(and_imm12, 0b0010011, 0b111, COMPRESSIBLE);\n+  INSN(ori,       0b0010011, 0b110, NOT_COMPRESSIBLE);\n+  INSN(xori,      0b0010011, 0b100, NOT_COMPRESSIBLE);\n@@ -978,1 +992,1 @@\n-#define INSN(NAME, op, funct3, funct6)                                   \\\n+#define INSN(NAME, op, funct3, funct6, C)                                \\\n@@ -981,0 +995,1 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs1, shamt)                           \\\n@@ -991,3 +1006,3 @@\n-  INSN(slli,  0b0010011, 0b001, 0b000000);\n-  INSN(srai,  0b0010011, 0b101, 0b010000);\n-  INSN(srli,  0b0010011, 0b101, 0b000000);\n+  INSN(slli,  0b0010011, 0b001, 0b000000, COMPRESSIBLE);\n+  INSN(srai,  0b0010011, 0b101, 0b010000, COMPRESSIBLE);\n+  INSN(srli,  0b0010011, 0b101, 0b000000, COMPRESSIBLE);\n@@ -1018,1 +1033,1 @@\n-#define INSN(NAME, op)                                                  \\\n+#define INSN(NAME, op, C)                                               \\\n@@ -1020,0 +1035,1 @@\n+    EMIT_MAY_COMPRESS(C, NAME, Rd, imm)                                 \\\n@@ -1029,2 +1045,2 @@\n-  INSN(lui,   0b0110111);\n-  INSN(auipc, 0b0010111);\n+  INSN(lui,   0b0110111, COMPRESSIBLE);\n+  INSN(auipc, 0b0010111, NOT_COMPRESSIBLE);\n@@ -1241,1 +1257,1 @@\n-  Assembler(CodeBuffer* code) : AbstractAssembler(code) {\n+  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(false) {\n@@ -1266,2 +1282,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":101,"deletions":87,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -0,0 +1,881 @@\n+\/*\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2022, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_ASSEMBLER_RISCV_C_HPP\n+#define CPU_RISCV_ASSEMBLER_RISCV_C_HPP\n+\n+private:\n+  bool _in_compressible_region;\n+public:\n+  bool in_compressible_region() const { return _in_compressible_region; }\n+  void set_in_compressible_region(bool b) { _in_compressible_region = b; }\n+public:\n+\n+  \/\/ RVC: If an instruction is compressible, then\n+  \/\/   we will implicitly emit a 16-bit compressed instruction instead of the 32-bit\n+  \/\/   instruction in Assembler. All below logic follows Chapter -\n+  \/\/   \"C\" Standard Extension for Compressed Instructions, Version 2.0.\n+  \/\/   We can get code size reduction and performance improvement with this extension,\n+  \/\/   considering the reduction of instruction size and the code density increment.\n+\n+  \/\/ Note:\n+  \/\/   1. When UseRVC is enabled, 32-bit instructions under 'CompressibleRegion's will be\n+  \/\/      transformed to 16-bit instructions if compressible.\n+  \/\/   2. RVC instructions in Assembler always begin with 'c_' prefix, as 'c_li',\n+  \/\/      but most of time we have no need to explicitly use these instructions.\n+  \/\/   3. We introduce 'CompressibleRegion' to hint instructions in this Region's RTTI range\n+  \/\/      are qualified to change to their 2-byte versions.\n+  \/\/      An example:\n+  \/\/\n+  \/\/        CompressibleRegion cr(_masm);\n+  \/\/        __ andr(...);      \/\/ this instruction could change to c.and if able to\n+  \/\/\n+  \/\/   4. Using -XX:PrintAssemblyOptions=no-aliases could print RVC instructions instead of\n+  \/\/      normal ones.\n+  \/\/\n+\n+  \/\/ RVC: extract a 16-bit instruction.\n+  static inline uint16_t c_extract(uint16_t val, unsigned msb, unsigned lsb) {\n+    assert_cond(msb >= lsb && msb <= 15);\n+    unsigned nbits = msb - lsb + 1;\n+    uint16_t mask = (1U << nbits) - 1;\n+    uint16_t result = val >> lsb;\n+    result &= mask;\n+    return result;\n+  }\n+\n+  static inline int16_t c_sextract(uint16_t val, unsigned msb, unsigned lsb) {\n+    assert_cond(msb >= lsb && msb <= 15);\n+    int16_t result = val << (15 - msb);\n+    result >>= (15 - msb + lsb);\n+    return result;\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction.\n+  static void c_patch(address a, unsigned msb, unsigned lsb, uint16_t val) {\n+    assert_cond(a != NULL);\n+    assert_cond(msb >= lsb && msb <= 15);\n+    unsigned nbits = msb - lsb + 1;\n+    guarantee(val < (1U << nbits), \"Field too big for insn\");\n+    uint16_t mask = (1U << nbits) - 1;\n+    val <<= lsb;\n+    mask <<= lsb;\n+    uint16_t target = *(uint16_t *)a;\n+    target &= ~mask;\n+    target |= val;\n+    *(uint16_t *)a = target;\n+  }\n+\n+  static void c_patch(address a, unsigned bit, uint16_t val) {\n+    c_patch(a, bit, bit, val);\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction with a general purpose register ranging [0, 31] (5 bits)\n+  static void c_patch_reg(address a, unsigned lsb, Register reg) {\n+    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction with a general purpose register ranging [8, 15] (3 bits)\n+  static void c_patch_compressed_reg(address a, unsigned lsb, Register reg) {\n+    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction with a float register ranging [0, 31] (5 bits)\n+  static void c_patch_reg(address a, unsigned lsb, FloatRegister reg) {\n+    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction with a float register ranging [8, 15] (3 bits)\n+  static void c_patch_compressed_reg(address a, unsigned lsb, FloatRegister reg) {\n+    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n+  }\n+\n+public:\n+\n+\/\/ RVC: Compressed Instructions\n+\n+\/\/ --------------  RVC Instruction Definitions  --------------\n+\n+  void c_nop() {\n+    c_addi(x0, 0);\n+  }\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi,   0b000, 0b01);\n+  INSN(c_addiw,  0b001, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(int32_t imm) {                                                                   \\\n+    assert_cond(is_imm_in_range(imm, 10, 0));                                                \\\n+    assert_cond((imm & 0b1111) == 0);                                                        \\\n+    assert_cond(imm != 0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n+    c_patch((address)&insn, 4, 3, (imm & right_n_bits(9)) >> 7);                             \\\n+    c_patch((address)&insn, 5, 5, (imm & nth_bit(6)) >> 6);                                  \\\n+    c_patch((address)&insn, 6, 6, (imm & nth_bit(4)) >> 4);                                  \\\n+    c_patch_reg((address)&insn, 7, sp);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(9)) >> 9);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi16sp, 0b011, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 10, 0));                                      \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    assert_cond(uimm != 0);                                                                  \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd);                                           \\\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(3)) >> 3);                                 \\\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n+    c_patch((address)&insn, 10, 7, (uimm & right_n_bits(10)) >> 6);                          \\\n+    c_patch((address)&insn, 12, 11, (uimm & right_n_bits(6)) >> 4);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi4spn, 0b000, 0b00);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n+    assert_cond(shamt != 0);                                                                 \\\n+    assert_cond(Rd_Rs1 != x0);                                                               \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_slli, 0b000, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n+    assert_cond(shamt != 0);                                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n+    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_srli, 0b100, 0b00, 0b01);\n+  INSN(c_srai, 0b100, 0b01, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_andi, 0b100, 0b10, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct6, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rs2);                                          \\\n+    c_patch((address)&insn, 6, 5, funct2);                                                   \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 15, 10, funct6);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_sub,  0b100011, 0b00, 0b01);\n+  INSN(c_xor,  0b100011, 0b01, 0b01);\n+  INSN(c_or,   0b100011, 0b10, 0b01);\n+  INSN(c_and,  0b100011, 0b11, 0b01);\n+  INSN(c_subw, 0b100111, 0b00, 0b01);\n+  INSN(c_addw, 0b100111, 0b01, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct4, op)                                                               \\\n+  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n+    assert_cond(Rd_Rs1 != x0);                                                               \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_mv,  0b1000, 0b10);\n+  INSN(c_add, 0b1001, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct4, op)                                                               \\\n+  void NAME(Register Rs1) {                                                                  \\\n+    assert_cond(Rs1 != x0);                                                                  \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, x0);                                                      \\\n+    c_patch_reg((address)&insn, 7, Rs1);                                                     \\\n+    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_jr,   0b1000, 0b10);\n+  INSN(c_jalr, 0b1001, 0b10);\n+\n+#undef INSN\n+\n+  typedef void (Assembler::* j_c_insn)(address dest);\n+  typedef void (Assembler::* compare_and_branch_c_insn)(Register Rs1, address dest);\n+\n+  void wrap_label(Label &L, j_c_insn insn) {\n+    if (L.is_bound()) {\n+      (this->*insn)(target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(pc());\n+    }\n+  }\n+\n+  void wrap_label(Label &L, Register r, compare_and_branch_c_insn insn) {\n+    if (L.is_bound()) {\n+      (this->*insn)(r, target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(r, pc());\n+    }\n+  }\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(int32_t offset) {                                                                \\\n+    assert_cond(is_imm_in_range(offset, 11, 1));                                             \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (offset & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 5, 3, (offset & right_n_bits(4)) >> 1);                          \\\n+    c_patch((address)&insn, 6, 6, (offset & nth_bit(7)) >> 7);                               \\\n+    c_patch((address)&insn, 7, 7, (offset & nth_bit(6)) >> 6);                               \\\n+    c_patch((address)&insn, 8, 8, (offset & nth_bit(10)) >> 10);                             \\\n+    c_patch((address)&insn, 10, 9, (offset & right_n_bits(10)) >> 8);                        \\\n+    c_patch((address)&insn, 11, 11, (offset & nth_bit(4)) >> 4);                             \\\n+    c_patch((address)&insn, 12, 12, (offset & nth_bit(11)) >> 11);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }                                                                                          \\\n+  void NAME(address dest) {                                                                  \\\n+    assert_cond(dest != NULL);                                                               \\\n+    int64_t distance = dest - pc();                                                          \\\n+    assert_cond(is_imm_in_range(distance, 11, 1));                                           \\\n+    c_j(distance);                                                                           \\\n+  }                                                                                          \\\n+  void NAME(Label &L) {                                                                      \\\n+    wrap_label(L, &Assembler::NAME);                                                         \\\n+  }\n+\n+  INSN(c_j, 0b101, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rs1, int32_t imm) {                                                     \\\n+    assert_cond(is_imm_in_range(imm, 8, 1));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n+    c_patch((address)&insn, 4, 3, (imm & right_n_bits(3)) >> 1);                             \\\n+    c_patch((address)&insn, 6, 5, (imm & right_n_bits(8)) >> 6);                             \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 11, 10, (imm & right_n_bits(5)) >> 3);                           \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(8)) >> 8);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }                                                                                          \\\n+  void NAME(Register Rs1, address dest) {                                                    \\\n+    assert_cond(dest != NULL);                                                               \\\n+    int64_t distance = dest - pc();                                                          \\\n+    assert_cond(is_imm_in_range(distance, 8, 1));                                            \\\n+    NAME(Rs1, distance);                                                                     \\\n+  }                                                                                          \\\n+  void NAME(Register Rs1, Label &L) {                                                        \\\n+    wrap_label(L, Rs1, &Assembler::NAME);                                                    \\\n+  }\n+\n+  INSN(c_beqz, 0b110, 0b01);\n+  INSN(c_bnez, 0b111, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    assert_cond(is_imm_in_range(imm, 18, 0));                                                \\\n+    assert_cond((imm & 0xfff) == 0);                                                         \\\n+    assert_cond(imm != 0);                                                                   \\\n+    assert_cond(Rd != x0 && Rd != x2);                                                       \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(17)) >> 12);                           \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(17)) >> 17);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lui, 0b011, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    assert_cond(Rd != x0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & right_n_bits(6)) >> 5);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_li, 0b010, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE, CHECK)                                         \\\n+  void NAME(REGISTER_TYPE Rd, uint32_t uimm) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    IF(CHECK, assert_cond(Rd != x0);)                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 4, 2, (uimm & right_n_bits(9)) >> 6);                            \\\n+    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(5)) >> 3);                            \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+#define IF(BOOL, ...)       IF_##BOOL(__VA_ARGS__)\n+#define IF_true(code)       code\n+#define IF_false(code)\n+\n+  INSN(c_ldsp,  0b011, 0b10, Register,      true);\n+  INSN(c_fldsp, 0b001, 0b10, FloatRegister, false);\n+\n+#undef IF_false\n+#undef IF_true\n+#undef IF\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n+  void NAME(REGISTER_TYPE Rd_Rs2, Register Rs1, uint32_t uimm) {                             \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n+    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_ld,  0b011, 0b00, Register);\n+  INSN(c_sd,  0b111, 0b00, Register);\n+  INSN(c_fld, 0b001, 0b00, FloatRegister);\n+  INSN(c_fsd, 0b101, 0b00, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n+  void NAME(REGISTER_TYPE Rs2, uint32_t uimm) {                                              \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch((address)&insn, 9, 7, (uimm & right_n_bits(9)) >> 6);                            \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_sdsp,  0b111, 0b10, Register);\n+  INSN(c_fsdsp, 0b101, 0b10, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rs2, uint32_t uimm) {                                                   \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch((address)&insn, 8, 7, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch((address)&insn, 12, 9, (uimm & right_n_bits(6)) >> 2);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_swsp, 0b110, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    assert_cond(Rd != x0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 3, 2, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch((address)&insn, 6, 4, (uimm & right_n_bits(5)) >> 2);                            \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lwsp, 0b010, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs2, Register Rs1, uint32_t uimm) {                                  \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 7, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(6)) >> 6);                                 \\\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lw, 0b010, 0b00);\n+  INSN(c_sw, 0b110, 0b00);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME() {                                                                              \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 11, 2, 0x0);                                                     \\\n+    c_patch((address)&insn, 12, 12, 0b1);                                                    \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_ebreak, 0b100, 0b10);\n+\n+#undef INSN\n+\n+\/\/ --------------  RVC Transformation Macros  --------------\n+\n+\/\/ two RVC macros\n+#define COMPRESSIBLE          true\n+#define NOT_COMPRESSIBLE      false\n+\n+\/\/ a pivotal dispatcher for RVC\n+#define EMIT_MAY_COMPRESS(C, NAME, ...)               EMIT_MAY_COMPRESS_##C(NAME, __VA_ARGS__)\n+#define EMIT_MAY_COMPRESS_true(NAME, ...)             EMIT_MAY_COMPRESS_##NAME(__VA_ARGS__)\n+#define EMIT_MAY_COMPRESS_false(NAME, ...)\n+\n+#define IS_COMPRESSIBLE(...)                          if (__VA_ARGS__)\n+#define CHECK_CEXT_AND_COMPRESSIBLE(...)              IS_COMPRESSIBLE(UseRVC && in_compressible_region() && __VA_ARGS__)\n+#define CHECK_CEXT()                                  if (UseRVC && in_compressible_region())\n+\n+\/\/ RVC transformation macros\n+#define EMIT_RVC_cond(PREFIX, COND, EMIT) {                                            \\\n+    PREFIX                                                                             \\\n+    CHECK_CEXT_AND_COMPRESSIBLE(COND) {                                                \\\n+      EMIT;                                                                            \\\n+      return;                                                                          \\\n+    }                                                                                  \\\n+  }\n+\n+#define EMIT_RVC_cond2(PREFIX, COND1, EMIT1, COND2, EMIT2) {                           \\\n+    PREFIX                                                                             \\\n+    CHECK_CEXT() {                                                                     \\\n+      IS_COMPRESSIBLE(COND1) {                                                         \\\n+        EMIT1;                                                                         \\\n+        return;                                                                        \\\n+      } else IS_COMPRESSIBLE(COND2) {                                                  \\\n+        EMIT2;                                                                         \\\n+        return;                                                                        \\\n+      }                                                                                \\\n+    }                                                                                  \\\n+  }\n+\n+#define EMIT_RVC_cond4(PREFIX, COND1, EMIT1, COND2, EMIT2, COND3, EMIT3, COND4, EMIT4) {  \\\n+    PREFIX                                                                             \\\n+    CHECK_CEXT() {                                                                     \\\n+      IS_COMPRESSIBLE(COND1) {                                                         \\\n+        EMIT1;                                                                         \\\n+        return;                                                                        \\\n+      } else IS_COMPRESSIBLE(COND2) {                                                  \\\n+        EMIT2;                                                                         \\\n+        return;                                                                        \\\n+      } else IS_COMPRESSIBLE(COND3) {                                                  \\\n+        EMIT3;                                                                         \\\n+        return;                                                                        \\\n+      } else IS_COMPRESSIBLE(COND4) {                                                  \\\n+        EMIT4;                                                                         \\\n+        return;                                                                        \\\n+      }                                                                                \\\n+    }                                                                                  \\\n+  }\n+\n+\/\/ --------------------------\n+\/\/ Register instructions\n+\/\/ --------------------------\n+\/\/ add -> c.add\n+#define EMIT_MAY_COMPRESS_add(Rd, Rs1, Rs2)                                            \\\n+  EMIT_RVC_cond(                                                                       \\\n+    Register src = noreg;,                                                             \\\n+    Rs1 != x0 && Rs2 != x0 && ((src = Rs1, Rs2 == Rd) || (src = Rs2, Rs1 == Rd)),      \\\n+    c_add(Rd, src)                                                                     \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ sub\/subw -> c.sub\/c.subw\n+#define EMIT_MAY_COMPRESS_sub_helper(C_NAME, Rd, Rs1, Rs2)                             \\\n+  EMIT_RVC_cond(,                                                                      \\\n+    Rs1 == Rd && Rd->is_compressed_valid() && Rs2->is_compressed_valid(),              \\\n+    C_NAME(Rd, Rs2)                                                                    \\\n+  )\n+\n+#define EMIT_MAY_COMPRESS_sub(Rd, Rs1, Rs2)                                            \\\n+  EMIT_MAY_COMPRESS_sub_helper(c_sub, Rd, Rs1, Rs2)\n+\n+#define EMIT_MAY_COMPRESS_subw(Rd, Rs1, Rs2)                                           \\\n+  EMIT_MAY_COMPRESS_sub_helper(c_subw, Rd, Rs1, Rs2)\n+\n+\/\/ --------------------------\n+\/\/ xor\/or\/and\/addw -> c.xor\/c.or\/c.and\/c.addw\n+#define EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(C_NAME, Rd, Rs1, Rs2)              \\\n+  EMIT_RVC_cond(                                                                       \\\n+    Register src = noreg;,                                                             \\\n+    Rs1->is_compressed_valid() && Rs2->is_compressed_valid() &&                        \\\n+      ((src = Rs1, Rs2 == Rd) || (src = Rs2, Rs1 == Rd)),                              \\\n+    C_NAME(Rd, src)                                                                    \\\n+  )\n+\n+#define EMIT_MAY_COMPRESS_xorr(Rd, Rs1, Rs2)                                           \\\n+  EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(c_xor, Rd, Rs1, Rs2)\n+\n+#define EMIT_MAY_COMPRESS_orr(Rd, Rs1, Rs2)                                            \\\n+  EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(c_or, Rd, Rs1, Rs2)\n+\n+#define EMIT_MAY_COMPRESS_andr(Rd, Rs1, Rs2)                                           \\\n+  EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(c_and, Rd, Rs1, Rs2)\n+\n+#define EMIT_MAY_COMPRESS_addw(Rd, Rs1, Rs2)                                           \\\n+  EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(c_addw, Rd, Rs1, Rs2)\n+\n+\/\/ --------------------------\n+\/\/ Load\/store register (all modes)\n+\/\/ --------------------------\n+private:\n+\n+#define FUNC(NAME, funct3, bits)                                                       \\\n+  bool NAME(Register rs1, Register rd_rs2, int32_t imm12, bool ld) {                   \\\n+    return rs1 == sp &&                                                                \\\n+      is_unsigned_imm_in_range(imm12, bits, 0) &&                                      \\\n+      (intx(imm12) & funct3) == 0x0 &&                                                 \\\n+      (!ld || rd_rs2 != x0);                                                           \\\n+  }                                                                                    \\\n+\n+  FUNC(is_c_ldsdsp,  0b111, 9);\n+  FUNC(is_c_lwswsp,  0b011, 8);\n+#undef FUNC\n+\n+#define FUNC(NAME, funct3, bits)                                                       \\\n+  bool NAME(Register rs1, int32_t imm12) {                                             \\\n+    return rs1 == sp &&                                                                \\\n+      is_unsigned_imm_in_range(imm12, bits, 0) &&                                      \\\n+      (intx(imm12) & funct3) == 0x0;                                                   \\\n+  }                                                                                    \\\n+\n+  FUNC(is_c_fldsdsp, 0b111, 9);\n+#undef FUNC\n+\n+#define FUNC(NAME, REG_TYPE, funct3, bits)                                             \\\n+  bool NAME(Register rs1, REG_TYPE rd_rs2, int32_t imm12) {                            \\\n+    return rs1->is_compressed_valid() &&                                               \\\n+      rd_rs2->is_compressed_valid() &&                                                 \\\n+      is_unsigned_imm_in_range(imm12, bits, 0) &&                                      \\\n+      (intx(imm12) & funct3) == 0x0;                                                   \\\n+  }                                                                                    \\\n+\n+  FUNC(is_c_ldsd,  Register,      0b111, 8);\n+  FUNC(is_c_lwsw,  Register,      0b011, 7);\n+  FUNC(is_c_fldsd, FloatRegister, 0b111, 8);\n+#undef FUNC\n+\n+public:\n+\/\/ --------------------------\n+\/\/ ld -> c.ldsp\/c.ld\n+#define EMIT_MAY_COMPRESS_ld(Rd, Rs, offset)                                           \\\n+  EMIT_RVC_cond2(,                                                                     \\\n+     is_c_ldsdsp(Rs, Rd, offset, true),                                                \\\n+     c_ldsp(Rd, offset),                                                               \\\n+     is_c_ldsd(Rs, Rd, offset),                                                        \\\n+     c_ld(Rd, Rs, offset)                                                              \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ sd -> c.sdsp\/c.sd\n+#define EMIT_MAY_COMPRESS_sd(Rd, Rs, offset)                                           \\\n+  EMIT_RVC_cond2(,                                                                     \\\n+     is_c_ldsdsp(Rs, Rd, offset, false),                                               \\\n+     c_sdsp(Rd, offset),                                                               \\\n+     is_c_ldsd(Rs, Rd, offset),                                                        \\\n+     c_sd(Rd, Rs, offset)                                                              \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ lw -> c.lwsp\/c.lw\n+#define EMIT_MAY_COMPRESS_lw(Rd, Rs, offset)                                           \\\n+  EMIT_RVC_cond2(,                                                                     \\\n+     is_c_lwswsp(Rs, Rd, offset, true),                                                \\\n+     c_lwsp(Rd, offset),                                                               \\\n+     is_c_lwsw(Rs, Rd, offset),                                                        \\\n+     c_lw(Rd, Rs, offset)                                                              \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ sw -> c.swsp\/c.sw\n+#define EMIT_MAY_COMPRESS_sw(Rd, Rs, offset)                                           \\\n+  EMIT_RVC_cond2(,                                                                     \\\n+     is_c_lwswsp(Rs, Rd, offset, false),                                               \\\n+     c_swsp(Rd, offset),                                                               \\\n+     is_c_lwsw(Rs, Rd, offset),                                                        \\\n+     c_sw(Rd, Rs, offset)                                                              \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ fld -> c.fldsp\/c.fld\n+#define EMIT_MAY_COMPRESS_fld(Rd, Rs, offset)                                          \\\n+  EMIT_RVC_cond2(,                                                                     \\\n+     is_c_fldsdsp(Rs, offset),                                                         \\\n+     c_fldsp(Rd, offset),                                                              \\\n+     is_c_fldsd(Rs, Rd, offset),                                                       \\\n+     c_fld(Rd, Rs, offset)                                                             \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ fsd -> c.fsdsp\/c.fsd\n+#define EMIT_MAY_COMPRESS_fsd(Rd, Rs, offset)                                          \\\n+  EMIT_RVC_cond2(,                                                                     \\\n+     is_c_fldsdsp(Rs, offset),                                                         \\\n+     c_fsdsp(Rd, offset),                                                              \\\n+     is_c_fldsd(Rs, Rd, offset),                                                       \\\n+     c_fsd(Rd, Rs, offset)                                                             \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ Conditional branch instructions\n+\/\/ --------------------------\n+\/\/ beq\/bne -> c.beqz\/c.bnez\n+\n+\/\/ Note: offset == 0 means this beqz\/benz is jumping forward and we cannot know the future position\n+\/\/   so we cannot compress this instrution.\n+#define EMIT_MAY_COMPRESS_beqz_bnez_helper(C_NAME, Rs1, Rs2, offset)                   \\\n+  EMIT_RVC_cond(,                                                                      \\\n+    offset != 0 && Rs2 == x0 && Rs1->is_compressed_valid() &&                          \\\n+      is_imm_in_range(offset, 8, 1),                                                   \\\n+    C_NAME(Rs1, offset)                                                                \\\n+  )\n+\n+#define EMIT_MAY_COMPRESS_beq(Rs1, Rs2, offset)                                        \\\n+  EMIT_MAY_COMPRESS_beqz_bnez_helper(c_beqz, Rs1, Rs2, offset)\n+\n+#define EMIT_MAY_COMPRESS_bne(Rs1, Rs2, offset)                                        \\\n+  EMIT_MAY_COMPRESS_beqz_bnez_helper(c_bnez, Rs1, Rs2, offset)\n+\n+\/\/ --------------------------\n+\/\/ Unconditional branch instructions\n+\/\/ --------------------------\n+\/\/ jalr\/jal -> c.jr\/c.jalr\/c.j\n+\n+#define EMIT_MAY_COMPRESS_jalr(Rd, Rs, offset)                                         \\\n+  EMIT_RVC_cond2(,                                                                     \\\n+    offset == 0 && Rd == x1 && Rs != x0,                                               \\\n+    c_jalr(Rs),                                                                        \\\n+    offset == 0 && Rd == x0 && Rs != x0,                                               \\\n+    c_jr(Rs)                                                                           \\\n+  )\n+\n+\/\/ Note: offset == 0 means this j() is jumping forward and we cannot know the future position\n+\/\/   so we cannot compress this instrution.\n+#define EMIT_MAY_COMPRESS_jal(Rd, offset)                                              \\\n+  EMIT_RVC_cond(,                                                                      \\\n+    offset != 0 && Rd == x0 && is_imm_in_range(offset, 11, 1),                         \\\n+    c_j(offset)                                                                        \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ Upper Immediate Instruction\n+\/\/ --------------------------\n+\/\/ lui -> c.lui\n+#define EMIT_MAY_COMPRESS_lui(Rd, imm)                                                 \\\n+  EMIT_RVC_cond(,                                                                      \\\n+    Rd != x0 && Rd != x2 && imm != 0 && is_imm_in_range(imm, 18, 0),                   \\\n+    c_lui(Rd, imm)                                                                     \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ Miscellaneous Instructions\n+\/\/ --------------------------\n+\/\/ ebreak -> c.ebreak\n+#define EMIT_MAY_COMPRESS_ebreak()                                                     \\\n+  EMIT_RVC_cond(,                                                                      \\\n+    true,                                                                              \\\n+    c_ebreak()                                                                         \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ Immediate Instructions\n+\/\/ --------------------------\n+\/\/ addi -> c.addi\/c.nop\/c.mv\/c.addi16sp\/c.addi4spn.\n+#define EMIT_MAY_COMPRESS_addi(Rd, Rs1, imm)                                                          \\\n+  EMIT_RVC_cond4(,                                                                                    \\\n+    Rd == Rs1 && is_imm_in_range(imm, 6, 0),                                                          \\\n+    c_addi(Rd, imm),                                                                                  \\\n+    imm == 0 && Rd != x0 && Rs1 != x0,                                                                \\\n+    c_mv(Rd, Rs1),                                                                                    \\\n+    Rs1 == sp && Rd == Rs1 && imm != 0 && (imm & 0b1111) == 0x0 && is_imm_in_range(imm, 10, 0),       \\\n+    c_addi16sp(imm),                                                                                  \\\n+    Rs1 == sp && Rd->is_compressed_valid() && imm != 0 && (imm & 0b11) == 0x0 && is_unsigned_imm_in_range(imm, 10, 0),  \\\n+    c_addi4spn(Rd, imm)                                                                               \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ addiw -> c.addiw\n+#define EMIT_MAY_COMPRESS_addiw(Rd, Rs1, imm)                                          \\\n+  EMIT_RVC_cond(,                                                                      \\\n+    Rd == Rs1 && Rd != x0 && is_imm_in_range(imm, 6, 0),                               \\\n+    c_addiw(Rd, imm)                                                                   \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ and_imm12 -> c.andi\n+#define EMIT_MAY_COMPRESS_and_imm12(Rd, Rs1, imm)                                      \\\n+  EMIT_RVC_cond(,                                                                      \\\n+    Rd == Rs1 && Rd->is_compressed_valid() && is_imm_in_range(imm, 6, 0),              \\\n+    c_andi(Rd, imm)                                                                    \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ Shift Immediate Instructions\n+\/\/ --------------------------\n+\/\/ slli -> c.slli\n+#define EMIT_MAY_COMPRESS_slli(Rd, Rs1, shamt)                                         \\\n+  EMIT_RVC_cond(,                                                                      \\\n+    Rd == Rs1 && Rd != x0 && shamt != 0,                                               \\\n+    c_slli(Rd, shamt)                                                                  \\\n+  )\n+\n+\/\/ --------------------------\n+\/\/ srai\/srli -> c.srai\/c.srli\n+#define EMIT_MAY_COMPRESS_srai_srli_helper(C_NAME, Rd, Rs1, shamt)                     \\\n+  EMIT_RVC_cond(,                                                                      \\\n+    Rd == Rs1 && Rd->is_compressed_valid() && shamt != 0,                              \\\n+    C_NAME(Rd, shamt)                                                                  \\\n+  )\n+\n+#define EMIT_MAY_COMPRESS_srai(Rd, Rs1, shamt)                                         \\\n+  EMIT_MAY_COMPRESS_srai_srli_helper(c_srai, Rd, Rs1, shamt)\n+\n+#define EMIT_MAY_COMPRESS_srli(Rd, Rs1, shamt)                                         \\\n+  EMIT_MAY_COMPRESS_srai_srli_helper(c_srli, Rd, Rs1, shamt)\n+\n+\/\/ --------------------------\n+\n+public:\n+\/\/ RVC: a compressible region\n+class CompressibleRegion : public StackObj {\n+protected:\n+  Assembler *_masm;\n+  bool _prev_in_compressible_region;\n+public:\n+  CompressibleRegion(Assembler *_masm)\n+  : _masm(_masm)\n+  , _prev_in_compressible_region(_masm->in_compressible_region()) {\n+    _masm->set_in_compressible_region(true);\n+  }\n+  ~CompressibleRegion() {\n+    _masm->set_in_compressible_region(_prev_in_compressible_region);\n+  }\n+};\n+\n+#endif \/\/ CPU_RISCV_ASSEMBLER_RISCV_C_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv_c.hpp","additions":881,"deletions":0,"binary":false,"changes":881,"status":"added"},{"patch":"@@ -1325,1 +1325,6 @@\n-void LIR_Assembler::align_call(LIR_Code code) {  }\n+void LIR_Assembler::align_call(LIR_Code code) {\n+  \/\/ RVC: With RVC a call may get 2-byte aligned.\n+  \/\/   the address of jal itself (which will be patched later) should not span the cache line.\n+  \/\/   See CallDynamicJavaDirectNode::compute_padding() for more info.\n+  __ align(4);\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-define_pd_global(intx, InteriorEntryAlignment,       16);\n+define_pd_global(intx, InteriorEntryAlignment,       4);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_globals_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -234,0 +234,2 @@\n+extern int nmethod_barrier_guard_offset();\n+\n@@ -241,0 +243,4 @@\n+  \/\/ RVC: RISCV's amoswap instructions need an alignment for the memory address it swaps\n+  \/\/   when we reach here we may get a 2-byte alignment so need to align it\n+  __ align(4, nmethod_barrier_guard_offset());\n+\n@@ -259,0 +265,1 @@\n+  assert(__ offset() % 4 == 0, \"RISCV CAS needs an alignment for memory\");\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -39,0 +39,7 @@\n+public:\n+  enum {\n+    guard_offset   = 12 * instruction_size,\n+    barrier_size   = guard_offset + 4,  \/\/ guard_offset + an int32 nmethod guard value\n+  };\n+\n+private:\n@@ -43,1 +50,1 @@\n-    return reinterpret_cast<int*>(instruction_address() + 12 * 4);\n+    return reinterpret_cast<int*>(instruction_address() + guard_offset);\n@@ -58,0 +65,4 @@\n+int nmethod_barrier_guard_offset() {\n+  return NativeNMethodBarrier::guard_offset;\n+}\n+\n@@ -144,1 +155,1 @@\n-static const int entry_barrier_offset = -4 * 13;\n+static const int entry_barrier_offset = - NativeNMethodBarrier::barrier_size;\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetNMethod_riscv.cpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-define_pd_global(intx, CodeEntryAlignment,       64);\n+define_pd_global(intx, CodeEntryAlignment,       16);\n@@ -94,1 +94,2 @@\n-  product(bool, UseRVB, false, EXPERIMENTAL, \"Use RVB instructions\")\n+  product(bool, UseRVB, false, EXPERIMENTAL, \"Use RVB instructions\")             \\\n+  product(bool, UseRVC, false, EXPERIMENTAL, \"Use RVC instructions\")             \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -91,2 +91,3 @@\n-void MacroAssembler::align(int modulus) {\n-  while (offset() % modulus != 0) { nop(); }\n+void MacroAssembler::align(int modulus, int extra_offset) {\n+  CompressibleRegion cr(this);\n+  while ((offset() + extra_offset) % modulus != 0) { nop(); }\n@@ -816,0 +817,1 @@\n+\n@@ -975,0 +977,1 @@\n+  CompressibleRegion cr(this);\n@@ -996,0 +999,1 @@\n+  CompressibleRegion cr(this);\n@@ -1018,0 +1022,1 @@\n+  CompressibleRegion cr(this);\n@@ -1037,0 +1042,1 @@\n+  CompressibleRegion cr(this);\n@@ -1057,0 +1063,1 @@\n+  CompressibleRegion cr(this);\n@@ -1078,0 +1085,1 @@\n+  CompressibleRegion cr(this);\n@@ -1100,0 +1108,1 @@\n+  CompressibleRegion cr(this);\n@@ -1114,0 +1123,1 @@\n+  CompressibleRegion cr(this);\n@@ -1127,0 +1137,1 @@\n+  CompressibleRegion cr(this);\n@@ -1132,0 +1143,1 @@\n+  CompressibleRegion cr(this);\n@@ -1136,0 +1148,1 @@\n+  CompressibleRegion cr(this);\n@@ -1157,0 +1170,1 @@\n+  CompressibleRegion cr(this);\n@@ -1323,1 +1337,4 @@\n-    tty->print_cr(\"pd_patch_instruction_size: instruction 0x%x could not be patched!\\n\", *(unsigned*)branch);\n+#ifdef ASSERT\n+    tty->print_cr(\"pd_patch_instruction_size: instruction 0x%x at \" INTPTR_FORMAT \" could not be patched!\\n\", *(unsigned*)branch, p2i(branch));\n+    Disassembler::decode(branch - 10, branch + 10);\n+#endif\n@@ -2924,1 +2941,2 @@\n-  while (offset() % wordSize == 0) { nop(); }\n+  \/\/ RVC: when we reach here we may get a 2-byte alignment so need to align it\n+  align(wordSize, NativeCallTrampolineStub::data_offset);\n@@ -2939,0 +2957,1 @@\n+  assert(offset() % wordSize == 0, \"address loaded by ld must be 8-byte aligned under riscv64\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  void align(int modulus);\n+  void align(int modulus, int extra_offset = 0);\n@@ -448,0 +448,1 @@\n+  void bnez(Register Rs, const address &dest);\n@@ -452,1 +453,0 @@\n-  void bnez(Register Rs, const address &dest);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-    instruction_size = 4\n+    instruction_size = 4,\n+    compressed_instruction_size = 2,\n@@ -425,1 +426,1 @@\n-    instruction_size            =    4,\n+    instruction_size            =    NativeInstruction::instruction_size,\n@@ -428,1 +429,1 @@\n-    next_instruction_offset     =    4\n+    next_instruction_offset     =    NativeInstruction::instruction_size\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,5 @@\n-    max_slots_per_register   = 2\n+    max_slots_per_register   = 2,\n+\n+    \/\/ RVC: integer registers in the range of [x8~x15] correspond to RVC. Please see Table 16.2 in spec.\n+    compressed_register_base = 8,\n+    compressed_register_top  = 15,\n@@ -74,0 +78,1 @@\n+  int   compressed_encoding() const              { assert(is_compressed_valid(), \"invalid compressed register\"); return ((intptr_t)this - compressed_register_base); }\n@@ -75,0 +80,1 @@\n+  bool  is_compressed_valid() const              { return compressed_register_base <= (intptr_t)this && (intptr_t)this <= compressed_register_top; }\n@@ -78,0 +84,1 @@\n+  int   compressed_encoding_nocheck() const      { return ((intptr_t)this - compressed_register_base); }\n@@ -134,1 +141,5 @@\n-    max_slots_per_register  = 2\n+    max_slots_per_register  = 2,\n+\n+    \/\/ RVC: float registers in the range of [f8~f15] correspond to RVC. Please see Table 16.2 in spec.\n+    compressed_register_base = 8,\n+    compressed_register_top  = 15,\n@@ -147,0 +158,1 @@\n+  int   compressed_encoding() const               { assert(is_compressed_valid(), \"invalid compressed register\"); return ((intptr_t)this - compressed_register_base); }\n@@ -148,0 +160,1 @@\n+  int   compressed_encoding_nocheck() const       { return ((intptr_t)this - compressed_register_base); }\n@@ -149,0 +162,1 @@\n+  bool  is_compressed_valid() const               { return compressed_register_base <= (intptr_t)this && (intptr_t)this <= compressed_register_top; }\n","filename":"src\/hotspot\/cpu\/riscv\/register_riscv.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1159,3 +1159,2 @@\n-  \/\/ call should be a simple jal\n-  int off = 4;\n-  return off;\n+  \/\/ jal\n+  return 1 * NativeInstruction::instruction_size;\n@@ -1166,1 +1165,1 @@\n-  return 28; \/\/ movptr, jal\n+  return 7 * NativeInstruction::instruction_size; \/\/ movptr, jal\n@@ -1174,1 +1173,1 @@\n-  \/\/ for real runtime callouts it will be five instructions\n+  \/\/ for real runtime callouts it will be 11 instructions\n@@ -1176,5 +1175,5 @@\n-  \/\/   la(t1, retaddr)\n-  \/\/   la(t0, RuntimeAddress(addr))\n-  \/\/   addi(sp, sp, -2 * wordSize)\n-  \/\/   sd(t1, Address(sp, wordSize))\n-  \/\/   jalr(t0)\n+  \/\/   la(t1, retaddr)                ->  auipc + addi\n+  \/\/   la(t0, RuntimeAddress(addr))   ->  lui + addi + slli + addi + slli + addi\n+  \/\/   addi(sp, sp, -2 * wordSize)    ->  addi\n+  \/\/   sd(t1, Address(sp, wordSize))  ->  sd\n+  \/\/   jalr(t0)                       ->  jalr\n@@ -1194,0 +1193,28 @@\n+\/\/ RVC: With RVC a call may get 2-byte aligned.\n+\/\/   The offset encoding in jal ranges bits [12, 31], which could span the cache line.\n+\/\/   Patching this unaligned address will make the write operation not atomic.\n+\/\/   Other threads may be running the same piece of code at full speed, causing concurrency issues.\n+\/\/   So we must ensure that it does not span a cache line so that it can be patched.\n+int CallStaticJavaDirectNode::compute_padding(int current_offset) const\n+{\n+  \/\/ to make sure the address of jal 4-byte aligned.\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n+\/\/ RVC: With RVC a call may get 2-byte aligned.\n+\/\/   The offset encoding in jal ranges bits [12, 31], which could span the cache line.\n+\/\/   Patching this unaligned address will make the write operation not atomic.\n+\/\/   Other threads may be running the same piece of code at full speed, causing concurrency issues.\n+\/\/   So we must ensure that it does not span a cache line so that it can be patched.\n+int CallDynamicJavaDirectNode::compute_padding(int current_offset) const\n+{\n+  \/\/ skip the movptr in MacroAssembler::ic_call():\n+  \/\/ lui + addi + slli + addi + slli + addi\n+  \/\/ Though movptr() has already 4-byte aligned with or without RVC,\n+  \/\/ We need to prevent from further changes by explicitly calculating the size.\n+  const int movptr_size = 6 * NativeInstruction::instruction_size;\n+  current_offset += movptr_size;\n+  \/\/ to make sure the address of jal 4-byte aligned.\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n@@ -1205,0 +1232,1 @@\n+  Assembler::CompressibleRegion cr(&_masm);\n@@ -1222,0 +1250,1 @@\n+    Assembler::CompressibleRegion cr(&_masm); \/\/ RVC: nops shall be 2-byte under RVC for alignment purposes.\n@@ -1228,1 +1257,1 @@\n-    return _count * NativeInstruction::instruction_size;\n+    return _count * (UseRVC ? NativeInstruction::compressed_instruction_size : NativeInstruction::instruction_size);\n@@ -1492,0 +1521,1 @@\n+      Assembler::CompressibleRegion cr(&_masm);\n@@ -1512,0 +1542,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2039,0 +2070,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2065,0 +2097,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2477,0 +2510,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2483,0 +2517,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2498,0 +2533,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4443,0 +4479,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4458,0 +4495,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4488,0 +4526,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4519,0 +4558,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4549,0 +4589,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4594,0 +4635,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4878,0 +4920,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4907,0 +4950,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4937,0 +4981,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4967,0 +5012,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -5011,0 +5057,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -5026,0 +5073,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6321,0 +6369,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6336,0 +6385,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6352,0 +6402,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6368,0 +6419,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6383,0 +6435,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6398,0 +6451,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6414,0 +6468,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6429,0 +6484,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6446,0 +6502,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6462,0 +6519,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6478,0 +6536,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6493,0 +6552,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6637,0 +6697,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6788,0 +6849,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6822,0 +6884,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6840,0 +6903,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6874,0 +6938,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7339,0 +7404,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7355,0 +7421,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7371,0 +7438,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7403,0 +7471,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7435,0 +7504,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7451,0 +7521,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7467,0 +7538,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7499,0 +7571,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7700,0 +7773,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7715,0 +7789,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7870,0 +7945,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8024,0 +8100,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8041,0 +8118,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8137,0 +8215,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8173,0 +8252,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8191,0 +8271,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8227,0 +8308,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8245,0 +8327,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8263,0 +8346,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -9799,0 +9883,1 @@\n+  ins_alignment(4);\n@@ -9818,0 +9903,1 @@\n+  ins_alignment(4);\n@@ -10398,0 +10484,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":98,"deletions":11,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -109,0 +109,6 @@\n+  \/\/ compressed instruction extension\n+  if (UseRVC && !(_features & CPU_C)) {\n+    warning(\"RVC is not supported on this CPU\");\n+    FLAG_SET_DEFAULT(UseRVC, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -332,1 +332,1 @@\n-#if defined(X86) && !defined(AMD64)\n+#if (defined(X86) && !defined(AMD64)) || defined(RISCV)\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}