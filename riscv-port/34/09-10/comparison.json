{"files":[{"patch":"@@ -2014,7 +2014,7 @@\n-\/\/   1. When UseRVC is enabled, 32-bit instructions under 'CompressibleRegion's will be\n-\/\/      transformed to 16-bit instructions if compressible.\n-\/\/   2. RVC instructions in Assembler always begin with 'c_' prefix, as 'c_li',\n-\/\/      but most of time we have no need to explicitly use these instructions.\n-\/\/   3. We introduce 'CompressibleRegion' to hint instructions in this Region's RTTI range\n-\/\/      are qualified to change to their 2-byte versions.\n-\/\/      An example:\n+\/\/ 1. When UseRVC is enabled, 32-bit instructions under 'CompressibleRegion's will be\n+\/\/    transformed to 16-bit instructions if compressible.\n+\/\/ 2. RVC instructions in Assembler always begin with 'c_' prefix, as 'c_li',\n+\/\/    but most of time we have no need to explicitly use these instructions.\n+\/\/ 3. We introduce 'CompressibleRegion' to hint instructions in this Region's RTTI range\n+\/\/    are qualified to change to their 2-byte versions.\n+\/\/    An example:\n@@ -2022,2 +2022,2 @@\n-\/\/        CompressibleRegion cr(_masm);\n-\/\/        __ andr(...);      \/\/ this instruction could change to c.and if able to\n+\/\/      CompressibleRegion cr(_masm);\n+\/\/      __ andr(...);      \/\/ this instruction could change to c.and if able to\n@@ -2025,2 +2025,2 @@\n-\/\/   4. Using -XX:PrintAssemblyOptions=no-aliases could print RVC instructions instead of\n-\/\/      normal ones.\n+\/\/ 4. Using -XX:PrintAssemblyOptions=no-aliases could print RVC instructions instead of\n+\/\/    normal ones.\n@@ -2052,17 +2052,0 @@\n-  \/\/ RVC: extract a 16-bit instruction.\n-  static inline uint16_t c_extract(uint16_t val, unsigned msb, unsigned lsb) {\n-    assert_cond(msb >= lsb && msb <= 15);\n-    unsigned nbits = msb - lsb + 1;\n-    uint16_t mask = (1U << nbits) - 1;\n-    uint16_t result = val >> lsb;\n-    result &= mask;\n-    return result;\n-  }\n-\n-  static inline int16_t c_sextract(uint16_t val, unsigned msb, unsigned lsb) {\n-    assert_cond(msb >= lsb && msb <= 15);\n-    int16_t result = val << (15 - msb);\n-    result >>= (15 - msb + lsb);\n-    return result;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -1328,1 +1328,1 @@\n-  \/\/   See CallDynamicJavaDirectNode::compute_padding() for more info.\n+  \/\/   See CallStaticJavaDirectNode::compute_padding() for more info.\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1194,1 +1194,1 @@\n-\/\/   The offset encoding in jal ranges bits [12, 31], which could span the cache line.\n+\/\/   The offset encoding in jal ranges bits [12, 31] could span the cache line.\n@@ -1204,5 +1204,1 @@\n-\/\/ RVC: With RVC a call may get 2-byte aligned.\n-\/\/   The offset encoding in jal ranges bits [12, 31], which could span the cache line.\n-\/\/   Patching this unaligned address will make the write operation not atomic.\n-\/\/   Other threads may be running the same piece of code at full speed, causing concurrency issues.\n-\/\/   So we must ensure that it does not span a cache line so that it can be patched.\n+\/\/ RVC: See CallStaticJavaDirectNode::compute_padding() for more info.\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -109,6 +109,0 @@\n-  \/\/ compressed instruction extension\n-  if (UseRVC && !(_features & CPU_C)) {\n-    warning(\"RVC is not supported on this CPU\");\n-    FLAG_SET_DEFAULT(UseRVC, false);\n-  }\n-\n@@ -130,0 +124,5 @@\n+  if (UseRVC && !(_features & CPU_C)) {\n+    warning(\"RVC is not supported on this CPU\");\n+    FLAG_SET_DEFAULT(UseRVC, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"}]}