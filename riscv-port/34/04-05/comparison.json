{"files":[{"patch":"@@ -82,6 +82,1 @@\n-void Assembler::li(Register Rd, int64_t imm) {\n-  CHECK_CEXT_AND_COMPRESSIBLE(is_imm_in_range(imm, 6, 0) && Rd != x0) {\n-    c_li(Rd, imm);\n-    return;\n-  }\n-\n+void Assembler::_li(Register Rd, int64_t imm) {\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -258,1 +258,0 @@\n-  #include \"assembler_riscv_c.hpp\"\n@@ -305,1 +304,1 @@\n-  void li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n+  void _li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n@@ -382,6 +381,2 @@\n-  void halt() {\n-    CHECK_CEXT() {\n-      emit_int16(0);\n-    } else {\n-      emit_int32(0);\n-    }\n+  void _halt() {\n+    emit_int32(0);\n@@ -391,1 +386,1 @@\n-#define INSN(NAME, op, funct3, funct7, C)                       \\\n+#define INSN(NAME, op, funct3, funct7)                          \\\n@@ -393,1 +388,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs1, Rs2)                    \\\n@@ -404,28 +398,28 @@\n-  INSN(add,   0b0110011, 0b000, 0b0000000, COMPRESSIBLE);\n-  INSN(sub,   0b0110011, 0b000, 0b0100000, COMPRESSIBLE);\n-  INSN(andr,  0b0110011, 0b111, 0b0000000, COMPRESSIBLE);\n-  INSN(orr,   0b0110011, 0b110, 0b0000000, COMPRESSIBLE);\n-  INSN(xorr,  0b0110011, 0b100, 0b0000000, COMPRESSIBLE);\n-  INSN(sll,   0b0110011, 0b001, 0b0000000, NOT_COMPRESSIBLE);\n-  INSN(sra,   0b0110011, 0b101, 0b0100000, NOT_COMPRESSIBLE);\n-  INSN(srl,   0b0110011, 0b101, 0b0000000, NOT_COMPRESSIBLE);\n-  INSN(slt,   0b0110011, 0b010, 0b0000000, NOT_COMPRESSIBLE);\n-  INSN(sltu,  0b0110011, 0b011, 0b0000000, NOT_COMPRESSIBLE);\n-  INSN(addw,  0b0111011, 0b000, 0b0000000, COMPRESSIBLE);\n-  INSN(subw,  0b0111011, 0b000, 0b0100000, COMPRESSIBLE);\n-  INSN(sllw,  0b0111011, 0b001, 0b0000000, NOT_COMPRESSIBLE);\n-  INSN(sraw,  0b0111011, 0b101, 0b0100000, NOT_COMPRESSIBLE);\n-  INSN(srlw,  0b0111011, 0b101, 0b0000000, NOT_COMPRESSIBLE);\n-  INSN(mul,   0b0110011, 0b000, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(mulh,  0b0110011, 0b001, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(mulhsu,0b0110011, 0b010, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(mulhu, 0b0110011, 0b011, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(mulw,  0b0111011, 0b000, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(div,   0b0110011, 0b100, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(divu,  0b0110011, 0b101, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(divw,  0b0111011, 0b100, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(divuw, 0b0111011, 0b101, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(rem,   0b0110011, 0b110, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(remu,  0b0110011, 0b111, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(remw,  0b0111011, 0b110, 0b0000001, NOT_COMPRESSIBLE);\n-  INSN(remuw, 0b0111011, 0b111, 0b0000001, NOT_COMPRESSIBLE);\n+  INSN(_add,  0b0110011, 0b000, 0b0000000);\n+  INSN(_sub,  0b0110011, 0b000, 0b0100000);\n+  INSN(_andr, 0b0110011, 0b111, 0b0000000);\n+  INSN(_orr,  0b0110011, 0b110, 0b0000000);\n+  INSN(_xorr, 0b0110011, 0b100, 0b0000000);\n+  INSN(sll,   0b0110011, 0b001, 0b0000000);\n+  INSN(sra,   0b0110011, 0b101, 0b0100000);\n+  INSN(srl,   0b0110011, 0b101, 0b0000000);\n+  INSN(slt,   0b0110011, 0b010, 0b0000000);\n+  INSN(sltu,  0b0110011, 0b011, 0b0000000);\n+  INSN(_addw, 0b0111011, 0b000, 0b0000000);\n+  INSN(_subw, 0b0111011, 0b000, 0b0100000);\n+  INSN(sllw,  0b0111011, 0b001, 0b0000000);\n+  INSN(sraw,  0b0111011, 0b101, 0b0100000);\n+  INSN(srlw,  0b0111011, 0b101, 0b0000000);\n+  INSN(mul,   0b0110011, 0b000, 0b0000001);\n+  INSN(mulh,  0b0110011, 0b001, 0b0000001);\n+  INSN(mulhsu,0b0110011, 0b010, 0b0000001);\n+  INSN(mulhu, 0b0110011, 0b011, 0b0000001);\n+  INSN(mulw,  0b0111011, 0b000, 0b0000001);\n+  INSN(div,   0b0110011, 0b100, 0b0000001);\n+  INSN(divu,  0b0110011, 0b101, 0b0000001);\n+  INSN(divw,  0b0111011, 0b100, 0b0000001);\n+  INSN(divuw, 0b0111011, 0b101, 0b0000001);\n+  INSN(rem,   0b0110011, 0b110, 0b0000001);\n+  INSN(remu,  0b0110011, 0b111, 0b0000001);\n+  INSN(remw,  0b0111011, 0b110, 0b0000001);\n+  INSN(remuw, 0b0111011, 0b111, 0b0000001);\n@@ -443,1 +437,1 @@\n-#define INSN(NAME, op, funct3, C)                                                                  \\\n+#define INSN(NAME, op, funct3)                                                                     \\\n@@ -446,1 +440,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs, offset)                                                     \\\n@@ -455,1 +448,13 @@\n-  }                                                                                                \\\n+  }\n+\n+  INSN(lb,  0b0000011, 0b000);\n+  INSN(lbu, 0b0000011, 0b100);\n+  INSN(lh,  0b0000011, 0b001);\n+  INSN(lhu, 0b0000011, 0b101);\n+  INSN(_lw, 0b0000011, 0b010);\n+  INSN(lwu, 0b0000011, 0b110);\n+  INSN(_ld, 0b0000011, 0b011);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n@@ -501,7 +506,7 @@\n-  INSN(lb,  0b0000011, 0b000, NOT_COMPRESSIBLE);\n-  INSN(lbu, 0b0000011, 0b100, NOT_COMPRESSIBLE);\n-  INSN(lh,  0b0000011, 0b001, NOT_COMPRESSIBLE);\n-  INSN(lhu, 0b0000011, 0b101, NOT_COMPRESSIBLE);\n-  INSN(lw,  0b0000011, 0b010, COMPRESSIBLE);\n-  INSN(lwu, 0b0000011, 0b110, NOT_COMPRESSIBLE);\n-  INSN(ld,  0b0000011, 0b011, COMPRESSIBLE);\n+  INSN(lb);\n+  INSN(lbu);\n+  INSN(lh);\n+  INSN(lhu);\n+  INSN(lw);\n+  INSN(lwu);\n+  INSN(ld);\n@@ -511,1 +516,1 @@\n-#define INSN(NAME, op, funct3, C)                                                                  \\\n+#define INSN(NAME, op, funct3)                                                                     \\\n@@ -514,1 +519,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs, offset)                                                     \\\n@@ -523,1 +527,8 @@\n-  }                                                                                                \\\n+  }\n+\n+  INSN(flw,  0b0000111, 0b010);\n+  INSN(_fld, 0b0000111, 0b011);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n@@ -561,2 +572,2 @@\n-  INSN(flw, 0b0000111, 0b010, NOT_COMPRESSIBLE);\n-  INSN(fld, 0b0000111, 0b011, COMPRESSIBLE);\n+  INSN(flw);\n+  INSN(fld);\n@@ -565,1 +576,1 @@\n-#define INSN(NAME, op, funct3, C)                                                                        \\\n+#define INSN(NAME, op, funct3)                                                                           \\\n@@ -568,1 +579,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rs1, Rs2, offset)                                                         \\\n@@ -584,1 +594,12 @@\n-  }                                                                                                      \\\n+  }\n+\n+  INSN(_beq, 0b1100011, 0b000);\n+  INSN(_bne, 0b1100011, 0b001);\n+  INSN(bge,  0b1100011, 0b101);\n+  INSN(bgeu, 0b1100011, 0b111);\n+  INSN(blt,  0b1100011, 0b100);\n+  INSN(bltu, 0b1100011, 0b110);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                       \\\n@@ -595,6 +616,6 @@\n-  INSN(beq,  0b1100011, 0b000, COMPRESSIBLE);\n-  INSN(bne,  0b1100011, 0b001, COMPRESSIBLE);\n-  INSN(bge,  0b1100011, 0b101, NOT_COMPRESSIBLE);\n-  INSN(bgeu, 0b1100011, 0b111, NOT_COMPRESSIBLE);\n-  INSN(blt,  0b1100011, 0b100, NOT_COMPRESSIBLE);\n-  INSN(bltu, 0b1100011, 0b110, NOT_COMPRESSIBLE);\n+  INSN(beq);\n+  INSN(bne);\n+  INSN(bge);\n+  INSN(bgeu);\n+  INSN(blt);\n+  INSN(bltu);\n@@ -618,1 +639,1 @@\n-#define INSN(NAME, REGISTER, op, funct3, C)                                                                 \\\n+#define INSN(NAME, REGISTER, op, funct3)                                                                    \\\n@@ -621,1 +642,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rs1, Rs2, offset)                                                            \\\n@@ -634,0 +654,11 @@\n+\n+  INSN(sb,   Register,      0b0100011, 0b000);\n+  INSN(sh,   Register,      0b0100011, 0b001);\n+  INSN(_sw,  Register,      0b0100011, 0b010);\n+  INSN(_sd,  Register,      0b0100011, 0b011);\n+  INSN(fsw,  FloatRegister, 0b0100111, 0b010);\n+  INSN(_fsd, FloatRegister, 0b0100111, 0b011);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                                                                \\\n@@ -638,6 +669,6 @@\n-  INSN(sb,  Register,      0b0100011, 0b000, NOT_COMPRESSIBLE);\n-  INSN(sh,  Register,      0b0100011, 0b001, NOT_COMPRESSIBLE);\n-  INSN(sw,  Register,      0b0100011, 0b010, COMPRESSIBLE);\n-  INSN(sd,  Register,      0b0100011, 0b011, COMPRESSIBLE);\n-  INSN(fsw, FloatRegister, 0b0100111, 0b010, NOT_COMPRESSIBLE);\n-  INSN(fsd, FloatRegister, 0b0100111, 0b011, COMPRESSIBLE);\n+  INSN(sb,  Register);\n+  INSN(sh,  Register);\n+  INSN(sw,  Register);\n+  INSN(sd,  Register);\n+  INSN(fsw, FloatRegister);\n+  INSN(fsd, FloatRegister);\n@@ -770,1 +801,1 @@\n-#define INSN(NAME, op, C)                                                                     \\\n+#define INSN(NAME, op)                                                                        \\\n@@ -773,1 +804,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rd, offset)                                                    \\\n@@ -782,1 +812,7 @@\n-  }                                                                                           \\\n+  }\n+\n+  INSN(_jal, 0b1101111);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                            \\\n@@ -800,1 +836,1 @@\n-  INSN(jal, 0b1101111, COMPRESSIBLE);\n+  INSN(jal);\n@@ -806,1 +842,1 @@\n-#define INSN(NAME, op, funct, C)                                                           \\\n+#define INSN(NAME, op, funct)                                                              \\\n@@ -809,1 +845,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs, offset)                                             \\\n@@ -820,1 +855,1 @@\n-  INSN(jalr, 0b1100111, 0b000, COMPRESSIBLE);\n+  INSN(_jalr, 0b1100111, 0b000);\n@@ -843,1 +878,1 @@\n-#define INSN(NAME, op, funct3, funct7, C)                   \\\n+#define INSN(NAME, op, funct3, funct7)                      \\\n@@ -845,1 +880,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME)                              \\\n@@ -855,3 +889,4 @@\n-  INSN(fence_i, 0b0001111, 0b001, 0b000000000000, NOT_COMPRESSIBLE);\n-  INSN(ecall,   0b1110011, 0b000, 0b000000000000, NOT_COMPRESSIBLE);\n-  INSN(ebreak,  0b1110011, 0b000, 0b000000000001, COMPRESSIBLE);\n+  INSN(fence_i, 0b0001111, 0b001, 0b000000000000);\n+  INSN(ecall,   0b1110011, 0b000, 0b000000000000);\n+  INSN(_ebreak, 0b1110011, 0b000, 0b000000000001);\n+\n@@ -953,1 +988,1 @@\n-#define INSN(NAME, op, funct3, C)                                                           \\\n+#define INSN(NAME, op, funct3)                                                              \\\n@@ -956,1 +991,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs1, imm)                                                \\\n@@ -966,6 +1000,6 @@\n-  INSN(addi,      0b0010011, 0b000, COMPRESSIBLE);\n-  INSN(slti,      0b0010011, 0b010, NOT_COMPRESSIBLE);\n-  INSN(addiw,     0b0011011, 0b000, COMPRESSIBLE);\n-  INSN(and_imm12, 0b0010011, 0b111, COMPRESSIBLE);\n-  INSN(ori,       0b0010011, 0b110, NOT_COMPRESSIBLE);\n-  INSN(xori,      0b0010011, 0b100, NOT_COMPRESSIBLE);\n+  INSN(_addi,      0b0010011, 0b000);\n+  INSN(slti,       0b0010011, 0b010);\n+  INSN(_addiw,     0b0011011, 0b000);\n+  INSN(_and_imm12, 0b0010011, 0b111);\n+  INSN(ori,        0b0010011, 0b110);\n+  INSN(xori,       0b0010011, 0b100);\n@@ -992,1 +1026,1 @@\n-#define INSN(NAME, op, funct3, funct6, C)                                \\\n+#define INSN(NAME, op, funct3, funct6)                                   \\\n@@ -995,1 +1029,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rd, Rs1, shamt)                           \\\n@@ -1006,3 +1039,3 @@\n-  INSN(slli,  0b0010011, 0b001, 0b000000, COMPRESSIBLE);\n-  INSN(srai,  0b0010011, 0b101, 0b010000, COMPRESSIBLE);\n-  INSN(srli,  0b0010011, 0b101, 0b000000, COMPRESSIBLE);\n+  INSN(_slli, 0b0010011, 0b001, 0b000000);\n+  INSN(_srai, 0b0010011, 0b101, 0b010000);\n+  INSN(_srli, 0b0010011, 0b101, 0b000000);\n@@ -1033,1 +1066,1 @@\n-#define INSN(NAME, op, C)                                               \\\n+#define INSN(NAME, op)                                                  \\\n@@ -1035,1 +1068,0 @@\n-    EMIT_MAY_COMPRESS(C, NAME, Rd, imm)                                 \\\n@@ -1045,2 +1077,2 @@\n-  INSN(lui,   0b0110111, COMPRESSIBLE);\n-  INSN(auipc, 0b0010111, NOT_COMPRESSIBLE);\n+  INSN(_lui,  0b0110111);\n+  INSN(auipc, 0b0010111);\n@@ -1278,0 +1310,968 @@\n+  \/\/ ---------------------------------------------------------------------------------\n+  \/\/ RVC: If an instruction is compressible, then\n+  \/\/   we will implicitly emit a 16-bit compressed instruction instead of the 32-bit\n+  \/\/   instruction in Assembler. All below logic follows Chapter -\n+  \/\/   \"C\" Standard Extension for Compressed Instructions, Version 2.0.\n+  \/\/   We can get code size reduction and performance improvement with this extension,\n+  \/\/   considering the reduction of instruction size and the code density increment.\n+\n+  \/\/ Note:\n+  \/\/   1. When UseRVC is enabled, 32-bit instructions under 'CompressibleRegion's will be\n+  \/\/      transformed to 16-bit instructions if compressible.\n+  \/\/   2. RVC instructions in Assembler always begin with 'c_' prefix, as 'c_li',\n+  \/\/      but most of time we have no need to explicitly use these instructions.\n+  \/\/   3. We introduce 'CompressibleRegion' to hint instructions in this Region's RTTI range\n+  \/\/      are qualified to change to their 2-byte versions.\n+  \/\/      An example:\n+  \/\/\n+  \/\/        CompressibleRegion cr(_masm);\n+  \/\/        __ andr(...);      \/\/ this instruction could change to c.and if able to\n+  \/\/\n+  \/\/   4. Using -XX:PrintAssemblyOptions=no-aliases could print RVC instructions instead of\n+  \/\/      normal ones.\n+  \/\/\n+\n+private:\n+  bool _in_compressible_region;\n+public:\n+  bool in_compressible_region() const { return _in_compressible_region; }\n+  void set_in_compressible_region(bool b) { _in_compressible_region = b; }\n+public:\n+\n+\/\/ RVC: a compressible region\n+  class CompressibleRegion : public StackObj {\n+  protected:\n+    Assembler *_masm;\n+    bool _prev_in_compressible_region;\n+  public:\n+    CompressibleRegion(Assembler *_masm)\n+    : _masm(_masm)\n+    , _prev_in_compressible_region(_masm->in_compressible_region()) {\n+      _masm->set_in_compressible_region(true);\n+    }\n+    ~CompressibleRegion() {\n+      _masm->set_in_compressible_region(_prev_in_compressible_region);\n+    }\n+  };\n+\n+  \/\/ RVC: extract a 16-bit instruction.\n+  static inline uint16_t c_extract(uint16_t val, unsigned msb, unsigned lsb) {\n+    assert_cond(msb >= lsb && msb <= 15);\n+    unsigned nbits = msb - lsb + 1;\n+    uint16_t mask = (1U << nbits) - 1;\n+    uint16_t result = val >> lsb;\n+    result &= mask;\n+    return result;\n+  }\n+\n+  static inline int16_t c_sextract(uint16_t val, unsigned msb, unsigned lsb) {\n+    assert_cond(msb >= lsb && msb <= 15);\n+    int16_t result = val << (15 - msb);\n+    result >>= (15 - msb + lsb);\n+    return result;\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction.\n+  static void c_patch(address a, unsigned msb, unsigned lsb, uint16_t val) {\n+    assert_cond(a != NULL);\n+    assert_cond(msb >= lsb && msb <= 15);\n+    unsigned nbits = msb - lsb + 1;\n+    guarantee(val < (1U << nbits), \"Field too big for insn\");\n+    uint16_t mask = (1U << nbits) - 1;\n+    val <<= lsb;\n+    mask <<= lsb;\n+    uint16_t target = *(uint16_t *)a;\n+    target &= ~mask;\n+    target |= val;\n+    *(uint16_t *)a = target;\n+  }\n+\n+  static void c_patch(address a, unsigned bit, uint16_t val) {\n+    c_patch(a, bit, bit, val);\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction with a general purpose register ranging [0, 31] (5 bits)\n+  static void c_patch_reg(address a, unsigned lsb, Register reg) {\n+    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction with a general purpose register ranging [8, 15] (3 bits)\n+  static void c_patch_compressed_reg(address a, unsigned lsb, Register reg) {\n+    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction with a float register ranging [0, 31] (5 bits)\n+  static void c_patch_reg(address a, unsigned lsb, FloatRegister reg) {\n+    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n+  }\n+\n+  \/\/ RVC: patch a 16-bit instruction with a float register ranging [8, 15] (3 bits)\n+  static void c_patch_compressed_reg(address a, unsigned lsb, FloatRegister reg) {\n+    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n+  }\n+\n+\/\/ --------------  RVC Instruction Definitions  --------------\n+\n+  void c_nop() {\n+    c_addi(x0, 0);\n+  }\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi,   0b000, 0b01);\n+  INSN(c_addiw,  0b001, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(int32_t imm) {                                                                   \\\n+    assert_cond(is_imm_in_range(imm, 10, 0));                                                \\\n+    assert_cond((imm & 0b1111) == 0);                                                        \\\n+    assert_cond(imm != 0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n+    c_patch((address)&insn, 4, 3, (imm & right_n_bits(9)) >> 7);                             \\\n+    c_patch((address)&insn, 5, 5, (imm & nth_bit(6)) >> 6);                                  \\\n+    c_patch((address)&insn, 6, 6, (imm & nth_bit(4)) >> 4);                                  \\\n+    c_patch_reg((address)&insn, 7, sp);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(9)) >> 9);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi16sp, 0b011, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 10, 0));                                      \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    assert_cond(uimm != 0);                                                                  \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd);                                           \\\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(3)) >> 3);                                 \\\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n+    c_patch((address)&insn, 10, 7, (uimm & right_n_bits(10)) >> 6);                          \\\n+    c_patch((address)&insn, 12, 11, (uimm & right_n_bits(6)) >> 4);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi4spn, 0b000, 0b00);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n+    assert_cond(shamt != 0);                                                                 \\\n+    assert_cond(Rd_Rs1 != x0);                                                               \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_slli, 0b000, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n+    assert_cond(shamt != 0);                                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n+    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_srli, 0b100, 0b00, 0b01);\n+  INSN(c_srai, 0b100, 0b01, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_andi, 0b100, 0b10, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct6, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rs2);                                          \\\n+    c_patch((address)&insn, 6, 5, funct2);                                                   \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 15, 10, funct6);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_sub,  0b100011, 0b00, 0b01);\n+  INSN(c_xor,  0b100011, 0b01, 0b01);\n+  INSN(c_or,   0b100011, 0b10, 0b01);\n+  INSN(c_and,  0b100011, 0b11, 0b01);\n+  INSN(c_subw, 0b100111, 0b00, 0b01);\n+  INSN(c_addw, 0b100111, 0b01, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct4, op)                                                               \\\n+  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n+    assert_cond(Rd_Rs1 != x0);                                                               \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_mv,  0b1000, 0b10);\n+  INSN(c_add, 0b1001, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct4, op)                                                               \\\n+  void NAME(Register Rs1) {                                                                  \\\n+    assert_cond(Rs1 != x0);                                                                  \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, x0);                                                      \\\n+    c_patch_reg((address)&insn, 7, Rs1);                                                     \\\n+    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_jr,   0b1000, 0b10);\n+  INSN(c_jalr, 0b1001, 0b10);\n+\n+#undef INSN\n+\n+  typedef void (Assembler::* j_c_insn)(address dest);\n+  typedef void (Assembler::* compare_and_branch_c_insn)(Register Rs1, address dest);\n+\n+  void wrap_label(Label &L, j_c_insn insn) {\n+    if (L.is_bound()) {\n+      (this->*insn)(target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(pc());\n+    }\n+  }\n+\n+  void wrap_label(Label &L, Register r, compare_and_branch_c_insn insn) {\n+    if (L.is_bound()) {\n+      (this->*insn)(r, target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(r, pc());\n+    }\n+  }\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(int32_t offset) {                                                                \\\n+    assert_cond(is_imm_in_range(offset, 11, 1));                                             \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (offset & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 5, 3, (offset & right_n_bits(4)) >> 1);                          \\\n+    c_patch((address)&insn, 6, 6, (offset & nth_bit(7)) >> 7);                               \\\n+    c_patch((address)&insn, 7, 7, (offset & nth_bit(6)) >> 6);                               \\\n+    c_patch((address)&insn, 8, 8, (offset & nth_bit(10)) >> 10);                             \\\n+    c_patch((address)&insn, 10, 9, (offset & right_n_bits(10)) >> 8);                        \\\n+    c_patch((address)&insn, 11, 11, (offset & nth_bit(4)) >> 4);                             \\\n+    c_patch((address)&insn, 12, 12, (offset & nth_bit(11)) >> 11);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }                                                                                          \\\n+  void NAME(address dest) {                                                                  \\\n+    assert_cond(dest != NULL);                                                               \\\n+    int64_t distance = dest - pc();                                                          \\\n+    assert_cond(is_imm_in_range(distance, 11, 1));                                           \\\n+    c_j(distance);                                                                           \\\n+  }                                                                                          \\\n+  void NAME(Label &L) {                                                                      \\\n+    wrap_label(L, &Assembler::NAME);                                                         \\\n+  }\n+\n+  INSN(c_j, 0b101, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rs1, int32_t imm) {                                                     \\\n+    assert_cond(is_imm_in_range(imm, 8, 1));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n+    c_patch((address)&insn, 4, 3, (imm & right_n_bits(3)) >> 1);                             \\\n+    c_patch((address)&insn, 6, 5, (imm & right_n_bits(8)) >> 6);                             \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 11, 10, (imm & right_n_bits(5)) >> 3);                           \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(8)) >> 8);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }                                                                                          \\\n+  void NAME(Register Rs1, address dest) {                                                    \\\n+    assert_cond(dest != NULL);                                                               \\\n+    int64_t distance = dest - pc();                                                          \\\n+    assert_cond(is_imm_in_range(distance, 8, 1));                                            \\\n+    NAME(Rs1, distance);                                                                     \\\n+  }                                                                                          \\\n+  void NAME(Register Rs1, Label &L) {                                                        \\\n+    wrap_label(L, Rs1, &Assembler::NAME);                                                    \\\n+  }\n+\n+  INSN(c_beqz, 0b110, 0b01);\n+  INSN(c_bnez, 0b111, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    assert_cond(is_imm_in_range(imm, 18, 0));                                                \\\n+    assert_cond((imm & 0xfff) == 0);                                                         \\\n+    assert_cond(imm != 0);                                                                   \\\n+    assert_cond(Rd != x0 && Rd != x2);                                                       \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(17)) >> 12);                           \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(17)) >> 17);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lui, 0b011, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    assert_cond(Rd != x0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & right_n_bits(6)) >> 5);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_li, 0b010, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE, CHECK)                                         \\\n+  void NAME(REGISTER_TYPE Rd, uint32_t uimm) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    IF(CHECK, assert_cond(Rd != x0);)                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 4, 2, (uimm & right_n_bits(9)) >> 6);                            \\\n+    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(5)) >> 3);                            \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+#define IF(BOOL, ...)       IF_##BOOL(__VA_ARGS__)\n+#define IF_true(code)       code\n+#define IF_false(code)\n+\n+  INSN(c_ldsp,  0b011, 0b10, Register,      true);\n+  INSN(c_fldsp, 0b001, 0b10, FloatRegister, false);\n+\n+#undef IF_false\n+#undef IF_true\n+#undef IF\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n+  void NAME(REGISTER_TYPE Rd_Rs2, Register Rs1, uint32_t uimm) {                             \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n+    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_ld,  0b011, 0b00, Register);\n+  INSN(c_sd,  0b111, 0b00, Register);\n+  INSN(c_fld, 0b001, 0b00, FloatRegister);\n+  INSN(c_fsd, 0b101, 0b00, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n+  void NAME(REGISTER_TYPE Rs2, uint32_t uimm) {                                              \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch((address)&insn, 9, 7, (uimm & right_n_bits(9)) >> 6);                            \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_sdsp,  0b111, 0b10, Register);\n+  INSN(c_fsdsp, 0b101, 0b10, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rs2, uint32_t uimm) {                                                   \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch((address)&insn, 8, 7, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch((address)&insn, 12, 9, (uimm & right_n_bits(6)) >> 2);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_swsp, 0b110, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    assert_cond(Rd != x0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 3, 2, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch((address)&insn, 6, 4, (uimm & right_n_bits(5)) >> 2);                            \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lwsp, 0b010, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs2, Register Rs1, uint32_t uimm) {                                  \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 7, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(6)) >> 6);                                 \\\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lw, 0b010, 0b00);\n+  INSN(c_sw, 0b110, 0b00);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME() {                                                                              \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 11, 2, 0x0);                                                     \\\n+    c_patch((address)&insn, 12, 12, 0b1);                                                    \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_ebreak, 0b100, 0b10);\n+\n+#undef INSN\n+\n+\/\/ --------------  RVC Transformation Functions  --------------\n+\n+#define CHECK_COND(...)                    if (__VA_ARGS__) {\n+#define CHECK_RVC()                        CHECK_COND(UseRVC && in_compressible_region())\n+#define CHECK_RETURN                       return; }\n+\n+\/\/ --------------------------\n+\/\/ Register instructions\n+\/\/ --------------------------\n+\/\/ add -> c.add\n+#define INSN(NAME)                                                                             \\\n+  void NAME(Register Rd, Register Rs1, Register Rs2) {                                         \\\n+    CHECK_RVC()                                                                                \\\n+      Register src = noreg;                                                                    \\\n+      CHECK_COND(Rs1 != x0 && Rs2 != x0 && ((src = Rs1, Rs2 == Rd) || (src = Rs2, Rs1 == Rd))) \\\n+        c_add(Rd, src);                                                                        \\\n+      CHECK_RETURN                                                                             \\\n+    }                                                                                          \\\n+    _##NAME(Rd, Rs1, Rs2);                                                                     \\\n+  }\n+\n+  INSN(add);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ sub\/subw -> c.sub\/c.subw\n+#define INSN(NAME, C_NAME)                                                                   \\\n+  void NAME(Register Rd, Register Rs1, Register Rs2) {                                       \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(Rd == Rs1 && Rd->is_compressed_valid() && Rs2->is_compressed_valid())       \\\n+        C_NAME(Rd, Rs2);                                                                     \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs1, Rs2);                                                                   \\\n+  }\n+\n+  INSN(sub,  c_sub);\n+  INSN(subw, c_subw);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ xor\/or\/and\/addw -> c.xor\/c.or\/c.and\/c.addw\n+#define INSN(NAME, C_NAME)                                                                   \\\n+  void NAME(Register Rd, Register Rs1, Register Rs2) {                                       \\\n+    CHECK_RVC()                                                                              \\\n+      Register src = noreg;                                                                  \\\n+      CHECK_COND(Rs1->is_compressed_valid() && Rs2->is_compressed_valid() &&                 \\\n+        ((src = Rs1, Rs2 == Rd) || (src = Rs2, Rs1 == Rd)))                                  \\\n+        C_NAME(Rd, src);                                                                     \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs1, Rs2);                                                                   \\\n+  }\n+\n+  INSN(andr, c_and);\n+  INSN(orr,  c_or);\n+  INSN(xorr, c_xor);\n+  INSN(addw, c_addw);\n+\n+#undef INSN\n+\n+private:\n+\/\/ some helper functions\n+#define FUNC(NAME, funct3, bits)                                                             \\\n+  bool NAME(Register rs1, Register rd_rs2, int32_t imm12, bool ld) {                         \\\n+    return rs1 == sp &&                                                                      \\\n+      is_unsigned_imm_in_range(imm12, bits, 0) &&                                            \\\n+      (intx(imm12) & funct3) == 0x0 &&                                                       \\\n+      (!ld || rd_rs2 != x0);                                                                 \\\n+  }                                                                                          \\\n+\n+  FUNC(is_c_ldsdsp,  0b111, 9);\n+  FUNC(is_c_lwswsp,  0b011, 8);\n+\n+#undef FUNC\n+\n+#define FUNC(NAME, funct3, bits)                                                             \\\n+  bool NAME(Register rs1, int32_t imm12) {                                                   \\\n+    return rs1 == sp &&                                                                      \\\n+      is_unsigned_imm_in_range(imm12, bits, 0) &&                                            \\\n+      (intx(imm12) & funct3) == 0x0;                                                         \\\n+  }                                                                                          \\\n+\n+  FUNC(is_c_fldsdsp, 0b111, 9);\n+\n+#undef FUNC\n+\n+#define FUNC(NAME, REG_TYPE, funct3, bits)                                                   \\\n+  bool NAME(Register rs1, REG_TYPE rd_rs2, int32_t imm12) {                                  \\\n+    return rs1->is_compressed_valid() &&                                                     \\\n+      rd_rs2->is_compressed_valid() &&                                                       \\\n+      is_unsigned_imm_in_range(imm12, bits, 0) &&                                            \\\n+      (intx(imm12) & funct3) == 0x0;                                                         \\\n+  }                                                                                          \\\n+\n+  FUNC(is_c_ldsd,  Register,      0b111, 8);\n+  FUNC(is_c_lwsw,  Register,      0b011, 7);\n+  FUNC(is_c_fldsd, FloatRegister, 0b111, 8);\n+\n+#undef FUNC\n+\n+public:\n+\/\/ --------------------------\n+\/\/ Load\/store register\n+\/\/ --------------------------\n+\/\/ lw -> c.lwsp\/c.lw\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(is_c_lwswsp(Rs, Rd, offset, true))                                          \\\n+        c_lwsp(Rd, offset);                                                                  \\\n+      CHECK_RETURN                                                                           \\\n+      else CHECK_COND(is_c_lwsw(Rs, Rd, offset))                                             \\\n+        c_lw(Rd, Rs, offset);                                                                \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs, offset);                                                                 \\\n+  }\n+\n+  INSN(lw);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ ld -> c.ldsp\/c.ld\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(is_c_ldsdsp(Rs, Rd, offset, true))                                          \\\n+        c_ldsp(Rd, offset);                                                                  \\\n+      CHECK_RETURN                                                                           \\\n+      else CHECK_COND(is_c_ldsd(Rs, Rd, offset))                                             \\\n+        c_ld(Rd, Rs, offset);                                                                \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs, offset);                                                                 \\\n+  }\n+\n+  INSN(ld);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ fld -> c.fldsp\/c.fld\n+#define INSN(NAME)                                                                           \\\n+  void NAME(FloatRegister Rd, Register Rs, const int32_t offset) {                           \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(is_c_fldsdsp(Rs, offset))                                                   \\\n+        c_fldsp(Rd, offset);                                                                 \\\n+      CHECK_RETURN                                                                           \\\n+      else CHECK_COND(is_c_fldsd(Rs, Rd, offset))                                            \\\n+        c_fld(Rd, Rs, offset);                                                               \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs, offset);                                                                 \\\n+  }\n+\n+  INSN(fld);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ sd -> c.sdsp\/c.sd\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(is_c_ldsdsp(Rs, Rd, offset, false))                                         \\\n+        c_sdsp(Rd, offset);                                                                  \\\n+      CHECK_RETURN                                                                           \\\n+      else CHECK_COND(is_c_ldsd(Rs, Rd, offset))                                             \\\n+        c_sd(Rd, Rs, offset);                                                                \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs, offset);                                                                 \\\n+  }\n+\n+  INSN(sd);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ sw -> c.swsp\/c.sw\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(is_c_lwswsp(Rs, Rd, offset, false))                                         \\\n+        c_swsp(Rd, offset);                                                                  \\\n+      CHECK_RETURN                                                                           \\\n+      else CHECK_COND(is_c_lwsw(Rs, Rd, offset))                                             \\\n+        c_sw(Rd, Rs, offset);                                                                \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs, offset);                                                                 \\\n+  }\n+\n+  INSN(sw);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ fsd -> c.fsdsp\/c.fsd\n+#define INSN(NAME)                                                                           \\\n+  void NAME(FloatRegister Rd, Register Rs, const int32_t offset) {                           \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(is_c_fldsdsp(Rs, offset))                                                   \\\n+        c_fsdsp(Rd, offset);                                                                 \\\n+      CHECK_RETURN                                                                           \\\n+      else CHECK_COND(is_c_fldsd(Rs, Rd, offset))                                            \\\n+        c_fsd(Rd, Rs, offset);                                                               \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs, offset);                                                                 \\\n+  }\n+\n+  INSN(fsd);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Conditional branch instructions\n+\/\/ --------------------------\n+\/\/ beq\/bne -> c.beqz\/c.bnez\n+\n+#define INSN(NAME, C_NAME)                                                                   \\\n+  void NAME(Register Rs1, Register Rs2, const int64_t offset) {                              \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(offset != 0 && Rs2 == x0 && Rs1->is_compressed_valid() &&                   \\\n+        is_imm_in_range(offset, 8, 1))                                                       \\\n+        C_NAME(Rs1, offset);                                                                 \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rs1, Rs2, offset);                                                               \\\n+  }\n+\n+  INSN(beq, c_beqz);\n+  INSN(bne, c_beqz);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Unconditional branch instructions\n+\/\/ --------------------------\n+\/\/ jal -> c.j\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, const int32_t offset) {                                             \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(offset != 0 && Rd == x0 && is_imm_in_range(offset, 11, 1))                  \\\n+        c_j(offset);                                                                         \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, offset);                                                                     \\\n+  }\n+\n+  INSN(jal);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ jalr -> c.jr\/c.jalr\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(offset == 0 && Rs != x0)                                                    \\\n+        CHECK_COND(Rd == x1)                                                                 \\\n+          c_jalr(Rs);                                                                        \\\n+        CHECK_RETURN                                                                         \\\n+        else CHECK_COND(Rd == x0)                                                            \\\n+          c_jr(Rs);                                                                          \\\n+        CHECK_RETURN                                                                         \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs, offset);                                                                 \\\n+  }\n+\n+  INSN(jalr);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Miscellaneous Instructions\n+\/\/ --------------------------\n+\/\/ ebreak -> c.ebreak\n+#define INSN(NAME)                                                     \\\n+  void NAME() {                                                        \\\n+    CHECK_RVC()                                                        \\\n+      c_ebreak();                                                      \\\n+    CHECK_RETURN                                                       \\\n+    _##NAME();                                                         \\\n+  }\n+\n+  INSN(ebreak);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Immediate Instructions\n+\/\/ --------------------------\n+\/\/ li -> c.li\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, int64_t imm) {                                                      \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(is_imm_in_range(imm, 6, 0) && Rd != x0)                                     \\\n+        c_li(Rd, imm);                                                                       \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, imm);                                                                        \\\n+  }\n+\n+  INSN(li);\n+\n+#undef INSN\n+\n+\/\/ addi -> c.addi\/c.nop\/c.mv\/c.addi16sp\/c.addi4spn.\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs1, int32_t imm) {                                        \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(Rd == Rs1 && is_imm_in_range(imm, 6, 0))                                    \\\n+        c_addi(Rd, imm);                                                                     \\\n+      CHECK_RETURN                                                                           \\\n+      else CHECK_COND(imm == 0 && Rd != x0 && Rs1 != x0)                                     \\\n+        c_mv(Rd, Rs1);                                                                       \\\n+      CHECK_RETURN                                                                           \\\n+      else CHECK_COND(Rs1 == sp && imm != 0)                                                 \\\n+        CHECK_COND(Rd == Rs1 && (imm & 0b1111) == 0x0 && is_imm_in_range(imm, 10, 0))        \\\n+          c_addi16sp(imm);                                                                   \\\n+        CHECK_RETURN                                                                         \\\n+        else CHECK_COND(Rd->is_compressed_valid() && (imm & 0b11) == 0x0 && is_unsigned_imm_in_range(imm, 10, 0))                                      \\\n+          c_addi4spn(Rd, imm);                                                               \\\n+        CHECK_RETURN                                                                         \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs1, imm);                                                                   \\\n+  }\n+\n+  INSN(addi);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ addiw -> c.addiw\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs1, int32_t imm) {                                        \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(Rd == Rs1 && Rd != x0 && is_imm_in_range(imm, 6, 0))                        \\\n+        c_addiw(Rd, imm);                                                                    \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs1, imm);                                                                   \\\n+  }\n+\n+  INSN(addiw);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ and_imm12 -> c.andi\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs1, int32_t imm) {                                        \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(Rd == Rs1 && Rd->is_compressed_valid() && is_imm_in_range(imm, 6, 0))       \\\n+        c_andi(Rd, imm);                                                                     \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs1, imm);                                                                   \\\n+  }\n+\n+  INSN(and_imm12);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Shift Immediate Instructions\n+\/\/ --------------------------\n+\/\/ slli -> c.slli\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs1, unsigned shamt) {                                     \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(Rd == Rs1 && Rd != x0 && shamt != 0)                                        \\\n+        c_slli(Rd, shamt);                                                                   \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs1, shamt);                                                                 \\\n+  }\n+\n+  INSN(slli);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ srai\/srli -> c.srai\/c.srli\n+#define INSN(NAME, C_NAME)                                                                   \\\n+  void NAME(Register Rd, Register Rs1, unsigned shamt) {                                     \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(Rd == Rs1 && Rd->is_compressed_valid() && shamt != 0)                       \\\n+        C_NAME(Rd, shamt);                                                                   \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, Rs1, shamt);                                                                 \\\n+  }\n+\n+  INSN(srai, c_srai);\n+  INSN(srli, c_srli);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Upper Immediate Instruction\n+\/\/ --------------------------\n+\/\/ lui -> c.lui\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    CHECK_RVC()                                                                              \\\n+      CHECK_COND(Rd != x0 && Rd != x2 && imm != 0 && is_imm_in_range(imm, 18, 0))            \\\n+        c_lui(Rd, imm);                                                                      \\\n+      CHECK_RETURN                                                                           \\\n+    }                                                                                        \\\n+    _##NAME(Rd, imm);                                                                        \\\n+  }\n+\n+  INSN(lui);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                      \\\n+  void NAME() {                                                         \\\n+    CHECK_RVC()                                                         \\\n+      emit_int16(0);                                                    \\\n+    CHECK_RETURN                                                        \\\n+    _##NAME();                                                          \\\n+  }\n+\n+  INSN(halt);\n+\n+#undef INSN\n+\n+#undef CHECK_RETURN\n+#undef CHECK_RVC\n+#undef CHECK_COND\n+\n+\/\/ ---------------------------------------------------------------------------------------\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1099,"deletions":99,"binary":false,"changes":1198,"status":"modified"},{"patch":"@@ -1,881 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2022, 2022, Alibaba Group Holding Limited. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_RISCV_ASSEMBLER_RISCV_C_HPP\n-#define CPU_RISCV_ASSEMBLER_RISCV_C_HPP\n-\n-private:\n-  bool _in_compressible_region;\n-public:\n-  bool in_compressible_region() const { return _in_compressible_region; }\n-  void set_in_compressible_region(bool b) { _in_compressible_region = b; }\n-public:\n-\n-  \/\/ RVC: If an instruction is compressible, then\n-  \/\/   we will implicitly emit a 16-bit compressed instruction instead of the 32-bit\n-  \/\/   instruction in Assembler. All below logic follows Chapter -\n-  \/\/   \"C\" Standard Extension for Compressed Instructions, Version 2.0.\n-  \/\/   We can get code size reduction and performance improvement with this extension,\n-  \/\/   considering the reduction of instruction size and the code density increment.\n-\n-  \/\/ Note:\n-  \/\/   1. When UseRVC is enabled, 32-bit instructions under 'CompressibleRegion's will be\n-  \/\/      transformed to 16-bit instructions if compressible.\n-  \/\/   2. RVC instructions in Assembler always begin with 'c_' prefix, as 'c_li',\n-  \/\/      but most of time we have no need to explicitly use these instructions.\n-  \/\/   3. We introduce 'CompressibleRegion' to hint instructions in this Region's RTTI range\n-  \/\/      are qualified to change to their 2-byte versions.\n-  \/\/      An example:\n-  \/\/\n-  \/\/        CompressibleRegion cr(_masm);\n-  \/\/        __ andr(...);      \/\/ this instruction could change to c.and if able to\n-  \/\/\n-  \/\/   4. Using -XX:PrintAssemblyOptions=no-aliases could print RVC instructions instead of\n-  \/\/      normal ones.\n-  \/\/\n-\n-  \/\/ RVC: extract a 16-bit instruction.\n-  static inline uint16_t c_extract(uint16_t val, unsigned msb, unsigned lsb) {\n-    assert_cond(msb >= lsb && msb <= 15);\n-    unsigned nbits = msb - lsb + 1;\n-    uint16_t mask = (1U << nbits) - 1;\n-    uint16_t result = val >> lsb;\n-    result &= mask;\n-    return result;\n-  }\n-\n-  static inline int16_t c_sextract(uint16_t val, unsigned msb, unsigned lsb) {\n-    assert_cond(msb >= lsb && msb <= 15);\n-    int16_t result = val << (15 - msb);\n-    result >>= (15 - msb + lsb);\n-    return result;\n-  }\n-\n-  \/\/ RVC: patch a 16-bit instruction.\n-  static void c_patch(address a, unsigned msb, unsigned lsb, uint16_t val) {\n-    assert_cond(a != NULL);\n-    assert_cond(msb >= lsb && msb <= 15);\n-    unsigned nbits = msb - lsb + 1;\n-    guarantee(val < (1U << nbits), \"Field too big for insn\");\n-    uint16_t mask = (1U << nbits) - 1;\n-    val <<= lsb;\n-    mask <<= lsb;\n-    uint16_t target = *(uint16_t *)a;\n-    target &= ~mask;\n-    target |= val;\n-    *(uint16_t *)a = target;\n-  }\n-\n-  static void c_patch(address a, unsigned bit, uint16_t val) {\n-    c_patch(a, bit, bit, val);\n-  }\n-\n-  \/\/ RVC: patch a 16-bit instruction with a general purpose register ranging [0, 31] (5 bits)\n-  static void c_patch_reg(address a, unsigned lsb, Register reg) {\n-    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n-  }\n-\n-  \/\/ RVC: patch a 16-bit instruction with a general purpose register ranging [8, 15] (3 bits)\n-  static void c_patch_compressed_reg(address a, unsigned lsb, Register reg) {\n-    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n-  }\n-\n-  \/\/ RVC: patch a 16-bit instruction with a float register ranging [0, 31] (5 bits)\n-  static void c_patch_reg(address a, unsigned lsb, FloatRegister reg) {\n-    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n-  }\n-\n-  \/\/ RVC: patch a 16-bit instruction with a float register ranging [8, 15] (3 bits)\n-  static void c_patch_compressed_reg(address a, unsigned lsb, FloatRegister reg) {\n-    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n-  }\n-\n-public:\n-\n-\/\/ RVC: Compressed Instructions\n-\n-\/\/ --------------  RVC Instruction Definitions  --------------\n-\n-  void c_nop() {\n-    c_addi(x0, 0);\n-  }\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n-    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n-    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n-    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_addi,   0b000, 0b01);\n-  INSN(c_addiw,  0b001, 0b01);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(int32_t imm) {                                                                   \\\n-    assert_cond(is_imm_in_range(imm, 10, 0));                                                \\\n-    assert_cond((imm & 0b1111) == 0);                                                        \\\n-    assert_cond(imm != 0);                                                                   \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n-    c_patch((address)&insn, 4, 3, (imm & right_n_bits(9)) >> 7);                             \\\n-    c_patch((address)&insn, 5, 5, (imm & nth_bit(6)) >> 6);                                  \\\n-    c_patch((address)&insn, 6, 6, (imm & nth_bit(4)) >> 4);                                  \\\n-    c_patch_reg((address)&insn, 7, sp);                                                      \\\n-    c_patch((address)&insn, 12, 12, (imm & nth_bit(9)) >> 9);                                \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_addi16sp, 0b011, 0b01);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n-    assert_cond(is_unsigned_imm_in_range(uimm, 10, 0));                                      \\\n-    assert_cond((uimm & 0b11) == 0);                                                         \\\n-    assert_cond(uimm != 0);                                                                  \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_compressed_reg((address)&insn, 2, Rd);                                           \\\n-    c_patch((address)&insn, 5, 5, (uimm & nth_bit(3)) >> 3);                                 \\\n-    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n-    c_patch((address)&insn, 10, 7, (uimm & right_n_bits(10)) >> 6);                          \\\n-    c_patch((address)&insn, 12, 11, (uimm & right_n_bits(6)) >> 4);                          \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_addi4spn, 0b000, 0b00);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n-    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n-    assert_cond(shamt != 0);                                                                 \\\n-    assert_cond(Rd_Rs1 != x0);                                                               \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n-    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n-    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_slli, 0b000, 0b10);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, funct2, op)                                                       \\\n-  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n-    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n-    assert_cond(shamt != 0);                                                                 \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n-    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n-    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n-    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_srli, 0b100, 0b00, 0b01);\n-  INSN(c_srai, 0b100, 0b01, 0b01);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, funct2, op)                                                       \\\n-  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n-    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n-    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n-    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n-    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_andi, 0b100, 0b10, 0b01);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct6, funct2, op)                                                       \\\n-  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_compressed_reg((address)&insn, 2, Rs2);                                          \\\n-    c_patch((address)&insn, 6, 5, funct2);                                                   \\\n-    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n-    c_patch((address)&insn, 15, 10, funct6);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_sub,  0b100011, 0b00, 0b01);\n-  INSN(c_xor,  0b100011, 0b01, 0b01);\n-  INSN(c_or,   0b100011, 0b10, 0b01);\n-  INSN(c_and,  0b100011, 0b11, 0b01);\n-  INSN(c_subw, 0b100111, 0b00, 0b01);\n-  INSN(c_addw, 0b100111, 0b01, 0b01);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct4, op)                                                               \\\n-  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n-    assert_cond(Rd_Rs1 != x0);                                                               \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n-    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n-    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_mv,  0b1000, 0b10);\n-  INSN(c_add, 0b1001, 0b10);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct4, op)                                                               \\\n-  void NAME(Register Rs1) {                                                                  \\\n-    assert_cond(Rs1 != x0);                                                                  \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_reg((address)&insn, 2, x0);                                                      \\\n-    c_patch_reg((address)&insn, 7, Rs1);                                                     \\\n-    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_jr,   0b1000, 0b10);\n-  INSN(c_jalr, 0b1001, 0b10);\n-\n-#undef INSN\n-\n-  typedef void (Assembler::* j_c_insn)(address dest);\n-  typedef void (Assembler::* compare_and_branch_c_insn)(Register Rs1, address dest);\n-\n-  void wrap_label(Label &L, j_c_insn insn) {\n-    if (L.is_bound()) {\n-      (this->*insn)(target(L));\n-    } else {\n-      L.add_patch_at(code(), locator());\n-      (this->*insn)(pc());\n-    }\n-  }\n-\n-  void wrap_label(Label &L, Register r, compare_and_branch_c_insn insn) {\n-    if (L.is_bound()) {\n-      (this->*insn)(r, target(L));\n-    } else {\n-      L.add_patch_at(code(), locator());\n-      (this->*insn)(r, pc());\n-    }\n-  }\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(int32_t offset) {                                                                \\\n-    assert_cond(is_imm_in_range(offset, 11, 1));                                             \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 2, 2, (offset & nth_bit(5)) >> 5);                               \\\n-    c_patch((address)&insn, 5, 3, (offset & right_n_bits(4)) >> 1);                          \\\n-    c_patch((address)&insn, 6, 6, (offset & nth_bit(7)) >> 7);                               \\\n-    c_patch((address)&insn, 7, 7, (offset & nth_bit(6)) >> 6);                               \\\n-    c_patch((address)&insn, 8, 8, (offset & nth_bit(10)) >> 10);                             \\\n-    c_patch((address)&insn, 10, 9, (offset & right_n_bits(10)) >> 8);                        \\\n-    c_patch((address)&insn, 11, 11, (offset & nth_bit(4)) >> 4);                             \\\n-    c_patch((address)&insn, 12, 12, (offset & nth_bit(11)) >> 11);                           \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }                                                                                          \\\n-  void NAME(address dest) {                                                                  \\\n-    assert_cond(dest != NULL);                                                               \\\n-    int64_t distance = dest - pc();                                                          \\\n-    assert_cond(is_imm_in_range(distance, 11, 1));                                           \\\n-    c_j(distance);                                                                           \\\n-  }                                                                                          \\\n-  void NAME(Label &L) {                                                                      \\\n-    wrap_label(L, &Assembler::NAME);                                                         \\\n-  }\n-\n-  INSN(c_j, 0b101, 0b01);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(Register Rs1, int32_t imm) {                                                     \\\n-    assert_cond(is_imm_in_range(imm, 8, 1));                                                 \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n-    c_patch((address)&insn, 4, 3, (imm & right_n_bits(3)) >> 1);                             \\\n-    c_patch((address)&insn, 6, 5, (imm & right_n_bits(8)) >> 6);                             \\\n-    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n-    c_patch((address)&insn, 11, 10, (imm & right_n_bits(5)) >> 3);                           \\\n-    c_patch((address)&insn, 12, 12, (imm & nth_bit(8)) >> 8);                                \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }                                                                                          \\\n-  void NAME(Register Rs1, address dest) {                                                    \\\n-    assert_cond(dest != NULL);                                                               \\\n-    int64_t distance = dest - pc();                                                          \\\n-    assert_cond(is_imm_in_range(distance, 8, 1));                                            \\\n-    NAME(Rs1, distance);                                                                     \\\n-  }                                                                                          \\\n-  void NAME(Register Rs1, Label &L) {                                                        \\\n-    wrap_label(L, Rs1, &Assembler::NAME);                                                    \\\n-  }\n-\n-  INSN(c_beqz, 0b110, 0b01);\n-  INSN(c_bnez, 0b111, 0b01);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(Register Rd, int32_t imm) {                                                      \\\n-    assert_cond(is_imm_in_range(imm, 18, 0));                                                \\\n-    assert_cond((imm & 0xfff) == 0);                                                         \\\n-    assert_cond(imm != 0);                                                                   \\\n-    assert_cond(Rd != x0 && Rd != x2);                                                       \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 6, 2, (imm & right_n_bits(17)) >> 12);                           \\\n-    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n-    c_patch((address)&insn, 12, 12, (imm & nth_bit(17)) >> 17);                              \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_lui, 0b011, 0b01);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(Register Rd, int32_t imm) {                                                      \\\n-    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n-    assert_cond(Rd != x0);                                                                   \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n-    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n-    c_patch((address)&insn, 12, 12, (imm & right_n_bits(6)) >> 5);                           \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_li, 0b010, 0b01);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op, REGISTER_TYPE, CHECK)                                         \\\n-  void NAME(REGISTER_TYPE Rd, uint32_t uimm) {                                               \\\n-    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n-    assert_cond((uimm & 0b111) == 0);                                                        \\\n-    IF(CHECK, assert_cond(Rd != x0);)                                                        \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 4, 2, (uimm & right_n_bits(9)) >> 6);                            \\\n-    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(5)) >> 3);                            \\\n-    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n-    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-#define IF(BOOL, ...)       IF_##BOOL(__VA_ARGS__)\n-#define IF_true(code)       code\n-#define IF_false(code)\n-\n-  INSN(c_ldsp,  0b011, 0b10, Register,      true);\n-  INSN(c_fldsp, 0b001, 0b10, FloatRegister, false);\n-\n-#undef IF_false\n-#undef IF_true\n-#undef IF\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n-  void NAME(REGISTER_TYPE Rd_Rs2, Register Rs1, uint32_t uimm) {                             \\\n-    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n-    assert_cond((uimm & 0b111) == 0);                                                        \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n-    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(8)) >> 6);                            \\\n-    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n-    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_ld,  0b011, 0b00, Register);\n-  INSN(c_sd,  0b111, 0b00, Register);\n-  INSN(c_fld, 0b001, 0b00, FloatRegister);\n-  INSN(c_fsd, 0b101, 0b00, FloatRegister);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n-  void NAME(REGISTER_TYPE Rs2, uint32_t uimm) {                                              \\\n-    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n-    assert_cond((uimm & 0b111) == 0);                                                        \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n-    c_patch((address)&insn, 9, 7, (uimm & right_n_bits(9)) >> 6);                            \\\n-    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_sdsp,  0b111, 0b10, Register);\n-  INSN(c_fsdsp, 0b101, 0b10, FloatRegister);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(Register Rs2, uint32_t uimm) {                                                   \\\n-    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n-    assert_cond((uimm & 0b11) == 0);                                                         \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n-    c_patch((address)&insn, 8, 7, (uimm & right_n_bits(8)) >> 6);                            \\\n-    c_patch((address)&insn, 12, 9, (uimm & right_n_bits(6)) >> 2);                           \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_swsp, 0b110, 0b10);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n-    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n-    assert_cond((uimm & 0b11) == 0);                                                         \\\n-    assert_cond(Rd != x0);                                                                   \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 3, 2, (uimm & right_n_bits(8)) >> 6);                            \\\n-    c_patch((address)&insn, 6, 4, (uimm & right_n_bits(5)) >> 2);                            \\\n-    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n-    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_lwsp, 0b010, 0b10);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME(Register Rd_Rs2, Register Rs1, uint32_t uimm) {                                  \\\n-    assert_cond(is_unsigned_imm_in_range(uimm, 7, 0));                                       \\\n-    assert_cond((uimm & 0b11) == 0);                                                         \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n-    c_patch((address)&insn, 5, 5, (uimm & nth_bit(6)) >> 6);                                 \\\n-    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n-    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n-    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_lw, 0b010, 0b00);\n-  INSN(c_sw, 0b110, 0b00);\n-\n-#undef INSN\n-\n-#define INSN(NAME, funct3, op)                                                               \\\n-  void NAME() {                                                                              \\\n-    uint16_t insn = 0;                                                                       \\\n-    c_patch((address)&insn, 1, 0, op);                                                       \\\n-    c_patch((address)&insn, 11, 2, 0x0);                                                     \\\n-    c_patch((address)&insn, 12, 12, 0b1);                                                    \\\n-    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n-    emit_int16(insn);                                                                        \\\n-  }\n-\n-  INSN(c_ebreak, 0b100, 0b10);\n-\n-#undef INSN\n-\n-\/\/ --------------  RVC Transformation Macros  --------------\n-\n-\/\/ two RVC macros\n-#define COMPRESSIBLE          true\n-#define NOT_COMPRESSIBLE      false\n-\n-\/\/ a pivotal dispatcher for RVC\n-#define EMIT_MAY_COMPRESS(C, NAME, ...)               EMIT_MAY_COMPRESS_##C(NAME, __VA_ARGS__)\n-#define EMIT_MAY_COMPRESS_true(NAME, ...)             EMIT_MAY_COMPRESS_##NAME(__VA_ARGS__)\n-#define EMIT_MAY_COMPRESS_false(NAME, ...)\n-\n-#define IS_COMPRESSIBLE(...)                          if (__VA_ARGS__)\n-#define CHECK_CEXT_AND_COMPRESSIBLE(...)              IS_COMPRESSIBLE(UseRVC && in_compressible_region() && __VA_ARGS__)\n-#define CHECK_CEXT()                                  if (UseRVC && in_compressible_region())\n-\n-\/\/ RVC transformation macros\n-#define EMIT_RVC_cond(PREFIX, COND, EMIT) {                                            \\\n-    PREFIX                                                                             \\\n-    CHECK_CEXT_AND_COMPRESSIBLE(COND) {                                                \\\n-      EMIT;                                                                            \\\n-      return;                                                                          \\\n-    }                                                                                  \\\n-  }\n-\n-#define EMIT_RVC_cond2(PREFIX, COND1, EMIT1, COND2, EMIT2) {                           \\\n-    PREFIX                                                                             \\\n-    CHECK_CEXT() {                                                                     \\\n-      IS_COMPRESSIBLE(COND1) {                                                         \\\n-        EMIT1;                                                                         \\\n-        return;                                                                        \\\n-      } else IS_COMPRESSIBLE(COND2) {                                                  \\\n-        EMIT2;                                                                         \\\n-        return;                                                                        \\\n-      }                                                                                \\\n-    }                                                                                  \\\n-  }\n-\n-#define EMIT_RVC_cond4(PREFIX, COND1, EMIT1, COND2, EMIT2, COND3, EMIT3, COND4, EMIT4) {  \\\n-    PREFIX                                                                             \\\n-    CHECK_CEXT() {                                                                     \\\n-      IS_COMPRESSIBLE(COND1) {                                                         \\\n-        EMIT1;                                                                         \\\n-        return;                                                                        \\\n-      } else IS_COMPRESSIBLE(COND2) {                                                  \\\n-        EMIT2;                                                                         \\\n-        return;                                                                        \\\n-      } else IS_COMPRESSIBLE(COND3) {                                                  \\\n-        EMIT3;                                                                         \\\n-        return;                                                                        \\\n-      } else IS_COMPRESSIBLE(COND4) {                                                  \\\n-        EMIT4;                                                                         \\\n-        return;                                                                        \\\n-      }                                                                                \\\n-    }                                                                                  \\\n-  }\n-\n-\/\/ --------------------------\n-\/\/ Register instructions\n-\/\/ --------------------------\n-\/\/ add -> c.add\n-#define EMIT_MAY_COMPRESS_add(Rd, Rs1, Rs2)                                            \\\n-  EMIT_RVC_cond(                                                                       \\\n-    Register src = noreg;,                                                             \\\n-    Rs1 != x0 && Rs2 != x0 && ((src = Rs1, Rs2 == Rd) || (src = Rs2, Rs1 == Rd)),      \\\n-    c_add(Rd, src)                                                                     \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ sub\/subw -> c.sub\/c.subw\n-#define EMIT_MAY_COMPRESS_sub_helper(C_NAME, Rd, Rs1, Rs2)                             \\\n-  EMIT_RVC_cond(,                                                                      \\\n-    Rs1 == Rd && Rd->is_compressed_valid() && Rs2->is_compressed_valid(),              \\\n-    C_NAME(Rd, Rs2)                                                                    \\\n-  )\n-\n-#define EMIT_MAY_COMPRESS_sub(Rd, Rs1, Rs2)                                            \\\n-  EMIT_MAY_COMPRESS_sub_helper(c_sub, Rd, Rs1, Rs2)\n-\n-#define EMIT_MAY_COMPRESS_subw(Rd, Rs1, Rs2)                                           \\\n-  EMIT_MAY_COMPRESS_sub_helper(c_subw, Rd, Rs1, Rs2)\n-\n-\/\/ --------------------------\n-\/\/ xor\/or\/and\/addw -> c.xor\/c.or\/c.and\/c.addw\n-#define EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(C_NAME, Rd, Rs1, Rs2)              \\\n-  EMIT_RVC_cond(                                                                       \\\n-    Register src = noreg;,                                                             \\\n-    Rs1->is_compressed_valid() && Rs2->is_compressed_valid() &&                        \\\n-      ((src = Rs1, Rs2 == Rd) || (src = Rs2, Rs1 == Rd)),                              \\\n-    C_NAME(Rd, src)                                                                    \\\n-  )\n-\n-#define EMIT_MAY_COMPRESS_xorr(Rd, Rs1, Rs2)                                           \\\n-  EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(c_xor, Rd, Rs1, Rs2)\n-\n-#define EMIT_MAY_COMPRESS_orr(Rd, Rs1, Rs2)                                            \\\n-  EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(c_or, Rd, Rs1, Rs2)\n-\n-#define EMIT_MAY_COMPRESS_andr(Rd, Rs1, Rs2)                                           \\\n-  EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(c_and, Rd, Rs1, Rs2)\n-\n-#define EMIT_MAY_COMPRESS_addw(Rd, Rs1, Rs2)                                           \\\n-  EMIT_MAY_COMPRESS_xorr_orr_andr_addw_helper(c_addw, Rd, Rs1, Rs2)\n-\n-\/\/ --------------------------\n-\/\/ Load\/store register (all modes)\n-\/\/ --------------------------\n-private:\n-\n-#define FUNC(NAME, funct3, bits)                                                       \\\n-  bool NAME(Register rs1, Register rd_rs2, int32_t imm12, bool ld) {                   \\\n-    return rs1 == sp &&                                                                \\\n-      is_unsigned_imm_in_range(imm12, bits, 0) &&                                      \\\n-      (intx(imm12) & funct3) == 0x0 &&                                                 \\\n-      (!ld || rd_rs2 != x0);                                                           \\\n-  }                                                                                    \\\n-\n-  FUNC(is_c_ldsdsp,  0b111, 9);\n-  FUNC(is_c_lwswsp,  0b011, 8);\n-#undef FUNC\n-\n-#define FUNC(NAME, funct3, bits)                                                       \\\n-  bool NAME(Register rs1, int32_t imm12) {                                             \\\n-    return rs1 == sp &&                                                                \\\n-      is_unsigned_imm_in_range(imm12, bits, 0) &&                                      \\\n-      (intx(imm12) & funct3) == 0x0;                                                   \\\n-  }                                                                                    \\\n-\n-  FUNC(is_c_fldsdsp, 0b111, 9);\n-#undef FUNC\n-\n-#define FUNC(NAME, REG_TYPE, funct3, bits)                                             \\\n-  bool NAME(Register rs1, REG_TYPE rd_rs2, int32_t imm12) {                            \\\n-    return rs1->is_compressed_valid() &&                                               \\\n-      rd_rs2->is_compressed_valid() &&                                                 \\\n-      is_unsigned_imm_in_range(imm12, bits, 0) &&                                      \\\n-      (intx(imm12) & funct3) == 0x0;                                                   \\\n-  }                                                                                    \\\n-\n-  FUNC(is_c_ldsd,  Register,      0b111, 8);\n-  FUNC(is_c_lwsw,  Register,      0b011, 7);\n-  FUNC(is_c_fldsd, FloatRegister, 0b111, 8);\n-#undef FUNC\n-\n-public:\n-\/\/ --------------------------\n-\/\/ ld -> c.ldsp\/c.ld\n-#define EMIT_MAY_COMPRESS_ld(Rd, Rs, offset)                                           \\\n-  EMIT_RVC_cond2(,                                                                     \\\n-     is_c_ldsdsp(Rs, Rd, offset, true),                                                \\\n-     c_ldsp(Rd, offset),                                                               \\\n-     is_c_ldsd(Rs, Rd, offset),                                                        \\\n-     c_ld(Rd, Rs, offset)                                                              \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ sd -> c.sdsp\/c.sd\n-#define EMIT_MAY_COMPRESS_sd(Rd, Rs, offset)                                           \\\n-  EMIT_RVC_cond2(,                                                                     \\\n-     is_c_ldsdsp(Rs, Rd, offset, false),                                               \\\n-     c_sdsp(Rd, offset),                                                               \\\n-     is_c_ldsd(Rs, Rd, offset),                                                        \\\n-     c_sd(Rd, Rs, offset)                                                              \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ lw -> c.lwsp\/c.lw\n-#define EMIT_MAY_COMPRESS_lw(Rd, Rs, offset)                                           \\\n-  EMIT_RVC_cond2(,                                                                     \\\n-     is_c_lwswsp(Rs, Rd, offset, true),                                                \\\n-     c_lwsp(Rd, offset),                                                               \\\n-     is_c_lwsw(Rs, Rd, offset),                                                        \\\n-     c_lw(Rd, Rs, offset)                                                              \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ sw -> c.swsp\/c.sw\n-#define EMIT_MAY_COMPRESS_sw(Rd, Rs, offset)                                           \\\n-  EMIT_RVC_cond2(,                                                                     \\\n-     is_c_lwswsp(Rs, Rd, offset, false),                                               \\\n-     c_swsp(Rd, offset),                                                               \\\n-     is_c_lwsw(Rs, Rd, offset),                                                        \\\n-     c_sw(Rd, Rs, offset)                                                              \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ fld -> c.fldsp\/c.fld\n-#define EMIT_MAY_COMPRESS_fld(Rd, Rs, offset)                                          \\\n-  EMIT_RVC_cond2(,                                                                     \\\n-     is_c_fldsdsp(Rs, offset),                                                         \\\n-     c_fldsp(Rd, offset),                                                              \\\n-     is_c_fldsd(Rs, Rd, offset),                                                       \\\n-     c_fld(Rd, Rs, offset)                                                             \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ fsd -> c.fsdsp\/c.fsd\n-#define EMIT_MAY_COMPRESS_fsd(Rd, Rs, offset)                                          \\\n-  EMIT_RVC_cond2(,                                                                     \\\n-     is_c_fldsdsp(Rs, offset),                                                         \\\n-     c_fsdsp(Rd, offset),                                                              \\\n-     is_c_fldsd(Rs, Rd, offset),                                                       \\\n-     c_fsd(Rd, Rs, offset)                                                             \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ Conditional branch instructions\n-\/\/ --------------------------\n-\/\/ beq\/bne -> c.beqz\/c.bnez\n-\n-\/\/ Note: offset == 0 means this beqz\/benz is jumping forward and we cannot know the future position\n-\/\/   so we cannot compress this instrution.\n-#define EMIT_MAY_COMPRESS_beqz_bnez_helper(C_NAME, Rs1, Rs2, offset)                   \\\n-  EMIT_RVC_cond(,                                                                      \\\n-    offset != 0 && Rs2 == x0 && Rs1->is_compressed_valid() &&                          \\\n-      is_imm_in_range(offset, 8, 1),                                                   \\\n-    C_NAME(Rs1, offset)                                                                \\\n-  )\n-\n-#define EMIT_MAY_COMPRESS_beq(Rs1, Rs2, offset)                                        \\\n-  EMIT_MAY_COMPRESS_beqz_bnez_helper(c_beqz, Rs1, Rs2, offset)\n-\n-#define EMIT_MAY_COMPRESS_bne(Rs1, Rs2, offset)                                        \\\n-  EMIT_MAY_COMPRESS_beqz_bnez_helper(c_bnez, Rs1, Rs2, offset)\n-\n-\/\/ --------------------------\n-\/\/ Unconditional branch instructions\n-\/\/ --------------------------\n-\/\/ jalr\/jal -> c.jr\/c.jalr\/c.j\n-\n-#define EMIT_MAY_COMPRESS_jalr(Rd, Rs, offset)                                         \\\n-  EMIT_RVC_cond2(,                                                                     \\\n-    offset == 0 && Rd == x1 && Rs != x0,                                               \\\n-    c_jalr(Rs),                                                                        \\\n-    offset == 0 && Rd == x0 && Rs != x0,                                               \\\n-    c_jr(Rs)                                                                           \\\n-  )\n-\n-\/\/ Note: offset == 0 means this j() is jumping forward and we cannot know the future position\n-\/\/   so we cannot compress this instrution.\n-#define EMIT_MAY_COMPRESS_jal(Rd, offset)                                              \\\n-  EMIT_RVC_cond(,                                                                      \\\n-    offset != 0 && Rd == x0 && is_imm_in_range(offset, 11, 1),                         \\\n-    c_j(offset)                                                                        \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ Upper Immediate Instruction\n-\/\/ --------------------------\n-\/\/ lui -> c.lui\n-#define EMIT_MAY_COMPRESS_lui(Rd, imm)                                                 \\\n-  EMIT_RVC_cond(,                                                                      \\\n-    Rd != x0 && Rd != x2 && imm != 0 && is_imm_in_range(imm, 18, 0),                   \\\n-    c_lui(Rd, imm)                                                                     \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ Miscellaneous Instructions\n-\/\/ --------------------------\n-\/\/ ebreak -> c.ebreak\n-#define EMIT_MAY_COMPRESS_ebreak()                                                     \\\n-  EMIT_RVC_cond(,                                                                      \\\n-    true,                                                                              \\\n-    c_ebreak()                                                                         \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ Immediate Instructions\n-\/\/ --------------------------\n-\/\/ addi -> c.addi\/c.nop\/c.mv\/c.addi16sp\/c.addi4spn.\n-#define EMIT_MAY_COMPRESS_addi(Rd, Rs1, imm)                                                          \\\n-  EMIT_RVC_cond4(,                                                                                    \\\n-    Rd == Rs1 && is_imm_in_range(imm, 6, 0),                                                          \\\n-    c_addi(Rd, imm),                                                                                  \\\n-    imm == 0 && Rd != x0 && Rs1 != x0,                                                                \\\n-    c_mv(Rd, Rs1),                                                                                    \\\n-    Rs1 == sp && Rd == Rs1 && imm != 0 && (imm & 0b1111) == 0x0 && is_imm_in_range(imm, 10, 0),       \\\n-    c_addi16sp(imm),                                                                                  \\\n-    Rs1 == sp && Rd->is_compressed_valid() && imm != 0 && (imm & 0b11) == 0x0 && is_unsigned_imm_in_range(imm, 10, 0),  \\\n-    c_addi4spn(Rd, imm)                                                                               \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ addiw -> c.addiw\n-#define EMIT_MAY_COMPRESS_addiw(Rd, Rs1, imm)                                          \\\n-  EMIT_RVC_cond(,                                                                      \\\n-    Rd == Rs1 && Rd != x0 && is_imm_in_range(imm, 6, 0),                               \\\n-    c_addiw(Rd, imm)                                                                   \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ and_imm12 -> c.andi\n-#define EMIT_MAY_COMPRESS_and_imm12(Rd, Rs1, imm)                                      \\\n-  EMIT_RVC_cond(,                                                                      \\\n-    Rd == Rs1 && Rd->is_compressed_valid() && is_imm_in_range(imm, 6, 0),              \\\n-    c_andi(Rd, imm)                                                                    \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ Shift Immediate Instructions\n-\/\/ --------------------------\n-\/\/ slli -> c.slli\n-#define EMIT_MAY_COMPRESS_slli(Rd, Rs1, shamt)                                         \\\n-  EMIT_RVC_cond(,                                                                      \\\n-    Rd == Rs1 && Rd != x0 && shamt != 0,                                               \\\n-    c_slli(Rd, shamt)                                                                  \\\n-  )\n-\n-\/\/ --------------------------\n-\/\/ srai\/srli -> c.srai\/c.srli\n-#define EMIT_MAY_COMPRESS_srai_srli_helper(C_NAME, Rd, Rs1, shamt)                     \\\n-  EMIT_RVC_cond(,                                                                      \\\n-    Rd == Rs1 && Rd->is_compressed_valid() && shamt != 0,                              \\\n-    C_NAME(Rd, shamt)                                                                  \\\n-  )\n-\n-#define EMIT_MAY_COMPRESS_srai(Rd, Rs1, shamt)                                         \\\n-  EMIT_MAY_COMPRESS_srai_srli_helper(c_srai, Rd, Rs1, shamt)\n-\n-#define EMIT_MAY_COMPRESS_srli(Rd, Rs1, shamt)                                         \\\n-  EMIT_MAY_COMPRESS_srai_srli_helper(c_srli, Rd, Rs1, shamt)\n-\n-\/\/ --------------------------\n-\n-public:\n-\/\/ RVC: a compressible region\n-class CompressibleRegion : public StackObj {\n-protected:\n-  Assembler *_masm;\n-  bool _prev_in_compressible_region;\n-public:\n-  CompressibleRegion(Assembler *_masm)\n-  : _masm(_masm)\n-  , _prev_in_compressible_region(_masm->in_compressible_region()) {\n-    _masm->set_in_compressible_region(true);\n-  }\n-  ~CompressibleRegion() {\n-    _masm->set_in_compressible_region(_prev_in_compressible_region);\n-  }\n-};\n-\n-#endif \/\/ CPU_RISCV_ASSEMBLER_RISCV_C_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv_c.hpp","additions":0,"deletions":881,"binary":false,"changes":881,"status":"deleted"},{"patch":"@@ -49,1 +49,1 @@\n-define_pd_global(intx, InteriorEntryAlignment,       4);\n+define_pd_global(intx, InteriorEntryAlignment,       16);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_globals_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-define_pd_global(intx, CodeEntryAlignment,       16);\n+define_pd_global(intx, CodeEntryAlignment,       64);\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}