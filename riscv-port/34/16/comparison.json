{"files":[{"patch":"@@ -86,1 +86,1 @@\n-void Assembler::li(Register Rd, int64_t imm) {\n+void Assembler::_li(Register Rd, int64_t imm) {\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-  void li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n+  void _li(Register Rd, int64_t imm);  \/\/ optimized load immediate\n@@ -381,1 +381,1 @@\n-  void halt() {\n+  void _halt() {\n@@ -385,1 +385,1 @@\n-\/\/ Rigster Instruction\n+\/\/ Register Instruction\n@@ -398,5 +398,5 @@\n-  INSN(add,   0b0110011, 0b000, 0b0000000);\n-  INSN(sub,   0b0110011, 0b000, 0b0100000);\n-  INSN(andr,  0b0110011, 0b111, 0b0000000);\n-  INSN(orr,   0b0110011, 0b110, 0b0000000);\n-  INSN(xorr,  0b0110011, 0b100, 0b0000000);\n+  INSN(_add,  0b0110011, 0b000, 0b0000000);\n+  INSN(_sub,  0b0110011, 0b000, 0b0100000);\n+  INSN(_andr, 0b0110011, 0b111, 0b0000000);\n+  INSN(_orr,  0b0110011, 0b110, 0b0000000);\n+  INSN(_xorr, 0b0110011, 0b100, 0b0000000);\n@@ -408,2 +408,2 @@\n-  INSN(addw,  0b0111011, 0b000, 0b0000000);\n-  INSN(subw,  0b0111011, 0b000, 0b0100000);\n+  INSN(_addw, 0b0111011, 0b000, 0b0000000);\n+  INSN(_subw, 0b0111011, 0b000, 0b0100000);\n@@ -439,1 +439,0 @@\n-    unsigned insn = 0;                                                                             \\\n@@ -441,0 +440,1 @@\n+    unsigned insn = 0;                                                                             \\\n@@ -448,1 +448,13 @@\n-  }                                                                                                \\\n+  }\n+\n+  INSN(lb,  0b0000011, 0b000);\n+  INSN(lbu, 0b0000011, 0b100);\n+  INSN(lh,  0b0000011, 0b001);\n+  INSN(lhu, 0b0000011, 0b101);\n+  INSN(_lw, 0b0000011, 0b010);\n+  INSN(lwu, 0b0000011, 0b110);\n+  INSN(_ld, 0b0000011, 0b011);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n@@ -494,7 +506,7 @@\n-  INSN(lb,  0b0000011, 0b000);\n-  INSN(lbu, 0b0000011, 0b100);\n-  INSN(ld,  0b0000011, 0b011);\n-  INSN(lh,  0b0000011, 0b001);\n-  INSN(lhu, 0b0000011, 0b101);\n-  INSN(lw,  0b0000011, 0b010);\n-  INSN(lwu, 0b0000011, 0b110);\n+  INSN(lb);\n+  INSN(lbu);\n+  INSN(lh);\n+  INSN(lhu);\n+  INSN(lw);\n+  INSN(lwu);\n+  INSN(ld);\n@@ -506,1 +518,0 @@\n-    unsigned insn = 0;                                                                             \\\n@@ -508,0 +519,1 @@\n+    unsigned insn = 0;                                                                             \\\n@@ -515,1 +527,8 @@\n-  }                                                                                                \\\n+  }\n+\n+  INSN(flw,  0b0000111, 0b010);\n+  INSN(_fld, 0b0000111, 0b011);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                 \\\n@@ -553,2 +572,2 @@\n-  INSN(flw, 0b0000111, 0b010);\n-  INSN(fld, 0b0000111, 0b011);\n+  INSN(flw);\n+  INSN(fld);\n@@ -559,1 +578,0 @@\n-    unsigned insn = 0;                                                                                   \\\n@@ -561,0 +579,1 @@\n+    unsigned insn = 0;                                                                                   \\\n@@ -575,1 +594,12 @@\n-  }                                                                                                      \\\n+  }\n+\n+  INSN(_beq, 0b1100011, 0b000);\n+  INSN(_bne, 0b1100011, 0b001);\n+  INSN(bge,  0b1100011, 0b101);\n+  INSN(bgeu, 0b1100011, 0b111);\n+  INSN(blt,  0b1100011, 0b100);\n+  INSN(bltu, 0b1100011, 0b110);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                                       \\\n@@ -586,6 +616,6 @@\n-  INSN(beq,  0b1100011, 0b000);\n-  INSN(bge,  0b1100011, 0b101);\n-  INSN(bgeu, 0b1100011, 0b111);\n-  INSN(blt,  0b1100011, 0b100);\n-  INSN(bltu, 0b1100011, 0b110);\n-  INSN(bne,  0b1100011, 0b001);\n+  INSN(beq);\n+  INSN(bne);\n+  INSN(bge);\n+  INSN(bgeu);\n+  INSN(blt);\n+  INSN(bltu);\n@@ -611,1 +641,0 @@\n-    unsigned insn = 0;                                                                                      \\\n@@ -613,0 +642,1 @@\n+    unsigned insn = 0;                                                                                      \\\n@@ -624,0 +654,11 @@\n+\n+  INSN(sb,   Register,      0b0100011, 0b000);\n+  INSN(sh,   Register,      0b0100011, 0b001);\n+  INSN(_sw,  Register,      0b0100011, 0b010);\n+  INSN(_sd,  Register,      0b0100011, 0b011);\n+  INSN(fsw,  FloatRegister, 0b0100111, 0b010);\n+  INSN(_fsd, FloatRegister, 0b0100111, 0b011);\n+\n+#undef INSN\n+\n+#define INSN(NAME, REGISTER)                                                                                \\\n@@ -628,6 +669,6 @@\n-  INSN(sb,  Register,      0b0100011, 0b000);\n-  INSN(sh,  Register,      0b0100011, 0b001);\n-  INSN(sw,  Register,      0b0100011, 0b010);\n-  INSN(sd,  Register,      0b0100011, 0b011);\n-  INSN(fsw, FloatRegister, 0b0100111, 0b010);\n-  INSN(fsd, FloatRegister, 0b0100111, 0b011);\n+  INSN(sb,  Register);\n+  INSN(sh,  Register);\n+  INSN(sw,  Register);\n+  INSN(sd,  Register);\n+  INSN(fsw, FloatRegister);\n+  INSN(fsd, FloatRegister);\n@@ -762,1 +803,0 @@\n-    unsigned insn = 0;                                                                        \\\n@@ -764,0 +804,1 @@\n+    unsigned insn = 0;                                                                        \\\n@@ -771,1 +812,7 @@\n-  }                                                                                           \\\n+  }\n+\n+  INSN(_jal, 0b1101111);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                                            \\\n@@ -789,1 +836,1 @@\n-  INSN(jal, 0b1101111);\n+  INSN(jal);\n@@ -797,1 +844,0 @@\n-    unsigned insn = 0;                                                                     \\\n@@ -799,0 +845,1 @@\n+    unsigned insn = 0;                                                                     \\\n@@ -808,1 +855,1 @@\n-  INSN(jalr, 0b1100111, 0b000);\n+  INSN(_jalr, 0b1100111, 0b000);\n@@ -844,1 +891,2 @@\n-  INSN(ebreak,  0b1110011, 0b000, 0b000000000001);\n+  INSN(_ebreak, 0b1110011, 0b000, 0b000000000001);\n+\n@@ -952,6 +1000,6 @@\n-  INSN(addi,  0b0010011, 0b000);\n-  INSN(slti,  0b0010011, 0b010);\n-  INSN(addiw, 0b0011011, 0b000);\n-  INSN(and_imm12,  0b0010011, 0b111);\n-  INSN(ori,   0b0010011, 0b110);\n-  INSN(xori,  0b0010011, 0b100);\n+  INSN(_addi,      0b0010011, 0b000);\n+  INSN(slti,       0b0010011, 0b010);\n+  INSN(_addiw,     0b0011011, 0b000);\n+  INSN(_and_imm12, 0b0010011, 0b111);\n+  INSN(ori,        0b0010011, 0b110);\n+  INSN(xori,       0b0010011, 0b100);\n@@ -991,3 +1039,3 @@\n-  INSN(slli,  0b0010011, 0b001, 0b000000);\n-  INSN(srai,  0b0010011, 0b101, 0b010000);\n-  INSN(srli,  0b0010011, 0b101, 0b000000);\n+  INSN(_slli, 0b0010011, 0b001, 0b000000);\n+  INSN(_srai, 0b0010011, 0b101, 0b010000);\n+  INSN(_srli, 0b0010011, 0b101, 0b000000);\n@@ -1029,1 +1077,1 @@\n-  INSN(lui,   0b0110111);\n+  INSN(_lui,  0b0110111);\n@@ -1974,0 +2022,957 @@\n+\/\/ ========================================\n+\/\/ RISC-V Compressed Instructions Extension\n+\/\/ ========================================\n+\/\/ Note:\n+\/\/ 1. When UseRVC is enabled, 32-bit instructions under 'CompressibleRegion's will be\n+\/\/    transformed to 16-bit instructions if compressible.\n+\/\/ 2. RVC instructions in Assembler always begin with 'c_' prefix, as 'c_li',\n+\/\/    but most of time we have no need to explicitly use these instructions.\n+\/\/ 3. We introduce 'CompressibleRegion' to hint instructions in this Region's RTTI range\n+\/\/    are qualified to change to their 2-byte versions.\n+\/\/    An example:\n+\/\/\n+\/\/      CompressibleRegion cr(_masm);\n+\/\/      __ andr(...);      \/\/ this instruction could change to c.and if able to\n+\/\/\n+\/\/ 4. Using -XX:PrintAssemblyOptions=no-aliases could print RVC instructions instead of\n+\/\/    normal ones.\n+\/\/\n+\n+private:\n+  bool _in_compressible_region;\n+public:\n+  bool in_compressible_region() const { return _in_compressible_region; }\n+  void set_in_compressible_region(bool b) { _in_compressible_region = b; }\n+public:\n+\n+  \/\/ a compressible region\n+  class CompressibleRegion : public StackObj {\n+  protected:\n+    Assembler *_masm;\n+    bool _saved_in_compressible_region;\n+  public:\n+    CompressibleRegion(Assembler *_masm)\n+    : _masm(_masm)\n+    , _saved_in_compressible_region(_masm->in_compressible_region()) {\n+      _masm->set_in_compressible_region(true);\n+    }\n+    ~CompressibleRegion() {\n+      _masm->set_in_compressible_region(_saved_in_compressible_region);\n+    }\n+  };\n+\n+  \/\/ patch a 16-bit instruction.\n+  static void c_patch(address a, unsigned msb, unsigned lsb, uint16_t val) {\n+    assert_cond(a != NULL);\n+    assert_cond(msb >= lsb && msb <= 15);\n+    unsigned nbits = msb - lsb + 1;\n+    guarantee(val < (1U << nbits), \"Field too big for insn\");\n+    uint16_t mask = (1U << nbits) - 1;\n+    val <<= lsb;\n+    mask <<= lsb;\n+    uint16_t target = *(uint16_t *)a;\n+    target &= ~mask;\n+    target |= val;\n+    *(uint16_t *)a = target;\n+  }\n+\n+  static void c_patch(address a, unsigned bit, uint16_t val) {\n+    c_patch(a, bit, bit, val);\n+  }\n+\n+  \/\/ patch a 16-bit instruction with a general purpose register ranging [0, 31] (5 bits)\n+  static void c_patch_reg(address a, unsigned lsb, Register reg) {\n+    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n+  }\n+\n+  \/\/ patch a 16-bit instruction with a general purpose register ranging [8, 15] (3 bits)\n+  static void c_patch_compressed_reg(address a, unsigned lsb, Register reg) {\n+    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n+  }\n+\n+  \/\/ patch a 16-bit instruction with a float register ranging [0, 31] (5 bits)\n+  static void c_patch_reg(address a, unsigned lsb, FloatRegister reg) {\n+    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n+  }\n+\n+  \/\/ patch a 16-bit instruction with a float register ranging [8, 15] (3 bits)\n+  static void c_patch_compressed_reg(address a, unsigned lsb, FloatRegister reg) {\n+    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n+  }\n+\n+\/\/ --------------  RVC Instruction Definitions  --------------\n+\n+  void c_nop() {\n+    c_addi(x0, 0);\n+  }\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi,   0b000, 0b01);\n+  INSN(c_addiw,  0b001, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(int32_t imm) {                                                                   \\\n+    assert_cond(is_imm_in_range(imm, 10, 0));                                                \\\n+    assert_cond((imm & 0b1111) == 0);                                                        \\\n+    assert_cond(imm != 0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n+    c_patch((address)&insn, 4, 3, (imm & right_n_bits(9)) >> 7);                             \\\n+    c_patch((address)&insn, 5, 5, (imm & nth_bit(6)) >> 6);                                  \\\n+    c_patch((address)&insn, 6, 6, (imm & nth_bit(4)) >> 4);                                  \\\n+    c_patch_reg((address)&insn, 7, sp);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(9)) >> 9);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi16sp, 0b011, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 10, 0));                                      \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    assert_cond(uimm != 0);                                                                  \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd);                                           \\\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(3)) >> 3);                                 \\\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n+    c_patch((address)&insn, 10, 7, (uimm & right_n_bits(10)) >> 6);                          \\\n+    c_patch((address)&insn, 12, 11, (uimm & right_n_bits(6)) >> 4);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi4spn, 0b000, 0b00);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n+    assert_cond(shamt != 0);                                                                 \\\n+    assert_cond(Rd_Rs1 != x0);                                                               \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_slli, 0b000, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n+    assert_cond(shamt != 0);                                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n+    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_srli, 0b100, 0b00, 0b01);\n+  INSN(c_srai, 0b100, 0b01, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_andi, 0b100, 0b10, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct6, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rs2);                                          \\\n+    c_patch((address)&insn, 6, 5, funct2);                                                   \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 15, 10, funct6);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_sub,  0b100011, 0b00, 0b01);\n+  INSN(c_xor,  0b100011, 0b01, 0b01);\n+  INSN(c_or,   0b100011, 0b10, 0b01);\n+  INSN(c_and,  0b100011, 0b11, 0b01);\n+  INSN(c_subw, 0b100111, 0b00, 0b01);\n+  INSN(c_addw, 0b100111, 0b01, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct4, op)                                                               \\\n+  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n+    assert_cond(Rd_Rs1 != x0);                                                               \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_mv,  0b1000, 0b10);\n+  INSN(c_add, 0b1001, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct4, op)                                                               \\\n+  void NAME(Register Rs1) {                                                                  \\\n+    assert_cond(Rs1 != x0);                                                                  \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, x0);                                                      \\\n+    c_patch_reg((address)&insn, 7, Rs1);                                                     \\\n+    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_jr,   0b1000, 0b10);\n+  INSN(c_jalr, 0b1001, 0b10);\n+\n+#undef INSN\n+\n+  typedef void (Assembler::* j_c_insn)(address dest);\n+  typedef void (Assembler::* compare_and_branch_c_insn)(Register Rs1, address dest);\n+\n+  void wrap_label(Label &L, j_c_insn insn) {\n+    if (L.is_bound()) {\n+      (this->*insn)(target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(pc());\n+    }\n+  }\n+\n+  void wrap_label(Label &L, Register r, compare_and_branch_c_insn insn) {\n+    if (L.is_bound()) {\n+      (this->*insn)(r, target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(r, pc());\n+    }\n+  }\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(int32_t offset) {                                                                \\\n+    assert_cond(is_imm_in_range(offset, 11, 1));                                             \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (offset & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 5, 3, (offset & right_n_bits(4)) >> 1);                          \\\n+    c_patch((address)&insn, 6, 6, (offset & nth_bit(7)) >> 7);                               \\\n+    c_patch((address)&insn, 7, 7, (offset & nth_bit(6)) >> 6);                               \\\n+    c_patch((address)&insn, 8, 8, (offset & nth_bit(10)) >> 10);                             \\\n+    c_patch((address)&insn, 10, 9, (offset & right_n_bits(10)) >> 8);                        \\\n+    c_patch((address)&insn, 11, 11, (offset & nth_bit(4)) >> 4);                             \\\n+    c_patch((address)&insn, 12, 12, (offset & nth_bit(11)) >> 11);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }                                                                                          \\\n+  void NAME(address dest) {                                                                  \\\n+    assert_cond(dest != NULL);                                                               \\\n+    int64_t distance = dest - pc();                                                          \\\n+    assert_cond(is_imm_in_range(distance, 11, 1));                                           \\\n+    c_j(distance);                                                                           \\\n+  }                                                                                          \\\n+  void NAME(Label &L) {                                                                      \\\n+    wrap_label(L, &Assembler::NAME);                                                         \\\n+  }\n+\n+  INSN(c_j, 0b101, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rs1, int32_t imm) {                                                     \\\n+    assert_cond(is_imm_in_range(imm, 8, 1));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n+    c_patch((address)&insn, 4, 3, (imm & right_n_bits(3)) >> 1);                             \\\n+    c_patch((address)&insn, 6, 5, (imm & right_n_bits(8)) >> 6);                             \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 11, 10, (imm & right_n_bits(5)) >> 3);                           \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(8)) >> 8);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }                                                                                          \\\n+  void NAME(Register Rs1, address dest) {                                                    \\\n+    assert_cond(dest != NULL);                                                               \\\n+    int64_t distance = dest - pc();                                                          \\\n+    assert_cond(is_imm_in_range(distance, 8, 1));                                            \\\n+    NAME(Rs1, distance);                                                                     \\\n+  }                                                                                          \\\n+  void NAME(Register Rs1, Label &L) {                                                        \\\n+    wrap_label(L, Rs1, &Assembler::NAME);                                                    \\\n+  }\n+\n+  INSN(c_beqz, 0b110, 0b01);\n+  INSN(c_bnez, 0b111, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    assert_cond(is_imm_in_range(imm, 18, 0));                                                \\\n+    assert_cond((imm & 0xfff) == 0);                                                         \\\n+    assert_cond(imm != 0);                                                                   \\\n+    assert_cond(Rd != x0 && Rd != x2);                                                       \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(17)) >> 12);                           \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(17)) >> 17);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lui, 0b011, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    assert_cond(Rd != x0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & right_n_bits(6)) >> 5);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_li, 0b010, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    assert_cond(Rd != x0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 4, 2, (uimm & right_n_bits(9)) >> 6);                            \\\n+    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(5)) >> 3);                            \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_ldsp,  0b011, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(FloatRegister Rd, uint32_t uimm) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 4, 2, (uimm & right_n_bits(9)) >> 6);                            \\\n+    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(5)) >> 3);                            \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_fldsp, 0b001, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n+  void NAME(REGISTER_TYPE Rd_Rs2, Register Rs1, uint32_t uimm) {                             \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n+    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_ld,  0b011, 0b00, Register);\n+  INSN(c_sd,  0b111, 0b00, Register);\n+  INSN(c_fld, 0b001, 0b00, FloatRegister);\n+  INSN(c_fsd, 0b101, 0b00, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n+  void NAME(REGISTER_TYPE Rs2, uint32_t uimm) {                                              \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch((address)&insn, 9, 7, (uimm & right_n_bits(9)) >> 6);                            \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_sdsp,  0b111, 0b10, Register);\n+  INSN(c_fsdsp, 0b101, 0b10, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rs2, uint32_t uimm) {                                                   \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch((address)&insn, 8, 7, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch((address)&insn, 12, 9, (uimm & right_n_bits(6)) >> 2);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_swsp, 0b110, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    assert_cond(Rd != x0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 3, 2, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch((address)&insn, 6, 4, (uimm & right_n_bits(5)) >> 2);                            \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lwsp, 0b010, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs2, Register Rs1, uint32_t uimm) {                                  \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 7, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(6)) >> 6);                                 \\\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lw, 0b010, 0b00);\n+  INSN(c_sw, 0b110, 0b00);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME() {                                                                              \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 11, 2, 0x0);                                                     \\\n+    c_patch((address)&insn, 12, 12, 0b1);                                                    \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_ebreak, 0b100, 0b10);\n+\n+#undef INSN\n+\n+\/\/ --------------  RVC Transformation Functions  --------------\n+\n+\/\/ --------------------------\n+\/\/ Register instructions\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                             \\\n+  void NAME(Register Rd, Register Rs1, Register Rs2) {                                         \\\n+    \/* add -> c.add *\/                                                                         \\\n+    if (do_compress()) {                                                                       \\\n+      Register src = noreg;                                                                    \\\n+      if (Rs1 != x0 && Rs2 != x0 && ((src = Rs1, Rs2 == Rd) || (src = Rs2, Rs1 == Rd))) {      \\\n+        c_add(Rd, src);                                                                        \\\n+        return;                                                                                \\\n+      }                                                                                        \\\n+    }                                                                                          \\\n+    _add(Rd, Rs1, Rs2);                                                                        \\\n+  }\n+\n+  INSN(add);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME, C_NAME, NORMAL_NAME)                                                      \\\n+  void NAME(Register Rd, Register Rs1, Register Rs2) {                                       \\\n+    \/* sub\/subw -> c.sub\/c.subw *\/                                                           \\\n+    if (do_compress() &&                                                                     \\\n+        (Rd == Rs1 && Rd->is_compressed_valid() && Rs2->is_compressed_valid())) {            \\\n+      C_NAME(Rd, Rs2);                                                                       \\\n+      return;                                                                                \\\n+    }                                                                                        \\\n+    NORMAL_NAME(Rd, Rs1, Rs2);                                                               \\\n+  }\n+\n+  INSN(sub,  c_sub,  _sub);\n+  INSN(subw, c_subw, _subw);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME, C_NAME, NORMAL_NAME)                                                      \\\n+  void NAME(Register Rd, Register Rs1, Register Rs2) {                                       \\\n+    \/* and\/or\/xor\/addw -> c.and\/c.or\/c.xor\/c.addw *\/                                         \\\n+    if (do_compress()) {                                                                     \\\n+      Register src = noreg;                                                                  \\\n+      if (Rs1->is_compressed_valid() && Rs2->is_compressed_valid() &&                        \\\n+        ((src = Rs1, Rs2 == Rd) || (src = Rs2, Rs1 == Rd))) {                                \\\n+        C_NAME(Rd, src);                                                                     \\\n+        return;                                                                              \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    NORMAL_NAME(Rd, Rs1, Rs2);                                                               \\\n+  }\n+\n+  INSN(andr, c_and,  _andr);\n+  INSN(orr,  c_or,   _orr);\n+  INSN(xorr, c_xor,  _xorr);\n+  INSN(addw, c_addw, _addw);\n+\n+#undef INSN\n+\n+private:\n+\/\/ some helper functions\n+  bool do_compress() const {\n+    return UseRVC && in_compressible_region();\n+  }\n+\n+#define FUNC(NAME, funct3, bits)                                                             \\\n+  bool NAME(Register rs1, Register rd_rs2, int32_t imm12, bool ld) {                         \\\n+    return rs1 == sp &&                                                                      \\\n+      is_unsigned_imm_in_range(imm12, bits, 0) &&                                            \\\n+      (intx(imm12) & funct3) == 0x0 &&                                                       \\\n+      (!ld || rd_rs2 != x0);                                                                 \\\n+  }                                                                                          \\\n+\n+  FUNC(is_c_ldsdsp,  0b111, 9);\n+  FUNC(is_c_lwswsp,  0b011, 8);\n+\n+#undef FUNC\n+\n+#define FUNC(NAME, funct3, bits)                                                             \\\n+  bool NAME(Register rs1, int32_t imm12) {                                                   \\\n+    return rs1 == sp &&                                                                      \\\n+      is_unsigned_imm_in_range(imm12, bits, 0) &&                                            \\\n+      (intx(imm12) & funct3) == 0x0;                                                         \\\n+  }                                                                                          \\\n+\n+  FUNC(is_c_fldsdsp, 0b111, 9);\n+\n+#undef FUNC\n+\n+#define FUNC(NAME, REG_TYPE, funct3, bits)                                                   \\\n+  bool NAME(Register rs1, REG_TYPE rd_rs2, int32_t imm12) {                                  \\\n+    return rs1->is_compressed_valid() &&                                                     \\\n+      rd_rs2->is_compressed_valid() &&                                                       \\\n+      is_unsigned_imm_in_range(imm12, bits, 0) &&                                            \\\n+      (intx(imm12) & funct3) == 0x0;                                                         \\\n+  }                                                                                          \\\n+\n+  FUNC(is_c_ldsd,  Register,      0b111, 8);\n+  FUNC(is_c_lwsw,  Register,      0b011, 7);\n+  FUNC(is_c_fldsd, FloatRegister, 0b111, 8);\n+\n+#undef FUNC\n+\n+public:\n+\/\/ --------------------------\n+\/\/ Load\/store register\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    \/* lw -> c.lwsp\/c.lw *\/                                                                  \\\n+    if (do_compress()) {                                                                     \\\n+      if (is_c_lwswsp(Rs, Rd, offset, true)) {                                               \\\n+        c_lwsp(Rd, offset);                                                                  \\\n+        return;                                                                              \\\n+      } else if (is_c_lwsw(Rs, Rd, offset)) {                                                \\\n+        c_lw(Rd, Rs, offset);                                                                \\\n+        return;                                                                              \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _lw(Rd, Rs, offset);                                                                     \\\n+  }\n+\n+  INSN(lw);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    \/* ld -> c.ldsp\/c.ld *\/                                                                  \\\n+    if (do_compress()) {                                                                     \\\n+      if (is_c_ldsdsp(Rs, Rd, offset, true)) {                                               \\\n+        c_ldsp(Rd, offset);                                                                  \\\n+        return;                                                                              \\\n+      } else if (is_c_ldsd(Rs, Rd, offset)) {                                                \\\n+        c_ld(Rd, Rs, offset);                                                                \\\n+        return;                                                                              \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _ld(Rd, Rs, offset);                                                                     \\\n+  }\n+\n+  INSN(ld);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(FloatRegister Rd, Register Rs, const int32_t offset) {                           \\\n+    \/* fld -> c.fldsp\/c.fld *\/                                                               \\\n+    if (do_compress()) {                                                                     \\\n+      if (is_c_fldsdsp(Rs, offset)) {                                                        \\\n+        c_fldsp(Rd, offset);                                                                 \\\n+        return;                                                                              \\\n+      } else if (is_c_fldsd(Rs, Rd, offset)) {                                               \\\n+        c_fld(Rd, Rs, offset);                                                               \\\n+        return;                                                                              \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _fld(Rd, Rs, offset);                                                                    \\\n+  }\n+\n+  INSN(fld);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    \/* sd -> c.sdsp\/c.sd *\/                                                                  \\\n+    if (do_compress()) {                                                                     \\\n+      if (is_c_ldsdsp(Rs, Rd, offset, false)) {                                              \\\n+        c_sdsp(Rd, offset);                                                                  \\\n+        return;                                                                              \\\n+      } else if (is_c_ldsd(Rs, Rd, offset)) {                                                \\\n+        c_sd(Rd, Rs, offset);                                                                \\\n+        return;                                                                              \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _sd(Rd, Rs, offset);                                                                     \\\n+  }\n+\n+  INSN(sd);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    \/* sw -> c.swsp\/c.sw *\/                                                                  \\\n+    if (do_compress()) {                                                                     \\\n+      if (is_c_lwswsp(Rs, Rd, offset, false)) {                                              \\\n+        c_swsp(Rd, offset);                                                                  \\\n+        return;                                                                              \\\n+      } else if (is_c_lwsw(Rs, Rd, offset)) {                                                \\\n+        c_sw(Rd, Rs, offset);                                                                \\\n+        return;                                                                              \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _sw(Rd, Rs, offset);                                                                     \\\n+  }\n+\n+  INSN(sw);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(FloatRegister Rd, Register Rs, const int32_t offset) {                           \\\n+    \/* fsd -> c.fsdsp\/c.fsd *\/                                                               \\\n+    if (do_compress()) {                                                                     \\\n+      if (is_c_fldsdsp(Rs, offset)) {                                                        \\\n+        c_fsdsp(Rd, offset);                                                                 \\\n+        return;                                                                              \\\n+      } else if (is_c_fldsd(Rs, Rd, offset)) {                                               \\\n+        c_fsd(Rd, Rs, offset);                                                               \\\n+        return;                                                                              \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _fsd(Rd, Rs, offset);                                                                    \\\n+  }\n+\n+  INSN(fsd);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Conditional branch instructions\n+\/\/ --------------------------\n+#define INSN(NAME, C_NAME, NORMAL_NAME)                                                      \\\n+  void NAME(Register Rs1, Register Rs2, const int64_t offset) {                              \\\n+    \/* beq\/bne -> c.beqz\/c.bnez *\/                                                           \\\n+    if (do_compress() &&                                                                     \\\n+        (offset != 0 && Rs2 == x0 && Rs1->is_compressed_valid() &&                           \\\n+        is_imm_in_range(offset, 8, 1))) {                                                    \\\n+      C_NAME(Rs1, offset);                                                                   \\\n+      return;                                                                                \\\n+    }                                                                                        \\\n+    NORMAL_NAME(Rs1, Rs2, offset);                                                           \\\n+  }\n+\n+  INSN(beq, c_beqz, _beq);\n+  INSN(bne, c_beqz, _bne);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Unconditional branch instructions\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, const int32_t offset) {                                             \\\n+    \/* jal -> c.j *\/                                                                         \\\n+    if (do_compress() && offset != 0 && Rd == x0 && is_imm_in_range(offset, 11, 1)) {        \\\n+      c_j(offset);                                                                           \\\n+      return;                                                                                \\\n+    }                                                                                        \\\n+    _jal(Rd, offset);                                                                        \\\n+  }\n+\n+  INSN(jal);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs, const int32_t offset) {                                \\\n+    \/* jalr -> c.jr\/c.jalr *\/                                                                \\\n+    if (do_compress() && (offset == 0 && Rs != x0)) {                                        \\\n+      if (Rd == x1) {                                                                        \\\n+        c_jalr(Rs);                                                                          \\\n+        return;                                                                              \\\n+      } else if (Rd == x0) {                                                                 \\\n+        c_jr(Rs);                                                                            \\\n+        return;                                                                              \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _jalr(Rd, Rs, offset);                                                                   \\\n+  }\n+\n+  INSN(jalr);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Miscellaneous Instructions\n+\/\/ --------------------------\n+#define INSN(NAME)                                                     \\\n+  void NAME() {                                                        \\\n+    \/* ebreak -> c.ebreak *\/                                           \\\n+    if (do_compress()) {                                               \\\n+      c_ebreak();                                                      \\\n+      return;                                                          \\\n+    }                                                                  \\\n+    _ebreak();                                                         \\\n+  }\n+\n+  INSN(ebreak);\n+\n+#undef INSN\n+\n+#define INSN(NAME)                                                      \\\n+  void NAME() {                                                         \\\n+    \/* The illegal instruction in RVC is presented by a 16-bit 0. *\/    \\\n+    if (do_compress()) {                                                \\\n+      emit_int16(0);                                                    \\\n+      return;                                                           \\\n+    }                                                                   \\\n+    _halt();                                                            \\\n+  }\n+\n+  INSN(halt);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Immediate Instructions\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, int64_t imm) {                                                      \\\n+    \/* li -> c.li *\/                                                                         \\\n+    if (do_compress() && (is_imm_in_range(imm, 6, 0) && Rd != x0)) {                         \\\n+      c_li(Rd, imm);                                                                         \\\n+      return;                                                                                \\\n+    }                                                                                        \\\n+    _li(Rd, imm);                                                                            \\\n+  }\n+\n+  INSN(li);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs1, int32_t imm) {                                        \\\n+    \/* addi -> c.addi\/c.nop\/c.mv\/c.addi16sp\/c.addi4spn *\/                                    \\\n+    if (do_compress()) {                                                                     \\\n+      if (Rd == Rs1 && is_imm_in_range(imm, 6, 0)) {                                         \\\n+        c_addi(Rd, imm);                                                                     \\\n+        return;                                                                              \\\n+      } else if (imm == 0 && Rd != x0 && Rs1 != x0) {                                        \\\n+        c_mv(Rd, Rs1);                                                                       \\\n+        return;                                                                              \\\n+      } else if (Rs1 == sp && imm != 0) {                                                    \\\n+        if (Rd == Rs1 && (imm & 0b1111) == 0x0 && is_imm_in_range(imm, 10, 0)) {             \\\n+          c_addi16sp(imm);                                                                   \\\n+          return;                                                                            \\\n+        } else if (Rd->is_compressed_valid() && (imm & 0b11) == 0x0 && is_unsigned_imm_in_range(imm, 10, 0)) { \\\n+          c_addi4spn(Rd, imm);                                                               \\\n+          return;                                                                            \\\n+        }                                                                                    \\\n+      }                                                                                      \\\n+    }                                                                                        \\\n+    _addi(Rd, Rs1, imm);                                                                     \\\n+  }\n+\n+  INSN(addi);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs1, int32_t imm) {                                        \\\n+    \/* addiw -> c.addiw *\/                                                                   \\\n+    if (do_compress() && (Rd == Rs1 && Rd != x0 && is_imm_in_range(imm, 6, 0))) {            \\\n+      c_addiw(Rd, imm);                                                                      \\\n+      return;                                                                                \\\n+    }                                                                                        \\\n+    _addiw(Rd, Rs1, imm);                                                                    \\\n+  }\n+\n+  INSN(addiw);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs1, int32_t imm) {                                        \\\n+    \/* and_imm12 -> c.andi *\/                                                                \\\n+    if (do_compress() &&                                                                     \\\n+        (Rd == Rs1 && Rd->is_compressed_valid() && is_imm_in_range(imm, 6, 0))) {            \\\n+      c_andi(Rd, imm);                                                                       \\\n+      return;                                                                                \\\n+    }                                                                                        \\\n+    _and_imm12(Rd, Rs1, imm);                                                                \\\n+  }\n+\n+  INSN(and_imm12);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Shift Immediate Instructions\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, Register Rs1, unsigned shamt) {                                     \\\n+    \/* slli -> c.slli *\/                                                                     \\\n+    if (do_compress() && (Rd == Rs1 && Rd != x0 && shamt != 0)) {                            \\\n+      c_slli(Rd, shamt);                                                                     \\\n+      return;                                                                                \\\n+    }                                                                                        \\\n+    _slli(Rd, Rs1, shamt);                                                                   \\\n+  }\n+\n+  INSN(slli);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+#define INSN(NAME, C_NAME, NORMAL_NAME)                                                      \\\n+  void NAME(Register Rd, Register Rs1, unsigned shamt) {                                     \\\n+    \/* srai\/srli -> c.srai\/c.srli *\/                                                         \\\n+    if (do_compress() && (Rd == Rs1 && Rd->is_compressed_valid() && shamt != 0)) {           \\\n+      C_NAME(Rd, shamt);                                                                     \\\n+      return;                                                                                \\\n+    }                                                                                        \\\n+    NORMAL_NAME(Rd, Rs1, shamt);                                                             \\\n+  }\n+\n+  INSN(srai, c_srai, _srai);\n+  INSN(srli, c_srli, _srli);\n+\n+#undef INSN\n+\n+\/\/ --------------------------\n+\/\/ Upper Immediate Instruction\n+\/\/ --------------------------\n+#define INSN(NAME)                                                                           \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    \/* lui -> c.lui *\/                                                                       \\\n+    if (do_compress() && (Rd != x0 && Rd != x2 && imm != 0 && is_imm_in_range(imm, 18, 0))) { \\\n+      c_lui(Rd, imm);                                                                        \\\n+      return;                                                                                \\\n+    }                                                                                        \\\n+    _lui(Rd, imm);                                                                           \\\n+  }\n+\n+  INSN(lui);\n+\n+#undef INSN\n+\n+\/\/ ---------------------------------------------------------------------------------------\n+\n@@ -2003,1 +3008,1 @@\n-  Assembler(CodeBuffer* code) : AbstractAssembler(code) {\n+  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(false) {\n@@ -2025,2 +3030,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":1060,"deletions":57,"binary":false,"changes":1117,"status":"modified"},{"patch":"@@ -1325,1 +1325,6 @@\n-void LIR_Assembler::align_call(LIR_Code code) {  }\n+void LIR_Assembler::align_call(LIR_Code code) {\n+  \/\/ With RVC a call may get 2-byte aligned.\n+  \/\/   the address of jal itself (which will be patched later) should not span the cache line.\n+  \/\/   See CallStaticJavaDirectNode::compute_padding() for more info.\n+  __ align(4);\n+}\n@@ -1347,0 +1352,1 @@\n+  assert((__ offset() % 4) == 0, \"call pc (patchable jals) must be aligned to maintain atomicity\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -241,0 +241,3 @@\n+  \/\/ RISCV's amoswap instructions need a 4-byte alignment for the 4-byte word it swaps in memory\n+  __ align(4);\n+\n@@ -259,0 +262,1 @@\n+  assert(__ offset() % 4 == 0, \"RISCV CAS needs a 4-byte alignment for the 4-byte word it swaps in memory\");\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-  product(bool, UseRVB, false, EXPERIMENTAL, \"Use RVB instructions\")\n+  product(bool, UseRVB, false, EXPERIMENTAL, \"Use RVB instructions\")             \\\n+  product(bool, UseRVC, false, EXPERIMENTAL, \"Use RVC instructions\")\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,2 +91,3 @@\n-void MacroAssembler::align(int modulus) {\n-  while (offset() % modulus != 0) { nop(); }\n+void MacroAssembler::align(int modulus, int extra_offset) {\n+  CompressibleRegion cr(this);\n+  while ((offset() + extra_offset) % modulus != 0) { nop(); }\n@@ -804,0 +805,1 @@\n+\n@@ -963,0 +965,1 @@\n+  CompressibleRegion cr(this);\n@@ -984,0 +987,1 @@\n+  CompressibleRegion cr(this);\n@@ -1006,0 +1010,1 @@\n+  CompressibleRegion cr(this);\n@@ -1025,0 +1030,1 @@\n+  CompressibleRegion cr(this);\n@@ -1045,0 +1051,1 @@\n+  CompressibleRegion cr(this);\n@@ -1066,0 +1073,1 @@\n+  CompressibleRegion cr(this);\n@@ -1088,0 +1096,1 @@\n+  CompressibleRegion cr(this);\n@@ -1102,0 +1111,1 @@\n+  CompressibleRegion cr(this);\n@@ -1115,0 +1125,1 @@\n+  CompressibleRegion cr(this);\n@@ -1120,0 +1131,1 @@\n+  CompressibleRegion cr(this);\n@@ -1124,0 +1136,1 @@\n+  CompressibleRegion cr(this);\n@@ -1145,0 +1158,1 @@\n+  CompressibleRegion cr(this);\n@@ -1311,1 +1325,4 @@\n-    tty->print_cr(\"pd_patch_instruction_size: instruction 0x%x could not be patched!\\n\", *(unsigned*)branch);\n+#ifdef ASSERT\n+    tty->print_cr(\"pd_patch_instruction_size: instruction 0x%x at \" INTPTR_FORMAT \" could not be patched!\\n\", *(unsigned*)branch, p2i(branch));\n+    Disassembler::decode(branch - 10, branch + 10);\n+#endif\n@@ -2920,1 +2937,2 @@\n-  while (offset() % wordSize == 0) { nop(); }\n+  \/\/ when we reach here we may get a 2-byte alignment so need to align it\n+  align(wordSize, NativeCallTrampolineStub::data_offset);\n@@ -2935,0 +2953,1 @@\n+  assert(offset() % wordSize == 0, \"address loaded by ld must be 8-byte aligned under riscv64\");\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  void align(int modulus);\n+  void align(int modulus, int extra_offset = 0);\n@@ -448,0 +448,1 @@\n+  void bnez(Register Rs, const address &dest);\n@@ -452,1 +453,0 @@\n-  void bnez(Register Rs, const address &dest);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-    instruction_size = 4\n+    instruction_size = 4,\n+    compressed_instruction_size = 2,\n@@ -425,1 +426,1 @@\n-    instruction_size            =    4,\n+    instruction_size            =    NativeInstruction::instruction_size,\n@@ -428,1 +429,1 @@\n-    next_instruction_offset     =    4\n+    next_instruction_offset     =    NativeInstruction::instruction_size\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,5 @@\n-    max_slots_per_register   = 2\n+    max_slots_per_register   = 2,\n+\n+    \/\/ integer registers in the range of [x8~x15] correspond to RVC. Please see Table 16.2 in spec.\n+    compressed_register_base = 8,\n+    compressed_register_top  = 15,\n@@ -74,0 +78,1 @@\n+  int   compressed_encoding() const              { assert(is_compressed_valid(), \"invalid compressed register\"); return ((intptr_t)this - compressed_register_base); }\n@@ -75,0 +80,1 @@\n+  bool  is_compressed_valid() const              { return compressed_register_base <= (intptr_t)this && (intptr_t)this <= compressed_register_top; }\n@@ -78,0 +84,1 @@\n+  int   compressed_encoding_nocheck() const      { return ((intptr_t)this - compressed_register_base); }\n@@ -134,1 +141,5 @@\n-    max_slots_per_register  = 2\n+    max_slots_per_register  = 2,\n+\n+    \/\/ float registers in the range of [f8~f15] correspond to RVC. Please see Table 16.2 in spec.\n+    compressed_register_base = 8,\n+    compressed_register_top  = 15,\n@@ -147,0 +158,1 @@\n+  int   compressed_encoding() const               { assert(is_compressed_valid(), \"invalid compressed register\"); return ((intptr_t)this - compressed_register_base); }\n@@ -148,0 +160,1 @@\n+  int   compressed_encoding_nocheck() const       { return ((intptr_t)this - compressed_register_base); }\n@@ -149,0 +162,1 @@\n+  bool  is_compressed_valid() const               { return compressed_register_base <= (intptr_t)this && (intptr_t)this <= compressed_register_top; }\n","filename":"src\/hotspot\/cpu\/riscv\/register_riscv.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1159,3 +1159,2 @@\n-  \/\/ call should be a simple jal\n-  int off = 4;\n-  return off;\n+  \/\/ jal\n+  return 1 * NativeInstruction::instruction_size;\n@@ -1166,1 +1165,1 @@\n-  return 28; \/\/ movptr, jal\n+  return 7 * NativeInstruction::instruction_size; \/\/ movptr, jal\n@@ -1174,1 +1173,1 @@\n-  \/\/ for real runtime callouts it will be five instructions\n+  \/\/ for real runtime callouts it will be 11 instructions\n@@ -1176,5 +1175,5 @@\n-  \/\/   la(t1, retaddr)\n-  \/\/   la(t0, RuntimeAddress(addr))\n-  \/\/   addi(sp, sp, -2 * wordSize)\n-  \/\/   sd(t1, Address(sp, wordSize))\n-  \/\/   jalr(t0)\n+  \/\/   la(t1, retaddr)                ->  auipc + addi\n+  \/\/   la(t0, RuntimeAddress(addr))   ->  lui + addi + slli + addi + slli + addi\n+  \/\/   addi(sp, sp, -2 * wordSize)    ->  addi\n+  \/\/   sd(t1, Address(sp, wordSize))  ->  sd\n+  \/\/   jalr(t0)                       ->  jalr\n@@ -1194,0 +1193,24 @@\n+\/\/ With RVC a call may get 2-byte aligned.\n+\/\/   The offset encoding in jal ranges bits [12, 31] could span the cache line.\n+\/\/   Patching this unaligned address will make the write operation not atomic.\n+\/\/   Other threads may be running the same piece of code at full speed, causing concurrency issues.\n+\/\/   So we must ensure that it does not span a cache line so that it can be patched.\n+int CallStaticJavaDirectNode::compute_padding(int current_offset) const\n+{\n+  \/\/ to make sure the address of jal 4-byte aligned.\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n+\/\/ Please see CallStaticJavaDirectNode::compute_padding() for more info.\n+int CallDynamicJavaDirectNode::compute_padding(int current_offset) const\n+{\n+  \/\/ skip the movptr in MacroAssembler::ic_call():\n+  \/\/ lui + addi + slli + addi + slli + addi\n+  \/\/ Though movptr() has already 4-byte aligned with or without RVC,\n+  \/\/ We need to prevent from further changes by explicitly calculating the size.\n+  const int movptr_size = 6 * NativeInstruction::instruction_size;\n+  current_offset += movptr_size;\n+  \/\/ to make sure the address of jal 4-byte aligned.\n+  return align_up(current_offset, alignment_required()) - current_offset;\n+}\n+\n@@ -1205,0 +1228,1 @@\n+  Assembler::CompressibleRegion cr(&_masm);\n@@ -1222,0 +1246,1 @@\n+    Assembler::CompressibleRegion cr(&_masm); \/\/ nops shall be 2-byte under RVC for alignment purposes.\n@@ -1228,1 +1253,1 @@\n-    return _count * NativeInstruction::instruction_size;\n+    return _count * (UseRVC ? NativeInstruction::compressed_instruction_size : NativeInstruction::instruction_size);\n@@ -1490,0 +1515,1 @@\n+      Assembler::CompressibleRegion cr(&_masm);\n@@ -1510,0 +1536,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2047,0 +2074,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2073,0 +2101,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2485,0 +2514,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2491,0 +2521,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -2506,0 +2537,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4490,0 +4522,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4505,0 +4538,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4535,0 +4569,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4566,0 +4601,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4596,0 +4632,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4641,0 +4678,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4925,0 +4963,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4954,0 +4993,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -4984,0 +5024,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -5014,0 +5055,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -5058,0 +5100,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -5073,0 +5116,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6368,0 +6412,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6383,0 +6428,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6399,0 +6445,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6415,0 +6462,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6430,0 +6478,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6445,0 +6494,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6461,0 +6511,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6476,0 +6527,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6493,0 +6545,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6509,0 +6562,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6525,0 +6579,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6540,0 +6595,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6669,0 +6725,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6824,0 +6881,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6859,0 +6917,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6877,0 +6936,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -6912,0 +6972,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7375,0 +7436,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7391,0 +7453,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7407,0 +7470,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7439,0 +7503,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7471,0 +7536,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7487,0 +7553,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7503,0 +7570,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7535,0 +7603,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7736,0 +7805,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7751,0 +7821,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -7905,0 +7976,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8059,0 +8131,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8076,0 +8149,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8172,0 +8246,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8208,0 +8283,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8226,0 +8302,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8262,0 +8339,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8280,0 +8358,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -8298,0 +8377,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n@@ -9834,0 +9914,1 @@\n+  ins_alignment(4);\n@@ -9853,0 +9934,1 @@\n+  ins_alignment(4);\n@@ -10433,0 +10515,1 @@\n+    Assembler::CompressibleRegion cr(&_masm);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":94,"deletions":11,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -119,0 +119,5 @@\n+  if (UseRVC && !(_features & CPU_C)) {\n+    warning(\"RVC is not supported on this CPU\");\n+    FLAG_SET_DEFAULT(UseRVC, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}