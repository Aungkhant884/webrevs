{"files":[{"patch":"@@ -258,0 +258,1 @@\n+  #include \"assembler_riscv_c.hpp\"\n@@ -1241,1 +1242,1 @@\n-  Assembler(CodeBuffer* code) : AbstractAssembler(code) {\n+  Assembler(CodeBuffer* code) : AbstractAssembler(code), _in_compressible_region(false) {\n@@ -1265,2 +1266,0 @@\n-class BiasedLockingCounters;\n-\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,581 @@\n+\/*\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2021, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CPU_RISCV_ASSEMBLER_RISCV_CEXT_HPP\n+#define CPU_RISCV_ASSEMBLER_RISCV_CEXT_HPP\n+\n+private:\n+  bool _in_compressible_region;\n+public:\n+  bool in_compressible_region() const { return _in_compressible_region; }\n+  void set_in_compressible_region(bool b) { _in_compressible_region = b; }\n+public:\n+\n+  \/\/ C-Ext: If an instruction is compressible, then\n+  \/\/   we will implicitly emit a 16-bit compressed instruction instead of the 32-bit\n+  \/\/   instruction in Assembler. All below logic follows Chapter -\n+  \/\/   \"C\" Standard Extension for Compressed Instructions, Version 2.0.\n+  \/\/   We can get code size reduction and performance improvement with this extension,\n+  \/\/   considering the reduction of instruction size and the code density increment.\n+\n+  \/\/ Note:\n+  \/\/   1. When UseRVC is enabled, 32-bit instructions under 'CompressibleRegion's will be\n+  \/\/      transformed to 16-bit instructions if compressible.\n+  \/\/   2. C-Ext's instructions in Assembler always begin with 'c_' prefix, as 'c_li',\n+  \/\/      but most of time we have no need to explicitly use these instructions.\n+  \/\/   3. In some cases, we need to force using one instruction's uncompressed version,\n+  \/\/      for instance code being patched should remain its general and longest version\n+  \/\/      to cover all possible cases, or code requiring a fixed length.\n+  \/\/      So we introduce 'UncompressibleRegion' to force instructions in its range\n+  \/\/      to remain its normal 4-byte version.\n+  \/\/      An example:\n+  \/\/\n+  \/\/        CompressibleRegion cr(_masm);\n+  \/\/        __ andr(...);      \/\/ this instruction could change to c.and if qualified\n+  \/\/        {\n+  \/\/          UncompressibleRegion ur(_masm);\n+  \/\/          __ andr(...);    \/\/ this instruction would remain the normal 32-bit form of andr\n+  \/\/        }\n+  \/\/\n+  \/\/   4. Using -XX:PrintAssemblyOptions=no-aliases could print C-Ext instructions instead of\n+  \/\/      normal ones.\n+  \/\/\n+\n+  \/\/ C-Ext: extract a 16-bit instruction.\n+  static inline uint16_t c_extract(uint16_t val, unsigned msb, unsigned lsb) {\n+    assert_cond(msb >= lsb && msb <= 15);\n+    unsigned nbits = msb - lsb + 1;\n+    uint16_t mask = (1U << nbits) - 1;\n+    uint16_t result = val >> lsb;\n+    result &= mask;\n+    return result;\n+  }\n+\n+  static inline int16_t c_sextract(uint16_t val, unsigned msb, unsigned lsb) {\n+    assert_cond(msb >= lsb && msb <= 15);\n+    int16_t result = val << (15 - msb);\n+    result >>= (15 - msb + lsb);\n+    return result;\n+  }\n+\n+  \/\/ C-Ext: patch a 16-bit instruction.\n+  static void c_patch(address a, unsigned msb, unsigned lsb, uint16_t val) {\n+    assert_cond(a != NULL);\n+    assert_cond(msb >= lsb && msb <= 15);\n+    unsigned nbits = msb - lsb + 1;\n+    guarantee(val < (1U << nbits), \"Field too big for insn\");\n+    uint16_t mask = (1U << nbits) - 1;\n+    val <<= lsb;\n+    mask <<= lsb;\n+    uint16_t target = *(uint16_t *)a;\n+    target &= ~mask;\n+    target |= val;\n+    *(uint16_t *)a = target;\n+  }\n+\n+  static void c_patch(address a, unsigned bit, uint16_t val) {\n+    c_patch(a, bit, bit, val);\n+  }\n+\n+  \/\/ C-Ext: patch a 16-bit instruction with a general purpose register ranging [0, 31] (5 bits)\n+  static void c_patch_reg(address a, unsigned lsb, Register reg) {\n+    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n+  }\n+\n+  \/\/ C-Ext: patch a 16-bit instruction with a general purpose register ranging [8, 15] (3 bits)\n+  static void c_patch_compressed_reg(address a, unsigned lsb, Register reg) {\n+    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n+  }\n+\n+  \/\/ C-Ext: patch a 16-bit instruction with a float register ranging [0, 31] (5 bits)\n+  static void c_patch_reg(address a, unsigned lsb, FloatRegister reg) {\n+    c_patch(a, lsb + 4, lsb, reg->encoding_nocheck());\n+  }\n+\n+  \/\/ C-Ext: patch a 16-bit instruction with a float register ranging [8, 15] (3 bits)\n+  static void c_patch_compressed_reg(address a, unsigned lsb, FloatRegister reg) {\n+    c_patch(a, lsb + 2, lsb, reg->compressed_encoding_nocheck());\n+  }\n+\n+public:\n+\n+\/\/ C-Ext: Compressed Instructions\n+\n+\/\/ --------------  C-Ext Instruction Definitions  --------------\n+\n+  void c_nop() {\n+    c_addi(x0, 0);\n+  }\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi,   0b000, 0b01);\n+  INSN(c_addiw,  0b001, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(int32_t imm) {                                                                   \\\n+    assert_cond(is_imm_in_range(imm, 10, 0));                                                \\\n+    assert_cond((imm & 0b1111) == 0);                                                        \\\n+    assert_cond(imm != 0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n+    c_patch((address)&insn, 4, 3, (imm & right_n_bits(9)) >> 7);                             \\\n+    c_patch((address)&insn, 5, 5, (imm & nth_bit(6)) >> 6);                                  \\\n+    c_patch((address)&insn, 6, 6, (imm & nth_bit(4)) >> 4);                                  \\\n+    c_patch_reg((address)&insn, 7, sp);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(9)) >> 9);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi16sp, 0b011, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 10, 0));                                      \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    assert_cond(uimm != 0);                                                                  \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd);                                           \\\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(3)) >> 3);                                 \\\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n+    c_patch((address)&insn, 10, 7, (uimm & right_n_bits(10)) >> 6);                          \\\n+    c_patch((address)&insn, 12, 11, (uimm & right_n_bits(6)) >> 4);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_addi4spn, 0b000, 0b00);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n+    assert_cond(shamt != 0);                                                                 \\\n+    assert_cond(Rd_Rs1 != x0);                                                               \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_slli, 0b000, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, uint32_t shamt) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(shamt, 6, 0));                                      \\\n+    assert_cond(shamt != 0);                                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (shamt & right_n_bits(5)));                                \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n+    c_patch((address)&insn, 12, 12, (shamt & nth_bit(5)) >> 5);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_srli, 0b100, 0b00, 0b01);\n+  INSN(c_srai, 0b100, 0b01, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, int32_t imm) {                                                  \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 11, 10, funct2);                                                 \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(5)) >> 5);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_andi, 0b100, 0b10, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct6, funct2, op)                                                       \\\n+  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rs2);                                          \\\n+    c_patch((address)&insn, 6, 5, funct2);                                                   \\\n+    c_patch_compressed_reg((address)&insn, 7, Rd_Rs1);                                       \\\n+    c_patch((address)&insn, 15, 10, funct6);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_sub,  0b100011, 0b00, 0b01);\n+  INSN(c_xor,  0b100011, 0b01, 0b01);\n+  INSN(c_or,   0b100011, 0b10, 0b01);\n+  INSN(c_and,  0b100011, 0b11, 0b01);\n+  INSN(c_subw, 0b100111, 0b00, 0b01);\n+  INSN(c_addw, 0b100111, 0b01, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct4, op)                                                               \\\n+  void NAME(Register Rd_Rs1, Register Rs2) {                                                 \\\n+    assert_cond(Rd_Rs1 != x0);                                                               \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch_reg((address)&insn, 7, Rd_Rs1);                                                  \\\n+    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_mv,  0b1000, 0b10);\n+  INSN(c_add, 0b1001, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct4, op)                                                               \\\n+  void NAME(Register Rs1) {                                                                  \\\n+    assert_cond(Rs1 != x0);                                                                  \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, x0);                                                      \\\n+    c_patch_reg((address)&insn, 7, Rs1);                                                     \\\n+    c_patch((address)&insn, 15, 12, funct4);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_jr,   0b1000, 0b10);\n+  INSN(c_jalr, 0b1001, 0b10);\n+\n+#undef INSN\n+\n+  typedef void (Assembler::* j_c_insn)(address dest);\n+  typedef void (Assembler::* compare_and_branch_c_insn)(Register Rs1, address dest);\n+\n+  void wrap_label(Label &L, j_c_insn insn) {\n+    if (L.is_bound()) {\n+      (this->*insn)(target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(pc());\n+    }\n+  }\n+\n+  void wrap_label(Label &L, Register r, compare_and_branch_c_insn insn) {\n+    if (L.is_bound()) {\n+      (this->*insn)(r, target(L));\n+    } else {\n+      L.add_patch_at(code(), locator());\n+      (this->*insn)(r, pc());\n+    }\n+  }\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(int32_t offset) {                                                                \\\n+    assert_cond(is_imm_in_range(offset, 11, 1));                                             \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (offset & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 5, 3, (offset & right_n_bits(4)) >> 1);                          \\\n+    c_patch((address)&insn, 6, 6, (offset & nth_bit(7)) >> 7);                               \\\n+    c_patch((address)&insn, 7, 7, (offset & nth_bit(6)) >> 6);                               \\\n+    c_patch((address)&insn, 8, 8, (offset & nth_bit(10)) >> 10);                             \\\n+    c_patch((address)&insn, 10, 9, (offset & right_n_bits(10)) >> 8);                        \\\n+    c_patch((address)&insn, 11, 11, (offset & nth_bit(4)) >> 4);                             \\\n+    c_patch((address)&insn, 12, 12, (offset & nth_bit(11)) >> 11);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }                                                                                          \\\n+  void NAME(address dest) {                                                                  \\\n+    assert_cond(dest != NULL);                                                               \\\n+    int64_t distance = dest - pc();                                                          \\\n+    assert_cond(is_imm_in_range(distance, 11, 1));                                           \\\n+    c_j(distance);                                                                           \\\n+  }                                                                                          \\\n+  void NAME(Label &L) {                                                                      \\\n+    wrap_label(L, &Assembler::NAME);                                                         \\\n+  }\n+\n+  INSN(c_j, 0b101, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rs1, int32_t imm) {                                                     \\\n+    assert_cond(is_imm_in_range(imm, 8, 1));                                                 \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 2, 2, (imm & nth_bit(5)) >> 5);                                  \\\n+    c_patch((address)&insn, 4, 3, (imm & right_n_bits(3)) >> 1);                             \\\n+    c_patch((address)&insn, 6, 5, (imm & right_n_bits(8)) >> 6);                             \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 11, 10, (imm & right_n_bits(5)) >> 3);                           \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(8)) >> 8);                                \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }                                                                                          \\\n+  void NAME(Register Rs1, address dest) {                                                    \\\n+    assert_cond(dest != NULL);                                                               \\\n+    int64_t distance = dest - pc();                                                          \\\n+    assert_cond(is_imm_in_range(distance, 8, 1));                                            \\\n+    NAME(Rs1, distance);                                                                     \\\n+  }                                                                                          \\\n+  void NAME(Register Rs1, Label &L) {                                                        \\\n+    wrap_label(L, Rs1, &Assembler::NAME);                                                    \\\n+  }\n+\n+  INSN(c_beqz, 0b110, 0b01);\n+  INSN(c_bnez, 0b111, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    assert_cond(is_imm_in_range(imm, 18, 0));                                                \\\n+    assert_cond((imm & 0xfff) == 0);                                                         \\\n+    assert_cond(imm != 0);                                                                   \\\n+    assert_cond(Rd != x0 && Rd != x2);                                                       \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(17)) >> 12);                           \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & nth_bit(17)) >> 17);                              \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lui, 0b011, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, int32_t imm) {                                                      \\\n+    assert_cond(is_imm_in_range(imm, 6, 0));                                                 \\\n+    assert_cond(Rd != x0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 6, 2, (imm & right_n_bits(5)));                                  \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (imm & right_n_bits(6)) >> 5);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_li, 0b010, 0b01);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE, CHECK)                                         \\\n+  void NAME(REGISTER_TYPE Rd, uint32_t uimm) {                                               \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    IF(CHECK, assert_cond(Rd != x0);)                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 4, 2, (uimm & right_n_bits(9)) >> 6);                            \\\n+    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(5)) >> 3);                            \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+#define IF(BOOL, ...)       IF_##BOOL(__VA_ARGS__)\n+#define IF_true(code)       code\n+#define IF_false(code)\n+\n+  INSN(c_ldsp,  0b011, 0b10, Register,      true);\n+  INSN(c_fldsp, 0b001, 0b10, FloatRegister, false);\n+\n+#undef IF_false\n+#undef IF_true\n+#undef IF\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n+  void NAME(REGISTER_TYPE Rd_Rs2, Register Rs1, uint32_t uimm) {                             \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n+    c_patch((address)&insn, 6, 5, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_ld,  0b011, 0b00, Register);\n+  INSN(c_sd,  0b111, 0b00, Register);\n+  INSN(c_fld, 0b001, 0b00, FloatRegister);\n+  INSN(c_fsd, 0b101, 0b00, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op, REGISTER_TYPE)                                                \\\n+  void NAME(REGISTER_TYPE Rs2, uint32_t uimm) {                                              \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 9, 0));                                       \\\n+    assert_cond((uimm & 0b111) == 0);                                                        \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch((address)&insn, 9, 7, (uimm & right_n_bits(9)) >> 6);                            \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_sdsp,  0b111, 0b10, Register);\n+  INSN(c_fsdsp, 0b101, 0b10, FloatRegister);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rs2, uint32_t uimm) {                                                   \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_reg((address)&insn, 2, Rs2);                                                     \\\n+    c_patch((address)&insn, 8, 7, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch((address)&insn, 12, 9, (uimm & right_n_bits(6)) >> 2);                           \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_swsp, 0b110, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd, uint32_t uimm) {                                                    \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 8, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    assert_cond(Rd != x0);                                                                   \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 3, 2, (uimm & right_n_bits(8)) >> 6);                            \\\n+    c_patch((address)&insn, 6, 4, (uimm & right_n_bits(5)) >> 2);                            \\\n+    c_patch_reg((address)&insn, 7, Rd);                                                      \\\n+    c_patch((address)&insn, 12, 12, (uimm & nth_bit(5)) >> 5);                               \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lwsp, 0b010, 0b10);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME(Register Rd_Rs2, Register Rs1, uint32_t uimm) {                                  \\\n+    assert_cond(is_unsigned_imm_in_range(uimm, 7, 0));                                       \\\n+    assert_cond((uimm & 0b11) == 0);                                                         \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch_compressed_reg((address)&insn, 2, Rd_Rs2);                                       \\\n+    c_patch((address)&insn, 5, 5, (uimm & nth_bit(6)) >> 6);                                 \\\n+    c_patch((address)&insn, 6, 6, (uimm & nth_bit(2)) >> 2);                                 \\\n+    c_patch_compressed_reg((address)&insn, 7, Rs1);                                          \\\n+    c_patch((address)&insn, 12, 10, (uimm & right_n_bits(6)) >> 3);                          \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_lw, 0b010, 0b00);\n+  INSN(c_sw, 0b110, 0b00);\n+\n+#undef INSN\n+\n+#define INSN(NAME, funct3, op)                                                               \\\n+  void NAME() {                                                                              \\\n+    uint16_t insn = 0;                                                                       \\\n+    c_patch((address)&insn, 1, 0, op);                                                       \\\n+    c_patch((address)&insn, 11, 2, 0x0);                                                     \\\n+    c_patch((address)&insn, 12, 12, 0b1);                                                    \\\n+    c_patch((address)&insn, 15, 13, funct3);                                                 \\\n+    emit_int16(insn);                                                                        \\\n+  }\n+\n+  INSN(c_ebreak, 0b100, 0b10);\n+\n+#undef INSN\n+\n+public:\n+\/\/ C-Ext: an abstact compressible region\n+class AbstractCompressibleRegion : public StackObj {\n+protected:\n+  Assembler *_masm;\n+  bool _prev_in_compressible_region;\n+protected:\n+  AbstractCompressibleRegion(Assembler *_masm)\n+  : _masm(_masm)\n+  , _prev_in_compressible_region(_masm->in_compressible_region()) {}\n+};\n+\n+class CompressibleRegion : public AbstractCompressibleRegion {\n+public:\n+  CompressibleRegion(Assembler *_masm) : AbstractCompressibleRegion(_masm) {\n+    _masm->set_in_compressible_region(true);\n+  }\n+  ~CompressibleRegion() {\n+    _masm->set_in_compressible_region(_prev_in_compressible_region);\n+  }\n+};\n+\n+\/\/ C-Ext: an uncompressible region\n+class UncompressibleRegion : public AbstractCompressibleRegion {\n+public:\n+  UncompressibleRegion(Assembler *_masm) : AbstractCompressibleRegion(_masm) {\n+    _masm->set_in_compressible_region(false);\n+  }\n+  ~UncompressibleRegion() {\n+    _masm->set_in_compressible_region(_prev_in_compressible_region);\n+  }\n+};\n+\n+#endif \/\/ CPU_RISCV_ASSEMBLER_RISCV_CEXT_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv_c.hpp","additions":581,"deletions":0,"binary":false,"changes":581,"status":"added"},{"patch":"@@ -93,1 +93,2 @@\n-  product(bool, UseRVV, false, EXPERIMENTAL, \"Use RVV instructions\")\n+  product(bool, UseRVV, false, EXPERIMENTAL, \"Use RVV instructions\")             \\\n+  product(bool, UseRVC, false, EXPERIMENTAL, \"Use RVC instructions\")             \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1319,1 +1319,4 @@\n-    tty->print_cr(\"pd_patch_instruction_size: instruction 0x%x could not be patched!\\n\", *(unsigned*)branch);\n+#ifdef ASSERT\n+    tty->print_cr(\"pd_patch_instruction_size: instruction 0x%x at \" INTPTR_FORMAT \" could not be patched!\\n\", *(unsigned*)branch, p2i(branch));\n+    Disassembler::decode(branch - 10, branch + 10);\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-    instruction_size = 4\n+    instruction_size = 4,\n+    compressed_instruction_size = 2,\n@@ -425,1 +426,1 @@\n-    instruction_size            =    4,\n+    instruction_size            =    NativeInstruction::instruction_size,\n@@ -428,1 +429,1 @@\n-    next_instruction_offset     =    4\n+    next_instruction_offset     =    NativeInstruction::instruction_size\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,1 +61,5 @@\n-    max_slots_per_register   = 2\n+    max_slots_per_register   = 2,\n+\n+    \/\/ C-Ext: integer registers in the range of [x8~x15] are correspond for RVC. Please see Table 16.2 in spec.\n+    compressed_register_base = 8,\n+    compressed_register_top  = 15,\n@@ -74,0 +78,1 @@\n+  int   compressed_encoding() const              { assert(is_compressed_valid(), \"invalid compressed register\"); return ((intptr_t)this - compressed_register_base); }\n@@ -75,0 +80,1 @@\n+  bool  is_compressed_valid() const              { return compressed_register_base <= (intptr_t)this && (intptr_t)this <= compressed_register_top; }\n@@ -78,0 +84,1 @@\n+  int   compressed_encoding_nocheck() const      { return ((intptr_t)this - compressed_register_base); }\n@@ -134,1 +141,5 @@\n-    max_slots_per_register  = 2\n+    max_slots_per_register  = 2,\n+\n+    \/\/ C-Ext: float registers in the range of [f8~f15] are correspond for RVC. Please see Table 16.2 in spec.\n+    compressed_register_base = 8,\n+    compressed_register_top  = 15,\n@@ -147,0 +158,1 @@\n+  int   compressed_encoding() const               { assert(is_compressed_valid(), \"invalid compressed register\"); return ((intptr_t)this - compressed_register_base); }\n@@ -148,0 +160,1 @@\n+  int   compressed_encoding_nocheck() const       { return ((intptr_t)this - compressed_register_base); }\n@@ -149,0 +162,1 @@\n+  bool  is_compressed_valid() const               { return compressed_register_base <= (intptr_t)this && (intptr_t)this <= compressed_register_top; }\n","filename":"src\/hotspot\/cpu\/riscv\/register_riscv.hpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1159,3 +1159,2 @@\n-  \/\/ call should be a simple jal\n-  int off = 4;\n-  return off;\n+  \/\/ jal\n+  return 1 * NativeInstruction::instruction_size;\n@@ -1166,1 +1165,1 @@\n-  return 28; \/\/ movptr, jal\n+  return 7 * NativeInstruction::instruction_size; \/\/ movptr, jal\n@@ -1174,1 +1173,1 @@\n-  \/\/ for real runtime callouts it will be five instructions\n+  \/\/ for real runtime callouts it will be 11 instructions\n@@ -1176,5 +1175,5 @@\n-  \/\/   la(t1, retaddr)\n-  \/\/   la(t0, RuntimeAddress(addr))\n-  \/\/   addi(sp, sp, -2 * wordSize)\n-  \/\/   sd(t1, Address(sp, wordSize))\n-  \/\/   jalr(t0)\n+  \/\/   la(t1, retaddr)                ->  auipc + addi\n+  \/\/   la(t0, RuntimeAddress(addr))   ->  lui + addi + slli + addi + slli + addi\n+  \/\/   addi(sp, sp, -2 * wordSize)    ->  addi\n+  \/\/   sd(t1, Address(sp, wordSize))  ->  sd\n+  \/\/   jalr(t0)                       ->  jalr\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -106,0 +106,6 @@\n+  \/\/ compressed instruction extension\n+  if (UseRVC && !(_features & CPU_C)) {\n+    warning(\"RVC is not supported on this CPU\");\n+    FLAG_SET_DEFAULT(UseRVC, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}