{"files":[{"patch":"@@ -27,0 +27,3 @@\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n@@ -29,0 +32,1 @@\n+#include \"runtime\/stubCodeGenerator.hpp\"\n@@ -35,0 +39,39 @@\n+static BufferBlob* stub_blob;\n+static const int vlen_stub_size=100;\n+\n+extern \"C\" {\n+  typedef uint32_t (*get_vector_len_stub_t)();\n+}\n+static get_vector_len_stub_t get_vector_len_stub = NULL;\n+\n+class VM_Version_StubGenerator: public StubCodeGenerator {\n+ public:\n+\n+  VM_Version_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}\n+  ~VM_Version_StubGenerator() {}\n+\n+  address generate_get_vector_len_stub(address* fault_pc, address* fault_pc2, address* continuation_pc) {\n+    StubCodeMark mark(this, \"VM_Version\", \"get_vector_len_stub\");\n+#   define __ _masm->\n+    address start = __ pc();\n+\n+    __ enter();\n+\n+    \/\/ read vcsr and vlenb, it may raise sigill\n+    __ mv(x10, zr);\n+    *fault_pc = __ pc();\n+    __ csrr(x10, CSR_VCSR);\n+\n+    __ mv(x10, zr);\n+    *fault_pc2 = __ pc();\n+    __ csrr(x10, CSR_VLENB);\n+\n+    *continuation_pc = __ pc();\n+    __ leave();\n+    __ ret();\n+\n+#   undef __\n+    return start;\n+  }\n+};\n+\n@@ -36,0 +79,3 @@\n+address  VM_Version::_checkvext_fault_pc = NULL;\n+address  VM_Version::_checkvext_fault_pc2 = NULL;\n+address  VM_Version::_checkvext_continuation_pc = NULL;\n@@ -112,1 +158,20 @@\n-      _initial_vector_length = get_current_vector_length();\n+\n+      \/\/ try to read vector register VLENB, if success, rvv is supported\n+      \/\/ otherwise, csrr will trigger sigill\n+      ResourceMark rm;\n+\n+      stub_blob = BufferBlob::create(\"get_vector_len_stub\", vlen_stub_size);\n+      if (stub_blob == NULL) {\n+        vm_exit_during_initialization(\"Unable to allocate get_vector_len_stub\");\n+      }\n+\n+      CodeBuffer c(stub_blob);\n+      VM_Version_StubGenerator g(&c);\n+      get_vector_len_stub = CAST_TO_FN_PTR(get_vector_len_stub_t,\n+                                     g.generate_get_vector_len_stub(&VM_Version::_checkvext_fault_pc,\n+                                                &VM_Version::_checkvext_fault_pc2,\n+                                                &VM_Version::_checkvext_continuation_pc));\n+      _initial_vector_length = get_vector_len_stub();\n+      if (_initial_vector_length == 0) {\n+        FLAG_SET_DEFAULT(UseRVV, false);\n+      }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -42,0 +42,8 @@\n+  static bool is_checkvext_fault(address pc) {\n+    return pc != NULL && (pc == _checkvext_fault_pc || pc == _checkvext_fault_pc2);\n+  }\n+\n+  static address continuation_for_checkvext_fault(address pc) {\n+    assert(_checkvext_continuation_pc != NULL, \"not initialized\");\n+    return _checkvext_continuation_pc;\n+  }\n@@ -61,0 +69,3 @@\n+  static address _checkvext_fault_pc;\n+  static address _checkvext_fault_pc2;\n+  static address _checkvext_continuation_pc;\n@@ -63,1 +74,0 @@\n-  static uint32_t get_current_vector_length();\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -205,0 +205,5 @@\n+    if (sig == SIGILL && VM_Version::is_checkvext_fault(pc)) {\n+      os::Posix::ucontext_set_pc(uc, VM_Version::continuation_for_checkvext_fault(pc));\n+      return true;\n+    }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -77,5 +77,0 @@\n-uint32_t VM_Version::get_current_vector_length() {\n-  assert(_features & CPU_V, \"should not call this\");\n-  return (uint32_t)read_csr(CSR_VLENB);\n-}\n-\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}