{"files":[{"patch":"@@ -240,1 +240,1 @@\n-  reg_save_frame_size = 32 \/* float *\/ + 32 \/* integer *\/\n+  reg_save_frame_size = 32 \/* float *\/ + 30 \/* integer excluding x3, x4 *\/\n@@ -265,1 +265,1 @@\n-                                                                                        x28,  x29, x30, x31};\n+                                                                                        x28, x29, x30, x31};\n@@ -289,2 +289,2 @@\n-  \/\/ if the number of pushed regs is odd, zr will be added\n-  __ push_reg(RegSet::range(x3, x31), sp);    \/\/ integer registers except ra(x1) & sp(x2)\n+  \/\/ if the number of pushed regs is odd, one slot will be reserved for alignment\n+  __ push_reg(RegSet::range(x5, x31), sp);    \/\/ integer registers except ra(x1) & sp(x2) & gp(x3) & tp(x4)\n@@ -299,1 +299,1 @@\n-    \/\/ we define reg_save_layout = 64 as the fixed frame size,\n+    \/\/ we define reg_save_layout = 62 as the fixed frame size,\n@@ -319,2 +319,2 @@\n-  \/\/ if the number of popped regs is odd, zr will be added\n-  __ pop_reg(RegSet::range(x3, x31), sp);   \/\/ integer registers except ra(x1) & sp(x2)\n+  \/\/ if the number of popped regs is odd, the reserved slot for alignment will be removed\n+  __ pop_reg(RegSet::range(x5, x31), sp);   \/\/ integer registers except ra(x1) & sp(x2) & gp(x3) & tp(x4)\n@@ -335,4 +335,4 @@\n-  \/\/ if the number of popped regs is odd, zr will be added\n-  \/\/ integer registers except ra(x1) & sp(x2) & x10\n-  __ pop_reg(RegSet::range(x3, x9), sp);   \/\/ pop zr, x3 ~ x9\n-  __ pop_reg(RegSet::range(x11, x31), sp); \/\/ pop x10 ~ x31, x10 will be loaded to zr\n+  \/\/ pop integer registers except ra(x1) & sp(x2) & gp(x3) & tp(x4) & x10\n+  \/\/ there is one reserved slot for alignment on the stack in save_live_registers().\n+  __ pop_reg(RegSet::range(x5, x9), sp);   \/\/ pop x5 ~ x9 with the reserved slot for alignment\n+  __ pop_reg(RegSet::range(x11, x31), sp); \/\/ pop x11 ~ x31; x10 will be automatically skipped here\n@@ -352,2 +352,1 @@\n-  \/\/ we save x0, x3 ~ x31, except x1, x2\n-  cpu_reg_save_offsets[0] = sp_offset;\n+  \/\/ a slot reserved for stack 16-byte alignment, see MacroAssembler::push_reg\n@@ -355,2 +354,2 @@\n-  \/\/ 3: loop starts from x3\n-  for (i = 3; i < FrameMap::nof_cpu_regs; i++) {\n+  \/\/ we save x5 ~ x31, except x0 ~ x4: loop starts from x5\n+  for (i = 5; i < FrameMap::nof_cpu_regs; i++) {\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1121,1 +1121,1 @@\n-\/\/ Push all the integer registers, except zr(x0) & sp(x2).\n+\/\/ Push all the integer registers, except zr(x0) & sp(x2) & gp(x3) & tp(x4).\n@@ -1123,1 +1123,1 @@\n-  push_reg(0xfffffffa, sp);\n+  push_reg(0xffffffe2, sp);\n@@ -1126,0 +1126,1 @@\n+\/\/ Pop all the integer registers, except zr(x0) & sp(x2) & gp(x3) & tp(x4).\n@@ -1127,1 +1128,1 @@\n-  pop_reg(0xfffffffa, sp);\n+  pop_reg(0xffffffe2, sp);\n@@ -1131,2 +1132,2 @@\n-  \/\/ integer registers, except zr(x0) & ra(x1) & sp(x2)\n-  push_reg(0xfffffff8, sp);\n+  \/\/ integer registers, except zr(x0) & ra(x1) & sp(x2) & gp(x3) & tp(x4)\n+  push_reg(0xffffffe0, sp);\n@@ -1167,2 +1168,2 @@\n-  \/\/ integer registers, except zr(x0) & ra(x1) & sp(x2)\n-  pop_reg(0xfffffff8, sp);\n+  \/\/ integer registers, except zr(x0) & ra(x1) & sp(x2) & gp(x3) & tp(x4)\n+  pop_reg(0xffffffe0, sp);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  \/\/ gregs:30, float_register:32; except: x1(ra) & x2(sp)\n+  \/\/ gregs:28, float_register:32; except: x1(ra) & x2(sp) & gp(x3) & tp(x4)\n@@ -102,3 +102,3 @@\n-  \/\/ |---zr---|\n-  \/\/ |---x3---|\n-  \/\/ |   x4   |\n+  \/\/ |---reserved slot for stack alignment---|\n+  \/\/ |---x5---|\n+  \/\/ |   x6   |\n@@ -120,1 +120,1 @@\n-  int x0_offset_in_bytes(void) {\n+  int reserved_slot_offset_in_bytes(void) {\n@@ -128,2 +128,2 @@\n-    assert (r->encoding() > 2, \"ra and sp not saved\");\n-    return x0_offset_in_bytes() + (r->encoding() - 2 \/* x1, x2*\/) * wordSize;\n+    assert (r->encoding() > 4, \"ra, sp, gp and tp not saved\");\n+    return reserved_slot_offset_in_bytes() + (r->encoding() - 4 \/* x1, x2, x3, x4 *\/) * wordSize;\n@@ -137,2 +137,2 @@\n-    return x0_offset_in_bytes() +\n-           (RegisterImpl::number_of_registers - 1) *\n+    return reserved_slot_offset_in_bytes() +\n+           (RegisterImpl::number_of_registers - 3) *\n@@ -193,2 +193,0 @@\n-  \/\/ ignore zr, ra and sp, being ignored also by push_CPU_state (pushing zr only for stack alignment)\n-  sp_offset_in_slots += RegisterImpl::max_slots_per_register;\n@@ -196,1 +194,5 @@\n-  for (int i = 3; i < RegisterImpl::number_of_registers; i++, sp_offset_in_slots += step_in_slots) {\n+  \/\/ skip the slot reserved for alignment, see MacroAssembler::push_reg;\n+  \/\/ also skip x5 ~ x6 on the stack because they are caller-saved registers.\n+  sp_offset_in_slots += RegisterImpl::max_slots_per_register * 3;\n+  \/\/ besides, we ignore x0 ~ x4 because push_CPU_state won't push them on the stack.\n+  for (int i = 7; i < RegisterImpl::number_of_registers; i++, sp_offset_in_slots += step_in_slots) {\n@@ -198,1 +200,1 @@\n-    if (r != xthread && r != t0 && r != t1) {\n+    if (r != xthread) {\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"}]}