{"files":[{"patch":"@@ -43,2 +43,2 @@\n-    n_int_register_parameters_c   = 8,  \/\/ x10, x11, ... x17 (c_rarg0, c_rarg1, ...)\n-    n_float_register_parameters_c = 8,  \/\/ f10, f11, ... f17 (c_farg0, c_farg1, ... )\n+    n_int_register_parameters_c   = 8, \/\/ x10, x11, ... x17 (c_rarg0, c_rarg1, ...)\n+    n_float_register_parameters_c = 8, \/\/ f10, f11, ... f17 (c_farg0, c_farg1, ... )\n@@ -130,1 +130,1 @@\n-\/\/ tempory register(caller-save registers)\n+\/\/ temporary register(caller-save registers)\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -224,2 +224,2 @@\n-  RegSet                _fp_regs;\n-  RegSet                _vp_regs;\n+  FloatRegSet           _fp_regs;\n+  VectorRegSet          _vp_regs;\n@@ -238,1 +238,1 @@\n-          _fp_regs += RegSet::of((Register)vm_reg->as_FloatRegister());\n+          _fp_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n@@ -241,1 +241,1 @@\n-          _vp_regs += RegSet::of((Register)vm_reg_base->as_VectorRegister());\n+          _vp_regs += VectorRegSet::of(vm_reg_base->as_VectorRegister());\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -50,0 +50,2 @@\n+#define USE_POINTERS_TO_REGISTER_IMPL_ARRAY\n+\n","filename":"src\/hotspot\/cpu\/riscv\/globalDefinitions_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -485,2 +485,2 @@\n-  void push_fp(RegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }\n-  void pop_fp(RegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }\n+  void push_fp(FloatRegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }\n+  void pop_fp(FloatRegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }\n@@ -488,2 +488,2 @@\n-  void push_vp(RegSet regs, Register stack) { if (regs.bits()) push_vp(regs.bits(), stack); }\n-  void pop_vp(RegSet regs, Register stack) { if (regs.bits()) pop_vp(regs.bits(), stack); }\n+  void push_vp(VectorRegSet regs, Register stack) { if (regs.bits()) push_vp(regs.bits(), stack); }\n+  void pop_vp(VectorRegSet regs, Register stack) { if (regs.bits()) pop_vp(regs.bits(), stack); }\n@@ -779,0 +779,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -521,4 +521,4 @@\n-      ((Register)(intptr_t)Assembler::extract(((unsigned*)addr)[0], 11, 7)     == x5) &&\n-      ((Register)(intptr_t)Assembler::extract(((unsigned*)addr)[1], 11, 7)     == x5) &&\n-      ((Register)(intptr_t)Assembler::extract(((unsigned*)addr)[1], 19, 15)    == x5) &&\n-      ((Register)(intptr_t)Assembler::extract(((unsigned*)addr)[2], 19, 15)    == x5) &&\n+      (as_Register((intptr_t)Assembler::extract(((unsigned*)addr)[0], 11, 7))     == x5) &&\n+      (as_Register((intptr_t)Assembler::extract(((unsigned*)addr)[1], 11, 7))     == x5) &&\n+      (as_Register((intptr_t)Assembler::extract(((unsigned*)addr)[1], 19, 15))    == x5) &&\n+      (as_Register((intptr_t)Assembler::extract(((unsigned*)addr)[2], 19, 15))    == x5) &&\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2020, 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -29,0 +29,4 @@\n+REGISTER_IMPL_DEFINITION(Register, RegisterImpl, RegisterImpl::number_of_registers);\n+REGISTER_IMPL_DEFINITION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n+REGISTER_IMPL_DEFINITION(VectorRegister, VectorRegisterImpl, VectorRegisterImpl::number_of_registers);\n+\n@@ -41,2 +45,2 @@\n-  const char* names[number_of_registers] = {\n-    \"zr\", \"ra\", \"sp\", \"gp\", \"tp\", \"x5\", \"x6\", \"x7\", \"fp\", \"x9\",\n+  static const char *const names[number_of_registers] = {\n+    \"zr\", \"ra\", \"sp\", \"gp\", \"tp\", \"t0\", \"t1\", \"t2\", \"fp\", \"x9\",\n@@ -51,1 +55,1 @@\n-  const char* names[number_of_registers] = {\n+  static const char *const names[number_of_registers] = {\n@@ -61,1 +65,1 @@\n-  const char* names[number_of_registers] = {\n+  static const char *const names[number_of_registers] = {\n","filename":"src\/hotspot\/cpu\/riscv\/register_riscv.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-typedef RegisterImpl* Register;\n+typedef const RegisterImpl* Register;\n@@ -52,3 +52,1 @@\n-inline Register as_Register(int encoding) {\n-  return (Register)(intptr_t) encoding;\n-}\n+inline constexpr Register as_Register(int encoding);\n@@ -57,0 +55,2 @@\n+  static constexpr Register first();\n+\n@@ -60,1 +60,0 @@\n-    number_of_byte_registers = 32,\n@@ -69,1 +68,1 @@\n-  Register successor() const                          { return as_Register(encoding() + 1); }\n+  const Register successor() const { return this + 1; }\n@@ -72,1 +71,1 @@\n-  inline friend Register as_Register(int encoding);\n+  inline friend constexpr Register as_Register(int encoding);\n@@ -74,1 +73,1 @@\n-  VMReg as_VMReg();\n+  VMReg as_VMReg() const;\n@@ -77,5 +76,3 @@\n-  int   encoding() const                         { assert(is_valid(), \"invalid register\"); return (intptr_t)this; }\n-  int   compressed_encoding() const              { assert(is_compressed_valid(), \"invalid compressed register\"); return ((intptr_t)this - compressed_register_base); }\n-  bool  is_valid() const                         { return 0 <= (intptr_t)this && (intptr_t)this < number_of_registers; }\n-  bool  is_compressed_valid() const              { return compressed_register_base <= (intptr_t)this && (intptr_t)this <= compressed_register_top; }\n-  bool  has_byte_register() const                { return 0 <= (intptr_t)this && (intptr_t)this < number_of_byte_registers; }\n+  int   encoding() const                         { assert(is_valid(), \"invalid register\"); return encoding_nocheck(); }\n+  int   encoding_nocheck() const                 { return this - first(); }\n+  bool  is_valid() const                         { return (unsigned)encoding_nocheck() < number_of_registers; }\n@@ -83,2 +80,0 @@\n-  int   encoding_nocheck() const                 { return (intptr_t)this; }\n-  int   compressed_encoding_nocheck() const      { return ((intptr_t)this - compressed_register_base); }\n@@ -86,3 +81,14 @@\n-  \/\/ Return the bit which represents this register.  This is intended\n-  \/\/ to be ORed into a bitmask: for usage see class RegSet below.\n-  unsigned long bit(bool should_set = true) const { return should_set ? 1 << encoding() : 0; }\n+  \/\/ for rvc\n+  int compressed_encoding() const {\n+    assert(is_compressed_valid(), \"invalid compressed register\");\n+    return encoding() - compressed_register_base;\n+  }\n+\n+  int compressed_encoding_nocheck() const {\n+    return encoding_nocheck() - compressed_register_base;\n+  }\n+\n+  bool is_compressed_valid() const {\n+    return encoding_nocheck() >= compressed_register_base &&\n+           encoding_nocheck() <= compressed_register_top;\n+  }\n@@ -91,0 +97,2 @@\n+REGISTER_IMPL_DECLARATION(Register, RegisterImpl, RegisterImpl::number_of_registers);\n+\n@@ -130,1 +138,1 @@\n-typedef FloatRegisterImpl* FloatRegister;\n+typedef const FloatRegisterImpl* FloatRegister;\n@@ -132,3 +140,1 @@\n-inline FloatRegister as_FloatRegister(int encoding) {\n-  return (FloatRegister)(intptr_t) encoding;\n-}\n+inline constexpr FloatRegister as_FloatRegister(int encoding);\n@@ -138,0 +144,2 @@\n+  static constexpr FloatRegister first();\n+\n@@ -149,1 +157,1 @@\n-  inline friend FloatRegister as_FloatRegister(int encoding);\n+  inline friend constexpr FloatRegister as_FloatRegister(int encoding);\n@@ -151,1 +159,1 @@\n-  VMReg as_VMReg();\n+  VMReg as_VMReg() const;\n@@ -154,1 +162,3 @@\n-  FloatRegister successor() const                          { return as_FloatRegister(encoding() + 1); }\n+  FloatRegister successor() const {\n+    return as_FloatRegister((encoding() + 1) % (unsigned)number_of_registers);\n+  }\n@@ -157,6 +167,3 @@\n-  int   encoding() const                          { assert(is_valid(), \"invalid register\"); return (intptr_t)this; }\n-  int   compressed_encoding() const               { assert(is_compressed_valid(), \"invalid compressed register\"); return ((intptr_t)this - compressed_register_base); }\n-  int   encoding_nocheck() const                         { return (intptr_t)this; }\n-  int   compressed_encoding_nocheck() const       { return ((intptr_t)this - compressed_register_base); }\n-  bool  is_valid() const                          { return 0 <= (intptr_t)this && (intptr_t)this < number_of_registers; }\n-  bool  is_compressed_valid() const               { return compressed_register_base <= (intptr_t)this && (intptr_t)this <= compressed_register_top; }\n+  int encoding() const                          { assert(is_valid(), \"invalid register\"); return encoding_nocheck(); }\n+  int   encoding_nocheck() const                { return this - first(); }\n+  int is_valid() const                          { return (unsigned)encoding_nocheck() < number_of_registers; }\n@@ -165,0 +172,14 @@\n+  \/\/ for rvc\n+  int compressed_encoding() const {\n+    assert(is_compressed_valid(), \"invalid compressed register\");\n+    return encoding() - compressed_register_base;\n+  }\n+\n+  int compressed_encoding_nocheck() const {\n+    return encoding_nocheck() - compressed_register_base;\n+  }\n+\n+  bool is_compressed_valid() const {\n+    return encoding_nocheck() >= compressed_register_base &&\n+           encoding_nocheck() <= compressed_register_top;\n+  }\n@@ -167,0 +188,2 @@\n+REGISTER_IMPL_DECLARATION(FloatRegister, FloatRegisterImpl, FloatRegisterImpl::number_of_registers);\n+\n@@ -206,1 +229,1 @@\n-typedef VectorRegisterImpl* VectorRegister;\n+typedef const VectorRegisterImpl* VectorRegister;\n@@ -208,3 +231,1 @@\n-inline VectorRegister as_VectorRegister(int encoding) {\n-  return (VectorRegister)(intptr_t) encoding;\n-}\n+inline constexpr VectorRegister as_VectorRegister(int encoding);\n@@ -214,0 +235,2 @@\n+  static constexpr VectorRegister first();\n+\n@@ -221,1 +244,1 @@\n-  inline friend VectorRegister as_VectorRegister(int encoding);\n+  inline friend constexpr VectorRegister as_VectorRegister(int encoding);\n@@ -223,1 +246,1 @@\n-  VMReg as_VMReg();\n+  VMReg as_VMReg() const;\n@@ -226,1 +249,1 @@\n-  VectorRegister successor() const { return as_VectorRegister(encoding() + 1); }\n+  VectorRegister successor() const { return this + 1; }\n@@ -229,3 +252,3 @@\n-  int encoding() const             { assert(is_valid(), \"invalid register\"); return (intptr_t)this; }\n-  int encoding_nocheck() const     { return (intptr_t)this; }\n-  bool is_valid() const            { return 0 <= (intptr_t)this && (intptr_t)this < number_of_registers; }\n+  int encoding() const             { assert(is_valid(), \"invalid register\"); return encoding_nocheck(); }\n+  int encoding_nocheck() const     { return this - first(); }\n+  bool is_valid() const            { return (unsigned)encoding_nocheck() < number_of_registers; }\n@@ -236,0 +259,2 @@\n+REGISTER_IMPL_DECLARATION(VectorRegister, VectorRegisterImpl, VectorRegisterImpl::number_of_registers);\n+\n@@ -295,1 +320,2 @@\n-class RegSet {\n+template<class RegImpl>\n+class AbstractRegSet {\n@@ -299,1 +325,1 @@\n-  RegSet(uint32_t bitset) : _bitset(bitset) { }\n+  AbstractRegSet(uint32_t bitset) : _bitset(bitset) { }\n@@ -301,1 +327,1 @@\n-  RegSet() : _bitset(0) { }\n+  AbstractRegSet() : _bitset(0) { }\n@@ -303,1 +329,1 @@\n-  RegSet(Register r1) : _bitset(r1->bit()) { }\n+  AbstractRegSet(RegImpl r1) : _bitset(1 << r1->encoding()) { }\n@@ -305,4 +331,2 @@\n-  ~RegSet() {}\n-\n-  RegSet operator+(const RegSet aSet) const {\n-    RegSet result(_bitset | aSet._bitset);\n+  AbstractRegSet operator+(const AbstractRegSet aSet) const {\n+    AbstractRegSet result(_bitset | aSet._bitset);\n@@ -312,2 +336,2 @@\n-  RegSet operator-(const RegSet aSet) const {\n-    RegSet result(_bitset & ~aSet._bitset);\n+  AbstractRegSet operator-(const AbstractRegSet aSet) const {\n+    AbstractRegSet result(_bitset & ~aSet._bitset);\n@@ -317,1 +341,1 @@\n-  RegSet &operator+=(const RegSet aSet) {\n+  AbstractRegSet &operator+=(const AbstractRegSet aSet) {\n@@ -322,1 +346,1 @@\n-  RegSet &operator-=(const RegSet aSet) {\n+  AbstractRegSet &operator-=(const AbstractRegSet aSet) {\n@@ -327,2 +351,2 @@\n-  static RegSet of(Register r1) {\n-    return RegSet(r1);\n+  static AbstractRegSet of(RegImpl r1) {\n+    return AbstractRegSet(r1);\n@@ -331,1 +355,1 @@\n-  static RegSet of(Register r1, Register r2) {\n+  static AbstractRegSet of(RegImpl r1, RegImpl r2) {\n@@ -335,1 +359,1 @@\n-  static RegSet of(Register r1, Register r2, Register r3) {\n+  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3) {\n@@ -339,1 +363,1 @@\n-  static RegSet of(Register r1, Register r2, Register r3, Register r4) {\n+  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3, RegImpl r4) {\n@@ -343,1 +367,1 @@\n-  static RegSet range(Register start, Register end) {\n+  static AbstractRegSet range(RegImpl start, RegImpl end) {\n@@ -349,1 +373,1 @@\n-    return RegSet(bits);\n+    return AbstractRegSet(bits);\n@@ -355,0 +379,4 @@\n+typedef AbstractRegSet<Register> RegSet;\n+typedef AbstractRegSet<FloatRegister> FloatRegSet;\n+typedef AbstractRegSet<VectorRegister> VectorRegSet;\n+\n","filename":"src\/hotspot\/cpu\/riscv\/register_riscv.hpp","additions":88,"deletions":60,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-inline VMReg RegisterImpl::as_VMReg() {\n+inline VMReg RegisterImpl::as_VMReg() const {\n@@ -36,1 +36,1 @@\n-inline VMReg FloatRegisterImpl::as_VMReg() {\n+inline VMReg FloatRegisterImpl::as_VMReg() const {\n@@ -41,1 +41,1 @@\n-inline VMReg VectorRegisterImpl::as_VMReg() {\n+inline VMReg VectorRegisterImpl::as_VMReg() const {\n","filename":"src\/hotspot\/cpu\/riscv\/vmreg_riscv.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}