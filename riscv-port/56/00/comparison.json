{"files":[{"patch":"@@ -2862,1 +2862,1 @@\n-      Pa, Pb, Pn, Pm, Rhi_ab, Rlo_ab, Rhi_mn, Rlo_mn, tmp, tmp1, tmp2, Ri, Rj;\n+      Pa, Pb, Pn, Pm, Rhi_ab, Rlo_ab, Rhi_mn, Rlo_mn, tmp0, tmp1, tmp2, Ri, Rj;\n@@ -2896,1 +2896,1 @@\n-      tmp  =  ++reg;    \/\/ Three registers which form a\n+      tmp0 =  ++reg;    \/\/ Three registers which form a\n@@ -2993,1 +2993,1 @@\n-      \/\/ MACC(Ra, Rb, tmp, tmp1, tmp2);\n+      \/\/ MACC(Ra, Rb, tmp0, tmp1, tmp2);\n@@ -3002,1 +3002,1 @@\n-      acc(Rhi_mn, Rlo_mn, tmp, tmp1, tmp2); \/\/ The pending m*n from the\n+      acc(Rhi_mn, Rlo_mn, tmp0, tmp1, tmp2); \/\/ The pending m*n from the\n@@ -3004,1 +3004,1 @@\n-      \/\/ MACC(Rm, Rn, tmp, tmp1, tmp2);\n+      \/\/ MACC(Rm, Rn, tmp0, tmp1, tmp2);\n@@ -3013,1 +3013,1 @@\n-      acc(Rhi_ab, Rlo_ab, tmp, tmp1, tmp2);\n+      acc(Rhi_ab, Rlo_ab, tmp0, tmp1, tmp2);\n@@ -3019,1 +3019,1 @@\n-      \/\/ MACC(Ra, Rb, tmp, tmp1, tmp2);\n+      \/\/ MACC(Ra, Rb, tmp0, tmp1, tmp2);\n@@ -3024,2 +3024,2 @@\n-      acc(Rhi_mn, Rlo_mn, tmp, tmp1, tmp2);  \/\/ The pending m*n\n-      acc(Rhi_ab, Rlo_ab, tmp, tmp1, tmp2);\n+      acc(Rhi_mn, Rlo_mn, tmp0, tmp1, tmp2);  \/\/ The pending m*n\n+      acc(Rhi_ab, Rlo_ab, tmp0, tmp1, tmp2);\n@@ -3027,2 +3027,2 @@\n-      \/\/ *Pm = Rm = tmp * inv;\n-      mul(Rm, tmp, inv);\n+      \/\/ *Pm = Rm = tmp0 * inv;\n+      mul(Rm, tmp0, inv);\n@@ -3031,2 +3031,2 @@\n-      \/\/ MACC(Rm, Rn, tmp, tmp1, tmp2);\n-      \/\/ tmp = tmp1; tmp1 = tmp2; tmp2 = 0;\n+      \/\/ MACC(Rm, Rn, tmp0, tmp1, tmp2);\n+      \/\/ tmp0 = tmp1; tmp1 = tmp2; tmp2 = 0;\n@@ -3036,1 +3036,1 @@\n-      \/\/ assert(m[i] * n[0] + tmp == 0, \"broken Montgomery multiply\");\n+      \/\/ assert(m[i] * n[0] + tmp0 == 0, \"broken Montgomery multiply\");\n@@ -3039,1 +3039,1 @@\n-        add(Rlo_mn, tmp, Rlo_mn);\n+        add(Rlo_mn, tmp0, Rlo_mn);\n@@ -3047,1 +3047,1 @@\n-      \/\/ m[i]*n[0] + tmp == 0 (mod b), so we don't have to calculate\n+      \/\/ m[i]*n[0] + tmp0 == 0 (mod b), so we don't have to calculate\n@@ -3049,3 +3049,3 @@\n-      \/\/ it must be -tmp.  tmp + (-tmp) must generate a carry iff\n-      \/\/ tmp != 0.  So, rather than do a mul and an cad we just set\n-      \/\/ the carry flag iff tmp is nonzero.\n+      \/\/ it must be -tmp0.  tmp0 + (-tmp0) must generate a carry iff\n+      \/\/ tmp0 != 0.  So, rather than do a mul and an cad we just set\n+      \/\/ the carry flag iff tmp0 is nonzero.\n@@ -3054,4 +3054,4 @@\n-      \/\/ cad(zr, tmp, Rlo_mn);\n-      addi(t0, tmp, -1);\n-      sltu(t0, t0, tmp); \/\/ Set carry iff tmp is nonzero\n-      cadc(tmp, tmp1, Rhi_mn, t0);\n+      \/\/ cad(zr, tmp0, Rlo_mn);\n+      addi(t0, tmp0, -1);\n+      sltu(t0, t0, tmp0); \/\/ Set carry iff tmp0 is nonzero\n+      cadc(tmp0, tmp1, Rhi_mn, t0);\n@@ -3101,1 +3101,1 @@\n-      cad(tmp, tmp, Rlo_mn, t0); \/\/ The pending m*n, low part\n+      cad(tmp0, tmp0, Rlo_mn, t0); \/\/ The pending m*n, low part\n@@ -3105,1 +3105,1 @@\n-      \/\/ Pm_base[i-len] = tmp;\n+      \/\/ Pm_base[i-len] = tmp0;\n@@ -3109,1 +3109,1 @@\n-      sd(tmp, Address(Rj));\n+      sd(tmp0, Address(Rj));\n@@ -3111,2 +3111,2 @@\n-      \/\/ tmp = tmp1; tmp1 = tmp2; tmp2 = 0;\n-      cadc(tmp, tmp1, Rhi_mn, t0); \/\/ The pending m*n, high part\n+      \/\/ tmp0 = tmp1; tmp1 = tmp2; tmp2 = 0;\n+      cadc(tmp0, tmp1, Rhi_mn, t0); \/\/ The pending m*n, high part\n@@ -3117,1 +3117,1 @@\n-    \/\/ A carry in tmp after Montgomery multiplication means that we\n+    \/\/ A carry in tmp0 after Montgomery multiplication means that we\n@@ -3122,2 +3122,2 @@\n-      \/\/ while (tmp)\n-      \/\/   tmp = sub(Pm_base, Pn_base, tmp, len);\n+      \/\/ while (tmp0)\n+      \/\/   tmp0 = sub(Pm_base, Pn_base, tmp0, len);\n@@ -3126,1 +3126,1 @@\n-      beqz(tmp, post); {\n+      beqz(tmp0, post); {\n@@ -3138,1 +3138,0 @@\n-            \/\/ csbc(Rm, Rm, Rn);\n@@ -3154,4 +3153,3 @@\n-          \/\/ sbc(tmp, tmp, zr);\n-          addi(tmp, tmp, -1);\n-          add(tmp, tmp, t0);\n-        } bnez(tmp, again);\n+          addi(tmp0, tmp0, -1);\n+          add(tmp0, tmp0, t0);\n+        } bnez(tmp0, again);\n@@ -3185,0 +3183,72 @@\n+    void step_squaring() {\n+      \/\/ An extra ACC\n+      step();\n+      acc(Rhi_ab, Rlo_ab, tmp0, tmp1, tmp2);\n+    }\n+\n+    void last_squaring(Register i) {\n+      Label dont;\n+      \/\/ if ((i & 1) == 0) {\n+      andi(t0, i, 0x1);\n+      bnez(t0, dont); {\n+        \/\/ MACC(Ra, Rb, tmp0, tmp1, tmp2);\n+        \/\/ Ra = *++Pa;\n+        \/\/ Rb = *--Pb;\n+        mulhu(Rhi_ab, Ra, Rb);\n+        mul(Rlo_ab, Ra, Rb);\n+        acc(Rhi_ab, Rlo_ab, tmp0, tmp1, tmp2);\n+      } bind(dont);\n+    }\n+\n+    void extra_step_squaring() {\n+      acc(Rhi_mn, Rlo_mn, tmp0, tmp1, tmp2);  \/\/ The pending m*n\n+\n+      \/\/ MACC(Rm, Rn, tmp0, tmp1, tmp2);\n+      \/\/ Rm = *++Pm;\n+      \/\/ Rn = *--Pn;\n+      mulhu(Rhi_mn, Rm, Rn);\n+      mul(Rlo_mn, Rm, Rn);\n+      addi(Pm, Pm, wordSize);\n+      ld(Rm, Address(Pm));\n+      addi(Pn, Pn, -wordSize);\n+      ld(Rn, Address(Pn));\n+    }\n+\n+    void post1_squaring() {\n+      acc(Rhi_mn, Rlo_mn, tmp0, tmp1, tmp2);  \/\/ The pending m*n\n+\n+      \/\/ *Pm = Rm = tmp0 * inv;\n+      mul(Rm, tmp0, inv);\n+      sd(Rm, Address(Pm));\n+\n+      \/\/ MACC(Rm, Rn, tmp0, tmp1, tmp2);\n+      \/\/ tmp0 = tmp1; tmp1 = tmp2; tmp2 = 0;\n+      mulhu(Rhi_mn, Rm, Rn);\n+\n+#ifndef PRODUCT\n+      \/\/ assert(m[i] * n[0] + tmp0 == 0, \"broken Montgomery multiply\");\n+      {\n+        mul(Rlo_mn, Rm, Rn);\n+        add(Rlo_mn, tmp0, Rlo_mn);\n+        Label ok;\n+        beqz(Rlo_mn, ok); {\n+          stop(\"broken Montgomery multiply\");\n+        } bind(ok);\n+      }\n+#endif\n+      \/\/ We have very carefully set things up so that\n+      \/\/ m[i]*n[0] + tmp0 == 0 (mod b), so we don't have to calculate\n+      \/\/ the lower half of Rm * Rn because we know the result already:\n+      \/\/ it must be -tmp0.  tmp0 + (-tmp0) must generate a carry iff\n+      \/\/ tmp0 != 0.  So, rather than do a mul and a cad we just set\n+      \/\/ the carry flag iff tmp0 is nonzero.\n+      \/\/\n+      \/\/ mul(Rlo_mn, Rm, Rn);\n+      \/\/ cad(zr, tmp, Rlo_mn);\n+      addi(t0, tmp0, -1);\n+      sltu(t0, t0, tmp0); \/\/ Set carry iff tmp0 is nonzero\n+      cadc(tmp0, tmp1, Rhi_mn, t0);\n+      adc(tmp1, tmp2, zr, t0);\n+      mv(tmp2, zr);\n+    }\n+\n@@ -3187,2 +3257,2 @@\n-             Register tmp, Register tmp1, Register tmp2) {\n-      cad(tmp, tmp, Rlo, t0);\n+             Register tmp0, Register tmp1, Register tmp2) {\n+      cad(tmp0, tmp0, Rlo, t0);\n@@ -3266,1 +3336,1 @@\n-      mv(tmp, zr);\n+      mv(tmp0, zr);\n@@ -3329,0 +3399,126 @@\n+\n+    \/**\n+     *\n+     * Arguments:\n+     *\n+     * Inputs:\n+     *   c_rarg0   - int array elements a\n+     *   c_rarg1   - int array elements n (the modulus)\n+     *   c_rarg2   - int length\n+     *   c_rarg3   - int inv\n+     *   c_rarg4   - int array elements m (the result)\n+     *\n+     *\/\n+    address generate_square() {\n+      Label argh;\n+      bind(argh);\n+      stop(\"MontgomeryMultiply total_allocation must be <= 8192\");\n+\n+      align(CodeEntryAlignment);\n+      address entry = pc();\n+\n+      enter();\n+\n+      \/\/ Make room.\n+      li(Ra, 512);\n+      bgt(Rlen, Ra, argh);\n+      slli(Ra, Rlen, exact_log2(4 * sizeof(jint)));\n+      sub(Ra, sp, Ra);\n+      andi(sp, Ra, -2 * wordSize);\n+\n+      srliw(Rlen, Rlen, 1);  \/\/ length in longwords = len\/2\n+\n+      {\n+        \/\/ Copy input args, reversing as we go.  We use Ra as a\n+        \/\/ temporary variable.\n+        reverse(Ra, Pa_base, Rlen, Ri, Rj);\n+        reverse(Ra, Pn_base, Rlen, Ri, Rj);\n+      }\n+\n+      \/\/ Push all call-saved registers and also Pm_base which we'll need\n+      \/\/ at the end.\n+      save_regs();\n+\n+      mv(Pm_base, Ra);\n+\n+      mv(tmp0, zr);\n+      mv(tmp1, zr);\n+      mv(tmp2, zr);\n+\n+      block_comment(\"for (int i = 0; i < len; i++) {\");\n+      mv(Ri, zr); {\n+        Label loop, end;\n+        bind(loop);\n+        bge(Ri, Rlen, end);\n+\n+        pre1(Ri);\n+\n+        block_comment(\"for (j = (i+1)\/2; j; j--) {\"); {\n+          addi(Rj, Ri, 1);\n+          srliw(Rj, Rj, 1);\n+          unroll_2(Rj, &MontgomeryMultiplyGenerator::step_squaring);\n+        } block_comment(\"  } \/\/ j\");\n+\n+        last_squaring(Ri);\n+\n+        block_comment(\"  for (j = i\/2; j; j--) {\"); {\n+          srliw(Rj, Ri, 1);\n+          unroll_2(Rj, &MontgomeryMultiplyGenerator::extra_step_squaring);\n+        } block_comment(\"  } \/\/ j\");\n+\n+        post1_squaring();\n+        addi(Ri, Ri, 1);\n+        blt(Ri, Rlen, loop);\n+\n+        bind(end);\n+        block_comment(\"} \/\/ i\");\n+      }\n+\n+      block_comment(\"for (int i = len; i < 2*len; i++) {\");\n+      mv(Ri, Rlen); {\n+        Label loop, end;\n+        bind(loop);\n+        slli(Rj, Rlen, 1);\n+        bge(Ri, Rj, end);\n+\n+        pre2(Ri, Rlen);\n+\n+        block_comment(\"  for (j = (2*len-i-1)\/2; j; j--) {\"); {\n+          slli(Rj, Rlen, 1);\n+          sub(Rj, Rj, Ri);\n+          sub(Rj, Rj, 1);\n+          srliw(Rj, Rj, 1);\n+          unroll_2(Rj, &MontgomeryMultiplyGenerator::step_squaring);\n+        } block_comment(\"  } \/\/ j\");\n+\n+        last_squaring(Ri);\n+\n+        block_comment(\"  for (j = (2*len-i)\/2; j; j--) {\"); {\n+          slli(Rj, Rlen, 1);\n+          sub(Rj, Rj, Ri);\n+          srliw(Rj, Rj, 1);\n+          unroll_2(Rj, &MontgomeryMultiplyGenerator::extra_step_squaring);\n+        } block_comment(\"  } \/\/ j\");\n+\n+        post2(Ri, Rlen);\n+        addi(Ri, Ri, 1);\n+        slli(t0, Rlen, 1);\n+        blt(Ri, t0, loop);\n+\n+        bind(end);\n+        block_comment(\"} \/\/ i\");\n+      }\n+\n+      normalize(Rlen);\n+\n+      mv(Ra, Pm_base);  \/\/ Save Pm_base in Ra\n+      restore_regs();  \/\/ Restore caller's Pm_base\n+\n+      \/\/ Copy our result into caller's Pm_base\n+      reverse(Pm_base, Ra, Rlen, Ri, Rj);\n+\n+      leave();\n+      ret();\n+\n+      return entry;\n+    }\n@@ -3520,0 +3716,6 @@\n+\n+    if (UseMontgomerySquareIntrinsic) {\n+      StubCodeMark mark(this, \"StubRoutines\", \"montgomerySquare\");\n+      MontgomeryMultiplyGenerator g(_masm, \/*squaring*\/true);\n+      StubRoutines::_montgomerySquare = g.generate_square();\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":242,"deletions":40,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -206,0 +206,4 @@\n+\n+  if (FLAG_IS_DEFAULT(UseMontgomerySquareIntrinsic)) {\n+    FLAG_SET_DEFAULT(UseMontgomerySquareIntrinsic, true);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}