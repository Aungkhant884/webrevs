{"files":[{"patch":"@@ -2202,2 +2202,1 @@\n-  \/\/ flush and load exclusive from the memory location\n-  \/\/ and fail if it is not what we expect\n+  \/\/ Load reserved from the memory location\n@@ -2205,0 +2204,1 @@\n+  \/\/ Fail and exit if it is not what we expect\n@@ -2206,1 +2206,1 @@\n-  \/\/ if we store+flush with no intervening write tmp wil be zero\n+  \/\/ If the store conditional succeeds, tmp will be zero\n@@ -2209,2 +2209,1 @@\n-  \/\/ retry so we only ever return after a load fails to compare\n-  \/\/ ensures we don't return a stale value after a failed write.\n+  \/\/ Retry only when the store conditional failed\n@@ -2212,1 +2211,1 @@\n-  \/\/ if the memory word differs we return it in oldv and signal a fail\n+\n@@ -2477,11 +2476,0 @@\n-void MacroAssembler::atomic_incw(Register counter_addr, Register tmp) {\n-  Label retry_load;\n-  bind(retry_load);\n-  \/\/ flush and load exclusive from the memory location\n-  lr_w(tmp, counter_addr);\n-  addw(tmp, tmp, 1);\n-  \/\/ if we store+flush with no intervening write tmp wil be zero\n-  sc_w(tmp, tmp, counter_addr);\n-  bnez(tmp, retry_load);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -600,7 +600,0 @@\n-  \/\/atomic\n-  void atomic_incw(Register counter_addr, Register tmp1);\n-  void atomic_incw(Address counter_addr, Register tmp1, Register tmp2) {\n-    la(tmp1, counter_addr);\n-    atomic_incw(tmp1, tmp2);\n-  }\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-\/\/   x7, x9-x17, x28-x31 volatile (caller save)\n-\/\/   x0-x4, x8, x27 system (no save, no allocate)\n+\/\/   x7, x9-x17, x27-x31 volatile (caller save)\n+\/\/   x0-x4, x8, x23 system (no save, no allocate)\n@@ -85,2 +85,2 @@\n-reg_def R1      ( SOC, SOC, Op_RegI, 1,  x1->as_VMReg()         ); \/\/ ra\n-reg_def R1_H    ( SOC, SOC, Op_RegI, 1,  x1->as_VMReg()->next() );\n+reg_def R1      ( NS,  SOC, Op_RegI, 1,  x1->as_VMReg()         ); \/\/ ra\n+reg_def R1_H    ( NS,  SOC, Op_RegI, 1,  x1->as_VMReg()->next() );\n@@ -1021,3 +1021,0 @@\n-\n-\/\/ predicate using the temp register for decoding klass\n-bool maybe_use_tmp_register_decoding_klass();\n@@ -1144,6 +1141,0 @@\n-\n-bool maybe_use_tmp_register_decoding_klass() {\n-  return !UseCompressedOops &&\n-         CompressedKlassPointers::base() != NULL &&\n-         CompressedKlassPointers::shift() != 0;\n-}\n@@ -1279,3 +1270,3 @@\n-  st->print(\"sd  fp, [sp, #%d]\", - 2 * wordSize);\n-  st->print(\"sd  ra, [sp, #%d]\", - wordSize);\n-  if (PreserveFramePointer) { st->print(\"\\n\\tsub  fp, sp, #%d\", 2 * wordSize); }\n+  st->print(\"sd  fp, [sp, #%d]\\n\\t\", - 2 * wordSize);\n+  st->print(\"sd  ra, [sp, #%d]\\n\\t\", - wordSize);\n+  if (PreserveFramePointer) { st->print(\"sub  fp, sp, #%d\\n\\t\", 2 * wordSize); }\n@@ -1684,1 +1675,1 @@\n-    st->print_cr(\"\\tlw t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n+    st->print_cr(\"\\tlwu t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n@@ -1689,1 +1680,1 @@\n-   st->print_cr(\"\\tld t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n+    st->print_cr(\"\\tld t0, [j_rarg0, oopDesc::klass_offset_in_bytes()]\\t# compressed klass\");\n@@ -1691,1 +1682,3 @@\n-  st->print_cr(\"\\tbne x10, t0, SharedRuntime::_ic_miss_stub\\t # Inline cache check\");\n+  st->print_cr(\"\\tbeq t0, t1, ic_hit\");\n+  st->print_cr(\"\\tj, SharedRuntime::_ic_miss_stub\\t # Inline cache check\");\n+  st->print_cr(\"\\tic_hit:\");\n@@ -8109,3 +8102,1 @@\n-instruct decodeKlass_not_null(iRegPNoSp dst, iRegN src) %{\n-  predicate(!maybe_use_tmp_register_decoding_klass());\n-\n+instruct decodeKlass_not_null(iRegPNoSp dst, iRegN src, iRegPNoSp tmp) %{\n@@ -8114,18 +8105,1 @@\n-  ins_cost(ALU_COST);\n-  format %{ \"decode_klass_not_null  $dst, $src\\t#@decodeKlass_not_null\" %}\n-\n-  ins_encode %{\n-    Register src_reg = as_Register($src$$reg);\n-    Register dst_reg = as_Register($dst$$reg);\n-    __ decode_klass_not_null(dst_reg, src_reg, UseCompressedOops ? xheapbase : t0);\n-  %}\n-\n-   ins_pipe(ialu_reg);\n-%}\n-\n-instruct decodeKlass_not_null_with_tmp(iRegPNoSp dst, iRegN src, rFlagsReg cr) %{\n-  predicate(maybe_use_tmp_register_decoding_klass());\n-\n-  match(Set dst (DecodeNKlass src));\n-\n-  effect(TEMP cr);\n+  effect(TEMP tmp);\n@@ -8139,1 +8113,1 @@\n-    Register tmp_reg = as_Register($cr$$reg);\n+    Register tmp_reg = as_Register($tmp$$reg);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":15,"deletions":41,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-\/\/ Riscv64 VEC Architecture Description File\n+\/\/ RISCV Vector Extension Architecture Description File\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_v.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}