{"files":[{"patch":"@@ -152,0 +152,1 @@\n+        $d\/cpu\/$(HOTSPOT_TARGET_CPU_ARCH)\/$(HOTSPOT_TARGET_CPU_ARCH)_b.ad \\\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+  INSN(rol,    0b0110011, 0b001, 0b0110000);\n+  INSN(rolw,   0b0111011, 0b001, 0b0110000);\n+  INSN(ror,    0b0110011, 0b101, 0b0110000);\n+  INSN(rorw,   0b0111011, 0b101, 0b0110000);\n@@ -62,0 +66,34 @@\n+#define INSN(NAME, op, funct3, funct6)                  \\\n+  void NAME(Register Rd, Register Rs1, unsigned shamt) {\\\n+    guarantee(shamt <= 0x3f, \"Shamt is invalid\");       \\\n+    unsigned insn = 0;                                  \\\n+    patch((address)&insn, 6, 0, op);                    \\\n+    patch((address)&insn, 14, 12, funct3);              \\\n+    patch((address)&insn, 25, 20, shamt);               \\\n+    patch((address)&insn, 31, 26, funct6);              \\\n+    patch_reg((address)&insn, 7, Rd);                   \\\n+    patch_reg((address)&insn, 15, Rs1);                 \\\n+    emit(insn);                                         \\\n+  }\n+\n+  INSN(rori, 0b0010011, 0b101, 0b011000);\n+\n+#undef INSN\n+\n+#define INSN(NAME, op, funct3, funct7)                  \\\n+  void NAME(Register Rd, Register Rs1, unsigned shamt){ \\\n+    guarantee(shamt <= 0x1f, \"Shamt is invalid\");       \\\n+    unsigned insn = 0;                                  \\\n+    patch((address)&insn, 6, 0, op);                    \\\n+    patch((address)&insn, 14, 12, funct3);              \\\n+    patch((address)&insn, 24, 20, shamt);               \\\n+    patch((address)&insn, 31, 25, funct7);              \\\n+    patch_reg((address)&insn, 7, Rd);                   \\\n+    patch_reg((address)&insn, 15, Rs1);                 \\\n+    emit(insn);                                         \\\n+  }\n+\n+  INSN(roriw, 0b0011011, 0b101, 0b0110000);\n+\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv_b.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -3056,1 +3056,0 @@\n-  sign_extend(len, len, 32);\n@@ -3125,1 +3124,1 @@\n-void MacroAssembler::ror(Register dst, Register src, uint32_t shift, Register tmp)\n+void MacroAssembler::ror_imm(Register dst, Register src, uint32_t shift, Register tmp)\n@@ -3127,0 +3126,5 @@\n+  if (UseRVB) {\n+    rori(dst, src, shift);\n+    return;\n+  }\n+\n@@ -3129,1 +3133,1 @@\n-  assert(shift <= 64, \"shift amount must be <= 64\");\n+  assert(shift < 64, \"shift amount must be < 64\");\n@@ -3211,1 +3215,1 @@\n-  ror(x_xstart, x_xstart, 32); \/\/ convert big-endian to little-endian\n+  ror_imm(x_xstart, x_xstart, 32); \/\/ convert big-endian to little-endian\n@@ -3222,1 +3226,1 @@\n-  ror(y_idx, y_idx, 32); \/\/ convert big-endian to little-endian\n+  ror_imm(y_idx, y_idx, 32); \/\/ convert big-endian to little-endian\n@@ -3231,1 +3235,1 @@\n-  ror(product, product, 32); \/\/ back to big-endian\n+  ror_imm(product, product, 32); \/\/ back to big-endian\n@@ -3296,2 +3300,2 @@\n-  ror(yz_idx1, yz_idx1, 32); \/\/ convert big-endian to little-endian\n-  ror(yz_idx2, yz_idx2, 32);\n+  ror_imm(yz_idx1, yz_idx1, 32); \/\/ convert big-endian to little-endian\n+  ror_imm(yz_idx2, yz_idx2, 32);\n@@ -3305,2 +3309,2 @@\n-  ror(t0, t0, 32, tmp); \/\/ convert big-endian to little-endian\n-  ror(t1, t1, 32, tmp);\n+  ror_imm(t0, t0, 32, tmp); \/\/ convert big-endian to little-endian\n+  ror_imm(t1, t1, 32, tmp);\n@@ -3319,2 +3323,2 @@\n-  ror(tmp3, tmp3, 32); \/\/ convert little-endian to big-endian\n-  ror(tmp4, tmp4, 32);\n+  ror_imm(tmp3, tmp3, 32); \/\/ convert little-endian to big-endian\n+  ror_imm(tmp4, tmp4, 32);\n@@ -3338,1 +3342,1 @@\n-  ror(yz_idx1, yz_idx1, 32);\n+  ror_imm(yz_idx1, yz_idx1, 32);\n@@ -3346,1 +3350,1 @@\n-  ror(yz_idx2, yz_idx2, 32, tmp);\n+  ror_imm(yz_idx2, yz_idx2, 32, tmp);\n@@ -3350,1 +3354,1 @@\n-  ror(tmp3, tmp3, 32, tmp);\n+  ror_imm(tmp3, tmp3, 32, tmp);\n@@ -3414,2 +3418,2 @@\n-  sign_extend(idx, ylen, 32); \/\/ idx = ylen;\n-  sign_extend(kdx, zlen, 32); \/\/ kdx = xlen+ylen;\n+  mv(idx, ylen); \/\/ idx = ylen;\n+  mv(kdx, zlen); \/\/ kdx = xlen+ylen;\n@@ -3439,1 +3443,1 @@\n-    sign_extend(jdx, ylen, 32);\n+    mv(jdx, ylen);\n@@ -3518,1 +3522,1 @@\n-  sign_extend(jdx, ylen, 32); \/\/ j = ystart+1\n+  mv(jdx, ylen); \/\/ j = ystart+1\n@@ -3536,1 +3540,1 @@\n-  ror(product_hi, product_hi, 32); \/\/ convert big-endian to little-endian\n+  ror_imm(product_hi, product_hi, 32); \/\/ convert big-endian to little-endian\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -657,1 +657,1 @@\n-  void ror(Register dst, Register src, uint32_t imm, Register tmp = t0);\n+  void ror_imm(Register dst, Register src, uint32_t shift, Register tmp = t0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2725,0 +2725,18 @@\n+operand immI_16()\n+%{\n+  predicate(n->get_int() == 16);\n+  match(ConI);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immI_24()\n+%{\n+  predicate(n->get_int() == 24);\n+  match(ConI);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -2735,0 +2753,18 @@\n+operand immI_48()\n+%{\n+  predicate(n->get_int() == 48);\n+  match(ConI);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immI_56()\n+%{\n+  predicate(n->get_int() == 56);\n+  match(ConI);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -2857,0 +2893,20 @@\n+\/\/ Int Immediate: low 16-bit mask\n+operand immI_16bits()\n+%{\n+  predicate(n->get_int() == 0xFFFFL);\n+  match(ConI);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Long Immediate: low 16-bit mask\n+operand immL_16bits()\n+%{\n+  predicate(n->get_long() == 0xFFFFL);\n+  match(ConL);\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":56,"deletions":0,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/\/\n+\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2021, Huawei Technologies Co., Ltd. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+\n+\/\/ RISCV Bit-Manipulation Extension Architecture Description File\n+\n+instruct rorI_imm_rvb(iRegINoSp dst, iRegI src, immI shift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RotateRight src shift));\n+\n+  format %{ \"roriw    $dst, $src, ($shift & 0x1f)\\t#@rorI_imm_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ roriw(as_Register($dst$$reg), as_Register($src$$reg), $shift$$constant & 0x1f);\n+  %}\n+\n+  ins_pipe(ialu_reg_shift);\n+%}\n+\n+instruct rorL_imm_rvb(iRegLNoSp dst, iRegL src, immI shift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RotateRight src shift));\n+\n+  format %{ \"rori    $dst, $src, ($shift & 0x3f)\\t#@rorL_imm_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ rori(as_Register($dst$$reg), as_Register($src$$reg), $shift$$constant & 0x3f);\n+  %}\n+\n+  ins_pipe(ialu_reg_shift);\n+%}\n+\n+instruct rorI_reg_rvb(iRegINoSp dst, iRegI src, iRegI shift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RotateRight src shift));\n+\n+  format %{ \"rorw    $dst, $src, $shift\\t#@rorI_reg_rvb\" %}\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ rorw(as_Register($dst$$reg), as_Register($src$$reg), as_Register($shift$$reg));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct rorL_reg_rvb(iRegLNoSp dst, iRegL src, iRegI shift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RotateRight src shift));\n+\n+  format %{ \"ror    $dst, $src, $shift\\t#@rorL_reg_rvb\" %}\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ ror(as_Register($dst$$reg), as_Register($src$$reg), as_Register($shift$$reg));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct rolI_reg_rvb(iRegINoSp dst, iRegI src, iRegI shift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RotateLeft src shift));\n+\n+  format %{ \"rolw    $dst, $src, $shift\\t#@rolI_reg_rvb\" %}\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ rolw(as_Register($dst$$reg), as_Register($src$$reg), as_Register($shift$$reg));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+instruct rolL_reg_rvb(iRegLNoSp dst, iRegL src, iRegI shift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RotateLeft src shift));\n+\n+  format %{ \"rol    $dst, $src, $shift\\t#@rolL_reg_rvb\" %}\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ rol(as_Register($dst$$reg), as_Register($src$$reg), as_Register($shift$$reg));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n+\n+\/\/ unsigned int to long (zero extend)\n+\/\/ this pattern occurs in bigmath arithmetic\n+instruct convUI2L_reg_reg_rvb(iRegLNoSp dst, iRegIorL2I src, immL_32bits mask) %{\n+  predicate(UseRVB);\n+  match(Set dst (AndL (ConvI2L src) mask));\n+\n+  format %{ \"zext.w    $dst, $src\\t# ui2l, #@convUI2L_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ zext_w(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg_shift);\n+%}\n+\n+\/\/ Convert oop into int for vectors alignment masking\n+instruct convP2I_rvb(iRegINoSp dst, iRegP src) %{\n+  predicate(UseRVB);\n+  match(Set dst (ConvL2I (CastP2X src)));\n+\n+  format %{ \"zext.w    $dst, $src\\t# ptr -> int @convP2I_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ zext_w(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ sign extend byte, used by type conversion between byte and short\/int\n+instruct sextByte_reg_reg_rvb(iRegINoSp dst, iRegIorL2I src, immI_24 lshift, immI_24 rshift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RShiftI (LShiftI src lshift) rshift));\n+\n+  format %{ \"sext.b    $dst, $src\\t# sextByte, #@sextByte_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ sext_b(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ long to byte\n+instruct convL2Byte_reg_reg_rvb(iRegINoSp dst, iRegILNPNoSp src, immI_56 lshift, immI_56 rshift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RShiftL (LShiftL src lshift) rshift));\n+\n+  format %{ \"sext.b    $dst, $src\\t# l2byte, #@convL2Byte_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ sext_b(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ int to short\n+instruct convI2S_reg_reg_rvb(iRegINoSp dst, iRegIorL2I src, immI_16 lshift, immI_16 rshift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RShiftI (LShiftI src lshift) rshift));\n+\n+  format %{ \"sext.h    $dst, $src\\t# i2s, #@convI2S_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ sext_h(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ long to short\n+instruct convL2S_reg_reg_rvb(iRegINoSp dst, iRegILNPNoSp src, immI_48 lshift, immI_48 rshift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RShiftL (LShiftL src lshift) rshift));\n+\n+  format %{ \"sext.h    $dst, $src\\t# l2s, #@convL2S_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ sext_h(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ unsigned int to short\n+instruct convUI2S_reg_reg_rvb(iRegINoSp dst, iRegIorL2I src, immI_16bits mask) %{\n+  predicate(UseRVB);\n+  match(Set dst (AndI src mask));\n+\n+  format %{ \"zext.h    $dst, $src\\t# ui2s, #@convUI2S_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ zext_h(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ unsigned long to short\n+instruct convUL2S_reg_reg_rvb(iRegINoSp dst, iRegLNoSp src, immL_16bits mask) %{\n+  predicate(UseRVB);\n+  match(Set dst (AndL (ConvI2L src) mask));\n+\n+  format %{ \"zext.h    $dst, $src\\t# ul2s, #@convUL2S_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ zext_h(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ byte to long\n+instruct convByte2L_reg_reg_rvb(iRegLNoSp dst, iRegILNPNoSp src, immI_56 lshift, immI_56 rshift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RShiftL (LShiftL src lshift) rshift));\n+\n+  format %{ \"sext.b    $dst, $src\\t# byte2l, #@convByte2L_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ sext_b(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ short to int\n+instruct convS2I_reg_reg_rvb(iRegINoSp dst, iRegIorL2I src, immI_16 lshift, immI_16 rshift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RShiftI (LShiftI src lshift) rshift));\n+\n+  format %{ \"sext.h    $dst, $src\\t# s2i, #@convS2I_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ sext_h(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ short to long\n+instruct convS2L_reg_reg_rvb(iRegLNoSp dst, iRegIorL2I src, immI_48 lshift, immI_48 rshift) %{\n+  predicate(UseRVB);\n+  match(Set dst (RShiftL (LShiftL src lshift) rshift));\n+\n+  format %{ \"sext.h    $dst, $src\\t# s2l, #@convS2L_reg_reg_rvb\" %}\n+\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ sext_h(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ unsigned short to int\n+instruct convUS2I_reg_reg_rvb(iRegINoSp dst, iRegIorL2I src, immI_16bits mask) %{\n+  predicate(UseRVB);\n+  match(Set dst (AndI src mask));\n+\n+  format %{ \"zext.h    $dst, $src\\t# us2i, #@convUS2I_reg_reg_rvb\" %}\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ zext_h(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ unsigned short to long\n+instruct convUS2L_reg_reg_rvb(iRegLNoSp dst, iRegILNPNoSp src, immL_16bits mask) %{\n+  predicate(UseRVB);\n+  match(Set dst (AndL (ConvI2L src) mask));\n+\n+  format %{ \"zext.h    $dst, $src\\t# us2l, #@convUS2L_reg_reg_rvb\" %}\n+  ins_cost(ALU_COST);\n+  ins_encode %{\n+    __ zext_h(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n\\ No newline at end of file\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"}]}