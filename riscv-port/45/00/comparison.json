{"files":[{"patch":"@@ -1931,0 +1931,6 @@\n+  INSN(clz,    0b0010011, 0b001, 0b011000000000);\n+  INSN(clzw,   0b0011011, 0b001, 0b011000000000);\n+  INSN(ctz,    0b0010011, 0b001, 0b011000000001);\n+  INSN(ctzw,   0b0011011, 0b001, 0b011000000001);\n+  INSN(cpop,   0b0010011, 0b001, 0b011000000010);\n+  INSN(cpopw,  0b0011011, 0b001, 0b011000000010);\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3553,1 +3553,1 @@\n-void MacroAssembler::ctzc_bit(Register Rd, Register Rs, bool isLL, Register Rtmp1, Register Rtmp2)\n+void MacroAssembler::ctzc_bit(Register Rd, Register Rs, bool isLL, Register tmp1, Register tmp2)\n@@ -3555,1 +3555,9 @@\n-  assert_different_registers(Rd, Rs, Rtmp1, Rtmp2);\n+  if (UseRVB) {\n+    assert_different_registers(Rd, Rs, tmp1);\n+    int step = isLL ? 8 : 16;\n+    ctz(Rd, Rs);\n+    andi(tmp1, Rd, step - 1);\n+    sub(Rd, Rd, tmp1);\n+    return;\n+  }\n+  assert_different_registers(Rd, Rs, tmp1, tmp2);\n@@ -3559,1 +3567,1 @@\n-  mv(Rtmp2, Rs);\n+  mv(tmp2, Rs);\n@@ -3563,3 +3571,3 @@\n-  andi(Rtmp1, Rtmp2, ((1 << step) - 1));\n-  srli(Rtmp2, Rtmp2, step);\n-  beqz(Rtmp1, Loop);\n+  andi(tmp1, tmp2, ((1 << step) - 1));\n+  srli(tmp2, tmp2, step);\n+  beqz(tmp1, Loop);\n@@ -3572,1 +3580,1 @@\n-void MacroAssembler::inflate_lo32(Register Rd, Register Rs, Register Rtmp1, Register Rtmp2)\n+void MacroAssembler::inflate_lo32(Register Rd, Register Rs, Register tmp1, Register tmp2)\n@@ -3574,2 +3582,2 @@\n-  assert_different_registers(Rd, Rs, Rtmp1, Rtmp2);\n-  li(Rtmp1, 0xFF);\n+  assert_different_registers(Rd, Rs, tmp1, tmp2);\n+  li(tmp1, 0xFF);\n@@ -3579,1 +3587,1 @@\n-    andr(Rtmp2, Rs, Rtmp1);\n+    andr(tmp2, Rs, tmp1);\n@@ -3581,1 +3589,1 @@\n-      slli(Rtmp2, Rtmp2, i * 8);\n+      slli(tmp2, tmp2, i * 8);\n@@ -3583,1 +3591,1 @@\n-    orr(Rd, Rd, Rtmp2);\n+    orr(Rd, Rd, tmp2);\n@@ -3585,1 +3593,1 @@\n-      slli(Rtmp1, Rtmp1, 8);\n+      slli(tmp1, tmp1, 8);\n@@ -3594,1 +3602,1 @@\n-void MacroAssembler::inflate_hi32(Register Rd, Register Rs, Register Rtmp1, Register Rtmp2)\n+void MacroAssembler::inflate_hi32(Register Rd, Register Rs, Register tmp1, Register tmp2)\n@@ -3596,2 +3604,2 @@\n-  assert_different_registers(Rd, Rs, Rtmp1, Rtmp2);\n-  li(Rtmp1, 0xFF00000000);\n+  assert_different_registers(Rd, Rs, tmp1, tmp2);\n+  li(tmp1, 0xFF00000000);\n@@ -3601,2 +3609,2 @@\n-    andr(Rtmp2, Rs, Rtmp1);\n-    orr(Rd, Rd, Rtmp2);\n+    andr(tmp2, Rs, tmp1);\n+    orr(Rd, Rd, tmp2);\n@@ -3605,1 +3613,1 @@\n-      slli(Rtmp1, Rtmp1, 8);\n+      slli(tmp1, tmp1, 8);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":27,"deletions":19,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -674,2 +674,2 @@\n-  void inflate_lo32(Register Rd, Register Rs, Register Rtmp1 = t0, Register Rtmp2 = t1);\n-  void inflate_hi32(Register Rd, Register Rs, Register Rtmp1 = t0, Register Rtmp2 = t1);\n+  void inflate_lo32(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2 = t1);\n+  void inflate_hi32(Register Rd, Register Rs, Register tmp1 = t0, Register tmp2 = t1);\n@@ -677,1 +677,1 @@\n-  void ctzc_bit(Register Rd, Register Rs, bool isLL = false, Register Rtmp1 = t0, Register Rtmp2 = t1);\n+  void ctzc_bit(Register Rd, Register Rs, bool isLL = false, Register tmp1 = t0, Register tmp2 = t1);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1773,0 +1773,3 @@\n+    case Op_PopCountI:\n+    case Op_PopCountL:\n+      return UsePopCountInstruction;\n@@ -1775,0 +1778,4 @@\n+    case Op_CountLeadingZerosI:\n+    case Op_CountLeadingZerosL:\n+    case Op_CountTrailingZerosI:\n+    case Op_CountTrailingZerosL:\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -308,0 +308,87 @@\n+%}\n+\n+\/\/ Zeros Count instructions\n+instruct countLeadingZerosI_rvb(iRegINoSp dst, iRegIorL2I src) %{\n+  predicate(UseRVB);\n+  match(Set dst (CountLeadingZerosI src));\n+\n+  ins_cost(ALU_COST);\n+  format %{ \"clzw  $dst, $src\\t#@countLeadingZerosI_rvb\" %}\n+\n+  ins_encode %{\n+    __ clzw(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countLeadingZerosL_rvb(iRegINoSp dst, iRegL src) %{\n+  predicate(UseRVB);\n+  match(Set dst (CountLeadingZerosL src));\n+\n+  ins_cost(ALU_COST);\n+  format %{ \"clz  $dst, $src\\t#@countLeadingZerosL_rvb\" %}\n+\n+  ins_encode %{\n+    __ clz(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countTrailingZerosI_rvb(iRegINoSp dst, iRegIorL2I src) %{\n+  predicate(UseRVB);\n+  match(Set dst (CountTrailingZerosI src));\n+\n+  ins_cost(ALU_COST);\n+  format %{ \"ctzw  $dst, $src\\t#@countTrailingZerosI_rvb\" %}\n+\n+  ins_encode %{\n+    __ ctzw(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+instruct countTrailingZerosL_rvb(iRegINoSp dst, iRegL src) %{\n+  predicate(UseRVB);\n+  match(Set dst (CountTrailingZerosL src));\n+\n+  ins_cost(ALU_COST);\n+  format %{ \"ctz  $dst, $src\\t#@countTrailingZerosL_rvb\" %}\n+\n+  ins_encode %{\n+    __ ctz(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Population Count instructions\n+instruct popCountI_rvb(iRegINoSp dst, iRegIorL2I src) %{\n+  predicate(UsePopCountInstruction);\n+  match(Set dst (PopCountI src));\n+\n+  ins_cost(ALU_COST);\n+  format %{ \"cpopw  $dst, $src\\t#@popCountI_rvb\" %}\n+\n+  ins_encode %{\n+    __ cpopw(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n+%}\n+\n+\/\/ Note: Long\/bitCount(long) returns an int.\n+instruct popCountL_rvb(iRegINoSp dst, iRegL src) %{\n+  predicate(UsePopCountInstruction);\n+  match(Set dst (PopCountL src));\n+\n+  ins_cost(ALU_COST);\n+  format %{ \"cpop  $dst, $src\\t#@popCountL_rvb\" %}\n+\n+  ins_encode %{\n+    __ cpop(as_Register($dst$$reg), as_Register($src$$reg));\n+  %}\n+\n+  ins_pipe(ialu_reg);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv_b.ad","additions":87,"deletions":0,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -89,5 +89,0 @@\n-  if (UsePopCountInstruction) {\n-    warning(\"Pop count instructions are not available on this CPU.\");\n-    FLAG_SET_DEFAULT(UsePopCountInstruction, false);\n-  }\n-\n@@ -128,0 +123,8 @@\n+  if (UseRVB) {\n+    if (FLAG_IS_DEFAULT(UsePopCountInstruction)) {\n+      FLAG_SET_DEFAULT(UsePopCountInstruction, true);\n+    }\n+  } else {\n+    FLAG_SET_DEFAULT(UsePopCountInstruction, false);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"}]}