{"files":[{"patch":"@@ -79,0 +79,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -89,2 +90,0 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -1525,2 +1524,0 @@\n-  _forwarding = new SlidingForwarding(heap_rs.region(), HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n-\n@@ -1676,0 +1673,2 @@\n+  GCForwarding::initialize(heap_rs.region(), HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-class SlidingForwarding;\n@@ -256,2 +255,0 @@\n-  SlidingForwarding* _forwarding;\n-\n@@ -271,4 +268,0 @@\n-  SlidingForwarding* forwarding() const {\n-    return _forwarding;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -211,0 +211,1 @@\n+  GCForwarding::begin();\n@@ -223,0 +224,2 @@\n+  GCForwarding::end();\n+\n@@ -334,2 +337,0 @@\n-  _heap->forwarding()->clear();\n-\n@@ -347,4 +348,3 @@\n-  \/\/ TODO: Disabled for now because it violates sliding-forwarding assumption.\n-\/\/  if (scope()->do_maximal_compaction() || !has_free_compaction_targets) {\n-\/\/    phase2c_prepare_serial_compaction();\n-\/\/  }\n+  if (!UseCompactObjectHeaders && (scope()->do_maximal_compaction() || !has_free_compaction_targets)) {\n+    phase2c_prepare_serial_compaction();\n+  }\n@@ -369,55 +369,55 @@\n-\/\/uint G1FullCollector::truncate_parallel_cps() {\n-\/\/  uint lowest_current = (uint)-1;\n-\/\/  for (uint i = 0; i < workers(); i++) {\n-\/\/    G1FullGCCompactionPoint* cp = compaction_point(i);\n-\/\/    if (cp->has_regions()) {\n-\/\/      lowest_current = MIN2(lowest_current, cp->current_region()->hrm_index());\n-\/\/    }\n-\/\/  }\n-\n-\/\/  for (uint i = 0; i < workers(); i++) {\n-\/\/    G1FullGCCompactionPoint* cp = compaction_point(i);\n-\/\/    if (cp->has_regions()) {\n-\/\/      cp->remove_at_or_above(lowest_current);\n-\/\/    }\n-\/\/  }\n-\/\/  return lowest_current;\n-\/\/}\n-\n-\/\/void G1FullCollector::phase2c_prepare_serial_compaction() {\n-\/\/  GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare serial compaction\", scope()->timer());\n-\/\/  \/\/ At this point, we know that after parallel compaction there will be regions that\n-\/\/  \/\/ are partially compacted into. Thus, the last compaction region of all\n-\/\/  \/\/ compaction queues still have space in them. We try to re-compact these regions\n-\/\/  \/\/ in serial to avoid a premature OOM when the mutator wants to allocate the first\n-\/\/  \/\/ eden region after gc.\n-\/\/\n-\/\/  \/\/ For maximum compaction, we need to re-prepare all objects above the lowest\n-\/\/  \/\/ region among the current regions for all thread compaction points. It may\n-\/\/  \/\/ happen that due to the uneven distribution of objects to parallel threads, holes\n-\/\/  \/\/ have been created as threads compact to different target regions between the\n-\/\/  \/\/ lowest and the highest region in the tails of the compaction points.\n-\/\/\n-\/\/  uint start_serial = truncate_parallel_cps();\n-\/\/  assert(start_serial < _heap->max_reserved_regions(), \"Called on empty parallel compaction queues\");\n-\/\/\n-\/\/  G1FullGCCompactionPoint* serial_cp = serial_compaction_point();\n-\/\/  assert(!serial_cp->is_initialized(), \"sanity!\");\n-\/\/\n-\/\/  HeapRegion* start_hr = _heap->region_at(start_serial);\n-\/\/  serial_cp->add(start_hr);\n-\/\/  serial_cp->initialize(start_hr);\n-\/\/\n-\/\/  HeapWord* dense_prefix_top = compaction_top(start_hr);\n-\/\/  G1SerialRePrepareClosure re_prepare(serial_cp, dense_prefix_top);\n-\/\/\n-\/\/  for (uint i = start_serial + 1; i < _heap->max_reserved_regions(); i++) {\n-\/\/    if (is_compaction_target(i)) {\n-\/\/      HeapRegion* current = _heap->region_at(i);\n-\/\/      set_compaction_top(current, current->bottom());\n-\/\/      serial_cp->add(current);\n-\/\/      current->apply_to_marked_objects(mark_bitmap(), &re_prepare);\n-\/\/    }\n-\/\/  }\n-\/\/  serial_cp->update();\n-\/\/}\n+uint G1FullCollector::truncate_parallel_cps() {\n+  uint lowest_current = (uint)-1;\n+  for (uint i = 0; i < workers(); i++) {\n+    G1FullGCCompactionPoint* cp = compaction_point(i);\n+    if (cp->has_regions()) {\n+      lowest_current = MIN2(lowest_current, cp->current_region()->hrm_index());\n+    }\n+  }\n+\n+  for (uint i = 0; i < workers(); i++) {\n+    G1FullGCCompactionPoint* cp = compaction_point(i);\n+    if (cp->has_regions()) {\n+      cp->remove_at_or_above(lowest_current);\n+    }\n+  }\n+  return lowest_current;\n+}\n+\n+void G1FullCollector::phase2c_prepare_serial_compaction() {\n+  GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare serial compaction\", scope()->timer());\n+  \/\/ At this point, we know that after parallel compaction there will be regions that\n+  \/\/ are partially compacted into. Thus, the last compaction region of all\n+  \/\/ compaction queues still have space in them. We try to re-compact these regions\n+  \/\/ in serial to avoid a premature OOM when the mutator wants to allocate the first\n+  \/\/ eden region after gc.\n+\n+  \/\/ For maximum compaction, we need to re-prepare all objects above the lowest\n+  \/\/ region among the current regions for all thread compaction points. It may\n+  \/\/ happen that due to the uneven distribution of objects to parallel threads, holes\n+  \/\/ have been created as threads compact to different target regions between the\n+  \/\/ lowest and the highest region in the tails of the compaction points.\n+\n+  uint start_serial = truncate_parallel_cps();\n+  assert(start_serial < _heap->max_reserved_regions(), \"Called on empty parallel compaction queues\");\n+\n+  G1FullGCCompactionPoint* serial_cp = serial_compaction_point();\n+  assert(!serial_cp->is_initialized(), \"sanity!\");\n+\n+  HeapRegion* start_hr = _heap->region_at(start_serial);\n+  serial_cp->add(start_hr);\n+  serial_cp->initialize(start_hr);\n+\n+  HeapWord* dense_prefix_top = compaction_top(start_hr);\n+  G1SerialRePrepareClosure re_prepare(serial_cp, dense_prefix_top);\n+\n+  for (uint i = start_serial + 1; i < _heap->max_reserved_regions(); i++) {\n+    if (is_compaction_target(i)) {\n+      HeapRegion* current = _heap->region_at(i);\n+      set_compaction_top(current, current->bottom());\n+      serial_cp->add(current);\n+      current->apply_to_marked_objects(mark_bitmap(), &re_prepare);\n+    }\n+  }\n+  serial_cp->update();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":62,"deletions":62,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -97,2 +97,1 @@\n-  const SlidingForwarding* const forwarding = G1CollectedHeap::heap()->forwarding();\n-  marker->preserved_stack()->adjust_during_full_gc(forwarding);\n+  marker->preserved_stack()->adjust_during_full_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -45,2 +45,2 @@\n-  if (obj->is_forwarded()) {\n-    HeapWord* destination = cast_from_oop<HeapWord*>(_forwarding->forwardee(obj));\n+  if (GCForwarding::is_forwarded(obj)) {\n+    HeapWord* destination = cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class SlidingForwarding;\n@@ -55,1 +54,0 @@\n-    const SlidingForwarding* const _forwarding;\n@@ -58,3 +56,1 @@\n-    G1CompactRegionClosure(G1CMBitMap* bitmap) :\n-      _bitmap(bitmap),\n-      _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n+    G1CompactRegionClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -95,1 +95,1 @@\n-void G1FullGCCompactionPoint::forward(SlidingForwarding* const forwarding, oop object, size_t size) {\n+void G1FullGCCompactionPoint::forward(oop object, size_t size) {\n@@ -105,2 +105,2 @@\n-    forwarding->forward_to(object, cast_to_oop(_compaction_top));\n-    assert(object->is_forwarded(), \"must be forwarded\");\n+    GCForwarding::forward_to(object, cast_to_oop(_compaction_top));\n+    assert(GCForwarding::is_forwarded(object), \"must be forwarded\");\n@@ -108,1 +108,1 @@\n-    assert(!object->is_forwarded(), \"must not be forwarded\");\n+    assert(GCForwarding::is_not_forwarded(object), \"must not be forwarded\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-class SlidingForwarding;\n@@ -56,1 +55,1 @@\n-  void forward(SlidingForwarding* const forwarding, oop object, size_t size);\n+  void forward(oop object, size_t size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -36,1 +35,0 @@\n-class SlidingForwarding;\n@@ -80,1 +78,0 @@\n-  const SlidingForwarding* const _forwarding;\n@@ -84,3 +81,1 @@\n-  G1AdjustClosure(G1FullCollector* collector) :\n-    _collector(collector),\n-    _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n+  G1AdjustClosure(G1FullCollector* collector) : _collector(collector) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -69,2 +69,2 @@\n-  if (obj->is_forwarded()) {\n-    oop forwardee = _forwarding->forwardee(obj);\n+  if (GCForwarding::is_forwarded(obj)) {\n+    oop forwardee = GCForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -111,1 +110,1 @@\n-    _cp(cp), _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n+    _cp(cp) { }\n@@ -115,1 +114,1 @@\n-  _cp->forward(_forwarding, object, size);\n+  _cp->forward(object, size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class SlidingForwarding;\n@@ -96,1 +95,0 @@\n-    SlidingForwarding* const _forwarding;\n@@ -106,11 +104,11 @@\n-\/\/class G1SerialRePrepareClosure : public StackObj {\n-\/\/  G1FullGCCompactionPoint* _cp;\n-\/\/  HeapWord* _dense_prefix_top;\n-\/\/\n-\/\/public:\n-\/\/  G1SerialRePrepareClosure(G1FullGCCompactionPoint* hrcp, HeapWord* dense_prefix_top) :\n-\/\/    _cp(hrcp),\n-\/\/    _dense_prefix_top(dense_prefix_top) { }\n-\/\/\n-\/\/  inline size_t apply(oop obj);\n-\/\/};\n+class G1SerialRePrepareClosure : public StackObj {\n+  G1FullGCCompactionPoint* _cp;\n+  HeapWord* _dense_prefix_top;\n+\n+public:\n+  G1SerialRePrepareClosure(G1FullGCCompactionPoint* hrcp, HeapWord* dense_prefix_top) :\n+    _cp(hrcp),\n+    _dense_prefix_top(dense_prefix_top) { }\n+\n+  inline size_t apply(oop obj);\n+};\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -114,15 +114,15 @@\n-\/\/inline size_t G1SerialRePrepareClosure::apply(oop obj) {\n-\/\/  if (obj->is_forwarded()) {\n-\/\/    \/\/ We skip objects compiled into the first region or\n-\/\/    \/\/ into regions not part of the serial compaction point.\n-\/\/    if (cast_from_oop<HeapWord*>(obj->forwardee()) < _dense_prefix_top) {\n-\/\/      return obj->size();\n-\/\/    }\n-\/\/  }\n-\/\/\n-\/\/  \/\/ Get size and forward.\n-\/\/  size_t size = obj->size();\n-\/\/  _cp->forward(obj, size);\n-\/\/\n-\/\/  return size;\n-\/\/}\n+inline size_t G1SerialRePrepareClosure::apply(oop obj) {\n+  if (GCForwarding::is_forwarded(obj)) {\n+    \/\/ We skip objects compiled into the first region or\n+    \/\/ into regions not part of the serial compaction point.\n+    if (cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj)) < _dense_prefix_top) {\n+      return obj->size();\n+    }\n+  }\n+\n+  \/\/ Get size and forward.\n+  size_t size = obj->size();\n+  _cp->forward(obj, size);\n+\n+  return size;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -838,1 +838,10 @@\n-    from()->set_next_compaction_space(to());\n+    \/\/ Ensure that compaction spaces are in address-order.\n+    if (from()->bottom() < to()->bottom()) {\n+      eden()->set_next_compaction_space(from());\n+      from()->set_next_compaction_space(to());\n+      to()->set_next_compaction_space(nullptr);\n+    } else {\n+      eden()->set_next_compaction_space(to());\n+      to()->set_next_compaction_space(from());\n+      from()->set_next_compaction_space(nullptr);\n+    }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -95,0 +96,2 @@\n+  GCForwarding::begin();\n+\n@@ -107,0 +110,2 @@\n+  GCForwarding::end();\n+\n@@ -183,0 +188,3 @@\n+  _young_marked_objects = 0;\n+  _old_marked_objects = 0;\n+\n@@ -259,2 +267,0 @@\n-  AdjustPointerClosure adjust_pointer_closure(gch->forwarding());\n-  CLDToOopClosure      adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -67,0 +67,1 @@\n+CLDToOopClosure    MarkSweep::adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n@@ -148,2 +149,2 @@\n-void PreservedMark::adjust_pointer(const SlidingForwarding* const forwarding) {\n-  MarkSweep::adjust_pointer(forwarding, &_obj);\n+void PreservedMark::adjust_pointer() {\n+  MarkSweep::adjust_pointer(&_obj);\n@@ -205,0 +206,6 @@\n+\n+  if (GenCollectedHeap::heap()->is_in_young(obj)) {\n+    _young_marked_objects++;\n+  } else {\n+    _old_marked_objects++;\n+  }\n@@ -223,2 +230,1 @@\n-void MarkSweep::adjust_marks() {\n-  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n+AdjustPointerClosure MarkSweep::adjust_pointer_closure;\n@@ -226,0 +232,1 @@\n+void MarkSweep::adjust_marks() {\n@@ -228,1 +235,1 @@\n-    _preserved_marks[i].adjust_pointer(forwarding);\n+    _preserved_marks[i].adjust_pointer();\n@@ -235,1 +242,1 @@\n-    p->adjust_pointer(forwarding);\n+    p->adjust_pointer();\n@@ -260,0 +267,3 @@\n+size_t MarkSweep::_young_marked_objects = 0;\n+size_t MarkSweep::_old_marked_objects = 0;\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-class SlidingForwarding;\n@@ -119,1 +118,4 @@\n- public:\n+  static size_t _young_marked_objects;\n+  static size_t _old_marked_objects;\n+\n+public:\n@@ -128,0 +130,2 @@\n+  static AdjustPointerClosure adjust_pointer_closure;\n+  static CLDToOopClosure      adjust_cld_closure;\n@@ -144,1 +148,1 @@\n-  static size_t adjust_pointers(const SlidingForwarding* const forwarding, oop obj);\n+  static size_t adjust_pointers(oop obj);\n@@ -148,1 +152,1 @@\n-  template <class T> static inline void adjust_pointer(const SlidingForwarding* const forwarding, T* p);\n+  template <class T> static inline void adjust_pointer(T* p);\n@@ -182,2 +186,0 @@\n-private:\n-  const SlidingForwarding* const _forwarding;\n@@ -185,1 +187,0 @@\n-  AdjustPointerClosure(const SlidingForwarding* forwarding) : _forwarding(forwarding) {}\n@@ -199,1 +200,1 @@\n-  void adjust_pointer(const SlidingForwarding* const forwarding);\n+  void adjust_pointer();\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -43,1 +43,1 @@\n-template <class T> inline void MarkSweep::adjust_pointer(const SlidingForwarding* const forwarding, T* p) {\n+template <class T> inline void MarkSweep::adjust_pointer(T* p) {\n@@ -49,4 +49,2 @@\n-    markWord header = obj->mark();\n-    if (header.is_marked()) {\n-      oop new_obj = forwarding->forwardee(obj);\n-      assert(new_obj != NULL, \"must be forwarded\");\n+    if (GCForwarding::is_forwarded(obj)) {\n+      oop new_obj = GCForwarding::forwardee(obj);\n@@ -60,1 +58,1 @@\n-void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(_forwarding, p); }\n+void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(p); }\n@@ -64,3 +62,2 @@\n-inline size_t MarkSweep::adjust_pointers(const SlidingForwarding* const forwarding, oop obj) {\n-  AdjustPointerClosure cl(forwarding);\n-  return obj->oop_iterate_size(&cl);\n+inline size_t MarkSweep::adjust_pointers(oop obj) {\n+  return obj->oop_iterate_size(&MarkSweep::adjust_pointer_closure);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+SlidingForwarding* GCForwarding::_sliding_forwarding = nullptr;\n+\n+void GCForwarding::initialize(MemRegion heap) {\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding == nullptr, \"only call this once\");\n+    _sliding_forwarding = new SlidingForwarding(heap);\n+  }\n+}\n+\n+void GCForwarding::initialize(MemRegion heap, size_t region_size_words_shift) {\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding == nullptr, \"only call this once\");\n+    _sliding_forwarding = new SlidingForwarding(heap, region_size_words_shift);\n+  }\n+}\n+\n+void GCForwarding::begin() {\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    _sliding_forwarding->clear();\n+  }\n+}\n+\n+void GCForwarding::end() {\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCFORWARDING_HPP\n+#define SHARE_GC_SHARED_GCFORWARDING_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class SlidingForwarding;\n+\n+class GCForwarding : public AllStatic {\n+private:\n+  static SlidingForwarding* _sliding_forwarding;\n+\n+public:\n+  static void initialize(MemRegion heap);\n+  static void initialize(MemRegion heap, size_t region_size_words_shift);\n+  static void begin();\n+  static void end();\n+\n+  static inline bool is_forwarded(oop obj);\n+  static inline bool is_not_forwarded(oop obj);\n+  static inline oop forwardee(oop obj);\n+  static inline void forward_to(oop obj, oop fwd);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_GCFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n+\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+inline bool GCForwarding::is_forwarded(oop obj) {\n+  return obj->is_forwarded();\n+}\n+\n+inline bool GCForwarding::is_not_forwarded(oop obj) {\n+  return !obj->is_forwarded();\n+}\n+\n+inline oop GCForwarding::forwardee(oop obj) {\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    return _sliding_forwarding->forwardee(obj);\n+  } else {\n+    return obj->forwardee();\n+  }\n+}\n+\n+inline void GCForwarding::forward_to(oop obj, oop fwd) {\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    _sliding_forwarding->forward_to(obj, fwd);\n+    assert(forwardee(obj) == fwd, \"must be forwarded to correct forwardee\");\n+  } else {\n+    obj->forward_to(fwd);\n+  }\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.inline.hpp","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -57,1 +58,0 @@\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -120,1 +120,0 @@\n-  _forwarding = new SlidingForwarding(_reserved);\n@@ -137,0 +136,2 @@\n+  GCForwarding::initialize(_reserved);\n+\n@@ -1039,1 +1040,0 @@\n-  _forwarding->clear();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-class SlidingForwarding;\n@@ -91,2 +90,0 @@\n-  SlidingForwarding* _forwarding;\n-\n@@ -318,4 +315,0 @@\n-  SlidingForwarding* forwarding() const {\n-    return _forwarding;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,0 +63,11 @@\n+size_t MarkBitMap::count_marked(MemRegion mr) {\n+  MemRegion intersection = mr.intersection(_covered);\n+  assert(!intersection.is_empty(),\n+         \"Given range from \" PTR_FORMAT \" to \" PTR_FORMAT \" is completely outside the heap\",\n+         p2i(mr.start()), p2i(mr.end()));\n+  \/\/ convert address range into offset range\n+  size_t beg = addr_to_offset(intersection.start());\n+  size_t end = addr_to_offset(intersection.end());\n+  return _bm.count_one_bits(beg, end);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+\n+  size_t count_marked(MemRegion mr);\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -44,2 +44,0 @@\n-\/\/ TODO: This method is unused, except in the gunit test. Change the test\n-\/\/ to exercise the updated method below instead, and remove this one.\n@@ -52,14 +50,2 @@\n-    if (obj->is_forwarded()) {\n-      elem->set_oop(obj->forwardee());\n-    }\n-  }\n-}\n-\n-void PreservedMarks::adjust_during_full_gc(const SlidingForwarding* const forwarding) {\n-  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n-  while (!iter.is_empty()) {\n-    OopAndMarkWord* elem = iter.next_addr();\n-\n-    oop obj = elem->get_oop();\n-    if (obj->is_forwarded()) {\n-      elem->set_oop(forwarding->forwardee(obj));\n+    if (GCForwarding::is_forwarded(obj)) {\n+      elem->set_oop(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class SlidingForwarding;\n@@ -67,2 +66,0 @@\n-  \/\/ TODO: This method is unused, except in the gunit test. Change the test\n-  \/\/ to exercise the updated method below instead, and remove this one.\n@@ -71,2 +68,0 @@\n-  void adjust_during_full_gc(const SlidingForwarding* const forwarding);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -256,1 +256,1 @@\n-                                    CompactPoint* cp, HeapWord* compact_top, SlidingForwarding* const forwarding) {\n+                                    CompactPoint* cp, HeapWord* compact_top) {\n@@ -279,1 +279,1 @@\n-    forwarding->forward_to(q, cast_to_oop(compact_top));\n+    GCForwarding::forward_to(q, cast_to_oop(compact_top));\n@@ -285,1 +285,1 @@\n-    assert(!q->is_forwarded(), \"should not be forwarded\");\n+    assert(GCForwarding::is_not_forwarded(q), \"should not be forwarded\");\n@@ -327,1 +327,0 @@\n-  SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -333,1 +332,1 @@\n-      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top, forwarding);\n+      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top);\n@@ -349,1 +348,1 @@\n-        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top, forwarding);\n+        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top);\n@@ -392,1 +391,0 @@\n-  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -404,1 +402,1 @@\n-      size_t size = MarkSweep::adjust_pointers(forwarding, cast_to_oop(cur_obj));\n+      size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_obj));\n@@ -445,2 +443,0 @@\n-  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n-\n@@ -449,1 +445,1 @@\n-    if (!cast_to_oop(cur_obj)->is_forwarded()) {\n+    if (GCForwarding::is_not_forwarded(cast_to_oop(cur_obj))) {\n@@ -460,1 +456,1 @@\n-      HeapWord* compaction_top = cast_from_oop<HeapWord*>(forwarding->forwardee(cast_to_oop(cur_obj)));\n+      HeapWord* compaction_top = cast_from_oop<HeapWord*>(GCForwarding::forwardee(cast_to_oop(cur_obj)));\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-class SlidingForwarding;\n@@ -388,1 +387,1 @@\n-                    HeapWord* compact_top, SlidingForwarding* const forwarding);\n+                    HeapWord* compact_top);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -191,1 +191,0 @@\n-    heap->forwarding()->clear();\n@@ -226,0 +225,1 @@\n+    GCForwarding::begin();\n@@ -237,0 +237,1 @@\n+    GCForwarding::end();\n@@ -302,3 +303,2 @@\n-  PreservedMarks*    const _preserved_marks;\n-  SlidingForwarding* const _forwarding;\n-  ShenandoahHeap*    const _heap;\n+  PreservedMarks*          const _preserved_marks;\n+  ShenandoahHeap*          const _heap;\n@@ -316,1 +316,0 @@\n-    _forwarding(ShenandoahHeap::heap()->forwarding()),\n@@ -370,1 +369,1 @@\n-    _forwarding->forward_to(p, cast_to_oop(_compact_point));\n+    GCForwarding::forward_to(p, cast_to_oop(_compact_point));\n@@ -423,0 +422,1 @@\n+        size_t num_marked = _heap->complete_marking_context()->count_marked(MemRegion(from_region->bottom(), from_region->top()));\n@@ -444,1 +444,0 @@\n-  SlidingForwarding* forwarding = heap->forwarding();\n@@ -479,1 +478,1 @@\n-        forwarding->forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n+        GCForwarding::forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -730,2 +729,1 @@\n-  ShenandoahHeap*           const _heap;\n-  const SlidingForwarding*  const _forwarding;\n+  ShenandoahHeap* const _heap;\n@@ -740,2 +738,2 @@\n-      if (obj->is_forwarded()) {\n-        oop forw = _forwarding->forwardee(obj);\n+      if (GCForwarding::is_forwarded(obj)) {\n+        oop forw = GCForwarding::forwardee(obj);\n@@ -750,1 +748,0 @@\n-    _forwarding(_heap->forwarding()),\n@@ -812,2 +809,1 @@\n-    const SlidingForwarding* const forwarding = ShenandoahHeap::heap()->forwarding();\n-    _preserved_marks->get(worker_id)->adjust_during_full_gc(forwarding);\n+    _preserved_marks->get(worker_id)->adjust_during_full_gc();\n@@ -843,3 +839,2 @@\n-  ShenandoahHeap*          const _heap;\n-  const SlidingForwarding* const _forwarding;\n-  uint                     const _worker_id;\n+  ShenandoahHeap* const _heap;\n+  uint            const _worker_id;\n@@ -849,1 +844,1 @@\n-    _heap(ShenandoahHeap::heap()), _forwarding(_heap->forwarding()), _worker_id(worker_id) {}\n+    _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}\n@@ -854,1 +849,1 @@\n-    if (p->is_forwarded()) {\n+    if (GCForwarding::is_forwarded(p)) {\n@@ -856,1 +851,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(_forwarding->forwardee(p));\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(GCForwarding::forwardee(p));\n@@ -953,1 +948,0 @@\n-  const SlidingForwarding* const forwarding = heap->forwarding();\n@@ -959,1 +953,1 @@\n-      if (!old_obj->is_forwarded()) {\n+      if (GCForwarding::is_not_forwarded(old_obj)) {\n@@ -968,1 +962,1 @@\n-      size_t new_start = heap->heap_region_index_containing(forwarding->forwardee(old_obj));\n+      size_t new_start = heap->heap_region_index_containing(GCForwarding::forwardee(old_obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -198,2 +198,0 @@\n-  _forwarding = new SlidingForwarding(_heap_region, ShenandoahHeapRegion::region_size_words_shift());\n-\n@@ -410,0 +408,2 @@\n+  GCForwarding::initialize(_heap_region, ShenandoahHeapRegion::region_size_words_shift());\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-class SlidingForwarding;\n@@ -232,1 +231,0 @@\n-  SlidingForwarding* _forwarding;\n@@ -249,2 +247,0 @@\n-  SlidingForwarding* forwarding() const { return _forwarding; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,0 +123,19 @@\n+size_t ShenandoahMarkBitMap::count_marked(MemRegion mr) const {\n+  MemRegion intersection = mr.intersection(_covered);\n+  assert(!intersection.is_empty(),\n+         \"Given range from \" PTR_FORMAT \" to \" PTR_FORMAT \" is completely outside the heap\",\n+          p2i(mr.start()), p2i(mr.end()));\n+  \/\/ convert address range into offset range\n+  HeapWord* beg = intersection.start();\n+  HeapWord* end = intersection.end();\n+  size_t sum = 0;\n+  \/\/ We could probably be smarter here, but the complication is that we use\n+  \/\/ two bits per object for strong vs weak marking.\n+  for (HeapWord* current = beg; current < end; current++) {\n+    if (is_marked(current)) {\n+      sum++;\n+    }\n+  }\n+  return sum;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  size_t count_marked(MemRegion mr) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+size_t ShenandoahMarkingContext::count_marked(MemRegion mr) const {\n+  return _mark_bit_map.count_marked(mr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  size_t count_marked(MemRegion mr) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,4 @@\n+#ifdef _LP64\n+  FlagSetting fs(UseCompactObjectHeaders, false);\n+#endif\n+\n@@ -81,3 +85,0 @@\n-  \/\/ TODO: This is the only use of PM::adjust_during_full_gc().\n-  \/\/ GCs use the variant with a forwarding structure here,\n-  \/\/ test that variant, and remove the method.\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}