{"files":[{"patch":"@@ -61,3 +61,0 @@\n-          - s390x\n-          - ppc64le\n-          - riscv64\n@@ -76,15 +73,0 @@\n-          - target-cpu: s390x\n-            gnu-arch: s390x\n-            debian-arch: s390x\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: bullseye\n-          - target-cpu: ppc64le\n-            gnu-arch: powerpc64le\n-            debian-arch: ppc64el\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: bullseye\n-          - target-cpu: riscv64\n-            gnu-arch: riscv64\n-            debian-arch: riscv64\n-            debian-repository: https:\/\/httpredir.debian.org\/debian\/\n-            debian-version: sid\n","filename":".github\/workflows\/build-cross-compile.yml","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=lilliput\n@@ -7,1 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -21,3 +21,0 @@\n-[checks \"merge\"]\n-message=Merge\n-\n@@ -25,1 +22,1 @@\n-reviewers=1\n+committers=1\n","filename":".jcheck\/conf","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -834,0 +834,5 @@\n+  # Add more Lilliput-specific ProblemLists when UCOH is enabled\n+  ifneq ($$(findstring -XX:+UseCompactObjectHeaders, $$(TEST_OPTS)), )\n+    JTREG_EXTRA_PROBLEM_LISTS += $(TOPDIR)\/test\/hotspot\/jtreg\/ProblemList-lilliput.txt\n+  endif\n+\n","filename":"make\/RunTests.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -7330,1 +7330,1 @@\n-  predicate(!needs_acquiring_load(n));\n+  predicate(!needs_acquiring_load(n) && !UseCompactObjectHeaders);\n@@ -7340,0 +7340,26 @@\n+instruct loadNKlassLilliput(iRegNNoSp dst, memory4 mem, rFlagsReg cr)\n+%{\n+  match(Set dst (LoadNKlass mem));\n+  effect(KILL cr);\n+  predicate(!needs_acquiring_load(n) && UseCompactObjectHeaders);\n+\n+  ins_cost(4 * INSN_COST);\n+  format %{ \"ldrw  $dst, $mem\\t# compressed class ptr\" %}\n+  ins_encode %{\n+    assert($mem$$disp == oopDesc::klass_offset_in_bytes(), \"expect correct offset\");\n+    assert($mem$$index$$Register == noreg, \"expect no index\");\n+    Register dst = $dst$$Register;\n+    Register obj = $mem$$base$$Register;\n+    C2LoadNKlassStub* stub = new (Compile::current()->comp_arena()) C2LoadNKlassStub(dst);\n+    Compile::current()->output()->add_stub(stub);\n+    __ ldr(dst, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    \/\/ NOTE: We can't use tbnz here, because the target is sometimes too far away\n+    \/\/ and cannot be encoded.\n+    __ tst(dst, markWord::monitor_value);\n+    __ br(Assembler::NE, stub->entry());\n+    __ bind(stub->continuation());\n+    __ lsr(dst, dst, markWord::klass_shift);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -236,0 +237,7 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  assert(UseCompactObjectHeaders, \"Only use with compact object headers\");\n+  __ bind(_entry);\n+  Register d = _result->as_register();\n+  __ ldr(d, Address(d, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n+  __ b(_continuation);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1232,1 +1232,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n@@ -2355,2 +2355,2 @@\n-        __ ldrw(tmp, src_klass_addr);\n-        __ ldrw(rscratch1, dst_klass_addr);\n+        __ load_nklass(tmp, src);\n+        __ load_nklass(rscratch1, dst);\n@@ -2359,2 +2359,2 @@\n-        __ ldr(tmp, src_klass_addr);\n-        __ ldr(rscratch1, dst_klass_addr);\n+        __ ldr(tmp, Address(src, oopDesc::klass_offset_in_bytes()));\n+        __ ldr(rscratch1, Address(dst, oopDesc::klass_offset_in_bytes()));\n@@ -2484,3 +2484,0 @@\n-    if (UseCompressedClassPointers) {\n-      __ encode_klass_not_null(tmp);\n-    }\n@@ -2489,8 +2486,1 @@\n-\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(rscratch1, dst_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(rscratch1, dst_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ cmp_klass(dst, tmp, rscratch1);\n@@ -2498,7 +2488,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(rscratch1, src_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(rscratch1, src_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ cmp_klass(src, tmp, rscratch1);\n@@ -2507,7 +2491,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(rscratch1, dst_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(rscratch1, dst_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ cmp_klass(dst, tmp, rscratch1);\n@@ -2594,1 +2572,12 @@\n-    __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+    if (UseCompactObjectHeaders) {\n+      \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+      __ ldr(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n+      __ tst(result, markWord::monitor_value);\n+      __ br(Assembler::NE, *op->stub()->entry());\n+      __ bind(*op->stub()->continuation());\n+\n+      \/\/ Shift to get proper narrow Klass*.\n+      __ lsr(result, result, markWord::klass_shift);\n+    } else {\n+      __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":20,"deletions":31,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -183,7 +183,3 @@\n-  \/\/ This assumes that all prototype bits fit in an int32_t\n-  mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n-  str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n-\n-  if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n-    encode_klass_not_null(t1, klass);\n-    strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  if (UseCompactObjectHeaders) {\n+    ldr(t1, Address(klass, Klass::prototype_header_offset()));\n+    str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n@@ -191,1 +187,10 @@\n-    str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    \/\/ This assumes that all prototype bits fit in an int32_t\n+    mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n+    str(t1, Address(obj, oopDesc::mark_offset_in_bytes()));\n+\n+    if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+      encode_klass_not_null(t1, klass);\n+      strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    } else {\n+      str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+    }\n@@ -196,1 +201,1 @@\n-  } else if (UseCompressedClassPointers) {\n+  } else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n@@ -215,0 +220,6 @@\n+  \/\/ Zero first 4 bytes, if start offset is not word aligned.\n+  if (!is_aligned(hdr_size_in_bytes, BytesPerWord)) {\n+    strw(zr, Address(obj, hdr_size_in_bytes));\n+    hdr_size_in_bytes += BytesPerInt;\n+  }\n+\n@@ -274,1 +285,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n@@ -287,1 +298,1 @@\n-  mov(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  mov(arr_size, (int32_t)base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -296,1 +307,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, t1, t2);\n+  initialize_body(obj, arr_size, base_offset_in_bytes, t1, t2);\n@@ -316,1 +327,5 @@\n-  assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), \"must add explicit null check\");\n+  if (UseCompactObjectHeaders) {\n+    assert(!MacroAssembler::needs_explicit_null_check(oopDesc::mark_offset_in_bytes()), \"must add explicit null check\");\n+  } else {\n+    assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), \"must add explicit null check\");\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -291,1 +291,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -94,0 +94,11 @@\n+int C2LoadNKlassStub::max_size() const {\n+  return 8;\n+}\n+\n+void C2LoadNKlassStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+  Register d = dst();\n+  __ ldr(d, Address(d, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n+  __ b(continuation());\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -4314,0 +4314,24 @@\n+\/\/ Loads the obj's Klass* into dst.\n+\/\/ Preserves all registers (incl src, rscratch1 and rscratch2).\n+void MacroAssembler::load_nklass(Register dst, Register src) {\n+  assert(UseCompressedClassPointers, \"expects UseCompressedClassPointers\");\n+\n+  if (!UseCompactObjectHeaders) {\n+    ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    return;\n+  }\n+\n+  Label fast;\n+\n+  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+  ldr(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n+  tbz(dst, exact_log2(markWord::monitor_value), fast);\n+\n+  \/\/ Fetch displaced header\n+  ldr(dst, Address(dst, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n+\n+  \/\/ Fast-path: shift and decode Klass*.\n+  bind(fast);\n+  lsr(dst, dst, markWord::klass_shift);\n+}\n+\n@@ -4316,1 +4340,5 @@\n-    ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    if (UseCompactObjectHeaders) {\n+      load_nklass(dst, src);\n+    } else {\n+      ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    }\n@@ -4354,0 +4382,1 @@\n+  assert_different_registers(oop, trial_klass, tmp);\n@@ -4355,1 +4384,5 @@\n-    ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n+    if (UseCompactObjectHeaders) {\n+      load_nklass(tmp, oop);\n+    } else {\n+      ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -853,0 +853,1 @@\n+  void load_nklass(Register dst, Register src);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3610,1 +3610,1 @@\n-    __ sub(r3, r3, sizeof(oopDesc));\n+    __ sub(r3, r3, oopDesc::base_offset_in_bytes());\n@@ -3615,1 +3615,6 @@\n-      __ add(r2, r0, sizeof(oopDesc));\n+      __ add(r2, r0, oopDesc::base_offset_in_bytes());\n+      if (!is_aligned(oopDesc::base_offset_in_bytes(), BytesPerLong)) {\n+        __ strw(zr, Address(__ post(r2, BytesPerInt)));\n+        __ sub(r3, r3, BytesPerInt);\n+        __ cbz(r3, initialize_header);\n+      }\n@@ -3625,5 +3630,8 @@\n-    __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n-    __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n-    __ store_klass_gap(r0, zr);  \/\/ zero klass gap for compressed oops\n-    __ store_klass(r0, r4);      \/\/ store klass last\n-\n+    if (UseCompactObjectHeaders) {\n+      __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n+      __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+    } else {\n+      __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n+      __ str(rscratch1, Address(r0, oopDesc::mark_offset_in_bytes()));\n+      __ store_klass(r0, r4);      \/\/ store klass last\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -220,0 +220,4 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -974,1 +974,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-                                       int header_size, int element_size,\n+                                       int header_size_in_bytes, int element_size,\n@@ -169,1 +169,0 @@\n-  const int header_size_in_bytes = header_size * BytesPerWord;\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                      int header_size, int element_size,\n+                      int header_size_in_bytes, int element_size,\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -301,0 +301,4 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4639,9 +4639,0 @@\n-void MacroAssembler::test_bit(Register Rd, Register Rs, uint32_t bit_pos, Register tmp) {\n-  assert(bit_pos < 64, \"invalid bit range\");\n-  if (UseZbs) {\n-    bexti(Rd, Rs, bit_pos);\n-    return;\n-  }\n-  andi(Rd, Rs, 1UL << bit_pos, tmp);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1684,1 +1684,1 @@\n-      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, count, \/*fallthrough*\/nullptr);\n+      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, count, \/*fallthrough*\/NULL);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -256,0 +256,5 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -281,0 +282,11 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  assert(UseCompactObjectHeaders, \"only with compact headers\");\n+  __ bind(_entry);\n+#ifdef _LP64\n+  Register d = _result->as_register();\n+  __ movq(d, Address(d, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n+  __ jmp(_continuation);\n+#else\n+  __ should_not_reach_here();\n+#endif\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1638,1 +1638,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n@@ -3073,0 +3073,1 @@\n+  Register tmp2 = UseCompactObjectHeaders ? rscratch2 : noreg;\n@@ -3264,7 +3265,1 @@\n-      if (UseCompressedClassPointers) {\n-        __ movl(tmp, src_klass_addr);\n-        __ cmpl(tmp, dst_klass_addr);\n-      } else {\n-        __ movptr(tmp, src_klass_addr);\n-        __ cmpptr(tmp, dst_klass_addr);\n-      }\n+      __ cmp_klass(src, dst, tmp, tmp2);\n@@ -3430,1 +3425,0 @@\n-\n@@ -3432,3 +3426,1 @@\n-\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);\n-      else                   __ cmpptr(tmp, dst_klass_addr);\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3436,2 +3428,1 @@\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);\n-      else                   __ cmpptr(tmp, src_klass_addr);\n+      __ cmp_klass(tmp, src, tmp2);\n@@ -3440,2 +3431,1 @@\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);\n-      else                   __ cmpptr(tmp, dst_klass_addr);\n+      __ cmp_klass(tmp, dst, tmp2);\n@@ -3537,0 +3527,14 @@\n+  if (UseCompactObjectHeaders) {\n+    Register tmp = rscratch1;\n+    assert_different_registers(tmp, obj);\n+    assert_different_registers(tmp, result);\n+\n+    \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+    __ movq(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    __ testb(result, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, *op->stub()->entry());\n+    __ bind(*op->stub()->continuation());\n+    \/\/ Fast-path: shift and decode Klass*.\n+    __ shrq(result, markWord::klass_shift);\n+    __ decode_klass_not_null(result, tmp);\n+  } else\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -166,2 +166,6 @@\n-  assert_different_registers(obj, klass, len);\n-  movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n+  assert_different_registers(obj, klass, len, t1, t2);\n+  if (UseCompactObjectHeaders) {\n+    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n+  } else {\n+    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n@@ -169,5 +173,5 @@\n-  if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n-    movptr(t1, klass);\n-    encode_klass_not_null(t1, rscratch1);\n-    movl(Address(obj, oopDesc::klass_offset_in_bytes()), t1);\n-  } else\n+    if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n+      movptr(t1, klass);\n+      encode_klass_not_null(t1, rscratch1);\n+      movl(Address(obj, oopDesc::klass_offset_in_bytes()), t1);\n+    } else\n@@ -175,2 +179,3 @@\n-  {\n-    movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n+    {\n+      movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n+    }\n@@ -178,1 +183,0 @@\n-\n@@ -183,1 +187,1 @@\n-  else if (UseCompressedClassPointers) {\n+  else if (UseCompressedClassPointers && !UseCompactObjectHeaders) {\n@@ -225,0 +229,1 @@\n+    int hdr_size_aligned = align_up(hdr_size_in_bytes, BytesPerWord); \/\/ klass gap is already cleared by init_header().\n@@ -227,1 +232,1 @@\n-      initialize_body(obj, index, hdr_size_in_bytes, t1_zero);\n+      initialize_body(obj, index, hdr_size_aligned, t1_zero);\n@@ -232,1 +237,1 @@\n-      for (int i = hdr_size_in_bytes; i < con_size_in_bytes; i += BytesPerWord)\n+      for (int i = hdr_size_aligned; i < con_size_in_bytes; i += BytesPerWord)\n@@ -234,1 +239,1 @@\n-    } else if (con_size_in_bytes > hdr_size_in_bytes) {\n+    } else if (con_size_in_bytes > hdr_size_aligned) {\n@@ -239,1 +244,1 @@\n-      movptr(index, (con_size_in_bytes - hdr_size_in_bytes) >> 3);\n+      movptr(index, (con_size_in_bytes - hdr_size_aligned) >> 3);\n@@ -241,1 +246,1 @@\n-      if (((con_size_in_bytes - hdr_size_in_bytes) & 4) != 0)\n+      if (((con_size_in_bytes - hdr_size_aligned) & 4) != 0)\n@@ -246,1 +251,1 @@\n-        movptr(Address(obj, index, Address::times_8, hdr_size_in_bytes - (1*BytesPerWord)),\n+        movptr(Address(obj, index, Address::times_8, hdr_size_aligned - (1*BytesPerWord)),\n@@ -248,1 +253,1 @@\n-        NOT_LP64(movptr(Address(obj, index, Address::times_8, hdr_size_in_bytes - (2*BytesPerWord)),\n+        NOT_LP64(movptr(Address(obj, index, Address::times_8, hdr_size_aligned - (2*BytesPerWord)),\n@@ -264,1 +269,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case) {\n@@ -277,1 +282,1 @@\n-  movptr(arr_size, header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  movptr(arr_size, (int32_t)base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -287,1 +292,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  initialize_body(obj, arr_size, base_offset_in_bytes, len_zero);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -96,0 +96,11 @@\n+\n+int C2LoadNKlassStub::max_size() const {\n+  return 10;\n+}\n+\n+void C2LoadNKlassStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+  Register d = dst();\n+  __ movq(d, Address(d, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n+  __ jmp(continuation());\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -666,1 +666,1 @@\n-  cmpxchgptr(scrReg, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+  cmpxchgptr(thread, Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n@@ -668,7 +668,0 @@\n-  \/\/ If we weren't able to swing _owner from null to the BasicLock\n-  \/\/ then take the slow path.\n-  jccb  (Assembler::notZero, NO_COUNT);\n-  \/\/ update _owner from BasicLock to thread\n-  get_thread (scrReg);                    \/\/ beware: clobbers ICCs\n-  movptr(Address(boxReg, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), scrReg);\n-  xorptr(boxReg, boxReg);                 \/\/ set icc.ZFlag = 1 to indicate success\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4159,1 +4159,1 @@\n-  assert((offset_in_bytes & (BytesPerWord - 1)) == 0, \"offset must be a multiple of BytesPerWord\");\n+  assert((offset_in_bytes & (BytesPerInt - 1)) == 0, \"offset must be a multiple of BytesPerInt\");\n@@ -4165,0 +4165,13 @@\n+  \/\/ Emit single 32bit store to clear leading bytes, if necessary.\n+  xorptr(temp, temp);    \/\/ use _zero reg to clear memory (shorter code)\n+#ifdef _LP64\n+  if (!is_aligned(offset_in_bytes, BytesPerWord)) {\n+    movl(Address(address, offset_in_bytes), temp);\n+    offset_in_bytes += BytesPerInt;\n+    decrement(length_in_bytes, BytesPerInt);\n+  }\n+  assert((offset_in_bytes & (BytesPerWord - 1)) == 0, \"offset must be a multiple of BytesPerWord\");\n+  testptr(length_in_bytes, length_in_bytes);\n+  jcc(Assembler::zero, done);\n+#endif\n+\n@@ -4177,1 +4190,0 @@\n-  xorptr(temp, temp);    \/\/ use _zero reg to clear memory (shorter code)\n@@ -5228,0 +5240,22 @@\n+#ifdef _LP64\n+void MacroAssembler::load_nklass(Register dst, Register src) {\n+  assert(UseCompressedClassPointers, \"expect compressed class pointers\");\n+\n+  if (!UseCompactObjectHeaders) {\n+    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    return;\n+  }\n+\n+  Label fast;\n+  movq(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n+  testb(dst, markWord::monitor_value);\n+  jccb(Assembler::zero, fast);\n+\n+  \/\/ Fetch displaced header\n+  movq(dst, Address(dst, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n+\n+  bind(fast);\n+  shrq(dst, markWord::klass_shift);\n+}\n+#endif\n+\n@@ -5233,1 +5267,1 @@\n-    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+    load_nklass(dst, src);\n@@ -5241,0 +5275,1 @@\n+  assert(!UseCompactObjectHeaders, \"not with compact headers\");\n@@ -5249,1 +5284,40 @@\n-    movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n+   movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n+}\n+\n+void MacroAssembler::cmp_klass(Register klass, Register obj, Register tmp) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    \/\/ NOTE: We need to deal with possible ObjectMonitor in object header.\n+    \/\/ Eventually we might be able to do simple movl & cmpl like in\n+    \/\/ the CCP path below.\n+    load_nklass(tmp, obj);\n+    cmpl(klass, tmp);\n+  } else if (UseCompressedClassPointers) {\n+    cmpl(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  } else\n+#endif\n+  {\n+    cmpptr(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  }\n+}\n+\n+void MacroAssembler::cmp_klass(Register src, Register dst, Register tmp1, Register tmp2) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    \/\/ NOTE: We need to deal with possible ObjectMonitor in object header.\n+    \/\/ Eventually we might be able to do simple movl & cmpl like in\n+    \/\/ the CCP path below.\n+    assert(tmp2 != noreg, \"need tmp2\");\n+    assert_different_registers(src, dst, tmp1, tmp2);\n+    load_nklass(tmp1, src);\n+    load_nklass(tmp2, dst);\n+    cmpl(tmp1, tmp2);\n+  } else if (UseCompressedClassPointers) {\n+    movl(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n+    cmpl(tmp1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  } else\n+#endif\n+  {\n+    movptr(tmp1, Address(src, oopDesc::klass_offset_in_bytes()));\n+    cmpptr(tmp1, Address(dst, oopDesc::klass_offset_in_bytes()));\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":78,"deletions":4,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -366,0 +366,3 @@\n+#ifdef _LP64\n+  void load_nklass(Register dst, Register src);\n+#endif\n@@ -369,0 +372,8 @@\n+  \/\/ Compares the Klass pointer of an object to a given Klass (which might be narrow,\n+  \/\/ depending on UseCompressedClassPointers).\n+  void cmp_klass(Register klass, Register dst, Register tmp);\n+\n+  \/\/ Compares the Klass pointer of two objects o1 and o2. Result is in the condition flags.\n+  \/\/ Uses t1 and t2 as temporary registers.\n+  void cmp_klass(Register src, Register dst, Register tmp1, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -71,2 +71,7 @@\n-  __ shrptr(result, markWord::hash_shift);\n-  __ andptr(result, markWord::hash_mask);\n+  if (UseCompactObjectHeaders) {\n+    __ shrptr(result, markWord::hash_shift_compact);\n+    __ andptr(result, markWord::hash_mask_compact);\n+  } else {\n+    __ shrptr(result, markWord::hash_shift);\n+    __ andptr(result, markWord::hash_mask);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4059,1 +4059,2 @@\n-    __ decrement(rdx, sizeof(oopDesc));\n+    int header_size = align_up(oopDesc::base_offset_in_bytes(), BytesPerLong);\n+    __ decrement(rdx, header_size);\n@@ -4081,2 +4082,2 @@\n-    __ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 1*oopSize), rcx);\n-    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - 2*oopSize), rcx));\n+    __ movptr(Address(rax, rdx, Address::times_8, header_size - 1*oopSize), rcx);\n+    NOT_LP64(__ movptr(Address(rax, rdx, Address::times_8, header_size - 2*oopSize), rcx));\n@@ -4089,3 +4090,8 @@\n-    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n-              (intptr_t)markWord::prototype().value()); \/\/ header\n-    __ pop(rcx);   \/\/ get saved klass back in the register.\n+    if (UseCompactObjectHeaders) {\n+      __ pop(rcx);   \/\/ get saved klass back in the register.\n+      __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n+      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n+    } else {\n+      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n+                (intptr_t)markWord::prototype().value()); \/\/ header\n+      __ pop(rcx);   \/\/ get saved klass back in the register.\n@@ -4093,2 +4099,2 @@\n-    __ xorl(rsi, rsi); \/\/ use zero reg to clear memory (shorter code)\n-    __ store_klass_gap(rax, rsi);  \/\/ zero klass gap for compressed oops\n+      __ xorl(rsi, rsi); \/\/ use zero reg to clear memory (shorter code)\n+      __ store_klass_gap(rax, rsi);  \/\/ zero klass gap for compressed oops\n@@ -4096,1 +4102,2 @@\n-    __ store_klass(rax, rcx, rscratch1);  \/\/ klass\n+      __ store_klass(rax, rcx, rscratch1);  \/\/ klass\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -5317,0 +5317,1 @@\n+  predicate(!UseCompactObjectHeaders);\n@@ -5327,0 +5328,23 @@\n+instruct loadNKlassLilliput(rRegN dst, indOffset8 mem, rFlagsReg cr)\n+%{\n+  predicate(UseCompactObjectHeaders);\n+  match(Set dst (LoadNKlass mem));\n+  effect(KILL cr);\n+  ins_cost(125); \/\/ XXX\n+  format %{ \"movl    $dst, $mem\\t# compressed klass ptr\" %}\n+  ins_encode %{\n+    assert($mem$$disp == oopDesc::klass_offset_in_bytes(), \"expect correct offset 4, but got: %d\", $mem$$disp);\n+    assert($mem$$index == 4, \"expect no index register: %d\", $mem$$index);\n+    Register dst = $dst$$Register;\n+    Register obj = $mem$$base$$Register;\n+    C2LoadNKlassStub* stub = new (Compile::current()->comp_arena()) C2LoadNKlassStub(dst);\n+    Compile::current()->output()->add_stub(stub);\n+    __ movq(dst, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    __ testb(dst, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, stub->entry());\n+    __ bind(stub->continuation());\n+    __ shrq(dst, markWord::klass_shift);\n+  %}\n+  ins_pipe(pipe_slow); \/\/ XXX\n+%}\n+\n@@ -12697,0 +12721,1 @@\n+  predicate(!UseCompactObjectHeaders);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -584,0 +584,18 @@\n+class LoadKlassStub: public CodeStub {\n+private:\n+  LIR_Opr          _result;\n+\n+public:\n+  LoadKlassStub(LIR_Opr result) :\n+    CodeStub(), _result(result) {};\n+\n+  virtual void emit_code(LIR_Assembler* e);\n+  virtual void visit(LIR_OpVisitState* visitor) {\n+    visitor->do_temp(_result);\n+    visitor->do_output(_result);\n+  }\n+#ifndef PRODUCT\n+virtual void print_name(outputStream* out) const { out->print(\"LoadKlassStub\"); }\n+#endif \/\/ PRODUCT\n+};\n+\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -893,0 +893,1 @@\n+      if (opLoadKlass->_stub) do_stub(opLoadKlass->_stub);\n@@ -1073,0 +1074,3 @@\n+  if (stub()) {\n+    masm->append_code_stub(stub());\n+  }\n@@ -2049,0 +2053,3 @@\n+  if (stub()) {\n+    out->print(\"[lbl:\" INTPTR_FORMAT \"]\", p2i(stub()->entry()));\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1906,0 +1906,1 @@\n+  CodeStub* _stub;\n@@ -1907,1 +1908,1 @@\n-  LIR_OpLoadKlass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info)\n+  LIR_OpLoadKlass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info, CodeStub* stub)\n@@ -1910,1 +1911,1 @@\n-    {}\n+    , _stub(stub) {}\n@@ -1913,0 +1914,1 @@\n+  CodeStub* stub()     const { return _stub; }\n@@ -2378,1 +2380,1 @@\n-  void load_klass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info) { append(new LIR_OpLoadKlass(obj, result, info)); }\n+  void load_klass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info, CodeStub* stub) { append(new LIR_OpLoadKlass(obj, result, info, stub)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1246,1 +1246,2 @@\n-  __ load_klass(obj, klass, null_check_info);\n+  CodeStub* slow_path = UseCompactObjectHeaders ? new LoadKlassStub(klass) : nullptr;\n+  __ load_klass(obj, klass, null_check_info, slow_path);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -203,2 +203,7 @@\n-    oopDesc::set_mark(mem, markWord::prototype());\n-    oopDesc::release_set_klass(mem, k);\n+    if (UseCompactObjectHeaders) {\n+      narrowKlass nk = ArchiveBuilder::current()->get_requested_narrow_klass(k);\n+      oopDesc::release_set_mark(mem, markWord::prototype().set_narrow_klass(nk));\n+    } else {\n+      oopDesc::set_mark(mem, markWord::prototype());\n+      oopDesc::release_set_klass(mem, k);\n+    }\n@@ -270,1 +275,0 @@\n-  oopDesc::set_mark(mem, markWord::prototype());\n@@ -272,1 +276,6 @@\n-  cast_to_oop(mem)->set_narrow_klass(nk);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, markWord::prototype().set_narrow_klass(nk));\n+  } else {\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    cast_to_oop(mem)->set_narrow_klass(nk);\n+  }\n@@ -460,1 +469,5 @@\n-    fake_oop->set_mark(markWord::prototype().copy_set_hash(src_hash));\n+    if (UseCompactObjectHeaders) {\n+      fake_oop->set_mark(markWord::prototype().set_narrow_klass(nk).copy_set_hash(src_hash));\n+    } else {\n+      fake_oop->set_mark(markWord::prototype().copy_set_hash(src_hash));\n+    }\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -206,0 +206,1 @@\n+  _compact_headers = UseCompactObjectHeaders;\n@@ -272,0 +273,1 @@\n+  st->print_cr(\"- compact_headers:                %d\", _compact_headers);\n@@ -2397,0 +2399,8 @@\n+  if (compact_headers() != UseCompactObjectHeaders) {\n+    log_info(cds)(\"The shared archive file's UseCompactObjectHeaders setting (%s)\"\n+                  \" does not equal the current UseCompactObjectHeaders setting (%s).\",\n+                  _compact_headers          ? \"enabled\" : \"disabled\",\n+                  UseCompactObjectHeaders   ? \"enabled\" : \"disabled\");\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+  bool   _compact_headers;                        \/\/ value of UseCompactObjectHeaders\n@@ -262,0 +263,1 @@\n+  bool compact_headers()                   const { return _compact_headers; }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/safepoint.hpp\"\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -252,0 +252,20 @@\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciKlass::prototype_header_offset\n+juint ciKlass::prototype_header_offset() {\n+  assert(is_loaded(), \"must be loaded\");\n+\n+  VM_ENTRY_MARK;\n+  Klass* this_klass = get_Klass();\n+  return in_bytes(this_klass->prototype_header_offset());\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciKlass::prototype_header\n+uintptr_t ciKlass::prototype_header() {\n+  assert(is_loaded(), \"must be loaded\");\n+\n+  VM_ENTRY_MARK;\n+  Klass* this_klass = get_Klass();\n+  return (uintptr_t)this_klass->prototype_header().to_pointer();\n+}\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+\n+  juint prototype_header_offset();\n+  uintptr_t prototype_header();\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -105,2 +105,2 @@\n-  static const int first_vtableStub_size =  64;\n-  static const int first_itableStub_size = 256;\n+  static const int first_vtableStub_size = 256;\n+  static const int first_itableStub_size = 512;\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -1520,0 +1521,2 @@\n+  GCForwarding::initialize(heap_rs.region(), HeapRegion::GrainWords);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -213,0 +214,1 @@\n+  GCForwarding::begin();\n@@ -225,0 +227,2 @@\n+  GCForwarding::end();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -44,1 +45,1 @@\n-  if (obj->is_forwarded()) {\n+  if (GCForwarding::is_forwarded(obj)) {\n@@ -55,2 +56,2 @@\n-  assert(obj->is_forwarded(), \"Sanity!\");\n-  assert(obj->forwardee() != obj, \"Object must have a new location\");\n+  assert(GCForwarding::is_forwarded(obj), \"Sanity!\");\n+  assert(GCForwarding::forwardee(obj) != obj, \"Object must have a new location\");\n@@ -61,1 +62,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  HeapWord* destination = cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj));\n@@ -123,1 +124,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  HeapWord* destination = cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -105,2 +106,2 @@\n-    object->forward_to(cast_to_oop(_compaction_top));\n-    assert(object->is_forwarded(), \"must be forwarded\");\n+    GCForwarding::forward_to(object, cast_to_oop(_compaction_top));\n+    assert(GCForwarding::is_forwarded(object), \"must be forwarded\");\n@@ -108,1 +109,1 @@\n-    assert(!object->is_forwarded(), \"must not be forwarded\");\n+    assert(GCForwarding::is_not_forwarded(object), \"must not be forwarded\");\n@@ -171,2 +172,2 @@\n-  obj->forward_to(cast_to_oop(dest_hr->bottom()));\n-  assert(obj->is_forwarded(), \"Object must be forwarded!\");\n+  GCForwarding::forward_to(obj, cast_to_oop(dest_hr->bottom()));\n+  assert(GCForwarding::is_forwarded(obj), \"Object must be forwarded!\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -68,2 +69,2 @@\n-  if (obj->is_forwarded()) {\n-    oop forwardee = obj->forwardee();\n+  if (GCForwarding::is_forwarded(obj)) {\n+    oop forwardee = GCForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  if (obj->is_forwarded()) {\n+  if (GCForwarding::is_forwarded(obj)) {\n@@ -108,1 +108,1 @@\n-    if (cast_from_oop<HeapWord*>(obj->forwardee()) < _dense_prefix_top) {\n+    if (cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj)) < _dense_prefix_top) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-      forwardee = cast_to_oop(m.decode_pointer());\n+      forwardee = obj->forwardee(m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-    obj = cast_to_oop(m.decode_pointer());\n+    obj = obj->forwardee(m);\n@@ -229,1 +229,0 @@\n-  assert(from_obj->is_objArray(), \"must be obj array\");\n@@ -259,1 +258,0 @@\n-  assert(from_obj->is_objArray(), \"precondition\");\n@@ -386,1 +384,1 @@\n-                                                  oop const old, size_t word_sz, uint age,\n+                                                  oop const old, Klass* klass, size_t word_sz, uint age,\n@@ -390,1 +388,1 @@\n-    _g1h->gc_tracer_stw()->report_promotion_in_new_plab_event(old->klass(), word_sz * HeapWordSize, age,\n+    _g1h->gc_tracer_stw()->report_promotion_in_new_plab_event(klass, word_sz * HeapWordSize, age,\n@@ -394,1 +392,1 @@\n-    _g1h->gc_tracer_stw()->report_promotion_outside_plab_event(old->klass(), word_sz * HeapWordSize, age,\n+    _g1h->gc_tracer_stw()->report_promotion_outside_plab_event(klass, word_sz * HeapWordSize, age,\n@@ -402,0 +400,1 @@\n+                                                   Klass* klass,\n@@ -424,1 +423,1 @@\n-      report_promotion_event(*dest_attr, old, word_sz, age, obj_ptr, node_index);\n+      report_promotion_event(*dest_attr, old, klass, word_sz, age, obj_ptr, node_index);\n@@ -459,0 +458,4 @@\n+  if (old_mark.is_marked()) {\n+    \/\/ Already forwarded by somebody else, return forwardee.\n+    return old->forwardee(old_mark);\n+  }\n@@ -461,1 +464,9 @@\n-  Klass* klass = old->klass();\n+  Klass* klass;\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    klass = old_mark.safe_klass();\n+  } else\n+#endif\n+  {\n+    klass = old->klass();\n+  }\n@@ -474,1 +485,1 @@\n-    obj_ptr = allocate_copy_slow(&dest_attr, old, word_sz, age, node_index);\n+    obj_ptr = allocate_copy_slow(&dest_attr, old, klass, word_sz, age, node_index);\n@@ -630,1 +641,1 @@\n-  oop forward_ptr = old->forward_to_atomic(old, m, memory_order_relaxed);\n+  oop forward_ptr = old->forward_to_self_atomic(m, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+                               Klass* klass,\n@@ -211,1 +212,1 @@\n-                              oop const old, size_t word_sz, uint age,\n+                              oop const old, Klass* klass, size_t word_sz, uint age,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-    HeapWord* test_addr = cast_from_oop<HeapWord*>(obj) + 1;\n+    HeapWord* test_addr = cast_from_oop<HeapWord*>(obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,1 +298,0 @@\n-  assert(old->is_objArray(), \"invariant\");\n@@ -336,1 +335,1 @@\n-  if (obj->forward_to_atomic(obj, obj_mark) == nullptr) {\n+  if (obj->forward_to_self_atomic(obj_mark) == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  inline void promotion_trace_event(oop new_obj, oop old_obj, size_t obj_size,\n+  inline void promotion_trace_event(oop new_obj, oop old_obj, Klass* klass, size_t obj_size,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-inline void PSPromotionManager::promotion_trace_event(oop new_obj, oop old_obj,\n+inline void PSPromotionManager::promotion_trace_event(oop new_obj, oop old_obj, Klass* klass,\n@@ -79,1 +79,1 @@\n-        gc_tracer->report_promotion_in_new_plab_event(old_obj->klass(), obj_bytes,\n+        gc_tracer->report_promotion_in_new_plab_event(klass, obj_bytes,\n@@ -86,1 +86,1 @@\n-        gc_tracer->report_promotion_outside_plab_event(old_obj->klass(), obj_bytes,\n+        gc_tracer->report_promotion_outside_plab_event(klass, obj_bytes,\n@@ -150,1 +150,1 @@\n-    return cast_to_oop(m.decode_pointer());\n+    return o->forwardee(m);\n@@ -166,1 +166,10 @@\n-  size_t new_obj_size = o->size();\n+  Klass* klass;\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    klass = test_mark.safe_klass();\n+  } else\n+#endif\n+  {\n+    klass = o->klass();\n+  }\n+  size_t new_obj_size = o->size_given_klass(klass);\n@@ -181,1 +190,1 @@\n-          promotion_trace_event(new_obj, o, new_obj_size, age, false, nullptr);\n+          promotion_trace_event(new_obj, o, klass, new_obj_size, age, false, nullptr);\n@@ -191,1 +200,1 @@\n-            promotion_trace_event(new_obj, o, new_obj_size, age, false, &_young_lab);\n+            promotion_trace_event(new_obj, o, klass, new_obj_size, age, false, &_young_lab);\n@@ -217,1 +226,1 @@\n-          promotion_trace_event(new_obj, o, new_obj_size, age, true, nullptr);\n+          promotion_trace_event(new_obj, o, klass, new_obj_size, age, true, nullptr);\n@@ -227,1 +236,1 @@\n-            promotion_trace_event(new_obj, o, new_obj_size, age, true, &_old_lab);\n+            promotion_trace_event(new_obj, o, klass, new_obj_size, age, true, &_old_lab);\n@@ -250,3 +259,5 @@\n-  \/\/ Parallel GC claims with a release - so other threads might access this object\n-  \/\/ after claiming and they should see the \"completed\" object.\n-  ContinuationGCSupport::transform_stack_chunk(new_obj);\n+  if (!new_obj->mark().is_marked()) {\n+    \/\/ Parallel GC claims with a release - so other threads might access this object\n+    \/\/ after claiming and they should see the \"completed\" object.\n+    ContinuationGCSupport::transform_stack_chunk(new_obj);\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -846,1 +846,10 @@\n-    from()->set_next_compaction_space(to());\n+    \/\/ Ensure that compaction spaces are in address-order.\n+    if (from()->bottom() < to()->bottom()) {\n+      eden()->set_next_compaction_space(from());\n+      from()->set_next_compaction_space(to());\n+      to()->set_next_compaction_space(nullptr);\n+    } else {\n+      eden()->set_next_compaction_space(to());\n+      to()->set_next_compaction_space(from());\n+      from()->set_next_compaction_space(nullptr);\n+    }\n@@ -881,1 +890,15 @@\n-        obj->init_mark();\n+#ifdef _LP64\n+        if (UseCompactObjectHeaders) {\n+          oop forwardee = obj->forwardee();\n+          markWord header = forwardee->mark();\n+          if (header.has_displaced_mark_helper()) {\n+            header = header.displaced_mark_helper();\n+          }\n+          assert(UseCompressedClassPointers, \"assume +UseCompressedClassPointers\");\n+          narrowKlass nklass = header.narrow_klass();\n+          obj->set_mark(markWord::prototype().set_narrow_klass(nklass));\n+        } else\n+#endif\n+        {\n+          obj->init_mark();\n+        }\n@@ -905,1 +928,1 @@\n-  old->forward_to(old);\n+  old->forward_to_self();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -92,0 +93,2 @@\n+  GCForwarding::begin();\n+\n@@ -104,0 +107,2 @@\n+  GCForwarding::end();\n+\n@@ -165,0 +170,3 @@\n+  _young_marked_objects = 0;\n+  _old_marked_objects = 0;\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -167,0 +168,2 @@\n+  ContinuationGCSupport::transform_stack_chunk(obj);\n+\n@@ -170,3 +173,13 @@\n-  obj->set_mark(markWord::prototype().set_marked());\n-\n-  ContinuationGCSupport::transform_stack_chunk(obj);\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    markWord real_mark = mark;\n+    if (real_mark.has_displaced_mark_helper()) {\n+      real_mark = real_mark.displaced_mark_helper();\n+    }\n+    Klass* klass = real_mark.klass();\n+    obj->set_mark(klass->prototype_header().set_marked());\n+  } else\n+#endif\n+  {\n+    obj->set_mark(markWord::prototype().set_marked());\n+  }\n@@ -177,0 +190,6 @@\n+\n+  if (GenCollectedHeap::heap()->is_in_young(obj)) {\n+    _young_marked_objects++;\n+  } else {\n+    _old_marked_objects++;\n+  }\n@@ -225,0 +244,3 @@\n+size_t MarkSweep::_young_marked_objects = 0;\n+size_t MarkSweep::_old_marked_objects = 0;\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -119,1 +119,4 @@\n- public:\n+  static size_t _young_marked_objects;\n+  static size_t _old_marked_objects;\n+\n+public:\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -48,2 +49,2 @@\n-    if (obj->is_forwarded()) {\n-      oop new_obj = obj->forwardee();\n+    if (GCForwarding::is_forwarded(obj)) {\n+      oop new_obj = GCForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  if (!Metaspace::contains(object->klass_raw())) {\n+  if (!UseCompactObjectHeaders && !Metaspace::contains(object->klass_raw())) {\n@@ -261,2 +261,4 @@\n-  _filler_array_max_size = align_object_size(filler_array_hdr_size() +\n-                                             max_len \/ elements_per_word);\n+  int header_size_in_bytes = arrayOopDesc::base_offset_in_bytes(T_INT);\n+  assert(header_size_in_bytes % sizeof(jint) == 0, \"must be aligned to int\");\n+  int header_size_in_ints = header_size_in_bytes \/ sizeof(jint);\n+  _filler_array_max_size = align_object_size((header_size_in_ints + max_len) \/ elements_per_word);\n@@ -412,1 +414,3 @@\n-  size_t max_int_size = typeArrayOopDesc::header_size(T_INT) +\n+  int header_size_in_bytes = typeArrayOopDesc::base_offset_in_bytes(T_INT);\n+  assert(header_size_in_bytes % sizeof(jint) == 0, \"header size must align to int\");\n+  size_t max_int_size = header_size_in_bytes \/ HeapWordSize +\n@@ -418,4 +422,0 @@\n-size_t CollectedHeap::filler_array_hdr_size() {\n-  return align_object_offset(arrayOopDesc::header_size(T_INT)); \/\/ align to Long\n-}\n-\n@@ -423,1 +423,2 @@\n-  return align_object_size(filler_array_hdr_size()); \/\/ align to MinObjAlignment\n+  int aligned_header_size_words = align_up(arrayOopDesc::base_offset_in_bytes(T_INT), HeapWordSize) \/ HeapWordSize;\n+  return align_object_size(aligned_header_size_words); \/\/ align to MinObjAlignment\n@@ -427,2 +428,3 @@\n-  Copy::fill_to_words(start + filler_array_hdr_size(),\n-                      words - filler_array_hdr_size(), value);\n+  int payload_start = align_up(arrayOopDesc::base_offset_in_bytes(T_INT), HeapWordSize) \/ HeapWordSize;\n+  Copy::fill_to_words(start + payload_start,\n+                      words - payload_start, value);\n@@ -452,2 +454,3 @@\n-  const size_t payload_size = words - filler_array_hdr_size();\n-  const size_t len = payload_size * HeapWordSize \/ sizeof(jint);\n+  const size_t payload_size_bytes = words * HeapWordSize - arrayOopDesc::base_offset_in_bytes(T_INT);\n+  assert(payload_size_bytes % sizeof(jint) == 0, \"must be int aligned\");\n+  const size_t len = payload_size_bytes \/ sizeof(jint);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-  static inline size_t filler_array_hdr_size();\n@@ -311,1 +310,1 @@\n-  static constexpr size_t min_dummy_object_size() {\n+  static size_t min_dummy_object_size() {\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+SlidingForwarding* GCForwarding::_sliding_forwarding = nullptr;\n+\n+void GCForwarding::initialize(MemRegion heap, size_t region_size_words) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding == nullptr, \"only call this once\");\n+    _sliding_forwarding = new SlidingForwarding(heap, region_size_words);\n+  }\n+#endif\n+}\n+\n+void GCForwarding::begin() {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    _sliding_forwarding->begin();\n+  }\n+#endif\n+}\n+\n+void GCForwarding::end() {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    _sliding_forwarding->end();\n+  }\n+#endif\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.cpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCFORWARDING_HPP\n+#define SHARE_GC_SHARED_GCFORWARDING_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class SlidingForwarding;\n+\n+class GCForwarding : public AllStatic {\n+private:\n+  static SlidingForwarding* _sliding_forwarding;\n+\n+public:\n+  static void initialize(MemRegion heap, size_t region_size_words_shift);\n+  static void begin();\n+  static void end();\n+\n+  static inline bool is_forwarded(oop obj);\n+  static inline bool is_not_forwarded(oop obj);\n+  static inline oop forwardee(oop obj);\n+  static inline void forward_to(oop obj, oop fwd);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_GCFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n+\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+inline bool GCForwarding::is_forwarded(oop obj) {\n+  return obj->is_forwarded();\n+}\n+\n+inline bool GCForwarding::is_not_forwarded(oop obj) {\n+  return !obj->is_forwarded();\n+}\n+\n+inline oop GCForwarding::forwardee(oop obj) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    return _sliding_forwarding->forwardee(obj);\n+  } else\n+#endif\n+    return obj->forwardee();\n+}\n+\n+inline void GCForwarding::forward_to(oop obj, oop fwd) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(_sliding_forwarding != nullptr, \"expect sliding forwarding initialized\");\n+    _sliding_forwarding->forward_to(obj, fwd);\n+    assert(forwardee(obj) == fwd, \"must be forwarded to correct forwardee\");\n+  } else\n+#endif\n+    obj->forward_to(fwd);\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.inline.hpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -134,0 +135,2 @@\n+  GCForwarding::initialize(_reserved, SpaceAlignment);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -63,0 +63,11 @@\n+size_t MarkBitMap::count_marked(MemRegion mr) {\n+  MemRegion intersection = mr.intersection(_covered);\n+  assert(!intersection.is_empty(),\n+         \"Given range from \" PTR_FORMAT \" to \" PTR_FORMAT \" is completely outside the heap\",\n+         p2i(mr.start()), p2i(mr.end()));\n+  \/\/ convert address range into offset range\n+  size_t beg = addr_to_offset(intersection.start());\n+  size_t end = addr_to_offset(intersection.end());\n+  return _bm.count_one_bits(beg, end);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+\n+  size_t count_marked(MemRegion mr);\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -384,1 +384,3 @@\n-  oopDesc::set_klass_gap(mem, 0);\n+  if (!UseCompactObjectHeaders) {\n+    oopDesc::set_klass_gap(mem, 0);\n+  }\n@@ -390,2 +392,0 @@\n-  \/\/ May be bootstrapping\n-  oopDesc::set_mark(mem, markWord::prototype());\n@@ -395,1 +395,6 @@\n-  oopDesc::release_set_klass(mem, _klass);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  } else {\n+    oopDesc::set_mark(mem, markWord::prototype());\n+    oopDesc::release_set_klass(mem, _klass);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -45,2 +46,2 @@\n-  if (obj->is_forwarded()) {\n-    elem->set_oop(obj->forwardee());\n+  if (GCForwarding::is_forwarded(obj)) {\n+    elem->set_oop(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+\n+#ifdef _LP64\n+\n+HeapWord* const SlidingForwarding::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n+\n+SlidingForwarding::SlidingForwarding(MemRegion heap, size_t region_size_words)\n+  : _heap_start(heap.start()),\n+    _num_regions(((heap.end() - heap.start()) \/ region_size_words) + 1),\n+    _region_size_words_shift(log2i_exact(region_size_words)),\n+  _target_base_table(nullptr),\n+  _fallback_table(nullptr) {\n+  assert(_region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n+  size_t heap_size_words = heap.end() - heap.start();\n+  if (UseSerialGC && heap_size_words <= (1 << NUM_COMPRESSED_BITS)) {\n+    \/\/ In this case we can treat the whole heap as a single region and\n+    \/\/ make the encoding very simple.\n+    _num_regions = 1;\n+    _region_size_words_shift = log2i_exact(round_up_power_of_2(heap_size_words));\n+  }\n+}\n+\n+SlidingForwarding::~SlidingForwarding() {\n+  if (_target_base_table != nullptr) {\n+    FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n+  }\n+  if (_fallback_table != nullptr) {\n+    delete _fallback_table;\n+  }\n+}\n+\n+void SlidingForwarding::begin() {\n+  assert(_target_base_table == nullptr, \"Should be uninitialized\");\n+  _target_base_table = NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * NUM_TARGET_REGIONS, mtGC);\n+  size_t max = _num_regions * NUM_TARGET_REGIONS;\n+  for (size_t i = 0; i < max; i++) {\n+    _target_base_table[i] = UNUSED_BASE;\n+  }\n+}\n+\n+void SlidingForwarding::end() {\n+  assert(_target_base_table != nullptr, \"Should be initialized\");\n+  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n+  _target_base_table = nullptr;\n+\n+  if (_fallback_table != nullptr) {\n+    delete _fallback_table;\n+    _fallback_table = nullptr;\n+  }\n+}\n+\n+void SlidingForwarding::fallback_forward_to(HeapWord* from, HeapWord* to) {\n+  if (_fallback_table == nullptr) {\n+    _fallback_table = new FallbackTable();\n+  }\n+  _fallback_table->forward_to(from, to);\n+}\n+\n+HeapWord* SlidingForwarding::fallback_forwardee(HeapWord* from) const {\n+  if (_fallback_table == nullptr) {\n+    return nullptr;\n+  } else {\n+    return _fallback_table->forwardee(from);\n+  }\n+}\n+\n+FallbackTable::FallbackTable() {\n+  for (size_t i = 0; i < TABLE_SIZE; i++) {\n+    _table[i]._next = nullptr;\n+    _table[i]._from = nullptr;\n+    _table[i]._to   = nullptr;\n+  }\n+}\n+\n+FallbackTable::~FallbackTable() {\n+  for (size_t i = 0; i < TABLE_SIZE; i++) {\n+    FallbackTableEntry* entry = _table[i]._next;\n+    while (entry != nullptr) {\n+      FallbackTableEntry* next = entry->_next;\n+      FREE_C_HEAP_OBJ(entry);\n+      entry = next;\n+    }\n+  }\n+}\n+\n+size_t FallbackTable::home_index(HeapWord* from) {\n+  uint64_t val = reinterpret_cast<uint64_t>(from);\n+  val *= 0xbf58476d1ce4e5b9ull;\n+  val ^= val >> 56;\n+  val *= 0x94d049bb133111ebull;\n+  val = (val * 11400714819323198485llu) >> (64 - log2i_exact(TABLE_SIZE));\n+  assert(val < TABLE_SIZE, \"must fit in table: val: \" UINT64_FORMAT \", table-size: \" UINTX_FORMAT \", table-size-bits: %d\", val, TABLE_SIZE, log2i_exact(TABLE_SIZE));\n+  return static_cast<size_t>(val);\n+}\n+\n+void FallbackTable::forward_to(HeapWord* from, HeapWord* to) {\n+  size_t idx = home_index(from);\n+  if (_table[idx]._from != nullptr) {\n+    FallbackTableEntry* entry = NEW_C_HEAP_OBJ(FallbackTableEntry, mtGC);\n+    entry->_next = _table[idx]._next;\n+    entry->_from = _table[idx]._from;\n+    entry->_to = _table[idx]._to;\n+    _table[idx]._next = entry;\n+  }\n+  _table[idx]._from = from;\n+  _table[idx]._to   = to;\n+}\n+\n+HeapWord* FallbackTable::forwardee(HeapWord* from) const {\n+  size_t idx = home_index(from);\n+  const FallbackTableEntry* entry = &_table[idx];\n+  while (entry != nullptr) {\n+    if (entry->_from == from) {\n+      return entry->_to;\n+    }\n+    entry = entry->_next;\n+  }\n+  return nullptr;\n+}\n+\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+\n+#ifdef _LP64\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class FallbackTable;\n+\n+\/**\n+ * SlidingForwarding is a method to store forwarding information in a compressed form into the object header,\n+ * that has been specifically designed for sliding compaction GCs.\n+ * It avoids overriding the compressed class pointer in the upper bits of the header, which would otherwise\n+ * be lost. SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n+ *\n+ * The idea is to use a pointer compression scheme very similar to the one that is used for compressed oops.\n+ * We divide the heap into number of logical regions. Each region spans maximum of 2^NUM_COMPRESSED_BITS words.\n+ * We take advantage of the fact that sliding compaction can forward objects from one region to a maximum of\n+ * two regions (including itself, but that does not really matter). We need 1 bit to indicate which region is forwarded\n+ * into. We also currently require the two lowest header bits to indicate that the object is forwarded. In addition to that,\n+ * we use 1 more bit to indicate that we should use a fallback-lookup-table instead of using the sliding encoding.\n+ *\n+ * For addressing, we need a table with N*2 entries, for N logical regions. For each region, it gives the base\n+ * address of the two target regions, or a special placeholder if not used.\n+ *\n+ * Adding a forwarding then works as follows:\n+ * Given an original address 'orig', and a 'target' address:\n+ * - Look-up first target base of region of orig. If it is already established and the region\n+ *   that 'target' is in, then use it in step 3. If not yet used, establish it to be the base of region of target\n+     address. Use that base in step 3.\n+ * - Else, if first target base is already used, check second target base. This must either be unused, or the\n+ *   base of the region of our target address. If unused, establish it to be the base of the region of our target\n+ *   address. Use that base for next step.\n+ * - Now we found a base address. Encode the target address with that base into lowest NUM_COMPRESSED_BITS bits, and shift\n+ *   that up by 4 bits. Set the 3rd bit if we used the secondary target base, otherwise leave it at 0. Set the\n+ *   lowest two bits to indicate that the object has been forwarded. Store that in the lowest 32 bits of the\n+ *   original object's header.\n+ *\n+ * Similarily, looking up the target address, given an original object address works as follows:\n+ * - Load lowest 32 from original object header. Extract target region bit and compressed address bits.\n+ * - Depending on target region bit, load base address from the target base table by looking up the corresponding entry\n+ *   for the region of the original object.\n+ * - Decode the target address by using the target base address and the compressed address bits.\n+ *\n+ * One complication is that G1 serial compaction breaks the assumption that we only forward\n+ * to two target regions. When that happens, we initialize a fallback-hashtable for storing those extra\n+ * forwardings, and set the 4th bit in the header to indicate that the forwardee is not encoded but\n+ * should be looked-up in the hashtable. G1 serial compaction is not very common -  it is the last-last-ditch\n+ * GC that is used when the JVM is scrambling to squeeze more space out of the heap, and at that\n+ * point, ultimate performance is no longer the main concern.\n+ *\/\n+class SlidingForwarding : public CHeapObj<mtGC> {\n+private:\n+  static const uintptr_t MARK_LOWER_HALF_MASK = 0xffffffff;\n+\n+  \/\/ We need the lowest two bits to indicate a forwarded object.\n+  \/\/ The 3rd bit (fallback-bit) indicates that the forwardee should be\n+  \/\/ looked-up in a fallback-table.\n+  static const int FALLBACK_SHIFT = markWord::lock_bits;\n+  static const int FALLBACK_BITS = 1;\n+  static const int FALLBACK_MASK = right_n_bits(FALLBACK_BITS) << FALLBACK_SHIFT;\n+  \/\/ The 4th bit selects the target region.\n+  static const int REGION_SHIFT = FALLBACK_SHIFT + FALLBACK_BITS;\n+  static const int REGION_BITS = 1;\n+\n+  \/\/ The compressed address bits start here.\n+  static const int COMPRESSED_BITS_SHIFT = REGION_SHIFT + REGION_BITS;\n+\n+  \/\/ How many bits we use for the compressed pointer\n+  static const int NUM_COMPRESSED_BITS = 32 - COMPRESSED_BITS_SHIFT;\n+\n+  static const size_t NUM_TARGET_REGIONS = 1 << REGION_BITS;\n+\n+  \/\/ Indicates an usused base address in the target base table. We cannot use 0, because that may already be\n+  \/\/ a valid base address in zero-based heaps. 0x1 is safe because heap base addresses must be aligned by 2^X.\n+  static HeapWord* const UNUSED_BASE;\n+\n+  HeapWord*  const _heap_start;\n+  size_t           _num_regions;\n+  size_t           _region_size_words_shift;\n+  HeapWord**       _target_base_table;\n+\n+  FallbackTable* _fallback_table;\n+\n+  inline size_t region_index_containing(HeapWord* addr) const;\n+  inline bool region_contains(HeapWord* region_base, HeapWord* addr) const;\n+\n+  inline uintptr_t encode_forwarding(HeapWord* original, HeapWord* target);\n+  inline HeapWord* decode_forwarding(HeapWord* original, uintptr_t encoded) const;\n+\n+  void fallback_forward_to(HeapWord* from, HeapWord* to);\n+  HeapWord* fallback_forwardee(HeapWord* from) const;\n+\n+public:\n+  SlidingForwarding(MemRegion heap, size_t region_size_words);\n+  ~SlidingForwarding();\n+\n+  void begin();\n+  void end();\n+\n+  inline void forward_to(oop original, oop target);\n+  inline oop forwardee(oop original) const;\n+};\n+\n+\/*\n+ * A simple hash-table that acts as fallback for the sliding forwarding.\n+ * This is used in the case of G1 serial compactio, which violates the\n+ * assumption of sliding forwarding that each object of any region is only\n+ * ever forwarded to one of two target regions. At this point, the GC is\n+ * scrambling to free up more Java heap memory, and therefore performance\n+ * is not the major concern.\n+ *\n+ * The implementation is a straightforward open hashtable.\n+ * It is a single-threaded (not thread-safe) implementation, and that\n+ * is sufficient because G1 serial compaction is single-threaded.\n+ *\/\n+class FallbackTable : public CHeapObj<mtGC>{\n+private:\n+  struct FallbackTableEntry {\n+    FallbackTableEntry* _next;\n+    HeapWord* _from;\n+    HeapWord* _to;\n+  };\n+\n+  static const size_t TABLE_SIZE = 128;\n+  FallbackTableEntry _table[TABLE_SIZE];\n+\n+  static size_t home_index(HeapWord* from);\n+\n+public:\n+  FallbackTable();\n+  ~FallbackTable();\n+\n+  void forward_to(HeapWord* from, HeapWord* to);\n+  HeapWord* forwardee(HeapWord* from) const;\n+};\n+\n+#endif \/\/ _LP64\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+\n+#ifdef _LP64\n+\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+size_t SlidingForwarding::region_index_containing(HeapWord* addr) const {\n+  assert(addr >= _heap_start, \"sanity: addr: \" PTR_FORMAT \" heap base: \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n+  size_t index = ((size_t) (addr - _heap_start)) >> _region_size_words_shift;\n+  assert(index < _num_regions, \"Region index is in bounds: \" PTR_FORMAT, p2i(addr));\n+  return index;\n+}\n+\n+bool SlidingForwarding::region_contains(HeapWord* region_base, HeapWord* addr) const {\n+  return uintptr_t(addr - region_base) < (1ull << _region_size_words_shift);\n+}\n+\n+\n+uintptr_t SlidingForwarding::encode_forwarding(HeapWord* original, HeapWord* target) {\n+  size_t orig_idx = region_index_containing(original);\n+  size_t base_table_idx = orig_idx * 2;\n+  size_t target_idx = region_index_containing(target);\n+  HeapWord* encode_base;\n+  uintptr_t region_idx;\n+  for (region_idx = 0; region_idx < NUM_TARGET_REGIONS; region_idx++) {\n+    encode_base = _target_base_table[base_table_idx + region_idx];\n+    if (encode_base == UNUSED_BASE) {\n+      encode_base = _heap_start + target_idx * (1ull << _region_size_words_shift);\n+      _target_base_table[base_table_idx + region_idx] = encode_base;\n+      break;\n+    } else if (region_contains(encode_base, target)) {\n+      break;\n+    }\n+  }\n+  if (region_idx >= NUM_TARGET_REGIONS) {\n+    assert(G1GC_ONLY(UseG1GC) NOT_G1GC(false), \"Only happens with G1 serial compaction\");\n+    return 1 << FALLBACK_SHIFT | markWord::marked_value;\n+  }\n+  assert(region_idx < NUM_TARGET_REGIONS, \"need to have found an encoding base\");\n+  assert(target >= encode_base, \"target must be above encode base, target:\" PTR_FORMAT \", encoded_base: \" PTR_FORMAT \",  target_idx: \" SIZE_FORMAT \", heap start: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT,\n+         p2i(target), p2i(encode_base), target_idx, p2i(_heap_start), region_idx);\n+  assert(region_contains(encode_base, target), \"region must contain target: original: \" PTR_FORMAT \", target: \" PTR_FORMAT \", encode_base: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT, p2i(original), p2i(target), p2i(encode_base), region_idx);\n+  uintptr_t encoded = (((uintptr_t)(target - encode_base)) << COMPRESSED_BITS_SHIFT) |\n+                      (region_idx << REGION_SHIFT) | markWord::marked_value;\n+  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n+  return encoded;\n+}\n+\n+HeapWord* SlidingForwarding::decode_forwarding(HeapWord* original, uintptr_t encoded) const {\n+  assert((encoded & markWord::marked_value) == markWord::marked_value, \"must be marked as forwarded\");\n+  size_t orig_idx = region_index_containing(original);\n+  size_t region_idx = (encoded >> REGION_SHIFT) & right_n_bits(REGION_BITS);\n+  size_t base_table_idx = orig_idx * 2 + region_idx;\n+  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n+  assert(decoded >= _heap_start, \"must be above heap start, encoded: \" INTPTR_FORMAT \", region_idx: \" SIZE_FORMAT \", base: \" PTR_FORMAT, encoded, region_idx, p2i(_target_base_table[base_table_idx]));\n+  return decoded;\n+}\n+\n+void SlidingForwarding::forward_to(oop original, oop target) {\n+  assert(_target_base_table != nullptr, \"call begin() before forwarding\");\n+  markWord header = original->mark();\n+  if (header.has_displaced_mark_helper()) {\n+    header = header.displaced_mark_helper();\n+  }\n+  HeapWord* from = cast_from_oop<HeapWord*>(original);\n+  HeapWord* to   = cast_from_oop<HeapWord*>(target);\n+  uintptr_t encoded = encode_forwarding(from, to);\n+  header = markWord((header.value() & ~MARK_LOWER_HALF_MASK) | encoded);\n+  original->set_mark(header);\n+  if ((encoded & FALLBACK_MASK) != 0) {\n+    fallback_forward_to(from, to);\n+    return;\n+  }\n+}\n+\n+oop SlidingForwarding::forwardee(oop original) const {\n+  assert(_target_base_table != nullptr, \"call begin() before forwarding\");\n+  markWord header = original->mark();\n+  if ((header.value() & FALLBACK_MASK) != 0) {\n+    HeapWord* from = cast_from_oop<HeapWord*>(original);\n+    HeapWord* to = fallback_forwardee(from);\n+    return cast_to_oop(to);\n+  }\n+  uintptr_t encoded = header.value() & MARK_LOWER_HALF_MASK;\n+  HeapWord* forwardee = decode_forwarding(cast_from_oop<HeapWord*>(original), encoded);\n+  return cast_to_oop(forwardee);\n+}\n+\n+#endif \/\/ _LP64\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -272,1 +273,1 @@\n-    q->forward_to(cast_to_oop(compact_top));\n+    GCForwarding::forward_to(q, cast_to_oop(compact_top));\n@@ -278,1 +279,1 @@\n-    assert(!q->is_forwarded(), \"should not be forwarded\");\n+    assert(GCForwarding::is_not_forwarded(q), \"should not be forwarded\");\n@@ -438,1 +439,1 @@\n-    if (!cast_to_oop(cur_obj)->is_forwarded()) {\n+    if (GCForwarding::is_not_forwarded(cast_to_oop(cur_obj))) {\n@@ -449,1 +450,1 @@\n-      HeapWord* compaction_top = cast_from_oop<HeapWord*>(cast_to_oop(cur_obj)->forwardee());\n+      HeapWord* compaction_top = cast_from_oop<HeapWord*>(GCForwarding::forwardee(cast_to_oop(cur_obj)));\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -200,1 +201,1 @@\n-  Klass* obj_klass = obj->klass_or_null();\n+  Klass* obj_klass = ShenandoahObjectUtils::klass(obj);\n@@ -232,1 +233,1 @@\n-    if (obj_klass != fwd->klass()) {\n+    if (obj_klass != ShenandoahObjectUtils::klass(fwd)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -89,0 +90,1 @@\n+    assert(prev_mark.is_marked(), \"must be forwarded\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -224,0 +225,1 @@\n+    GCForwarding::begin();\n@@ -235,0 +237,1 @@\n+    GCForwarding::end();\n@@ -366,1 +369,1 @@\n-    p->forward_to(cast_to_oop(_compact_point));\n+    GCForwarding::forward_to(p, cast_to_oop(_compact_point));\n@@ -419,0 +422,1 @@\n+        size_t num_marked = _heap->complete_marking_context()->count_marked(MemRegion(from_region->bottom(), from_region->top()));\n@@ -474,1 +478,1 @@\n-        old_obj->forward_to(cast_to_oop(heap->get_region(start)->bottom()));\n+        GCForwarding::forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -734,2 +738,2 @@\n-      if (obj->is_forwarded()) {\n-        oop forw = obj->forwardee();\n+      if (GCForwarding::is_forwarded(obj)) {\n+        oop forw = GCForwarding::forwardee(obj);\n@@ -845,1 +849,1 @@\n-    if (p->is_forwarded()) {\n+    if (GCForwarding::is_forwarded(p)) {\n@@ -847,1 +851,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(p->forwardee());\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(GCForwarding::forwardee(p));\n@@ -949,1 +953,1 @@\n-      if (!old_obj->is_forwarded()) {\n+      if (GCForwarding::is_not_forwarded(old_obj)) {\n@@ -958,1 +962,1 @@\n-      size_t new_start = heap->heap_region_index_containing(old_obj->forwardee());\n+      size_t new_start = heap->heap_region_index_containing(GCForwarding::forwardee(old_obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -442,0 +443,2 @@\n+  GCForwarding::initialize(_heap_region, ShenandoahHeapRegion::region_size_words());\n+\n@@ -993,1 +996,1 @@\n-    if (!p->is_forwarded()) {\n+    if (!ShenandoahForwarding::is_forwarded(p)) {\n@@ -1338,0 +1341,1 @@\n+    shenandoah_assert_not_in_cset_except(NULL, obj, cancelled_gc());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -287,1 +288,1 @@\n-  size_t size = p->size();\n+  size_t size = ShenandoahObjectUtils::size(p);\n@@ -325,2 +326,7 @@\n-  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n-\n+  if (!copy_val->mark().is_marked()) {\n+    \/\/ If we copied a mark-word that indicates 'forwarded' state, then\n+    \/\/ another thread beat us, and this new copy will never be published.\n+    \/\/ ContinuationGCSupport would get a corrupt Klass* in that case,\n+    \/\/ so don't even attempt it.\n+    ContinuationGCSupport::relativize_stack_chunk(copy_val);\n+  }\n@@ -506,1 +512,1 @@\n-    size_t size = obj->size();\n+    size_t size = ShenandoahObjectUtils::size(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -123,0 +123,19 @@\n+size_t ShenandoahMarkBitMap::count_marked(MemRegion mr) const {\n+  MemRegion intersection = mr.intersection(_covered);\n+  assert(!intersection.is_empty(),\n+         \"Given range from \" PTR_FORMAT \" to \" PTR_FORMAT \" is completely outside the heap\",\n+          p2i(mr.start()), p2i(mr.end()));\n+  \/\/ convert address range into offset range\n+  HeapWord* beg = intersection.start();\n+  HeapWord* end = intersection.end();\n+  size_t sum = 0;\n+  \/\/ We could probably be smarter here, but the complication is that we use\n+  \/\/ two bits per object for strong vs weak marking.\n+  for (HeapWord* current = beg; current < end; current++) {\n+    if (is_marked(current)) {\n+      sum++;\n+    }\n+  }\n+  return sum;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  size_t count_marked(MemRegion mr) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+size_t ShenandoahMarkingContext::count_marked(MemRegion mr) const {\n+  return _mark_bit_map.count_marked(mr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  size_t count_marked(MemRegion mr) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class Klass;\n+\n+class ShenandoahObjectUtils : public AllStatic {\n+public:\n+#ifdef _LP64\n+  static inline markWord stable_mark(oop obj);\n+#endif\n+  static inline Klass* klass(oop obj);\n+  static inline size_t size(oop obj);\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+\/\/ This is a variant of ObjectSynchronizer::stable_mark(), which does the same thing, but also\n+\/\/ handles forwarded objects. This is intended to be used by concurrent evacuation only. No other\n+\/\/ code is supposed to observe from-space objects.\n+#ifdef _LP64\n+markWord ShenandoahObjectUtils::stable_mark(oop obj) {\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  for (;;) {\n+    assert(heap->is_in(obj), \"object not in heap: \" PTR_FORMAT, p2i(obj));\n+    markWord mark = obj->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  Inflated     - just return mark from inflated monitor\n+    \/\/ *  Stack-locked - coerce it to inflating, and then return displaced mark\n+    \/\/ *  INFLATING    - busy wait for conversion to complete\n+    \/\/ *  Neutral      - return mark\n+    \/\/ *  Marked       - object is forwarded, try again on forwardee\n+\n+    \/\/ Most common case first.\n+    if (mark.is_neutral() || mark.is_fast_locked()) {\n+      return mark;\n+    }\n+\n+    \/\/ If object is already forwarded, then resolve it, and try again.\n+    if (mark.is_marked()) {\n+      if (heap->is_full_gc_move_in_progress()) {\n+        \/\/ In these cases, we want to return the header as-is: the Klass* would not be overloaded.\n+        return mark;\n+      }\n+      obj = cast_to_oop(mark.decode_pointer());\n+      continue;\n+    }\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      \/\/ It is safe to access the object monitor because all Java and GC worker threads\n+      \/\/ participate in the monitor deflation protocol (i.e, they react to handshakes and STS requests).\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n+      return dmw;\n+    }\n+\n+    \/\/ CASE: inflating\n+    if (mark.is_being_inflated()) {\n+      \/\/ Interference, try again.\n+      continue;\n+    }\n+\n+    \/\/ CASE: stack-locked\n+    if (mark.has_locker()) {\n+      if (Thread::current()->is_lock_owned((address)mark.locker())) {\n+        \/\/ This thread owns the lock. We can safely access it.\n+        markWord dmw = mark.displaced_mark_helper();\n+        assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n+        return dmw;\n+      }\n+\n+      \/\/ Else we try to install INFLATING into the header. This will (temporarily) prevent other\n+      \/\/ threads from stack-locking or evacuating the object.\n+      markWord cmp = obj->cas_set_mark(markWord::INFLATING(), mark);\n+      if (cmp != mark) {\n+        continue;       \/\/ Interference -- just retry\n+      }\n+\n+      \/\/ We've successfully installed INFLATING (0) into the mark-word.\n+      \/\/ This is the only case where 0 will appear in a mark-word.\n+      \/\/ Only the singular thread that successfully swings the mark-word\n+      \/\/ to 0 can fetch the stack-lock and safely read the displaced header.\n+\n+      \/\/ fetch the displaced mark from the owner's stack.\n+      \/\/ The owner can't die or unwind past the lock while our INFLATING\n+      \/\/ object is in the mark.  Furthermore the owner can't complete\n+      \/\/ an unlock on the object, either. No other thread can do evacuation, either.\n+      markWord dmw = mark.displaced_mark_helper();\n+      \/\/ Catch if the object's header is not neutral (not locked and\n+      \/\/ not marked is what we care about here).\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+\n+      \/\/ Must preserve store ordering. The monitor state must\n+      \/\/ be stable at the time of publishing the monitor address.\n+      guarantee(obj->mark() == markWord::INFLATING(), \"invariant\");\n+      \/\/ Release semantics so that above set_object() is seen first.\n+      obj->release_set_mark(mark);\n+\n+      return dmw;\n+    }\n+  }\n+}\n+#endif\n+\n+Klass* ShenandoahObjectUtils::klass(oop obj) {\n+  if (!UseCompactObjectHeaders) {\n+    return obj->klass();\n+  }\n+#ifdef _LP64\n+  markWord header = stable_mark(obj);\n+  assert(header.narrow_klass() != 0, \"klass must not be NULL: \" INTPTR_FORMAT, header.value());\n+  return header.klass();\n+#else\n+  return obj->klass();\n+#endif\n+}\n+\n+size_t ShenandoahObjectUtils::size(oop obj) {\n+  if (!UseCompactObjectHeaders) {\n+    return obj->size();\n+  }\n+  Klass* kls = klass(obj);\n+  return obj->size_given_klass(kls);\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.inline.hpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -101,1 +102,1 @@\n-      if (is_instance_ref_klass(obj->klass())) {\n+      if (is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n@@ -128,1 +129,1 @@\n-    Klass* obj_klass = obj->klass_or_null();\n+    Klass* obj_klass = ShenandoahObjectUtils::klass(obj);\n@@ -143,1 +144,1 @@\n-        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj->size()) <= obj_reg->top(),\n+        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + ShenandoahObjectUtils::size(obj)) <= obj_reg->top(),\n@@ -147,1 +148,1 @@\n-        size_t humongous_end = humongous_start + (obj->size() >> ShenandoahHeapRegion::region_size_words_shift());\n+        size_t humongous_end = humongous_start + (ShenandoahObjectUtils::size(obj) >> ShenandoahHeapRegion::region_size_words_shift());\n@@ -164,1 +165,1 @@\n-          Atomic::add(&_ld[obj_reg->index()], (uint) obj->size(), memory_order_relaxed);\n+          Atomic::add(&_ld[obj_reg->index()], (uint) ShenandoahObjectUtils::size(obj), memory_order_relaxed);\n@@ -205,1 +206,1 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd->size()) <= fwd_reg->top(),\n+      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + ShenandoahObjectUtils::size(fwd)) <= fwd_reg->top(),\n@@ -308,1 +309,2 @@\n-    obj->oop_iterate(this);\n+    Klass* klass = ShenandoahObjectUtils::klass(obj);\n+    obj->oop_iterate_backwards(this, klass);\n@@ -588,1 +590,1 @@\n-    if (!is_instance_ref_klass(obj->klass())) {\n+    if (!is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-        assert(!UseCompressedClassPointers, \"should only happen without compressed class pointers\");\n+        assert(!UseCompressedClassPointers || UseCompactObjectHeaders, \"should only happen without compressed class pointers or with compact object headers\");\n","filename":"src\/hotspot\/share\/gc\/x\/c2\/xBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,2 +53,9 @@\n-  const size_t header = arrayOopDesc::header_size(element_type);\n-  const size_t payload_size = _word_size - header;\n+int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n+\n+  \/\/ Clear leading 32 bit, if necessary.\n+  if (!is_aligned(base_offset, HeapWordSize)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n+    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n@@ -56,0 +63,2 @@\n+  const size_t header = heap_word_size(base_offset);\n+  const size_t payload_size = _word_size - header;\n@@ -66,2 +75,6 @@\n-  arrayOopDesc::set_mark(mem, markWord::prototype());\n-  arrayOopDesc::release_set_klass(mem, _klass);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  } else {\n+    arrayOopDesc::set_mark(mem, markWord::prototype());\n+    arrayOopDesc::release_set_klass(mem, _klass);\n+  }\n","filename":"src\/hotspot\/share\/gc\/x\/xObjArrayAllocator.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -483,1 +483,1 @@\n-        assert(!UseCompressedClassPointers, \"should only happen without compressed class pointers\");\n+        assert(!UseCompressedClassPointers || UseCompactObjectHeaders, \"should only happen without compressed class pointers or with compact object headers\");\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,2 +53,9 @@\n-  const size_t header = arrayOopDesc::header_size(element_type);\n-  const size_t payload_size = _word_size - header;\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n+\n+  \/\/ Clear leading 32 bit, if necessary.\n+  if (!is_aligned(base_offset, HeapWordSize)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n+    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n@@ -56,0 +63,2 @@\n+  const size_t header = heap_word_size(base_offset);\n+  const size_t payload_size = _word_size - header;\n@@ -69,2 +78,6 @@\n-  arrayOopDesc::set_mark(mem, markWord::prototype().set_marked());\n-  arrayOopDesc::release_set_klass(mem, _klass);\n+  if (UseCompactObjectHeaders) {\n+    oopDesc::release_set_mark(mem, _klass->prototype_header().set_marked());\n+  } else {\n+    arrayOopDesc::set_mark(mem, markWord::prototype().set_marked());\n+    arrayOopDesc::release_set_klass(mem, _klass);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -897,0 +897,4 @@\n+\n+    if (SuspendibleThreadSet::should_yield()) {\n+      SuspendibleThreadSet::yield();\n+    }\n@@ -1097,0 +1101,1 @@\n+    SuspendibleThreadSetJoiner sts_joiner;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2003,0 +2003,3 @@\n+#ifdef _LP64\n+              oopDesc::release_set_mark(result, ik->prototype_header());\n+#else\n@@ -2004,1 +2007,0 @@\n-              oopDesc::set_klass_gap(result, 0);\n@@ -2006,1 +2008,1 @@\n-\n+#endif\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-    _store->push(ObjectSampleMarkWord(obj, obj->mark()));\n+    markWord mark = obj->mark();\n+    _store->push(ObjectSampleMarkWord(obj, mark));\n@@ -73,1 +74,6 @@\n-    obj->set_mark(markWord::prototype().set_marked());\n+#ifdef _LP64\n+    if (mark.has_displaced_mark_helper()) {\n+      mark = mark.displaced_mark_helper();\n+    }\n+#endif\n+    obj->set_mark(markWord::prototype().set_marked() LP64_ONLY(.set_narrow_klass(mark.narrow_klass())));\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/objectSampleMarker.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2416,1 +2416,1 @@\n-  return arrayOopDesc::header_size(type) * HeapWordSize;\n+  return arrayOopDesc::base_offset_in_bytes(type);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,0 @@\n-  volatile_nonstatic_field(oopDesc,            _metadata._klass,                              Klass*)                                \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,2 +53,1 @@\n-    size_t hs = align_up(length_offset_in_bytes() + sizeof(int),\n-                              HeapWordSize);\n+    size_t hs = length_offset_in_bytes() + sizeof(int);\n@@ -74,0 +73,5 @@\n+#ifdef _LP64\n+    if (type == T_OBJECT || type == T_ARRAY) {\n+      return !UseCompressedOops;\n+    }\n+#endif\n@@ -82,2 +86,1 @@\n-    return UseCompressedClassPointers ? klass_gap_offset_in_bytes() :\n-                               sizeof(arrayOopDesc);\n+    return oopDesc::base_offset_in_bytes();\n@@ -88,1 +91,4 @@\n-    return header_size(type) * HeapWordSize;\n+    size_t typesize_in_bytes = header_size_in_bytes();\n+    return (int)(element_type_should_be_aligned(type)\n+                 ? align_up(typesize_in_bytes, BytesPerLong)\n+                 : typesize_in_bytes);\n@@ -125,11 +131,0 @@\n-  \/\/ Should only be called with constants as argument\n-  \/\/ (will not constant fold otherwise)\n-  \/\/ Returns the header size in words aligned to the requirements of the\n-  \/\/ array object type.\n-  static int header_size(BasicType type) {\n-    size_t typesize_in_bytes = header_size_in_bytes();\n-    return (int)(element_type_should_be_aligned(type)\n-      ? align_object_offset(typesize_in_bytes\/HeapWordSize)\n-      : typesize_in_bytes\/HeapWordSize);\n-  }\n-\n@@ -144,4 +139,2 @@\n-    const size_t max_element_words_per_size_t =\n-      align_down((SIZE_MAX\/HeapWordSize - header_size(type)), MinObjAlignment);\n-    const size_t max_elements_per_size_t =\n-      HeapWordSize * max_element_words_per_size_t \/ type2aelembytes(type);\n+    const size_t max_size_bytes = align_down(SIZE_MAX - base_offset_in_bytes(type), MinObjAlignmentInBytes);\n+    const size_t max_elements_per_size_t = max_size_bytes \/ type2aelembytes(type);\n@@ -153,1 +146,2 @@\n-      return align_down(max_jint - header_size(type), MinObjAlignment);\n+      int header_size_words = align_up(base_offset_in_bytes(type), HeapWordSize) \/ HeapWordSize;\n+      return align_down(max_jint - header_size_words, MinObjAlignment);\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-  \/\/ aligned header size.\n-  static int header_size() { return sizeof(instanceOopDesc)\/HeapWordSize; }\n-\n@@ -41,4 +38,1 @@\n-    return (UseCompressedClassPointers) ?\n-            klass_gap_offset_in_bytes() :\n-            sizeof(instanceOopDesc);\n-\n+    return oopDesc::base_offset_in_bytes();\n","filename":"src\/hotspot\/share\/oops\/instanceOop.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  static void trace_reference_gc(const char *s, oop obj) NOT_DEBUG_RETURN;\n+  void trace_reference_gc(const char *s, oop obj) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -195,1 +197,15 @@\n-  return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);\n+  MetaWord* p = Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);\n+  assert(is_aligned(p, KlassAlignmentInBytes),\n+         \"metaspace returned badly aligned memory (\" PTR_FORMAT \"), alignment required: %u\",\n+         p2i(p), (unsigned)KlassAlignmentInBytes);\n+  return p;\n+}\n+\n+static markWord make_prototype(Klass* kls) {\n+  markWord prototype = markWord::prototype();\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    prototype = prototype.set_klass(kls);\n+  }\n+#endif\n+  return prototype;\n@@ -203,0 +219,1 @@\n+                           _prototype_header(make_prototype(this)),\n@@ -747,0 +764,4 @@\n+     if (UseCompactObjectHeaders) {\n+       st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n+       st->cr();\n+     }\n@@ -770,0 +791,4 @@\n+  if (UseCompressedClassPointers) {\n+    assert(is_aligned(this, KlassAlignmentInBytes), \"misaligned Klass structure\");\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -170,0 +170,2 @@\n+  markWord _prototype_header;   \/\/ Used to initialize objects' header\n+\n@@ -679,0 +681,7 @@\n+  markWord prototype_header() const      {\n+    assert(UseCompactObjectHeaders, \"only use with compact object headers\");\n+    return _prototype_header;\n+  }\n+  inline void set_prototype_header(markWord header);\n+  static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,0 +55,5 @@\n+inline void Klass::set_prototype_header(markWord header) {\n+  assert(UseCompactObjectHeaders, \"only with compact headers\");\n+  _prototype_header = header;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/compressedKlass.hpp\" \/\/ for narrowKlass\n@@ -46,0 +47,4 @@\n+\/\/  64 bits (with compact headers):\n+\/\/  -------------------------------\n+\/\/  nklass:32 hash:25 -->| unused_gap:1  age:4  self-fwded:1  lock:2 (normal object)\n+\/\/\n@@ -106,2 +111,2 @@\n-  static const int first_unused_gap_bits          = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n+  static const int self_forwarded_bits            = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - self_forwarded_bits;\n@@ -109,1 +114,7 @@\n-  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n+  static const int hash_bits_compact              = max_hash_bits > 25 ? 25 : max_hash_bits;\n+  \/\/ Used only without compact headers.\n+  static const int unused_gap_bits                = LP64_ONLY(1) NOT_LP64(0);\n+#ifdef _LP64\n+  \/\/ Used only with compact headers.\n+  static const int klass_bits                     = 32;\n+#endif\n@@ -112,2 +123,8 @@\n-  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n-  static const int hash_shift                     = age_shift + age_bits + second_unused_gap_bits;\n+  static const int self_forwarded_shift           = lock_shift + lock_bits;\n+  static const int age_shift                      = self_forwarded_shift + self_forwarded_bits;\n+  static const int hash_shift                     = age_shift + age_bits + unused_gap_bits;\n+  static const int hash_shift_compact             = age_shift + age_bits;\n+#ifdef _LP64\n+  \/\/ Used only with compact headers.\n+  static const int klass_shift                    = hash_shift_compact + hash_bits_compact;\n+#endif\n@@ -117,0 +134,2 @@\n+  static const uintptr_t self_forwarded_mask      = right_n_bits(self_forwarded_bits);\n+  static const uintptr_t self_forwarded_mask_in_place = self_forwarded_mask << self_forwarded_shift;\n@@ -121,0 +140,6 @@\n+  static const uintptr_t hash_mask_compact        = right_n_bits(hash_bits_compact);\n+  static const uintptr_t hash_mask_compact_in_place = hash_mask_compact << hash_shift_compact;\n+#ifdef _LP64\n+  static const uintptr_t klass_mask               = right_n_bits(klass_bits);\n+  static const uintptr_t klass_mask_in_place      = klass_mask << klass_shift;\n+#endif\n@@ -208,3 +233,9 @@\n-    uintptr_t tmp = value() & (~hash_mask_in_place);\n-    tmp |= ((hash & hash_mask) << hash_shift);\n-    return markWord(tmp);\n+    if (UseCompactObjectHeaders) {\n+      uintptr_t tmp = value() & (~hash_mask_compact_in_place);\n+      tmp |= ((hash & hash_mask_compact) << hash_shift_compact);\n+      return markWord(tmp);\n+    } else {\n+      uintptr_t tmp = value() & (~hash_mask_in_place);\n+      tmp |= ((hash & hash_mask) << hash_shift);\n+      return markWord(tmp);\n+    }\n@@ -243,1 +274,5 @@\n-    return mask_bits(value() >> hash_shift, hash_mask);\n+    if (UseCompactObjectHeaders) {\n+      return mask_bits(value() >> hash_shift_compact, hash_mask_compact);\n+    } else {\n+      return mask_bits(value() >> hash_shift, hash_mask);\n+    }\n@@ -250,0 +285,9 @@\n+#ifdef _LP64\n+  inline Klass* klass() const;\n+  inline Klass* klass_or_null() const;\n+  inline Klass* safe_klass() const;\n+  inline markWord set_klass(const Klass* klass) const;\n+  inline narrowKlass narrow_klass() const;\n+  inline markWord set_narrow_klass(const narrowKlass klass) const;\n+#endif\n+\n@@ -263,0 +307,8 @@\n+\n+  inline bool self_forwarded() const {\n+    return mask_bits(value(), self_forwarded_mask_in_place) != 0;\n+  }\n+\n+  inline markWord set_self_forwarded() const {\n+    return markWord(value() | self_forwarded_mask_in_place | marked_value);\n+  }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":61,"deletions":9,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_MARKWORD_INLINE_HPP\n+#define SHARE_OOPS_MARKWORD_INLINE_HPP\n+\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+\n+#ifdef _LP64\n+narrowKlass markWord::narrow_klass() const {\n+  return narrowKlass(value() >> klass_shift);\n+}\n+\n+Klass* markWord::klass() const {\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n+  assert(!CompressedKlassPointers::is_null(narrow_klass()), \"narrow klass must not be null: \" INTPTR_FORMAT, value());\n+  return CompressedKlassPointers::decode_not_null(narrow_klass());\n+}\n+\n+Klass* markWord::klass_or_null() const {\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n+  return CompressedKlassPointers::decode(narrow_klass());\n+}\n+\n+markWord markWord::set_narrow_klass(const narrowKlass nklass) const {\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n+  return markWord((value() & ~klass_mask_in_place) | ((uintptr_t) nklass << klass_shift));\n+}\n+\n+Klass* markWord::safe_klass() const {\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n+  assert(SafepointSynchronize::is_at_safepoint(), \"only call at safepoint\");\n+  markWord m = *this;\n+  if (m.has_displaced_mark_helper()) {\n+    m = m.displaced_mark_helper();\n+  }\n+  return CompressedKlassPointers::decode_not_null(m.narrow_klass());\n+}\n+\n+markWord markWord::set_klass(const Klass* klass) const {\n+  assert(UseCompactObjectHeaders, \"only used with compact object headers\");\n+  assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n+  \/\/ TODO: Don't cast to non-const, change CKP::encode() to accept const Klass* instead.\n+  narrowKlass nklass = CompressedKlassPointers::encode(const_cast<Klass*>(klass));\n+  return set_narrow_klass(nklass);\n+}\n+#endif\n+\n+#endif \/\/ SHARE_OOPS_MARKWORD_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -159,1 +159,0 @@\n-  assert(obj->is_objArray(), \"must be object array\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  assert (obj->is_array(), \"obj must be array\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -55,23 +55,3 @@\n-  \/\/ Give size of objArrayOop in HeapWords minus the header\n-  static int array_size(int length) {\n-    const uint OopsPerHeapWord = HeapWordSize\/heapOopSize;\n-    assert(OopsPerHeapWord >= 1 && (HeapWordSize % heapOopSize == 0),\n-           \"Else the following (new) computation would be in error\");\n-    uint res = ((uint)length + OopsPerHeapWord - 1)\/OopsPerHeapWord;\n-#ifdef ASSERT\n-    \/\/ The old code is left in for sanity-checking; it'll\n-    \/\/ go away pretty soon. XXX\n-    \/\/ Without UseCompressedOops, this is simply:\n-    \/\/ oop->length() * HeapWordsPerOop;\n-    \/\/ With narrowOops, HeapWordsPerOop is 1\/2 or equal 0 as an integer.\n-    \/\/ The oop elements are aligned up to wordSize\n-    const uint HeapWordsPerOop = heapOopSize\/HeapWordSize;\n-    uint old_res;\n-    if (HeapWordsPerOop > 0) {\n-      old_res = length * HeapWordsPerOop;\n-    } else {\n-      old_res = align_up((uint)length, OopsPerHeapWord)\/OopsPerHeapWord;\n-    }\n-    assert(res == old_res, \"Inconsistency between old and new.\");\n-#endif  \/\/ ASSERT\n-    return res;\n+  \/\/ Give size of objArrayOop in bytes minus the header\n+  static size_t array_size_in_bytes(int length) {\n+    return (size_t)length * heapOopSize;\n@@ -97,1 +77,0 @@\n-  static int header_size()    { return arrayOopDesc::header_size(T_OBJECT); }\n@@ -102,5 +81,5 @@\n-    uint asz = array_size(length);\n-    uint osz = align_object_size(header_size() + asz);\n-    assert(osz >= asz,   \"no overflow\");\n-    assert((int)osz > 0, \"no overflow\");\n-    return (size_t)osz;\n+    size_t asz = array_size_in_bytes(length);\n+    size_t size_words = align_up(base_offset_in_bytes() + asz, HeapWordSize) \/ HeapWordSize;\n+    size_t osz = align_object_size(size_words);\n+    assert(osz < max_jint, \"no overflow\");\n+    return osz;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":8,"deletions":29,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -159,2 +160,3 @@\n-  \/\/ Only has a klass gap when compressed class pointers are used.\n-  return UseCompressedClassPointers;\n+  \/\/ Only has a klass gap when compressed class pointers are used, but\n+  \/\/ only if not using compact headers..\n+  return UseCompressedClassPointers && !UseCompactObjectHeaders;\n@@ -167,1 +169,5 @@\n-  _metadata._compressed_klass = nk;\n+  if (UseCompactObjectHeaders) {\n+    set_mark(mark().set_narrow_klass(nk));\n+  } else {\n+    _metadata._compressed_klass = nk;\n+  }\n@@ -172,7 +178,8 @@\n-  if (UseCompressedClassPointers) {\n-    narrowKlass narrow_klass = obj->_metadata._compressed_klass;\n-    if (narrow_klass == 0) return nullptr;\n-    return (void*)CompressedKlassPointers::decode_raw(narrow_klass);\n-  } else {\n-    return obj->_metadata._klass;\n-  }\n+  \/\/ TODO: Remove method altogether and replace with calls to obj->klass() ?\n+  \/\/ OTOH, we may eventually get rid of locking in header, and then no\n+  \/\/ longer have to deal with that anymore.\n+#ifdef _LP64\n+  return obj->klass();\n+#else\n+  return obj->_metadata._klass;\n+#endif\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  inline markWord resolve_mark() const;\n+\n@@ -101,1 +103,8 @@\n-  static constexpr int header_size() { return sizeof(oopDesc)\/HeapWordSize; }\n+  static int header_size() {\n+#ifdef _LP64\n+    if (UseCompactObjectHeaders) {\n+      return sizeof(markWord) \/ HeapWordSize;\n+    } else\n+#endif\n+    return sizeof(oopDesc)\/HeapWordSize;\n+  }\n@@ -263,0 +272,1 @@\n+  inline void forward_to_self();\n@@ -269,0 +279,1 @@\n+  inline oop forward_to_self_atomic(markWord compare, atomic_memory_order order = memory_order_conservative);\n@@ -271,0 +282,1 @@\n+  inline oop forwardee(markWord header) const;\n@@ -314,1 +326,0 @@\n-  static int klass_offset_in_bytes()     { return (int)offset_of(oopDesc, _metadata._klass); }\n@@ -317,0 +328,1 @@\n+    assert(!UseCompactObjectHeaders, \"don't use klass_offset_in_bytes() with compact headers\");\n@@ -320,0 +332,24 @@\n+  static int klass_offset_in_bytes()     {\n+#ifdef _LP64\n+    if (UseCompactObjectHeaders) {\n+      STATIC_ASSERT(markWord::klass_shift % 8 == 0);\n+      return mark_offset_in_bytes() + markWord::klass_shift \/ 8;\n+    } else\n+#endif\n+    return offset_of(oopDesc, _metadata._klass);\n+  }\n+\n+  static int base_offset_in_bytes() {\n+#ifdef _LP64\n+    if (UseCompactObjectHeaders) {\n+      \/\/ With compact headers, the Klass* field is not used for the Klass*\n+      \/\/ and is used for the object fields instead.\n+      assert(sizeof(markWord) == 8, \"sanity\");\n+      return sizeof(markWord);\n+    } else if (UseCompressedClassPointers) {\n+      return sizeof(markWord) + sizeof(narrowKlass);\n+    } else\n+#endif\n+    return sizeof(oopDesc);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":38,"deletions":2,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"oops\/markWord.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -41,0 +41,3 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n@@ -85,0 +88,10 @@\n+markWord oopDesc::resolve_mark() const {\n+  assert(LockingMode != LM_LEGACY, \"Not safe with legacy stack-locking\");\n+  markWord hdr = mark();\n+  if (hdr.has_monitor()) {\n+    ObjectMonitor* monitor = hdr.monitor();\n+    return monitor->header();\n+  }\n+  return hdr;\n+}\n+\n@@ -86,0 +99,7 @@\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    markWord header = resolve_mark();\n+    assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n+    set_mark(markWord((header.value() & markWord::klass_mask_in_place) | markWord::prototype().value()));\n+  } else\n+#endif\n@@ -90,1 +110,6 @@\n-  if (UseCompressedClassPointers) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+    markWord header = resolve_mark();\n+    return header.klass();\n+  } else if (UseCompressedClassPointers) {\n@@ -92,3 +117,3 @@\n-  } else {\n-    return _metadata._klass;\n-  }\n+  } else\n+#endif\n+  return _metadata._klass;\n@@ -98,1 +123,6 @@\n-  if (UseCompressedClassPointers) {\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+    markWord header = resolve_mark();\n+    return header.klass_or_null();\n+  } else if (UseCompressedClassPointers) {\n@@ -100,3 +130,3 @@\n-  } else {\n-    return _metadata._klass;\n-  }\n+  } else\n+#endif\n+  return _metadata._klass;\n@@ -106,6 +136,14 @@\n-  if (UseCompressedClassPointers) {\n-    narrowKlass nklass = Atomic::load_acquire(&_metadata._compressed_klass);\n-    return CompressedKlassPointers::decode(nklass);\n-  } else {\n-    return Atomic::load_acquire(&_metadata._klass);\n-  }\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders) {\n+    assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+    markWord header = mark_acquire();\n+    if (header.has_monitor()) {\n+      header = header.monitor()->header();\n+    }\n+    return header.klass_or_null();\n+  } else if (UseCompressedClassPointers) {\n+     narrowKlass nklass = Atomic::load_acquire(&_metadata._compressed_klass);\n+     return CompressedKlassPointers::decode(nklass);\n+  } else\n+#endif\n+  return Atomic::load_acquire(&_metadata._klass);\n@@ -115,5 +153,1 @@\n-  if (UseCompressedClassPointers) {\n-    return CompressedKlassPointers::decode_raw(_metadata._compressed_klass);\n-  } else {\n-    return _metadata._klass;\n-  }\n+  return klass();\n@@ -123,1 +157,2 @@\n-  assert(Universe::is_bootstrapping() || (k != nullptr && k->is_klass()), \"incorrect Klass\");\n+  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* with compact headers\");\n@@ -132,1 +167,2 @@\n-  assert(Universe::is_bootstrapping() || (k != nullptr && k->is_klass()), \"incorrect Klass\");\n+  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* with compact headers\");\n@@ -143,0 +179,1 @@\n+  assert(!UseCompactObjectHeaders, \"don't set Klass* gap with compact headers\");\n@@ -274,1 +311,1 @@\n-  assert(m.decode_pointer() == p, \"encoding must be reversible\");\n+  assert(forwardee(m) == p, \"encoding must be reversable\");\n@@ -278,0 +315,16 @@\n+void oopDesc::forward_to_self() {\n+#ifdef _LP64\n+  markWord m = mark();\n+  \/\/ If mark is displaced, we need to preserve the Klass* from real header.\n+  assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+  if (m.has_displaced_mark_helper()) {\n+    m = m.displaced_mark_helper();\n+  }\n+  m = m.set_self_forwarded();\n+  assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversable\");\n+  set_mark(m);\n+#else\n+  forward_to(oop(this));\n+#endif\n+}\n+\n@@ -280,1 +333,1 @@\n-  assert(m.decode_pointer() == p, \"encoding must be reversible\");\n+  assert(forwardee(m) == p, \"encoding must be reversable\");\n@@ -285,1 +338,1 @@\n-    return cast_to_oop(old_mark.decode_pointer());\n+    return forwardee(old_mark);\n@@ -289,0 +342,22 @@\n+oop oopDesc::forward_to_self_atomic(markWord compare, atomic_memory_order order) {\n+#ifdef _LP64\n+  markWord m = compare;\n+  \/\/ If mark is displaced, we need to preserve the Klass* from real header.\n+  assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+  if (m.has_displaced_mark_helper()) {\n+    m = m.displaced_mark_helper();\n+  }\n+  m = m.set_self_forwarded();\n+  assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversable\");\n+  markWord old_mark = cas_set_mark(m, compare, order);\n+  if (old_mark == compare) {\n+    return NULL;\n+  } else {\n+    assert(old_mark.is_marked(), \"must be marked here\");\n+    return forwardee(old_mark);\n+  }\n+#else\n+  return forward_to_atomic(oop(this), compare, order);\n+#endif\n+}\n+\n@@ -293,2 +368,14 @@\n-  assert(is_forwarded(), \"only decode when actually forwarded\");\n-  return cast_to_oop(mark().decode_pointer());\n+  return forwardee(mark());\n+}\n+\n+oop oopDesc::forwardee(markWord header) const {\n+  assert(header.is_marked(), \"must be forwarded\");\n+#ifdef _LP64\n+  if (header.self_forwarded()) {\n+    return cast_to_oop(this);\n+  } else\n+#endif\n+  {\n+    assert(header.is_marked(), \"only decode when actually forwarded\");\n+    return cast_to_oop(header.decode_pointer());\n+  }\n@@ -351,1 +438,0 @@\n-  assert(k == klass(), \"wrong klass\");\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":114,"deletions":28,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-  assert(obj->is_typeArray(),\"must be a type array\");\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-  assert(obj->is_typeArray(),\"must be a type array\");\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,0 +113,10 @@\n+\n+class C2LoadNKlassStub : public C2CodeStub {\n+private:\n+  Register _dst;\n+public:\n+  C2LoadNKlassStub(Register dst) : C2CodeStub(), _dst(dst) {}\n+  Register dst() { return _dst; }\n+  int max_size() const;\n+  void emit(C2_MacroAssembler& masm);\n+};\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1619,2 +1619,8 @@\n-  \/\/ For now only enable fast locking for non-array types\n-  mark_node = phase->MakeConX(markWord::prototype().value());\n+  if (UseCompactObjectHeaders) {\n+    Node* klass_node = in(AllocateNode::KlassNode);\n+    Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n+    mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n+  } else {\n+    \/\/ For now only enable fast locking for non-array types\n+    mark_node = phase->MakeConX(markWord::prototype().value());\n+  }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1695,0 +1695,4 @@\n+      if (UseCompactObjectHeaders) {\n+        if (flat->offset() == in_bytes(Klass::prototype_header_offset()))\n+          alias_type(idx)->set_rewritable(false);\n+      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4559,2 +4559,2 @@\n-  Node *hash_mask      = _gvn.intcon(markWord::hash_mask);\n-  Node *hash_shift     = _gvn.intcon(markWord::hash_shift);\n+  Node *hash_mask      = _gvn.intcon(UseCompactObjectHeaders ? markWord::hash_mask_compact  : markWord::hash_mask);\n+  Node *hash_shift     = _gvn.intcon(UseCompactObjectHeaders ? markWord::hash_shift_compact : markWord::hash_shift);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1696,1 +1696,4 @@\n-  rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+  if (!UseCompactObjectHeaders) {\n+    rawmem = make_store(control, rawmem, object, oopDesc::klass_offset_in_bytes(), klass_node, T_METADATA);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1906,0 +1906,7 @@\n+  if (UseCompactObjectHeaders) {\n+    if (tkls->offset() == in_bytes(Klass::prototype_header_offset())) {\n+      \/\/ The field is Klass::_prototype_header.  Return its (constant) value.\n+      assert(this->Opcode() == Op_LoadX, \"must load a proper type from _prototype_header\");\n+      return TypeX::make(klass->prototype_header());\n+    }\n+  }\n@@ -2078,0 +2085,7 @@\n+      if (UseCompactObjectHeaders) {\n+        if (tkls->offset() == in_bytes(Klass::prototype_header_offset())) {\n+          \/\/ The field is Klass::_prototype_header. Return its (constant) value.\n+          assert(this->Opcode() == Op_LoadX, \"must load a proper type from _prototype_header\");\n+          return TypeX::make(klass->prototype_header());\n+        }\n+      }\n@@ -2168,1 +2182,1 @@\n-  if (alloc != nullptr) {\n+  if (!UseCompactObjectHeaders && alloc != nullptr) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-    const size_t hs = arrayOopDesc::header_size(elem_type);\n+    const size_t hs_bytes = arrayOopDesc::base_offset_in_bytes(elem_type);\n@@ -325,1 +325,1 @@\n-    const size_t aligned_hs = align_object_offset(hs);\n+    const size_t aligned_hs_bytes = align_up(hs_bytes, BytesPerLong);\n@@ -327,2 +327,2 @@\n-    if (aligned_hs > hs) {\n-      Copy::zero_to_words(obj+hs, aligned_hs-hs);\n+    if (aligned_hs_bytes > hs_bytes) {\n+      Copy::zero_to_bytes(obj + hs_bytes, aligned_hs_bytes - hs_bytes);\n@@ -331,0 +331,1 @@\n+    const size_t aligned_hs = aligned_hs_bytes \/ HeapWordSize;\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -5153,1 +5153,2 @@\n-    int header_size = objArrayOopDesc::header_size() * wordSize;\n+    BasicType basic_elem_type = elem()->basic_type();\n+    int header_size = arrayOopDesc::base_offset_in_bytes(basic_elem_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \\\n+  ( arrayOopDesc::base_offset_in_bytes(T_DOUBLE) \\\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3095,0 +3095,12 @@\n+#ifdef _LP64\n+  if (UseCompactObjectHeaders && FLAG_IS_CMDLINE(UseCompressedClassPointers) && !UseCompressedClassPointers) {\n+    \/\/ If user specifies -UseCompressedClassPointers, disable compact headers with a warning.\n+    warning(\"Compact object headers require compressed class pointers. Disabling compact object headers.\");\n+    FLAG_SET_DEFAULT(UseCompactObjectHeaders, false);\n+  }\n+\n+  if (UseCompactObjectHeaders && LockingMode == LM_LEGACY) {\n+    FLAG_SET_DEFAULT(LockingMode, LM_LIGHTWEIGHT);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -133,0 +133,3 @@\n+  product(bool, UseCompactObjectHeaders, false, EXPERIMENTAL,               \\\n+          \"Use 64-bit object headers instead of 96-bit headers\")            \\\n+                                                                            \\\n@@ -150,0 +153,1 @@\n+const bool UseCompactObjectHeaders = false;\n@@ -1058,1 +1062,1 @@\n-  develop(bool, UseHeavyMonitors, false,                                    \\\n+  product(bool, UseHeavyMonitors, false, DIAGNOSTIC,                        \\\n@@ -1982,0 +1986,6 @@\n+  product(bool, HeapObjectStats, false, DIAGNOSTIC,                         \\\n+             \"Enable gathering of heap object statistics\")                  \\\n+                                                                            \\\n+  product(size_t, HeapObjectStatsSamplingInterval, 500, DIAGNOSTIC,         \\\n+             \"Heap object statistics sampling interval (ms)\")               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -220,0 +220,1 @@\n+  static ByteSize header_offset()      { return byte_offset_of(ObjectMonitor, _header); }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -905,1 +906,1 @@\n-  value &= markWord::hash_mask;\n+  value &= UseCompactObjectHeaders ? markWord::hash_mask_compact : markWord::hash_mask;\n@@ -1712,0 +1713,3 @@\n+      \/\/ Also, we sync and desync GC threads around the handshake, so that they can\n+      \/\/ safely read the mark-word and look-through to the object-monitor, without\n+      \/\/ being afraid that the object-monitor is going away.\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -115,0 +115,3 @@\n+#if INCLUDE_VM_STRUCTS\n+#include \"runtime\/vmStructs.hpp\"\n+#endif\n@@ -501,0 +504,7 @@\n+  \/\/ Should happen before any agent attaches and pokes into vmStructs\n+#if INCLUDE_VM_STRUCTS\n+  if (UseCompactObjectHeaders) {\n+    VMStructs::compact_headers_overrides();\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+  template(HeapObjectStatistics)                  \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -149,0 +149,10 @@\n+\/\/ Used by VMStructs when CompactObjectHeaders are enabled.\n+\/\/ Must match the relevant parts from the real oopDesc.\n+class fakeOopDesc {\n+private:\n+  union _metadata {\n+    Klass*      _klass;\n+    narrowKlass _compressed_klass;\n+  } _metadata;\n+};\n+\n@@ -1163,0 +1173,2 @@\n+  declare_toplevel_type(fakeOopDesc)                                      \\\n+                                                                          \\\n@@ -2533,0 +2545,1 @@\n+  declare_constant(markWord::hash_bits_compact)                           \\\n@@ -2537,0 +2550,2 @@\n+  declare_constant(markWord::hash_shift_compact)                          \\\n+  LP64_ONLY(declare_constant(markWord::klass_shift))                      \\\n@@ -2544,0 +2559,2 @@\n+  declare_constant(markWord::hash_mask_compact)                           \\\n+  declare_constant(markWord::hash_mask_compact_in_place)                  \\\n@@ -3080,0 +3097,26 @@\n+\n+void VMStructs::compact_headers_overrides() {\n+  assert(UseCompactObjectHeaders, \"Should have been checked before\");\n+\n+  \/\/ We cannot allow SA and other facilities to poke into VM internal fields\n+  \/\/ expecting the class pointers there. This will crash in the best case,\n+  \/\/ or yield incorrect execution in the worst case. This code hides the\n+  \/\/ risky fields from external code by replacing their original container\n+  \/\/ type to a fake one. The fake type should exist for VMStructs verification\n+  \/\/ code to work.\n+\n+  size_t len = localHotSpotVMStructsLength();\n+  for (size_t off = 0; off < len; off++) {\n+    VMStructEntry* e = &localHotSpotVMStructs[off];\n+    if (e == nullptr) continue;\n+    if (e->typeName == nullptr) continue;\n+    if (e->fieldName == nullptr) continue;\n+\n+    if (strcmp(e->typeName, \"oopDesc\") == 0) {\n+      if ((strcmp(e->fieldName, \"_metadata._klass\") == 0) ||\n+          (strcmp(e->fieldName, \"_metadata._compressed_klass\") == 0)) {\n+        e->typeName = \"fakeOopDesc\";\n+      }\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -149,0 +149,3 @@\n+\n+public:\n+  static void compact_headers_overrides() NOT_VM_STRUCTS_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/heapObjectStatistics.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+HeapObjectStatistics* HeapObjectStatistics::_instance = NULL;\n+\n+class HeapObjectStatsObjectClosure : public ObjectClosure {\n+private:\n+  HeapObjectStatistics* const _stats;\n+public:\n+  HeapObjectStatsObjectClosure() : _stats(HeapObjectStatistics::instance()) {}\n+  void do_object(oop obj) {\n+    _stats->visit_object(obj);\n+  }\n+};\n+\n+class VM_HeapObjectStatistics : public VM_Operation {\n+public:\n+  VMOp_Type type() const { return VMOp_HeapObjectStatistics; }\n+  bool doit_prologue() {\n+    Heap_lock->lock();\n+    return true;\n+  }\n+\n+  void doit_epilogue() {\n+    Heap_lock->unlock();\n+  }\n+\n+  void doit() {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"all threads are stopped\");\n+    assert(Heap_lock->is_locked(), \"should have the Heap_lock\");\n+\n+    CollectedHeap* heap = Universe::heap();\n+    heap->ensure_parsability(false);\n+\n+    HeapObjectStatistics* stats = HeapObjectStatistics::instance();\n+    stats->begin_sample();\n+\n+    HeapObjectStatsObjectClosure cl;\n+    heap->object_iterate(&cl);\n+  }\n+};\n+\n+HeapObjectStatisticsTask::HeapObjectStatisticsTask() : PeriodicTask(HeapObjectStatsSamplingInterval) {}\n+\n+void HeapObjectStatisticsTask::task() {\n+  VM_HeapObjectStatistics vmop;\n+  VMThread::execute(&vmop);\n+}\n+\n+void HeapObjectStatistics::initialize() {\n+  assert(_instance == NULL, \"Don't init twice\");\n+  if (HeapObjectStats) {\n+    _instance = new HeapObjectStatistics();\n+    _instance->start();\n+  }\n+}\n+\n+void HeapObjectStatistics::shutdown() {\n+  if (HeapObjectStats) {\n+    assert(_instance != NULL, \"Must be initialized\");\n+    LogTarget(Info, heap, stats) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ResourceMark rm;\n+      _instance->print(&ls);\n+    }\n+    _instance->stop();\n+    delete _instance;\n+    _instance = NULL;\n+  }\n+}\n+\n+HeapObjectStatistics* HeapObjectStatistics::instance() {\n+  assert(_instance != NULL, \"Must be initialized\");\n+  return _instance;\n+}\n+\n+void HeapObjectStatistics::increase_counter(uint64_t& counter, uint64_t val) {\n+  uint64_t oldval = counter;\n+  uint64_t newval = counter + val;\n+  if (newval < oldval) {\n+    log_warning(heap, stats)(\"HeapObjectStats counter overflow: resulting statistics will be useless\");\n+  }\n+  counter = newval;\n+}\n+\n+HeapObjectStatistics::HeapObjectStatistics() :\n+  _task(), _num_samples(0), _num_objects(0), _num_ihashed(0), _num_locked(0), _lds(0) { }\n+\n+void HeapObjectStatistics::start() {\n+  _task.enroll();\n+}\n+\n+void HeapObjectStatistics::stop() {\n+  _task.disenroll();\n+}\n+\n+void HeapObjectStatistics::begin_sample() {\n+  _num_samples++;\n+}\n+\n+void HeapObjectStatistics::visit_object(oop obj) {\n+  increase_counter(_num_objects);\n+  markWord mark = obj->mark();\n+  if (!mark.has_no_hash()) {\n+    increase_counter(_num_ihashed);\n+    if (mark.age() > 0) {\n+      increase_counter(_num_ihashed_moved);\n+    }\n+  }\n+  if (mark.is_locked()) {\n+    increase_counter(_num_locked);\n+  }\n+#ifdef ASSERT\n+#ifdef _LP64\n+  if (!mark.has_displaced_mark_helper()) {\n+    assert(mark.narrow_klass() == CompressedKlassPointers::encode(obj->klass_or_null()), \"upper 32 mark bits must be narrow klass: mark: \" INTPTR_FORMAT \", compressed-klass: \" INTPTR_FORMAT, (intptr_t)mark.narrow_klass(), (intptr_t)CompressedKlassPointers::encode(obj->klass_or_null()));\n+  }\n+#endif\n+#endif\n+  increase_counter(_lds, obj->size());\n+}\n+\n+void HeapObjectStatistics::print(outputStream* out) const {\n+  if (!HeapObjectStats) {\n+    return;\n+  }\n+  if (_num_samples == 0 || _num_objects == 0) {\n+    return;\n+  }\n+\n+  out->print_cr(\"Number of samples:  \" UINT64_FORMAT, _num_samples);\n+  out->print_cr(\"Average number of objects: \" UINT64_FORMAT, _num_objects \/ _num_samples);\n+  out->print_cr(\"Average object size: \" UINT64_FORMAT \" bytes, %.1f words\", (_lds * HeapWordSize) \/ _num_objects, (float) _lds \/ _num_objects);\n+  out->print_cr(\"Average number of hashed objects: \" UINT64_FORMAT \" (%.2f%%)\", _num_ihashed \/ _num_samples, (float) (_num_ihashed * 100.0) \/ _num_objects);\n+  out->print_cr(\"Average number of moved hashed objects: \" UINT64_FORMAT \" (%.2f%%)\", _num_ihashed_moved \/ _num_samples, (float) (_num_ihashed_moved * 100.0) \/ _num_objects);\n+  out->print_cr(\"Average number of locked objects: \" UINT64_FORMAT \" (%.2f%%)\", _num_locked \/ _num_samples, (float) (_num_locked * 100) \/ _num_objects);\n+  out->print_cr(\"Average LDS: \" UINT64_FORMAT \" bytes\", _lds * HeapWordSize \/ _num_samples);\n+  out->print_cr(\"Avg LDS with (assumed) 64bit header: \" UINT64_FORMAT \" bytes (%.1f%%)\", (_lds - _num_objects) * HeapWordSize \/ _num_samples, ((float) _lds - _num_objects) * 100.0 \/ _lds);\n+}\n","filename":"src\/hotspot\/share\/services\/heapObjectStatistics.cpp","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_HEAPOBJECTSTATISTICS_HPP\n+#define SHARE_SERVICES_HEAPOBJECTSTATISTICS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/task.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+\n+class outputStream;\n+\n+class HeapObjectStatisticsTask : public PeriodicTask {\n+public:\n+  HeapObjectStatisticsTask();\n+  void task();\n+};\n+\n+class HeapObjectStatistics : public CHeapObj<mtGC> {\n+private:\n+  static HeapObjectStatistics* _instance;\n+\n+  HeapObjectStatisticsTask _task;\n+  uint64_t _num_samples;\n+  uint64_t _num_objects;\n+  uint64_t _num_ihashed;\n+  uint64_t _num_ihashed_moved;\n+  uint64_t _num_locked;\n+  uint64_t _lds;\n+\n+  static void increase_counter(uint64_t& counter, uint64_t val = 1);\n+\n+  void print(outputStream* out) const;\n+\n+public:\n+  static void initialize();\n+  static void shutdown();\n+\n+  static HeapObjectStatistics* instance();\n+\n+  HeapObjectStatistics();\n+  void start();\n+  void stop();\n+\n+  void begin_sample();\n+  void visit_object(oop object);\n+};\n+\n+#endif \/\/ SHARE_SERVICES_HEAPOBJECTSTATISTICS_HPP\n","filename":"src\/hotspot\/share\/services\/heapObjectStatistics.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -27,0 +27,3 @@\n+import sun.jvm.hotspot.oops.Mark;\n+import sun.jvm.hotspot.runtime.VM;\n+\n@@ -397,1 +400,9 @@\n-    long value = readCInteger(address, getKlassPtrSize(), true);\n+    long value;\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      \/\/ On 64 bit systems, the compressed Klass* is currently read from the mark\n+      \/\/ word. We need to load the whole mark, and shift the upper parts.\n+      value = readCInteger(address, machDesc.getAddressSize(), true);\n+      value = value >>> Mark.getKlassShift();\n+    } else {\n+      value = readCInteger(address, getKlassPtrSize(), true);\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerBase.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -119,7 +119,0 @@\n-  \/\/ Check whether an element of a typeArrayOop with the given type must be\n-  \/\/ aligned 0 mod 8.  The typeArrayOop itself must be aligned at least this\n-  \/\/ strongly.\n-  public static boolean elementTypeShouldBeAligned(BasicType type) {\n-    return type == BasicType.T_DOUBLE || type == BasicType.T_LONG;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/Universe.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,0 +60,12 @@\n+  \/\/ Check whether an element of a typeArrayOop with the given type must be\n+  \/\/ aligned 0 mod 8.  The typeArrayOop itself must be aligned at least this\n+  \/\/ strongly.\n+  private static boolean elementTypeShouldBeAligned(BasicType type) {\n+    if (VM.getVM().isLP64()) {\n+      if (type == BasicType.T_OBJECT || type == BasicType.T_ARRAY) {\n+        return !VM.getVM().isCompressedOopsEnabled();\n+      }\n+    }\n+    return type == BasicType.T_DOUBLE || type == BasicType.T_LONG;\n+  }\n+\n@@ -64,2 +76,2 @@\n-    if (VM.getVM().isCompressedKlassPointersEnabled()) {\n-      headerSize = typeSize;\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      headerSize = lengthOffsetInBytes() + VM.getVM().getIntSize();\n@@ -67,2 +79,6 @@\n-      headerSize = VM.getVM().alignUp(typeSize + VM.getVM().getIntSize(),\n-                                      VM.getVM().getHeapWordSize());\n+      if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+         headerSize = typeSize;\n+      } else {\n+        headerSize = VM.getVM().alignUp(typeSize + VM.getVM().getIntSize(),\n+                                        VM.getVM().getHeapWordSize());\n+      }\n@@ -73,7 +89,7 @@\n-  private static long headerSize(BasicType type) {\n-    if (Universe.elementTypeShouldBeAligned(type)) {\n-       return alignObjectSize(headerSizeInBytes())\/VM.getVM().getHeapWordSize();\n-    } else {\n-      return headerSizeInBytes()\/VM.getVM().getHeapWordSize();\n-    }\n-  }\n+   private static long headerSize(BasicType type) {\n+     if (elementTypeShouldBeAligned(type)) {\n+        return alignObjectSize(headerSizeInBytes())\/VM.getVM().getHeapWordSize();\n+     } else {\n+       return headerSizeInBytes()\/VM.getVM().getHeapWordSize();\n+     }\n+   }\n@@ -81,1 +97,1 @@\n-  private long lengthOffsetInBytes() {\n+  private static long lengthOffsetInBytes() {\n@@ -85,2 +101,2 @@\n-    if (VM.getVM().isCompressedKlassPointersEnabled()) {\n-      lengthOffsetInBytes = typeSize - VM.getVM().getIntSize();\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      lengthOffsetInBytes = Oop.getHeaderSize();\n@@ -88,1 +104,5 @@\n-      lengthOffsetInBytes = typeSize;\n+      if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+        lengthOffsetInBytes = typeSize - VM.getVM().getIntSize();\n+      } else {\n+        lengthOffsetInBytes = typeSize;\n+      }\n@@ -111,1 +131,11 @@\n-    return headerSize(type) * VM.getVM().getHeapWordSize();\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      long typeSizeInBytes = headerSizeInBytes();\n+      if (elementTypeShouldBeAligned(type)) {\n+        VM vm = VM.getVM();\n+        return vm.alignUp(typeSizeInBytes, vm.getVM().getHeapWordSize());\n+      } else {\n+        return typeSizeInBytes;\n+      }\n+    } else {\n+      return headerSize(type) * VM.getVM().getHeapWordSize();\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Array.java","additions":46,"deletions":16,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+        System.out.println(\"base: \" + baseField.getValue().minus(null));\n@@ -77,1 +78,3 @@\n-    return (int)shiftField.getValue();\n+\n+      System.out.println(\"shift: \" + (int)shiftField.getValue());\n+      return (int)shiftField.getValue();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/CompressedKlassPointers.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      return Oop.getHeaderSize();\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Instance.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    hashBitsCompact     = db.lookupLongConstant(\"markWord::hash_bits_compact\").longValue();\n@@ -57,0 +58,4 @@\n+    hashShiftCompact    = db.lookupLongConstant(\"markWord::hash_shift_compact\").longValue();\n+    if (VM.getVM().isLP64()) {\n+      klassShift          = db.lookupLongConstant(\"markWord::klass_shift\").longValue();\n+    }\n@@ -63,0 +68,2 @@\n+    hashMaskCompact     = db.lookupLongConstant(\"markWord::hash_mask_compact\").longValue();\n+    hashMaskCompactInPlace = db.lookupLongConstant(\"markWord::hash_mask_compact_in_place\").longValue();\n@@ -81,0 +88,1 @@\n+  private static long hashBitsCompact;\n@@ -85,0 +93,2 @@\n+  private static long hashShiftCompact;\n+  private static long klassShift;\n@@ -92,0 +102,2 @@\n+  private static long hashMaskCompact;\n+  private static long hashMaskCompactInPlace;\n@@ -105,0 +117,4 @@\n+  public static long getKlassShift() {\n+    return klassShift;\n+  }\n+\n@@ -177,1 +193,5 @@\n-    return Bits.maskBitsLong(value() >> hashShift, hashMask);\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      return Bits.maskBitsLong(value() >> hashShiftCompact, hashMaskCompact);\n+    } else {\n+      return Bits.maskBitsLong(value() >> hashShift, hashMask);\n+    }\n@@ -184,0 +204,6 @@\n+  public Klass getKlass() {\n+    assert(VM.getVM().isCompactObjectHeadersEnabled());\n+    assert(!hasMonitor());\n+    return (Klass)Metadata.instantiateWrapperFor(addr.getCompKlassAddressAt(0));\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -49,3 +49,8 @@\n-    klass      = new MetadataField(type.getAddressField(\"_metadata._klass\"), 0);\n-    compressedKlass  = new NarrowKlassField(type.getAddressField(\"_metadata._compressed_klass\"), 0);\n-    headerSize = type.getSize();\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      Type markType = db.lookupType(\"markWord\");\n+      headerSize = markType.getSize();\n+    } else {\n+      headerSize = type.getSize();\n+      klass      = new MetadataField(type.getAddressField(\"_metadata._klass\"), 0);\n+      compressedKlass  = new NarrowKlassField(type.getAddressField(\"_metadata._compressed_klass\"), 0);\n+    }\n@@ -78,0 +83,10 @@\n+\n+  private static Klass getKlass(Mark mark) {\n+    assert(VM.getVM().isCompactObjectHeadersEnabled());\n+    if (mark.hasMonitor()) {\n+      ObjectMonitor mon = mark.monitor();\n+      mark = mon.header();\n+    }\n+    return mark.getKlass();\n+  }\n+\n@@ -79,1 +94,4 @@\n-    if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+        assert(VM.getVM().isCompressedKlassPointersEnabled());\n+        return getKlass(getMark());\n+    } else if (VM.getVM().isCompressedKlassPointersEnabled()) {\n@@ -150,4 +168,6 @@\n-      if (VM.getVM().isCompressedKlassPointersEnabled()) {\n-        visitor.doMetadata(compressedKlass, true);\n-      } else {\n-        visitor.doMetadata(klass, true);\n+      if (!VM.getVM().isCompactObjectHeadersEnabled()) {\n+        if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+          visitor.doMetadata(compressedKlass, true);\n+        } else {\n+          visitor.doMetadata(klass, true);\n+        }\n@@ -209,1 +229,4 @@\n-    if (VM.getVM().isCompressedKlassPointersEnabled()) {\n+    if (VM.getVM().isCompactObjectHeadersEnabled()) {\n+      Mark mark = new Mark(handle);\n+      return getKlass(mark);\n+    } else if (VM.getVM().isCompressedKlassPointersEnabled()) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Oop.java","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+  private Boolean compactObjectHeadersEnabled;\n@@ -973,0 +974,9 @@\n+  public boolean isCompactObjectHeadersEnabled() {\n+    if (compactObjectHeadersEnabled == null) {\n+        Flag flag = getCommandLineFlag(\"UseCompactObjectHeaders\");\n+        compactObjectHeadersEnabled = (flag == null) ? Boolean.FALSE:\n+             (flag.getBool()? Boolean.TRUE: Boolean.FALSE);\n+    }\n+    return compactObjectHeadersEnabled.booleanValue();\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.jvm.hotspot.oops.Oop;\n@@ -40,20 +41,0 @@\n-  private static AddressField klassField;\n-\n-  static {\n-    VM.registerVMInitializedObserver(new Observer() {\n-        public void update(Observable o, Object data) {\n-          initialize(VM.getVM().getTypeDataBase());\n-        }\n-      });\n-  }\n-\n-  private static void initialize(TypeDataBase db) {\n-    Type type = db.lookupType(\"oopDesc\");\n-\n-    if (VM.getVM().isCompressedKlassPointersEnabled()) {\n-      klassField = type.getAddressField(\"_metadata._compressed_klass\");\n-    } else {\n-      klassField = type.getAddressField(\"_metadata._klass\");\n-    }\n-  }\n-\n@@ -69,5 +50,1 @@\n-      if (VM.getVM().isCompressedKlassPointersEnabled()) {\n-        Metadata.instantiateWrapperFor(oop.getCompKlassAddressAt(klassField.getOffset()));\n-      } else {\n-        Metadata.instantiateWrapperFor(klassField.getValue(oop));\n-      }\n+      Oop.getKlassForOopHandle(oop);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/RobustOopDeterminator.java","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -72,1 +72,2 @@\n-    final int hubOffset = getFieldOffset(\"oopDesc::_metadata._klass\", Integer.class, \"Klass*\");\n+    \/\/ TODO: Lilliput. Probably ok.\n+    final int hubOffset = 4; \/\/ getFieldOffset(\"oopDesc::_metadata._klass\", Integer.class, \"Klass*\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static markWord originalMark() { return markWord(markWord::lock_mask_in_place); }\n+  static markWord originalMark() { return markWord(markWord::unlocked_value); }\n@@ -58,0 +58,4 @@\n+#ifdef _LP64\n+  FlagSetting fs(UseCompactObjectHeaders, false);\n+#endif\n+\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#ifndef _LP64\n@@ -40,0 +41,1 @@\n+#endif\n","filename":"test\/hotspot\/gtest\/oops\/test_typeArrayOop.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+#\n+# Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#\n+# These tests are problematic when +UseCompactObjectHeaders is enabled.\n+# The test exclusions are for the cases when we are sure the tests would fail\n+# for the known and innocuous implementation reasons.\n+#\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList-lilliput.txt","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -174,0 +174,13 @@\n+\n+Lilliput temporary:\n+compiler\/c2\/irTests\/TestVectorizationNotRun.java 8301785 generic-all\n+runtime\/CompressedOops\/CompressedClassPointerEncoding.java#x64-area-beyond-encoding-range-use-xor 8302094 windows-all,macosx-all\n+runtime\/CompressedOops\/CompressedClassPointerEncoding.java#x64-area-partly-within-encoding-range-use-add 8302094 windows-all,macosx-all\n+runtime\/CompressedOops\/CompressedClassPointerEncoding.java#x64-area-within-encoding-range-use-zero 8302094 windows-all,macosx-all\n+runtime\/CompressedOops\/CompressedClassPointerEncoding.java#x64-area-far-out-no-low-bits-use-xor 8302094 windows-all,macosx-all\n+runtime\/CompressedOops\/CompressedClassPointerEncoding.java#x64-area-far-out-with-low-bits-use-add 8302094 windows-all,macosx-all\n+runtime\/CompressedOops\/CompressedClassPointerEncoding.java#aarch64-xor 8302094 windows-all,macosx-all\n+runtime\/CompressedOops\/CompressedClassPointerEncoding.java#aarch64-movk-1 8302094 windows-all,macosx-all\n+runtime\/CompressedOops\/CompressedClassPointerEncoding.java#aarch64-movk-2 8302094 windows-all,macosx-all\n+runtime\/CompressedOops\/CompressedClassPointerEncoding.java#aarch64-movk-3 8302094 windows-all,macosx-all\n+runtime\/CompressedOops\/CompressedClassSpaceSize.java 8302094 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -387,2 +387,0 @@\n- -runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT1.java \\\n- -runtime\/Metaspace\/elastic\/TestMetaspaceAllocationMT2.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,7 @@\n+\/\/ Note Lilliput:\n+\/\/ Tests test that vectorization is used to fill destination byte array if alignment allows. That works in Stock VM\n+\/\/ since for both byte[] and long[] members start at the same offset. It does not work in Lilliput, nor would it work\n+\/\/ in stock if we fix \"8139457: Array bases are aligned at HeapWord granularity\", since bytes start at offset 12, long\n+\/\/ at offset 16.\n+\/\/ For now I just enforce -CompactObjectHeaders.\n+\n@@ -58,1 +65,1 @@\n-            TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+            TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,5 @@\n+\/\/ Note Lilliput:\n+\/\/ Tests rely on array members starting at the same offset, otherwise vectorization does not kick in. Not true\n+\/\/ for Lilliput.\n+\/\/ For now I just enforce -CompactObjectHeaders.\n+\n@@ -81,1 +86,1 @@\n-                                   \"-XX:LoopUnrollLimit=1000\");\n+                                   \"-XX:LoopUnrollLimit=1000\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,5 +36,0 @@\n- *                                 -XX:+UseCompressedOops -XX:-UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n@@ -43,5 +38,0 @@\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:-UseCompressedOops -XX:-UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/OpaqueAccesses.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.arguments;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Platform;\n-\n-\/*\n- * @test\n- * @bug 8015107\n- * @summary Tests that VM prints a warning when -XX:CompressedClassSpaceSize\n- *          is used together with -XX:-UseCompressedClassPointers\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver gc.arguments.TestCompressedClassFlags\n- *\/\n-public class TestCompressedClassFlags {\n-    public static void main(String[] args) throws Exception {\n-        if (Platform.is64bit()) {\n-            OutputAnalyzer output = runJava(\"-XX:CompressedClassSpaceSize=1g\",\n-                                            \"-XX:-UseCompressedClassPointers\",\n-                                            \"-version\");\n-            output.shouldContain(\"warning\");\n-            output.shouldNotContain(\"error\");\n-            output.shouldHaveExitValue(0);\n-        }\n-    }\n-\n-    private static OutputAnalyzer runJava(String ... args) throws Exception {\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(args);\n-        return new OutputAnalyzer(pb.start());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestCompressedClassFlags.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -129,1 +129,3 @@\n-    String compressedClassSpaceSizeArg = \"-XX:CompressedClassSpaceSize=\" + 2 * getCompressedClassSpaceSize();\n+    \/\/ Lilliput: do not assume a max. class space size, since that is subject to change. Instead, use a value slightly smaller\n+    \/\/  than what the parent VM runs with (which is the default size).\n+    String compressedClassSpaceSizeArg = \"-XX:CompressedClassSpaceSize=\" + (getCompressedClassSpaceSize() - 1);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsErgoTools.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        dump_args.addAll(Arrays.asList(new String[] { \"-Xshare:dump\", \"-Xlog:cds\" }));\n+        dump_args.addAll(Arrays.asList(new String[] { \"-Xshare:dump\", \"-Xlog:cds*\", \"-Xlog:metaspace*\" }));\n@@ -64,0 +64,1 @@\n+        output.reportDiagnosticSummary();\n@@ -73,1 +74,1 @@\n-            load_args.addAll(Arrays.asList(new String[] { \"-Xshare:on\", \"-version\" }));\n+            load_args.addAll(Arrays.asList(new String[] { \"-Xshare:on\", \"-Xlog:cds*\", \"-Xlog:metaspace*\", \"-version\" }));\n@@ -77,0 +78,1 @@\n+            output.reportDiagnosticSummary();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestSharedArchiveWithPreTouch.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.test.lib.Platform;\n@@ -75,1 +76,1 @@\n-    private static final int OBJECT_SIZE_HIGH = 3250;\n+    private static final int OBJECT_SIZE_HIGH = Platform.is64bit() ? 3266 : 3258;\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABPromotion.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n- * @run driver gc.metaspace.TestSizeTransitions false -XX:+UseSerialGC\n- * @run driver gc.metaspace.TestSizeTransitions true  -XX:+UseSerialGC\n+ * @run driver gc.metaspace.TestSizeTransitions -XX:+UseSerialGC\n@@ -46,2 +45,1 @@\n- * @run driver gc.metaspace.TestSizeTransitions false -XX:+UseParallelGC\n- * @run driver gc.metaspace.TestSizeTransitions true  -XX:+UseParallelGC\n+ * @run driver gc.metaspace.TestSizeTransitions -XX:+UseParallelGC\n@@ -54,2 +52,1 @@\n- * @run driver gc.metaspace.TestSizeTransitions false -XX:+UseG1GC\n- * @run driver gc.metaspace.TestSizeTransitions true  -XX:+UseG1GC\n+ * @run driver gc.metaspace.TestSizeTransitions -XX:+UseG1GC\n@@ -93,2 +90,2 @@\n-    \/\/ args: <use-coops> <gc-arg>\n-    if (args.length != 2) {\n+    \/\/ args: <gc-arg>\n+    if (args.length != 1) {\n@@ -99,8 +96,1 @@\n-    final boolean useCompressedKlassPointers = Boolean.parseBoolean(args[0]);\n-    final String gcArg = args[1];\n-\n-    if (!hasCompressedKlassPointers && useCompressedKlassPointers) {\n-       \/\/ No need to run this configuration.\n-       System.out.println(\"Skipping test.\");\n-       return;\n-    }\n+    final String gcArg = args[0];\n@@ -109,3 +99,0 @@\n-    if (hasCompressedKlassPointers) {\n-      jvmArgs.add(useCompressedKlassPointers ? \"-XX:+UseCompressedClassPointers\" : \"-XX:-UseCompressedClassPointers\");\n-    }\n@@ -127,1 +114,1 @@\n-    if (useCompressedKlassPointers) {\n+    if (hasCompressedKlassPointers) {\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/TestSizeTransitions.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- *   -Xmx1G -XX:G1HeapRegionSize=8m -XX:MaxGCPauseMillis=1000 gc.stress.TestMultiThreadStressRSet 60 16\n+ *   -Xmx1100M -XX:G1HeapRegionSize=8m -XX:MaxGCPauseMillis=1000 gc.stress.TestMultiThreadStressRSet 60 16\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestMultiThreadStressRSet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+ * @requires vm.debug\n@@ -62,0 +63,37 @@\n+\n+\n+\/* @test id=ccs-on-compact-headers-on\n+ * @summary Run with +UseCCS and +UseCompactObjectHeaders\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.debug\n+ * @requires vm.bits == 64\n+ * @requires vm.flagless\n+ * @run main\/native GTestWrapper --gtest_filter=metaspace* -Xlog:metaspace* -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders -XX:+UseCompressedClassPointers -XX:VerifyMetaspaceInterval=3\n+ *\/\n+\n+\/* @test id=ccs-on-compact-headers-off\n+ * @summary Run with +UseCCS and -UseCompactObjectHeaders\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.debug\n+ * @requires vm.bits == 64\n+ * @requires vm.flagless\n+ * @run main\/native GTestWrapper --gtest_filter=metaspace* -Xlog:metaspace* -XX:+UnlockExperimentalVMOptions -XX:-UseCompactObjectHeaders -XX:+UseCompressedClassPointers -XX:VerifyMetaspaceInterval=3\n+ *\/\n+\n+\/* @test id=ccs-off\n+ * @summary Run with -UseCCS\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @requires vm.debug\n+ * @requires vm.bits == 64\n+ * @requires vm.flagless\n+ * @run main\/native GTestWrapper --gtest_filter=metaspace* -Xlog:metaspace* -XX:-UseCompressedClassPointers -XX:VerifyMetaspaceInterval=3\n+ *\/\n+\n+\n+\n","filename":"test\/hotspot\/jtreg\/gtest\/MetaspaceGtests.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -30,11 +30,0 @@\n-\n-\/* @test\n- * @bug 8264008\n- * @summary Run metaspace utils related gtests with compressed class pointers off\n- * @requires vm.bits == 64\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.xml\n- * @requires vm.flagless\n- * @run main\/native GTestWrapper --gtest_filter=MetaspaceUtils* -XX:-UseCompressedClassPointers\n- *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/MetaspaceUtilsGtests.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @library \/test\/lib \/\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI BaseOffsets\n+ *\/\n+\/*\n+ * @test id=no-coops\n+ * @library \/test\/lib \/\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseCompressedOops BaseOffsets\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import jdk.internal.misc.Unsafe;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class BaseOffsets {\n+\n+    static class LIClass {\n+        public int i;\n+    }\n+\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+  \/\/ @0:  8 byte header,  @8: int field\n+    static final long INT_OFFSET;\n+    static final int  INT_ARRAY_OFFSET;\n+    static final int  LONG_ARRAY_OFFSET;\n+    static {\n+        if (!Platform.is64bit() || WB.getBooleanVMFlag(\"UseCompactObjectHeaders\")) {\n+            INT_OFFSET = 8;\n+            INT_ARRAY_OFFSET = 12;\n+            LONG_ARRAY_OFFSET = 16;\n+        } else if (WB.getBooleanVMFlag(\"UseCompressedClassPointers\")) {\n+            INT_OFFSET = 12;\n+            INT_ARRAY_OFFSET = 16;\n+            LONG_ARRAY_OFFSET = 16;\n+        } else {\n+            INT_OFFSET = 16;\n+            INT_ARRAY_OFFSET = 20;\n+            LONG_ARRAY_OFFSET = 24;\n+        }\n+    }\n+\n+    static public void main(String[] args) {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        Class c = LIClass.class;\n+        Field[] fields = c.getFields();\n+        for (int i = 0; i < fields.length; i++) {\n+            long offset = unsafe.objectFieldOffset(fields[i]);\n+            if (fields[i].getType() == int.class) {\n+                Asserts.assertEquals(offset, INT_OFFSET, \"Misplaced int field\");\n+            } else {\n+                Asserts.fail(\"Unexpected field type\");\n+            }\n+        }\n+\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), INT_ARRAY_OFFSET,  \"Misplaced boolean array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    INT_ARRAY_OFFSET,  \"Misplaced byte    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    INT_ARRAY_OFFSET,  \"Misplaced char    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   INT_ARRAY_OFFSET,  \"Misplaced short   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     INT_ARRAY_OFFSET,  \"Misplaced int     array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    LONG_ARRAY_OFFSET, \"Misplaced long    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   INT_ARRAY_OFFSET,  \"Misplaced float   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  LONG_ARRAY_OFFSET, \"Misplaced double  array base\");\n+        boolean narrowOops = System.getProperty(\"java.vm.compressedOopsMode\") != null ||\n+                             !Platform.is64bit();\n+        int expected_objary_offset = narrowOops ? INT_ARRAY_OFFSET : LONG_ARRAY_OFFSET;\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(Object[].class),  expected_objary_offset, \"Misplaced object  array base\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/BaseOffsets.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -41,1 +41,0 @@\n- * @run main\/othervm -XX:+UseCompressedOops -XX:-UseCompressedClassPointers FieldDensityTest\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/FieldDensityTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -32,1 +32,3 @@\n- * @run main\/othervm -XX:+UseCompressedClassPointers -XX:-UseEmptySlotsInSupers OldLayoutCheck\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseCompressedClassPointers -XX:-UseEmptySlotsInSupers OldLayoutCheck\n@@ -38,1 +40,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/\n@@ -41,1 +43,3 @@\n- * @run main\/othervm -XX:-UseEmptySlotsInSupers OldLayoutCheck\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:-UseEmptySlotsInSupers OldLayoutCheck\n@@ -51,0 +55,1 @@\n+import jdk.test.whitebox.WhiteBox;\n@@ -59,4 +64,15 @@\n-    \/\/ 32-bit VMs: @0:  8 byte header,  @8: long field, @16:  int field\n-    \/\/ 64-bit VMs: @0: 12 byte header, @12:  int field, @16: long field\n-    static final long INT_OFFSET  = Platform.is64bit() ? 12L : 16L;\n-    static final long LONG_OFFSET = Platform.is64bit() ? 16L :  8L;\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    \/\/ 32-bit VMs\/compact headers: @0:  8 byte header,  @8: long field, @16:  int field\n+    \/\/ 64-bit VMs:                 @0: 12 byte header, @12:  int field, @16: long field\n+    static final long INT_OFFSET;\n+    static final long LONG_OFFSET;\n+    static {\n+      if (!Platform.is64bit() || WB.getBooleanVMFlag(\"UseCompactObjectHeaders\")) {\n+        INT_OFFSET = 16L;\n+        LONG_OFFSET = 8L;\n+      } else {\n+        INT_OFFSET = 12L;\n+        LONG_OFFSET = 16L;\n+      }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/OldLayoutCheck.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -51,11 +51,1 @@\n- * @test id=test-64bit-noccs\n- * @summary Test the VM.metaspace command\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run main\/othervm -Dwithout-compressed-class-space -XX:MaxMetaspaceSize=201M -Xmx100M -XX:-UseCompressedOops -XX:-UseCompressedClassPointers PrintMetaspaceDcmd\n- *\/\n-\n- \/*\n- * @test id=test-nospecified\n+ * @test id=test-64bit-compact-headers\n@@ -64,0 +54,1 @@\n+ * @requires vm.debug == true\n@@ -67,1 +58,1 @@\n- * @run main\/othervm -Dno-specified-flag -Xmx100M -XX:-UseCompressedOops -XX:-UseCompressedClassPointers PrintMetaspaceDcmd\n+ * @run main\/othervm -Dwith-compressed-class-space -XX:+UnlockExperimentalVMOptions -XX:+UseCompactObjectHeaders -XX:MaxMetaspaceSize=201M -Xmx100M -XX:+UseCompressedOops -XX:+UseCompressedClassPointers -XX:+UnlockDiagnosticVMOptions -XX:+MetaspaceGuardAllocations PrintMetaspaceDcmd\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/PrintMetaspaceDcmd.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test CdsDifferentCompactObjectHeaders\n+ * @summary Testing CDS (class data sharing) using opposite compact object header settings.\n+ *          Using different compact bject headers setting for each dump\/load pair.\n+ *          This is a negative test; using compact header setting for loading that\n+ *          is different from compact headers for creating a CDS file\n+ *          should fail when loading.\n+ * @requires vm.cds\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @run driver CdsDifferentCompactObjectHeaders\n+ *\/\n+\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Platform;\n+\n+public class CdsDifferentCompactObjectHeaders {\n+\n+    public static void main(String[] args) throws Exception {\n+        createAndLoadSharedArchive(true, false);\n+        createAndLoadSharedArchive(false, true);\n+    }\n+\n+    \/\/ Parameters are object alignment expressed in bytes\n+    private static void\n+    createAndLoadSharedArchive(boolean createCompactHeaders, boolean loadCompactHeaders)\n+    throws Exception {\n+        String createCompactHeadersArg = \"-XX:\" + (createCompactHeaders ? \"+\" : \"-\") + \"UseCompactObjectHeaders\";\n+        String loadCompactHeadersArg   = \"-XX:\" + (loadCompactHeaders   ? \"+\" : \"-\") + \"UseCompactObjectHeaders\";\n+        String expectedErrorMsg =\n+            String.format(\n+            \"The shared archive file's UseCompactObjectHeaders setting (%s)\" +\n+            \" does not equal the current UseCompactObjectHeaders setting (%s)\",\n+            createCompactHeaders ? \"enabled\" : \"disabled\",\n+            loadCompactHeaders   ? \"enabled\" : \"disabled\");\n+\n+        CDSTestUtils.createArchiveAndCheck(\"-XX:+UnlockExperimentalVMOptions\", createCompactHeadersArg);\n+\n+        OutputAnalyzer out = CDSTestUtils.runWithArchive(\"-Xlog:cds\", \"-XX:+UnlockExperimentalVMOptions\", loadCompactHeadersArg);\n+        CDSTestUtils.checkExecExpectError(out, 1, expectedErrorMsg);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CdsDifferentCompactObjectHeaders.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -48,1 +48,1 @@\n-      processArgs.add(\"-XX:MaxMetaspaceSize=3m\");\n+      processArgs.add(\"-XX:MaxMetaspaceSize=2m\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/MaxMetaspaceSize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-        testTable.add( new TestVector(\"-XX:+UseCompressedClassPointers\", \"-XX:-UseCompressedClassPointers\",\n-           \"The saved state of UseCompressedOops and UseCompressedClassPointers is different from runtime, CDS will be disabled.\", 1) );\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CommandLineFlagComboNegative.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-        public boolean useCompressedClassPointers;   \/\/ UseCompressedClassPointers\n@@ -52,1 +51,1 @@\n-        public ConfArg(boolean useCompressedOops, boolean useCompressedClassPointers, String msg, int code) {\n+        public ConfArg(boolean useCompressedOops, String msg, int code) {\n@@ -54,1 +53,0 @@\n-            this.useCompressedClassPointers = useCompressedClassPointers;\n@@ -69,1 +67,1 @@\n-            *          UseCompressedOops   UseCompressedClassPointers  Result\n+            *          UseCompressedOops   Result\n@@ -71,5 +69,3 @@\n-            *    dump: on                  on\n-            *    test: on                  on                          Pass\n-            *          on                  off                         Fail\n-            *          off                 on                          Fail\n-            *          off                 off                         Fail\n+            *    dump: on\n+            *    test: on                  Pass\n+            *          off                 Fail\n@@ -77,15 +73,3 @@\n-            *    dump: on                  off\n-            *    test: on                  off                         Pass\n-            *          on                  on                          Fail\n-            *          off                 on                          Pass\n-            *          off                 off                         Fail\n-            *    3.\n-            *    dump: off                 on\n-            *    test: off                 on                          Pass\n-            *          on                  on                          Fail\n-            *          on                  off                         Fail\n-            *    4.\n-            *    dump: off                 off\n-            *    test: off                 off                         Pass\n-            *          on                  on                          Fail\n-            *          on                  off                         Fail\n+            *    dump: off\n+            *    test: off                 Pass\n+            *          on                  Fail\n@@ -94,1 +78,1 @@\n-            if (dumpArg.useCompressedOops && dumpArg.useCompressedClassPointers) {\n+            if (dumpArg.useCompressedOops) {\n@@ -96,1 +80,1 @@\n-                    .add(new ConfArg(true, true, HELLO_STRING, PASS));\n+                    .add(new ConfArg(true, HELLO_STRING, PASS));\n@@ -98,15 +82,1 @@\n-                    .add(new ConfArg(true, false, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(false, true, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(false, false, EXEC_ABNORMAL_MSG, FAIL));\n-\n-            }  else if(dumpArg.useCompressedOops && !dumpArg.useCompressedClassPointers) {\n-                execArgs\n-                    .add(new ConfArg(true, false, HELLO_STRING, PASS));\n-                execArgs\n-                    .add(new ConfArg(true, true, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(false, true, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(false, false, EXEC_ABNORMAL_MSG, FAIL));\n+                    .add(new ConfArg(false, EXEC_ABNORMAL_MSG, FAIL));\n@@ -114,3 +84,1 @@\n-            } else if (!dumpArg.useCompressedOops && dumpArg.useCompressedClassPointers) {\n-                execArgs\n-                    .add(new ConfArg(false, true, HELLO_STRING, PASS));\n+            } else if (!dumpArg.useCompressedOops) {\n@@ -118,1 +86,1 @@\n-                    .add(new ConfArg(true, true, EXEC_ABNORMAL_MSG, FAIL));\n+                    .add(new ConfArg(false, HELLO_STRING, PASS));\n@@ -120,8 +88,1 @@\n-                    .add(new ConfArg(true, false, EXEC_ABNORMAL_MSG, FAIL));\n-            } else if (!dumpArg.useCompressedOops && !dumpArg.useCompressedClassPointers) {\n-                execArgs\n-                    .add(new ConfArg(false, false, HELLO_STRING, PASS));\n-                execArgs\n-                    .add(new ConfArg(true, true, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(true, false, EXEC_ABNORMAL_MSG, FAIL));\n+                    .add(new ConfArg(true, EXEC_ABNORMAL_MSG, FAIL));\n@@ -137,5 +98,0 @@\n-    public static String getCompressedClassPointersArg(boolean on) {\n-        if (on) return \"-XX:+UseCompressedClassPointers\";\n-        else    return \"-XX:-UseCompressedClassPointers\";\n-    }\n-\n@@ -147,5 +103,1 @@\n-            .add(new RunArg(new ConfArg(true, true, null, PASS)));\n-        runList\n-            .add(new RunArg(new ConfArg(true, false, null, PASS)));\n-        runList\n-            .add(new RunArg(new ConfArg(false, true, null, PASS)));\n+            .add(new RunArg(new ConfArg(true, null, PASS)));\n@@ -153,1 +105,1 @@\n-            .add(new RunArg(new ConfArg(false, false, null, PASS)));\n+            .add(new RunArg(new ConfArg(false, null, PASS)));\n@@ -165,1 +117,0 @@\n-                      getCompressedClassPointersArg(t.dumpArg.useCompressedClassPointers),\n@@ -178,1 +129,0 @@\n-                                      getCompressedClassPointersArg(c.useCompressedClassPointers),\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCombinedCompressedFlags.java","additions":16,"deletions":66,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -92,13 +92,1 @@\n-         System.out.println(\"3. Run with -UseCompressedOops -UseCompressedClassPointers\");\n-         out = TestCommon\n-                   .exec(helloJar,\n-                         \"-XX:+UseSerialGC\",\n-                         \"-XX:-UseCompressedOops\",\n-                         \"-XX:-UseCompressedClassPointers\",\n-                         \"-Xlog:cds\",\n-                         \"Hello\");\n-         out.shouldContain(UNABLE_TO_USE_ARCHIVE);\n-         out.shouldContain(ERR_MSG);\n-         out.shouldHaveExitValue(1);\n-\n-         System.out.println(\"4. Run with -UseCompressedOops +UseCompressedClassPointers\");\n+         System.out.println(\"3. Run with -UseCompressedOops +UseCompressedClassPointers\");\n@@ -115,13 +103,1 @@\n-         System.out.println(\"5. Run with +UseCompressedOops -UseCompressedClassPointers\");\n-         out = TestCommon\n-                   .exec(helloJar,\n-                         \"-XX:+UseSerialGC\",\n-                         \"-XX:+UseCompressedOops\",\n-                         \"-XX:-UseCompressedClassPointers\",\n-                         \"-Xlog:cds\",\n-                         \"Hello\");\n-         out.shouldContain(UNABLE_TO_USE_ARCHIVE);\n-         out.shouldContain(ERR_MSG);\n-         out.shouldHaveExitValue(1);\n-\n-         System.out.println(\"6. Run with +UseCompressedOops +UseCompressedClassPointers\");\n+         System.out.println(\"4. Run with +UseCompressedOops +UseCompressedClassPointers\");\n@@ -139,12 +115,1 @@\n-         System.out.println(\"7. Dump with -UseCompressedOops -UseCompressedClassPointers\");\n-         out = TestCommon\n-                   .dump(helloJar,\n-                         new String[] {\"Hello\"},\n-                         \"-XX:+UseSerialGC\",\n-                         \"-XX:-UseCompressedOops\",\n-                         \"-XX:+UseCompressedClassPointers\",\n-                         \"-Xlog:cds\");\n-         out.shouldContain(\"Dumping shared data to file:\");\n-         out.shouldHaveExitValue(0);\n-\n-         System.out.println(\"8. Run with ZGC\");\n+         System.out.println(\"5. Run with ZGC\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestZGCWithCDS.java","additions":3,"deletions":38,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                       Platform.is64bit() ? 549755813632L: 4294967168L);\n+                        Platform.is64bit() ? 549755813632L: 4294967168L);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,2 +134,1 @@\n-        runCheck(new String[] {\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-UseCompressedClassPointers\"},\n-                 BadFailOnConstraint.create(Loads.class, \"load()\", 1, 1, \"Load\"),\n+        runCheck(BadFailOnConstraint.create(Loads.class, \"load()\", 1, 1, \"Load\"),\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = roundUp(8, OBJ_ALIGN);\n@@ -382,1 +382,1 @@\n-        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = roundUp(8, OBJ_ALIGN);\n@@ -392,1 +392,1 @@\n-        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = roundUp(8, OBJ_ALIGN);\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,2 @@\n-        int objectHeaderSize = bytesPerWord * 3; \/\/ length will be aligned on 64 bits\n+        \/\/ length will be in klass-gap on 64 bits, extra field on 32 bits.\n+        int objectHeaderSize = bytesPerWord * (runsOn32Bit ? 3 : 2);\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/objectcount\/ObjectCountEventVerifier.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -673,1 +673,5 @@\n-                \"CreateCoredumpOnCrash\"\n+                \"CreateCoredumpOnCrash\",\n+                \/\/ experimental features unlocking flag does not affect behavior\n+                \"UnlockExperimentalVMOptions\",\n+                \/\/ all compact headers settings should run flagless tests\n+                \"UseCompactObjectHeaders\"\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+\n+\n+jdk\/jshell\/ToolTabSnippetTest.java 1234567 generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}