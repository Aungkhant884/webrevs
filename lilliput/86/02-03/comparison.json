{"files":[{"patch":"@@ -35,0 +35,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/binList.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/ostream.hpp\"\n@@ -74,0 +75,5 @@\n+void FreeBlocks::print_on(outputStream* st) const {\n+  st->print(\"small_blocks: %u blocks, \" SIZE_FORMAT \" words; tree: %u nodes, \" SIZE_FORMAT \" words.\",\n+            _small_blocks.count(), _small_blocks.total_size(), _tree.count(), _tree.total_size());\n+}\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeBlocks.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,0 +113,2 @@\n+  void print_on(outputStream* st) const;\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeBlocks.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -557,2 +557,2 @@\n-  st->print_cr(\"sm %s: %d chunks, total word size: \" SIZE_FORMAT \", committed word size: \" SIZE_FORMAT, _name,\n-               _chunks.count(), _chunks.calc_word_size(), _chunks.calc_committed_word_size());\n+  st->print_cr(\"Arena @\" PTR_FORMAT \" (%s): %d chunks, total word size: \" SIZE_FORMAT \", committed word size: \" SIZE_FORMAT,\n+               p2i(this), _name, _chunks.count(), _chunks.calc_word_size(), _chunks.calc_committed_word_size());\n@@ -561,2 +561,8 @@\n-  st->print_cr(\"growth-policy \" PTR_FORMAT \", lock \" PTR_FORMAT \", cm \" PTR_FORMAT \", fbl \" PTR_FORMAT,\n-                p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));\n+  st->print(\"growth-policy \" PTR_FORMAT \", lock \" PTR_FORMAT \", cm \" PTR_FORMAT \", fbl \" PTR_FORMAT,\n+             p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));\n+  if (_fbl) {\n+    st->print(\" (\");\n+    _fbl->print_on(st);\n+    st->print(\")\");\n+  }\n+  st->cr();\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -799,3 +799,1 @@\n-\/\/ test_with_chunk_turnover: if true, we test allocation for an arena that allocates multiple chunks.\n-\/\/ if false, we test allocation for one gigantic chunk (the easier, better predictable scenario).\n-static void test_allocate_for_klass(bool test_with_chunk_turnover) {\n+static void test_allocate_for_klass_repeat_random(bool test_with_chunk_turnover) {\n@@ -815,2 +813,0 @@\n-  \/\/ The different MetaspaceType will cause us to exercise different chunk allocation policies and\n-  \/\/ exercise allocate_for_klass with chunk turnover\n@@ -818,5 +814,13 @@\n-  MetaspaceTestArena* arena = context.create_arena(\n-      test_with_chunk_turnover ?\n-          Metaspace::ReflectionMetaspaceType : \/\/ starts with a small chunk, working itself up\n-          Metaspace::BootMetaspaceType         \/\/ starts with a big chunk\n-          );\n+\n+  \/\/ - If we are to allocate from one chunk (test_with_chunk_turnover=false), we use BootMetaspaceType\n+  \/\/   policy for the arena; that will cause the arena to allocate one gigantic chunk right at the start.\n+  \/\/ - If we are to allocate from different chunks (test_with_chunk_turnover=true), we use\n+  \/\/   ClassMirrorHolderMetaspaceType, which is the most fine-granular growth policy (see metaspaceAllocationGrowthPolicy.cpp).\n+  \/\/   In addition, we alternate allocations between two arenas to prevent chunks from growing in-place.\n+  MetaspaceTestArena* arenas[2];\n+  if (test_with_chunk_turnover) {\n+    arenas[0] = context.create_arena(Metaspace::ClassMirrorHolderMetaspaceType);\n+    arenas[1] = context.create_arena(Metaspace::ClassMirrorHolderMetaspaceType);\n+  } else {\n+    arenas[0] = arenas[1] = context.create_arena(Metaspace::BootMetaspaceType);\n+  }\n@@ -828,4 +832,2 @@\n-  \/\/ We allocate blocks that are always < 1 klass_slot_size_words in size. Therefore we can exactly determine\n-  \/\/ the remainder size regardless of the underlying chunk geometry (since one slot is always smaller than\n-  \/\/ the smallest chunk)\n-  RandSizeGenerator rgen(1 + sizeof(Klass) \/ BytesPerWord, klass_slot_size_words);\n+  \/\/ We allocate blocks with a size distribution between 1 and 3 class space slots.\n+  RandSizeGenerator rgen(klass_size_words, 3 * klass_slot_size_words);\n@@ -834,5 +836,4 @@\n-  size_t last_word_size = 0;\n-  size_t expected_used_words = 0;\n-  size_t expected_freeblock_words = 0;\n-  uintx expected_freeblock_num = 0;\n-  for (int i = 0; i < 1000; i++) {\n+  const int num_allocations = 10 ;\n+  for (int i = 0; i < num_allocations; i++) {\n+    MetaspaceTestArena* const arena = arenas[i % 2]; \/\/ alternate between arenas.\n+\n@@ -840,1 +841,0 @@\n-    assert(word_size <= klass_slot_size_words && word_size >= klass_size_words, \"Sanity\");\n@@ -847,9 +847,0 @@\n-    const size_t remainder_last_block = last_word_size > 0 ? klass_slot_size_words - last_word_size : 0;\n-    expected_used_words += (word_size + remainder_last_block);\n-\n-    if (remainder_last_block >= FreeBlocks::MinWordSize) {\n-      expected_freeblock_words += remainder_last_block;\n-      expected_freeblock_num++;\n-    }\n-\n-    last_word_size = word_size;\n@@ -858,1 +849,1 @@\n-  \/\/ Test\n+  \/\/ Sanity check sizes.\n@@ -860,11 +851,4 @@\n-  arena->add_to_statistics(&stats);\n-\n-  \/\/ Check size of salvaged space.\n-  \/\/ Note: due to chunk turnover, exact numbers for used\/salvaged can be lower (because on chunk turnover, only *committed*\n-  \/\/ space of old chunk is salvaged). Predicting that gets intricate and makes the test brittle, therefore I just require that\n-  \/\/ we are within 30% of the target.\n-  const size_t expected_used_words_min = calc_envelope_min(expected_used_words, 0.3f);\n-  const size_t expected_used_words_max = calc_envelope_max(expected_used_words, 0.3f);\n-\n-  const size_t expected_freeblock_words_min = calc_envelope_min(expected_freeblock_words, 0.3f);\n-  const size_t expected_freeblock_words_max = calc_envelope_max(expected_freeblock_words, 0.3f);\n+  arenas[0]->add_to_statistics(&stats);\n+  if (arenas[0] != arenas[1]) {\n+    arenas[1]->add_to_statistics(&stats);\n+  }\n@@ -872,2 +856,3 @@\n-  const uintx expected_freeblock_num_min = calc_envelope_min(expected_freeblock_num, 0.3f);\n-  const uintx expected_freeblock_num_max = calc_envelope_max(expected_freeblock_num, 0.3f);\n+  \/\/ When the arena does a chunk turnover, it salvages the space of the old chunk that is *committed*, which may\n+  \/\/ not be the whole chunk. In addition, it cannot salvage blocks that are smaller than FreeBlocks min word size.\n+  \/\/ All of that makes for some fuzziness when estimating usage.\n@@ -875,2 +860,2 @@\n-  EXPECT_GE(stats.totals()._used_words, expected_used_words_min);\n-  EXPECT_LE(stats.totals()._used_words, expected_used_words_max);\n+  EXPECT_GE(stats.totals()._used_words, allocated_words);\n+  EXPECT_LE(stats.totals()._used_words, num_allocations * (3 * klass_slot_size_words));\n@@ -878,2 +863,3 @@\n-  EXPECT_GE(stats._free_blocks_word_size, expected_freeblock_words_min);\n-  EXPECT_LE(stats._free_blocks_word_size, expected_freeblock_words_max);\n+  const size_t used_but_not_allocated = stats.totals()._used_words - allocated_words;\n+  EXPECT_GE(stats._free_blocks_word_size, (uintx)1);\n+  EXPECT_LE(stats._free_blocks_word_size, used_but_not_allocated);\n@@ -881,2 +867,2 @@\n-  EXPECT_GE(stats._free_blocks_num, expected_freeblock_num_min);\n-  EXPECT_LE(stats._free_blocks_num, expected_freeblock_num_max);\n+  EXPECT_GE(stats._free_blocks_num, (uintx)1);\n+  EXPECT_LE(stats._free_blocks_num, (uintx)num_allocations * 2);\n@@ -884,4 +870,3 @@\n-  \/\/ Now check that we can allocate the salvaged space via allocate_from_freeblocks_only;\n-  size_t allocated_from_fbl = 0;\n-  for (MetaWord* p = arena->allocate_from_freeblocks_only(2); p != nullptr; p = arena->allocate_from_freeblocks_only(2)) {\n-    allocated_from_fbl += 2;\n+  delete arenas[0];\n+  if (arenas[0] != arenas[1]) {\n+    delete arenas[1];\n@@ -889,6 +874,0 @@\n-\n-  EXPECT_GE(allocated_from_fbl, expected_freeblock_words_min);\n-  EXPECT_LE(allocated_from_fbl, expected_freeblock_words_max);\n-\n-  delete arena;\n-\n@@ -897,2 +876,2 @@\n-TEST_VM(metaspace, MetaspaceArena_test_klass_allocation_1) { test_allocate_for_klass(Metaspace::StandardMetaspaceType); }\n-TEST_VM(metaspace, MetaspaceArena_test_klass_allocation_2) { test_allocate_for_klass(Metaspace::BootMetaspaceType); }\n+TEST_VM(metaspace, MetaspaceArena_test_klass_allocation_random_one_chunk)    { test_allocate_for_klass_repeat_random(false); }\n+TEST_VM(metaspace, MetaspaceArena_test_klass_allocation_random_many_chunks)  { test_allocate_for_klass_repeat_random(true); }\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":40,"deletions":61,"binary":false,"changes":101,"status":"modified"}]}