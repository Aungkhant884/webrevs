{"files":[{"patch":"@@ -15,0 +15,4 @@\n+concurrency:\n+  group: ${{ github.workflow }}-${{ github.ref }}\n+  cancel-in-progress: true\n+\n@@ -187,1 +191,0 @@\n-          --with-version-build=0\n@@ -205,2 +208,2 @@\n-            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\n@@ -312,2 +315,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}\"\n@@ -317,2 +320,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}\"\n@@ -322,1 +325,1 @@\n-          imageroot=`find ${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }} -name release -type f`\n+          imageroot=`find ${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }} -name release -type f`\n@@ -328,1 +331,1 @@\n-          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}\n@@ -471,2 +474,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin\"\n-          tar -xf \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin.tar.gz\" -C \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin\"\n+          mkdir -p \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin\"\n+          tar -xf \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin.tar.gz\" -C \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin\"\n@@ -476,1 +479,1 @@\n-          build_jdk_root=`find ${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin -name release -type f`\n+          build_jdk_root=`find ${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin -name release -type f`\n@@ -545,1 +548,0 @@\n-          --with-version-build=0\n@@ -645,1 +647,0 @@\n-          --with-version-build=0\n@@ -663,2 +664,2 @@\n-            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\n@@ -771,2 +772,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}\"\n@@ -776,2 +777,2 @@\n-          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}\"\n@@ -781,1 +782,1 @@\n-          imageroot=`find ${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }} -name release -type f`\n+          imageroot=`find ${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }} -name release -type f`\n@@ -787,1 +788,1 @@\n-          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}\n@@ -924,1 +925,0 @@\n-          --with-version-build=0\n@@ -1037,1 +1037,0 @@\n-          --with-version-build=0\n@@ -1057,3 +1056,3 @@\n-            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}.zip\n-            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\n+            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}.zip\n+            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\n@@ -1179,2 +1178,2 @@\n-          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}.zip\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}.zip\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}\"\n@@ -1184,2 +1183,2 @@\n-          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols\"\n-          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols\"\n+          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols\"\n+          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols\"\n@@ -1189,2 +1188,2 @@\n-          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}\"\n@@ -1193,1 +1192,1 @@\n-        run: echo (\"imageroot=\" + (Get-ChildItem -Path $HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }} -Filter release -Recurse -ErrorAction SilentlyContinue -Force).DirectoryName) | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8\n+        run: echo (\"imageroot=\" + (Get-ChildItem -Path $HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }} -Filter release -Recurse -ErrorAction SilentlyContinue -Force).DirectoryName) | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8\n@@ -1201,1 +1200,1 @@\n-          $env:TEST_IMAGE_DIR = cygpath \"$HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}\" ;\n+          $env:TEST_IMAGE_DIR = cygpath \"$HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}\" ;\n@@ -1345,1 +1344,0 @@\n-          --with-version-build=0\n@@ -1363,2 +1361,2 @@\n-            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\n@@ -1449,1 +1447,0 @@\n-          --with-version-build=0\n@@ -1467,2 +1464,2 @@\n-            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-aarch64_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-aarch64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-aarch64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-aarch64_bin-tests${{ matrix.artifact }}.tar.gz\n@@ -1575,2 +1572,2 @@\n-          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}\"\n@@ -1580,2 +1577,2 @@\n-          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}\"\n+          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}\"\n@@ -1591,1 +1588,1 @@\n-          imageroot=`find ${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin${{ matrix.artifact }} -name release -type f`\n+          imageroot=`find ${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }} -name release -type f`\n@@ -1597,1 +1594,1 @@\n-          TEST_IMAGE_DIR=${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_macos-x64_bin-tests${{ matrix.artifact }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}\n","filename":".github\/workflows\/submit.yml","additions":44,"deletions":47,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1202,3 +1202,0 @@\n-reg_class p0_reg(P0);\n-reg_class p1_reg(P1);\n-\n@@ -1859,0 +1856,4 @@\n+  if (VM_Version::use_rop_protection()) {\n+    st->print(\"ldr zr, [lr]\\n\\t\");\n+    st->print(\"pacia  lr, rfp\\n\\t\");\n+  }\n@@ -1967,0 +1968,4 @@\n+  if (VM_Version::use_rop_protection()) {\n+    st->print(\"autia lr, rfp\\n\\t\");\n+    st->print(\"ldr zr, [lr]\\n\\t\");\n+  }\n@@ -3207,0 +3212,5 @@\n+  enc_class aarch64_enc_stlrb0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlrb);\n+  %}\n+\n@@ -3212,0 +3222,5 @@\n+  enc_class aarch64_enc_stlrh0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlrh);\n+  %}\n+\n@@ -3217,0 +3232,4 @@\n+  enc_class aarch64_enc_stlrw0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlrw);\n+  %}\n@@ -3307,0 +3326,5 @@\n+  enc_class aarch64_enc_stlr0(memory mem) %{\n+    MOV_VOLATILE(zr, $mem$$base, $mem$$index, $mem$$scale, $mem$$disp,\n+                 rscratch1, stlr);\n+  %}\n+\n@@ -5690,18 +5714,0 @@\n-operand pRegGov_P0()\n-%{\n-  constraint(ALLOC_IN_RC(p0_reg));\n-  match(RegVectMask);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n-operand pRegGov_P1()\n-%{\n-  constraint(ALLOC_IN_RC(p1_reg));\n-  match(RegVectMask);\n-  op_cost(0);\n-  format %{ %}\n-  interface(REG_INTER);\n-%}\n-\n@@ -8302,0 +8308,12 @@\n+instruct storeimmB0_volatile(immI0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreB mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrb  zr, $mem\\t# byte\" %}\n+\n+  ins_encode(aarch64_enc_stlrb0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8315,0 +8333,12 @@\n+instruct storeimmC0_volatile(immI0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreC mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrh  zr, $mem\\t# short\" %}\n+\n+  ins_encode(aarch64_enc_stlrh0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8329,0 +8359,12 @@\n+instruct storeimmI0_volatile(immI0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem(StoreI mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrw  zr, $mem\\t# int\" %}\n+\n+  ins_encode(aarch64_enc_stlrw0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8342,0 +8384,12 @@\n+instruct storeimmL0_volatile(immL0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreL mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlr  zr, $mem\\t# int\" %}\n+\n+  ins_encode(aarch64_enc_stlr0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8355,0 +8409,12 @@\n+instruct storeimmP0_volatile(immP0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreP mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlr  zr, $mem\\t# ptr\" %}\n+\n+  ins_encode(aarch64_enc_stlr0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -8368,0 +8434,12 @@\n+instruct storeimmN0_volatile(immN0 zero, \/* sync_memory*\/indirect mem)\n+%{\n+  match(Set mem (StoreN mem zero));\n+\n+  ins_cost(VOLATILE_REF_COST);\n+  format %{ \"stlrw  zr, $mem\\t# compressed ptr\" %}\n+\n+  ins_encode(aarch64_enc_stlrw0(mem));\n+\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n@@ -16689,1 +16767,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n@@ -16699,1 +16777,1 @@\n-                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::UU);\n+                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::UU);\n@@ -16707,1 +16785,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n@@ -16716,1 +16794,1 @@\n-                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::LL);\n+                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::LL);\n@@ -16725,1 +16803,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n@@ -16736,1 +16814,1 @@\n-                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::UL);\n+                      $vtmp3$$FloatRegister, StrIntrinsicNode::UL);\n@@ -16745,1 +16823,1 @@\n-  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n+  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n@@ -16756,1 +16834,1 @@\n-                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::LU);\n+                      $vtmp3$$FloatRegister,StrIntrinsicNode::LU);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":107,"deletions":29,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -392,0 +392,1 @@\n+    __ authenticate_return_address(exception_pc, rscratch1);\n@@ -440,0 +441,1 @@\n+  __ protect_return_address(exception_pc, rscratch1);\n@@ -455,0 +457,1 @@\n+  __ protect_return_address(r0, rscratch1);\n@@ -503,0 +506,2 @@\n+  __ mov(r3, lr);\n+  __ protect_return_address();\n@@ -506,1 +511,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), rthread, lr);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), rthread, r3);\n@@ -519,0 +524,1 @@\n+  __ authenticate_return_address();\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1142,0 +1142,2 @@\n+  strip_return_address(); \/\/ This might happen within a stack frame.\n+  protect_return_address();\n@@ -1155,0 +1157,1 @@\n+  authenticate_return_address();\n@@ -1171,0 +1174,2 @@\n+  strip_return_address(); \/\/ This might happen within a stack frame.\n+  protect_return_address();\n@@ -1191,0 +1196,1 @@\n+  authenticate_return_address();\n@@ -4317,0 +4323,1 @@\n+  protect_return_address();\n@@ -4349,0 +4356,1 @@\n+  authenticate_return_address();\n@@ -5190,0 +5198,1 @@\n+  protect_return_address();\n@@ -5199,0 +5208,1 @@\n+  authenticate_return_address();\n@@ -5290,0 +5300,99 @@\n+\n+\/\/ Stack frame creation\/removal\n+\n+void MacroAssembler::enter(bool strip_ret_addr) {\n+  if (strip_ret_addr) {\n+    \/\/ Addresses can only be signed once. If there are multiple nested frames being created\n+    \/\/ in the same function, then the return address needs stripping first.\n+    strip_return_address();\n+  }\n+  protect_return_address();\n+  stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n+  mov(rfp, sp);\n+}\n+\n+void MacroAssembler::leave() {\n+  mov(sp, rfp);\n+  ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n+  authenticate_return_address();\n+}\n+\n+\/\/ ROP Protection\n+\/\/ Use the AArch64 PAC feature to add ROP protection for generated code. Use whenever creating\/\n+\/\/ destroying stack frames or whenever directly loading\/storing the LR to memory.\n+\/\/ If ROP protection is not set then these functions are no-ops.\n+\/\/ For more details on PAC see pauth_aarch64.hpp.\n+\n+\/\/ Sign the LR. Use during construction of a stack frame, before storing the LR to memory.\n+\/\/ Uses the FP as the modifier.\n+\/\/\n+void MacroAssembler::protect_return_address() {\n+  if (VM_Version::use_rop_protection()) {\n+    check_return_address();\n+    \/\/ The standard convention for C code is to use paciasp, which uses SP as the modifier. This\n+    \/\/ works because in C code, FP and SP match on function entry. In the JDK, SP and FP may not\n+    \/\/ match, so instead explicitly use the FP.\n+    pacia(lr, rfp);\n+  }\n+}\n+\n+\/\/ Sign the return value in the given register. Use before updating the LR in the exisiting stack\n+\/\/ frame for the current function.\n+\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n+\/\/ the current FP.\n+\/\/\n+void MacroAssembler::protect_return_address(Register return_reg, Register temp_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n+    check_return_address(return_reg);\n+    ldr(temp_reg, Address(rfp));\n+    pacia(return_reg, temp_reg);\n+  }\n+}\n+\n+\/\/ Authenticate the LR. Use before function return, after restoring FP and loading LR from memory.\n+\/\/\n+void MacroAssembler::authenticate_return_address(Register return_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    autia(return_reg, rfp);\n+    check_return_address(return_reg);\n+  }\n+}\n+\n+\/\/ Authenticate the return value in the given register. Use before updating the LR in the exisiting\n+\/\/ stack frame for the current function.\n+\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n+\/\/ the current FP.\n+\/\/\n+void MacroAssembler::authenticate_return_address(Register return_reg, Register temp_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n+    ldr(temp_reg, Address(rfp));\n+    autia(return_reg, temp_reg);\n+    check_return_address(return_reg);\n+  }\n+}\n+\n+\/\/ Strip any PAC data from LR without performing any authentication. Use with caution - only if\n+\/\/ there is no guaranteed way of authenticating the LR.\n+\/\/\n+void MacroAssembler::strip_return_address() {\n+  if (VM_Version::use_rop_protection()) {\n+    xpaclri();\n+  }\n+}\n+\n+#ifndef PRODUCT\n+\/\/ PAC failures can be difficult to debug. After an authentication failure, a segfault will only\n+\/\/ occur when the pointer is used - ie when the program returns to the invalid LR. At this point\n+\/\/ it is difficult to debug back to the callee function.\n+\/\/ This function simply loads from the address in the given register.\n+\/\/ Use directly after authentication to catch authentication failures.\n+\/\/ Also use before signing to check that the pointer is valid and hasn't already been signed.\n+\/\/\n+void MacroAssembler::check_return_address(Register return_reg) {\n+  if (VM_Version::use_rop_protection()) {\n+    ldr(zr, Address(return_reg));\n+  }\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -702,10 +702,10 @@\n-  void enter()\n-  {\n-    stp(rfp, lr, Address(pre(sp, -2 * wordSize)));\n-    mov(rfp, sp);\n-  }\n-  void leave()\n-  {\n-    mov(sp, rfp);\n-    ldp(rfp, lr, Address(post(sp, 2 * wordSize)));\n-  }\n+  void enter(bool strip_ret_addr = false);\n+  void leave();\n+\n+  \/\/ ROP Protection\n+  void protect_return_address();\n+  void protect_return_address(Register return_reg, Register temp_reg);\n+  void authenticate_return_address(Register return_reg = lr);\n+  void authenticate_return_address(Register return_reg, Register temp_reg);\n+  void strip_return_address();\n+  void check_return_address(Register return_reg=lr) PRODUCT_RETURN;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -4685,1 +4685,1 @@\n-  Label RET_TRUE, RET_TRUE_NO_POP, RET_FALSE, ALIGNED, LOOP16, CHECK_16, DONE,\n+  Label RET_TRUE, RET_TRUE_NO_POP, RET_FALSE, ALIGNED, LOOP16, CHECK_16,\n@@ -4827,4 +4827,0 @@\n-  __ bind(DONE);\n-    __ pop(spilled_regs, sp);\n-    __ leave();\n-    __ ret(lr);\n@@ -5228,91 +5224,0 @@\n-  enum string_compare_mode {\n-    LL,\n-    LU,\n-    UL,\n-    UU,\n-  };\n-\n-  \/\/ The following registers are declared in aarch64.ad\n-  \/\/ r0  = result\n-  \/\/ r1  = str1\n-  \/\/ r2  = cnt1\n-  \/\/ r3  = str2\n-  \/\/ r4  = cnt2\n-  \/\/ r10 = tmp1\n-  \/\/ r11 = tmp2\n-  \/\/ z0  = ztmp1\n-  \/\/ z1  = ztmp2\n-  \/\/ p0  = pgtmp1\n-  \/\/ p1  = pgtmp2\n-  address generate_compare_long_string_sve(string_compare_mode mode) {\n-    __ align(CodeEntryAlignment);\n-    address entry = __ pc();\n-    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,\n-             tmp1 = r10, tmp2 = r11;\n-\n-    Label LOOP, MATCH, DONE, NOMATCH;\n-    Register vec_len = tmp1;\n-    Register idx = tmp2;\n-    \/\/ The minimum of the string lengths has been stored in cnt2.\n-    Register cnt = cnt2;\n-    FloatRegister ztmp1 = z0, ztmp2 = z1;\n-    PRegister pgtmp1 = p0, pgtmp2 = p1;\n-\n-    if (mode == LL) {\n-      __ sve_cntb(vec_len);\n-    } else {\n-      __ sve_cnth(vec_len);\n-    }\n-\n-    __ mov(idx, 0);\n-    __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n-\n-    __ bind(LOOP);\n-      switch (mode) {\n-        case LL:\n-          __ sve_ld1b(ztmp1, __ B, pgtmp1, Address(str1, idx));\n-          __ sve_ld1b(ztmp2, __ B, pgtmp1, Address(str2, idx));\n-          break;\n-        case LU:\n-          __ sve_ld1b(ztmp1, __ H, pgtmp1, Address(str1, idx));\n-          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n-          break;\n-        case UL:\n-          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n-          __ sve_ld1b(ztmp2, __ H, pgtmp1, Address(str2, idx));\n-          break;\n-        case UU:\n-          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n-          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n-          break;\n-        default: ShouldNotReachHere();\n-      }\n-      __ add(idx, idx, vec_len);\n-\n-      \/\/ Compare strings.\n-      __ sve_cmp(Assembler::NE, pgtmp2, mode == LL ? __ B : __ H, pgtmp1, ztmp1, ztmp2);\n-      __ br(__ NE, MATCH);\n-      __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n-      __ br(__ LT, LOOP);\n-\n-      \/\/ The result has been computed in the caller prior to entering this stub.\n-      __ b(DONE);\n-\n-    __ bind(MATCH);\n-\n-      \/\/ Crop the vector to find its location.\n-      __ sve_brkb(pgtmp2, pgtmp1, pgtmp2, false \/* isMerge *\/);\n-\n-      \/\/ Extract the first different characters of each string.\n-      __ sve_lasta(rscratch1, mode == LL ? __ B : __ H, pgtmp2, ztmp1);\n-      __ sve_lasta(rscratch2, mode == LL ? __ B : __ H, pgtmp2, ztmp2);\n-\n-      \/\/ Compute the difference of the first different characters.\n-      __ sub(result, rscratch1, rscratch2);\n-\n-    __ bind(DONE);\n-      __ ret(lr);\n-\n-    return entry;\n-  }\n-\n@@ -5441,1 +5346,0 @@\n-    if (UseSVE == 0) {\n@@ -5450,10 +5354,0 @@\n-    } else {\n-      StubRoutines::aarch64::_compare_long_string_LL\n-          = generate_compare_long_string_sve(LL);\n-      StubRoutines::aarch64::_compare_long_string_UU\n-          = generate_compare_long_string_sve(UU);\n-      StubRoutines::aarch64::_compare_long_string_LU\n-          = generate_compare_long_string_sve(LU);\n-      StubRoutines::aarch64::_compare_long_string_UL\n-          = generate_compare_long_string_sve(UL);\n-    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":107,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -528,1 +528,1 @@\n-      __ jcc(Assembler::notEqual, notInt);\n+      __ jccb(Assembler::notEqual, notInt);\n@@ -536,1 +536,1 @@\n-      __ jcc(Assembler::notEqual, notFloat);\n+      __ jccb(Assembler::notEqual, notFloat);\n@@ -544,1 +544,1 @@\n-      __ jcc(Assembler::notEqual, notShort);\n+      __ jccb(Assembler::notEqual, notShort);\n@@ -552,1 +552,1 @@\n-      __ jcc(Assembler::notEqual, notByte);\n+      __ jccb(Assembler::notEqual, notByte);\n@@ -560,1 +560,1 @@\n-      __ jcc(Assembler::notEqual, notChar);\n+      __ jccb(Assembler::notEqual, notChar);\n@@ -568,1 +568,1 @@\n-      __ jcc(Assembler::notEqual, notBool);\n+      __ jccb(Assembler::notEqual, notBool);\n@@ -582,1 +582,1 @@\n-      __ jcc(Assembler::notEqual, notLong);\n+      __ jccb(Assembler::notEqual, notLong);\n@@ -592,1 +592,1 @@\n-      __ jcc(Assembler::notEqual, notDouble);\n+      __ jccb(Assembler::notEqual, notDouble);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1013,0 +1013,1 @@\n+      case Bytecodes::_ldc2_w:\n@@ -1157,1 +1158,0 @@\n-              assert(mirror() != NULL, \"klass not set\");\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsHeapVerifier.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"logging\/logMessage.hpp\"\n@@ -147,5 +147,18 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\n-\/\/ Java heap object archiving support\n-\/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+static bool is_subgraph_root_class_of(ArchivableStaticFieldInfo fields[], int num, InstanceKlass* ik) {\n+  for (int i = 0; i < num; i++) {\n+    if (fields[i].klass == ik) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool HeapShared::is_subgraph_root_class(InstanceKlass* ik) {\n+  return is_subgraph_root_class_of(closed_archive_subgraph_entry_fields,\n+                                   num_closed_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(open_archive_subgraph_entry_fields,\n+                                   num_open_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(fmg_open_archive_subgraph_entry_fields,\n+                                   num_fmg_open_archive_subgraph_entry_fields, ik);\n+}\n+\n@@ -207,1 +220,1 @@\n-  oop* p = cache->get(obj);\n+  CachedOopInfo* p = cache->get(obj);\n@@ -209,1 +222,1 @@\n-    return *p;\n+    return p->_obj;\n@@ -313,1 +326,2 @@\n-    cache->put(obj, archived_oop);\n+    CachedOopInfo info = make_cached_oop_info(archived_oop);\n+    cache->put(obj, info);\n@@ -347,0 +361,88 @@\n+\/\/ -- Handling of Enum objects\n+\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n+\/\/     enum MyEnum {FOO, BAR}\n+\/\/     MyEnum::<clinint> {\n+\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n+\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n+\/\/     }\n+\/\/\n+\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n+\/\/ ensure the archived value equals (in object address) to the runtime value of\n+\/\/ MyEnum::FOO.\n+\/\/\n+\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n+\/\/ no way of programatically handling this inside the Java code (as you would handle\n+\/\/ ModuleLayer::EMPTY_LAYER, for example).\n+\/\/\n+\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n+\/\/ HeapShared::initialize_enum_klass() will skip the <clinit> method and pull\n+\/\/ the static fields out of the archived heap.\n+void HeapShared::check_enum_obj(int level,\n+                                KlassSubGraphInfo* subgraph_info,\n+                                oop orig_obj,\n+                                bool is_closed_archive) {\n+  Klass* k = orig_obj->klass();\n+  Klass* relocated_k = ArchiveBuilder::get_relocated_klass(k);\n+  if (!k->is_instance_klass()) {\n+    return;\n+  }\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  if (ik->java_super() == vmClasses::Enum_klass() && !ik->has_archived_enum_objs()) {\n+    ResourceMark rm;\n+    ik->set_has_archived_enum_objs();\n+    relocated_k->set_has_archived_enum_objs();\n+    oop mirror = ik->java_mirror();\n+\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n+          guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        }\n+        oop oop_field = mirror->obj_field(fd.offset());\n+        if (oop_field == NULL) {\n+          guarantee(false, \"static field %s::%s must not be null\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n+          guarantee(false, \"static field %s::%s is of the wrong type\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        }\n+        oop archived_oop_field = archive_reachable_objects_from(level, subgraph_info, oop_field, is_closed_archive);\n+        int root_index = append_root(archived_oop_field);\n+        log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \")\",\n+                            root_index, ik->external_name(), fd.name()->as_C_string(),\n+                            p2i((oopDesc*)oop_field), p2i((oopDesc*)archived_oop_field));\n+        SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ See comments in HeapShared::check_enum_obj()\n+bool HeapShared::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n+  if (!is_fully_available()) {\n+    return false;\n+  }\n+\n+  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n+  assert(info != NULL, \"sanity\");\n+\n+  if (log_is_enabled(Info, cds, heap)) {\n+    ResourceMark rm;\n+    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n+  }\n+\n+  oop mirror = k->java_mirror();\n+  int i = 0;\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      int root_index = info->enum_klass_static_field_root_index_at(i++);\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n+      mirror->obj_field_put(fd.offset(), get_root(root_index, \/*clear=*\/true));\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -388,0 +490,1 @@\n+    CDSHeapVerifier::verify();\n@@ -916,0 +1019,5 @@\n+\n+  \/\/ The following are for maintaining a stack for determining\n+  \/\/ CachedOopInfo::_referrer\n+  static WalkOopAndArchiveClosure* _current;\n+  WalkOopAndArchiveClosure* _last;\n@@ -925,1 +1033,7 @@\n-    _orig_referencing_obj(orig), _archived_referencing_obj(archived) {}\n+    _orig_referencing_obj(orig), _archived_referencing_obj(archived) {\n+    _last = _current;\n+    _current = this;\n+  }\n+  ~WalkOopAndArchiveClosure() {\n+    _current = _last;\n+  }\n@@ -962,0 +1076,5 @@\n+\n+ public:\n+  static WalkOopAndArchiveClosure* current()  { return _current;              }\n+  oop orig_referencing_obj()                  { return _orig_referencing_obj; }\n+  KlassSubGraphInfo* subgraph_info()          { return _subgraph_info;        }\n@@ -964,0 +1083,13 @@\n+WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = NULL;\n+\n+HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop orig_obj) {\n+  CachedOopInfo info;\n+  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+\n+  info._subgraph_info = (walker == NULL) ? NULL : walker->subgraph_info();\n+  info._referrer = (walker == NULL) ? NULL : walker->orig_referencing_obj();\n+  info._obj = orig_obj;\n+\n+  return info;\n+}\n+\n@@ -1089,0 +1221,2 @@\n+\n+  check_enum_obj(level + 1, subgraph_info, orig_obj, is_closed_archive);\n@@ -1692,0 +1826,4 @@\n+  if (bitmap_base == 0) {\n+    _loading_failed = true;\n+    return false; \/\/ OOM or CRC error\n+  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":148,"deletions":10,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -797,0 +797,7 @@\n+void SystemDictionaryShared::add_enum_klass_static_field(InstanceKlass* ik, int root_index) {\n+  assert(DumpSharedSpaces, \"static dump only\");\n+  DumpTimeClassInfo* info = SystemDictionaryShared::find_or_allocate_info_for_locked(ik);\n+  assert(info != NULL, \"must be\");\n+  info->add_enum_klass_static_field(root_index);\n+}\n+\n@@ -1178,1 +1185,1 @@\n-      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      size_t byte_size = info.runtime_info_bytesize();\n@@ -1287,1 +1294,1 @@\n-      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      size_t byte_size = info.runtime_info_bytesize();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2412,1 +2412,0 @@\n-  case VerifyOption_G1UseNextMarking: return is_obj_ill(obj, hr);\n@@ -2423,1 +2422,0 @@\n-  case VerifyOption_G1UseNextMarking: return is_obj_ill(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1246,5 +1246,0 @@\n-  \/\/ This function returns true when an object has been\n-  \/\/ around since the previous marking and hasn't yet\n-  \/\/ been marked during this marking, and is not in a closed archive region.\n-  inline bool is_obj_ill(const oop obj, const HeapRegion* hr) const;\n-\n@@ -1259,2 +1254,0 @@\n-  inline bool is_obj_ill(const oop obj) const;\n-\n@@ -1312,1 +1305,0 @@\n-  \/\/ vo == UseNextMarking -> use \"next\" marking information\n@@ -1318,3 +1310,0 @@\n-  \/\/ Currently, there is only one case where this is called with\n-  \/\/ vo == UseNextMarking, which is to verify the \"next\" marking\n-  \/\/ information at the end of remark.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n-    MutexLocker x(ExpandHeap_lock);\n+    MutexLocker x(PSOldGenExpand_lock);\n@@ -184,1 +184,1 @@\n-  assert_lock_strong(ExpandHeap_lock);\n+  assert_lock_strong(PSOldGenExpand_lock);\n@@ -222,1 +222,1 @@\n-  assert_lock_strong(ExpandHeap_lock);\n+  assert_lock_strong(PSOldGenExpand_lock);\n@@ -258,1 +258,1 @@\n-  assert_lock_strong(ExpandHeap_lock);\n+  assert_lock_strong(PSOldGenExpand_lock);\n@@ -271,1 +271,1 @@\n-  assert_lock_strong(ExpandHeap_lock);\n+  assert_lock_strong(PSOldGenExpand_lock);\n@@ -276,1 +276,0 @@\n-    assert_lock_strong(ExpandHeap_lock);\n@@ -287,0 +286,9 @@\n+void PSOldGen::complete_loaded_archive_space(MemRegion archive_space) {\n+  HeapWord* cur = archive_space.start();\n+  while (cur < archive_space.end()) {\n+    _start_array.allocate_block(cur);\n+    size_t word_size = cast_to_oop(cur)->size();\n+    cur += word_size;\n+  }\n+}\n+\n@@ -315,1 +323,1 @@\n-    MutexLocker x(ExpandHeap_lock);\n+    MutexLocker x(PSOldGenExpand_lock);\n@@ -319,1 +327,1 @@\n-    MutexLocker x(ExpandHeap_lock);\n+    MutexLocker x(PSOldGenExpand_lock);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -291,1 +291,0 @@\n-  MutexLocker x(ExpandHeap_lock);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,0 +314,2 @@\n+  static_field(StubRoutines,                _md5_implCompress,                                address)                               \\\n+  static_field(StubRoutines,                _md5_implCompressMB,                              address)                               \\\n@@ -320,0 +322,2 @@\n+  static_field(StubRoutines,                _sha3_implCompress,                               address)                               \\\n+  static_field(StubRoutines,                _sha3_implCompressMB,                             address)                               \\\n@@ -740,0 +744,3 @@\n+  static_field(StubRoutines::aarch64, _has_negatives, address)          \\\n+  static_field(StubRoutines::aarch64, _has_negatives_long, address)     \\\n+  static_field(VM_Version, _rop_protection, bool)                       \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -100,3 +100,0 @@\n-  template <typename T, class OopClosureType, class Contains>\n-  static void do_next(oop obj, OopClosureType* closure, Contains& contains);\n-\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -178,4 +178,5 @@\n-    _archived_lambda_proxy_is_available = 2,\n-    _has_value_based_class_annotation = 4,\n-    _verified_at_dump_time = 8,\n-    _regenerated = 16\n+    _archived_lambda_proxy_is_available    = 1 << 1,\n+    _has_value_based_class_annotation      = 1 << 2,\n+    _verified_at_dump_time                 = 1 << 3,\n+    _has_archived_enum_objs                = 1 << 4,\n+    _regenerated                           = 1 << 5\n@@ -345,0 +346,8 @@\n+  void set_has_archived_enum_objs() {\n+    CDS_ONLY(_shared_class_flags |= _has_archived_enum_objs;)\n+  }\n+  bool has_archived_enum_objs() const {\n+    CDS_ONLY(return (_shared_class_flags & _has_archived_enum_objs) != 0;)\n+    NOT_CDS(return false;)\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -909,1 +909,1 @@\n-        const Node *cn = pn->unique_ctrl_out();\n+        const Node* cn = pn->unique_ctrl_out_or_null();\n@@ -1417,1 +1417,1 @@\n-    Node* out_c = unique_ctrl_out();\n+    Node* out_c = unique_ctrl_out_or_null();\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -540,0 +540,1 @@\n+  { \"ExtendedDTraceProbes\",         JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n@@ -550,0 +551,1 @@\n+  { \"PrefetchFieldsAhead\",          JDK_Version::undefined(), JDK_Version::jdk(19), JDK_Version::jdk(20) },\n@@ -863,0 +865,3 @@\n+    if ((!is_neg && v > max_jint) || (is_neg && -(intx)v < min_jint)) {\n+      return false;\n+    }\n@@ -865,0 +870,3 @@\n+    if (v > max_juint) {\n+      return false;\n+    }\n@@ -870,1 +878,10 @@\n-      intx_v = -intx_v;\n+      if (intx_v != min_intx) {\n+        intx_v = - intx_v;\n+        if (intx_v > 0) {\n+          return false; \/\/ underflow\n+        }\n+      }\n+    } else {\n+      if (intx_v < 0) {\n+        return false; \/\/ overflow\n+      }\n@@ -2871,0 +2888,2 @@\n+      warning(\"Option ExtendedDTraceProbes was deprecated in version 19 and will likely be removed in a future release.\");\n+      warning(\"Use the combination of -XX:+DTraceMethodProbes, -XX:+DTraceAllocProbes and -XX:+DTraceMonitorProbes instead.\");\n@@ -2887,0 +2906,12 @@\n+    } else if (match_option(option, \"-XX:+DTraceMethodProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceMethodProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n+    } else if (match_option(option, \"-XX:+DTraceAllocProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceAllocProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n+    } else if (match_option(option, \"-XX:+DTraceMonitorProbes\")) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"DTraceMonitorProbes flag is not applicable for this configuration\\n\");\n+      return JNI_EINVAL;\n@@ -3561,0 +3592,4 @@\n+            if (AutoCreateSharedArchive) {\n+              warning(\"-XX:+AutoCreateSharedArchive is unsupported when base CDS archive is not loaded. Run with -Xlog:cds for more info.\");\n+              AutoCreateSharedArchive = false;\n+            }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1531,1 +1531,1 @@\n-  develop_pd(intx, CodeEntryAlignment,                                      \\\n+  product_pd(intx, CodeEntryAlignment, EXPERIMENTAL,                        \\\n@@ -1537,1 +1537,1 @@\n-          range(1, 16)                                                      \\\n+          range(1, 128)                                                     \\\n@@ -1861,1 +1861,3 @@\n-          \"Enable performance-impacting dtrace probes\")                     \\\n+          \"(Deprecated) Enable performance-impacting dtrace probes. \"       \\\n+          \"Use the combination of -XX:+DTraceMethodProbes, \"                \\\n+          \"-XX:+DTraceAllocProbes and -XX:+DTraceMonitorProbes instead.\")   \\\n@@ -1864,1 +1866,1 @@\n-          \"Enable dtrace probes for method-entry and method-exit\")          \\\n+          \"Enable dtrace tool probes for method-entry and method-exit\")     \\\n@@ -1867,1 +1869,1 @@\n-          \"Enable dtrace probes for object allocation\")                     \\\n+          \"Enable dtrace tool probes for object allocation\")                \\\n@@ -1870,1 +1872,1 @@\n-          \"Enable dtrace probes for monitor events\")                        \\\n+          \"Enable dtrace tool probes for monitor events\")                   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-class ObjectMonitor : public CHeapObj<mtInternal> {\n+class ObjectMonitor : public CHeapObj<mtObjectMonitor> {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -653,3 +653,1 @@\n-  const NMT_TrackingLevel level = MemTracker::tracking_level();\n-  const size_t nmt_overhead =\n-      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n+  const size_t outer_size = size + MemTracker::overhead_per_malloc();\n@@ -657,3 +655,1 @@\n-  const size_t outer_size = size + nmt_overhead;\n-\n-  void* const outer_ptr = (u_char*)::malloc(outer_size);\n+  void* const outer_ptr = ::malloc(outer_size);\n@@ -664,1 +660,1 @@\n-  void* inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack, level);\n+  void* const inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, memflags, stack);\n@@ -700,5 +696,1 @@\n-  const NMT_TrackingLevel level = MemTracker::tracking_level();\n-  const size_t nmt_overhead =\n-      MemTracker::malloc_header_size(level) + MemTracker::malloc_footer_size(level);\n-\n-  const size_t new_outer_size = size + nmt_overhead;\n+  const size_t new_outer_size = size + MemTracker::overhead_per_malloc();\n@@ -707,1 +699,1 @@\n-  void* const old_outer_ptr = MemTracker::record_free(memblock, level);\n+  void* const old_outer_ptr = MemTracker::record_free(memblock);\n@@ -710,0 +702,3 @@\n+  if (new_outer_ptr == NULL) {\n+    return NULL;\n+  }\n@@ -711,2 +706,1 @@\n-  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n-  void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack, level);\n+  void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack);\n@@ -732,3 +726,2 @@\n-  const NMT_TrackingLevel level = MemTracker::tracking_level();\n-\n-  void* const old_outer_ptr = MemTracker::record_free(memblock, level);\n+  void* const old_outer_ptr = MemTracker::record_free(memblock);\n+\n@@ -1388,1 +1381,1 @@\n-  \/\/ Check if we have StackShadowPages above the yellow zone.  This parameter\n+  \/\/ Check if we have StackShadowPages above the guard zone. This parameter\n@@ -1396,3 +1389,1 @@\n-  address limit = JavaThread::cast(thread)->stack_end() +\n-                  (StackOverflow::stack_guard_zone_size() + StackOverflow::stack_shadow_zone_size());\n-\n+  address limit = JavaThread::cast(thread)->stack_overflow_state()->shadow_zone_safe_limit();\n@@ -1749,0 +1740,8 @@\n+\/\/ Pretouching must use a store, not just a load.  On many OSes loads from\n+\/\/ fresh memory would be satisfied from a single mapped page containing all\n+\/\/ zeros.  We need to store something to each page to get them backed by\n+\/\/ their own memory, which is the effect we want here.  An atomic add of\n+\/\/ zero is used instead of a simple store, allowing the memory to be used\n+\/\/ while pretouch is in progress, rather than requiring users of the memory\n+\/\/ to wait until the entire range has been touched.  This is technically\n+\/\/ a UB data race, but doesn't cause any problems for us.\n@@ -1750,6 +1749,16 @@\n-  for (volatile char *p = (char*)start; p < (char*)end; p += page_size) {\n-    \/\/ Note: this must be a store, not a load. On many OSes loads from fresh\n-    \/\/ memory would be satisfied from a single mapped page containing all zeros.\n-    \/\/ We need to store something to each page to get them backed by their own\n-    \/\/ memory, which is the effect we want here.\n-    *p = 0;\n+  assert(start <= end, \"invalid range: \" PTR_FORMAT \" -> \" PTR_FORMAT, p2i(start), p2i(end));\n+  assert(is_power_of_2(page_size), \"page size misaligned: %zu\", page_size);\n+  assert(page_size >= sizeof(int), \"page size too small: %zu\", page_size);\n+  if (start < end) {\n+    \/\/ We're doing concurrent-safe touch and memory state has page\n+    \/\/ granularity, so we can touch anywhere in a page.  Touch at the\n+    \/\/ beginning of each page to simplify iteration.\n+    char* cur = static_cast<char*>(align_down(start, page_size));\n+    void* last = align_down(static_cast<char*>(end) - 1, page_size);\n+    assert(cur <= last, \"invariant\");\n+    \/\/ Iterate from first page through last (inclusive), being careful to\n+    \/\/ avoid overflow if the last page abuts the end of the address range.\n+    for ( ; true; cur += page_size) {\n+      Atomic::add(reinterpret_cast<int*>(cur), 0, memory_order_relaxed);\n+      if (cur >= last) break;\n+    }\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":37,"deletions":28,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -1849,0 +1849,3 @@\n+  declare_c2_type(VectorUCastB2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastS2XNode, VectorNode)                         \\\n+  declare_c2_type(VectorUCastI2XNode, VectorNode)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"compiler\/compiler_globals.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"unittest.hpp\"\n+\n+class LargeOptionsTest : public ::testing::Test {\n+public:\n+  static bool test_option_value(const char* option, intx value) {\n+    char buffer[100];\n+    UnlockDiagnosticVMOptions = true;\n+    os::snprintf(buffer, 100, \"%s=\" INTX_FORMAT, option, value);\n+    return Arguments::parse_argument(buffer, JVMFlagOrigin::COMMAND_LINE);\n+  }\n+\n+  static bool test_option_value(const char* option) {\n+    UnlockDiagnosticVMOptions = true;\n+    return Arguments::parse_argument(option, JVMFlagOrigin::COMMAND_LINE);\n+  }\n+};\n+\n+#ifdef _LP64\n+\/\/ CompilerDirectivesLimit is a diagnostic int option.\n+TEST_VM(LARGE_OPTION, large_ints) {\n+  for (intx x = max_jint - 1; x <= (intx)max_jint + 1; x++) {\n+    bool result = LargeOptionsTest::test_option_value(\"CompilerDirectivesLimit\", x);\n+    if (x > max_jint) {\n+      ASSERT_FALSE(result);\n+    } else {\n+      ASSERT_TRUE(result);\n+      ASSERT_EQ(CompilerDirectivesLimit, x);\n+    }\n+  }\n+}\n+\n+TEST_VM(LARGE_OPTION, small_ints) {\n+  for (intx x = min_jint + 1; x >= (intx)min_jint - 1; x--) {\n+    bool result = LargeOptionsTest::test_option_value(\"CompilerDirectivesLimit\", x);\n+    if (x < min_jint) {\n+      ASSERT_FALSE(result);\n+    } else {\n+      ASSERT_TRUE(result);\n+      ASSERT_EQ(CompilerDirectivesLimit, x);\n+    }\n+  }\n+}\n+\n+TEST_VM(LARGE_OPTION, large_int_overflow) { \/\/ Test 0x100000000\n+  ASSERT_FALSE(LargeOptionsTest::test_option_value(\"CompilerDirectivesLimit\", 4294967296));\n+}\n+#endif\n+\n+\/\/ HandshakeTimeout is a diagnostic uint option.\n+TEST_VM(LARGE_OPTION, large_uints) {\n+  for (uintx x = max_juint - 1; x <= (uintx)max_juint + 1; x++) {\n+    bool result = LargeOptionsTest::test_option_value(\"HandshakeTimeout\", x);\n+    if (x <= max_juint) {\n+      ASSERT_TRUE(result);\n+      ASSERT_EQ(HandshakeTimeout, x);\n+    } else {\n+      ASSERT_FALSE(result);\n+    }\n+  }\n+}\n+\n+#ifdef _LP64\n+\/\/ MaxJNILocalCapacity is an intx option.\n+TEST_VM(LARGE_OPTION, large_intxs) {\n+  \/\/ max_intx + 1 equals min_intx!\n+  for (julong x = max_intx - 1; x <= (julong)max_intx + 1; x++) {\n+    ASSERT_TRUE(LargeOptionsTest::test_option_value(\"MaxJNILocalCapacity\", x));\n+    ASSERT_EQ((julong)MaxJNILocalCapacity, x);\n+  }\n+}\n+\n+TEST_VM(LARGE_OPTION, small_intxs) {\n+  ASSERT_TRUE(LargeOptionsTest::test_option_value(\"MaxJNILocalCapacity\", min_intx + 1));\n+  ASSERT_EQ(MaxJNILocalCapacity, -9223372036854775807);\n+  ASSERT_TRUE(LargeOptionsTest::test_option_value(\"MaxJNILocalCapacity\", min_intx));\n+  ASSERT_EQ(MaxJNILocalCapacity, min_intx);\n+  \/\/ Test value that's less than min_intx (-0x8000000000000001).\n+  ASSERT_FALSE(LargeOptionsTest::test_option_value(\"MaxJNILocalCapacity=-9223372036854775809\"));\n+}\n+#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_largeOptions.cpp","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -70,3 +70,3 @@\n-compiler\/whitebox\/ClearMethodStateTest.java 8265360 macosx-aarch64\n-compiler\/whitebox\/EnqueueMethodForCompilationTest.java 8265360 macosx-aarch64\n-compiler\/whitebox\/MakeMethodNotCompilableTest.java 8265360 macosx-aarch64\n+compiler\/whitebox\/ClearMethodStateTest.java 8265360 macosx-all\n+compiler\/whitebox\/EnqueueMethodForCompilationTest.java 8265360 macosx-all\n+compiler\/whitebox\/MakeMethodNotCompilableTest.java 8265360 macosx-all\n@@ -74,1 +74,1 @@\n-compiler\/codecache\/jmx\/PoolsIndependenceTest.java 8264632 macosx-generic\n+compiler\/codecache\/jmx\/PoolsIndependenceTest.java 8264632 macosx-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+    public static final String OUTERSTRIPMINEDLOOP = START + \"OuterStripMinedLoop\\\\b\" + MID + END;\n@@ -133,0 +134,1 @@\n+    public static final String DIV_BY_ZERO_TRAP = START + \"CallStaticJava\" + MID + \"uncommon_trap.*div0_check\" + END;\n@@ -138,0 +140,1 @@\n+    public static final String SAFEPOINT = START + \"SafePoint\" + MID + END;\n@@ -143,0 +146,1 @@\n+    public static final String AND = START + \"And(I|L)\" + MID + END;\n@@ -147,0 +151,1 @@\n+    public static final String LSHIFT = START + \"LShift(I|L)\" + MID + END;\n@@ -149,0 +154,7 @@\n+    public static final String RSHIFT = START + \"RShift(I|L)\" + MID + END;\n+    public static final String RSHIFT_I = START + \"RShiftI\" + MID + END;\n+    public static final String RSHIFT_L = START + \"RShiftL\" + MID + END;\n+    public static final String URSHIFT = START + \"URShift(B|S|I|L)\" + MID + END;\n+    public static final String URSHIFT_I = START + \"URShiftI\" + MID + END;\n+    public static final String URSHIFT_L = START + \"URShiftL\" + MID + END;\n+    public static final String ADD = START + \"Add(I|L|F|D|P)\" + MID + END;\n@@ -152,0 +164,1 @@\n+    public static final String SUB = START + \"Sub(I|L|F|D)\" + MID + END;\n@@ -156,0 +169,1 @@\n+    public static final String MUL = START + \"Mul(I|L|F|D)\" + MID + END;\n@@ -158,0 +172,2 @@\n+    public static final String DIV = START + \"Div(I|L|F|D)\" + MID + END;\n+    public static final String DIV_L = START + \"DivL\" + MID + END;\n@@ -159,0 +175,1 @@\n+    public static final String CONV_L2I = START + \"ConvL2I\" + MID + END;\n@@ -166,0 +183,3 @@\n+    public static final String VECTOR_UCAST_B2X = START + \"VectorUCastB2X\" + MID + END;\n+    public static final String VECTOR_UCAST_S2X = START + \"VectorUCastS2X\" + MID + END;\n+    public static final String VECTOR_UCAST_I2X = START + \"VectorUCastI2X\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import jdk.test.lib.process.ProcessTools;\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsErgoTools.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}