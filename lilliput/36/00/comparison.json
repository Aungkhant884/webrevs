{"files":[{"patch":"@@ -3696,5 +3696,53 @@\n-  if (UseCompressedClassPointers) {\n-    ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n-    decode_klass_not_null(dst);\n-  } else {\n-    ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+  assert(UseCompressedClassPointers, \"expects UseCompressedClassPointers\");\n+\n+  \/\/ We can receive src and dst in the same register here, and they can also\n+  \/\/ come in rscratch1 and rscratch2. Let's allocate an additional register\n+  \/\/ here to preserve src across the fast-path.\n+  Register tmp = dst;\n+  if (src == dst) {\n+    if (src == r0) {\n+      tmp = r1;\n+    } else {\n+      tmp = r0;\n+    }\n+    push(RegSet::of(tmp), sp);\n+  }\n+  assert_different_registers(src, tmp);\n+\n+  Label slow, done;\n+\n+  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+  ldr(tmp, Address(src, oopDesc::mark_offset_in_bytes()));\n+  eor(tmp, tmp, markWord::unlocked_value);\n+  tst(tmp, markWord::lock_mask_in_place);\n+  br(Assembler::NE, slow);\n+\n+  \/\/ Fast-path: shift and decode Klass*.\n+  mov(dst, tmp);\n+  lsr(dst, dst, markWord::klass_shift);\n+  b(done);\n+\n+  bind(slow);\n+  enter();\n+  \/\/ We need r0 as argument and return register for the call. Preserve it, if necessary.\n+  if (dst != r0) {\n+    push(RegSet::of(r0), sp);\n+  }\n+  \/\/ We don't need to preserve r0 here, but we need to preserve rscratch1 and rescratch2,\n+  \/\/ because some users of load_klass() use them around the call.\n+  push(RegSet::of(rscratch1, rscratch2), sp);\n+  mov(r0, src);\n+  assert(StubRoutines::load_nklass() != NULL, \"Must have stub\");\n+  mov(rscratch1, StubRoutines::load_nklass());\n+  blr(rscratch1);\n+  pop(RegSet::of(rscratch1, rscratch2), sp);\n+  if (dst != r0) {\n+    mov(dst, r0);\n+    pop(RegSet::of(r0), sp);\n+  }\n+  leave();\n+\n+  bind(done);\n+  decode_klass_not_null(dst);\n+  if (src == dst) {\n+    pop(RegSet::of(tmp), sp);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":53,"deletions":5,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -587,2 +587,11 @@\n-    __ load_klass(r0, r0);  \/\/ get klass\n-    __ cbz(r0, error);      \/\/ if klass is NULL it is broken\n+    \/\/ NOTE: We used to load the Klass* here, and compare that to zero.\n+    \/\/ However, with current Lilliput implementation, that would require\n+    \/\/ checking the locking bits and calling into the runtime, which\n+    \/\/ clobbers the condition flags, which may be live around this call.\n+    \/\/ OTOH, this is a simple NULL-check, and we can simply load the upper\n+    \/\/ 32bit of the header as narrowKlass, and compare that to 0. The\n+    \/\/ worst that can happen (rarely) is that the object is locked and\n+    \/\/ we have lock pointer bits in the upper 32bits. We can't get a false\n+    \/\/ negative.\n+    __ ldrw(r0, Address(r0, oopDesc::nklass_offset_in_bytes()));  \/\/ get klass\n+    __ cbzw(r0, error);      \/\/ if klass is NULL it is broken\n@@ -6598,0 +6607,21 @@\n+  \/\/ Pass object argument in r0 (which has to be preserved outside this stub)\n+  \/\/ Pass back result in r0\n+  \/\/ Clobbers rscratch1\n+  address generate_load_nklass() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"load_nklass\");\n+\n+    address start = __ pc();\n+\n+    __ set_last_Java_frame(sp, rfp, lr, rscratch1);\n+    __ enter();\n+    __ push_call_clobbered_registers_except(RegSet::of(r0));\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_nklass_runtime), 1);\n+    __ pop_call_clobbered_registers_except(RegSet::of(r0));\n+    __ leave();\n+    __ reset_last_Java_frame(true);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -7588,0 +7618,2 @@\n+\n+    StubRoutines::_load_nklass = generate_load_nklass();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-  const ptrdiff_t estimate = 124;\n+  const ptrdiff_t estimate = 180;\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -310,0 +310,3 @@\n+#ifdef _LP64\n+  static int nklass_offset_in_bytes()    { return mark_offset_in_bytes() + markWord::klass_shift \/ 8; }\n+#endif\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -181,0 +181,2 @@\n+address StubRoutines::_load_nklass = NULL;\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,3 @@\n- public:\n+  static address _load_nklass;\n+\n+public:\n@@ -429,0 +431,2 @@\n+  static address load_nklass()         { return _load_nklass; }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}