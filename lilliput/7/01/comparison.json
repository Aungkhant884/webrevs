{"files":[{"patch":"@@ -160,1 +160,0 @@\n-  assert_different_registers(obj, klass, len);\n@@ -162,8 +161,3 @@\n-  if (UseBiasedLocking && !len->is_valid()) {\n-    assert_different_registers(obj, klass, len, t1, t2);\n-    movptr(t1, Address(klass, Klass::prototype_header_offset()));\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n-  } else {\n-    \/\/ This assumes that all prototype bits fit in an int32_t\n-    movptr(Address(obj, oopDesc::mark_offset_in_bytes ()), (int32_t)(intptr_t)markWord::prototype().value());\n-  }\n+  assert_different_registers(obj, klass, len, t1, t2);\n+  movptr(t1, Address(klass, Klass::prototype_header_offset()));\n+  movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4046,9 +4046,3 @@\n-    if (UseBiasedLocking) {\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-      __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n-    } else {\n-      __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()),\n-                (intptr_t)markWord::prototype().value()); \/\/ header\n-      __ pop(rcx);   \/\/ get saved klass back in the register.\n-    }\n+    __ pop(rcx);   \/\/ get saved klass back in the register.\n+    __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n+    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -734,0 +735,3 @@\n+    Klass* requested_k = to_requested(k);\n+    narrowKlass nk = CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n+    k->set_prototype_header(markWord::prototype() LP64_ONLY(.set_narrow_klass(nk)));\n@@ -779,0 +783,3 @@\n+#ifdef _LP64\n+  o->set_mark(o->mark().set_narrow_klass(nk));\n+#endif\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -278,1 +278,2 @@\n-    archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original));\n+    narrowKlass nklass = obj->mark().narrow_klass();\n+    archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original) LP64_ONLY(.set_narrow_klass(nklass)));\n@@ -419,5 +420,1 @@\n-    if (UseBiasedLocking) {\n-      oopDesc::set_mark(mem, k->prototype_header());\n-    } else {\n-      oopDesc::set_mark(mem, markWord::prototype());\n-    }\n+    oopDesc::set_mark(mem, markWord::prototype_for_klass(k));\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -63,2 +63,1 @@\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n-  if (destination == NULL) {\n+  if (!obj->is_forwarded()) {\n@@ -68,0 +67,1 @@\n+  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,1 +108,6 @@\n-    if (object->forwardee() != NULL) {\n+    \/\/ TODO: This seems to be checking if mark-word looks like a forwarding pointer, and fix it if\n+    \/\/ it doesn't. That is because compaction code (G1FullGCCompactTask::G1CompactRegionClosure::apply(oop obj))\n+    \/\/ used to do the same check. However, it is more reliable to first check the lower bits (is_forwarded())\n+    \/\/ instead before accepting the forwardee. The code in G1FullCompactTask has been changed accordingly,\n+    \/\/ which should make this block superfluous.\n+    if ((cast_from_oop<uintptr_t>(object->forwardee()) & 0x00000000ffffffff) != 0) {\n@@ -125,1 +130,1 @@\n-    assert(object->forwardee() == NULL, \"should be forwarded to NULL\");\n+    assert((cast_from_oop<uintptr_t>(object->forwardee()) & 0x00000000ffffffff) == 0, \"should be forwarded to NULL\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -79,2 +79,1 @@\n-  oop forwardee = obj->forwardee();\n-  if (forwardee == NULL) {\n+  if (!obj->is_forwarded()) {\n@@ -91,0 +90,1 @@\n+  oop forwardee = obj->forwardee();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  if (forwarded_to != NULL && !_current->is_in(forwarded_to)) {\n+  if (obj->is_forwarded() && !_current->is_in(forwarded_to)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,9 +82,4 @@\n-    oop new_obj = cast_to_oop(obj->mark().decode_pointer());\n-\n-    assert(new_obj != NULL ||                      \/\/ is forwarding ptr?\n-           obj->mark() == markWord::prototype() || \/\/ not gc marked?\n-           (UseBiasedLocking && obj->mark().has_bias_pattern()),\n-           \/\/ not gc marked?\n-           \"should be forwarded\");\n-\n-    if (new_obj != NULL) {\n+    markWord header = obj->mark();\n+    if (header.is_marked()) {\n+      oop new_obj = cast_to_oop(header.decode_pointer());\n+      assert(new_obj != NULL, \"must be forwarded\");\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -387,6 +387,1 @@\n-  if (UseBiasedLocking) {\n-    oopDesc::set_mark(mem, _klass->prototype_header());\n-  } else {\n-    \/\/ May be bootstrapping\n-    oopDesc::set_mark(mem, markWord::prototype());\n-  }\n+  oopDesc::set_mark(mem, _klass->prototype_header());\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -379,1 +379,1 @@\n-    assert(q->forwardee() == NULL, \"should be forwarded to NULL\");\n+    assert(!q->is_forwarded(), \"should not be forwarded\");\n@@ -595,1 +595,1 @@\n-    t->set_mark(markWord::prototype());\n+    t->set_mark(markWord::prototype_for_klass(Universe::intArrayKlassObj()));\n@@ -602,1 +602,1 @@\n-    obj->set_mark(markWord::prototype());\n+    obj->set_mark(markWord::prototype_for_klass(vmClasses::Object_klass()));\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-                           _prototype_header(markWord::prototype()),\n+                           _prototype_header(markWord::prototype() LP64_ONLY(.set_klass(this))),\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n@@ -101,0 +102,21 @@\n+\n+#ifdef _LP64\n+narrowKlass markWord::narrow_klass() const {\n+  return narrowKlass(value() >> klass_shift);\n+}\n+\n+Klass* markWord::klass() const {\n+  return CompressedKlassPointers::decode(narrow_klass());\n+}\n+\n+markWord markWord::set_narrow_klass(const narrowKlass nklass) const {\n+  return markWord((value() & ~klass_mask_in_place) | ((uintptr_t) nklass << klass_shift));\n+}\n+\n+markWord markWord::set_klass(const Klass* klass) const {\n+  assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n+  \/\/ TODO: Don't cast to non-const, change CKP::encode() to accept const Klass* instead.\n+  narrowKlass nklass = CompressedKlassPointers::encode(const_cast<Klass*>(klass));\n+  return set_narrow_klass(nklass);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -135,0 +135,3 @@\n+#ifdef _LP64\n+  static const int klass_bits                     = 32;\n+#endif\n@@ -143,0 +146,3 @@\n+#ifdef _LP64\n+  static const int klass_shift                    = hash_shift + hash_bits;\n+#endif\n@@ -157,0 +163,5 @@\n+#ifdef _LP64\n+  static const uintptr_t klass_mask               = right_n_bits(klass_bits);\n+  static const uintptr_t klass_mask_in_place      = klass_mask << klass_shift;\n+#endif\n+\n@@ -339,0 +350,7 @@\n+#ifdef _LP64\n+  narrowKlass narrow_klass() const;\n+  Klass* klass() const;\n+  markWord set_klass(const Klass* klass) const;\n+  markWord set_narrow_klass(const narrowKlass klass) const;\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -73,2 +73,1 @@\n-  assert(prototype_header == prototype() || prototype_header.has_bias_pattern(), \"corrupt prototype header\");\n-\n+  assert(prototype_header == prototype() LP64_ONLY(.set_klass(klass)) || prototype_header.has_bias_pattern(), \"corrupt prototype header;\");\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -77,1 +77,8 @@\n-  set_mark(markWord::prototype_for_klass(klass()));\n+  markWord header = markWord::prototype();\n+#ifdef _LP64\n+  assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n+  narrowKlass nklass = _metadata._compressed_klass;\n+  assert(nklass != 0, \"expect klass\");\n+  header = header.set_narrow_klass(nklass);\n+#endif\n+  set_mark(header);\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1630,9 +1630,3 @@\n-  Node* mark_node = NULL;\n-  \/\/ For now only enable fast locking for non-array types\n-  if (UseBiasedLocking && Opcode() == Op_Allocate) {\n-    Node* klass_node = in(AllocateNode::KlassNode);\n-    Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n-    mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n-  } else {\n-    mark_node = phase->MakeConX(markWord::prototype().value());\n-  }\n+  Node* klass_node = in(AllocateNode::KlassNode);\n+  Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n+  Node* mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  product(bool, UseCompressedClassPointers, false,                          \\\n+  product(bool, UseCompressedClassPointers, true,                           \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,0 +151,1 @@\n+#ifdef _LP64\n@@ -152,1 +153,1 @@\n-    assert((mark.value() & 0xffffffff00000000) == 0, \"upper 32 mark bits must be free\");\n+    assert(mark.narrow_klass() == CompressedKlassPointers::encode(obj->klass_or_null()), \"upper 32 mark bits must be narrow klass: mark: \" INTPTR_FORMAT \", compressed-klass: \" INTPTR_FORMAT, (intptr_t)mark.narrow_klass(), (intptr_t)CompressedKlassPointers::encode(obj->klass_or_null()));\n@@ -154,0 +155,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/services\/heapObjectStatistics.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}