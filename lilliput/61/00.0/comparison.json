{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=20\n+version=21\n@@ -18,1 +18,1 @@\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.md|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n","filename":".jcheck\/conf","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+    \/\/ Governing predicates for load\/store and arithmetic\n@@ -470,1 +471,1 @@\n-    P7,\n+    \/\/ Extra predicates\n@@ -480,0 +481,3 @@\n+\n+    \/\/ Preserved for all-true predicate\n+    P7,\n@@ -1795,2 +1799,3 @@\n-        C2EntryBarrierStub* stub = Compile::current()->output()->entry_barrier_table()->add_entry_barrier();\n-        slow_path = &stub->slow_path();\n+        C2EntryBarrierStub* stub = new (Compile::current()->comp_arena()) C2EntryBarrierStub();\n+        Compile::current()->output()->add_stub(stub);\n+        slow_path = &stub->entry();\n@@ -1878,1 +1883,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n@@ -3376,1 +3383,2 @@\n-        if (con < (address)(uintptr_t)os::vm_page_size()) {\n+        if (! __ is_valid_AArch64_address(con) ||\n+            con < (address)(uintptr_t)os::vm_page_size()) {\n@@ -3630,0 +3638,5 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ nop();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n@@ -3669,1 +3682,0 @@\n-    _masm.clear_inst_mark();\n@@ -3865,1 +3877,1 @@\n-    __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n+    __ tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n@@ -4903,1 +4915,1 @@\n-  \/\/match(iRegP_R5);\n+  match(iRegP_R5);\n@@ -5541,0 +5553,1 @@\n+  match(pReg);\n@@ -14579,0 +14592,26 @@\n+instruct convF2HF_reg_reg(iRegINoSp dst, vRegF src, vRegF tmp) %{\n+  match(Set dst (ConvF2HF src));\n+  format %{ \"fcvt $tmp, $src\\t# convert single to half precision\\n\\t\"\n+            \"smov $dst, $tmp\\t# move result from $tmp to $dst\"\n+  %}\n+  effect(TEMP tmp);\n+  ins_encode %{\n+      __ fcvtsh($tmp$$FloatRegister, $src$$FloatRegister);\n+      __ smov($dst$$Register, $tmp$$FloatRegister, __ H, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct convHF2F_reg_reg(vRegF dst, iRegINoSp src, vRegF tmp) %{\n+  match(Set dst (ConvHF2F src));\n+  format %{ \"mov $tmp, $src\\t# move source from $src to $tmp\\n\\t\"\n+            \"fcvt $dst, $tmp\\t# convert half to single precision\"\n+  %}\n+  effect(TEMP tmp);\n+  ins_encode %{\n+      __ mov($tmp$$FloatRegister, __ H, 0, $src$$Register);\n+      __ fcvths($dst$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":47,"deletions":8,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-  load_heap_oop(result, Address(result, index, Address::uxtw(LogBytesPerHeapOop)));\n+  load_heap_oop(result, Address(result, index, Address::uxtw(LogBytesPerHeapOop)), tmp, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"jvm.h\"\n@@ -33,0 +32,2 @@\n+#include \"compiler\/compileTask.hpp\"\n+#include \"compiler\/disassembler.hpp\"\n@@ -42,3 +43,1 @@\n-#include \"compiler\/compileTask.hpp\"\n-#include \"compiler\/disassembler.hpp\"\n-#include \"logging\/log.hpp\"\n+#include \"jvm.h\"\n@@ -1895,18 +1894,0 @@\n-void MacroAssembler::atomic_incw(Register counter_addr, Register tmp, Register tmp2) {\n-  if (UseLSE) {\n-    mov(tmp, 1);\n-    ldadd(Assembler::word, tmp, zr, counter_addr);\n-    return;\n-  }\n-  Label retry_load;\n-  prfm(Address(counter_addr), PSTL1STRM);\n-  bind(retry_load);\n-  \/\/ flush and load exclusive from the memory location\n-  ldxrw(tmp, counter_addr);\n-  addw(tmp, tmp, 1);\n-  \/\/ if we store+flush with no intervening write tmp will be zero\n-  stxrw(tmp2, tmp, counter_addr);\n-  cbnzw(tmp2, retry_load);\n-}\n-\n-\n@@ -2081,1 +2062,1 @@\n-void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2) {\n+void MacroAssembler::load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed) {\n@@ -2091,1 +2072,1 @@\n-void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2) {\n+void MacroAssembler::store_sized_value(Address dst, Register src, size_t size_in_bytes) {\n@@ -2399,1 +2380,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2401,1 +2382,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -2436,1 +2417,1 @@\n-  unsigned char regs[PRegister::number_of_saved_registers];\n+  unsigned char regs[PRegister::number_of_registers];\n@@ -2438,1 +2419,1 @@\n-  for (int reg = 0; reg < PRegister::number_of_saved_registers; reg++) {\n+  for (int reg = 0; reg < PRegister::number_of_registers; reg++) {\n@@ -2942,1 +2923,1 @@\n-    for (int i = 0; i < PRegister::number_of_saved_registers; i++) {\n+    for (int i = 0; i < PRegister::number_of_registers; i++) {\n@@ -2951,1 +2932,1 @@\n-    for (int i = PRegister::number_of_saved_registers - 1; i >= 0; i--) {\n+    for (int i = PRegister::number_of_registers - 1; i >= 0; i--) {\n@@ -3999,1 +3980,5 @@\n-  _masm->cbzw(rscratch1, _label);\n+  if (value) {\n+    _masm->cbnzw(rscratch1, _label);\n+  } else {\n+    _masm->cbzw(rscratch1, _label);\n+  }\n@@ -4422,1 +4407,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -4432,1 +4417,1 @@\n-                                     Address dst, Register src,\n+                                     Address dst, Register val,\n@@ -4435,1 +4420,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -4438,1 +4423,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -4440,1 +4425,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -4454,1 +4439,1 @@\n-void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,\n+void MacroAssembler::store_heap_oop(Address dst, Register val, Register tmp1,\n@@ -4456,1 +4441,1 @@\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, val, tmp1, tmp2, tmp3);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":23,"deletions":38,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -124,7 +124,0 @@\n-  \/\/ Helper functions for statistics gathering.\n-  \/\/ Unconditional atomic increment.\n-  void atomic_incw(Register counter_addr, Register tmp, Register tmp2);\n-  void atomic_incw(Address counter_addr, Register tmp1, Register tmp2, Register tmp3) {\n-    lea(tmp1, counter_addr);\n-    atomic_incw(tmp1, tmp2, tmp3);\n-  }\n@@ -134,1 +127,0 @@\n-    code_section()->relocate(inst_mark(), a.rspec());\n@@ -671,2 +663,2 @@\n-  void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed, Register dst2 = noreg);\n-  void store_sized_value(Address dst, Register src, size_t size_in_bytes, Register src2 = noreg);\n+  void load_sized_value(Register dst, Address src, size_t size_in_bytes, bool is_signed);\n+  void store_sized_value(Address dst, Register src, size_t size_in_bytes);\n@@ -864,1 +856,1 @@\n-  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register val,\n@@ -867,2 +859,2 @@\n-  void load_heap_oop(Register dst, Address src, Register tmp1 = noreg,\n-                     Register tmp2 = noreg, DecoratorSet decorators = 0);\n+  void load_heap_oop(Register dst, Address src, Register tmp1,\n+                     Register tmp2, DecoratorSet decorators = 0);\n@@ -870,4 +862,4 @@\n-  void load_heap_oop_not_null(Register dst, Address src, Register tmp1 = noreg,\n-                              Register tmp2 = noreg, DecoratorSet decorators = 0);\n-  void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,\n-                      Register tmp2 = noreg, Register tmp3 = noreg, DecoratorSet decorators = 0);\n+  void load_heap_oop_not_null(Register dst, Address src, Register tmp1,\n+                              Register tmp2, DecoratorSet decorators = 0);\n+  void store_heap_oop(Address dst, Register val, Register tmp1,\n+                      Register tmp2, Register tmp3, DecoratorSet decorators = 0);\n@@ -1197,1 +1189,1 @@\n-  \/\/ Check if branches to the the non nmethod section require a far jump\n+  \/\/ Check if branches to the non nmethod section require a far jump\n@@ -1469,0 +1461,7 @@\n+  \/\/ ChaCha20 functions support block\n+  void cc20_quarter_round(FloatRegister aVec, FloatRegister bVec,\n+          FloatRegister cVec, FloatRegister dVec, FloatRegister scratch,\n+          FloatRegister tbl);\n+  void cc20_shift_lane_org(FloatRegister bVec, FloatRegister cVec,\n+          FloatRegister dVec, bool colToDiag);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":17,"deletions":18,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-  __ load_heap_oop(method_temp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset())), temp2);\n+  __ load_heap_oop(method_temp, Address(recv, NONZERO(java_lang_invoke_MethodHandle::form_offset())), temp2, rscratch2);\n@@ -141,1 +141,1 @@\n-  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset())), temp2);\n+  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_LambdaForm::vmentry_offset())), temp2, rscratch2);\n@@ -143,1 +143,1 @@\n-  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset())), temp2);\n+  __ load_heap_oop(method_temp, Address(method_temp, NONZERO(java_lang_invoke_MemberName::method_offset())), temp2, rscratch2);\n@@ -340,1 +340,1 @@\n-        __ load_heap_oop(temp2_defc, member_clazz, temp3);\n+        __ load_heap_oop(temp2_defc, member_clazz, temp3, rscratch2);\n@@ -368,1 +368,1 @@\n-      __ load_heap_oop(rmethod, member_vmtarget);\n+      __ load_heap_oop(rmethod, member_vmtarget, temp3, rscratch2);\n@@ -376,1 +376,1 @@\n-      __ load_heap_oop(rmethod, member_vmtarget);\n+      __ load_heap_oop(rmethod, member_vmtarget, temp3, rscratch2);\n@@ -418,1 +418,1 @@\n-      __ load_heap_oop(temp3_intf, member_clazz);\n+      __ load_heap_oop(temp3_intf, member_clazz, temp2, rscratch2);\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-#define TIMES_OOP Address::sxtw(exact_log2(UseCompressedOops ? 4 : 8))\n@@ -79,4 +78,0 @@\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots);\n-void fill_continuation_entry(MacroAssembler* masm);\n-void continuation_enter_cleanup(MacroAssembler* masm);\n-\n@@ -636,2 +631,0 @@\n-  void array_overlap_test(Label& L_no_overlap, Address::sxtw sf) { __ b(L_no_overlap); }\n-\n@@ -643,0 +636,1 @@\n+    \/\/ B\n@@ -645,0 +639,15 @@\n+    \/\/ H\n+    __ emit_data64(0x0003000200010000, relocInfo::none);\n+    __ emit_data64(0x0007000600050004, relocInfo::none);\n+    \/\/ S\n+    __ emit_data64(0x0000000100000000, relocInfo::none);\n+    __ emit_data64(0x0000000300000002, relocInfo::none);\n+    \/\/ D\n+    __ emit_data64(0x0000000000000000, relocInfo::none);\n+    __ emit_data64(0x0000000000000001, relocInfo::none);\n+    \/\/ S - FP\n+    __ emit_data64(0x3F80000000000000, relocInfo::none); \/\/ 0.0f, 1.0f\n+    __ emit_data64(0x4040000040000000, relocInfo::none); \/\/ 2.0f, 3.0f\n+    \/\/ D - FP\n+    __ emit_data64(0x0000000000000000, relocInfo::none); \/\/ 0.0d\n+    __ emit_data64(0x3FF0000000000000, relocInfo::none); \/\/ 1.0d\n@@ -1809,1 +1818,1 @@\n-      array_overlap_test(L, TIMES_OOP);\n+      __ b(L);                  \/\/ conjoint check not yet implemented\n@@ -3250,1 +3259,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);\n+    __ addw(rscratch4, rscratch4, rscratch1);\n@@ -3261,1 +3270,2 @@\n-    __ eorw(rscratch2, r2, r3);\n+    __ andw(rscratch3, r2, r4);\n+    __ bicw(rscratch4, r3, r4);\n@@ -3263,2 +3273,1 @@\n-    __ andw(rscratch3, rscratch2, r4);\n-    __ eorw(rscratch3, rscratch3, r3);\n+    __ orrw(rscratch3, rscratch3, rscratch4);\n@@ -3267,1 +3276,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);\n+    __ addw(rscratch4, rscratch4, rscratch1);\n@@ -3283,1 +3292,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);\n+    __ addw(rscratch4, rscratch4, rscratch1);\n@@ -3299,1 +3308,1 @@\n-    __ addw(rscratch3, rscratch3, rscratch1);\n+    __ addw(rscratch4, rscratch4, rscratch1);\n@@ -3825,2 +3834,2 @@\n-  \/\/   c_rarg1   - byte[]   SHA.state\n-  \/\/   c_rarg2   - int     digest_length\n+  \/\/   c_rarg1   - byte[]  SHA.state\n+  \/\/   c_rarg2   - int     block_size\n@@ -3848,1 +3857,1 @@\n-    Register digest_length = c_rarg2;\n+    Register block_size    = c_rarg2;\n@@ -3853,1 +3862,1 @@\n-    Label sha3_512, sha3_384_or_224, sha3_256;\n+    Label sha3_512_or_sha3_384, shake128;\n@@ -3889,2 +3898,2 @@\n-    \/\/ digest_length == 64, SHA3-512\n-    __ tbnz(digest_length, 6, sha3_512);\n+    \/\/ block_size == 72, SHA3-512; block_size == 104, SHA3-384\n+    __ tbz(block_size, 7, sha3_512_or_sha3_384);\n@@ -3893,1 +3902,1 @@\n-    __ ld1(v29, v30, __ T8B, __ post(buf, 16));\n+    __ ld1(v29, v30, v31, __ T8B, __ post(buf, 24));\n@@ -3900,0 +3909,1 @@\n+    __ eor(v13, __ T8B, v13, v31);\n@@ -3901,10 +3911,4 @@\n-    \/\/ digest_length == 28, SHA3-224;  digest_length == 48, SHA3-384\n-    __ tbnz(digest_length, 4, sha3_384_or_224);\n-\n-    \/\/ SHA3-256\n-    __ ld1(v25, v26, v27, v28, __ T8B, __ post(buf, 32));\n-    __ eor(v13, __ T8B, v13, v25);\n-    __ eor(v14, __ T8B, v14, v26);\n-    __ eor(v15, __ T8B, v15, v27);\n-    __ eor(v16, __ T8B, v16, v28);\n-    __ b(rounds24_loop);\n+    __ ld1(v25, v26, v27,  __ T8B, __ post(buf, 24));\n+    __ eor(v14, __ T8B, v14, v25);\n+    __ eor(v15, __ T8B, v15, v26);\n+    __ eor(v16, __ T8B, v16, v27);\n@@ -3912,2 +3916,3 @@\n-    __ BIND(sha3_384_or_224);\n-    __ tbz(digest_length, 2, rounds24_loop); \/\/ bit 2 cleared? SHA-384\n+    \/\/ block_size == 136, bit4 == 0 and bit5 == 0, SHA3-256 or SHAKE256\n+    __ andw(c_rarg5, block_size, 48);\n+    __ cbzw(c_rarg5, rounds24_loop);\n@@ -3915,8 +3920,4 @@\n-    \/\/ SHA3-224\n-    __ ld1(v25, v26, v27, v28, __ T8B, __ post(buf, 32));\n-    __ ld1(v29, __ T8B, __ post(buf, 8));\n-    __ eor(v13, __ T8B, v13, v25);\n-    __ eor(v14, __ T8B, v14, v26);\n-    __ eor(v15, __ T8B, v15, v27);\n-    __ eor(v16, __ T8B, v16, v28);\n-    __ eor(v17, __ T8B, v17, v29);\n+    __ tbnz(block_size, 5, shake128);\n+    \/\/ block_size == 144, bit5 == 0, SHA3-244\n+    __ ldrd(v28, __ post(buf, 8));\n+    __ eor(v17, __ T8B, v17, v28);\n@@ -3925,1 +3926,9 @@\n-    __ BIND(sha3_512);\n+    __ BIND(shake128);\n+    __ ld1(v28, v29, v30, v31, __ T8B, __ post(buf, 32));\n+    __ eor(v17, __ T8B, v17, v28);\n+    __ eor(v18, __ T8B, v18, v29);\n+    __ eor(v19, __ T8B, v19, v30);\n+    __ eor(v20, __ T8B, v20, v31);\n+    __ b(rounds24_loop); \/\/ block_size == 168, SHAKE128\n+\n+    __ BIND(sha3_512_or_sha3_384);\n@@ -3929,0 +3938,8 @@\n+    __ tbz(block_size, 5, rounds24_loop); \/\/ SHA3-512\n+\n+    \/\/ SHA3-384\n+    __ ld1(v27, v28, v29, v30, __ T8B, __ post(buf, 32));\n+    __ eor(v9,  __ T8B, v9,  v27);\n+    __ eor(v10, __ T8B, v10, v28);\n+    __ eor(v11, __ T8B, v11, v29);\n+    __ eor(v12, __ T8B, v12, v30);\n@@ -4013,4 +4030,1 @@\n-      \/\/ block_size =  200 - 2 * digest_length, ofs += block_size\n-      __ add(ofs, ofs, 200);\n-      __ sub(ofs, ofs, digest_length, Assembler::LSL, 1);\n-\n+      __ add(ofs, ofs, block_size);\n@@ -4080,0 +4094,126 @@\n+  \/\/ ChaCha20 block function.  This version parallelizes by loading\n+  \/\/ individual 32-bit state elements into vectors for four blocks\n+  \/\/ (e.g. all four blocks' worth of state[0] in one register, etc.)\n+  \/\/\n+  \/\/ state (int[16]) = c_rarg0\n+  \/\/ keystream (byte[1024]) = c_rarg1\n+  \/\/ return - number of bytes of keystream (always 256)\n+  address generate_chacha20Block_blockpar() {\n+    Label L_twoRounds, L_cc20_const;\n+    \/\/ The constant data is broken into two 128-bit segments to be loaded\n+    \/\/ onto FloatRegisters.  The first 128 bits are a counter add overlay\n+    \/\/ that adds +0\/+1\/+2\/+3 to the vector holding replicated state[12].\n+    \/\/ The second 128-bits is a table constant used for 8-bit left rotations.\n+    __ BIND(L_cc20_const);\n+    __ emit_int64(0x0000000100000000UL);\n+    __ emit_int64(0x0000000300000002UL);\n+    __ emit_int64(0x0605040702010003UL);\n+    __ emit_int64(0x0E0D0C0F0A09080BUL);\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    int i, j;\n+    const Register state = c_rarg0;\n+    const Register keystream = c_rarg1;\n+    const Register loopCtr = r10;\n+    const Register tmpAddr = r11;\n+\n+    const FloatRegister stateFirst = v0;\n+    const FloatRegister stateSecond = v1;\n+    const FloatRegister stateThird = v2;\n+    const FloatRegister stateFourth = v3;\n+    const FloatRegister origCtrState = v28;\n+    const FloatRegister scratch = v29;\n+    const FloatRegister lrot8Tbl = v30;\n+\n+    \/\/ Organize SIMD registers in an array that facilitates\n+    \/\/ putting repetitive opcodes into loop structures.  It is\n+    \/\/ important that each grouping of 4 registers is monotonically\n+    \/\/ increasing to support the requirements of multi-register\n+    \/\/ instructions (e.g. ld4r, st4, etc.)\n+    const FloatRegister workSt[16] = {\n+         v4,  v5,  v6,  v7, v16, v17, v18, v19,\n+        v20, v21, v22, v23, v24, v25, v26, v27\n+    };\n+\n+    \/\/ Load from memory and interlace across 16 SIMD registers,\n+    \/\/ With each word from memory being broadcast to all lanes of\n+    \/\/ each successive SIMD register.\n+    \/\/      Addr(0) -> All lanes in workSt[i]\n+    \/\/      Addr(4) -> All lanes workSt[i + 1], etc.\n+    __ mov(tmpAddr, state);\n+    for (i = 0; i < 16; i += 4) {\n+      __ ld4r(workSt[i], workSt[i + 1], workSt[i + 2], workSt[i + 3], __ T4S,\n+          __ post(tmpAddr, 16));\n+    }\n+\n+    \/\/ Pull in constant data.  The first 16 bytes are the add overlay\n+    \/\/ which is applied to the vector holding the counter (state[12]).\n+    \/\/ The second 16 bytes is the index register for the 8-bit left\n+    \/\/ rotation tbl instruction.\n+    __ adr(tmpAddr, L_cc20_const);\n+    __ ldpq(origCtrState, lrot8Tbl, Address(tmpAddr));\n+    __ addv(workSt[12], __ T4S, workSt[12], origCtrState);\n+\n+    \/\/ Set up the 10 iteration loop and perform all 8 quarter round ops\n+    __ mov(loopCtr, 10);\n+    __ BIND(L_twoRounds);\n+\n+    __ cc20_quarter_round(workSt[0], workSt[4], workSt[8], workSt[12],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[1], workSt[5], workSt[9], workSt[13],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[2], workSt[6], workSt[10], workSt[14],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[3], workSt[7], workSt[11], workSt[15],\n+        scratch, lrot8Tbl);\n+\n+    __ cc20_quarter_round(workSt[0], workSt[5], workSt[10], workSt[15],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[1], workSt[6], workSt[11], workSt[12],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[2], workSt[7], workSt[8], workSt[13],\n+        scratch, lrot8Tbl);\n+    __ cc20_quarter_round(workSt[3], workSt[4], workSt[9], workSt[14],\n+        scratch, lrot8Tbl);\n+\n+    \/\/ Decrement and iterate\n+    __ sub(loopCtr, loopCtr, 1);\n+    __ cbnz(loopCtr, L_twoRounds);\n+\n+    __ mov(tmpAddr, state);\n+\n+    \/\/ Add the starting state back to the post-loop keystream\n+    \/\/ state.  We read\/interlace the state array from memory into\n+    \/\/ 4 registers similar to what we did in the beginning.  Then\n+    \/\/ add the counter overlay onto workSt[12] at the end.\n+    for (i = 0; i < 16; i += 4) {\n+      __ ld4r(stateFirst, stateSecond, stateThird, stateFourth, __ T4S,\n+          __ post(tmpAddr, 16));\n+      __ addv(workSt[i], __ T4S, workSt[i], stateFirst);\n+      __ addv(workSt[i + 1], __ T4S, workSt[i + 1], stateSecond);\n+      __ addv(workSt[i + 2], __ T4S, workSt[i + 2], stateThird);\n+      __ addv(workSt[i + 3], __ T4S, workSt[i + 3], stateFourth);\n+    }\n+    __ addv(workSt[12], __ T4S, workSt[12], origCtrState);    \/\/ Add ctr mask\n+\n+    \/\/ Write to key stream, storing the same element out of workSt[0..15]\n+    \/\/ to consecutive 4-byte offsets in the key stream buffer, then repeating\n+    \/\/ for the next element position.\n+    for (i = 0; i < 4; i++) {\n+      for (j = 0; j < 16; j += 4) {\n+        __ st4(workSt[j], workSt[j + 1], workSt[j + 2], workSt[j + 3], __ S, i,\n+            __ post(keystream, 16));\n+      }\n+    }\n+\n+    __ mov(r0, 256);             \/\/ Return length of output keystream\n+    __ leave();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -7884,1 +8024,3 @@\n-    StubRoutines::aarch64::_vector_iota_indices    = generate_iota_indices(\"iota_indices\");\n+    if (UseSVE == 0) {\n+      StubRoutines::aarch64::_vector_iota_indices = generate_iota_indices(\"iota_indices\");\n+    }\n@@ -7941,0 +8083,4 @@\n+    if (UseChaCha20Intrinsics) {\n+      StubRoutines::_chacha20Block = generate_chacha20Block_blockpar();\n+    }\n+\n@@ -8054,72 +8200,0 @@\n-\n-\n-#undef __\n-#define __ masm->\n-\n-\/\/ on exit, sp points to the ContinuationEntry\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n-  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n-\n-  stack_slots += (int)ContinuationEntry::size()\/wordSize;\n-  __ sub(sp, sp, (int)ContinuationEntry::size()); \/\/ place Continuation metadata\n-\n-  OopMap* map = new OopMap(((int)ContinuationEntry::size() + wordSize)\/ VMRegImpl::stack_slot_size, 0 \/* arg_slots*\/);\n-  ContinuationEntry::setup_oopmap(map);\n-\n-  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_offset()));\n-  __ mov(rscratch1, sp); \/\/ we can't use sp as the source in str\n-  __ str(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-\n-  return map;\n-}\n-\n-\/\/ on entry c_rarg1 points to the continuation\n-\/\/          sp points to ContinuationEntry\n-\/\/          c_rarg3 -- isVirtualThread\n-void fill_continuation_entry(MacroAssembler* masm) {\n-#ifdef ASSERT\n-  __ movw(rscratch1, ContinuationEntry::cookie_value());\n-  __ strw(rscratch1, Address(sp, ContinuationEntry::cookie_offset()));\n-#endif\n-\n-  __ str (c_rarg1, Address(sp, ContinuationEntry::cont_offset()));\n-  __ strw(c_rarg3, Address(sp, ContinuationEntry::flags_offset()));\n-  __ str (zr,      Address(sp, ContinuationEntry::chunk_offset()));\n-  __ strw(zr,      Address(sp, ContinuationEntry::argsize_offset()));\n-  __ strw(zr,      Address(sp, ContinuationEntry::pin_count_offset()));\n-\n-  __ ldr(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n-  __ ldr(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-\n-  __ str(zr, Address(rthread, JavaThread::cont_fastpath_offset()));\n-  __ str(zr, Address(rthread, JavaThread::held_monitor_count_offset()));\n-}\n-\n-\/\/ on entry, sp points to the ContinuationEntry\n-\/\/ on exit, rfp points to the spilled rfp in the entry frame\n-void continuation_enter_cleanup(MacroAssembler* masm) {\n-#ifndef PRODUCT\n-  Label OK;\n-  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-  __ cmp(sp, rscratch1);\n-  __ br(Assembler::EQ, OK);\n-  __ stop(\"incorrect sp1\");\n-  __ bind(OK);\n-#endif\n-\n-  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n-  __ str(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n-  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ str(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-  __ ldr(rscratch2, Address(sp, ContinuationEntry::parent_offset()));\n-  __ str(rscratch2, Address(rthread, JavaThread::cont_entry_offset()));\n-  __ add(rfp, sp, (int)ContinuationEntry::size());\n-}\n-\n-#undef __\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":194,"deletions":120,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-void TemplateTable::ldc(bool wide)\n+void TemplateTable::ldc(LdcType type)\n@@ -317,1 +317,1 @@\n-  if (wide) {\n+  if (is_ldc_wide(type)) {\n@@ -346,1 +346,1 @@\n-  __ mov(c_rarg1, wide);\n+  __ mov(c_rarg1, is_ldc_wide(type) ? 1 : 0);\n@@ -379,1 +379,1 @@\n-void TemplateTable::fast_aldc(bool wide)\n+void TemplateTable::fast_aldc(LdcType type)\n@@ -387,1 +387,1 @@\n-  int index_size = wide ? sizeof(u2) : sizeof(u1);\n+  int index_size = is_ldc_wide(type) ? sizeof(u2) : sizeof(u1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -65,0 +67,4 @@\n+\n+  \/\/ Insert nmethod entry barrier into frame.\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->nmethod_entry_barrier(this);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1184,0 +1184,8 @@\n+void MacroAssembler::post_call_nop() {\n+  \/\/ Make inline again when loom is always enabled.\n+  if (!Continuations::enabled()) {\n+    return;\n+  }\n+  nop();\n+}\n+\n@@ -2628,0 +2636,1 @@\n+  Label success, failure;\n@@ -2636,1 +2645,1 @@\n-    bne(flag, cont);\n+    bne(flag, failure);\n@@ -2674,0 +2683,3 @@\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object and we have now locked it.\n+    b(success);\n@@ -2677,0 +2689,1 @@\n+    b(failure);\n@@ -2679,4 +2692,0 @@\n-  \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-  \/\/ object and we have now locked it.\n-  b(cont);\n-\n@@ -2697,1 +2706,0 @@\n-  \/\/ Handle existing monitor.\n@@ -2700,0 +2708,1 @@\n+  \/\/ Handle existing monitor.\n@@ -2724,1 +2733,1 @@\n-  beq(flag, cont);\n+  beq(flag, success);\n@@ -2728,1 +2737,1 @@\n-  bne(flag, cont);\n+  bne(flag, failure);\n@@ -2741,1 +2750,1 @@\n-  \/\/ flag == EQ indicates success\n+  \/\/ flag == EQ indicates success, increment held monitor count\n@@ -2743,0 +2752,4 @@\n+  bne(flag, failure);\n+  bind(success);\n+  inc_held_monitor_count(temp);\n+  bind(failure);\n@@ -2750,1 +2763,2 @@\n-  Label cont, object_has_monitor, notRecursive;\n+  Label object_has_monitor, notRecursive;\n+  Label success, failure;\n@@ -2760,1 +2774,1 @@\n-    b(cont);                                                    \/\/ ... and we're done\n+    b(success);                                                 \/\/ ... and we're done\n@@ -2771,1 +2785,1 @@\n-    beq(flag, cont);\n+    beq(flag, success);\n@@ -2793,1 +2807,1 @@\n-             &cont);\n+             &failure);\n@@ -2795,0 +2809,1 @@\n+    b(success);\n@@ -2798,0 +2813,1 @@\n+    b(failure);\n@@ -2801,2 +2817,0 @@\n-  b(cont);\n-\n@@ -2816,1 +2830,1 @@\n-    b(cont);\n+    b(success);\n@@ -2824,1 +2838,1 @@\n-  bne(flag, cont);\n+  bne(flag, failure);\n@@ -2829,1 +2843,1 @@\n-  b(cont); \/\/ flag is already EQ here.\n+  b(success); \/\/ flag is already EQ here.\n@@ -2836,1 +2850,1 @@\n-  bne(flag, cont);\n+  bne(flag, failure);\n@@ -2840,2 +2854,1 @@\n-  bind(cont);\n-  \/\/ flag == EQ indicates success\n+  \/\/ flag == EQ indicates success, decrement held monitor count\n@@ -2843,0 +2856,3 @@\n+  bind(success);\n+  dec_held_monitor_count(temp);\n+  bind(failure);\n@@ -4374,0 +4390,45 @@\n+\n+void MacroAssembler::push_cont_fastpath() {\n+  Label done;\n+  ld_ptr(R0, JavaThread::cont_fastpath_offset(), R16_thread);\n+  cmpld(CCR0, R1_SP, R0);\n+  ble(CCR0, done);\n+  st_ptr(R1_SP, JavaThread::cont_fastpath_offset(), R16_thread);\n+  bind(done);\n+}\n+\n+void MacroAssembler::pop_cont_fastpath() {\n+  Label done;\n+  ld_ptr(R0, JavaThread::cont_fastpath_offset(), R16_thread);\n+  cmpld(CCR0, R1_SP, R0);\n+  ble(CCR0, done);\n+  li(R0, 0);\n+  st_ptr(R0, JavaThread::cont_fastpath_offset(), R16_thread);\n+  bind(done);\n+}\n+\n+void MacroAssembler::inc_held_monitor_count(Register tmp) {\n+  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+#ifdef ASSERT\n+  Label ok;\n+  cmpdi(CCR0, tmp, 0);\n+  bge_predict_taken(CCR0, ok);\n+  stop(\"held monitor count is negativ at increment\");\n+  bind(ok);\n+#endif\n+  addi(tmp, tmp, 1);\n+  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+}\n+\n+void MacroAssembler::dec_held_monitor_count(Register tmp) {\n+  ld(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+#ifdef ASSERT\n+  Label ok;\n+  cmpdi(CCR0, tmp, 0);\n+  bgt_predict_taken(CCR0, ok);\n+  stop(\"held monitor count is <= 0 at decrement\");\n+  bind(ok);\n+#endif\n+  addi(tmp, tmp, -1);\n+  std(tmp, in_bytes(JavaThread::held_monitor_count_offset()), R16_thread);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":82,"deletions":21,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -3862,1 +3862,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -3881,1 +3881,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3458,1 +3458,1 @@\n-    __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)));\n+    __ incrementl(ExternalAddress(Runtime1::arraycopy_count_address(basic_type)), rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,1 +167,0 @@\n-  jcc(Assembler::zero, done);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -31,0 +30,1 @@\n+#include \"crc32c.h\"\n@@ -37,1 +37,1 @@\n-#include \"logging\/log.hpp\"\n+#include \"jvm.h\"\n@@ -57,1 +57,0 @@\n-#include \"crc32c.h\"\n@@ -1222,0 +1221,13 @@\n+#ifdef _LP64\n+void MacroAssembler::andq(Register dst, AddressLiteral src, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    andq(dst, as_Address(src));\n+  } else {\n+    lea(rscratch, src);\n+    andq(dst, Address(rscratch, 0));\n+  }\n+}\n+#endif\n+\n@@ -5153,1 +5165,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -5162,1 +5174,1 @@\n-void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+void MacroAssembler::access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register val,\n@@ -5165,1 +5177,1 @@\n-  decorators = AccessInternal::decorator_fixup(decorators);\n+  decorators = AccessInternal::decorator_fixup(decorators, type);\n@@ -5168,1 +5180,1 @@\n-    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->BarrierSetAssembler::store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -5170,1 +5182,1 @@\n-    bs->store_at(this, decorators, type, dst, src, tmp1, tmp2, tmp3);\n+    bs->store_at(this, decorators, type, dst, val, tmp1, tmp2, tmp3);\n@@ -5185,1 +5197,1 @@\n-void MacroAssembler::store_heap_oop(Address dst, Register src, Register tmp1,\n+void MacroAssembler::store_heap_oop(Address dst, Register val, Register tmp1,\n@@ -5187,1 +5199,1 @@\n-  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, src, tmp1, tmp2, tmp3);\n+  access_store_at(T_OBJECT, IN_HEAP | decorators, dst, val, tmp1, tmp2, tmp3);\n@@ -9154,20 +9166,0 @@\n-void MacroAssembler::anytrue(Register dst, uint masklen, KRegister src1, KRegister src2) {\n-   masklen = masklen < 8 ? 8 : masklen;\n-   ktest(masklen, src1, src2);\n-   setb(Assembler::notZero, dst);\n-   movzbl(dst, dst);\n-}\n-\n-void MacroAssembler::alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch) {\n-  if (masklen < 8) {\n-    knotbl(kscratch, src2);\n-    kortestbl(src1, kscratch);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  } else {\n-    ktest(masklen, src1, src2);\n-    setb(Assembler::carrySet, dst);\n-    movzbl(dst, dst);\n-  }\n-}\n-\n@@ -9259,0 +9251,34 @@\n+\n+void MacroAssembler::evpandq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    evpandq(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    evpandq(dst, nds, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n+void MacroAssembler::evporq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    evporq(dst, nds, as_Address(src), vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    evporq(dst, nds, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n+void MacroAssembler::vpternlogq(XMMRegister dst, int imm8, XMMRegister src2, AddressLiteral src3, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src3), \"missing\");\n+\n+  if (reachable(src3)) {\n+    vpternlogq(dst, imm8, src2, as_Address(src3), vector_len);\n+  } else {\n+    lea(rscratch, src3);\n+    vpternlogq(dst, imm8, src2, Address(rscratch, 0), vector_len);\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":56,"deletions":30,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -382,1 +382,1 @@\n-  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register src,\n+  void access_store_at(BasicType type, DecoratorSet decorators, Address dst, Register val,\n@@ -389,1 +389,1 @@\n-  void store_heap_oop(Address dst, Register src, Register tmp1 = noreg,\n+  void store_heap_oop(Address dst, Register val, Register tmp1 = noreg,\n@@ -758,0 +758,5 @@\n+#ifdef _LP64\n+  using Assembler::andq;\n+  void andq(Register dst, AddressLiteral src, Register rscratch = noreg);\n+#endif\n+\n@@ -1782,2 +1787,8 @@\n-  void alltrue(Register dst, uint masklen, KRegister src1, KRegister src2, KRegister kscratch);\n-  void anytrue(Register dst, uint masklen, KRegister src, KRegister kscratch);\n+  using Assembler::evpandq;\n+  void evpandq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n+  using Assembler::evporq;\n+  void evporq(XMMRegister dst, XMMRegister nds, AddressLiteral src, int vector_len, Register rscratch = noreg);\n+\n+  using Assembler::vpternlogq;\n+  void vpternlogq(XMMRegister dst, int imm8, XMMRegister src2, AddressLiteral src3, int vector_len, Register rscratch = noreg);\n@@ -2004,4 +2015,0 @@\n-\n-  OopMap* continuation_enter_setup(int& stack_slots);\n-  void fill_continuation_entry(Register reg_cont_obj, Register reg_flags);\n-  void continuation_enter_cleanup();\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -33,0 +32,1 @@\n+#include \"jvm.h\"\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-\n+  \/\/ B\n@@ -823,1 +823,45 @@\n-\n+  \/\/ W\n+  __ emit_data64(0x0003000200010000, relocInfo::none);\n+  __ emit_data64(0x0007000600050004, relocInfo::none);\n+  __ emit_data64(0x000B000A00090008, relocInfo::none);\n+  __ emit_data64(0x000F000E000D000C, relocInfo::none);\n+  __ emit_data64(0x0013001200110010, relocInfo::none);\n+  __ emit_data64(0x0017001600150014, relocInfo::none);\n+  __ emit_data64(0x001B001A00190018, relocInfo::none);\n+  __ emit_data64(0x001F001E001D001C, relocInfo::none);\n+  \/\/ D\n+  __ emit_data64(0x0000000100000000, relocInfo::none);\n+  __ emit_data64(0x0000000300000002, relocInfo::none);\n+  __ emit_data64(0x0000000500000004, relocInfo::none);\n+  __ emit_data64(0x0000000700000006, relocInfo::none);\n+  __ emit_data64(0x0000000900000008, relocInfo::none);\n+  __ emit_data64(0x0000000B0000000A, relocInfo::none);\n+  __ emit_data64(0x0000000D0000000C, relocInfo::none);\n+  __ emit_data64(0x0000000F0000000E, relocInfo::none);\n+  \/\/ Q\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0x0000000000000001, relocInfo::none);\n+  __ emit_data64(0x0000000000000002, relocInfo::none);\n+  __ emit_data64(0x0000000000000003, relocInfo::none);\n+  __ emit_data64(0x0000000000000004, relocInfo::none);\n+  __ emit_data64(0x0000000000000005, relocInfo::none);\n+  __ emit_data64(0x0000000000000006, relocInfo::none);\n+  __ emit_data64(0x0000000000000007, relocInfo::none);\n+  \/\/ D - FP\n+  __ emit_data64(0x3F80000000000000, relocInfo::none); \/\/ 0.0f, 1.0f\n+  __ emit_data64(0x4040000040000000, relocInfo::none); \/\/ 2.0f, 3.0f\n+  __ emit_data64(0x40A0000040800000, relocInfo::none); \/\/ 4.0f, 5.0f\n+  __ emit_data64(0x40E0000040C00000, relocInfo::none); \/\/ 6.0f, 7.0f\n+  __ emit_data64(0x4110000041000000, relocInfo::none); \/\/ 8.0f, 9.0f\n+  __ emit_data64(0x4130000041200000, relocInfo::none); \/\/ 10.0f, 11.0f\n+  __ emit_data64(0x4150000041400000, relocInfo::none); \/\/ 12.0f, 13.0f\n+  __ emit_data64(0x4170000041600000, relocInfo::none); \/\/ 14.0f, 15.0f\n+  \/\/ Q - FP\n+  __ emit_data64(0x0000000000000000, relocInfo::none); \/\/ 0.0d\n+  __ emit_data64(0x3FF0000000000000, relocInfo::none); \/\/ 1.0d\n+  __ emit_data64(0x4000000000000000, relocInfo::none); \/\/ 2.0d\n+  __ emit_data64(0x4008000000000000, relocInfo::none); \/\/ 3.0d\n+  __ emit_data64(0x4010000000000000, relocInfo::none); \/\/ 4.0d\n+  __ emit_data64(0x4014000000000000, relocInfo::none); \/\/ 5.0d\n+  __ emit_data64(0x4018000000000000, relocInfo::none); \/\/ 6.0d\n+  __ emit_data64(0x401c000000000000, relocInfo::none); \/\/ 7.0d\n@@ -2478,1 +2522,1 @@\n-    __ vporq(mask, tmp, input_initial_valid_b64, Assembler::AVX_512bit);\n+    __ evporq(mask, tmp, input_initial_valid_b64, Assembler::AVX_512bit);\n@@ -3294,1 +3338,1 @@\n-      StubRoutines::_dtan = generate_libmTan();\n+      StubRoutines::_dtan = generate_libmTan(); \/\/ from stubGenerator_x86_64_tan.cpp\n@@ -3297,1 +3341,1 @@\n-      StubRoutines::_dexp = generate_libmExp();\n+      StubRoutines::_dexp = generate_libmExp(); \/\/ from stubGenerator_x86_64_exp.cpp\n@@ -3300,1 +3344,1 @@\n-      StubRoutines::_dpow = generate_libmPow();\n+      StubRoutines::_dpow = generate_libmPow(); \/\/ from stubGenerator_x86_64_pow.cpp\n@@ -3303,1 +3347,1 @@\n-      StubRoutines::_dlog = generate_libmLog();\n+      StubRoutines::_dlog = generate_libmLog(); \/\/ from stubGenerator_x86_64_log.cpp\n@@ -3306,1 +3350,1 @@\n-      StubRoutines::_dlog10 = generate_libmLog10();\n+      StubRoutines::_dlog10 = generate_libmLog10(); \/\/ from stubGenerator_x86_64_log.cpp\n@@ -3708,0 +3752,4 @@\n+  if (UsePoly1305Intrinsics) {\n+    StubRoutines::_poly1305_processBlocks = generate_poly1305_processBlocks();\n+  }\n+\n@@ -3718,0 +3766,2 @@\n+\n+  generate_libm_stubs();\n@@ -3806,0 +3856,2 @@\n+  generate_chacha_stubs();\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":60,"deletions":8,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -390,0 +390,30 @@\n+  \/\/ ChaCha20 stubs and helper functions\n+  void generate_chacha_stubs();\n+  address generate_chacha20Block_avx();\n+  address generate_chacha20Block_avx512();\n+  void cc20_quarter_round_avx(XMMRegister aVec, XMMRegister bVec,\n+    XMMRegister cVec, XMMRegister dVec, XMMRegister scratch,\n+    XMMRegister lrot8, XMMRegister lrot16, int vector_len);\n+  void cc20_shift_lane_org(XMMRegister bVec, XMMRegister cVec,\n+    XMMRegister dVec, int vector_len, bool colToDiag);\n+  void cc20_keystream_collate_avx512(XMMRegister aVec, XMMRegister bVec,\n+    XMMRegister cVec, XMMRegister dVec, Register baseAddr, int baseOffset);\n+\n+  \/\/ Poly1305 multiblock using IFMA instructions\n+  address generate_poly1305_processBlocks();\n+  void poly1305_process_blocks_avx512(const Register input, const Register length,\n+                                      const Register A0, const Register A1, const Register A2,\n+                                      const Register R0, const Register R1, const Register C1);\n+  void poly1305_multiply_scalar(const Register a0, const Register a1, const Register a2,\n+                                const Register r0, const Register r1, const Register c1, bool only128,\n+                                const Register t0, const Register t1, const Register t2,\n+                                const Register mulql, const Register mulqh);\n+  void poly1305_multiply8_avx512(const XMMRegister A0, const XMMRegister A1, const XMMRegister A2,\n+                                 const XMMRegister R0, const XMMRegister R1, const XMMRegister R2, const XMMRegister R1P, const XMMRegister R2P,\n+                                 const XMMRegister P0L, const XMMRegister P0H, const XMMRegister P1L, const XMMRegister P1H, const XMMRegister P2L, const XMMRegister P2H,\n+                                 const XMMRegister TMP, const Register rscratch);\n+  void poly1305_limbs(const Register limbs, const Register a0, const Register a1, const Register a2, const Register t0, const Register t1);\n+  void poly1305_limbs_out(const Register a0, const Register a1, const Register a2, const Register limbs, const Register t0, const Register t1);\n+  void poly1305_limbs_avx512(const XMMRegister D0, const XMMRegister D1,\n+                             const XMMRegister L0, const XMMRegister L1, const XMMRegister L2, bool padMSG,\n+                             const XMMRegister TMP, const Register rscratch);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -353,1 +353,1 @@\n-void TemplateTable::ldc(bool wide) {\n+void TemplateTable::ldc(LdcType type) {\n@@ -358,1 +358,1 @@\n-  if (wide) {\n+  if (is_ldc_wide(type)) {\n@@ -386,1 +386,1 @@\n-  __ movl(rarg, wide);\n+  __ movl(rarg, is_ldc_wide(type) ? 1 : 0);\n@@ -418,1 +418,1 @@\n-void TemplateTable::fast_aldc(bool wide) {\n+void TemplateTable::fast_aldc(LdcType type) {\n@@ -424,1 +424,1 @@\n-  int index_size = wide ? sizeof(u2) : sizeof(u1);\n+  int index_size = is_ldc_wide(type) ? sizeof(u2) : sizeof(u1);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -322,0 +322,8 @@\n+\n+source_hpp %{\n+\n+#include \"peephole_x86_64.hpp\"\n+\n+%}\n+\n+\/\/ Register masks\n@@ -964,2 +972,2 @@\n-    st->print_cr(\"cmpq     rsp, poll_offset[r15_thread] \\n\\t\"\n-                 \"ja       #safepoint_stub\\t\"\n+    st->print_cr(\"cmpq    rsp, poll_offset[r15_thread] \\n\\t\"\n+                 \"ja      #safepoint_stub\\t\"\n@@ -1015,1 +1023,3 @@\n-      code_stub = &C->output()->safepoint_poll_table()->add_safepoint(__ offset());\n+      C2SafepointPollStub* stub = new (C->comp_arena()) C2SafepointPollStub(__ offset());\n+      C->output()->add_stub(stub);\n+      code_stub = &stub->entry();\n@@ -2159,1 +2169,0 @@\n-    $$$emit8$primary;\n@@ -2162,0 +2171,1 @@\n+      $$$emit8$primary;\n@@ -2165,0 +2175,5 @@\n+    } else if (_method->intrinsic_id() == vmIntrinsicID::_ensureMaterializedForStackWalk) {\n+      \/\/ The NOP here is purely to ensure that eliding a call to\n+      \/\/ JVM_EnsureMaterializedForStackWalk doesn't change the code size.\n+      __ addr_nop_5();\n+      __ block_comment(\"call JVM_EnsureMaterializedForStackWalk (elided)\");\n@@ -2166,0 +2181,1 @@\n+      $$$emit8$primary;\n@@ -9006,0 +9022,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salI_rReg_immI2(rRegI dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftI dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"sall    $dst, $shift\" %}\n+  ins_encode %{\n+    __ sall($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -9240,0 +9269,13 @@\n+\/\/ Shift Left by one, two, three\n+instruct salL_rReg_immI2(rRegL dst, immI2 shift, rFlagsReg cr)\n+%{\n+  match(Set dst (LShiftL dst shift));\n+  effect(KILL cr);\n+\n+  format %{ \"salq    $dst, $shift\" %}\n+  ins_encode %{\n+    __ salq($dst$$Register, $shift$$constant);\n+  %}\n+  ins_pipe(ialu_reg);\n+%}\n+\n@@ -13550,0 +13592,3 @@\n+\/\/ peeppredicate ( rule_predicate );\n+\/\/ \/\/ the predicate unless which the peephole rule will be ignored\n+\/\/\n@@ -13552,0 +13597,10 @@\n+\/\/ peepprocedure ( procedure_name );\n+\/\/ \/\/ provide a procedure name to perform the optimization, the procedure should\n+\/\/ \/\/ reside in the architecture dependent peephole file, the method has the\n+\/\/ \/\/ signature of MachNode* (Block*, int, PhaseRegAlloc*, (MachNode*)(*)(), int...)\n+\/\/ \/\/ with the arguments being the basic block, the current node index inside the\n+\/\/ \/\/ block, the register allocator, the functions upon invoked return a new node\n+\/\/ \/\/ defined in peepreplace, and the rules of the nodes appearing in the\n+\/\/ \/\/ corresponding peepmatch, the function return true if successful, else\n+\/\/ \/\/ return false\n+\/\/\n@@ -13572,4 +13627,1 @@\n-\/\/ Only match adjacent instructions in same basic block\n-\/\/ Only equality constraints\n-\/\/ Only constraints between operands, not (0.dest_reg == RAX_enc)\n-\/\/ Only one replacement instruction\n+\/\/ Only transformations inside a basic block (do we need more for peephole)\n@@ -13591,0 +13643,11 @@\n+\/\/ instruct leaI_rReg_immI(rRegI dst, immI_1 src)\n+\/\/ %{\n+\/\/   match(Set dst (AddI dst src));\n+\/\/ %}\n+\/\/\n+\/\/ 1. Simple replacement\n+\/\/ - Only match adjacent instructions in same basic block\n+\/\/ - Only equality constraints\n+\/\/ - Only constraints between operands, not (0.dest_reg == RAX_enc)\n+\/\/ - Only one replacement instruction\n+\/\/\n@@ -13593,0 +13656,2 @@\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n@@ -13603,3 +13668,6 @@\n-\n-\/\/ Implementation no longer uses movX instructions since\n-\/\/ machine-independent system no longer uses CopyX nodes.\n+\/\/ 2. Procedural replacement\n+\/\/ - More flexible finding relevent nodes\n+\/\/ - More flexible constraints\n+\/\/ - More flexible transformations\n+\/\/ - May utilise architecture-dependent API more effectively\n+\/\/ - Currently only one replacement instruction due to adlc parsing capabilities\n@@ -13607,5 +13675,11 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n+\/\/ \/\/ Change (inc mov) to lea\n+\/\/ peephole %{\n+\/\/   \/\/ lea should only be emitted when beneficial\n+\/\/   peeppredicate( VM_Version::supports_fast_2op_lea() );\n+\/\/   \/\/ the rule numbers of these nodes inside are passed into the function below\n+\/\/   peepmatch ( incI_rReg movI );\n+\/\/   \/\/ the method that takes the responsibility of transformation\n+\/\/   peepprocedure ( inc_mov_to_lea );\n+\/\/   \/\/ the replacement is a leaI_rReg_immI, a lambda upon invoked creating this\n+\/\/   \/\/ node is passed into the function above\n+\/\/   peepreplace ( leaI_rReg_immI() );\n@@ -13614,6 +13688,19 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decI_rReg movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+\/\/ These instructions is not matched by the matcher but used by the peephole\n+instruct leaI_rReg_rReg_peep(rRegI dst, rRegI src1, rRegI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leal(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leal(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13621,6 +13708,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addI_rReg_imm movI);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaI_rReg_immI(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI_peep(rRegI dst, rRegI src1, immI src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddI src1 src2));\n+  format %{ \"leal    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leal($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13628,6 +13719,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (incL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaI_rReg_immI2_peep(rRegI dst, rRegI src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftI src shift));\n+  format %{ \"leal    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leal($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leal($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13635,6 +13736,18 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (decL_rReg movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_rReg_peep(rRegL dst, rRegL src1, rRegL src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    Register dst = $dst$$Register;\n+    Register src1 = $src1$$Register;\n+    Register src2 = $src2$$Register;\n+    if (src1 != rbp && src1 != r13) {\n+      __ leaq(dst, Address(src1, src2, Address::times_1));\n+    } else {\n+      assert(src2 != rbp && src2 != r13, \"\");\n+      __ leaq(dst, Address(src2, src1, Address::times_1));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13642,6 +13755,10 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addL_rReg_imm movL);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaL_rReg_immL(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immL32_peep(rRegL dst, rRegL src1, immL32 src2)\n+%{\n+  predicate(false);\n+  match(Set dst (AddL src1 src2));\n+  format %{ \"leaq    $dst, [$src1 + $src2]\" %}\n+  ins_encode %{\n+    __ leaq($dst$$Register, Address($src1$$Register, $src2$$constant));\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13649,6 +13766,16 @@\n-\/\/ peephole\n-\/\/ %{\n-\/\/   peepmatch (addP_rReg_imm movP);\n-\/\/   peepconstraint (0.dst == 1.dst);\n-\/\/   peepreplace (leaP_rReg_imm(0.dst 1.src 0.src));\n-\/\/ %}\n+instruct leaL_rReg_immI2_peep(rRegL dst, rRegL src, immI2 shift)\n+%{\n+  predicate(false);\n+  match(Set dst (LShiftL src shift));\n+  format %{ \"leaq    $dst, [$src << $shift]\" %}\n+  ins_encode %{\n+    Address::ScaleFactor scale = static_cast<Address::ScaleFactor>($shift$$constant);\n+    Register src = $src$$Register;\n+    if (scale == Address::times_2 && src != rbp && src != r13) {\n+      __ leaq($dst$$Register, Address(src, src, Address::times_1));\n+    } else {\n+      __ leaq($dst$$Register, Address(noreg, src, scale));\n+    }\n+  %}\n+  ins_pipe(ialu_reg_reg);\n+%}\n@@ -13656,11 +13783,63 @@\n-\/\/ \/\/ Change load of spilled value to only a spill\n-\/\/ instruct storeI(memory mem, rRegI src)\n-\/\/ %{\n-\/\/   match(Set mem (StoreI mem src));\n-\/\/ %}\n-\/\/\n-\/\/ instruct loadI(rRegI dst, memory mem)\n-\/\/ %{\n-\/\/   match(Set dst (LoadI mem));\n-\/\/ %}\n-\/\/\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaI_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addI_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decI_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salI_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaI_rReg_immI2_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg);\n+  peepprocedure (lea_coalesce_reg);\n+  peepreplace (leaL_rReg_rReg_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (addL_rReg_imm);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n+\n+peephole\n+%{\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (incL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n+%}\n@@ -13670,3 +13849,4 @@\n-  peepmatch (loadI storeI);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeI(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (decL_rReg);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immL32_peep());\n@@ -13677,3 +13857,4 @@\n-  peepmatch (loadL storeL);\n-  peepconstraint (1.src == 0.dst, 1.mem == 0.mem);\n-  peepreplace (storeL(1.mem 1.mem 1.src));\n+  peeppredicate(VM_Version::supports_fast_2op_lea());\n+  peepmatch (salL_rReg_immI2);\n+  peepprocedure (lea_coalesce_imm);\n+  peepreplace (leaL_rReg_immI2_peep());\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":250,"deletions":69,"binary":false,"changes":319,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-  if (TwoOperandLIRForm) {\n+  if (two_operand_lir_form) {\n@@ -536,1 +536,1 @@\n-                                                 do_stub(opAllocObj->_stub);\n+      if (opAllocObj->_stub != nullptr)          do_stub(opAllocObj->_stub);\n@@ -836,1 +836,1 @@\n-                                                  do_stub(opTypeCheck->_stub);\n+      if (opTypeCheck->_stub != nullptr)          do_stub(opTypeCheck->_stub);\n@@ -845,15 +845,12 @@\n-      LIR_OpCompareAndSwap* opCompareAndSwap = (LIR_OpCompareAndSwap*)op;\n-\n-      assert(opCompareAndSwap->_addr->is_valid(),      \"used\");\n-      assert(opCompareAndSwap->_cmp_value->is_valid(), \"used\");\n-      assert(opCompareAndSwap->_new_value->is_valid(), \"used\");\n-      if (opCompareAndSwap->_info)                    do_info(opCompareAndSwap->_info);\n-                                                      do_input(opCompareAndSwap->_addr);\n-                                                      do_temp(opCompareAndSwap->_addr);\n-                                                      do_input(opCompareAndSwap->_cmp_value);\n-                                                      do_temp(opCompareAndSwap->_cmp_value);\n-                                                      do_input(opCompareAndSwap->_new_value);\n-                                                      do_temp(opCompareAndSwap->_new_value);\n-      if (opCompareAndSwap->_tmp1->is_valid())        do_temp(opCompareAndSwap->_tmp1);\n-      if (opCompareAndSwap->_tmp2->is_valid())        do_temp(opCompareAndSwap->_tmp2);\n-      if (opCompareAndSwap->_result->is_valid())      do_output(opCompareAndSwap->_result);\n+      LIR_OpCompareAndSwap* opCmpAndSwap = (LIR_OpCompareAndSwap*)op;\n+\n+      if (opCmpAndSwap->_info)                              do_info(opCmpAndSwap->_info);\n+      assert(opCmpAndSwap->_addr->is_valid(), \"used\");      do_input(opCmpAndSwap->_addr);\n+                                                            do_temp(opCmpAndSwap->_addr);\n+      assert(opCmpAndSwap->_cmp_value->is_valid(), \"used\"); do_input(opCmpAndSwap->_cmp_value);\n+                                                            do_temp(opCmpAndSwap->_cmp_value);\n+      assert(opCmpAndSwap->_new_value->is_valid(), \"used\"); do_input(opCmpAndSwap->_new_value);\n+                                                            do_temp(opCmpAndSwap->_new_value);\n+      if (opCmpAndSwap->_tmp1->is_valid())                  do_temp(opCmpAndSwap->_tmp1);\n+      if (opCmpAndSwap->_tmp2->is_valid())                  do_temp(opCmpAndSwap->_tmp2);\n+      if (opCmpAndSwap->_result->is_valid())                do_output(opCmpAndSwap->_result);\n@@ -871,2 +868,6 @@\n-      if (opAllocArray->_klass->is_valid())           do_input(opAllocArray->_klass); do_temp(opAllocArray->_klass);\n-      if (opAllocArray->_len->is_valid())             do_input(opAllocArray->_len);   do_temp(opAllocArray->_len);\n+      if (opAllocArray->_klass->is_valid()) {         do_input(opAllocArray->_klass);\n+                                                      do_temp(opAllocArray->_klass);\n+                                            }\n+      if (opAllocArray->_len->is_valid())   {         do_input(opAllocArray->_len);\n+                                                      do_temp(opAllocArray->_len);\n+                                            }\n@@ -878,1 +879,1 @@\n-                                                      do_stub(opAllocArray->_stub);\n+      if (opAllocArray->_stub != nullptr)             do_stub(opAllocArray->_stub);\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-  if (TwoOperandLIRForm && left_op != result_op) {\n+  if (two_operand_lir_form && left_op != result_op) {\n@@ -566,1 +566,1 @@\n-  if (TwoOperandLIRForm && value != result_op\n+  if (two_operand_lir_form && value != result_op\n@@ -588,1 +588,1 @@\n-  if (TwoOperandLIRForm && left_op != result_op) {\n+  if (two_operand_lir_form && left_op != result_op) {\n@@ -1432,2 +1432,2 @@\n-void LIRGenerator::do_extentLocalCache(Intrinsic* x) {\n-  do_JavaThreadField(x, JavaThread::extentLocalCache_offset());\n+void LIRGenerator::do_scopedValueCache(Intrinsic* x) {\n+  do_JavaThreadField(x, JavaThread::scopedValueCache_offset());\n@@ -2952,1 +2952,1 @@\n-  case vmIntrinsics::_extentLocalCache: do_extentLocalCache(x); break;\n+  case vmIntrinsics::_scopedValueCache: do_scopedValueCache(x); break;\n@@ -3551,1 +3551,1 @@\n-  if (TwoOperandLIRForm) {\n+  if (two_operand_lir_form) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -692,1 +692,1 @@\n-  sprintf(message, \"Index %d out of bounds for length %d\", index, a->length());\n+  os::snprintf_checked(message, sizeof(message), \"Index %d out of bounds for length %d\", index, a->length());\n@@ -704,1 +704,1 @@\n-  sprintf(message, \"%d\", index);\n+  os::snprintf_checked(message, sizeof(message), \"%d\", index);\n@@ -767,0 +767,1 @@\n+  assert(current == JavaThread::current(), \"pre-condition\");\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-ArchiveBuilder::SourceObjList::SourceObjList() : _ptrmap(16 * K) {\n+ArchiveBuilder::SourceObjList::SourceObjList() : _ptrmap(16 * K, mtClassShared) {\n@@ -65,1 +65,1 @@\n-  _objs = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<SourceObjInfo*>(128 * K, mtClassShared);\n+  _objs = new (mtClassShared) GrowableArray<SourceObjInfo*>(128 * K, mtClassShared);\n@@ -160,0 +160,1 @@\n+  _ptrmap(mtClassShared),\n@@ -169,3 +170,3 @@\n-  _klasses = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<Klass*>(4 * K, mtClassShared);\n-  _symbols = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<Symbol*>(256 * K, mtClassShared);\n-  _special_refs = new (ResourceObj::C_HEAP, mtClassShared) GrowableArray<SpecialRefInfo>(24 * K, mtClassShared);\n+  _klasses = new (mtClassShared) GrowableArray<Klass*>(4 * K, mtClassShared);\n+  _symbols = new (mtClassShared) GrowableArray<Symbol*>(256 * K, mtClassShared);\n+  _special_refs = new (mtClassShared) GrowableArray<SpecialRefInfo>(24 * K, mtClassShared);\n@@ -1188,2 +1189,2 @@\n-                                   GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n-                                   GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps) {\n+                                   GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_bitmaps,\n+                                   GrowableArray<ArchiveHeapBitmapInfo>* open_heap_bitmaps) {\n@@ -1198,1 +1199,1 @@\n-  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_oopmaps, open_heap_oopmaps,\n+  char* bitmap = mapinfo->write_bitmap_region(ArchivePtrMarker::ptrmap(), closed_heap_bitmaps, open_heap_bitmaps,\n@@ -1204,1 +1205,1 @@\n-                                        closed_heap_oopmaps,\n+                                        closed_heap_bitmaps,\n@@ -1209,1 +1210,1 @@\n-                                        open_heap_oopmaps,\n+                                        open_heap_bitmaps,\n@@ -1243,2 +1244,2 @@\n-  const size_t bitmap_used = mapinfo->space_at(MetaspaceShared::bm)->used();\n-  const size_t bitmap_reserved = mapinfo->space_at(MetaspaceShared::bm)->used_aligned();\n+  const size_t bitmap_used = mapinfo->region_at(MetaspaceShared::bm)->used();\n+  const size_t bitmap_reserved = mapinfo->region_at(MetaspaceShared::bm)->used_aligned();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-struct ArchiveHeapOopmapInfo;\n+struct ArchiveHeapBitmapInfo;\n@@ -240,2 +240,2 @@\n-  ResizeableResourceHashtable<address, SourceObjInfo, ResourceObj::C_HEAP, mtClassShared> _src_obj_table;\n-  ResizeableResourceHashtable<address, address, ResourceObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n+  ResizeableResourceHashtable<address, SourceObjInfo, AnyObj::C_HEAP, mtClassShared> _src_obj_table;\n+  ResizeableResourceHashtable<address, address, AnyObj::C_HEAP, mtClassShared> _buffered_to_src_table;\n@@ -420,2 +420,2 @@\n-                     GrowableArray<ArchiveHeapOopmapInfo>* closed_heap_oopmaps,\n-                     GrowableArray<ArchiveHeapOopmapInfo>* open_heap_oopmaps);\n+                     GrowableArray<ArchiveHeapBitmapInfo>* closed_heap_oopmaps,\n+                     GrowableArray<ArchiveHeapBitmapInfo>* open_heap_oopmaps);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -345,1 +345,2 @@\n-      intptr_t runtime_oop = dumptime_oop + ArchiveHeapLoader::runtime_delta();\n+      assert(!ArchiveHeapLoader::is_loaded(), \"ArchiveHeapLoader::can_load() is not supported for uncompessed oops\");\n+      intptr_t runtime_oop = dumptime_oop + ArchiveHeapLoader::mapped_heap_delta();\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,0 +104,5 @@\n+\n+  msg.debug(\"Class CP entries = %d, archived = %d (%3.1f%%)\",\n+            _num_klass_cp_entries, _num_klass_cp_entries_archived,\n+            percent_of(_num_klass_cp_entries_archived, _num_klass_cp_entries));\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,3 @@\n+  int _num_klass_cp_entries;\n+  int _num_klass_cp_entries_archived;\n+\n@@ -74,0 +77,2 @@\n+    _num_klass_cp_entries = 0;\n+    _num_klass_cp_entries_archived = 0;\n@@ -102,0 +107,5 @@\n+  void record_klass_cp_entry(bool archived) {\n+    _num_klass_cp_entries ++;\n+    _num_klass_cp_entries_archived += archived ? 1 : 0;\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-#include \"classfile\/classLoaderDataShared.hpp\"\n-#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/modules.hpp\"\n@@ -86,0 +85,6 @@\n+GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = NULL;\n+\n+size_t HeapShared::_alloc_count[HeapShared::ALLOC_STAT_SLOTS];\n+size_t HeapShared::_alloc_size[HeapShared::ALLOC_STAT_SLOTS];\n+size_t HeapShared::_total_obj_count;\n+size_t HeapShared::_total_obj_size;\n@@ -304,0 +309,1 @@\n+    count_allocation(len);\n@@ -331,0 +337,1 @@\n+    mark_native_pointers(obj, archived_oop);\n@@ -364,0 +371,26 @@\n+void HeapShared::mark_native_pointers(oop orig_obj, oop archived_obj) {\n+  if (java_lang_Class::is_instance(orig_obj)) {\n+    mark_one_native_pointer(archived_obj, java_lang_Class::klass_offset());\n+    mark_one_native_pointer(archived_obj, java_lang_Class::array_klass_offset());\n+  }\n+}\n+\n+void HeapShared::mark_one_native_pointer(oop archived_obj, int offset) {\n+  Metadata* ptr = archived_obj->metadata_field_acquire(offset);\n+  if (ptr != NULL) {\n+    \/\/ Set the native pointer to the requested address (at runtime, if the metadata\n+    \/\/ is mapped at the default location, it will be at this address).\n+    address buffer_addr = ArchiveBuilder::current()->get_buffered_addr((address)ptr);\n+    address requested_addr = ArchiveBuilder::current()->to_requested(buffer_addr);\n+    archived_obj->metadata_field_put(offset, (Metadata*)requested_addr);\n+\n+    \/\/ Remember this pointer. At runtime, if the metadata is mapped at a non-default\n+    \/\/ location, the pointer needs to be patched (see ArchiveHeapLoader::patch_native_pointers()).\n+    _native_pointers->append(archived_obj->field_addr<Metadata*>(offset));\n+\n+    log_debug(cds, heap, mirror)(\n+        \"Marked metadata field at %d: \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+         offset, p2i(ptr), p2i(requested_addr));\n+  }\n+}\n+\n@@ -531,1 +564,1 @@\n-    ClassLoaderDataShared::init_archived_oops();\n+    Modules::verify_archived_modules();\n@@ -571,0 +604,1 @@\n+  count_allocation(roots()->size());\n@@ -606,1 +640,1 @@\n-      new(ResourceObj::C_HEAP, mtClass) GrowableArray<int>(10, mtClass);\n+      new (mtClass) GrowableArray<int>(10, mtClass);\n@@ -620,1 +654,1 @@\n-      new(ResourceObj::C_HEAP, mtClass) GrowableArray<Klass*>(50, mtClass);\n+      new (mtClass) GrowableArray<Klass*>(50, mtClass);\n@@ -816,0 +850,3 @@\n+  if (log_is_enabled(Info, cds, heap)) {\n+    print_stats();\n+  }\n@@ -818,1 +855,1 @@\n-void HeapShared::serialize(SerializeClosure* soc) {\n+void HeapShared::serialize_root(SerializeClosure* soc) {\n@@ -834,0 +871,3 @@\n+}\n+\n+void HeapShared::serialize_tables(SerializeClosure* soc) {\n@@ -879,1 +919,1 @@\n-void HeapShared::resolve_classes(JavaThread* THREAD) {\n+void HeapShared::resolve_classes(JavaThread* current) {\n@@ -884,3 +924,3 @@\n-  resolve_classes_for_subgraphs(closed_archive_subgraph_entry_fields,   THREAD);\n-  resolve_classes_for_subgraphs(open_archive_subgraph_entry_fields,     THREAD);\n-  resolve_classes_for_subgraphs(fmg_open_archive_subgraph_entry_fields, THREAD);\n+  resolve_classes_for_subgraphs(current, closed_archive_subgraph_entry_fields);\n+  resolve_classes_for_subgraphs(current, open_archive_subgraph_entry_fields);\n+  resolve_classes_for_subgraphs(current, fmg_open_archive_subgraph_entry_fields);\n@@ -889,2 +929,1 @@\n-void HeapShared::resolve_classes_for_subgraphs(ArchivableStaticFieldInfo fields[],\n-                                               JavaThread* THREAD) {\n+void HeapShared::resolve_classes_for_subgraphs(JavaThread* current, ArchivableStaticFieldInfo fields[]) {\n@@ -896,1 +935,1 @@\n-    resolve_classes_for_subgraph_of(k, THREAD);\n+    resolve_classes_for_subgraph_of(current, k);\n@@ -900,1 +939,2 @@\n-void HeapShared::resolve_classes_for_subgraph_of(Klass* k, JavaThread* THREAD) {\n+void HeapShared::resolve_classes_for_subgraph_of(JavaThread* current, Klass* k) {\n+  JavaThread* THREAD = current;\n@@ -912,1 +952,2 @@\n-void HeapShared::initialize_from_archived_subgraph(Klass* k, JavaThread* THREAD) {\n+void HeapShared::initialize_from_archived_subgraph(JavaThread* current, Klass* k) {\n+  JavaThread* THREAD = current;\n@@ -1160,19 +1201,0 @@\n-void HeapShared::check_module_oop(oop orig_module_obj) {\n-  assert(DumpSharedSpaces, \"must be\");\n-  assert(java_lang_Module::is_instance(orig_module_obj), \"must be\");\n-  ModuleEntry* orig_module_ent = java_lang_Module::module_entry_raw(orig_module_obj);\n-  if (orig_module_ent == NULL) {\n-    \/\/ These special Module objects are created in Java code. They are not\n-    \/\/ defined via Modules::define_module(), so they don't have a ModuleEntry:\n-    \/\/     java.lang.Module::ALL_UNNAMED_MODULE\n-    \/\/     java.lang.Module::EVERYONE_MODULE\n-    \/\/     jdk.internal.loader.ClassLoaders$BootClassLoader::unnamedModule\n-    assert(java_lang_Module::name(orig_module_obj) == NULL, \"must be unnamed\");\n-    log_info(cds, heap)(\"Module oop with No ModuleEntry* @[\" PTR_FORMAT \"]\", p2i(orig_module_obj));\n-  } else {\n-    ClassLoaderData* loader_data = orig_module_ent->loader_data();\n-    assert(loader_data->is_builtin_class_loader_data(), \"must be\");\n-  }\n-}\n-\n-\n@@ -1247,1 +1269,3 @@\n-      check_module_oop(orig_obj);\n+      if (Modules::check_module_oop(orig_obj)) {\n+        Modules::update_oops_in_archived_module(orig_obj, append_root(archived_obj));\n+      }\n@@ -1249,1 +1273,0 @@\n-      java_lang_Module::set_loader(archived_obj, NULL);\n@@ -1571,1 +1594,1 @@\n-  _dump_time_subgraph_info_table = new (ResourceObj::C_HEAP, mtClass)DumpTimeKlassSubGraphInfoTable();\n+  _dump_time_subgraph_info_table = new (mtClass)DumpTimeKlassSubGraphInfoTable();\n@@ -1643,1 +1666,2 @@\n-    _dumped_interned_strings = new (ResourceObj::C_HEAP, mtClass)DumpedInternedStrings();\n+    _dumped_interned_strings = new (mtClass)DumpedInternedStrings();\n+    _native_pointers = new GrowableArrayCHeap<Metadata**, mtClassShared>(2048);\n@@ -1809,0 +1833,74 @@\n+\n+ResourceBitMap HeapShared::calculate_ptrmap(MemRegion region) {\n+  size_t num_bits = region.byte_size() \/ sizeof(Metadata*);\n+  ResourceBitMap oopmap(num_bits);\n+\n+  Metadata** start = (Metadata**)region.start();\n+  Metadata** end   = (Metadata**)region.end();\n+\n+  int num_non_null_ptrs = 0;\n+  int len = _native_pointers->length();\n+  for (int i = 0; i < len; i++) {\n+    Metadata** p = _native_pointers->at(i);\n+    if (start <= p && p < end) {\n+      assert(*p != NULL, \"must be non-null\");\n+      num_non_null_ptrs ++;\n+      size_t idx = p - start;\n+      oopmap.set_bit(idx);\n+    }\n+  }\n+\n+  log_info(cds, heap)(\"calculate_ptrmap: marked %d non-null native pointers out of \"\n+                      SIZE_FORMAT \" possible locations\", num_non_null_ptrs, num_bits);\n+  if (num_non_null_ptrs > 0) {\n+    return oopmap;\n+  } else {\n+    return ResourceBitMap(0);\n+  }\n+}\n+\n+void HeapShared::count_allocation(size_t size) {\n+  _total_obj_count ++;\n+  _total_obj_size += size;\n+  for (int i = 0; i < ALLOC_STAT_SLOTS; i++) {\n+    if (size <= (size_t(1) << i)) {\n+      _alloc_count[i] ++;\n+      _alloc_size[i] += size;\n+      return;\n+    }\n+  }\n+}\n+\n+static double avg_size(size_t size, size_t count) {\n+  double avg = 0;\n+  if (count > 0) {\n+    avg = double(size * HeapWordSize) \/ double(count);\n+  }\n+  return avg;\n+}\n+\n+void HeapShared::print_stats() {\n+  size_t huge_count = _total_obj_count;\n+  size_t huge_size = _total_obj_size;\n+\n+  for (int i = 0; i < ALLOC_STAT_SLOTS; i++) {\n+    size_t byte_size_limit = (size_t(1) << i) * HeapWordSize;\n+    size_t count = _alloc_count[i];\n+    size_t size = _alloc_size[i];\n+    log_info(cds, heap)(SIZE_FORMAT_W(8) \" objects are <= \" SIZE_FORMAT_W(-6)\n+                        \" bytes (total \" SIZE_FORMAT_W(8) \" bytes, avg %8.1f bytes)\",\n+                        count, byte_size_limit, size * HeapWordSize, avg_size(size, count));\n+    huge_count -= count;\n+    huge_size -= size;\n+  }\n+\n+  log_info(cds, heap)(SIZE_FORMAT_W(8) \" huge  objects               (total \"  SIZE_FORMAT_W(8) \" bytes\"\n+                      \", avg %8.1f bytes)\",\n+                      huge_count, huge_size * HeapWordSize,\n+                      avg_size(huge_size, huge_count));\n+  log_info(cds, heap)(SIZE_FORMAT_W(8) \" total objects               (total \"  SIZE_FORMAT_W(8) \" bytes\"\n+                      \", avg %8.1f bytes)\",\n+                      _total_obj_count, _total_obj_size * HeapWordSize,\n+                      avg_size(_total_obj_size, _total_obj_count));\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":136,"deletions":38,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -432,1 +432,1 @@\n-  ResourceObj::C_HEAP> {};\n+  AnyObj::C_HEAP> {};\n@@ -445,1 +445,1 @@\n-    _unregistered_classes_table = new (ResourceObj::C_HEAP, mtClass)UnregisteredClassesTable();\n+    _unregistered_classes_table = new (mtClass)UnregisteredClassesTable();\n@@ -504,1 +504,1 @@\n-    _dumptime_table = new (ResourceObj::C_HEAP, mtClass) DumpTimeSharedClassTable;\n+    _dumptime_table = new (mtClass) DumpTimeSharedClassTable;\n@@ -506,1 +506,1 @@\n-                      new (ResourceObj::C_HEAP, mtClass) DumpTimeLambdaProxyClassDictionary;\n+                      new (mtClass) DumpTimeLambdaProxyClassDictionary;\n@@ -1063,1 +1063,3 @@\n-      method->signature()->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\")) {\n+      method->signature()->equals(\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;\"\n+            \"Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;\"\n+            \"Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\")) {\n@@ -1503,1 +1505,1 @@\n-  _cloned_dumptime_table = new (ResourceObj::C_HEAP, mtClass) DumpTimeSharedClassTable;\n+  _cloned_dumptime_table = new (mtClass) DumpTimeSharedClassTable;\n@@ -1511,1 +1513,1 @@\n-                                        new (ResourceObj::C_HEAP, mtClass) DumpTimeLambdaProxyClassDictionary;\n+                                        new (mtClass) DumpTimeLambdaProxyClassDictionary;\n@@ -1556,70 +1558,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-\n-class ArchivedMirrorPatcher {\n-protected:\n-  static void update(Klass* k) {\n-    if (k->has_archived_mirror_index()) {\n-      oop m = k->archived_java_mirror();\n-      if (m != NULL) {\n-        java_lang_Class::update_archived_mirror_native_pointers(m);\n-      }\n-    }\n-  }\n-\n-public:\n-  static void update_array_klasses(Klass* ak) {\n-    while (ak != NULL) {\n-      update(ak);\n-      ak = ArrayKlass::cast(ak)->higher_dimension();\n-    }\n-  }\n-\n-  void do_value(const RunTimeClassInfo* info) {\n-    InstanceKlass* ik = info->_klass;\n-    update(ik);\n-    update_array_klasses(ik->array_klasses());\n-  }\n-};\n-\n-class ArchivedLambdaMirrorPatcher : public ArchivedMirrorPatcher {\n-public:\n-  void do_value(const RunTimeLambdaProxyClassInfo* info) {\n-    InstanceKlass* ik = info->proxy_klass_head();\n-    while (ik != NULL) {\n-      update(ik);\n-      Klass* k = ik->next_link();\n-      ik = (k != NULL) ? InstanceKlass::cast(k) : NULL;\n-    }\n-  }\n-};\n-\n-void SystemDictionaryShared::update_archived_mirror_native_pointers_for(RunTimeSharedDictionary* dict) {\n-  ArchivedMirrorPatcher patcher;\n-  dict->iterate(&patcher);\n-}\n-\n-void SystemDictionaryShared::update_archived_mirror_native_pointers_for(LambdaProxyClassDictionary* dict) {\n-  ArchivedLambdaMirrorPatcher patcher;\n-  dict->iterate(&patcher);\n-}\n-\n-void SystemDictionaryShared::update_archived_mirror_native_pointers() {\n-  if (!ArchiveHeapLoader::are_archived_mirrors_available()) {\n-    return;\n-  }\n-  if (MetaspaceShared::relocation_delta() == 0) {\n-    return;\n-  }\n-  \/\/ mirrors are not archived for the classes in the dynamic archive\n-  update_archived_mirror_native_pointers_for(&_static_archive._builtin_dictionary);\n-  update_archived_mirror_native_pointers_for(&_static_archive._unregistered_dictionary);\n-  update_archived_mirror_native_pointers_for(&_static_archive._lambda_proxy_class_dictionary);\n-\n-  for (int t = T_BOOLEAN; t <= T_LONG; t++) {\n-    Klass* k = Universe::typeArrayKlassObj((BasicType)t);\n-    ArchivedMirrorPatcher::update_array_klasses(k);\n-  }\n-  ArchivedMirrorPatcher::update_array_klasses(Universe::fillerArrayKlassObj());\n-}\n-#endif\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":9,"deletions":77,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"gc\/g1\/g1MonotonicArenaFreeMemoryTask.hpp\"\n@@ -67,1 +68,0 @@\n-#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n@@ -403,1 +403,0 @@\n-    bool preventive_collection_required = false;\n@@ -411,2 +410,1 @@\n-      size_t actual_size;\n-      result = _allocator->attempt_allocation(word_size, word_size, &actual_size);\n+      result = _allocator->attempt_allocation_locked(word_size);\n@@ -417,5 +415,7 @@\n-      preventive_collection_required = policy()->preventive_collection_required(1);\n-      if (!preventive_collection_required) {\n-        \/\/ We've already attempted a lock-free allocation above, so we don't want to\n-        \/\/ do it again. Let's jump straight to replacing the active region.\n-        result = _allocator->attempt_allocation_using_new_region(word_size);\n+      \/\/ If the GCLocker is active and we are bound for a GC, try expanding young gen.\n+      \/\/ This is different to when only GCLocker::needs_gc() is set: try to avoid\n+      \/\/ waiting because the GCLocker is active to not wait too long.\n+      if (GCLocker::is_active_and_needs_gc() && policy()->can_expand_young_list()) {\n+        \/\/ No need for an ergo message here, can_expand_young_list() does this when\n+        \/\/ it returns true.\n+        result = _allocator->attempt_allocation_force(word_size);\n@@ -425,12 +425,0 @@\n-\n-        \/\/ If the GCLocker is active and we are bound for a GC, try expanding young gen.\n-        \/\/ This is different to when only GCLocker::needs_gc() is set: try to avoid\n-        \/\/ waiting because the GCLocker is active to not wait too long.\n-        if (GCLocker::is_active_and_needs_gc() && policy()->can_expand_young_list()) {\n-          \/\/ No need for an ergo message here, can_expand_young_list() does this when\n-          \/\/ it returns true.\n-          result = _allocator->attempt_allocation_force(word_size);\n-          if (result != NULL) {\n-            return result;\n-          }\n-        }\n@@ -448,3 +436,1 @@\n-      GCCause::Cause gc_cause = preventive_collection_required ? GCCause::_g1_preventive_collection\n-                                                               : GCCause::_g1_inc_collection_pause;\n-      result = do_collection_pause(word_size, gc_count_before, &succeeded, gc_cause);\n+      result = do_collection_pause(word_size, gc_count_before, &succeeded, GCCause::_g1_inc_collection_pause);\n@@ -865,1 +851,0 @@\n-    bool preventive_collection_required = false;\n@@ -873,11 +858,8 @@\n-      preventive_collection_required = policy()->preventive_collection_required((uint)size_in_regions);\n-      if (!preventive_collection_required) {\n-        \/\/ Given that humongous objects are not allocated in young\n-        \/\/ regions, we'll first try to do the allocation without doing a\n-        \/\/ collection hoping that there's enough space in the heap.\n-        result = humongous_obj_allocate(word_size);\n-        if (result != NULL) {\n-          policy()->old_gen_alloc_tracker()->\n-            add_allocated_humongous_bytes_since_last_gc(size_in_regions * HeapRegion::GrainBytes);\n-          return result;\n-        }\n+      \/\/ Given that humongous objects are not allocated in young\n+      \/\/ regions, we'll first try to do the allocation without doing a\n+      \/\/ collection hoping that there's enough space in the heap.\n+      result = humongous_obj_allocate(word_size);\n+      if (result != NULL) {\n+        policy()->old_gen_alloc_tracker()->\n+          add_allocated_humongous_bytes_since_last_gc(size_in_regions * HeapRegion::GrainBytes);\n+        return result;\n@@ -895,3 +877,1 @@\n-      GCCause::Cause gc_cause = preventive_collection_required ? GCCause::_g1_preventive_collection\n-                                                              : GCCause::_g1_humongous_allocation;\n-      result = do_collection_pause(word_size, gc_count_before, &succeeded, gc_cause);\n+      result = do_collection_pause(word_size, gc_count_before, &succeeded, GCCause::_g1_humongous_allocation);\n@@ -1068,1 +1048,1 @@\n-  G1BarrierSet::dirty_card_queue_set().abandon_logs();\n+  G1BarrierSet::dirty_card_queue_set().abandon_logs_and_stats();\n@@ -1434,1 +1414,1 @@\n-  _free_segmented_array_memory_task(NULL),\n+  _free_arena_memory_task(NULL),\n@@ -1463,2 +1443,2 @@\n-  _gc_timer_stw(new (ResourceObj::C_HEAP, mtGC) STWGCTimer()),\n-  _gc_tracer_stw(new (ResourceObj::C_HEAP, mtGC) G1NewTracer()),\n+  _gc_timer_stw(new STWGCTimer()),\n+  _gc_tracer_stw(new G1NewTracer()),\n@@ -1471,0 +1451,1 @@\n+  _card_set_freelist_pool(G1CardSetConfiguration::num_mem_object_types()),\n@@ -1538,1 +1519,1 @@\n-  _cr = G1ConcurrentRefine::create(&ecode);\n+  _cr = G1ConcurrentRefine::create(policy(), &ecode);\n@@ -1720,3 +1701,0 @@\n-  \/\/ Initialize and schedule sampling task on service thread.\n-  _rem_set->initialize_sampling_task(service_thread());\n-\n@@ -1727,2 +1705,2 @@\n-  _free_segmented_array_memory_task = new G1SegmentedArrayFreeMemoryTask(\"Card Set Free Memory Task\");\n-  _service_thread->register_task(_free_segmented_array_memory_task);\n+  _free_arena_memory_task = new G1MonotonicArenaFreeMemoryTask(\"Card Set Free Memory Task\");\n+  _service_thread->register_task(_free_arena_memory_task);\n@@ -2033,3 +2011,1 @@\n-    VM_G1TryInitiateConcMark op(gc_counter,\n-                                cause,\n-                                policy()->max_pause_time_ms());\n+    VM_G1TryInitiateConcMark op(gc_counter, cause);\n@@ -2209,2 +2185,1 @@\n-                                 cause,\n-                                 policy()->max_pause_time_ms());\n+                                 cause);\n@@ -2230,2 +2205,1 @@\n-    double pause_target = policy()->max_pause_time_ms();\n-    do_collection_pause_at_safepoint(pause_target);\n+    do_collection_pause_at_safepoint();\n@@ -2571,2 +2545,3 @@\n-  size_t eden_used_bytes = _eden.used_bytes();\n-  size_t survivor_used_bytes = _survivor.used_bytes();\n+  size_t eden_used_bytes = _monitoring_support->eden_space_used();\n+  size_t survivor_used_bytes = _monitoring_support->survivor_space_used();\n+  size_t old_gen_used_bytes = _monitoring_support->old_gen_used();\n@@ -2579,2 +2554,2 @@\n-  return G1HeapSummary(heap_summary, heap_used, eden_used_bytes,\n-                       eden_capacity_bytes, survivor_used_bytes, num_regions());\n+  return G1HeapSummary(heap_summary, heap_used, eden_used_bytes, eden_capacity_bytes,\n+                       survivor_used_bytes, old_gen_used_bytes, num_regions());\n@@ -2626,2 +2601,2 @@\n-  _free_segmented_array_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n-                                                      &_collection_set_candidates_card_set_stats);\n+  _free_arena_memory_task->notify_new_stats(&_young_gen_card_set_stats,\n+                                            &_collection_set_candidates_card_set_stats);\n@@ -2660,4 +2635,1 @@\n-  VM_G1CollectForAllocation op(word_size,\n-                               gc_count_before,\n-                               gc_cause,\n-                               policy()->max_pause_time_ms());\n+  VM_G1CollectForAllocation op(word_size, gc_count_before, gc_cause);\n@@ -2799,1 +2771,1 @@\n-bool G1CollectedHeap::do_collection_pause_at_safepoint(double target_pause_time_ms) {\n+bool G1CollectedHeap::do_collection_pause_at_safepoint() {\n@@ -2807,1 +2779,1 @@\n-  do_collection_pause_at_safepoint_helper(target_pause_time_ms);\n+  do_collection_pause_at_safepoint_helper();\n@@ -2868,1 +2840,1 @@\n-void G1CollectedHeap::do_collection_pause_at_safepoint_helper(double target_pause_time_ms) {\n+void G1CollectedHeap::do_collection_pause_at_safepoint_helper() {\n@@ -2886,1 +2858,1 @@\n-  G1YoungCollector collector(gc_cause(), target_pause_time_ms);\n+  G1YoungCollector collector(gc_cause());\n@@ -2939,1 +2911,1 @@\n-void G1CollectedHeap::set_collection_set_candidates_stats(G1SegmentedArrayMemoryStats& stats) {\n+void G1CollectedHeap::set_collection_set_candidates_stats(G1MonotonicArenaMemoryStats& stats) {\n@@ -2943,1 +2915,1 @@\n-void G1CollectedHeap::set_young_gen_card_set_stats(const G1SegmentedArrayMemoryStats& stats) {\n+void G1CollectedHeap::set_young_gen_card_set_stats(const G1MonotonicArenaMemoryStats& stats) {\n@@ -3415,3 +3387,3 @@\n-    nmethod* nm = (cb != NULL) ? cb->as_nmethod_or_null() : NULL;\n-    if (nm == NULL) {\n-      return;\n+    nmethod* nm = cb->as_nmethod_or_null();\n+    if (nm != NULL) {\n+      _g1h->register_nmethod(nm);\n@@ -3419,2 +3391,0 @@\n-\n-    _g1h->register_nmethod(nm);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":47,"deletions":77,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+#include \"gc\/g1\/g1MonotonicArenaFreeMemoryTask.hpp\"\n+#include \"gc\/g1\/g1MonotonicArenaFreePool.hpp\"\n@@ -44,1 +46,0 @@\n-#include \"gc\/g1\/g1SegmentedArrayFreeMemoryTask.hpp\"\n@@ -149,1 +150,1 @@\n-  G1SegmentedArrayFreeMemoryTask* _free_segmented_array_memory_task;\n+  G1MonotonicArenaFreeMemoryTask* _free_arena_memory_task;\n@@ -166,1 +167,1 @@\n-  G1SegmentedArrayMemoryStats _young_gen_card_set_stats;\n+  G1MonotonicArenaMemoryStats _young_gen_card_set_stats;\n@@ -168,1 +169,1 @@\n-  G1SegmentedArrayMemoryStats _collection_set_candidates_card_set_stats;\n+  G1MonotonicArenaMemoryStats _collection_set_candidates_card_set_stats;\n@@ -245,2 +246,2 @@\n-  void set_collection_set_candidates_stats(G1SegmentedArrayMemoryStats& stats);\n-  void set_young_gen_card_set_stats(const G1SegmentedArrayMemoryStats& stats);\n+  void set_collection_set_candidates_stats(G1MonotonicArenaMemoryStats& stats);\n+  void set_young_gen_card_set_stats(const G1MonotonicArenaMemoryStats& stats);\n@@ -766,1 +767,1 @@\n-  bool do_collection_pause_at_safepoint(double target_pause_time_ms);\n+  bool do_collection_pause_at_safepoint();\n@@ -770,1 +771,1 @@\n-  void do_collection_pause_at_safepoint_helper(double target_pause_time_ms);\n+  void do_collection_pause_at_safepoint_helper();\n@@ -797,0 +798,2 @@\n+  G1MonotonicArenaFreePool _card_set_freelist_pool;\n+\n@@ -923,0 +926,3 @@\n+  const G1MonotonicArenaFreePool* card_set_freelist_pool() const { return &_card_set_freelist_pool; }\n+  G1MonotonicArenaFreePool* card_set_freelist_pool() { return &_card_set_freelist_pool; }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -226,0 +227,3 @@\n+  \/\/ Need completely cleared claim bits for the next concurrent marking or full gc.\n+  ClassLoaderDataGraph::clear_claimed_marks();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderData.hpp\"\n@@ -87,2 +88,1 @@\n-  \/\/ Need cleared claim bits for the roots processing\n-  ClassLoaderDataGraph::clear_claimed_marks();\n+  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n@@ -106,1 +106,1 @@\n-  CLDToOopClosure adjust_cld(&_adjust, ClassLoaderData::_claim_strong);\n+  CLDToOopClosure adjust_cld(&_adjust, ClassLoaderData::_claim_stw_fullgc_adjust);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  _compaction_regions = new (ResourceObj::C_HEAP, mtGC) GrowableArray<HeapRegion*>(32, mtGC);\n+  _compaction_regions = new (mtGC) GrowableArray<HeapRegion*>(32, mtGC);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-class G1MarkAndPushClosure : public OopIterateClosure {\n+class G1MarkAndPushClosure : public ClaimMetadataVisitingOopIterateClosure {\n@@ -68,2 +68,2 @@\n-  G1MarkAndPushClosure(uint worker, G1FullGCMarker* marker, ReferenceDiscoverer* ref) :\n-    OopIterateClosure(ref),\n+  G1MarkAndPushClosure(uint worker_id, G1FullGCMarker* marker, int claim, ReferenceDiscoverer* ref) :\n+    ClaimMetadataVisitingOopIterateClosure(claim, ref),\n@@ -71,1 +71,1 @@\n-    _worker_id(worker) { }\n+    _worker_id(worker_id) { }\n@@ -76,6 +76,0 @@\n-\n-  virtual bool do_metadata();\n-  virtual void do_klass(Klass* k);\n-  virtual void do_cld(ClassLoaderData* cld);\n-  virtual void do_method(Method* m);\n-  virtual void do_nmethod(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -55,20 +55,0 @@\n-inline bool G1MarkAndPushClosure::do_metadata() {\n-  return true;\n-}\n-\n-inline void G1MarkAndPushClosure::do_klass(Klass* k) {\n-  _marker->follow_klass(k);\n-}\n-\n-inline void G1MarkAndPushClosure::do_cld(ClassLoaderData* cld) {\n-  _marker->follow_cld(cld);\n-}\n-\n-inline void G1MarkAndPushClosure::do_method(Method* m) {\n-  m->record_gc_epoch();\n-}\n-\n-inline void G1MarkAndPushClosure::do_nmethod(nmethod* nm) {\n-  nm->follow_nmethod(this);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -120,11 +120,3 @@\n-  assert(is_object_aligned(obj), \"oop must be aligned\");\n-  assert(g1h->is_in_reserved(obj), \"oop must be in reserved\");\n-\n-  HeapRegion* from = g1h->heap_region_containing(p);\n-\n-  assert(from->is_in_reserved(p) ||\n-         (from->is_humongous() &&\n-          g1h->heap_region_containing(p)->is_humongous() &&\n-          from->humongous_start_region() == g1h->heap_region_containing(p)->humongous_start_region()),\n-         \"p \" PTR_FORMAT \" is not in the same region %u or part of the correct humongous object starting at region %u.\",\n-         p2i(p), from->hrm_index(), from->humongous_start_region()->hrm_index());\n+  assert(is_object_aligned(obj), \"obj must be aligned\");\n+  assert(g1h->is_in(obj), \"invariant\");\n+  assert(g1h->is_in(p), \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -576,1 +576,1 @@\n-                               _preserved_marks_set->get(worker_id),\n+                               _preserved_marks_set.get(worker_id),\n@@ -697,2 +697,0 @@\n-                                                 G1RedirtyCardsQueueSet* rdcqs,\n-                                                 PreservedMarksSet* preserved_marks_set,\n@@ -704,2 +702,2 @@\n-    _rdcqs(rdcqs),\n-    _preserved_marks_set(preserved_marks_set),\n+    _rdcqs(G1BarrierSet::dirty_card_queue_set().allocator()),\n+    _preserved_marks_set(true \/* in_c_heap *\/),\n@@ -713,0 +711,1 @@\n+  _preserved_marks_set.init(n_workers);\n@@ -723,0 +722,2 @@\n+  _preserved_marks_set.assert_empty();\n+  _preserved_marks_set.reclaim();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/shared\/preservedMarks.hpp\"\n@@ -233,2 +234,2 @@\n-  G1RedirtyCardsQueueSet* _rdcqs;\n-  PreservedMarksSet* _preserved_marks_set;\n+  G1RedirtyCardsQueueSet _rdcqs;\n+  PreservedMarksSet _preserved_marks_set;\n@@ -245,2 +246,0 @@\n-                          G1RedirtyCardsQueueSet* rdcqs,\n-                          PreservedMarksSet* preserved_marks_set,\n@@ -253,2 +252,2 @@\n-  G1RedirtyCardsQueueSet* rdcqs() { return _rdcqs; }\n-  PreservedMarksSet* preserved_marks_set() { return _preserved_marks_set; }\n+  G1RedirtyCardsQueueSet* rdcqs() { return &_rdcqs; }\n+  PreservedMarksSet* preserved_marks_set() { return &_preserved_marks_set; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  _lgrp_spaces = new (ResourceObj::C_HEAP, mtGC) GrowableArray<LGRPSpace*>(0, mtGC);\n+  _lgrp_spaces = new (mtGC) GrowableArray<LGRPSpace*>(0, mtGC);\n@@ -317,1 +317,2 @@\n-    os::realign_memory((char*)aligned_region.start(), aligned_region.byte_size(), page_size());\n+    const size_t os_align = UseLargePages ? page_size() : os::vm_page_size();\n+    os::realign_memory((char*)aligned_region.start(), aligned_region.byte_size(), os_align);\n@@ -319,1 +320,3 @@\n-    os::free_memory((char*)aligned_region.start(), aligned_region.byte_size(), page_size());\n+    \/\/ The alignment_hint argument must be less than or equal to the small page\n+    \/\/ size if not using large pages or else this function does nothing.\n+    os::free_memory((char*)aligned_region.start(), aligned_region.byte_size(), os_align);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  _gc_timer = new (ResourceObj::C_HEAP, mtGC) STWGCTimer();\n+  _gc_timer = new STWGCTimer();\n@@ -190,1 +190,1 @@\n-  _gc_tracer = new (ResourceObj::C_HEAP, mtGC) DefNewTracer();\n+  _gc_tracer = new DefNewTracer();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -183,2 +183,1 @@\n-  \/\/ Need new claim bits before marking starts.\n-  ClassLoaderDataGraph::clear_claimed_marks();\n+  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_mark);\n@@ -189,6 +188,7 @@\n-    gch->full_process_roots(false, \/\/ not the adjust phase\n-                            GenCollectedHeap::SO_None,\n-                            ClassUnloading, \/\/ only strong roots if ClassUnloading\n-                                            \/\/ is enabled\n-                            &follow_root_closure,\n-                            &follow_cld_closure);\n+    CLDClosure* weak_cld_closure = ClassUnloading ? NULL : &follow_cld_closure;\n+    MarkingCodeBlobClosure mark_code_closure(&follow_root_closure, !CodeBlobToOopClosure::FixRelocations, true);\n+    gch->process_roots(GenCollectedHeap::SO_None,\n+                       &follow_root_closure,\n+                       &follow_cld_closure,\n+                       weak_cld_closure,\n+                       &mark_code_closure);\n@@ -264,2 +264,1 @@\n-  \/\/ Need new claim bits for the pointer adjustment tracing.\n-  ClassLoaderDataGraph::clear_claimed_marks();\n+  ClassLoaderDataGraph::verify_claimed_marks_cleared(ClassLoaderData::_claim_stw_fullgc_adjust);\n@@ -268,10 +267,7 @@\n-  CLDToOopClosure adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_strong);\n-  {\n-    StrongRootsScope srs(0);\n-\n-    gch->full_process_roots(true,  \/\/ this is the adjust phase\n-                            GenCollectedHeap::SO_AllCodeCache,\n-                            false, \/\/ all roots\n-                            &adjust_pointer_closure,\n-                            &adjust_cld_closure);\n-  }\n+  CLDToOopClosure      adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n+  CodeBlobToOopClosure code_closure(&adjust_pointer_closure, CodeBlobToOopClosure::FixRelocations);\n+  gch->process_roots(GenCollectedHeap::SO_AllCodeCache,\n+                     &adjust_pointer_closure,\n+                     &adjust_cld_closure,\n+                     &adjust_cld_closure,\n+                     &code_closure);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -65,3 +65,3 @@\n-MarkAndPushClosure MarkSweep::mark_and_push_closure;\n-CLDToOopClosure    MarkSweep::follow_cld_closure(&mark_and_push_closure, ClassLoaderData::_claim_strong);\n-template <class T> inline void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {\n+MarkAndPushClosure MarkSweep::mark_and_push_closure(ClassLoaderData::_claim_stw_fullgc_mark);\n+CLDToOopClosure    MarkSweep::follow_cld_closure(&mark_and_push_closure, ClassLoaderData::_claim_stw_fullgc_mark);\n+template <class T> void MarkSweep::KeepAliveClosure::do_oop_work(T* p) {\n@@ -78,2 +78,2 @@\n-inline void MarkSweep::follow_array(objArrayOop array) {\n-  MarkSweep::follow_klass(array->klass());\n+void MarkSweep::follow_array(objArrayOop array) {\n+  mark_and_push_closure.do_klass(array->klass());\n@@ -86,1 +86,1 @@\n-inline void MarkSweep::follow_object(oop obj) {\n+void MarkSweep::follow_object(oop obj) {\n@@ -131,1 +131,1 @@\n-template <class T> inline void MarkSweep::follow_root(T* p) {\n+template <class T> void MarkSweep::follow_root(T* p) {\n@@ -176,0 +176,44 @@\n+void MarkSweep::mark_object(oop obj) {\n+  if (StringDedup::is_enabled() &&\n+      java_lang_String::is_instance(obj) &&\n+      SerialStringDedup::is_candidate_from_mark(obj)) {\n+    _string_dedup_requests->add(obj);\n+  }\n+\n+  ContinuationGCSupport::transform_stack_chunk(obj);\n+\n+  \/\/ some marks may contain information we need to preserve so we store them away\n+  \/\/ and overwrite the mark.  We'll restore it at the end of markSweep.\n+  markWord mark = obj->mark();\n+#ifdef _LP64\n+  markWord real_mark = mark;\n+  if (real_mark.has_displaced_mark_helper()) {\n+    real_mark = real_mark.displaced_mark_helper();\n+  }\n+  Klass* klass = real_mark.klass();\n+  obj->set_mark(klass->prototype_header().set_marked());\n+#else\n+  obj->set_mark(markWord::prototype().set_marked());\n+#endif\n+\n+  if (obj->mark_must_be_preserved(mark)) {\n+    preserve_mark(obj, mark);\n+  }\n+}\n+\n+template <class T> void MarkSweep::mark_and_push(T* p) {\n+  T heap_oop = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(heap_oop)) {\n+    oop obj = CompressedOops::decode_not_null(heap_oop);\n+    if (!obj->mark().is_marked()) {\n+      mark_object(obj);\n+      _marking_stack.push(obj);\n+    }\n+  }\n+}\n+\n+template <typename T>\n+void MarkAndPushClosure::do_oop_work(T* p)            { MarkSweep::mark_and_push(p); }\n+void MarkAndPushClosure::do_oop(      oop* p)         { do_oop_work(p); }\n+void MarkAndPushClosure::do_oop(narrowOop* p)         { do_oop_work(p); }\n+\n@@ -217,2 +261,2 @@\n-  MarkSweep::_gc_timer = new (ResourceObj::C_HEAP, mtGC) STWGCTimer();\n-  MarkSweep::_gc_tracer = new (ResourceObj::C_HEAP, mtGC) SerialOldTracer();\n+  MarkSweep::_gc_timer = new STWGCTimer();\n+  MarkSweep::_gc_tracer = new SerialOldTracer();\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":53,"deletions":9,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-class Method;\n-class nmethod;\n@@ -152,4 +150,0 @@\n-  static void follow_klass(Klass* klass);\n-\n-  static void follow_cld(ClassLoaderData* cld);\n-\n@@ -176,1 +170,1 @@\n-class MarkAndPushClosure: public OopIterateClosure {\n+class MarkAndPushClosure: public ClaimMetadataVisitingOopIterateClosure {\n@@ -178,0 +172,2 @@\n+  MarkAndPushClosure(int claim) : ClaimMetadataVisitingOopIterateClosure(claim) {}\n+\n@@ -179,1 +175,1 @@\n-  virtual void do_oop(oop* p);\n+  virtual void do_oop(      oop* p);\n@@ -182,6 +178,0 @@\n-  virtual bool do_metadata() { return true; }\n-  virtual void do_klass(Klass* k);\n-  virtual void do_cld(ClassLoaderData* cld);\n-  virtual void do_method(Method* m);\n-  virtual void do_nmethod(nmethod* nm);\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"code\/nmethod.hpp\"\n@@ -40,1 +39,0 @@\n-#include \"oops\/method.hpp\"\n@@ -45,48 +43,0 @@\n-inline void MarkSweep::mark_object(oop obj) {\n-  if (StringDedup::is_enabled() &&\n-      java_lang_String::is_instance(obj) &&\n-      SerialStringDedup::is_candidate_from_mark(obj)) {\n-    _string_dedup_requests->add(obj);\n-  }\n-\n-  \/\/ some marks may contain information we need to preserve so we store them away\n-  \/\/ and overwrite the mark.  We'll restore it at the end of markSweep.\n-  markWord mark = obj->mark();\n-  obj->set_mark(obj->klass()->prototype_header().set_marked());\n-\n-  ContinuationGCSupport::transform_stack_chunk(obj);\n-\n-  if (obj->mark_must_be_preserved(mark)) {\n-    preserve_mark(obj, mark);\n-  }\n-}\n-\n-template <class T> inline void MarkSweep::mark_and_push(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    if (!obj->mark().is_marked()) {\n-      mark_object(obj);\n-      _marking_stack.push(obj);\n-    }\n-  }\n-}\n-\n-inline void MarkSweep::follow_klass(Klass* klass) {\n-  oop op = klass->class_loader_data()->holder_no_keepalive();\n-  MarkSweep::mark_and_push(&op);\n-}\n-\n-inline void MarkSweep::follow_cld(ClassLoaderData* cld) {\n-  MarkSweep::follow_cld_closure.do_cld(cld);\n-}\n-\n-template <typename T>\n-inline void MarkAndPushClosure::do_oop_work(T* p)            { MarkSweep::mark_and_push(p); }\n-inline void MarkAndPushClosure::do_oop(oop* p)               { do_oop_work(p); }\n-inline void MarkAndPushClosure::do_oop(narrowOop* p)         { do_oop_work(p); }\n-inline void MarkAndPushClosure::do_klass(Klass* k)           { MarkSweep::follow_klass(k); }\n-inline void MarkAndPushClosure::do_cld(ClassLoaderData* cld) { MarkSweep::follow_cld(cld); }\n-inline void MarkAndPushClosure::do_method(Method* m)         { m->record_gc_epoch(); }\n-inline void MarkAndPushClosure::do_nmethod(nmethod* nm)      { nm->follow_nmethod(this); }\n-\n@@ -114,1 +64,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -654,5 +654,0 @@\n-uint32_t CollectedHeap::hash_oop(oop obj) const {\n-  const uintptr_t addr = cast_from_oop<uintptr_t>(obj);\n-  return static_cast<uint32_t>(addr >> LogMinObjAlignment);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -282,2 +282,0 @@\n-  virtual uint32_t hash_oop(oop obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -633,0 +633,4 @@\n+\n+    \/\/ Need to clear claim bits for the next mark.\n+    ClassLoaderDataGraph::clear_claimed_marks();\n+\n@@ -794,14 +798,0 @@\n-void GenCollectedHeap::full_process_roots(bool is_adjust_phase,\n-                                          ScanningOption so,\n-                                          bool only_strong_roots,\n-                                          OopClosure* root_closure,\n-                                          CLDClosure* cld_closure) {\n-  \/\/ Called from either the marking phase or the adjust phase.\n-  const bool is_marking_phase = !is_adjust_phase;\n-\n-  MarkingCodeBlobClosure mark_code_closure(root_closure, is_adjust_phase, is_marking_phase);\n-  CLDClosure* weak_cld_closure = only_strong_roots ? NULL : cld_closure;\n-\n-  process_roots(so, root_closure, cld_closure, weak_cld_closure, &mark_code_closure);\n-}\n-\n@@ -818,22 +808,0 @@\n-\n-  if ((cause == GCCause::_wb_young_gc) ||\n-      (cause == GCCause::_gc_locker)) {\n-    \/\/ Young collection for WhiteBox or GCLocker.\n-    collect(cause, YoungGen);\n-  } else {\n-#ifdef ASSERT\n-  if (cause == GCCause::_scavenge_alot) {\n-    \/\/ Young collection only.\n-    collect(cause, YoungGen);\n-  } else {\n-    \/\/ Stop-the-world full collection.\n-    collect(cause, OldGen);\n-  }\n-#else\n-    \/\/ Stop-the-world full collection.\n-    collect(cause, OldGen);\n-#endif\n-  }\n-}\n-\n-void GenCollectedHeap::collect(GCCause::Cause cause, GenerationType max_generation) {\n@@ -858,0 +826,8 @@\n+  bool should_run_young_gc =  (cause == GCCause::_wb_young_gc)\n+                           || (cause == GCCause::_gc_locker)\n+                DEBUG_ONLY(|| (cause == GCCause::_scavenge_alot));\n+\n+  const GenerationType max_generation = should_run_young_gc\n+                                      ? YoungGen\n+                                      : OldGen;\n+\n@@ -1082,1 +1058,1 @@\n-  log_debug(gc, verify)(\"%s\", _old_gen->name());\n+  log_debug(gc, verify)(\"%s\", _young_gen->name());\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":13,"deletions":37,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -192,4 +192,0 @@\n-  \/\/ Perform a full collection of generations up to and including max_generation.\n-  \/\/ Mostly used for testing purposes. Caller does not hold the Heap_lock on entry.\n-  void collect(GCCause::Cause cause, GenerationType max_generation);\n-\n@@ -340,0 +336,5 @@\n+  virtual void gc_prologue(bool full);\n+  virtual void gc_epilogue(bool full);\n+\n+ public:\n+  \/\/ Apply closures on various roots in Young GC or marking\/adjust phases of Full GC.\n@@ -346,10 +347,0 @@\n-  virtual void gc_prologue(bool full);\n-  virtual void gc_epilogue(bool full);\n-\n- public:\n-  void full_process_roots(bool is_adjust_phase,\n-                          ScanningOption so,\n-                          bool only_strong_roots,\n-                          OopClosure* root_closure,\n-                          CLDClosure* cld_closure);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  void notify_allocation();\n+  void notify_allocation(JavaThread* thread);\n@@ -63,1 +63,1 @@\n-  void notify_allocation_dtrace_sampler();\n+  void notify_allocation_dtrace_sampler(JavaThread* thread);\n@@ -87,1 +87,1 @@\n-      notify_allocation();\n+      notify_allocation(_thread);\n@@ -238,1 +238,1 @@\n-void MemAllocator::Allocation::notify_allocation_dtrace_sampler() {\n+void MemAllocator::Allocation::notify_allocation_dtrace_sampler(JavaThread* thread) {\n@@ -244,1 +244,1 @@\n-      SharedRuntime::dtrace_object_alloc(Thread::current(), obj(), word_size);\n+      SharedRuntime::dtrace_object_alloc(thread, obj(), word_size);\n@@ -249,1 +249,1 @@\n-void MemAllocator::Allocation::notify_allocation() {\n+void MemAllocator::Allocation::notify_allocation(JavaThread* thread) {\n@@ -252,1 +252,1 @@\n-  notify_allocation_dtrace_sampler();\n+  notify_allocation_dtrace_sampler(thread);\n@@ -256,1 +256,1 @@\n-HeapWord* MemAllocator::allocate_outside_tlab(Allocation& allocation) const {\n+HeapWord* MemAllocator::mem_allocate_outside_tlab(Allocation& allocation) const {\n@@ -270,1 +270,1 @@\n-HeapWord* MemAllocator::allocate_inside_tlab(Allocation& allocation) const {\n+HeapWord* MemAllocator::mem_allocate_inside_tlab(Allocation& allocation) const {\n@@ -274,1 +274,1 @@\n-  HeapWord* mem = allocate_inside_tlab_fast();\n+  HeapWord* mem = mem_allocate_inside_tlab_fast();\n@@ -280,1 +280,1 @@\n-  return allocate_inside_tlab_slow(allocation);\n+  return mem_allocate_inside_tlab_slow(allocation);\n@@ -283,1 +283,1 @@\n-HeapWord* MemAllocator::allocate_inside_tlab_fast() const {\n+HeapWord* MemAllocator::mem_allocate_inside_tlab_fast() const {\n@@ -287,1 +287,1 @@\n-HeapWord* MemAllocator::allocate_inside_tlab_slow(Allocation& allocation) const {\n+HeapWord* MemAllocator::mem_allocate_inside_tlab_slow(Allocation& allocation) const {\n@@ -354,1 +354,5 @@\n-HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n+\n+HeapWord* MemAllocator::mem_allocate_slow(Allocation& allocation) const {\n+  \/\/ Allocation of an oop can always invoke a safepoint.\n+  debug_only(JavaThread::cast(_thread)->check_for_valid_safepoint_state());\n+\n@@ -356,3 +360,4 @@\n-    HeapWord* result = allocate_inside_tlab(allocation);\n-    if (result != NULL) {\n-      return result;\n+    \/\/ Try refilling the TLAB and allocating the object in it.\n+    HeapWord* mem = mem_allocate_inside_tlab_slow(allocation);\n+    if (mem != NULL) {\n+      return mem;\n@@ -362,1 +367,1 @@\n-  return allocate_outside_tlab(allocation);\n+  return mem_allocate_outside_tlab(allocation);\n@@ -365,5 +370,4 @@\n-oop MemAllocator::allocate() const {\n-  oop obj = NULL;\n-  {\n-    Allocation allocation(*this, &obj);\n-    HeapWord* mem = mem_allocate(allocation);\n+HeapWord* MemAllocator::mem_allocate(Allocation& allocation) const {\n+  if (UseTLAB) {\n+    \/\/ Try allocating from an existing TLAB.\n+    HeapWord* mem = mem_allocate_inside_tlab_fast();\n@@ -371,5 +375,1 @@\n-      obj = initialize(mem);\n-    } else {\n-      \/\/ The unhandled oop detector will poison local variable obj,\n-      \/\/ so reset it to NULL if mem is NULL.\n-      obj = NULL;\n+      return mem;\n@@ -378,1 +378,2 @@\n-  return obj;\n+\n+  return mem_allocate_slow(allocation);\n@@ -381,1 +382,1 @@\n-oop MemAllocator::try_allocate_in_existing_tlab() {\n+oop MemAllocator::allocate() const {\n@@ -384,1 +385,2 @@\n-    HeapWord* mem = allocate_inside_tlab_fast();\n+    Allocation allocation(*this, &obj);\n+    HeapWord* mem = mem_allocate(allocation);\n@@ -452,17 +454,0 @@\n-\n-\/\/ Does the minimal amount of initialization needed for a TLAB allocation.\n-\/\/ We don't need to do a full initialization, as such an allocation need not be immediately walkable.\n-oop StackChunkAllocator::initialize(HeapWord* mem) const {\n-  assert(_stack_size > 0, \"\");\n-  assert(_stack_size <= max_jint, \"\");\n-  assert(_word_size > _stack_size, \"\");\n-\n-  \/\/ zero out fields (but not the stack)\n-  const size_t hs = oopDesc::header_size();\n-  Copy::fill_to_aligned_words(mem + hs, vmClasses::StackChunk_klass()->size_helper() - hs);\n-\n-  jdk_internal_vm_StackChunk::set_size(mem, (int)_stack_size);\n-  jdk_internal_vm_StackChunk::set_sp(mem, (int)_stack_size);\n-\n-  return finish(mem);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":33,"deletions":48,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"metaprogramming\/isConst.hpp\"\n@@ -41,0 +40,2 @@\n+#include <type_traits>\n+\n@@ -366,1 +367,1 @@\n-  typedef typename Conditional<IsConst<Storage>::value, const Block*, Block*>::type BlockPtr;\n+  typedef typename Conditional<std::is_const<Storage>::value, const Block*, Block*>::type BlockPtr;\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -165,6 +165,0 @@\n-DirtyCardToOopClosure* Space::new_dcto_cl(OopIterateClosure* cl,\n-                                          CardTable::PrecisionStyle precision,\n-                                          HeapWord* boundary) {\n-  return new DirtyCardToOopClosure(this, cl, precision, boundary);\n-}\n-\n@@ -193,3 +187,3 @@\n-void FilteringDCTOC::walk_mem_region(MemRegion mr,\n-                                     HeapWord* bottom,\n-                                     HeapWord* top) {\n+void ContiguousSpaceDCTOC::walk_mem_region(MemRegion mr,\n+                                           HeapWord* bottom,\n+                                           HeapWord* top) {\n@@ -294,1 +288,1 @@\n-void OffsetTableContigSpace::clear(bool mangle_space) {\n+void TenuredSpace::clear(bool mangle_space) {\n@@ -299,1 +293,1 @@\n-void OffsetTableContigSpace::set_bottom(HeapWord* new_bottom) {\n+void TenuredSpace::set_bottom(HeapWord* new_bottom) {\n@@ -304,1 +298,1 @@\n-void OffsetTableContigSpace::set_end(HeapWord* new_end) {\n+void TenuredSpace::set_end(HeapWord* new_end) {\n@@ -604,1 +598,1 @@\n-void OffsetTableContigSpace::print_on(outputStream* st) const {\n+void TenuredSpace::print_on(outputStream* st) const {\n@@ -747,1 +741,1 @@\n-void OffsetTableContigSpace::initialize_threshold() {\n+void TenuredSpace::initialize_threshold() {\n@@ -751,1 +745,1 @@\n-void OffsetTableContigSpace::alloc_block(HeapWord* start, HeapWord* end) {\n+void TenuredSpace::alloc_block(HeapWord* start, HeapWord* end) {\n@@ -755,2 +749,2 @@\n-OffsetTableContigSpace::OffsetTableContigSpace(BlockOffsetSharedArray* sharedOffsetArray,\n-                                               MemRegion mr) :\n+TenuredSpace::TenuredSpace(BlockOffsetSharedArray* sharedOffsetArray,\n+                           MemRegion mr) :\n@@ -758,1 +752,1 @@\n-  _par_alloc_lock(Mutex::safepoint, \"OffsetTableContigSpaceParAlloc_lock\", true)\n+  _par_alloc_lock(Mutex::safepoint, \"TenuredSpaceParAlloc_lock\", true)\n@@ -767,1 +761,1 @@\n-void OffsetTableContigSpace::verify() const {\n+void TenuredSpace::verify() const {\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":13,"deletions":19,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -136,1 +136,0 @@\n-  bool not_empty() const             { return used() > 0; }\n@@ -178,8 +177,0 @@\n-  \/\/ Create and return a new dirty card to oop closure. Can be\n-  \/\/ overridden to return the appropriate type of closure\n-  \/\/ depending on the type of space in which the closure will\n-  \/\/ operate. ResourceArea allocated.\n-  virtual DirtyCardToOopClosure* new_dcto_cl(OopIterateClosure* cl,\n-                                             CardTable::PrecisionStyle precision,\n-                                             HeapWord* boundary);\n-\n@@ -262,1 +253,0 @@\n-  NOT_PRODUCT(HeapWord* _last_explicit_min_done;)\n@@ -287,1 +277,0 @@\n-    NOT_PRODUCT(_last_explicit_min_done = NULL);\n@@ -290,11 +279,1 @@\n-  void do_MemRegion(MemRegion mr);\n-\n-  void set_min_done(HeapWord* min_done) {\n-    _min_done = min_done;\n-    NOT_PRODUCT(_last_explicit_min_done = _min_done);\n-  }\n-#ifndef PRODUCT\n-  void set_last_bottom(HeapWord* last_bottom) {\n-    _last_bottom = last_bottom;\n-  }\n-#endif\n+  void do_MemRegion(MemRegion mr) override;\n@@ -334,2 +313,2 @@\n-  virtual void initialize(MemRegion mr, bool clear_space, bool mangle_space);\n-  virtual void clear(bool mangle_space);\n+  void initialize(MemRegion mr, bool clear_space, bool mangle_space) override;\n+  void clear(bool mangle_space) override;\n@@ -376,1 +355,1 @@\n-  virtual void adjust_pointers();\n+  void adjust_pointers() override;\n@@ -403,7 +382,0 @@\n-\n-  \/\/ Return a size with adjustments as required of the space.\n-  virtual size_t adjust_object_size_v(size_t size) const { return size; }\n-\n-  void set_first_dead(HeapWord* value) { _first_dead = value; }\n-  void set_end_of_live(HeapWord* value) { _end_of_live = value; }\n-\n@@ -442,2 +414,2 @@\n-  virtual void initialize(MemRegion mr, bool clear_space, bool mangle_space);\n-  virtual void clear(bool mangle_space);\n+  void initialize(MemRegion mr, bool clear_space, bool mangle_space) override;\n+  void clear(bool mangle_space) override;\n@@ -464,1 +436,1 @@\n-  void mangle_unused_area() PRODUCT_RETURN;\n+  void mangle_unused_area() override PRODUCT_RETURN;\n@@ -466,1 +438,1 @@\n-  void mangle_unused_area_complete() PRODUCT_RETURN;\n+  void mangle_unused_area_complete() override PRODUCT_RETURN;\n@@ -475,3 +447,2 @@\n-  size_t capacity() const        { return byte_size(bottom(), end()); }\n-  size_t used() const            { return byte_size(bottom(), top()); }\n-  size_t free() const            { return byte_size(top(),    end()); }\n+  size_t used() const override   { return byte_size(bottom(), top()); }\n+  size_t free() const override   { return byte_size(top(),    end()); }\n@@ -479,1 +450,1 @@\n-  virtual bool is_free_block(const HeapWord* p) const;\n+  bool is_free_block(const HeapWord* p) const override;\n@@ -483,1 +454,1 @@\n-  MemRegion used_region() const { return MemRegion(bottom(), top()); }\n+  MemRegion used_region() const override { return MemRegion(bottom(), top()); }\n@@ -486,2 +457,2 @@\n-  virtual HeapWord* allocate(size_t word_size);\n-  virtual HeapWord* par_allocate(size_t word_size);\n+  HeapWord* allocate(size_t word_size) override;\n+  HeapWord* par_allocate(size_t word_size) override;\n@@ -490,2 +461,2 @@\n-  void oop_iterate(OopIterateClosure* cl);\n-  void object_iterate(ObjectClosure* blk);\n+  void oop_iterate(OopIterateClosure* cl) override;\n+  void object_iterate(ObjectClosure* blk) override;\n@@ -494,1 +465,1 @@\n-  virtual void reset_after_compaction() {\n+  void reset_after_compaction() override {\n@@ -499,1 +470,0 @@\n-  \/\/ Override.\n@@ -520,2 +490,2 @@\n-  virtual HeapWord* block_start_const(const void* p) const;\n-  size_t block_size(const HeapWord* p) const;\n+  HeapWord* block_start_const(const void* p) const override;\n+  size_t block_size(const HeapWord* p) const override;\n@@ -523,1 +493,1 @@\n-  bool block_is_obj(const HeapWord* p) const { return p < top(); }\n+  bool block_is_obj(const HeapWord* p) const override { return p < top(); }\n@@ -531,1 +501,1 @@\n-  void prepare_for_compaction(CompactPoint* cp);\n+  void prepare_for_compaction(CompactPoint* cp) override;\n@@ -534,1 +504,1 @@\n-  virtual void print_on(outputStream* st) const;\n+  void print_on(outputStream* st) const override;\n@@ -537,1 +507,1 @@\n-  virtual ContiguousSpace* toContiguousSpace() {\n+  ContiguousSpace* toContiguousSpace() override {\n@@ -542,1 +512,1 @@\n-  virtual void verify() const;\n+  void verify() const override;\n@@ -545,6 +515,12 @@\n-\n-\/\/ A dirty card to oop closure that does filtering.\n-\/\/ It knows how to filter out objects that are outside of the _boundary.\n-class FilteringDCTOC : public DirtyCardToOopClosure {\n-protected:\n-  \/\/ Override.\n+\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n+\/\/ sub-classes). It knows how to filter out objects that are outside of the\n+\/\/ _boundary.\n+\/\/\n+\/\/ Assumptions:\n+\/\/ 1. That the actual top of any area in a memory region\n+\/\/    contained by the space is bounded by the end of the contiguous\n+\/\/    region of the space.\n+\/\/ 2. That the space is really made up of objects and not just\n+\/\/    blocks.\n+class ContiguousSpaceDCTOC : public DirtyCardToOopClosure {\n+  \/\/ Overrides.\n@@ -552,1 +528,3 @@\n-                       HeapWord* bottom, HeapWord* top);\n+                       HeapWord* bottom, HeapWord* top) override;\n+\n+  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj) override;\n@@ -561,35 +539,6 @@\n-  virtual void walk_mem_region_with_cl(MemRegion mr,\n-                                       HeapWord* bottom, HeapWord* top,\n-                                       OopIterateClosure* cl) = 0;\n-  virtual void walk_mem_region_with_cl(MemRegion mr,\n-                                       HeapWord* bottom, HeapWord* top,\n-                                       FilteringClosure* cl) = 0;\n-\n-public:\n-  FilteringDCTOC(Space* sp, OopIterateClosure* cl,\n-                  CardTable::PrecisionStyle precision,\n-                  HeapWord* boundary) :\n-    DirtyCardToOopClosure(sp, cl, precision, boundary) {}\n-};\n-\n-\/\/ A dirty card to oop closure for contiguous spaces\n-\/\/ (ContiguousSpace and sub-classes).\n-\/\/ It is a FilteringClosure, as defined above, and it knows:\n-\/\/\n-\/\/ 1. That the actual top of any area in a memory region\n-\/\/    contained by the space is bounded by the end of the contiguous\n-\/\/    region of the space.\n-\/\/ 2. That the space is really made up of objects and not just\n-\/\/    blocks.\n-\n-class ContiguousSpaceDCTOC : public FilteringDCTOC {\n-protected:\n-  \/\/ Overrides.\n-  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n-\n-  virtual void walk_mem_region_with_cl(MemRegion mr,\n-                                       HeapWord* bottom, HeapWord* top,\n-                                       OopIterateClosure* cl);\n-  virtual void walk_mem_region_with_cl(MemRegion mr,\n-                                       HeapWord* bottom, HeapWord* top,\n-                                       FilteringClosure* cl);\n+  void walk_mem_region_with_cl(MemRegion mr,\n+                               HeapWord* bottom, HeapWord* top,\n+                               OopIterateClosure* cl);\n+  void walk_mem_region_with_cl(MemRegion mr,\n+                               HeapWord* bottom, HeapWord* top,\n+                               FilteringClosure* cl);\n@@ -601,1 +550,1 @@\n-    FilteringDCTOC(sp, cl, precision, boundary)\n+    DirtyCardToOopClosure(sp, cl, precision, boundary)\n@@ -605,4 +554,0 @@\n-\/\/ A ContigSpace that Supports an efficient \"block_start\" operation via\n-\/\/ a BlockOffsetArray (whose BlockOffsetSharedArray may be shared with\n-\/\/ other spaces.)  This is the abstract base class for old generation\n-\/\/ (tenured) spaces.\n@@ -611,1 +556,6 @@\n-class OffsetTableContigSpace: public ContiguousSpace {\n+\n+\/\/ Class TenuredSpace is used by TenuredGeneration; it supports an efficient\n+\/\/ \"block_start\" operation via a BlockOffsetArray (whose BlockOffsetSharedArray\n+\/\/ may be shared with other spaces.)\n+\n+class TenuredSpace: public ContiguousSpace {\n@@ -617,0 +567,2 @@\n+  \/\/ Mark sweep support\n+  size_t allowed_dead_ratio() const override;\n@@ -619,2 +571,2 @@\n-  OffsetTableContigSpace(BlockOffsetSharedArray* sharedOffsetArray,\n-                         MemRegion mr);\n+  TenuredSpace(BlockOffsetSharedArray* sharedOffsetArray,\n+               MemRegion mr);\n@@ -622,2 +574,2 @@\n-  void set_bottom(HeapWord* value);\n-  void set_end(HeapWord* value);\n+  void set_bottom(HeapWord* value) override;\n+  void set_end(HeapWord* value) override;\n@@ -625,1 +577,1 @@\n-  void clear(bool mangle_space);\n+  void clear(bool mangle_space) override;\n@@ -627,1 +579,1 @@\n-  inline HeapWord* block_start_const(const void* p) const;\n+  inline HeapWord* block_start_const(const void* p) const override;\n@@ -630,2 +582,2 @@\n-  virtual inline HeapWord* allocate(size_t word_size);\n-  inline HeapWord* par_allocate(size_t word_size);\n+  inline HeapWord* allocate(size_t word_size) override;\n+  inline HeapWord* par_allocate(size_t word_size) override;\n@@ -634,2 +586,2 @@\n-  virtual void initialize_threshold();\n-  virtual void alloc_block(HeapWord* start, HeapWord* end);\n+  void initialize_threshold() override;\n+  void alloc_block(HeapWord* start, HeapWord* end) override;\n@@ -637,1 +589,1 @@\n-  virtual void print_on(outputStream* st) const;\n+  void print_on(outputStream* st) const override;\n@@ -640,16 +592,1 @@\n-  void verify() const;\n-};\n-\n-\n-\/\/ Class TenuredSpace is used by TenuredGeneration\n-\n-class TenuredSpace: public OffsetTableContigSpace {\n-  friend class VMStructs;\n- protected:\n-  \/\/ Mark sweep support\n-  size_t allowed_dead_ratio() const;\n- public:\n-  \/\/ Constructor\n-  TenuredSpace(BlockOffsetSharedArray* sharedOffsetArray,\n-               MemRegion mr) :\n-    OffsetTableContigSpace(sharedOffsetArray, mr) {}\n+  void verify() const override;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":66,"deletions":129,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-inline HeapWord* OffsetTableContigSpace::allocate(size_t size) {\n+inline HeapWord* TenuredSpace::allocate(size_t size) {\n@@ -59,1 +59,1 @@\n-inline HeapWord* OffsetTableContigSpace::par_allocate(size_t size) {\n+inline HeapWord* TenuredSpace::par_allocate(size_t size) {\n@@ -77,1 +77,1 @@\n-OffsetTableContigSpace::block_start_const(const void* p) const {\n+TenuredSpace::block_start_const(const void* p) const {\n@@ -160,1 +160,1 @@\n-  \/\/ space subtypes.  For example, OffsetTableContigSpace's that were\n+  \/\/ space subtypes.  For example, TenuredSpace's that were\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+ShenandoahFullGC::~ShenandoahFullGC() {\n+  delete _preserved_marks;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-  _gc_timer(new (ResourceObj::C_HEAP, mtGC) ConcurrentGCTimer()),\n+  _gc_timer(new ConcurrentGCTimer()),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-class ZBarrierSetC2State : public ResourceObj {\n+class ZBarrierSetC2State : public ArenaObj {\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -31,2 +32,2 @@\n-ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, Thread* thread) :\n-    ObjArrayAllocator(klass, word_size, length, false \/* do_zero *\/, thread) {}\n+ZObjArrayAllocator::ZObjArrayAllocator(Klass* klass, size_t word_size, int length, bool do_zero, Thread* thread) :\n+    ObjArrayAllocator(klass, word_size, length, do_zero, thread) {}\n@@ -34,3 +35,43 @@\n-oop ZObjArrayAllocator::finish(HeapWord* mem) const {\n-  \/\/ Initialize object header and length field\n-  ObjArrayAllocator::finish(mem);\n+void ZObjArrayAllocator::yield_for_safepoint() const {\n+  ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n+}\n+\n+oop ZObjArrayAllocator::initialize(HeapWord* mem) const {\n+  \/\/ ZGC specializes the initialization by performing segmented clearing\n+  \/\/ to allow shorter time-to-safepoints.\n+\n+  if (!_do_zero) {\n+    \/\/ No need for ZGC specialization\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n+\n+  \/\/ A max segment size of 64K was chosen because microbenchmarking\n+  \/\/ suggested that it offered a good trade-off between allocation\n+  \/\/ time and time-to-safepoint\n+  const size_t segment_max = ZUtils::bytes_to_words(64 * K);\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  int base_offset = arrayOopDesc::base_offset_in_bytes(element_type);\n+\n+  \/\/ Clear leading 32 bit, if necessary.\n+  if (!is_aligned(base_offset, HeapWordSize)) {\n+    assert(is_aligned(base_offset, BytesPerInt), \"array base must be 32 bit aligned\");\n+    *reinterpret_cast<jint*>(reinterpret_cast<char*>(mem) + base_offset) = 0;\n+    base_offset += BytesPerInt;\n+  }\n+  assert(is_aligned(base_offset, HeapWordSize), \"remaining array base must be 64 bit aligned\");\n+\n+  const size_t header = heap_word_size(base_offset);\n+  const size_t payload_size = _word_size - header;\n+  if (payload_size <= segment_max) {\n+    \/\/ To small to use segmented clearing\n+    return ObjArrayAllocator::initialize(mem);\n+  }\n+\n+  \/\/ Segmented clearing\n+\n+  \/\/ The array is going to be exposed before it has been completely\n+  \/\/ cleared, therefore we can't expose the header at the end of this\n+  \/\/ function. Instead explicitly initialize it according to our needs.\n+  oopDesc::release_set_mark(mem, _klass->prototype_header());\n+  assert(_length >= 0, \"length should be non-negative\");\n+  arrayOopDesc::set_length(mem, _length);\n@@ -41,0 +82,1 @@\n+  \/\/ Relocation knows how to dodge iterating over such objects.\n@@ -43,7 +85,5 @@\n-  \/\/ A max segment size of 64K was chosen because microbenchmarking\n-  \/\/ suggested that it offered a good trade-off between allocation\n-  \/\/ time and time-to-safepoint\n-  const size_t segment_max = 64 * K;\n-  const size_t skip = arrayOopDesc::base_offset_in_bytes(ArrayKlass::cast(_klass)->element_type());\n-  size_t byte_size = _word_size * BytesPerWord;\n-  size_t remaining = byte_size - skip;\n+  for (size_t processed = 0; processed < payload_size; processed += segment_max) {\n+    \/\/ Calculate segment\n+    HeapWord* const start = (HeapWord*)(mem + header + processed);\n+    const size_t remaining = payload_size - processed;\n+    const size_t segment_size = MIN2(remaining, segment_max);\n@@ -51,9 +91,4 @@\n-  while (remaining > 0) {\n-    const size_t segment = MIN2(remaining, segment_max);\n-    Copy::zero_to_bytes(((char*)mem) + (byte_size - remaining), segment);\n-    remaining -= segment;\n-\n-    if (remaining > 0) {\n-      \/\/ Safepoint\n-      ThreadBlockInVM tbivm(JavaThread::cast(_thread));\n-    }\n+    Copy::zero_to_words(start, segment_size);\n+\n+    \/\/ Safepoint\n+    yield_for_safepoint();\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":56,"deletions":21,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm_io.h\"\n@@ -36,0 +35,1 @@\n+#include \"jvm_io.h\"\n@@ -63,2 +63,0 @@\n-\/\/ no precompiled headers\n-\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,2 +145,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -156,2 +156,2 @@\n-  JVMCITraceMark jtm(\"CompilerToVM::\" #name);            \\\n-  C2V_BLOCK(result_type, name, signature)\n+  C2V_BLOCK(result_type, name, signature)                \\\n+  JVMCITraceMark jtm(\"CompilerToVM::\" #name);\n@@ -506,1 +506,1 @@\n-    JVMCIENV->runtime()->initialize(JVMCIENV);\n+    JVMCIENV->runtime()->initialize(JVMCI_CHECK_NULL);\n@@ -579,0 +579,10 @@\n+C2V_VMENTRY_NULL(jobject, getUncachedStringInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  constantTag tag = cp->tag_at(index);\n+  if (!tag.is_string()) {\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(\"Unexpected constant pool tag at index %d: %d\", index, tag.value()));\n+  }\n+  oop obj = cp->uncached_string_at(index, CHECK_NULL);\n+  return JVMCIENV->get_jobject(JVMCIENV->get_object_constant(obj));\n+C2V_END\n+\n@@ -1602,1 +1612,1 @@\n-    GrowableArray<ScopeValue*>* extentLocals = cvf->scope()->locals();\n+    GrowableArray<ScopeValue*>* scopedValues = cvf->scope()->locals();\n@@ -1607,1 +1617,1 @@\n-        if (var->type() == T_OBJECT && extentLocals->at(i2)->is_object()) {\n+        if (var->type() == T_OBJECT && scopedValues->at(i2)->is_object()) {\n@@ -1894,3 +1904,0 @@\n-  \/\/ Ensure class is linked\n-  iklass->link_class(CHECK_NULL);\n-\n@@ -1924,3 +1931,0 @@\n-  \/\/ Ensure class is linked\n-  iklass->link_class(CHECK_NULL);\n-\n@@ -2311,1 +2315,0 @@\n-  JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2314,0 +2317,1 @@\n+    JVMCITraceMark jtm(\"isCurrentThreadAttached\");\n@@ -2330,1 +2334,0 @@\n-  JVMCITraceMark jtm(\"getCurrentJavaThread\");\n@@ -2376,1 +2379,0 @@\n-  JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2380,0 +2382,1 @@\n+    JVMCITraceMark jtm(\"attachCurrentThread\");\n@@ -2434,1 +2437,0 @@\n-  JVMCITraceMark jtm(\"detachCurrentThread\");\n@@ -2438,0 +2440,1 @@\n+    JVMCITraceMark jtm(\"detachCurrentThread\");\n@@ -2837,0 +2840,1 @@\n+  {CC \"getUncachedStringInPool\",                      CC \"(\" HS_CONSTANT_POOL2 \"I)\" JAVACONSTANT,                                           FN_PTR(getUncachedStringInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-  nonstatic_field(InstanceKlass,               _misc_flags,                                   u2)                                    \\\n+  nonstatic_field(InstanceKlass,               _misc_status._flags,                           u2)                                    \\\n@@ -177,0 +177,1 @@\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                             OopHandle)                             \\\n@@ -319,0 +320,1 @@\n+  static_field(StubRoutines,                _chacha20Block,                                   address)                               \\\n@@ -653,2 +655,2 @@\n-  declare_constant(InstanceKlass::_misc_has_nonstatic_concrete_methods)   \\\n-  declare_constant(InstanceKlass::_misc_declares_nonstatic_concrete_methods) \\\n+  declare_constant(InstanceKlassMiscStatus::_misc_has_nonstatic_concrete_methods)   \\\n+  declare_constant(InstanceKlassMiscStatus::_misc_declares_nonstatic_concrete_methods) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -226,3 +226,3 @@\n-  \/\/ - Mapping backed by a file\n-  \/\/ - Mapping backed by explicit large pages\n-  \/\/ - Mapping backed by normal pages or transparent huge pages\n+  \/\/ 1. Mapping backed by a file\n+  \/\/ 2. Mapping backed by explicit large pages\n+  \/\/ 3. Mapping backed by normal pages or transparent huge pages\n@@ -232,0 +232,1 @@\n+  \/\/ == Case 1 ==\n@@ -242,1 +243,4 @@\n-  } else if (use_explicit_large_pages(page_size)) {\n+  }\n+\n+  \/\/ == Case 2 ==\n+  if (use_explicit_large_pages(page_size)) {\n@@ -247,4 +251,1 @@\n-    size_t used_page_size = page_size;\n-    char* base = NULL;\n-\n-      base = reserve_memory_special(requested_address, size, alignment, used_page_size, executable);\n+      char* base = reserve_memory_special(requested_address, size, alignment, page_size, executable);\n@@ -253,1 +254,3 @@\n-        break;\n+        \/\/ Successful reservation using large pages.\n+        initialize_members(base, size, alignment, page_size, true, executable);\n+        return;\n@@ -255,2 +258,2 @@\n-      used_page_size = os::page_sizes().next_smaller(used_page_size);\n-    } while (used_page_size > (size_t) os::vm_page_size());\n+      page_size = os::page_sizes().next_smaller(page_size);\n+    } while (page_size > (size_t) os::vm_page_size());\n@@ -258,5 +261,0 @@\n-    if (base != NULL) {\n-      \/\/ Successful reservation using large pages.\n-      initialize_members(base, size, alignment, used_page_size, true, executable);\n-      return;\n-    }\n@@ -266,1 +264,1 @@\n-    page_size = os::vm_page_size();\n+    assert(page_size == (size_t) os::vm_page_size(), \"inv\");\n@@ -269,1 +267,1 @@\n-  \/\/ Not a 'special' reservation.\n+  \/\/ == Case 3 ==\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm_io.h\"\n@@ -31,1 +30,1 @@\n-#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"jvm_io.h\"\n@@ -70,4 +70,0 @@\n-void Klass::replace_java_mirror(oop mirror) {\n-  _java_mirror.replace(mirror);\n-}\n-\n@@ -802,1 +798,1 @@\n-    guarantee(oopDesc::is_oop(java_mirror_no_keepalive()), \"should be instance\");\n+    guarantee(java_lang_Class::is_instance(java_mirror_no_keepalive()), \"should be instance\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -274,1 +274,2 @@\n-  void replace_java_mirror(oop mirror);\n+  OopHandle java_mirror_handle() const { return _java_mirror; }\n+  void swap_java_mirror_handle(OopHandle& mirror) { _java_mirror.swap(mirror); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,4 +104,1 @@\n-  ResetNoHandleMark rnm; \/\/ Might be called from LEAF\/QUICK ENTRY\n-  HandleMark hm(current);\n-  Handle object(current, this);\n-  return ObjectSynchronizer::identity_hash_value_for(object);\n+  return ObjectSynchronizer::FastHashCode(current, this);\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -298,0 +298,1 @@\n+  inline bool fast_no_hash_check();\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -430,0 +430,8 @@\n+\/\/ This checks fast simple case of whether the oop has_no_hash,\n+\/\/ to optimize JVMTI table lookup.\n+bool oopDesc::fast_no_hash_check() {\n+  markWord mrk = mark_acquire();\n+  assert(!mrk.is_marked(), \"should never be marked\");\n+  return mrk.is_unlocked() && mrk.has_no_hash();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1554,0 +1554,1 @@\n+  init_req( ValidLengthTest    , topnode);\n@@ -1580,48 +1581,0 @@\n-\/\/=============================================================================\n-Node* AllocateArrayNode::Ideal(PhaseGVN *phase, bool can_reshape) {\n-  if (remove_dead_region(phase, can_reshape))  return this;\n-  \/\/ Don't bother trying to transform a dead node\n-  if (in(0) && in(0)->is_top())  return NULL;\n-\n-  const Type* type = phase->type(Ideal_length());\n-  if (type->isa_int() && type->is_int()->_hi < 0) {\n-    if (can_reshape) {\n-      PhaseIterGVN *igvn = phase->is_IterGVN();\n-      \/\/ Unreachable fall through path (negative array length),\n-      \/\/ the allocation can only throw so disconnect it.\n-      Node* proj = proj_out_or_null(TypeFunc::Control);\n-      Node* catchproj = NULL;\n-      if (proj != NULL) {\n-        for (DUIterator_Fast imax, i = proj->fast_outs(imax); i < imax; i++) {\n-          Node *cn = proj->fast_out(i);\n-          if (cn->is_Catch()) {\n-            catchproj = cn->as_Multi()->proj_out_or_null(CatchProjNode::fall_through_index);\n-            break;\n-          }\n-        }\n-      }\n-      if (catchproj != NULL && catchproj->outcnt() > 0 &&\n-          (catchproj->outcnt() > 1 ||\n-           catchproj->unique_out()->Opcode() != Op_Halt)) {\n-        assert(catchproj->is_CatchProj(), \"must be a CatchProjNode\");\n-        Node* nproj = catchproj->clone();\n-        igvn->register_new_node_with_optimizer(nproj);\n-\n-        Node *frame = new ParmNode( phase->C->start(), TypeFunc::FramePtr );\n-        frame = phase->transform(frame);\n-        \/\/ Halt & Catch Fire\n-        Node* halt = new HaltNode(nproj, frame, \"unexpected negative array length\");\n-        igvn->add_input_to(phase->C->root(), halt);\n-        phase->transform(halt);\n-\n-        igvn->replace_node(catchproj, phase->C->top());\n-        return this;\n-      }\n-    } else {\n-      \/\/ Can't correct it during regular GVN so register for IGVN\n-      phase->C->record_for_igvn(this);\n-    }\n-  }\n-  return NULL;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":48,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -61,3 +61,0 @@\n-#if INCLUDE_SHENANDOAHGC\n-#include \"gc\/shenandoah\/c2\/shenandoahBarrierSetC2.hpp\"\n-#endif\n@@ -585,0 +582,1 @@\n+    BarrierSetC2 *bs = BarrierSet::barrier_set()->barrier_set_c2();\n@@ -601,2 +599,1 @@\n-          if (!n->is_Store() && n->Opcode() != Op_CastP2X\n-              SHENANDOAHGC_ONLY(&& (!UseShenandoahGC || !ShenandoahBarrierSetC2::is_shenandoah_wb_pre_call(n))) ) {\n+          if (!n->is_Store() && n->Opcode() != Op_CastP2X && !bs->is_gc_pre_barrier_node(n)) {\n@@ -1195,1 +1192,2 @@\n-            address slow_call_address  \/\/ Address of slow call\n+            address slow_call_address,  \/\/ Address of slow call\n+            Node* valid_length_test \/\/ whether length is valid or not\n@@ -1380,0 +1378,6 @@\n+  \/\/ For array allocations, copy the valid length check to the call node so Compile::final_graph_reshaping() can verify\n+  \/\/ that the call has the expected number of CatchProj nodes (in case the allocation always fails and the fallthrough\n+  \/\/ path dies).\n+  if (valid_length_test != NULL) {\n+    call->add_req(valid_length_test);\n+  }\n@@ -1622,1 +1626,1 @@\n-                                          static_cast<int (*)(Thread*, oopDesc*)>(SharedRuntime::dtrace_object_alloc)),\n+                                          static_cast<int (*)(JavaThread*, oopDesc*)>(SharedRuntime::dtrace_object_alloc)),\n@@ -1868,1 +1872,1 @@\n-                         OptoRuntime::new_instance_Java());\n+                         OptoRuntime::new_instance_Java(), NULL);\n@@ -1873,0 +1877,1 @@\n+  Node* valid_length_test = alloc->in(AllocateNode::ValidLengthTest);\n@@ -1887,1 +1892,1 @@\n-                         slow_call_address);\n+                         slow_call_address, valid_length_test);\n@@ -2371,1 +2376,0 @@\n-               n->Opcode() == Op_Opaque2   ||\n@@ -2414,1 +2418,1 @@\n-      } else if (n->is_Opaque1() || n->Opcode() == Op_Opaque2) {\n+      } else if (n->is_Opaque1()) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1022,1 +1022,1 @@\n-  if (is_sha3) fields[argp++] = TypeInt::INT; \/\/ digest_length\n+  if (is_sha3) fields[argp++] = TypeInt::INT; \/\/ block_size\n@@ -1044,1 +1044,1 @@\n-  if (is_sha3) fields[argp++] = TypeInt::INT; \/\/ digest_length\n+  if (is_sha3) fields[argp++] = TypeInt::INT; \/\/ block_size\n@@ -1226,0 +1226,20 @@\n+\n+\/\/ ChaCha20 Block function\n+const TypeFunc* OptoRuntime::chacha20Block_Type() {\n+    int argcnt = 2;\n+\n+    const Type** fields = TypeTuple::fields(argcnt);\n+    int argp = TypeFunc::Parms;\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ state\n+    fields[argp++] = TypePtr::NOTNULL;      \/\/ result\n+\n+    assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+    const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);\n+\n+    \/\/ result type needed\n+    fields = TypeTuple::fields(1);\n+    fields[TypeFunc::Parms + 0] = TypeInt::INT;     \/\/ key stream outlen as int\n+    const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+    return TypeFunc::make(domain, range);\n+}\n+\n@@ -1270,0 +1290,20 @@\n+\/\/ Poly1305 processMultipleBlocks function\n+const TypeFunc* OptoRuntime::poly1305_processBlocks_Type() {\n+  int argcnt = 4;\n+\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ input array\n+  fields[argp++] = TypeInt::INT;        \/\/ input length\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ accumulator array\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ r array\n+  assert(argp == TypeFunc::Parms + argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms + 0] = NULL; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"jni.h\"\n-#include \"jvm.h\"\n@@ -35,0 +33,2 @@\n+#include \"jni.h\"\n+#include \"jvm.h\"\n@@ -756,1 +756,0 @@\n-  assert(event->should_commit(), \"invariant\");\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -39,0 +38,1 @@\n+#include \"jvm.h\"\n@@ -44,1 +44,0 @@\n-#include \"metaprogramming\/enableIf.hpp\"\n@@ -65,0 +64,1 @@\n+#include \"utilities\/parseInteger.hpp\"\n@@ -70,0 +70,1 @@\n+\n@@ -541,0 +542,1 @@\n+  { \"EnableWaitForParallelLoad\",    JDK_Version::jdk(20), JDK_Version::jdk(21), JDK_Version::jdk(22) },\n@@ -549,5 +551,6 @@\n-  { \"ExtendedDTraceProbes\",         JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"UseContainerCpuShares\",        JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"PreferContainerQuotaForCPUCount\", JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"AliasLevel\",                   JDK_Version::jdk(19), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n-  { \"UseCodeAging\",                 JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::jdk(21) },\n+  { \"G1ConcRefinementGreenZone\",    JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementYellowZone\",   JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementRedZone\",      JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementThresholdStep\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1UseAdaptiveConcRefinement\",  JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n+  { \"G1ConcRefinementServiceIntervalMillis\", JDK_Version::undefined(), JDK_Version::jdk(20), JDK_Version::undefined() },\n@@ -748,109 +751,0 @@\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  \/\/ Don't use strtol -- on 64-bit builds, \"long\" could be either 32- or 64-bits\n-  \/\/ so the range tests could be tautological and might cause compiler warnings.\n-  STATIC_ASSERT(sizeof(long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  long long v = strtoll(s, endptr, base);\n-  if (errno != 0 || v < min_jint || v > max_jint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  \/\/ Don't use strtoul -- same reason as above.\n-  STATIC_ASSERT(sizeof(unsigned long long) >= 8); \/\/ C++ specification\n-  errno = 0; \/\/ errno is thread safe\n-  unsigned long long v = strtoull(s, endptr, base);\n-  if (errno != 0 || v > max_juint) {\n-    return false;\n-  }\n-  *result = static_cast<T>(v);\n-  return true;\n-}\n-\n-template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoll(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n-static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n-  if (s[0] == '-') {\n-    return false;\n-  }\n-  errno = 0; \/\/ errno is thread safe\n-  *result = strtoull(s, endptr, base);\n-  return errno == 0;\n-}\n-\n-template<typename T>\n-static bool multiply_by_1k(T& n) {\n-  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n-      n <= std::numeric_limits<T>::max() \/ 1024) {\n-    n *= 1024;\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-\/\/ All of the integral types that can be used for command line options:\n-\/\/   int, uint, intx, uintx, uint64_t, size_t\n-\/\/\n-\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n-\/\/    {signed, unsigned} x {32-bit, 64-bit}\n-\/\/\n-\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n-template<typename T>\n-static bool parse_integer(const char *s, T* result) {\n-  if (!isdigit(s[0]) && s[0] != '-') {\n-    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n-    return false;\n-  }\n-\n-  T n = 0;\n-  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n-                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n-  char* remainder;\n-\n-  if (!parse_integer_impl(s, &remainder, (is_hex ? 16 : 10), &n)) {\n-    return false;\n-  }\n-\n-  \/\/ Fail if no number was read at all or if the remainder contains more than a single non-digit character.\n-  if (remainder == s || strlen(remainder) > 1) {\n-    return false;\n-  }\n-\n-  switch (*remainder) {\n-    case 'T': case 't':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'G': case 'g':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'M': case 'm':\n-      if (!multiply_by_1k(n)) return false;\n-      \/\/ fall-through\n-    case 'K': case 'k':\n-      if (!multiply_by_1k(n)) return false;\n-      break;\n-    case '\\0':\n-      break;\n-    default:\n-      return false;\n-  }\n-\n-  *result = n;\n-  return true;\n-}\n-\n@@ -2038,1 +1932,11 @@\n-    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+    if (ClassLoader::is_module_observable(\"jdk.internal.vm.ci\")) {\n+      if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+        return false;\n+      }\n+    }\n+  }\n+#endif\n+\n+#if INCLUDE_JFR\n+  if (status && (FlightRecorderOptions || StartFlightRecording)) {\n+    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.jfr\", addmods_count++)) {\n@@ -2914,20 +2818,1 @@\n-    } else if (match_option(option, \"-XX:+ExtendedDTraceProbes\")) {\n-#if defined(DTRACE_ENABLED)\n-      warning(\"Option ExtendedDTraceProbes was deprecated in version 19 and will likely be removed in a future release.\");\n-      warning(\"Use the combination of -XX:+DTraceMethodProbes, -XX:+DTraceAllocProbes and -XX:+DTraceMonitorProbes instead.\");\n-      if (FLAG_SET_CMDLINE(ExtendedDTraceProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(DTraceMethodProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(DTraceAllocProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(DTraceMonitorProbes, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-#else \/\/ defined(DTRACE_ENABLED)\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"ExtendedDTraceProbes flag is not applicable for this configuration\\n\");\n-      return JNI_EINVAL;\n+#if !defined(DTRACE_ENABLED)\n@@ -2946,1 +2831,1 @@\n-#endif \/\/ defined(DTRACE_ENABLED)\n+#endif \/\/ !defined(DTRACE_ENABLED)\n@@ -3037,1 +2922,1 @@\n-    _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<ModulePatchPath*>(10, mtArguments);\n+    _patch_mod_prefix = new (mtArguments) GrowableArray<ModulePatchPath*>(10, mtArguments);\n@@ -4259,32 +4144,0 @@\n-const char* Arguments::PropertyList_get_key_at(SystemProperty *pl, int index) {\n-  int count = 0;\n-  const char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->key();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n-char* Arguments::PropertyList_get_value_at(SystemProperty* pl, int index) {\n-  int count = 0;\n-  char* ret_val = NULL;\n-\n-  while(pl != NULL) {\n-    if(count >= index) {\n-      ret_val = pl->value();\n-      break;\n-    }\n-    count++;\n-    pl = pl->next();\n-  }\n-\n-  return ret_val;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":24,"deletions":171,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -241,0 +241,3 @@\n+  product(bool, UsePoly1305Intrinsics, false, DIAGNOSTIC,                   \\\n+          \"Use intrinsics for sun.security.util.math.intpoly\")              \\\n+                                                                            \\\n@@ -323,0 +326,3 @@\n+  product(bool, UseChaCha20Intrinsics, false, DIAGNOSTIC,                   \\\n+          \"Use intrinsics for the vectorized version of ChaCha20\")          \\\n+                                                                            \\\n@@ -452,4 +458,0 @@\n-  develop(bool, UseMallocOnly, false,                                       \\\n-          \"Use only malloc\/free for allocation (no resource area\/arena). \"  \\\n-          \"Used to help diagnose memory stomping bugs.\")                    \\\n-                                                                            \\\n@@ -514,0 +516,3 @@\n+  product(bool, ErrorLogSecondaryErrorDetails, false, DIAGNOSTIC,           \\\n+          \"If enabled, show details on secondary crashes in the error log\") \\\n+                                                                            \\\n@@ -679,3 +684,0 @@\n-  product(bool, DynamicallyResizeSystemDictionaries, true, DIAGNOSTIC,      \\\n-          \"Dynamically resize system dictionaries as needed\")               \\\n-                                                                            \\\n@@ -686,0 +688,4 @@\n+  product(bool, EnableWaitForParallelLoad, false,                           \\\n+          \"(Deprecated) Enable legacy parallel classloading logic for \"     \\\n+          \"class loaders not registered as parallel capable\")               \\\n+                                                                            \\\n@@ -1825,5 +1831,0 @@\n-  product(bool, ExtendedDTraceProbes,    false,                             \\\n-          \"(Deprecated) Enable performance-impacting dtrace probes. \"       \\\n-          \"Use the combination of -XX:+DTraceMethodProbes, \"                \\\n-          \"-XX:+DTraceAllocProbes and -XX:+DTraceMonitorProbes instead.\")   \\\n-                                                                            \\\n@@ -1949,5 +1950,0 @@\n-  product(intx, ExtentLocalCacheSize, 16,                                   \\\n-          \"Size of the cache for scoped values\")                            \\\n-           range(0, max_intx)                                               \\\n-           constraint(ExtentLocalCacheSizeConstraintFunc, AtParse)          \\\n-                                                                            \\\n@@ -1995,3 +1991,0 @@\n-                                                                            \\\n-  develop(bool, TraceOptimizedUpcallStubs, false,                           \\\n-                \"Trace optimized upcall stub generation\")                   \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":13,"deletions":20,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1435,0 +1435,6 @@\n+static inline bool is_excluded(const Klass* monitor_klass) {\n+  assert(monitor_klass != nullptr, \"invariant\");\n+  NOT_JFR_RETURN_(false);\n+  JFR_ONLY(return vmSymbols::jfr_chunk_rotation_monitor() == monitor_klass->name());\n+}\n+\n@@ -1442,1 +1448,5 @@\n-  event->set_monitorClass(monitor->object()->klass());\n+  const Klass* monitor_klass = monitor->object()->klass();\n+  if (is_excluded(monitor_klass)) {\n+    return;\n+  }\n+  event->set_monitorClass(monitor_klass);\n@@ -1888,1 +1898,1 @@\n-  if (NotRunnable(current, (JavaThread*) owner_raw())) {\n+  if (NotRunnable(current, static_cast<JavaThread*>(owner_raw()))) {\n@@ -1937,1 +1947,1 @@\n-    JavaThread* ox = (JavaThread*) owner_raw();\n+    JavaThread* ox = static_cast<JavaThread*>(owner_raw());\n@@ -1939,1 +1949,1 @@\n-      ox = (JavaThread*)try_set_owner_from(NULL, current);\n+      ox = static_cast<JavaThread*>(try_set_owner_from(NULL, current));\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -207,2 +207,0 @@\n-  static int header_offset_in_bytes()      { return offset_of(ObjectMonitor, _header); }\n-  static int object_offset_in_bytes()      { return offset_of(ObjectMonitor, _object); }\n@@ -249,0 +247,2 @@\n+  \/\/ Returns true if this OM has an owner, false otherwise.\n+  bool      has_owner() const;\n@@ -268,2 +268,0 @@\n-  \/\/ Get _next_om field with acquire semantics.\n-  ObjectMonitor* next_om_acquire() const;\n@@ -272,6 +270,0 @@\n-  \/\/ Set _next_om field to new_value with release semantics.\n-  void release_set_next_om(ObjectMonitor* new_value);\n-  \/\/ Try to set _next_om field to new_value if the current value matches\n-  \/\/ old_value, using Atomic::cmpxchg(). Otherwise, does not change the\n-  \/\/ _next_om field. Returns the prior value of the _next_om field.\n-  ObjectMonitor* try_set_next_om(ObjectMonitor* old_value, ObjectMonitor* new_value);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"jvm.h\"\n@@ -36,1 +35,1 @@\n-#include \"logging\/log.hpp\"\n+#include \"jvm.h\"\n@@ -67,0 +66,1 @@\n+#include \"services\/mallocHeader.inline.hpp\"\n@@ -103,0 +103,10 @@\n+int os::snprintf_checked(char* buf, size_t len, const char* fmt, ...) {\n+  va_list args;\n+  va_start(args, fmt);\n+  int result = os::vsnprintf(buf, len, fmt, args);\n+  va_end(args);\n+  assert(result >= 0, \"os::snprintf error\");\n+  assert(static_cast<size_t>(result) < len, \"os::snprintf truncated\");\n+  return result;\n+}\n+\n@@ -179,1 +189,1 @@\n-  \/\/    between UTC and and local time.\n+  \/\/    between UTC and local time.\n@@ -659,0 +669,5 @@\n+  \/\/ Check for overflow.\n+  if (outer_size < size) {\n+    return NULL;\n+  }\n+\n@@ -704,1 +719,2 @@\n-  const size_t new_outer_size = size + MemTracker::overhead_per_malloc();\n+  if (MemTracker::enabled()) {\n+    \/\/ NMT realloc handling\n@@ -706,2 +722,1 @@\n-  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n-  void* const old_outer_ptr = MemTracker::record_free(memblock);\n+    const size_t new_outer_size = size + MemTracker::overhead_per_malloc();\n@@ -709,4 +724,39 @@\n-  ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(old_outer_ptr, new_outer_size);)\n-  if (new_outer_ptr == NULL) {\n-    return NULL;\n-  }\n+    \/\/ Handle size overflow.\n+    if (new_outer_size < size) {\n+      return NULL;\n+    }\n+\n+    \/\/ Perform integrity checks on and mark the old block as dead *before* calling the real realloc(3) since it\n+    \/\/ may invalidate the old block, including its header.\n+    MallocHeader* header = MallocTracker::malloc_header(memblock);\n+    header->assert_block_integrity(); \/\/ Assert block hasn't been tampered with.\n+    const MallocHeader::FreeInfo free_info = header->free_info();\n+    header->mark_block_as_dead();\n+\n+    \/\/ the real realloc\n+    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(header, new_outer_size);)\n+\n+    if (new_outer_ptr == NULL) {\n+      \/\/ realloc(3) failed and the block still exists.\n+      \/\/ We have however marked it as dead, revert this change.\n+      header->revive();\n+      return nullptr;\n+    }\n+    \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n+    MemTracker::deaccount(free_info);\n+\n+    \/\/ After a successful realloc(3), we account the resized block with its new size\n+    \/\/ to NMT.\n+    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack);\n+\n+#ifdef ASSERT\n+    size_t old_size = free_info.size;\n+    if (old_size < size) {\n+      \/\/ We also zap the newly extended region.\n+      ::memset((char*)new_inner_ptr + old_size, uninitBlockPad, size - old_size);\n+    }\n+#endif\n+\n+    rc = new_inner_ptr;\n+\n+  } else {\n@@ -714,1 +764,7 @@\n-  void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, memflags, stack);\n+    \/\/ NMT disabled.\n+    ALLOW_C_FUNCTION(::realloc, rc = ::realloc(memblock, size);)\n+    if (rc == NULL) {\n+      return NULL;\n+    }\n+\n+  }\n@@ -716,1 +772,1 @@\n-  DEBUG_ONLY(break_if_ptr_caught(new_inner_ptr);)\n+  DEBUG_ONLY(break_if_ptr_caught(rc);)\n@@ -718,1 +774,1 @@\n-  return new_inner_ptr;\n+  return rc;\n@@ -734,1 +790,1 @@\n-  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n+  \/\/ When NMT is enabled this checks for heap overwrites, then deaccounts the old block.\n@@ -1272,1 +1328,1 @@\n-  sprintf(modified_mode, \"%s\" LINUX_ONLY(\"e\") BSD_ONLY(\"e\") WINDOWS_ONLY(\"N\"), mode);\n+  os::snprintf_checked(modified_mode, sizeof(modified_mode), \"%s\" LINUX_ONLY(\"e\") BSD_ONLY(\"e\") WINDOWS_ONLY(\"N\"), mode);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":71,"deletions":15,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-address StubRoutines::_atomic_xchg_long_entry                   = NULL;\n-address StubRoutines::_atomic_store_entry                       = NULL;\n-address StubRoutines::_atomic_cmpxchg_byte_entry                = NULL;\n@@ -76,1 +73,0 @@\n-address StubRoutines::_atomic_add_long_entry                    = NULL;\n@@ -131,0 +127,1 @@\n+address StubRoutines::_chacha20Block                       = NULL;\n@@ -133,0 +130,1 @@\n+address StubRoutines::_poly1305_processBlocks              = NULL;\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -146,3 +146,0 @@\n-  static address _atomic_xchg_long_entry;\n-  static address _atomic_store_entry;\n-  static address _atomic_cmpxchg_byte_entry;\n@@ -152,1 +149,0 @@\n-  static address _atomic_add_long_entry;\n@@ -212,0 +208,1 @@\n+  static address _chacha20Block;\n@@ -214,0 +211,1 @@\n+  static address _poly1305_processBlocks;\n@@ -317,3 +315,0 @@\n-  static address atomic_xchg_long_entry()                  { return _atomic_xchg_long_entry; }\n-  static address atomic_store_entry()                      { return _atomic_store_entry; }\n-  static address atomic_cmpxchg_byte_entry()               { return _atomic_cmpxchg_byte_entry; }\n@@ -323,1 +318,0 @@\n-  static address atomic_add_long_entry()                   { return _atomic_add_long_entry; }\n@@ -389,0 +383,1 @@\n+  static address poly1305_processBlocks()               { return _poly1305_processBlocks; }\n@@ -391,0 +386,1 @@\n+  static address chacha20Block()         { return _chacha20Block; }\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-                        ResourceObj::C_HEAP, mtThread,\n+                        AnyObj::C_HEAP, mtThread,\n@@ -88,1 +88,1 @@\n-    list = new (ResourceObj::C_HEAP, mtThread) ObjectMonitorsHashtable::PtrList;\n+    list = new (mtThread) ObjectMonitorsHashtable::PtrList;\n@@ -244,1 +244,1 @@\n-int dtrace_waited_probe(ObjectMonitor* monitor, Handle obj, Thread* thr) {\n+int dtrace_waited_probe(ObjectMonitor* monitor, Handle obj, JavaThread* thr) {\n@@ -376,1 +376,1 @@\n-    JavaThread* const owner = (JavaThread*) m->owner_raw();\n+    JavaThread* const owner = static_cast<JavaThread*>(m->owner_raw());\n@@ -433,1 +433,1 @@\n-    current->print_stack_on(&ss);\n+    current->print_active_stack_on(&ss);\n@@ -448,1 +448,1 @@\n-      current->print_stack_on(&info_stream);\n+      current->print_active_stack_on(&info_stream);\n@@ -698,10 +698,0 @@\n-\/\/ No exception are possible in this case as we only use this internally when locking is\n-\/\/ correct and we have to wait until notified - so no interrupts or timeouts.\n-void ObjectSynchronizer::wait_uninterruptibly(Handle obj, JavaThread* current) {\n-  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-  \/\/ field is incremented before ownership is dropped and decremented\n-  \/\/ after ownership is regained.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n-  monitor->wait(0 \/* wait-forever *\/, false \/* not interruptible *\/, current);\n-}\n-\n@@ -1049,7 +1039,0 @@\n-\/\/ Deprecated -- use FastHashCode() instead.\n-\n-intptr_t ObjectSynchronizer::identity_hash_value_for(Handle obj) {\n-  return FastHashCode(Thread::current(), obj());\n-}\n-\n-\n@@ -1079,1 +1062,0 @@\n-\/\/ FIXME: jvmti should call this\n@@ -1271,1 +1253,0 @@\n-  assert(event->should_commit(), \"invariant\");\n@@ -1587,0 +1568,2 @@\n+  size_t unlinked_count = 0;\n+  size_t deleted_count = 0;\n@@ -1596,2 +1579,1 @@\n-    size_t unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer,\n-                                                         &delete_list);\n+    unlinked_count = _in_use_list.unlink_deflated(current, ls, &timer, &delete_list);\n@@ -1628,1 +1610,0 @@\n-    size_t deleted_count = 0;\n@@ -1639,0 +1620,1 @@\n+    assert(unlinked_count == deleted_count, \"must be\");\n@@ -1643,3 +1625,3 @@\n-    if (deflated_count != 0 || log_is_enabled(Debug, monitorinflation)) {\n-      ls->print_cr(\"deflated \" SIZE_FORMAT \" monitors in %3.7f secs\",\n-                   deflated_count, timer.seconds());\n+    if (deflated_count != 0 || unlinked_count != 0 || log_is_enabled(Debug, monitorinflation)) {\n+      ls->print_cr(\"deflated_count=\" SIZE_FORMAT \", {unlinked,deleted}_count=\" SIZE_FORMAT \" monitors in %3.7f secs\",\n+                   deflated_count, unlinked_count, timer.seconds());\n@@ -1754,0 +1736,1 @@\n+  log_info(monitorinflation)(\"Starting the final audit.\");\n@@ -1756,1 +1739,1 @@\n-    \/\/ Do a deflation in order to reduce the in-use monitor population\n+    \/\/ Do deflations in order to reduce the in-use monitor population\n@@ -1759,1 +1742,1 @@\n-    while (ObjectSynchronizer::deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr) >= (size_t)MonitorDeflationMax) {\n+    while (deflate_idle_monitors(\/* ObjectMonitorsHashtable is not needed here *\/ nullptr) > 0) {\n@@ -1764,1 +1747,1 @@\n-    ObjectSynchronizer::audit_and_print_stats(true \/* on_exit *\/);\n+    audit_and_print_stats(true \/* on_exit *\/);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":17,"deletions":34,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  typedef ResourceHashtable<void*, PtrList*, 1031, ResourceObj::C_HEAP, mtThread,\n+  typedef ResourceHashtable<void*, PtrList*, 1031, AnyObj::C_HEAP, mtThread,\n@@ -66,1 +66,1 @@\n-  ObjectMonitorsHashtable() : _ptrs(new (ResourceObj::C_HEAP, mtThread) PtrTable), _key_count(0), _om_count(0) {}\n+  ObjectMonitorsHashtable() : _ptrs(new (mtThread) PtrTable), _key_count(0), _om_count(0) {}\n@@ -82,5 +82,0 @@\n-  bool has_entry(void* key) {\n-    PtrList** listpp = _ptrs->get(key);\n-    return listpp != nullptr && *listpp != nullptr;\n-  }\n-\n@@ -162,5 +157,0 @@\n-  \/\/ Special internal-use-only method for use by JVM infrastructure\n-  \/\/ that needs to wait() on a java-level object but must not respond\n-  \/\/ to interrupt requests and doesn't timeout.\n-  static void wait_uninterruptibly(Handle obj, JavaThread* current);\n-\n@@ -181,1 +171,0 @@\n-  static intptr_t identity_hash_value_for(Handle obj);\n@@ -275,1 +264,0 @@\n-  void wait_uninterruptibly(JavaThread* current) { ObjectSynchronizer::wait_uninterruptibly(_obj, current); }\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -112,5 +112,0 @@\n-\n-#include CPU_HEADER(vmStructs)\n-#include OS_HEADER(vmStructs)\n-#include OS_CPU_HEADER(vmStructs)\n-\n@@ -145,0 +140,4 @@\n+#include CPU_HEADER(vmStructs)\n+#include OS_HEADER(vmStructs)\n+#include OS_CPU_HEADER(vmStructs)\n+\n@@ -238,1 +237,0 @@\n-  nonstatic_field(InstanceKlass,               _misc_flags,                                   u2)                                    \\\n@@ -489,1 +487,1 @@\n-  nonstatic_field(GrowableArrayBase,           _max,                                          int)                                   \\\n+  nonstatic_field(GrowableArrayBase,           _capacity,                                     int)                                   \\\n@@ -545,0 +543,1 @@\n+     static_field(StubRoutines,                _chacha20Block,                                address)                               \\\n@@ -547,0 +546,1 @@\n+     static_field(StubRoutines,                _poly1305_processBlocks,                       address)                               \\\n@@ -712,1 +712,1 @@\n-  nonstatic_field(JavaThread,                  _extentLocalCache,                              OopHandle)                             \\\n+  nonstatic_field(JavaThread,                  _scopedValueCache,                              OopHandle)                             \\\n@@ -1049,1 +1049,1 @@\n-  CDS_ONLY(nonstatic_field(FileMapHeader,      _space[0],                 CDSFileMapRegion))                                         \\\n+  CDS_ONLY(nonstatic_field(FileMapHeader,      _regions[0],               CDSFileMapRegion))                                         \\\n@@ -1068,1 +1068,1 @@\n-  nonstatic_field(CompileTask,                 _compile_id,                                   uint)                                  \\\n+  nonstatic_field(CompileTask,                 _compile_id,                                   int)                                   \\\n@@ -1073,1 +1073,0 @@\n-  nonstatic_field(vframeArray,                 _next,                                         vframeArray*)                          \\\n@@ -1568,1 +1567,1 @@\n-  declare_c2_type(BlackholeNode, MemBarNode)                              \\\n+  declare_c2_type(BlackholeNode, MultiNode)                               \\\n@@ -1572,1 +1571,0 @@\n-  declare_c2_type(Opaque2Node, Node)                                      \\\n@@ -1845,0 +1843,2 @@\n+  declare_c2_type(IsFiniteFNode, Node)                                    \\\n+  declare_c2_type(IsFiniteDNode, Node)                                    \\\n@@ -1877,1 +1877,1 @@\n-  declare_c2_type(VectorTestNode, Node)                                   \\\n+  declare_c2_type(VectorTestNode, CmpNode)                                \\\n@@ -2100,1 +2100,0 @@\n-  declare_constant(JVM_ACC_PROMOTED_FLAGS)                                \\\n@@ -2284,16 +2283,0 @@\n-  \/***************************************\/                               \\\n-  \/* InstanceKlass enums for _misc_flags *\/                               \\\n-  \/***************************************\/                               \\\n-                                                                          \\\n-  declare_constant(InstanceKlass::_misc_rewritten)                        \\\n-  declare_constant(InstanceKlass::_misc_has_nonstatic_fields)             \\\n-  declare_constant(InstanceKlass::_misc_should_verify_class)              \\\n-  declare_constant(InstanceKlass::_misc_is_contended)                     \\\n-  declare_constant(InstanceKlass::_misc_has_nonstatic_concrete_methods)   \\\n-  declare_constant(InstanceKlass::_misc_declares_nonstatic_concrete_methods)\\\n-  declare_constant(InstanceKlass::_misc_has_been_redefined)               \\\n-  declare_constant(InstanceKlass::_misc_is_scratch_class)                 \\\n-  declare_constant(InstanceKlass::_misc_is_shared_boot_class)             \\\n-  declare_constant(InstanceKlass::_misc_is_shared_platform_class)         \\\n-  declare_constant(InstanceKlass::_misc_is_shared_app_class)              \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":14,"deletions":31,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include <type_traits>\n@@ -113,0 +114,1 @@\n+#define INT32_FORMAT_X           \"0x%\"        PRIx32\n@@ -116,0 +118,1 @@\n+#define UINT32_FORMAT_X          \"0x%\"        PRIx32\n@@ -131,0 +134,1 @@\n+#define SSIZE_PLUS_FORMAT        \"%+\"         PRIdPTR\n@@ -373,0 +377,3 @@\n+#define PROPERFMT             SIZE_FORMAT \"%s\"\n+#define PROPERFMTARGS(s)      byte_size_in_proper_unit(s), proper_unit_for_byte_size(s)\n+\n@@ -779,4 +786,1 @@\n-inline const char* type2name(BasicType t) {\n-  assert((uint)t < T_CONFLICT + 1, \"invalid type\");\n-  return type2name_tab[t];\n-}\n+const char* type2name(BasicType t);\n@@ -1278,0 +1282,4 @@\n+\/\/ Converts any type T to a reference type.\n+template<typename T>\n+std::add_rvalue_reference_t<T> declval() noexcept;\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"jvm.h\"\n@@ -34,0 +33,1 @@\n+#include \"jvm.h\"\n@@ -44,0 +44,1 @@\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -57,1 +58,0 @@\n-#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -351,1 +351,1 @@\n-void VMError::print_native_stack(outputStream* st, frame fr, Thread* t, bool print_source_info, char* buf, int buf_size) {\n+void VMError::print_native_stack(outputStream* st, frame fr, Thread* t, bool print_source_info, int max_frames, char* buf, int buf_size) {\n@@ -356,1 +356,1 @@\n-\n+    const int limit = max_frames == -1 ? StackPrintLimit : MIN2(max_frames, (int)StackPrintLimit);\n@@ -358,1 +358,1 @@\n-    while (count++ < StackPrintLimit) {\n+    while (count++ < limit) {\n@@ -378,1 +378,1 @@\n-    if (count > StackPrintLimit) {\n+    if (count > limit) {\n@@ -382,1 +382,0 @@\n-    st->cr();\n@@ -532,4 +531,23 @@\n-# define BEGIN if (_current_step == 0) { _current_step = __LINE__;\n-# define STEP(s) } if (_current_step < __LINE__) { _current_step = __LINE__; _current_step_info = s; \\\n-  record_step_start_time(); _step_did_timeout = false;\n-# define END clear_step_start_time(); }\n+# define BEGIN                                             \\\n+  if (_current_step == 0) {                                \\\n+    _current_step = __LINE__;                              \\\n+    {\n+      \/\/ [Begin logic]\n+\n+# define STEP_IF(s,cond)                                   \\\n+    }                                                      \\\n+  }                                                        \\\n+  if (_current_step < __LINE__) {                          \\\n+    _current_step = __LINE__;                              \\\n+    _current_step_info = s;                                \\\n+    record_step_start_time();                              \\\n+    _step_did_timeout = false;                             \\\n+    if ((cond)) {\n+      \/\/ [Step logic]\n+\n+# define STEP(s) STEP_IF(s, true)\n+\n+# define END                                               \\\n+    }                                                      \\\n+    clear_step_start_time();                               \\\n+  }\n@@ -545,1 +563,0 @@\n-\n@@ -562,20 +579,15 @@\n-  STEP(\"test secondary crash 1\")\n-    if (_verbose && TestCrashInErrorHandler == TEST_SECONDARY_CRASH) {\n-      st->print_cr(\"Will crash now (TestCrashInErrorHandler=%u)...\",\n-        TestCrashInErrorHandler);\n-      controlled_crash(TestCrashInErrorHandler);\n-    }\n-\n-  STEP(\"test secondary crash 2\")\n-    if (_verbose && TestCrashInErrorHandler == TEST_SECONDARY_CRASH) {\n-      st->print_cr(\"Will crash now (TestCrashInErrorHandler=%u)...\",\n-        TestCrashInErrorHandler);\n-      controlled_crash(TestCrashInErrorHandler);\n-    }\n-\n-  STEP(\"test missing ResourceMark does not crash\")\n-    if (_verbose && TestCrashInErrorHandler == TEST_RESOURCE_MARK_CRASH) {\n-      stringStream message;\n-      message.print(\"This is a message with no ResourceMark\");\n-      tty->print_cr(\"%s\", message.as_string());\n-    }\n+  STEP_IF(\"test secondary crash 1\", _verbose && TestCrashInErrorHandler == TEST_SECONDARY_CRASH)\n+    st->print_cr(\"Will crash now (TestCrashInErrorHandler=%u)...\",\n+      TestCrashInErrorHandler);\n+    controlled_crash(TestCrashInErrorHandler);\n+\n+  STEP_IF(\"test secondary crash 2\", _verbose && TestCrashInErrorHandler == TEST_SECONDARY_CRASH)\n+    st->print_cr(\"Will crash now (TestCrashInErrorHandler=%u)...\",\n+      TestCrashInErrorHandler);\n+    controlled_crash(TestCrashInErrorHandler);\n+\n+  STEP_IF(\"test missing ResourceMark does not crash\",\n+      _verbose && TestCrashInErrorHandler == TEST_RESOURCE_MARK_CRASH)\n+    stringStream message;\n+    message.print(\"This is a message with no ResourceMark\");\n+    tty->print_cr(\"%s\", message.as_string());\n@@ -587,11 +599,11 @@\n-  STEP(\"setup for test unresponsive error reporting step\")\n-    if (_verbose && TestUnresponsiveErrorHandler) {\n-      \/\/ We record reporting_start_time for this test here because we\n-      \/\/ care about the time spent executing TIMEOUT_TEST_STEP and not\n-      \/\/ about the time it took us to get here.\n-      tty->print_cr(\"Recording reporting_start_time for TestUnresponsiveErrorHandler.\");\n-      record_reporting_start_time();\n-    }\n-\n-  #define TIMEOUT_TEST_STEP STEP(\"test unresponsive error reporting step\") \\\n-    if (_verbose && TestUnresponsiveErrorHandler) { os::infinite_sleep(); }\n+  STEP_IF(\"setup for test unresponsive error reporting step\",\n+      _verbose && TestUnresponsiveErrorHandler)\n+    \/\/ We record reporting_start_time for this test here because we\n+    \/\/ care about the time spent executing TIMEOUT_TEST_STEP and not\n+    \/\/ about the time it took us to get here.\n+    tty->print_cr(\"Recording reporting_start_time for TestUnresponsiveErrorHandler.\");\n+    record_reporting_start_time();\n+\n+  #define TIMEOUT_TEST_STEP STEP_IF(\"test unresponsive error reporting step\", \\\n+      _verbose && TestUnresponsiveErrorHandler) \\\n+    os::infinite_sleep();\n@@ -604,1 +616,1 @@\n-  STEP(\"test safefetch in error handler\")\n+  STEP_IF(\"test safefetch in error handler\", _verbose && TestSafeFetchInErrorHandler)\n@@ -607,11 +619,9 @@\n-    if (_verbose && TestSafeFetchInErrorHandler) {\n-      st->print_cr(\"Will test SafeFetch...\");\n-      int* const invalid_pointer = (int*)segfault_address;\n-      const int x = 0x76543210;\n-      int i1 = SafeFetch32(invalid_pointer, x);\n-      int i2 = SafeFetch32(invalid_pointer, x);\n-      if (i1 == x && i2 == x) {\n-        st->print_cr(\"SafeFetch OK.\"); \/\/ Correctly deflected and returned default pattern\n-      } else {\n-        st->print_cr(\"??\");\n-      }\n+    st->print_cr(\"Will test SafeFetch...\");\n+    int* const invalid_pointer = (int*)segfault_address;\n+    const int x = 0x76543210;\n+    int i1 = SafeFetch32(invalid_pointer, x);\n+    int i2 = SafeFetch32(invalid_pointer, x);\n+    if (i1 == x && i2 == x) {\n+      st->print_cr(\"SafeFetch OK.\"); \/\/ Correctly deflected and returned default pattern\n+    } else {\n+      st->print_cr(\"??\");\n@@ -622,35 +632,34 @@\n-\n-     switch(static_cast<unsigned int>(_id)) {\n-       case OOM_MALLOC_ERROR:\n-       case OOM_MMAP_ERROR:\n-       case OOM_MPROTECT_ERROR:\n-         if (_size) {\n-           st->print(\"# Native memory allocation \");\n-           st->print((_id == (int)OOM_MALLOC_ERROR) ? \"(malloc) failed to allocate \" :\n-                     (_id == (int)OOM_MMAP_ERROR)   ? \"(mmap) failed to map \" :\n-                                                      \"(mprotect) failed to protect \");\n-           jio_snprintf(buf, sizeof(buf), SIZE_FORMAT, _size);\n-           st->print(\"%s\", buf);\n-           st->print(\" bytes\");\n-           if (strlen(_detail_msg) > 0) {\n-             st->print(\" for \");\n-             st->print(\"%s\", _detail_msg);\n-           }\n-           st->cr();\n-         } else {\n-           if (strlen(_detail_msg) > 0) {\n-             st->print(\"# \");\n-             st->print_cr(\"%s\", _detail_msg);\n-           }\n-         }\n-         \/\/ In error file give some solutions\n-         if (_verbose) {\n-           print_oom_reasons(st);\n-         } else {\n-           return;  \/\/ that's enough for the screen\n-         }\n-         break;\n-       case INTERNAL_ERROR:\n-       default:\n-         break;\n-     }\n+    switch(static_cast<unsigned int>(_id)) {\n+      case OOM_MALLOC_ERROR:\n+      case OOM_MMAP_ERROR:\n+      case OOM_MPROTECT_ERROR:\n+        if (_size) {\n+          st->print(\"# Native memory allocation \");\n+          st->print((_id == (int)OOM_MALLOC_ERROR) ? \"(malloc) failed to allocate \" :\n+                    (_id == (int)OOM_MMAP_ERROR)   ? \"(mmap) failed to map \" :\n+                                                    \"(mprotect) failed to protect \");\n+          jio_snprintf(buf, sizeof(buf), SIZE_FORMAT, _size);\n+          st->print(\"%s\", buf);\n+          st->print(\" bytes\");\n+          if (strlen(_detail_msg) > 0) {\n+            st->print(\" for \");\n+            st->print(\"%s\", _detail_msg);\n+          }\n+          st->cr();\n+        } else {\n+          if (strlen(_detail_msg) > 0) {\n+            st->print(\"# \");\n+            st->print_cr(\"%s\", _detail_msg);\n+          }\n+        }\n+        \/\/ In error file give some solutions\n+        if (_verbose) {\n+          print_oom_reasons(st);\n+        } else {\n+          return;  \/\/ that's enough for the screen\n+        }\n+        break;\n+      case INTERNAL_ERROR:\n+      default:\n+        break;\n+    }\n@@ -659,18 +668,17 @@\n-\n-     st->print_cr(\"#\");\n-     st->print(\"#  \");\n-     \/\/ Is it an OS exception\/signal?\n-     if (os::exception_name(_id, buf, sizeof(buf))) {\n-       st->print(\"%s\", buf);\n-       st->print(\" (0x%x)\", _id);                \/\/ signal number\n-       st->print(\" at pc=\" PTR_FORMAT, p2i(_pc));\n-       if (_siginfo != NULL && os::signal_sent_by_kill(_siginfo)) {\n-         st->print(\" (sent by kill)\");\n-       }\n-     } else {\n-       if (should_report_bug(_id)) {\n-         st->print(\"Internal Error\");\n-       } else {\n-         st->print(\"Out of Memory Error\");\n-       }\n-       if (_filename != NULL && _lineno > 0) {\n+    st->print_cr(\"#\");\n+    st->print(\"#  \");\n+    \/\/ Is it an OS exception\/signal?\n+    if (os::exception_name(_id, buf, sizeof(buf))) {\n+      st->print(\"%s\", buf);\n+      st->print(\" (0x%x)\", _id);                \/\/ signal number\n+      st->print(\" at pc=\" PTR_FORMAT, p2i(_pc));\n+      if (_siginfo != NULL && os::signal_sent_by_kill(_siginfo)) {\n+        st->print(\" (sent by kill)\");\n+      }\n+    } else {\n+      if (should_report_bug(_id)) {\n+        st->print(\"Internal Error\");\n+      } else {\n+        st->print(\"Out of Memory Error\");\n+      }\n+      if (_filename != NULL && _lineno > 0) {\n@@ -678,2 +686,2 @@\n-         \/\/ In product mode chop off pathname\n-         const char *file = get_filename_only();\n+        \/\/ In product mode chop off pathname\n+        const char *file = get_filename_only();\n@@ -681,1 +689,1 @@\n-         const char *file = _filename;\n+        const char *file = _filename;\n@@ -683,5 +691,5 @@\n-         st->print(\" (%s:%d)\", file, _lineno);\n-       } else {\n-         st->print(\" (0x%x)\", _id);\n-       }\n-     }\n+        st->print(\" (%s:%d)\", file, _lineno);\n+      } else {\n+        st->print(\" (0x%x)\", _id);\n+      }\n+    }\n@@ -690,0 +698,4 @@\n+    \/\/ process id, thread id\n+    st->print(\", pid=%d\", os::current_process_id());\n+    st->print(\", tid=\" UINTX_FORMAT, os::current_thread_id());\n+    st->cr();\n@@ -691,15 +703,7 @@\n-     \/\/ process id, thread id\n-     st->print(\", pid=%d\", os::current_process_id());\n-     st->print(\", tid=\" UINTX_FORMAT, os::current_thread_id());\n-     st->cr();\n-\n-  STEP(\"printing error message\")\n-\n-     if (should_report_bug(_id)) {  \/\/ already printed the message.\n-       \/\/ error message\n-       if (strlen(_detail_msg) > 0) {\n-         st->print_cr(\"#  %s: %s\", _message ? _message : \"Error\", _detail_msg);\n-       } else if (_message) {\n-         st->print_cr(\"#  Error: %s\", _message);\n-       }\n-     }\n+  STEP_IF(\"printing error message\", should_report_bug(_id)) \/\/ already printed the message.\n+    \/\/ error message\n+    if (strlen(_detail_msg) > 0) {\n+      st->print_cr(\"#  %s: %s\", _message ? _message : \"Error\", _detail_msg);\n+    } else if (_message) {\n+      st->print_cr(\"#  Error: %s\", _message);\n+    }\n@@ -708,0 +712,1 @@\n+    report_vm_version(st, buf, sizeof(buf));\n@@ -709,13 +714,8 @@\n-     report_vm_version(st, buf, sizeof(buf));\n-\n-  STEP(\"printing problematic frame\")\n-\n-     \/\/ Print current frame if we have a context (i.e. it's a crash)\n-     if (_context) {\n-       st->print_cr(\"# Problematic frame:\");\n-       st->print(\"# \");\n-       frame fr = os::fetch_frame_from_context(_context);\n-       fr.print_on_error(st, buf, sizeof(buf));\n-       st->cr();\n-       st->print_cr(\"#\");\n-     }\n+  STEP_IF(\"printing problematic frame\", _context != nullptr)\n+    \/\/ Print current frame if we have a context (i.e. it's a crash)\n+    st->print_cr(\"# Problematic frame:\");\n+    st->print(\"# \");\n+    frame fr = os::fetch_frame_from_context(_context);\n+    fr.print_on_error(st, buf, sizeof(buf));\n+    st->cr();\n+    st->print_cr(\"#\");\n@@ -740,55 +740,2 @@\n-  STEP(\"printing bug submit message\")\n-\n-     if (should_submit_bug_report(_id) && _verbose) {\n-       print_bug_submit_message(st, _thread);\n-     }\n-\n-  STEP(\"printing summary\")\n-\n-     if (_verbose) {\n-       st->cr();\n-       st->print_cr(\"---------------  S U M M A R Y ------------\");\n-       st->cr();\n-     }\n-\n-  STEP(\"printing VM option summary\")\n-\n-     if (_verbose) {\n-       \/\/ VM options\n-       Arguments::print_summary_on(st);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing summary machine and OS info\")\n-\n-     if (_verbose) {\n-       os::print_summary_info(st, buf, sizeof(buf));\n-     }\n-\n-  STEP(\"printing date and time\")\n-\n-     if (_verbose) {\n-       os::print_date_and_time(st, buf, sizeof(buf));\n-     }\n-\n-  STEP(\"printing thread\")\n-\n-     if (_verbose) {\n-       st->cr();\n-       st->print_cr(\"---------------  T H R E A D  ---------------\");\n-       st->cr();\n-     }\n-\n-  STEP(\"printing current thread\")\n-\n-     \/\/ current thread\n-     if (_verbose) {\n-       if (_thread) {\n-         st->print(\"Current thread (\" PTR_FORMAT \"):  \", p2i(_thread));\n-         _thread->print_on_error(st, buf, sizeof(buf));\n-         st->cr();\n-       } else {\n-         st->print_cr(\"Current thread is native thread\");\n-       }\n-       st->cr();\n-     }\n+  STEP_IF(\"printing bug submit message\", should_submit_bug_report(_id) && _verbose)\n+    print_bug_submit_message(st, _thread);\n@@ -796,19 +743,4 @@\n-  STEP(\"printing current compile task\")\n-\n-     if (_verbose && _thread && _thread->is_Compiler_thread()) {\n-        CompilerThread* t = (CompilerThread*)_thread;\n-        if (t->task()) {\n-           st->cr();\n-           st->print_cr(\"Current CompileTask:\");\n-           t->task()->print_line_on_error(st, buf, sizeof(buf));\n-           st->cr();\n-        }\n-     }\n-\n-  STEP(\"printing stack bounds\")\n-\n-     if (_verbose) {\n-       st->print(\"Stack: \");\n-\n-       address stack_top;\n-       size_t stack_size;\n+  STEP_IF(\"printing summary\", _verbose)\n+    st->cr();\n+    st->print_cr(\"---------------  S U M M A R Y ------------\");\n+    st->cr();\n@@ -816,7 +748,4 @@\n-       if (_thread) {\n-          stack_top = _thread->stack_base();\n-          stack_size = _thread->stack_size();\n-       } else {\n-          stack_top = os::current_stack_base();\n-          stack_size = os::current_stack_size();\n-       }\n+  STEP_IF(\"printing VM option summary\", _verbose)\n+    \/\/ VM options\n+    Arguments::print_summary_on(st);\n+    st->cr();\n@@ -824,2 +753,2 @@\n-       address stack_bottom = stack_top - stack_size;\n-       st->print(\"[\" PTR_FORMAT \",\" PTR_FORMAT \"]\", p2i(stack_bottom), p2i(stack_top));\n+  STEP_IF(\"printing summary machine and OS info\", _verbose)\n+    os::print_summary_info(st, buf, sizeof(buf));\n@@ -827,2 +756,2 @@\n-       frame fr = _context ? os::fetch_frame_from_context(_context)\n-                           : os::current_frame();\n+  STEP_IF(\"printing date and time\", _verbose)\n+    os::print_date_and_time(st, buf, sizeof(buf));\n@@ -830,5 +759,4 @@\n-       if (fr.sp()) {\n-         st->print(\",  sp=\" PTR_FORMAT, p2i(fr.sp()));\n-         size_t free_stack_size = pointer_delta(fr.sp(), stack_bottom, 1024);\n-         st->print(\",  free space=\" SIZE_FORMAT \"k\", free_stack_size);\n-       }\n+  STEP_IF(\"printing thread\", _verbose)\n+    st->cr();\n+    st->print_cr(\"---------------  T H R E A D  ---------------\");\n+    st->cr();\n@@ -836,2 +764,10 @@\n-       st->cr();\n-     }\n+  STEP_IF(\"printing current thread\", _verbose)\n+    \/\/ current thread\n+    if (_thread) {\n+      st->print(\"Current thread (\" PTR_FORMAT \"):  \", p2i(_thread));\n+      _thread->print_on_error(st, buf, sizeof(buf));\n+      st->cr();\n+    } else {\n+      st->print_cr(\"Current thread is native thread\");\n+    }\n+    st->cr();\n@@ -839,1 +775,9 @@\n-  STEP(\"printing native stack (with source info)\")\n+  STEP_IF(\"printing current compile task\",\n+      _verbose && _thread != nullptr && _thread->is_Compiler_thread())\n+    CompilerThread* t = (CompilerThread*)_thread;\n+    if (t->task()) {\n+        st->cr();\n+        st->print_cr(\"Current CompileTask:\");\n+        t->task()->print_line_on_error(st, buf, sizeof(buf));\n+        st->cr();\n+    }\n@@ -841,7 +785,2 @@\n-   if (_verbose) {\n-     if (os::platform_print_native_stack(st, _context, buf, sizeof(buf))) {\n-       \/\/ We have printed the native stack in platform-specific code\n-       \/\/ Windows\/x64 needs special handling.\n-     } else {\n-       frame fr = _context ? os::fetch_frame_from_context(_context)\n-                           : os::current_frame();\n+  STEP_IF(\"printing stack bounds\", _verbose)\n+    st->print(\"Stack: \");\n@@ -849,5 +788,2 @@\n-       print_native_stack(st, fr, _thread, true, buf, sizeof(buf));\n-       _print_native_stack_used = true;\n-     }\n-     print_native_stack_succeeded = true;\n-   }\n+    address stack_top;\n+    size_t stack_size;\n@@ -855,1 +791,7 @@\n-  STEP(\"retry printing native stack (no source info)\")\n+    if (_thread) {\n+      stack_top = _thread->stack_base();\n+      stack_size = _thread->stack_size();\n+    } else {\n+      stack_top = os::current_stack_base();\n+      stack_size = os::current_stack_size();\n+    }\n@@ -857,7 +799,2 @@\n-   if (_verbose && !print_native_stack_succeeded) {\n-     st->cr();\n-     st->print_cr(\"Retrying call stack printing without source information...\");\n-     frame fr = _context ? os::fetch_frame_from_context(_context) : os::current_frame();\n-     print_native_stack(st, fr, _thread, false, buf, sizeof(buf));\n-     _print_native_stack_used = true;\n-   }\n+    address stack_bottom = stack_top - stack_size;\n+    st->print(\"[\" PTR_FORMAT \",\" PTR_FORMAT \"]\", p2i(stack_bottom), p2i(stack_top));\n@@ -865,1 +802,2 @@\n-  STEP(\"printing Java stack\")\n+    frame fr = _context ? os::fetch_frame_from_context(_context)\n+                        : os::current_frame();\n@@ -867,3 +805,5 @@\n-     if (_verbose && _thread && _thread->is_Java_thread()) {\n-       print_stack_trace(st, JavaThread::cast(_thread), buf, sizeof(buf));\n-     }\n+    if (fr.sp()) {\n+      st->print(\",  sp=\" PTR_FORMAT, p2i(fr.sp()));\n+      size_t free_stack_size = pointer_delta(fr.sp(), stack_bottom, 1024);\n+      st->print(\",  free space=\" SIZE_FORMAT \"k\", free_stack_size);\n+    }\n@@ -871,1 +811,1 @@\n-  STEP(\"printing target Java thread stack\")\n+    st->cr();\n@@ -873,9 +813,7 @@\n-     \/\/ printing Java thread stack trace if it is involved in GC crash\n-     if (_verbose && _thread && (_thread->is_Named_thread())) {\n-       Thread* thread = ((NamedThread *)_thread)->processed_thread();\n-       if (thread != NULL && thread->is_Java_thread()) {\n-         JavaThread* jt = JavaThread::cast(thread);\n-         st->print_cr(\"JavaThread \" PTR_FORMAT \" (nid = %d) was being processed\", p2i(jt), jt->osthread()->thread_id());\n-         print_stack_trace(st, jt, buf, sizeof(buf), true);\n-       }\n-     }\n+  STEP_IF(\"printing native stack (with source info)\", _verbose)\n+    if (os::platform_print_native_stack(st, _context, buf, sizeof(buf))) {\n+      \/\/ We have printed the native stack in platform-specific code\n+      \/\/ Windows\/x64 needs special handling.\n+    } else {\n+      frame fr = _context ? os::fetch_frame_from_context(_context)\n+                          : os::current_frame();\n@@ -883,1 +821,4 @@\n-  STEP(\"printing siginfo\")\n+      print_native_stack(st, fr, _thread, true, -1, buf, sizeof(buf));\n+      _print_native_stack_used = true;\n+    }\n+    print_native_stack_succeeded = true;\n@@ -885,6 +826,11 @@\n-     \/\/ signal no, signal code, address that caused the fault\n-     if (_verbose && _siginfo) {\n-       st->cr();\n-       os::print_siginfo(st, _siginfo);\n-       st->cr();\n-     }\n+  STEP_IF(\"retry printing native stack (no source info)\", _verbose && !print_native_stack_succeeded)\n+    st->cr();\n+    st->print_cr(\"Retrying call stack printing without source information...\");\n+    frame fr = _context ? os::fetch_frame_from_context(_context) : os::current_frame();\n+    print_native_stack(st, fr, _thread, false, -1, buf, sizeof(buf));\n+    _print_native_stack_used = true;\n+\n+  STEP_IF(\"printing Java stack\", _verbose && _thread && _thread->is_Java_thread())\n+    if (_verbose && _thread && _thread->is_Java_thread()) {\n+      print_stack_trace(st, JavaThread::cast(_thread), buf, sizeof(buf));\n+    }\n@@ -892,1 +838,9 @@\n-  STEP(\"CDS archive access warning\")\n+  STEP_IF(\"printing target Java thread stack\",\n+      _verbose && _thread != nullptr && (_thread->is_Named_thread()))\n+    \/\/ printing Java thread stack trace if it is involved in GC crash\n+    Thread* thread = ((NamedThread *)_thread)->processed_thread();\n+    if (thread != NULL && thread->is_Java_thread()) {\n+      JavaThread* jt = JavaThread::cast(thread);\n+      st->print_cr(\"JavaThread \" PTR_FORMAT \" (nid = %d) was being processed\", p2i(jt), jt->osthread()->thread_id());\n+      print_stack_trace(st, jt, buf, sizeof(buf), true);\n+    }\n@@ -894,5 +848,5 @@\n-     \/\/ Print an explicit hint if we crashed on access to the CDS archive.\n-     if (_verbose && _siginfo) {\n-       check_failing_cds_access(st, _siginfo);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing siginfo\", _verbose && _siginfo != nullptr)\n+    \/\/ signal no, signal code, address that caused the fault\n+    st->cr();\n+    os::print_siginfo(st, _siginfo);\n+    st->cr();\n@@ -900,1 +854,4 @@\n-  STEP(\"printing registers\")\n+  STEP_IF(\"CDS archive access warning\", _verbose && _siginfo != nullptr)\n+    \/\/ Print an explicit hint if we crashed on access to the CDS archive.\n+    check_failing_cds_access(st, _siginfo);\n+    st->cr();\n@@ -902,5 +859,4 @@\n-     \/\/ printing registers\n-     if (_verbose && _context) {\n-       os::print_context(st, _context);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing registers\", _verbose && _context != nullptr)\n+    \/\/ printing registers\n+    os::print_context(st, _context);\n+    st->cr();\n@@ -908,1 +864,6 @@\n-  STEP(\"printing register info\")\n+  STEP_IF(\"printing register info\",\n+      _verbose && _context != nullptr && _thread != nullptr && Universe::is_fully_initialized())\n+    \/\/ decode register contents if possible\n+    ResourceMark rm(_thread);\n+    os::print_register_info(st, _context);\n+    st->cr();\n@@ -910,6 +871,0 @@\n-     \/\/ decode register contents if possible\n-     if (_verbose && _context && _thread && Universe::is_fully_initialized()) {\n-       ResourceMark rm(_thread);\n-       os::print_register_info(st, _context);\n-       st->cr();\n-     }\n@@ -919,5 +874,4 @@\n-     \/\/ printing top of stack, instructions near pc\n-     if (_verbose && _context) {\n-       os::print_tos_pc(st, _context);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing top of stack, instructions near pc\", _verbose && _context)\n+    \/\/ printing top of stack, instructions near pc\n+    os::print_tos_pc(st, _context);\n+    st->cr();\n@@ -925,18 +879,16 @@\n-  STEP(\"inspecting top of stack\")\n-\n-     \/\/ decode stack contents if possible\n-     if (_verbose && _context && _thread && Universe::is_fully_initialized()) {\n-       frame fr = os::fetch_frame_from_context(_context);\n-       const int slots = 8;\n-       const intptr_t *start = fr.sp();\n-       const intptr_t *end = start + slots;\n-       if (is_aligned(start, sizeof(intptr_t)) && os::is_readable_range(start, end)) {\n-         st->print_cr(\"Stack slot to memory mapping:\");\n-         for (int i = 0; i < slots; ++i) {\n-           st->print(\"stack at sp + %d slots: \", i);\n-           ResourceMark rm(_thread);\n-           os::print_location(st, *(start + i));\n-         }\n-       }\n-       st->cr();\n-     }\n+  STEP_IF(\"inspecting top of stack\",\n+      _verbose && _context != nullptr && _thread != nullptr && Universe::is_fully_initialized())\n+    \/\/ decode stack contents if possible\n+    frame fr = os::fetch_frame_from_context(_context);\n+    const int slots = 8;\n+    const intptr_t *start = fr.sp();\n+    const intptr_t *end = start + slots;\n+    if (is_aligned(start, sizeof(intptr_t)) && os::is_readable_range(start, end)) {\n+      st->print_cr(\"Stack slot to memory mapping:\");\n+      for (int i = 0; i < slots; ++i) {\n+        st->print(\"stack at sp + %d slots: \", i);\n+        ResourceMark rm(_thread);\n+        os::print_location(st, *(start + i));\n+      }\n+    }\n+    st->cr();\n@@ -946,53 +898,17 @@\n-     if (_verbose) {\n-       const int printed_capacity = max_error_log_print_code;\n-       address printed[printed_capacity];\n-       printed[0] = nullptr;\n-       int printed_len = 0;\n-       \/\/ Even though ErrorLogPrintCodeLimit is ranged checked\n-       \/\/ during argument parsing, there's no way to prevent it\n-       \/\/ subsequently (i.e., after parsing) being set to a\n-       \/\/ value outside the range.\n-       int limit = MIN2(ErrorLogPrintCodeLimit, printed_capacity);\n-       if (limit > 0) {\n-         \/\/ Scan the native stack\n-         if (!_print_native_stack_used) {\n-           \/\/ Only try to print code of the crashing frame since\n-           \/\/ the native stack cannot be walked with next_frame.\n-           if (print_code(st, _thread, _pc, true, printed, printed_capacity)) {\n-             printed_len++;\n-           }\n-         } else {\n-           frame fr = _context ? os::fetch_frame_from_context(_context)\n-                               : os::current_frame();\n-           while (printed_len < limit && fr.pc() != nullptr) {\n-             if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n-               printed_len++;\n-             }\n-             fr = next_frame(fr, _thread);\n-           }\n-         }\n-\n-         \/\/ Scan the Java stack\n-         if (_thread != nullptr && _thread->is_Java_thread()) {\n-           JavaThread* jt = JavaThread::cast(_thread);\n-           if (jt->has_last_Java_frame()) {\n-             for (StackFrameStream sfs(jt, true \/* update *\/, true \/* process_frames *\/); printed_len < limit && !sfs.is_done(); sfs.next()) {\n-               address pc = sfs.current()->pc();\n-               if (print_code(st, _thread, pc, pc == _pc, printed, printed_capacity)) {\n-                 printed_len++;\n-               }\n-             }\n-           }\n-         }\n-       }\n-     }\n-\n-  STEP(\"printing VM operation\")\n-\n-     if (_verbose && _thread && _thread->is_VM_thread()) {\n-        VMThread* t = (VMThread*)_thread;\n-        VM_Operation* op = t->vm_operation();\n-        if (op) {\n-          op->print_on_error(st);\n-          st->cr();\n-          st->cr();\n+  STEP_IF(\"printing code blobs if possible\", _verbose)\n+    const int printed_capacity = max_error_log_print_code;\n+    address printed[printed_capacity];\n+    printed[0] = nullptr;\n+    int printed_len = 0;\n+    \/\/ Even though ErrorLogPrintCodeLimit is ranged checked\n+    \/\/ during argument parsing, there's no way to prevent it\n+    \/\/ subsequently (i.e., after parsing) being set to a\n+    \/\/ value outside the range.\n+    int limit = MIN2(ErrorLogPrintCodeLimit, printed_capacity);\n+    if (limit > 0) {\n+      \/\/ Scan the native stack\n+      if (!_print_native_stack_used) {\n+        \/\/ Only try to print code of the crashing frame since\n+        \/\/ the native stack cannot be walked with next_frame.\n+        if (print_code(st, _thread, _pc, true, printed, printed_capacity)) {\n+          printed_len++;\n@@ -1000,11 +916,10 @@\n-     }\n-\n-  STEP(\"printing process\")\n-\n-     if (_verbose) {\n-       st->cr();\n-       st->print_cr(\"---------------  P R O C E S S  ---------------\");\n-       st->cr();\n-     }\n-\n-  STEP(\"printing user info\")\n+      } else {\n+        frame fr = _context ? os::fetch_frame_from_context(_context)\n+                            : os::current_frame();\n+        while (printed_len < limit && fr.pc() != nullptr) {\n+          if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n+            printed_len++;\n+          }\n+          fr = next_frame(fr, _thread);\n+        }\n+      }\n@@ -1012,3 +927,13 @@\n-     if (ExtensiveErrorReports && _verbose) {\n-       os::print_user_info(st);\n-     }\n+      \/\/ Scan the Java stack\n+      if (_thread != nullptr && _thread->is_Java_thread()) {\n+        JavaThread* jt = JavaThread::cast(_thread);\n+        if (jt->has_last_Java_frame()) {\n+          for (StackFrameStream sfs(jt, true \/* update *\/, true \/* process_frames *\/); printed_len < limit && !sfs.is_done(); sfs.next()) {\n+            address pc = sfs.current()->pc();\n+            if (print_code(st, _thread, pc, pc == _pc, printed, printed_capacity)) {\n+              printed_len++;\n+            }\n+          }\n+        }\n+      }\n+    }\n@@ -1016,1 +941,8 @@\n-  STEP(\"printing all threads\")\n+  STEP_IF(\"printing VM operation\", _verbose && _thread != nullptr && _thread->is_VM_thread())\n+    VMThread* t = (VMThread*)_thread;\n+    VM_Operation* op = t->vm_operation();\n+    if (op) {\n+      op->print_on_error(st);\n+      st->cr();\n+      st->cr();\n+    }\n@@ -1018,5 +950,1 @@\n-     \/\/ all threads\n-     if (_verbose && _thread) {\n-       Threads::print_on_error(st, _thread, buf, sizeof(buf));\n-       st->cr();\n-     }\n+  STEP(\"printing process\")\n@@ -1024,1 +952,4 @@\n-  STEP(\"printing VM state\")\n+  STEP_IF(\"printing process\", _verbose)\n+    st->cr();\n+    st->print_cr(\"---------------  P R O C E S S  ---------------\");\n+    st->cr();\n@@ -1026,3 +957,2 @@\n-     if (_verbose) {\n-       \/\/ Safepoint state\n-       st->print(\"VM state: \");\n+  STEP_IF(\"printing user info\", ExtensiveErrorReports && _verbose)\n+    os::print_user_info(st);\n@@ -1030,3 +960,4 @@\n-       if (SafepointSynchronize::is_synchronizing()) st->print(\"synchronizing\");\n-       else if (SafepointSynchronize::is_at_safepoint()) st->print(\"at safepoint\");\n-       else st->print(\"not at safepoint\");\n+  STEP_IF(\"printing all threads\", _verbose && _thread)\n+    \/\/ all threads\n+    Threads::print_on_error(st, _thread, buf, sizeof(buf));\n+    st->cr();\n@@ -1034,11 +965,3 @@\n-       \/\/ Also see if error occurred during initialization or shutdown\n-       if (!Universe::is_fully_initialized()) {\n-         st->print(\" (not fully initialized)\");\n-       } else if (VM_Exit::vm_exited()) {\n-         st->print(\" (shutting down)\");\n-       } else {\n-         st->print(\" (normal execution)\");\n-       }\n-       st->cr();\n-       st->cr();\n-     }\n+  STEP_IF(\"printing VM state\", _verbose)\n+    \/\/ Safepoint state\n+    st->print(\"VM state: \");\n@@ -1046,1 +969,3 @@\n-  STEP(\"printing owned locks on error\")\n+    if (SafepointSynchronize::is_synchronizing()) st->print(\"synchronizing\");\n+    else if (SafepointSynchronize::is_at_safepoint()) st->print(\"at safepoint\");\n+    else st->print(\"not at safepoint\");\n@@ -1048,5 +973,10 @@\n-     \/\/ mutexes\/monitors that currently have an owner\n-     if (_verbose) {\n-       print_owned_locks_on_error(st);\n-       st->cr();\n-     }\n+    \/\/ Also see if error occurred during initialization or shutdown\n+    if (!Universe::is_fully_initialized()) {\n+      st->print(\" (not fully initialized)\");\n+    } else if (VM_Exit::vm_exited()) {\n+      st->print(\" (shutting down)\");\n+    } else {\n+      st->print(\" (normal execution)\");\n+    }\n+    st->cr();\n+    st->cr();\n@@ -1054,1 +984,4 @@\n-  STEP(\"printing number of OutOfMemoryError and StackOverflow exceptions\")\n+  STEP_IF(\"printing owned locks on error\", _verbose)\n+    \/\/ mutexes\/monitors that currently have an owner\n+    print_owned_locks_on_error(st);\n+    st->cr();\n@@ -1056,5 +989,5 @@\n-     if (_verbose && Exceptions::has_exception_counts()) {\n-       st->print_cr(\"OutOfMemory and StackOverflow Exception counts:\");\n-       Exceptions::print_exception_counts_on_error(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing number of OutOfMemoryError and StackOverflow exceptions\",\n+      _verbose && Exceptions::has_exception_counts())\n+    st->print_cr(\"OutOfMemory and StackOverflow Exception counts:\");\n+    Exceptions::print_exception_counts_on_error(st);\n+    st->cr();\n@@ -1063,8 +996,3 @@\n-  STEP(\"printing compressed oops mode\")\n-\n-     if (_verbose && UseCompressedOops) {\n-       CompressedOops::print_mode(st);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing compressed klass pointers mode\")\n+  STEP_IF(\"printing compressed oops mode\", _verbose && UseCompressedOops)\n+    CompressedOops::print_mode(st);\n+    st->cr();\n@@ -1072,6 +1000,5 @@\n-     if (_verbose && UseCompressedClassPointers) {\n-       CDS_ONLY(MetaspaceShared::print_on(st);)\n-       Metaspace::print_compressed_class_space(st);\n-       CompressedKlassPointers::print_mode(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing compressed klass pointers mode\", _verbose && UseCompressedClassPointers)\n+    CDS_ONLY(MetaspaceShared::print_on(st);)\n+    Metaspace::print_compressed_class_space(st);\n+    CompressedKlassPointers::print_mode(st);\n+    st->cr();\n@@ -1080,62 +1007,2 @@\n-  STEP(\"printing heap information\")\n-\n-     if (_verbose) {\n-       GCLogPrecious::print_on_error(st);\n-\n-       if (Universe::heap() != NULL) {\n-         Universe::heap()->print_on_error(st);\n-         st->cr();\n-       }\n-\n-       if (Universe::is_fully_initialized()) {\n-         st->print_cr(\"Polling page: \" PTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));\n-         st->cr();\n-       }\n-     }\n-\n-  STEP(\"printing metaspace information\")\n-\n-     if (_verbose && Universe::is_fully_initialized()) {\n-       st->print_cr(\"Metaspace:\");\n-       MetaspaceUtils::print_basic_report(st, 0);\n-     }\n-\n-  STEP(\"printing code cache information\")\n-\n-     if (_verbose && Universe::is_fully_initialized()) {\n-       \/\/ print code cache information before vm abort\n-       CodeCache::print_summary(st);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing ring buffers\")\n-\n-     if (_verbose) {\n-       Events::print_all(st);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing dynamic libraries\")\n-\n-     if (_verbose) {\n-       \/\/ dynamic libraries, or memory map\n-       os::print_dll_info(st);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing native decoder state\")\n-\n-     if (_verbose) {\n-       Decoder::print_state_on(st);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing VM options\")\n-\n-     if (_verbose) {\n-       \/\/ VM options\n-       Arguments::print_on(st);\n-       st->cr();\n-     }\n-\n-  STEP(\"printing flags\")\n+  STEP_IF(\"printing heap information\", _verbose)\n+    GCLogPrecious::print_on_error(st);\n@@ -1143,6 +1010,2 @@\n-    if (_verbose) {\n-      JVMFlag::printFlags(\n-        st,\n-        true, \/\/ with comments\n-        false, \/\/ no ranges\n-        true); \/\/ skip defaults\n+    if (Universe::heap() != NULL) {\n+      Universe::heap()->print_on_error(st);\n@@ -1152,11 +1015,2 @@\n-  STEP(\"printing warning if internal testing API used\")\n-\n-     if (WhiteBox::used()) {\n-       st->print_cr(\"Unsupported internal testing APIs have been used.\");\n-       st->cr();\n-     }\n-\n-  STEP(\"printing log configuration\")\n-    if (_verbose){\n-      st->print_cr(\"Logging:\");\n-      LogConfiguration::describe_current_configuration(st);\n+    if (Universe::is_fully_initialized()) {\n+      st->print_cr(\"Polling page: \" PTR_FORMAT, p2i(SafepointMechanism::get_polling_page()));\n@@ -1166,1 +1020,3 @@\n-  STEP(\"printing all environment variables\")\n+  STEP_IF(\"printing metaspace information\", _verbose && Universe::is_fully_initialized())\n+    st->print_cr(\"Metaspace:\");\n+    MetaspaceUtils::print_basic_report(st, 0);\n@@ -1168,4 +1024,4 @@\n-     if (_verbose) {\n-       os::print_environment_variables(st, env_list);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing code cache information\", _verbose && Universe::is_fully_initialized())\n+    \/\/ print code cache information before vm abort\n+    CodeCache::print_summary(st);\n+    st->cr();\n@@ -1173,1 +1029,3 @@\n-  STEP(\"printing locale settings\")\n+  STEP_IF(\"printing ring buffers\", _verbose)\n+    Events::print_all(st);\n+    st->cr();\n@@ -1175,4 +1033,4 @@\n-     if (_verbose) {\n-       os::print_active_locale(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing dynamic libraries\", _verbose)\n+    \/\/ dynamic libraries, or memory map\n+    os::print_dll_info(st);\n+    st->cr();\n@@ -1180,1 +1038,3 @@\n-  STEP(\"printing signal handlers\")\n+  STEP_IF(\"printing native decoder state\", _verbose)\n+    Decoder::print_state_on(st);\n+    st->cr();\n@@ -1182,4 +1042,4 @@\n-     if (_verbose) {\n-       os::print_signal_handlers(st, buf, sizeof(buf));\n-       st->cr();\n-     }\n+  STEP_IF(\"printing VM options\", _verbose)\n+    \/\/ VM options\n+    Arguments::print_on(st);\n+    st->cr();\n@@ -1187,4 +1047,7 @@\n-  STEP(\"Native Memory Tracking\")\n-     if (_verbose) {\n-       MemTracker::error_report(st);\n-     }\n+  STEP_IF(\"printing flags\", _verbose)\n+    JVMFlag::printFlags(\n+      st,\n+      true, \/\/ with comments\n+      false, \/\/ no ranges\n+      true); \/\/ skip defaults\n+    st->cr();\n@@ -1192,1 +1055,3 @@\n-  STEP(\"printing system\")\n+  STEP_IF(\"printing warning if internal testing API used\", WhiteBox::used())\n+    st->print_cr(\"Unsupported internal testing APIs have been used.\");\n+    st->cr();\n@@ -1194,5 +1059,4 @@\n-     if (_verbose) {\n-       st->cr();\n-       st->print_cr(\"---------------  S Y S T E M  ---------------\");\n-       st->cr();\n-     }\n+  STEP_IF(\"printing log configuration\", _verbose)\n+    st->print_cr(\"Logging:\");\n+    LogConfiguration::describe_current_configuration(st);\n+    st->cr();\n@@ -1200,1 +1064,3 @@\n-  STEP(\"printing OS information\")\n+  STEP_IF(\"printing all environment variables\", _verbose)\n+    os::print_environment_variables(st, env_list);\n+    st->cr();\n@@ -1202,4 +1068,3 @@\n-     if (_verbose) {\n-       os::print_os_info(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing locale settings\", _verbose)\n+    os::print_active_locale(st);\n+    st->cr();\n@@ -1207,5 +1072,3 @@\n-  STEP(\"printing CPU info\")\n-     if (_verbose) {\n-       os::print_cpu_info(st, buf, sizeof(buf));\n-       st->cr();\n-     }\n+  STEP_IF(\"printing signal handlers\", _verbose)\n+    os::print_signal_handlers(st, buf, sizeof(buf));\n+    st->cr();\n@@ -1213,1 +1076,2 @@\n-  STEP(\"printing memory info\")\n+  STEP_IF(\"Native Memory Tracking\", _verbose)\n+    MemTracker::error_report(st);\n@@ -1215,4 +1079,4 @@\n-     if (_verbose) {\n-       os::print_memory_info(st);\n-       st->cr();\n-     }\n+  STEP_IF(\"printing system\", _verbose)\n+    st->cr();\n+    st->print_cr(\"---------------  S Y S T E M  ---------------\");\n+    st->cr();\n@@ -1220,1 +1084,3 @@\n-  STEP(\"printing internal vm info\")\n+  STEP_IF(\"printing OS information\", _verbose)\n+    os::print_os_info(st);\n+    st->cr();\n@@ -1222,4 +1088,3 @@\n-     if (_verbose) {\n-       st->print_cr(\"vm_info: %s\", VM_Version::internal_vm_info_string());\n-       st->cr();\n-     }\n+  STEP_IF(\"printing CPU info\", _verbose)\n+    os::print_cpu_info(st, buf, sizeof(buf));\n+    st->cr();\n@@ -1227,2 +1092,3 @@\n-  \/\/ print a defined marker to show that error handling finished correctly.\n-  STEP(\"printing end marker\")\n+  STEP_IF(\"printing memory info\", _verbose)\n+    os::print_memory_info(st);\n+    st->cr();\n@@ -1230,3 +1096,7 @@\n-     if (_verbose) {\n-       st->print_cr(\"END.\");\n-     }\n+  STEP_IF(\"printing internal vm info\", _verbose)\n+    st->print_cr(\"vm_info: %s\", VM_Version::internal_vm_info_string());\n+    st->cr();\n+\n+  \/\/ print a defined marker to show that error handling finished correctly.\n+  STEP_IF(\"printing end marker\", _verbose)\n+    st->print_cr(\"END.\");\n@@ -1237,0 +1107,1 @@\n+# undef STEP_IF\n@@ -1633,2 +1504,5 @@\n-        \/\/ Crash or assert during error reporting. Lets continue reporting with the next step.\n-        stringStream ss(buffer, sizeof(buffer));\n+        \/\/ A secondary error happened. Print brief information, but take care, since crashing\n+        \/\/ here would just recurse endlessly.\n+        \/\/ Any information (signal, context, siginfo etc) printed here should use the function\n+        \/\/ arguments, not the information stored in *this, since those describe the primary crash.\n+        static char tmp[256]; \/\/ cannot use global scratch buffer\n@@ -1637,1 +1511,1 @@\n-        ss.print(\"[error occurred during error reporting (%s), id 0x%x\",\n+        st->print(\"[error occurred during error reporting (%s), id 0x%x\",\n@@ -1639,3 +1513,2 @@\n-        char signal_name[64];\n-        if (os::exception_name(id, signal_name, sizeof(signal_name))) {\n-          ss.print(\", %s (0x%x) at pc=\" PTR_FORMAT, signal_name, id, p2i(pc));\n+        if (os::exception_name(id, tmp, sizeof(tmp))) {\n+          st->print(\", %s (0x%x) at pc=\" PTR_FORMAT, tmp, id, p2i(pc));\n@@ -1644,1 +1517,1 @@\n-            ss.print(\", Internal Error (%s:%d)\",\n+            st->print(\", Internal Error (%s:%d)\",\n@@ -1647,1 +1520,1 @@\n-            ss.print(\", Out of Memory Error (%s:%d)\",\n+            st->print(\", Out of Memory Error (%s:%d)\",\n@@ -1651,3 +1524,23 @@\n-        ss.print(\"]\");\n-        st->print_raw_cr(buffer);\n-        st->cr();\n+        st->print_cr(\"]\");\n+        if (ErrorLogSecondaryErrorDetails) {\n+          static bool recursed = false;\n+          if (!recursed) {\n+            recursed = true;\n+            \/\/ Print even more information for secondary errors. This may generate a lot of output\n+            \/\/ and possibly disturb error reporting, therefore its optional and only available in debug builds.\n+            if (siginfo != nullptr) {\n+              st->print(\"[\");\n+              os::print_siginfo(st, siginfo);\n+              st->print_cr(\"]\");\n+            }\n+            st->print(\"[stack: \");\n+            frame fr = context ? os::fetch_frame_from_context(context) : os::current_frame();\n+            \/\/ Subsequent secondary errors build up stack; to avoid flooding the hs-err file with irrelevant\n+            \/\/ call stacks, limit the stack we print here (we are only interested in what happened before the\n+            \/\/ last assert\/fault).\n+            const int max_stack_size = 15;\n+            print_native_stack(st, fr, _thread, true, max_stack_size, tmp, sizeof(tmp));\n+            st->print_cr(\"]\");\n+          } \/\/ !recursed\n+          recursed = false; \/\/ Note: reset outside !recursed\n+        }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":470,"deletions":577,"binary":false,"changes":1047,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_flags\", Integer.class, \"u2\");\n+    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_status._flags\", Integer.class, \"u2\");\n@@ -123,0 +123,1 @@\n+    final int fieldInfoConstantValueIndexOffset = getConstant(\"FieldInfo::initval_index_offset\", Integer.class);\n@@ -143,2 +144,2 @@\n-    final int jvmMiscFlagsHasDefaultMethods = getConstant(\"InstanceKlass::_misc_has_nonstatic_concrete_methods\", Integer.class);\n-    final int jvmMiscFlagsDeclaresDefaultMethods = getConstant(\"InstanceKlass::_misc_declares_nonstatic_concrete_methods\", Integer.class);\n+    final int jvmMiscFlagsHasDefaultMethods = getConstant(\"InstanceKlassMiscStatus::_misc_has_nonstatic_concrete_methods\", Integer.class);\n+    final int jvmMiscFlagsDeclaresDefaultMethods = getConstant(\"InstanceKlassMiscStatus::_misc_declares_nonstatic_concrete_methods\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-compiler\/jvmci\/compilerToVM\/GetFlagValueTest.java 8204459 generic-all\n-compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/NativeCallTest.java 8262901 macosx-aarch64\n-compiler\/tiered\/LevelTransitionTest.java 8067651 generic-all\n@@ -56,11 +53,11 @@\n-compiler\/rtm\/locking\/TestRTMAbortRatio.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMAfterNonRTMDeopt.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMDeoptOnHighAbortRatio.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMLockingCalculationDelay.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestUseRTMDeopt.java 8183263 generic-x64\n-compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64\n-compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64\n+compiler\/rtm\/locking\/TestRTMAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMAfterNonRTMDeopt.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMDeoptOnHighAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMDeoptOnLowAbortRatio.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMLockingCalculationDelay.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMLockingThreshold.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMDeopt.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/locking\/TestUseRTMXendForLockBusy.java 8183263 generic-x64,generic-i586\n+compiler\/rtm\/print\/TestPrintPreciseRTMLockingStatistics.java 8183263 generic-x64,generic-i586\n@@ -84,1 +81,0 @@\n-gc\/metaspace\/CompressedClassSpaceSizeInJmapHeap.java 8241293 macosx-x64\n@@ -101,0 +97,3 @@\n+runtime\/vthread\/RedefineClass.java 8297286 generic-all\n+runtime\/vthread\/TestObjectAllocationSampleEvent.java 8297286 generic-all\n+runtime\/StackGuardPages\/TestStackGuardPages.java 8293452 linux-all\n@@ -117,7 +116,8 @@\n-serviceability\/sa\/ClhsdbCDSCore.java 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/ClhsdbPmap.java#core 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/ClhsdbPstack.java#core 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/TestJmapCore.java 8269982,8267433 macosx-aarch64,macosx-x64\n-serviceability\/sa\/TestJmapCoreMetaspace.java 8269982,8267433 macosx-aarch64,macosx-x64\n+serviceability\/sa\/ClhsdbCDSCore.java 8294316,8267433 macosx-x64\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-core 8294316,8267433 macosx-x64\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core 8294316,8267433 macosx-x64\n+serviceability\/sa\/ClhsdbPmap.java#core 8294316,8267433 macosx-x64\n+serviceability\/sa\/ClhsdbPstack.java#core 8294316,8267433 macosx-x64\n+serviceability\/sa\/TestJmapCore.java 8294316,8267433 macosx-x64\n+serviceability\/sa\/TestJmapCoreMetaspace.java 8294316,8267433 macosx-x64\n+\n@@ -186,0 +186,1 @@\n+vmTestbase\/nsk\/jvmti\/InterruptThread\/intrpthrd003\/TestDescription.java 8288911 macosx-x64\n@@ -199,0 +200,6 @@\n+\n+vmTestbase\/nsk\/stress\/except\/except012.java 8297977 generic-all\n+vmTestbase\/nsk\/stress\/strace\/strace002.java 8288912 macosx-x64,windows-x64\n+vmTestbase\/nsk\/stress\/strace\/strace003.java 8297824 macosx-x64,windows-x64\n+vmTestbase\/nsk\/stress\/strace\/strace004.java 8297824 macosx-x64,windows-x64\n+vmTestbase\/nsk\/monitoring\/ThreadMXBean\/ThreadInfo\/Multi\/Multi005\/TestDescription.java 8076494 windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":29,"deletions":22,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -273,0 +273,3 @@\n+        \/\/ Only one thread at a time can be controlling concurrent GC.\n+        static final Object concGCMonitor = new Object();\n+        static Shifter concGCController = null;\n@@ -295,1 +298,12 @@\n-                    if (!WB.g1InConcurrentMark()) {\n+                    \/\/ If no currently controlling thread and no concurrent GC\n+                    \/\/ in progress, then claim control.\n+                    synchronized (concGCMonitor) {\n+                        if ((concGCController == null) && !WB.g1InConcurrentMark()) {\n+                            concGCController = this;\n+                        }\n+                    }\n+                    if (concGCController == this) {\n+                        \/\/ If we've claimed control then take control, start a\n+                        \/\/ concurrent GC, and release control and the claim,\n+                        \/\/ letting the GC run to completion while we continue\n+                        \/\/ doing work.\n@@ -297,1 +311,9 @@\n-                        WB.g1StartConcMarkCycle();\n+                        WB.concurrentGCAcquireControl();\n+                        try {\n+                            WB.concurrentGCRunTo(WB.AFTER_MARKING_STARTED, false);\n+                        } finally {\n+                            WB.concurrentGCReleaseControl();\n+                            synchronized (concGCMonitor) {\n+                                concGCController = null;\n+                            }\n+                        }\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestMultiThreadStressRSet.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-                if (!Platform.isAArch64() && !Platform.isOSX()) {\n+                if (!Platform.isAArch64() && !Platform.isPPC() && !Platform.isOSX()) {\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -242,1 +242,4 @@\n-                Pattern pattern = Pattern.compile(\">>> Compilation.*both\\\\d.*\\\\RPrintIdeal:(?:(?!PrintOpto|>>> Compilation)[\\\\S\\\\s])+PrintOptoAssembly\");\n+                Pattern pattern = Pattern.compile(compilationPrefix() + \".*both\\\\d.*\\\\R> Phase \\\"\"\n+                                                  + CompilePhase.PRINT_IDEAL.getName()\n+                                                  + \"\\\":(?:(?!PrintOpto|\" + compilationPrefix()\n+                                                  + \")[\\\\S\\\\s])+PrintOptoAssembly\");\n@@ -246,1 +249,2 @@\n-                    failures.append(\"- Could not find all both() methods, expected 7 but found \").append(bothCount).append(System.lineSeparator());\n+                    failures.append(\"- Could not find all both() methods, expected 7 but found \").append(bothCount)\n+                            .append(System.lineSeparator());\n@@ -248,1 +252,3 @@\n-                pattern = Pattern.compile(\">>> Compilation.*ideal\\\\d.*\\\\RPrintIdeal:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+                pattern = Pattern.compile(compilationPrefix() + \".*ideal\\\\d.*\\\\R> Phase \\\"\"\n+                                          + CompilePhase.PRINT_IDEAL.getName()\n+                                          + \"\\\":(?:(?!\" + compilationPrefix() + \")[\\\\S\\\\s])+\");\n@@ -259,1 +265,2 @@\n-                    failures.append(\"- Could not find all ideal() methods, expected 7 but found \").append(count).append(System.lineSeparator());\n+                    failures.append(\"- Could not find all ideal() methods, expected 7 but found \").append(count)\n+                            .append(System.lineSeparator());\n@@ -261,1 +268,2 @@\n-                pattern = Pattern.compile(\">>> Compilation.*opto\\\\d.*\\\\RPrintOptoAssembly:(?:(?!>>> Compilation)[\\\\S\\\\s])+\");\n+                pattern = Pattern.compile(compilationPrefix() + \".*opto\\\\d.*\\\\R> Phase \\\"PrintOptoAssembly\\\":(?:(?!\"\n+                                          + compilationPrefix()  + \")[\\\\S\\\\s])+\");\n@@ -326,1 +334,0 @@\n-                Exception e = entry.getKey();\n@@ -385,1 +392,5 @@\n-    public static void findIrIds(String output, String method, int... numbers) {\n+    private static String compilationPrefix() {\n+        return \"\\\\d\\\\) Compilation\";\n+    }\n+\n+    private static void findIrIds(String output, String method, int... numbers) {\n@@ -962,2 +973,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN)\n@@ -972,2 +983,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    @IR(failOn = IRNode.COUNTED_LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN)\n@@ -982,2 +993,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    @IR(failOn = IRNode.COUNTED_LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN)\n@@ -994,2 +1005,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP) \/\/ fails\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN) \/\/ fails\n+    @IR(failOn = IRNode.COUNTED_LOOP) \/\/ fails\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN) \/\/ fails\n@@ -1005,2 +1016,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n-    @IR(failOn = IRNode.COUNTEDLOOP_MAIN)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP_MAIN)\n@@ -1246,0 +1257,1 @@\n+    private Object obj;\n@@ -1248,1 +1260,3 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP + \"[\\\\s\\\\S]*\" + \"call\")\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(failOn = {\"call\"},\n+        phase = CompilePhase.PRINT_OPTO_ASSEMBLY)\n@@ -1256,1 +1270,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP + \"|\" + \"call\")\n+    @IR(failOn = \"CountedLoop|call\",\n+        phase = {CompilePhase.PRINT_IDEAL, CompilePhase.PRINT_OPTO_ASSEMBLY})\n@@ -1264,2 +1279,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n-    @IR(failOn = \"call\")\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(failOn = \"call\", phase = CompilePhase.PRINT_OPTO_ASSEMBLY)\n@@ -1273,1 +1288,3 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP + \"[\\\\s\\\\S]*\" + \"call\", \"0\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"0\"})\n+    @IR(counts = {\"call\", \"0\"},\n+        phase = {CompilePhase.PRINT_OPTO_ASSEMBLY})\n@@ -1281,1 +1298,2 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP + \"|\" + \"call\", \"1\"})\n+    @IR(counts = {\"CountedLoop|call\", \"10\"},\n+        phase = {CompilePhase.PRINT_IDEAL, CompilePhase.PRINT_OPTO_ASSEMBLY})\n@@ -1289,2 +1307,2 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"0\"})\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"0\"})\n+    @IR(counts = {\"call\", \"0\"}, phase = CompilePhase.PRINT_OPTO_ASSEMBLY)\n@@ -1298,2 +1316,2 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n+    @IR(counts = {\"call\", \"0\"}, phase = CompilePhase.PRINT_OPTO_ASSEMBLY)\n@@ -1307,1 +1325,1 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n@@ -1315,1 +1333,1 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n@@ -1324,1 +1342,1 @@\n-    @IR(failOn = IRNode.COUNTEDLOOP)\n+    @IR(failOn = IRNode.COUNTED_LOOP)\n@@ -1333,1 +1351,1 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\"})\n@@ -1342,1 +1360,1 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\"})\n@@ -1351,1 +1369,1 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\"})\n@@ -1359,2 +1377,2 @@\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"5\"})\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"2\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"5\"})\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"2\"})\n@@ -1368,1 +1386,1 @@\n-    @IR(failOn = \"call\")\n+    @IR(failOn = IRNode.ALLOC)\n@@ -1370,3 +1388,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1376,2 +1392,2 @@\n-    @IR(failOn = \"call\")\n-    @IR(failOn = IRNode.STORE) \/\/ not fail\n+    @IR(failOn = IRNode.ALLOC)\n+    @IR(failOn = IRNode.STORE_F) \/\/ not fail\n@@ -1379,3 +1395,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1385,2 +1399,2 @@\n-    @IR(failOn = \"call\")\n-    @IR(counts = {IRNode.COUNTEDLOOP, \"1\"}) \/\/ not fail\n+    @IR(failOn = IRNode.ALLOC)\n+    @IR(counts = {IRNode.COUNTED_LOOP, \"1\"}) \/\/ not fail\n@@ -1389,1 +1403,1 @@\n-            dontInline();\n+            obj = new Object();\n@@ -1394,1 +1408,1 @@\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(counts = {IRNode.ALLOC, \"0\"})\n@@ -1396,3 +1410,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1402,2 +1414,2 @@\n-    @IR(failOn = IRNode.STORE) \/\/ not fail\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(failOn = IRNode.STORE_F) \/\/ not fail\n+    @IR(counts = {IRNode.ALLOC, \"0\"})\n@@ -1405,3 +1417,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1411,2 +1421,2 @@\n-    @IR(counts = {IRNode.STORE, \"0\"}) \/\/ not fail\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(counts = {IRNode.STORE_F, \"0\"}) \/\/ not fail\n+    @IR(counts = {IRNode.ALLOC, \"0\"})\n@@ -1414,3 +1424,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1420,2 +1428,2 @@\n-    @IR(counts = {\"call\", \"10\"})\n-    @IR(counts = {\"call\", \"0\"})\n+    @IR(counts = {IRNode.ALLOC, \"10\"})\n+    @IR(counts = {IRNode.ALLOC, \"0\"})\n@@ -1423,3 +1431,1 @@\n-        for (int i = 0; i < 100; i++) {\n-            dontInline();\n-        }\n+        obj = new Object();\n@@ -1616,1 +1622,1 @@\n-                                   \".*Regex \\\\d+:.*\\\\R.*Matched forbidden node.*\");\n+                                   \".*Constraint \\\\d+:.*\\\\R.*Matched forbidden node.*\");\n@@ -1619,1 +1625,1 @@\n-                                   \".*Regex \\\\d+:.*\\\\R.*Expected.*\");\n+                                   \".*Constraint \\\\d+:.*\\\\R.*Expected.*\");\n@@ -1639,1 +1645,1 @@\n-            pattern = Pattern.compile(\"Regex \" + regexIndex + \":.*\");\n+            pattern = Pattern.compile(\"Constraint \" + regexIndex + \":.*\");\n@@ -1642,1 +1648,1 @@\n-                Asserts.assertFalse(matcher.find(), errorPrefix() + \" failed with Regex \" + regexIndex);\n+                Asserts.assertFalse(matcher.find(), errorPrefix() + \" failed with Constraint \" + regexIndex);\n@@ -1645,2 +1651,2 @@\n-                Asserts.assertTrue(matcher.find(), errorPrefix() + \" should have failed at Regex \" + regexIndex);\n-                String[] splitRegex = categoryString.split(\"Regex \");\n+                Asserts.assertTrue(matcher.find(), errorPrefix() + \" should have failed at Constraint \" + regexIndex);\n+                String[] splitRegex = categoryString.split(\"Constraint \");\n@@ -1654,1 +1660,1 @@\n-                                               errorPrefix() + \" could not find all matches at Regex \" + regexIndex);\n+                                               errorPrefix() + \" could not find all matches at Constraint \" + regexIndex);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":79,"deletions":73,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -291,1 +291,1 @@\n- * @run main\/othervm -Xmx8g\n+ * @run main\/othervm\/timeout=180 -Xmx8g\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,12 +59,0 @@\n-###########################################################################\n-#\n-# sjavac\n-\n-tools\/sjavac\/IncCompileFullyQualifiedRef.java                                   8152055    generic-all    Requires dependency code to deal with in-method dependencies.\n-tools\/sjavac\/IncCompileWithChanges.java                                         8152055    generic-all    Requires dependency code to deal with in-method dependencies.\n-\n-tools\/sjavac\/ApiExtraction.java                                                 8158002    generic-all    Requires investigation\n-tools\/sjavac\/IgnoreSymbolFile.java                                              8158002    generic-all    Requires investigation\n-tools\/sjavac\/ClasspathDependencies.java                                         8158002    generic-all    Requires investigation\n-\n-\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"}]}