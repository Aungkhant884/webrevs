{"files":[{"patch":"@@ -719,0 +719,6 @@\n+  product(uintx, MonitorStorageSize, NOT_LP64(64*M) LP64_ONLY(4 * G),       \\\n+           \"Size of object monitor store\")                                  \\\n+                                                                            \\\n+  product(uintx, PreallocatedObjectMonitors, NOT_LP64(8) LP64_ONLY(64),     \\\n+           \"Max. thread local preallocated OMs\")                            \\\n+                                                                            \\\n@@ -2038,0 +2044,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -156,0 +156,1 @@\n+Mutex*   ObjectMonitorStorage_lock    = NULL;\n@@ -249,0 +250,1 @@\n+  def(ObjectMonitorStorage_lock    , PaddedMutex,   nosafepoint-3);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -150,0 +150,2 @@\n+extern Mutex*   ObjectMonitorStorage_lock;       \/\/ protects ObjectMonitorStorage\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-class ObjectMonitor : public CHeapObj<mtObjectMonitor> {\n+class ObjectMonitor : public StackObj {\n@@ -206,0 +206,2 @@\n+  void* operator new (size_t size, void* p) throw() { return p; }\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/objectMonitorStorage.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/static const bool be_paranoid = true;\n+static const bool be_paranoid = false;\n+\n+ReservedSpace ObjectMonitorStorage::_rs;\n+ObjectMonitorStorage::ArrayType ObjectMonitorStorage::_array;\n+address ObjectMonitorStorage::_base = NULL;\n+uintx ObjectMonitorStorage::_max_capacity = 0;\n+\n+\/\/ re-build a new list of newly allocated free monitors and return its head\n+void ObjectMonitorStorage::bulk_allocate_new_list(OMFreeListType& freelist_to_fill) {\n+\n+  MutexLocker ml(ObjectMonitorStorage_lock, Mutex::_no_safepoint_check_flag);\n+\n+  for (int i = 0; i < (int)PreallocatedObjectMonitors - 1; i ++) {\n+    ObjectMonitor* m = _array.allocate();\n+    if (m == NULL) {\n+      fatal(\"Maximum number of object monitors allocated (\" UINTX_FORMAT \"), increase MonitorStorageSize.\",\n+            _array.capacity());\n+    }\n+    freelist_to_fill.prepend(m);\n+  }\n+  DEBUG_ONLY(freelist_to_fill.verify(be_paranoid);)\n+  DEBUG_ONLY(verify();)\n+  log_with_state(\"bulk_allocate_new_list: \" UINTX_FORMAT \" new monitors\", PreallocatedObjectMonitors);\n+}\n+\n+\/\/ When a thread dies, return OMs left unused to the global store.\n+void ObjectMonitorStorage::cleanup_before_thread_death(Thread* t) {\n+  \/\/ Note that the ObjectMonitors we are about to return to the storage are\n+  \/\/ not yet initialized, so no need to destroy them.\n+  OMFreeListType& tl_list = t->_om_freelist;\n+  if (tl_list.empty() == false) {\n+    MutexLocker ml(ObjectMonitorStorage_lock, Mutex::_no_safepoint_check_flag);\n+    log_with_state(\"cleanup_before_thread_death: returning \" UINTX_FORMAT \" unused monitors\",\n+                   tl_list.count());\n+    _array.bulk_deallocate(tl_list);\n+    DEBUG_ONLY(verify();)\n+  }\n+  assert(tl_list.empty(), \"thread local list should now be empty\");\n+}\n+\n+\/\/ deallocate a list of monitors\n+void ObjectMonitorStorage::bulk_deallocate(OMFreeListType& omlist) {\n+  if (omlist.empty() == false) {\n+    MutexLocker ml(ObjectMonitorStorage_lock, Mutex::_no_safepoint_check_flag);\n+    log_with_state(\"bulk_deallocate: returning \" UINTX_FORMAT \" deflated monitors\",\n+                   omlist.count());\n+    _array.bulk_deallocate(omlist);\n+    DEBUG_ONLY(verify();)\n+  }\n+}\n+\n+void ObjectMonitorStorage::initialize() {\n+\n+  \/\/ Calc size of underlying address range\n+  const uintx min_object_monitors = 1024;\n+  const uintx max_object_monitors = (uintx)UINT_MAX - 1; \/\/ lets say, for now, it should fit into 32 bits\n+  const size_t range_size = align_up(\n+      clamp(MonitorStorageSize,\n+            min_object_monitors * sizeof(ObjectMonitor),\n+            max_object_monitors * sizeof(ObjectMonitor)),\n+            os::vm_page_size());\n+  const uintx max_capacity = range_size \/ sizeof(ObjectMonitor);\n+\n+  \/\/ Reserve space\n+  _rs = ReservedSpace(range_size);\n+  if (_rs.is_reserved()) {\n+    log_with_state(\"Reserved: [\" PTR_FORMAT \"-\" PTR_FORMAT \"), \" SIZE_FORMAT \" bytes (\" UINTX_FORMAT \" monitors).\",\n+                   p2i(_rs.base()), p2i(_rs.end()), _rs.size(), max_capacity);\n+    _array.initialize((ObjectMonitor*)_rs.base(), min_object_monitors, max_capacity);\n+    _base = (address) _rs.base();\n+    _max_capacity = max_capacity;\n+  } else {\n+    vm_exit_out_of_memory(range_size, OOM_MMAP_ERROR, \"Failed to reserve Object Monitor Store\");\n+  }\n+\n+  \/\/ Register with NMT\n+  MemTracker::record_virtual_memory_type(_rs.base(), mtObjectMonitor);\n+}\n+\n+void ObjectMonitorStorage::print(outputStream* st) {\n+  _array.print_on(st);\n+  st->cr();\n+}\n+\n+#ifdef ASSERT\n+void ObjectMonitorStorage::verify() {\n+  assert_lock_strong(ObjectMonitorStorage_lock);\n+  _array.verify(be_paranoid);\n+}\n+#endif\n+\n+void ObjectMonitorStorage::log_with_state(const char* fmt, ...) {\n+  LogTarget(Info, monitorinflation) lt;\n+  if (lt.is_enabled()) {\n+    va_list va;\n+    va_start(va, fmt);\n+    LogTarget(Info, monitorinflation) lt;\n+    assert(lt.is_enabled(), \"only call via LOG macro\");\n+    LogStream ls(lt);\n+    ls.print(\"OM Store: \");\n+    ls.vprint_cr(fmt, va);\n+    va_end(va);\n+    ls.print(\"OM Store: state now: \");\n+    print(&ls);\n+    ls.cr();\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/objectMonitorStorage.cpp","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_OBJECTMONITORSTORAGE_HPP\n+#define SHARE_RUNTIME_OBJECTMONITORSTORAGE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oop.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/addressStableArray.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+typedef FreeList<ObjectMonitor> OMFreeListType;\n+\n+typedef uint32_t OMRef;\n+#define INVALID_OMREF ((OMRef)-1)\n+\n+class ObjectMonitorStorage : public AllStatic {\n+\n+  typedef AddressStableArrayWithFreeList<ObjectMonitor> ArrayType;\n+  static ArrayType _array;\n+\n+  static ReservedSpace _rs;\n+\n+  \/\/ Precalculated for quick access\n+  static address _base;\n+  static uintx _max_capacity;\n+\n+  \/\/ re-build a new list of newly allocated free monitors and return its head\n+  static void bulk_allocate_new_list(OMFreeListType& freelist_to_fill);\n+\n+  \/\/ Return the current thread's om freelist\n+  static OMFreeListType& current_omlist() {\n+    \/\/ Note: monitors in this list are not initialized.\n+    return Thread::current()->_om_freelist;\n+  }\n+\n+  static void log_with_state(const char* fmt, ...) ATTRIBUTE_PRINTF(1, 2);\n+\n+public:\n+\n+  \/\/ On behalf of the current thread allocate a single monitor, preferably from\n+  \/\/ thread local freelist\n+  static ObjectMonitor* allocate_monitor(oop object) {\n+    OMFreeListType& tl_list = current_omlist();\n+    ObjectMonitor* om = tl_list.take_top();\n+    if (om == NULL) {\n+      bulk_allocate_new_list(tl_list);\n+      om = tl_list.take_top();\n+      assert(om != NULL, \"sanity\");\n+    }\n+    om = new (om) ObjectMonitor(object);\n+    assert(decode(encode(om)) == om, \"Decoding problem.\");\n+    return om; \/\/ done\n+  }\n+\n+  \/\/ On behalf of the current thread deallocate a single monitor\n+  static void deallocate_monitor(ObjectMonitor* m) {\n+    m->~ObjectMonitor(); \/\/ de-initialize.\n+    OMFreeListType& tl_list = current_omlist();\n+    tl_list.prepend(m);\n+  }\n+\n+  \/\/ deallocate a list of monitors; empties out the donor list.\n+  static void bulk_deallocate(OMFreeListType& omlist);\n+\n+  static void cleanup_before_thread_death(Thread* t);\n+\n+  static void initialize();\n+\n+  static void print(outputStream* st);\n+\n+  DEBUG_ONLY(static void verify();)\n+\n+  \/\/ Encoding, decoding\n+  static address base()           { return _base; }\n+  static ObjectMonitor* ombase()  { return (ObjectMonitor*) base(); }\n+\n+  static ObjectMonitor* decode(OMRef ref) {\n+    assert(ref < _max_capacity, \"OM ref oob (%u)\", ref);\n+    return ombase() + ref;\n+  }\n+\n+  static OMRef encode(const ObjectMonitor* om) {\n+    assert(om >= ombase() && om < (ombase() + _max_capacity),\n+           \"OM oob (\" PTR_FORMAT \")\", p2i(om));\n+    assert(is_aligned(om, BytesPerWord), \"om unaligned or has tag bits (\" PTR_FORMAT \")\", p2i(om));\n+    return (OMRef)(om - ombase());\n+  }\n+\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_OBJECTMONITORSTORAGE_HPP\n","filename":"src\/hotspot\/share\/runtime\/objectMonitorStorage.hpp","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"runtime\/objectMonitorStorage.hpp\"\n@@ -1345,1 +1346,1 @@\n-      ObjectMonitor* m = new ObjectMonitor(object);\n+      ObjectMonitor* m = ObjectMonitorStorage::allocate_monitor(object);\n@@ -1352,1 +1353,1 @@\n-        delete m;\n+        ObjectMonitorStorage::deallocate_monitor(m);\n@@ -1439,1 +1440,1 @@\n-    ObjectMonitor* m = new ObjectMonitor(object);\n+    ObjectMonitor* m = ObjectMonitorStorage::allocate_monitor(object);\n@@ -1444,1 +1445,1 @@\n-      delete m;\n+      ObjectMonitorStorage::deallocate_monitor(m);\n@@ -1638,9 +1639,16 @@\n-    size_t deleted_count = 0;\n-    for (ObjectMonitor* monitor: delete_list) {\n-      delete monitor;\n-      deleted_count++;\n-\n-      if (current->is_Java_thread()) {\n-        \/\/ A JavaThread must check for a safepoint\/handshake and honor it.\n-        chk_for_block_req(JavaThread::cast(current), \"deletion\", \"deleted_count\",\n-                          deleted_count, ls, &timer);\n+    \/\/ We prepare the OM freelist off-lock, the chain the prepared list to the\n+    \/\/ ObjectMonitorStorage freelist. That way time spent inside the lock is O(1).\n+    {\n+      const unsigned check_safepoint_interval = 256 * K;\n+      unsigned iter = 0;\n+      OMFreeListType omlist;\n+      for (ObjectMonitor* m : delete_list) {\n+        \/\/ We need to call ~ObjectMonitor explicitely. And we need to do this before adding\n+        \/\/ it to the freelist since the latter is a destructive call, so order matters.\n+        m->~ObjectMonitor();\n+        omlist.prepend(m);\n+        iter++;\n+        if ((iter % check_safepoint_interval) == 0) {\n+          chk_for_block_req(JavaThread::cast(current), \"deletion\", \"deleted_count\",\n+                            delete_list.length(), ls, &timer);\n+        }\n@@ -1648,0 +1656,2 @@\n+      \/\/ Now free the prepared list.\n+      ObjectMonitorStorage::bulk_deallocate(omlist);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":23,"deletions":13,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+#include \"runtime\/objectMonitorStorage.hpp\"\n@@ -380,0 +381,2 @@\n+  ObjectMonitorStorage::cleanup_before_thread_death(this);\n+\n@@ -420,0 +423,1 @@\n+\n@@ -2806,0 +2810,1 @@\n+  ObjectMonitorStorage::initialize();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"utilities\/freeList.hpp\"\n@@ -87,0 +88,2 @@\n+class ObjectMonitor;\n+\n@@ -643,0 +646,4 @@\n+\n+ public:\n+  FreeList<ObjectMonitor> _om_freelist;\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/objectMonitorStorage.hpp\"\n@@ -101,0 +102,4 @@\n+\n+  \/\/ Sneak in here for now\n+  ObjectMonitorStorage::print(out);\n+\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/objectMonitorStorage.hpp\"\n@@ -145,0 +146,1 @@\n+  output->cr();\n","filename":"src\/hotspot\/share\/services\/memTracker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_ADDRESSSTABLEARRAY_HPP\n+#define SHARE_UTILITIES_ADDRESSSTABLEARRAY_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/freeList.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+\/\/ An growable array of homogenous things, living in a pre-reserved address range\n+\/\/  (and hence ultimately limited in size).\n+\/\/ It does not own the reserved memory range (does get handed in) but does its own\n+\/\/  on-demand committing\/uncommitting.\n+\n+template <class T>\n+class AddressStableArray : public CHeapObj<mtInternal> {\n+  STATIC_ASSERT(sizeof(T) >= sizeof(T*));              \/\/ (1)\n+  STATIC_ASSERT(is_aligned(sizeof(T), sizeof(T*)));    \/\/ (2)\n+\n+  \/\/ Underlying address range [_elements, _elements + _max_capacity). Gets\n+  \/\/ handed in from outside. Note that we commit and uncommit page wise and\n+  \/\/ therefore the start pointer has to be page aligned. End does not have to\n+  \/\/ be (we can curtail _max_capacity beyond what the last page could\n+  \/\/ accomodate) but nothing else should live in the remainder of the last page.\n+  T* _elements;\n+  uintx _max_capacity;            \/\/ max number of slots\n+\n+  uintx _capacity;                \/\/ number of slots committed\n+  uintx _used;                    \/\/ number of slots allocated\n+\n+  static uintx capacity_of(size_t bytes)  { return bytes \/ sizeof(T); }\n+\n+  T* at(uintx idx) const                  { return _elements + idx; }\n+\n+  static size_t bytes_needed(uintx n)               { return sizeof(T) * n; }\n+  static size_t page_align(size_t s)                { return align_up(s, os::vm_page_size()); }\n+  static size_t bytes_needed_page_aligned(uintx n)  { return page_align(bytes_needed(n)); }\n+  static size_t pages_needed(uintx n)               { return bytes_needed_page_aligned(n) \/ os::vm_page_size(); }\n+\n+  \/\/ Enlarge committed capacity\n+  void enlarge_capacity(uintx min_needed_capacity);\n+\n+  void check_index(uintx index) const {\n+    assert(index < _used, \"invalid index (\" UINTX_FORMAT \")\", index);\n+  }\n+\n+public:\n+\n+  AddressStableArray() : _elements(NULL), _max_capacity(0), _capacity(0), _used(0) {}\n+\n+  void initialize(T* elements, uintx initial_capacity, uintx max_capacity) {\n+    assert(elements != NULL, \"sanity\");\n+    assert(is_aligned(elements, os::vm_page_size()), \"start address must be page aligned\");\n+    assert(max_capacity > 0, \"empty range?\");\n+    assert(max_capacity >= initial_capacity, \"sanity\");\n+\n+    assert(_elements == NULL, \"already initialized?\");\n+    _elements = elements;\n+    _max_capacity = max_capacity;\n+    _capacity = _used = 0;\n+\n+    if ((initial_capacity) > 0) {\n+      enlarge_capacity(initial_capacity);\n+    }\n+  }\n+\n+  bool contains(const T* v) const {\n+    return _elements <= v && (_elements + _used) > v;\n+  }\n+\n+  T* allocate() {\n+    if (_used == _capacity) {\n+      if (_capacity == _max_capacity) {\n+        return NULL;\n+      }\n+      enlarge_capacity(_capacity + 1);\n+    }\n+    assert(_used < _capacity, \"enlarge failed?\");\n+    T* p = at(_used);\n+    _used ++;\n+    return p;\n+  }\n+\n+  size_t reserved_bytes() const {\n+    return bytes_needed_page_aligned(_max_capacity);\n+  }\n+\n+  size_t committed_bytes() const {\n+    return bytes_needed_page_aligned(_capacity);\n+  }\n+\n+  uintx capacity() const { return _capacity; }\n+  uintx used() const     { return _used; }\n+\n+  \/\/ uncommit the underlying memory and reset the commit watermark.\n+  \/\/ (note: range stays reserved)\n+  void uncommit();\n+\n+  DEBUG_ONLY(void verify() const;)\n+  void print_on(outputStream* st) const;\n+\n+  \/\/ Base address (exposed to set NMT cat; TODO: this is annoying, should be done better\n+  const T* base() const { return _elements; }\n+\n+}; \/\/ AddressStableArray\n+\n+\/\/ Same, but with freelist supporting deallocation\n+template <class T>\n+class AddressStableArrayWithFreeList : public CHeapObj<mtInternal> {\n+\n+  typedef AddressStableArray<T> ArrayType;\n+  typedef FreeList<T> FreeListType;\n+\n+  ArrayType _array;\n+  FreeListType _freelist;\n+\n+public:\n+\n+  void initialize(T* elements, uintx initial_capacity, uintx max_capacity) {\n+    _array.initialize(elements, initial_capacity, max_capacity);\n+  }\n+\n+  T* allocate() {\n+    T* p = _freelist.take_top();\n+    if (p == NULL) {\n+      p = _array.allocate();\n+    }\n+    return p;\n+  }\n+\n+  void deallocate(T* t) {\n+    _freelist.prepend(t);\n+  }\n+\n+  \/\/ Add all elements to freelist and empties out the donor list\n+  void bulk_deallocate(FreeListType& list) {\n+    _freelist.prepend_list(list);\n+  }\n+\n+  \/\/ If all elements are free (there are no outstanding elements, all have been\n+  \/\/ returned to the freelist), uncommit the underlying memory range and reset the\n+  \/\/ freelist. Returns true if that worked, false otherwise.\n+  bool try_uncommit();\n+\n+  size_t committed_bytes() const         { return _array.committed_bytes(); }\n+  bool contains(const T* v) const        { return _array.contains(v); }\n+\n+  \/\/ Returns the committed capacity, in number of elements\n+  uintx capacity() const                  { return _array.capacity(); }\n+  \/\/ Returns the number of outstanding allocations\n+  uintx used() const                      { return _array.used() - free(); }\n+  \/\/ Returns the number of elements in the freelist waiting for reuse\n+  uintx free() const                      { return _freelist.count(); }\n+\n+  DEBUG_ONLY(void verify(bool paranoid = false) const;)\n+  void print_on(outputStream* st) const;\n+\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_ADDRESSSTABLEARRAY_HPP\n","filename":"src\/hotspot\/share\/utilities\/addressStableArray.hpp","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_ADDRESSSTABLEARRAY_INLINE_HPP\n+#define SHARE_UTILITIES_ADDRESSSTABLEARRAY_INLINE_HPP\n+\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/addressStableArray.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/freeList.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/\n+\/\/\n+\/\/\/\/\/\/\/ AddressStableArray \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/\n+\n+template <class T>\n+void AddressStableArray<T>::enlarge_capacity(uintx min_needed_capacity) {\n+\n+  assert(_elements != NULL, \"address space not reserved?\");\n+\n+  assert(_capacity < _max_capacity, \"cannot enlarge capacity\");\n+\n+  \/\/ We increase by a quarter, but at least 4 pages.\n+  const uintx cap_increase =\n+      MAX2(_capacity \/ 4, capacity_of(os::vm_page_size() * 4));\n+\n+  const uintx new_capacity =\n+      clamp((uintx)(_capacity + cap_increase), min_needed_capacity, _max_capacity);\n+\n+  const size_t committed_bytes = bytes_needed_page_aligned(_capacity);\n+  const size_t new_committed_bytes = bytes_needed_page_aligned(new_capacity);\n+\n+  \/\/ Since we always set _capacity to either _max_capacity or the limit of what is\n+  \/\/ committed, this should hold always true:\n+  assert(new_committed_bytes > committed_bytes, \"_capacity not at commit boundary\");\n+\n+  os::commit_memory_or_exit((char*)_elements + committed_bytes,\n+                        new_committed_bytes - committed_bytes,\n+                        false, \"\");\n+  _capacity = MIN2(capacity_of(new_committed_bytes), _max_capacity);\n+\n+  DEBUG_ONLY(verify();)\n+}\n+\n+\/\/ uncommit the underlying memory and reset the commit watermark.\n+\/\/ (note: range stays reserved)\n+template <class T>\n+void AddressStableArray<T>::uncommit() {\n+  if (_capacity > 0) {\n+    const size_t committed_bytes = bytes_needed_page_aligned(_capacity);\n+    bool rc = os::uncommit_memory((char*)_elements, committed_bytes, false);\n+    assert(rc, \"uncommit failed\");\n+    _capacity = 0;\n+    _used = 0;\n+  }\n+}\n+\n+#ifdef ASSERT\n+template <class T>\n+void AddressStableArray<T>::verify() const {\n+  assert(_elements != NULL, \"not reserved?\");\n+  assert(_capacity <= _max_capacity, \"Sanity\");\n+  assert(_used <= _capacity, \"Sanity\");\n+}\n+#endif \/\/ ASSERT\n+\n+template <class T>\n+void AddressStableArray<T>::print_on(outputStream* st) const {\n+  st->print(\"elem size: \" SIZE_FORMAT \", \"\n+      \"[\" PTR_FORMAT \"-\" PTR_FORMAT \"), res\/comm \" SIZE_FORMAT \"\/\" SIZE_FORMAT \", \"\n+      \"used\/capacity\/max: \" UINTX_FORMAT \"\/\" UINTX_FORMAT \"\/\" UINTX_FORMAT\n+      ,\n+      sizeof(T),\n+      p2i(_elements), p2i(_elements + _max_capacity),\n+      reserved_bytes(), committed_bytes(),\n+      _used, _capacity, _max_capacity\n+      );\n+}\n+\n+\/\/\n+\/\/\n+\/\/\/\/\/\/\/ AddressStableArrayWithFreeList \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/\n+\/\/\n+\n+template <class T>\n+struct VerifyFreeListClosure : public FreeList<T>::Closure {\n+  const AddressStableArrayWithFreeList<T>* _container;\n+  bool do_it(const T* p) override {\n+    assert(_container->contains(p), \"kukuck\");\n+    return true;\n+  }\n+};\n+\n+#ifdef ASSERT\n+template <class T>\n+void AddressStableArrayWithFreeList<T>::verify(bool paranoid) const {\n+  assert((used() + free()) <= capacity(),\n+         \"number mismatch (\" UINTX_FORMAT \", \" UINTX_FORMAT \", \" UINTX_FORMAT \")\",\n+         capacity(), used(), free());\n+  _array.verify();\n+  _freelist.verify(paranoid);\n+  \/\/ verify that all elements are part of the array\n+  VerifyFreeListClosure<T> verifier;\n+  verifier._container = this;\n+  _freelist.iterate(verifier);\n+}\n+#endif \/\/ ASSERT\n+\n+template <class T>\n+void AddressStableArrayWithFreeList<T>::print_on(outputStream* st) const {\n+  _array.print_on(st);\n+  st->print(\", freelist: \");\n+  _freelist.print_on(st, false);\n+}\n+\n+\/\/ If all elements are free (there are no outstanding elements, all have been\n+\/\/ returned to the freelist), uncommit the underlying memory range and reset the\n+\/\/ freelist. Returns true if that worked, false otherwise.\n+template <class T>\n+bool AddressStableArrayWithFreeList<T>::try_uncommit() {\n+  \/\/ if we are already completely uncommitted, its a benign noop.\n+  if (_array.used() == 0) {\n+    assert(_array.committed_bytes() == 0, \"sanity\");\n+    return true;\n+  }\n+  \/\/ if we have committed some slots, but all of them are in the freelist,\n+  \/\/ we can uncommit.\n+  if (_array.used() > 0 &&\n+      _array.used() == _freelist.count()) {\n+    _freelist.reset();\n+    _array.uncommit();\n+    return true;\n+  }\n+  return false;\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_ADDRESSSTABLEARRAY_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/addressStableArray.inline.hpp","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,178 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_FREELIST_HPP\n+#define SHARE_UTILITIES_FREELIST_HPP\n+\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+\/\/ Simple classic double-headed, self-counting (optional), freelist of dead elements\n+\n+template <class T>\n+static T* Tptr_at(T* p)                   { return *((T**)p); }\n+\n+template <class T>\n+static void set_Tptr_at(T* p, T* newval)  { *((T**)p) = newval; }\n+\n+template <class T>\n+static void set_Tptr_at_null(T* p)        { set_Tptr_at(p, (T*) NULL); }\n+\n+template <class T>\n+class FreeList {\n+\n+  T* _head;\n+  T* _tail;\n+  uintx _count;\n+  DEBUG_ONLY(uintx _peak_count;)\n+\n+#ifdef ASSERT\n+  void quick_verify() const {\n+    assert((_head == NULL) == (_tail == NULL), \"malformed list\");\n+    assert( (_count == 0 && _head == NULL && _tail == NULL) ||\n+            (_count == 1 && _head == _tail) ||\n+            (_count > 1 && _head != _tail), \"malformed list\");\n+    DEBUG_ONLY(assert(_peak_count >= _count, \"peak count off\");)\n+  }\n+#endif\n+\n+public:\n+\n+  FreeList() :\n+    _head(NULL), _tail(NULL),\n+    _count(0)\n+#ifdef ASSERT\n+    , _peak_count(0)\n+#endif\n+  {}\n+\n+  FreeList(T* head, T* tail, uintx count) :\n+    _head(head), _tail(tail),\n+    _count(count)\n+#ifdef ASSERT\n+    , _peak_count(count)\n+#endif\n+  {}\n+\n+  T* head() const { return _head; }\n+  T* tail() const { return _tail; }\n+\n+  \/\/ Remove the topmost element from the freelist; NULL if empty\n+  T* take_top() {\n+    T* p = _head;\n+    if (p != NULL) {\n+      _head = Tptr_at(_head);\n+      if (_head == NULL) {\n+        _tail = NULL;\n+      }\n+      assert(_count > 0, \"sanity\");\n+      _count --;\n+      DEBUG_ONLY(set_Tptr_at_null(p);)\n+      DEBUG_ONLY(quick_verify();)\n+    }\n+    return p;\n+  }\n+\n+  void prepend(T* elem) {\n+    if (_head == NULL) {\n+      assert(0 == _count, \"invalid freelist count\");\n+      _head = _tail = elem;\n+      set_Tptr_at_null(_head);\n+    } else {\n+      assert(0 < _count, \"invalid freelist count\");\n+      set_Tptr_at(elem, _head);\n+      _head = elem;\n+    }\n+    _count ++;\n+    DEBUG_ONLY(_peak_count = MAX2(_peak_count, _count);)\n+    DEBUG_ONLY(quick_verify();)\n+  }\n+\n+  \/\/ Take over other list, reset other list\n+  void take_elements(FreeList& other) {\n+    assert(empty(), \"must be empty\");\n+    if (!other.empty()) {\n+      _head = other.head();\n+      _tail = other.tail();\n+      _count = other.count();\n+      DEBUG_ONLY(_peak_count = other.peak_count();)\n+      other.reset();\n+      DEBUG_ONLY(verify();)\n+    }\n+  }\n+\n+  \/\/ Prepends list items to this list and resets the other list.\n+  void prepend_list(FreeList& other) {\n+    DEBUG_ONLY(other.quick_verify();)\n+    if (!other.empty()) {\n+      if (empty()) {\n+        take_elements(other);\n+      } else {\n+        set_Tptr_at(other.tail(), _head);\n+        _head = other.head();\n+        _count += other.count();\n+        DEBUG_ONLY(_peak_count = MAX2(_peak_count, _count);)\n+        DEBUG_ONLY(verify();)\n+        other.reset();\n+      }\n+    }\n+  }\n+\n+  void prepend_list(T* head, T* tail, uintx count) {\n+    FreeList tmp(head, tail, count);\n+    add_list_to_front(tmp);\n+  }\n+\n+  \/\/ Reset also resets the peak count, so the history is lost.\n+  void reset() {\n+    _head = _tail = NULL;\n+    _count = 0;\n+    DEBUG_ONLY(_peak_count = 0;)\n+  }\n+\n+  bool empty() const { return _head == NULL; }\n+\n+  uintx count() const { return _count; }\n+  DEBUG_ONLY(uintx peak_count() const { return _peak_count; })\n+\n+  struct Closure {\n+    \/\/ return false to stop iterating\n+    virtual bool do_it(const T* element) = 0;\n+  };\n+  \/\/ Call Closure.doit(). If that returns false, iteration is cancelled at that point.\n+  uintx iterate(Closure& closure) const;\n+\n+#ifdef ASSERT\n+  \/\/ paranoid = true: dup check\n+  void verify(bool paranoid = false) const;\n+#endif\n+\n+  void print_on(outputStream* st, bool print_elems = false) const;\n+\n+}; \/\/ Freelist\n+\n+#endif \/\/ SHARE_UTILITIES_FREELIST_HPP\n","filename":"src\/hotspot\/share\/utilities\/freeList.hpp","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_FREELIST_INLINE_HPP\n+#define SHARE_UTILITIES_FREELIST_INLINE_HPP\n+\n+#include \"utilities\/freeList.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+class outputStream;\n+\n+template <class T>\n+uintx FreeList<T>::iterate(FreeList<T>::Closure& closure) const {\n+  uintx processed = 0;\n+  bool go_on = true;\n+  for (const T* p = head(); go_on && p != NULL; p = Tptr_at(p)) {\n+    processed ++;\n+    go_on = closure.do_it(p);\n+  }\n+  return processed;\n+}\n+\n+#ifdef ASSERT\n+template <class T>\n+void FreeList<T>::verify(bool paranoid) const {\n+\n+  STATIC_ASSERT(sizeof(T) >= sizeof(T*));\n+\n+  quick_verify();\n+\n+  \/\/ Simple verify list and list length. Also call verify_closure if it is set.\n+  uintx counted = 0;\n+  for (const T* p = head(); p != NULL; p = Tptr_at(p)) {\n+    assert(counted < _count, \"too many elements (more than \" UINTX_FORMAT \")?\", _count);\n+    counted ++;\n+  }\n+  assert(_count == counted, \"count is off (found: \" UINTX_FORMAT \", expected: \" UINTX_FORMAT \".\",\n+         counted, _count);\n+\n+  \/\/ In paranoid mode, or if we have know we have fewer than n elements,\n+  \/\/ we check for duplicates. Slow (O(n^2)\/2).\n+  if (paranoid || _count < 5) {\n+    for (const T* p = head(); p != NULL; p = Tptr_at(p)) {\n+      for (const T* p2 = Tptr_at(p); p2 != NULL; p2 = Tptr_at(p2)) {\n+        assert(p2 != p, \"duplicate in list\");\n+      }\n+    }\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+template <class T>\n+void FreeList<T>::print_on(outputStream* st, bool print_elems) const {\n+  st->print(UINTX_FORMAT \" elems\", _count);\n+#ifdef ASSERT\n+  st->print(\" (peak: \" UINTX_FORMAT \" elems)\", _peak_count);\n+#endif\n+  if (print_elems) {\n+    st->cr();\n+    for (const T* p = head(); p != NULL; p = Tptr_at(p)) {\n+      st->print(PTR_FORMAT \"->\", p2i(p));\n+    }\n+    st->cr();\n+  }\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_FREELIST_INLINE_HPP\n","filename":"src\/hotspot\/share\/utilities\/freeList.inline.hpp","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/objectMonitorStorage.hpp\"\n@@ -1080,0 +1081,7 @@\n+  STEP(\"printing objmon storage information\")\n+\n+     if (_verbose && Universe::is_fully_initialized()) {\n+       st->print_cr(\"ObjectMonitorStorage:\");\n+       ObjectMonitorStorage::print(st);\n+     }\n+\n@@ -1289,0 +1297,7 @@\n+  \/\/ STEP(\"printing objmon storage information\")\n+\n+  if (Universe::is_fully_initialized()) {\n+    st->print_cr(\"ObjectMonitorStorage:\");\n+    ObjectMonitorStorage::print(st);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/addressStableArray.inline.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include \"unittest.hpp\"\n+#include \"testutils.hpp\"\n+\n+\n+static const size_t max_memory = 10 * M; \/\/ a single test should not use more than that\n+\n+\/\/ Helper class to reserve memory for a test\n+template <class T>\n+class MemoryReserver {\n+  ReservedSpace _rs;\n+public:\n+  MemoryReserver(uintx max_elems) :\n+    _rs(align_up(max_elems * sizeof(T), (size_t)os::vm_allocation_granularity()))\n+  {\n+    assert(_rs.base() != NULL, \"Failed to reserve space\");\n+    assert(_rs.size() <= max_memory, \"too much memory for test\");\n+  }\n+  T* elements() { return (T*)_rs.base(); }\n+};\n+\n+\/\/ helper, calc expected committed range size for a given element number\n+template <class T>\n+static size_t expected_committed_bytes(uintx elems) {\n+  return align_up(sizeof(T) * elems, os::vm_page_size());\n+}\n+\n+\/\/ capacity is difficult to predict, since it increases in larger steps and the increase\n+\/\/ depends on page size and cap increase steps. I just do some range checks here\n+#define ASSERT_CAP_EQ(array, n)                                       \\\n+  ASSERT_EQ(array.capacity(), (uintx)n);                              \\\n+  ASSERT_EQ(array.committed_bytes(), expected_committed_bytes<T>(n));\n+\n+\/\/ Range check for cap. Note range is including on both ends ([])\n+#define ASSERT_CAP_IN_RANGE(array, n1, n2)                             \\\n+  ASSERT_GE(array.capacity(), (uintx)n1);                              \\\n+  ASSERT_LE(array.capacity(), (uintx)n2);                              \\\n+  ASSERT_GE(array.committed_bytes(), expected_committed_bytes<T>(n1)); \\\n+  ASSERT_LE(array.committed_bytes(), expected_committed_bytes<T>(n2)); \\\n+\n+#define ASSERT_USED(array, n)   ASSERT_EQ(array.used(), (uintx)n)\n+#define ASSERT_FREE(array, n)   ASSERT_EQ(array.free(), (uintx)n)\n+\n+#define ASSERT_USED_FREE(array, used, free) \\\n+    ASSERT_USED(array, used);               \\\n+    ASSERT_FREE(array, free);\n+\n+\/\/ Test expectation that heap is completely filled. Stats should reflect that.\n+\/\/ Allocation should return NULL and leave stats unchanged.\n+#define ASSERT_ARRAY_IS_FULL(a1)        \\\n+    ASSERT_USED_FREE(a1, max_size, 0);  \\\n+    ASSERT_CAP_EQ(a1, max_size);        \\\n+    ASSERT_EQ(a1.allocate(), (T*)NULL); \\\n+    ASSERT_USED_FREE(a1, max_size, 0);  \\\n+    ASSERT_CAP_EQ(a1, max_size);\n+\n+\/\/ Allocate from array a single element, and if not null, stamp it\n+template <class T> T* allocate_from_array(AddressStableArrayWithFreeList<T>& a) {\n+  T* p = a.allocate();\n+  if (p != NULL) {\n+    GtestUtils::mark_range(p, sizeof(T));\n+  }\n+  return p;\n+}\n+\n+\/\/ Return an element to the array. Before doing that, check stamp.\n+template <class T> void deallocate_to_array(AddressStableArrayWithFreeList<T>& a, T* elem) {\n+  ASSERT_TRUE(GtestUtils::check_range(elem, sizeof(T)));\n+  a.deallocate(elem);\n+}\n+\n+template <class T> class SimpleArray {\n+  T* const _v;\n+public:\n+  SimpleArray(uintx size) : _v(NEW_C_HEAP_ARRAY(T, size, mtTest)) {\n+    ::memset(_v, 0, sizeof(T) * size);\n+  }\n+  ~SimpleArray() { FREE_C_HEAP_ARRAY(T, _v); }\n+  T* v() { return _v; }\n+};\n+\n+template <class T>\n+static void test_fill_empty_repeat(AddressStableArrayWithFreeList<T>& a1, uintx initialsize, uintx max_size) {\n+\n+  ASSERT_USED_FREE(a1, 0, 0);\n+  ASSERT_CAP_IN_RANGE(a1, initialsize, max_size);\n+\n+  SimpleArray<T*> elems_holder(max_size);\n+  T** elems = elems_holder.v();\n+\n+  DEBUG_ONLY(a1.verify();)\n+\n+  uintx expected_used = 0;\n+  uintx expected_free = 0;\n+  for (int cycle = 0; cycle < 3; cycle ++) {\n+\n+    \/\/ fill completely\n+    for (uintx i = 0; i < max_size; i ++) {\n+      T* p = allocate_from_array(a1);\n+      ASSERT_NE(p, (T*)NULL);\n+      elems[i] = p;\n+      expected_used ++;\n+      if (expected_free > 0) {\n+        expected_free --;\n+      }\n+      \/\/ used increases, cap increases in spurts,\n+      \/\/ free stays 0 since freelist gets only filled after deallocs,\n+      ASSERT_USED_FREE(a1, expected_used, expected_free);\n+      ASSERT_CAP_IN_RANGE(a1, expected_used + expected_free, max_size);\n+    }\n+\n+    ASSERT_EQ(expected_used, max_size);\n+    ASSERT_EQ(expected_free, (uintx)0);\n+\n+    \/\/ We should be right at the edge now\n+    ASSERT_ARRAY_IS_FULL(a1)\n+\n+    \/\/ Return all elements\n+    for (uintx i = 0; i < max_size; i ++) {\n+      deallocate_to_array(a1, elems[i]);\n+      expected_used --;\n+      expected_free ++;\n+      \/\/ used, free change, cap stays at max\n+      ASSERT_USED_FREE(a1, expected_used, expected_free);\n+      ASSERT_CAP_EQ(a1, max_size);\n+    }\n+\n+    ASSERT_EQ(expected_used, (uintx)0);\n+    ASSERT_EQ(expected_free, max_size);\n+\n+    DEBUG_ONLY(a1.verify();)\n+  }\n+}\n+\n+template <class T>\n+static void test_fill_empty_randomly(AddressStableArrayWithFreeList<T>& a1, uintx initialsize, uintx max_size) {\n+\n+  ASSERT_USED_FREE(a1, 0, 0);\n+  ASSERT_CAP_IN_RANGE(a1, initialsize, max_size);\n+\n+  SimpleArray<T*> elems_holder(max_size);\n+  T** elems = elems_holder.v();\n+\n+  DEBUG_ONLY(a1.verify();)\n+\n+  \/\/ randomly alloc or dealloc a number of times and observe stats\n+  uintx expected_used = 0;\n+  uintx expected_free = 0;\n+\n+  for (uintx iter = 0; iter < MAX2(max_size * 10, (uintx)256); iter ++) {\n+    const int idx = os::random() % max_size;\n+    if (elems[idx] == NULL) {\n+      T* p = allocate_from_array(a1);\n+      ASSERT_NE(p, (T*)NULL);\n+      elems[idx] = p;\n+      expected_used ++;\n+      if (expected_free > 0) {\n+        expected_free --;\n+      }\n+    } else {\n+      deallocate_to_array(a1, elems[idx]);\n+      elems[idx] = NULL;\n+      expected_free ++;\n+      expected_used --;\n+    }\n+    ASSERT_USED_FREE(a1, expected_used, expected_free);\n+    ASSERT_CAP_IN_RANGE(a1, expected_used + expected_free, max_size);\n+    if ((iter % 256) == 0) {\n+      DEBUG_ONLY(a1.verify(false);)\n+    }\n+  }\n+  DEBUG_ONLY(a1.verify(true);)\n+\n+  \/\/ Now allocate fully\n+  for (uintx i = 0; i < max_size; i++) {\n+    if (elems[i] == 0) {\n+      T* p = allocate_from_array(a1);\n+      ASSERT_NE(p, (T*)NULL);\n+      elems[i] = p;\n+      expected_used ++;\n+      if (expected_free > 0) {\n+        expected_free --;\n+      }\n+      ASSERT_USED_FREE(a1, expected_used, expected_free);\n+      ASSERT_CAP_IN_RANGE(a1, expected_used + expected_free, max_size);\n+    }\n+  }\n+\n+  \/\/ We should be right at the edge now\n+  ASSERT_ARRAY_IS_FULL(a1)\n+\n+  DEBUG_ONLY(a1.verify(true);)\n+}\n+\n+template <class T>\n+static void test_commit_and_uncommit(AddressStableArrayWithFreeList<T>& a1, uintx initialsize, uintx max_size) {\n+\n+  ASSERT_USED_FREE(a1, 0, 0);\n+  ASSERT_CAP_IN_RANGE(a1, initialsize, max_size);\n+\n+  SimpleArray<T*> elems_holder(max_size);\n+  T** elems = elems_holder.v();\n+\n+  for (int cycle = 0; cycle < 5; cycle ++) {\n+\n+    \/\/ fill completely\n+    for (uintx i = 0; i < max_size; i ++) {\n+      T* p = allocate_from_array(a1);\n+      ASSERT_NE(p, (T*)NULL);\n+      elems[i] = p;\n+      \/\/ used increases, cap increases in spurts,\n+      \/\/ free stays 0 since freelist gets only filled after deallocs,\n+      ASSERT_USED_FREE(a1, i + 1, 0);\n+      ASSERT_CAP_IN_RANGE(a1, i + 1, max_size);\n+    }\n+\n+    ASSERT_ARRAY_IS_FULL(a1);\n+\n+    \/\/ uncommiting should fail, since elements are not free, and should\n+    \/\/ leave array unchanged\n+    ASSERT_FALSE(a1.try_uncommit());\n+    ASSERT_ARRAY_IS_FULL(a1);\n+\n+    \/\/ release all but one\n+    \/\/ fill array completely\n+    for (uintx i = 0; i < max_size - 1; i ++) {\n+      deallocate_to_array(a1, elems[i]);\n+    }\n+\n+    \/\/ capacity is max, but almost all are free now:\n+    ASSERT_USED_FREE(a1, 1, max_size - 1);\n+    ASSERT_CAP_EQ(a1, max_size);\n+\n+    \/\/ uncommiting should still fail, since elements are not free, and should\n+    \/\/ leave array unchanged\n+    ASSERT_FALSE(a1.try_uncommit());\n+    ASSERT_USED_FREE(a1, 1, max_size - 1);\n+    ASSERT_CAP_EQ(a1, max_size);\n+\n+    \/\/ release the last element\n+    deallocate_to_array(a1, elems[max_size - 1]);\n+\n+    \/\/ now all should be free, still fully committed though\n+    ASSERT_USED_FREE(a1, 0, max_size);\n+    ASSERT_CAP_EQ(a1, max_size);\n+\n+    \/\/ release should work and reset the whole array\n+    ASSERT_TRUE(a1.try_uncommit());\n+    ASSERT_USED_FREE(a1, 0, 0);\n+    ASSERT_CAP_EQ(a1, 0);\n+\n+    \/\/ a second release on an empty array should work too and be a noop\n+    ASSERT_TRUE(a1.try_uncommit());\n+    ASSERT_USED_FREE(a1, 0, 0);\n+    ASSERT_CAP_EQ(a1, 0);\n+  }\n+}\n+\n+#define xstr(s) str(s)\n+#define str(s) #s\n+\n+#define TEST_single(T, function, initialsize, max_size)                         \\\n+TEST_VM(AddressStableArray, function##_##T##_##initialsize##_##max_size)        \\\n+{                                                                               \\\n+  MemoryReserver<T> reserver(max_size);                                         \\\n+  AddressStableArrayWithFreeList<T> a;                                          \\\n+  a.initialize(reserver.elements(), initialsize, max_size);                     \\\n+  function<T>(a, initialsize, max_size);                                        \\\n+}\n+\n+#define TEST_all_functions(T, initialsize, max_size)                            \\\n+  TEST_single(T, test_fill_empty_repeat, initialsize, max_size)                 \\\n+  TEST_single(T, test_fill_empty_randomly, initialsize, max_size)               \\\n+  TEST_single(T, test_commit_and_uncommit, initialsize, max_size)\n+\n+#define TEST_all_functions_small_sizes(T)                                       \\\n+  TEST_all_functions(T, 0, 1)                                                   \\\n+  TEST_all_functions(T, 1, 1)                                                   \\\n+  TEST_all_functions(T, 0, 100)                                                 \\\n+  TEST_all_functions(T, 10, 100)\n+\n+\n+\/\/ This we only execute for small types\n+#define TEST_all_functions_all_sizes(T)                                         \\\n+  TEST_all_functions_small_sizes(T)                                             \\\n+  TEST_all_functions(T, 0, 50000)                                               \\\n+  TEST_all_functions(T, 1000, 50000)\n+\n+struct s3 { void* p[3]; };\n+\n+#ifndef _LP64\n+TEST_all_functions_all_sizes(uint32_t)\n+#endif\n+\n+TEST_all_functions_all_sizes(uint64_t)\n+TEST_all_functions_all_sizes(s3)\n+\n+\/\/ Some larger types\n+\n+struct s216 { char p[216]; };\n+\n+\/\/ almost, but not quite, a page (note: sizeof all types for AddressStableArray must be pointer aligned)\n+struct almost4k { char m[4096 - sizeof(intptr_t)]; };\n+\n+\/\/ large\n+struct s64k { char m[64 * 1024]; };\n+\n+TEST_all_functions_small_sizes(s216)\n+TEST_all_functions_small_sizes(almost4k)\n+TEST_all_functions_small_sizes(s64k)\n","filename":"test\/hotspot\/gtest\/utilities\/test_addressStableArray.cpp","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/freeList.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+#include \"unittest.hpp\"\n+#include \"testutils.hpp\"\n+\n+#define ASSERT_LIST_COUNT(list, n) ASSERT_EQ(list.count(), (uintx)n);\n+\n+#ifdef ASSERT\n+#define ASSERT_LIST_PEAK(list, n)  ASSERT_EQ(list.peak_count(), (uintx)n);\n+#else\n+#define ASSERT_LIST_PEAK(list, n)\n+#endif\n+\n+#define ASSERT_LIST_EMPTY(list)    \\\n+  ASSERT_TRUE(list.empty());       \\\n+  ASSERT_LIST_COUNT(list, 0)\n+\n+template <class T>\n+static void prepend_all_with_checks(FreeList<T>& list, T* elems, int num, int expected_start_count) {\n+  ASSERT_LIST_COUNT(list, expected_start_count);\n+  if (expected_start_count == 0) {\n+    ASSERT_TRUE(list.empty());\n+  }\n+  for (int i = 0; i < num; i ++) {\n+    list.prepend(elems + i);\n+    ASSERT_LIST_COUNT(list, expected_start_count + i + 1);\n+    ASSERT_FALSE(list.empty());\n+  }\n+}\n+\n+template <class T>\n+static void safely_print_list(FreeList<T>& list) {\n+  char tmp[1024];\n+  stringStream ss(tmp, sizeof(tmp));\n+  list.print_on(&ss, true);\n+  printf(\"%s\\n\", tmp);\n+}\n+\n+\n+#define NUM_ELEMS 30\n+\n+template <class T>\n+static void test_empty_list() {\n+  FreeList<T> list;\n+  ASSERT_LIST_EMPTY(list);\n+  DEBUG_ONLY(list.verify(true);)\n+}\n+\n+template <class T>\n+static void prepare_new_list_with_checks(FreeList<T>& list, T* elems) {\n+  prepend_all_with_checks(list, elems, NUM_ELEMS, 0);\n+  ASSERT_LIST_COUNT(list, NUM_ELEMS);\n+  ASSERT_LIST_PEAK(list, NUM_ELEMS);\n+  DEBUG_ONLY(list.verify(true);)\n+}\n+\n+template <class T>\n+static void test_single_prepend() {\n+\n+  FreeList<T> list;\n+  ASSERT_LIST_EMPTY(list);\n+  DEBUG_ONLY(list.verify(true);)\n+\n+  T t[NUM_ELEMS];\n+  prepare_new_list_with_checks<T>(list, t);\n+\n+  for (int i = NUM_ELEMS - 1; i >= 0; i --) {\n+    T* p = list.take_top();\n+    ASSERT_EQ(p, t + i);\n+    ASSERT_LIST_COUNT(list, i);\n+  }\n+  ASSERT_LIST_EMPTY(list);\n+  ASSERT_LIST_PEAK(list, NUM_ELEMS);\n+  DEBUG_ONLY(list.verify(true);)\n+}\n+\n+template <class T, int max_expected>\n+struct TestIterator : public FreeList<T>::Closure {\n+\n+  const T* t[max_expected];\n+  const int _stop_after;\n+  int _found;\n+\n+  TestIterator(int stop_after = max_expected * 2)\n+    : _stop_after(stop_after),\n+      _found(0)\n+  {\n+    for (int i = 0; i < max_expected; i ++) {\n+      t[i] = NULL;\n+    }\n+  }\n+\n+  bool do_it(const T* p) override {\n+    if (_found == max_expected) {\n+     return false;\n+    }\n+    t[_found] = p;\n+    _found ++;\n+    return _found < _stop_after;\n+  }\n+\n+};\n+\n+template <class T>\n+static void test_iteration(bool premature_stop) {\n+\n+  FreeList<T> list;\n+  ASSERT_LIST_EMPTY(list);\n+  DEBUG_ONLY(list.verify(true);)\n+\n+  T t[NUM_ELEMS];\n+  prepare_new_list_with_checks<T>(list, t);\n+\n+  const int stop_after = premature_stop ? 3 : INT_MAX;\n+  const int expected_stop_at = premature_stop ? 3 : NUM_ELEMS;\n+  TestIterator<T, NUM_ELEMS> it(stop_after);\n+\n+  ASSERT_EQ(list.iterate(it), (uintx)expected_stop_at);\n+  ASSERT_EQ(it._found, expected_stop_at);\n+  for (int i = 0; i < NUM_ELEMS; i++) {\n+\/\/safely_print_list<T>(list);\n+    if (i < expected_stop_at) {\n+      ASSERT_EQ(it.t[i], t + (NUM_ELEMS - i - 1)) << i; \/\/ we prepended, so FIFO\n+    } else {\n+      ASSERT_NULL(it.t[i]) << i;\n+    }\n+  }\n+}\n+\n+template <class T>\n+static void test_iteration_full()         { test_iteration<T>(false); }\n+\n+template <class T>\n+static void test_iteration_interrupted()  { test_iteration<T>(true); }\n+\n+template <class T>\n+static void test_reset() {\n+  FreeList<T> list;\n+\n+  T t[NUM_ELEMS];\n+  prepare_new_list_with_checks<T>(list, t);\n+\n+  list.reset();\n+  ASSERT_LIST_EMPTY(list);\n+  ASSERT_LIST_PEAK(list, 0); \/\/ Reset also should reset peak\n+  DEBUG_ONLY(list.verify(true);)\n+}\n+\n+template <class T>\n+static void test_take_over() {\n+  FreeList<T> list1;\n+  ASSERT_LIST_EMPTY(list1);\n+\n+  FreeList<T> list2;\n+  T t[NUM_ELEMS];\n+  prepare_new_list_with_checks<T>(list2, t);\n+\n+  list1.take_elements(list2);\n+  ASSERT_LIST_EMPTY(list2);\n+  ASSERT_LIST_COUNT(list1, NUM_ELEMS);\n+  ASSERT_LIST_PEAK(list1, NUM_ELEMS);\n+}\n+\n+template <class T>\n+static void test_prepend_list(bool empty_receiver, bool empty_donor) {\n+  FreeList<T> list1;\n+  FreeList<T> list2;\n+\n+  T t1[NUM_ELEMS];\n+  uintx num1 = 0;\n+  T t2[NUM_ELEMS];\n+  uintx num2 = 0;\n+\n+  if (!empty_receiver) {\n+    prepare_new_list_with_checks<T>(list1, t1);\n+    num1 = NUM_ELEMS;\n+  }\n+\n+  if (!empty_donor) {\n+    prepare_new_list_with_checks<T>(list2, t2);\n+    num2 = NUM_ELEMS;\n+  }\n+\n+  list1.prepend_list(list2);\n+  ASSERT_LIST_COUNT(list1, num1 + num2);\n+  ASSERT_LIST_PEAK(list1, num1 + num2);\n+  DEBUG_ONLY(list1.verify(true);)\n+\n+  ASSERT_LIST_EMPTY(list2);\n+  DEBUG_ONLY(list2.verify(true);)\n+\n+  \/\/ Prepends prepends the list2 elems in front of list1\n+  \/\/ and since prepare_new_list_with_checks also prepends the individual\n+  \/\/ elements, we expect elements to be in inverse address order\n+  for (int i = num2 - 1; i >= 0; i --) {\n+    T* p = list1.take_top();\n+    ASSERT_EQ(p, t2 + i);\n+    ASSERT_LIST_COUNT(list1, num1 + i);\n+  }\n+\n+  for (int i = num1 - 1; i >= 0; i --) {\n+    T* p = list1.take_top();\n+    ASSERT_EQ(p, t1 + i);\n+    ASSERT_LIST_COUNT(list1, i);\n+  }\n+\n+  ASSERT_LIST_COUNT(list1, 0);\n+  ASSERT_LIST_PEAK(list1, num1 + num2);\n+  DEBUG_ONLY(list1.verify(true);)\n+}\n+\n+template <class T> static void test_prepend_list_both_empty()     { test_prepend_list<T>(true, true); }\n+template <class T> static void test_prepend_list_both_nonempty()  { test_prepend_list<T>(false, false); }\n+template <class T> static void test_prepend_list_receiver_empty() { test_prepend_list<T>(true, false); }\n+template <class T> static void test_prepend_list_donor_empty()    { test_prepend_list<T>(false, true); }\n+\n+#define DO_ONE_TEST(T, testname)      \\\n+TEST(FreeList, test_##testname##_##T) \\\n+{                                     \\\n+  testname<T>();                      \\\n+}\n+\n+#define DO_ALL_TESTS(T)                               \\\n+  DO_ONE_TEST(T, test_empty_list)                     \\\n+  DO_ONE_TEST(T, test_single_prepend)                 \\\n+  DO_ONE_TEST(T, test_reset)                          \\\n+  DO_ONE_TEST(T, test_prepend_list_both_empty)        \\\n+  DO_ONE_TEST(T, test_prepend_list_both_nonempty)     \\\n+  DO_ONE_TEST(T, test_prepend_list_receiver_empty)    \\\n+  DO_ONE_TEST(T, test_prepend_list_donor_empty)       \\\n+  DO_ONE_TEST(T, test_iteration_full)                 \\\n+  DO_ONE_TEST(T, test_iteration_interrupted)          \\\n+\n+DO_ALL_TESTS(uint64_t);\n+\n+struct s3 { void* p[3]; };\n+DO_ALL_TESTS(s3);\n+\n+struct s216 { char p[216]; };\n+DO_ALL_TESTS(s216);\n","filename":"test\/hotspot\/gtest\/utilities\/test_freelist.cpp","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/native -agentlib:SuspendWithRawMonitorEnter SuspendWithRawMonitorEnter\n+ * @run main\/othervm\/native -XX:+ErrorFileToStdout -agentlib:SuspendWithRawMonitorEnter SuspendWithRawMonitorEnter\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithRawMonitorEnter\/SuspendWithRawMonitorEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+                \"-XX:MonitorStorageSize=64m\",\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/Allocate\/alloc001\/alloc001.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}