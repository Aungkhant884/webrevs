{"files":[{"patch":"@@ -34,0 +34,7 @@\n+\/\/ Note Lilliput:\n+\/\/ Tests test that vectorization is used to fill destination byte array if alignment allows. That works in Stock VM\n+\/\/ since for both byte[] and long[] members start at the same offset. It does not work in Lilliput, nor would it work\n+\/\/ in stock if we fix \"8139457: Array bases are aligned at HeapWord granularity\", since bytes start at offset 12, long\n+\/\/ at offset 16.\n+\/\/ For now I just enforce -CompactObjectHeaders.\n+\n@@ -58,1 +65,1 @@\n-            TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+            TestFramework.runWithFlags(\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\", \"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorizationMismatchedAccess.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,5 @@\n+\/\/ Note Lilliput:\n+\/\/ Tests rely on array members starting at the same offset, otherwise vectorization does not kick in. Not true\n+\/\/ for Lilliput.\n+\/\/ For now I just enforce -CompactObjectHeaders.\n+\n@@ -82,1 +87,1 @@\n-                                   \"-XX:LoopUnrollLimit=1000\");\n+                                   \"-XX:LoopUnrollLimit=1000\", \"-XX:+UnlockExperimentalVMOptions\", \"-XX:-UseCompactObjectHeaders\");\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}