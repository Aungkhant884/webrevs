{"files":[{"patch":"@@ -80,4 +80,1 @@\n-\n-  markWord old_mark = ObjectSynchronizer::read_stable_mark(obj);\n-  assert(!old_mark.is_being_inflated(), \"must not see INFLATING marker here\");\n-\n+  markWord old_mark = obj->mark();\n@@ -88,4 +85,0 @@\n-  \/\/ Ensure that the copy has the correct mark-word, in case it happened to copy with\n-  \/\/ INFLATING marker.\n-  update->set_mark(old_mark);\n-\n@@ -93,12 +86,6 @@\n-  while (true) {\n-    markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n-    if (prev_mark == old_mark) {\n-      return update;\n-    } else if (prev_mark == markWord::INFLATING()) {\n-      \/\/ This happens when we encounter a stack-locked object in from-space.\n-      \/\/ Busy-wait for completion.\n-      SpinPause();\n-    } else {\n-      assert(prev_mark.is_marked(), \"must be forwarded\");\n-      return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n-    }\n+  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n+  if (prev_mark == old_mark) {\n+    return update;\n+  } else {\n+    assert(prev_mark.is_marked(), \"must be forwarded\");\n+    return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    if (mark.is_neutral()) {\n+    if (mark.is_neutral() || mark.is_fast_locked()) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  assert(header.is_neutral(), \"expect neutral header here\");\n+  assert(header.is_neutral() || header.is_fast_locked(), \"expect neutral or fast-locked header here\");\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3107,0 +3107,3 @@\n+  \/\/ Lilliput requires fast-locking.\n+  FLAG_SET_DEFAULT(UseFastLocking, true);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -920,1 +920,1 @@\n-    assert(mark.is_neutral() || mark.is_marked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    assert(mark.is_neutral() || mark.is_marked() || mark.is_fast_locked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n@@ -1416,1 +1416,1 @@\n-          lsh.print_cr(\"inflate(locked): object=\" INTPTR_FORMAT \", mark=\"\n+          lsh.print_cr(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}