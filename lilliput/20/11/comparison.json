{"files":[{"patch":"@@ -256,0 +256,14 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  __ bind(_entry);\n+  Register res = _result->as_register();\n+  ce->store_parameter(_obj->as_register(), 0);\n+  if (res != r0) {\n+    __ push(RegSet::of(r0), sp);\n+  }\n+  __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::load_klass_id)));\n+  if (res != r0) {\n+    __ mov(res, r0);\n+    __ pop(RegSet::of(r0), sp);\n+  }\n+  __ b(_continuation);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2591,0 +2591,1 @@\n+  Register tmp = rscratch1;\n@@ -2597,6 +2598,14 @@\n-  if (UseCompressedClassPointers) {\n-    __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n-    __ decode_klass_not_null(result);\n-  } else {\n-    __ ldr(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n-  }\n+  assert(UseCompressedClassPointers, \"expects UseCompressedClassPointers\");\n+\n+  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+  __ ldr(tmp, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  __ eor(tmp, tmp, markWord::unlocked_value);\n+  __ tst(tmp, markWord::lock_mask_in_place);\n+  __ br(Assembler::NE, *op->stub()->entry());\n+\n+  \/\/ Fast-path: shift and decode Klass*.\n+  __ mov(result, tmp);\n+  __ lsr(result, result, markWord::klass_shift);\n+  __ decode_klass_not_null(result);\n+\n+  __ bind(*op->stub()->continuation());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -276,2 +276,2 @@\n-static OopMap* save_live_registers(StubAssembler* sasm,\n-                                   bool save_fpu_registers = true) {\n+static void save_live_registers_no_oop_map(StubAssembler* sasm,\n+                                              bool save_fpu_registers = true) {\n@@ -291,0 +291,1 @@\n+}\n@@ -292,0 +293,3 @@\n+static OopMap* save_live_registers(StubAssembler* sasm,\n+                                   bool save_fpu_registers = true) {\n+  save_live_registers_no_oop_map(sasm, save_fpu_registers);\n@@ -718,0 +722,10 @@\n+    case load_klass_id:\n+      {\n+        StubFrame f(sasm, \"load_klass\", dont_gc_arguments);\n+        save_live_registers_no_oop_map(sasm, true);\n+        f.load_argument(0, r0); \/\/ obj\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_klass_runtime), r0);\n+        restore_live_registers_except_r0(sasm, true);\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -246,0 +246,4 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -322,0 +322,4 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -273,0 +273,5 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -303,0 +303,16 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  __ bind(_entry);\n+  Register res = _result->as_register();\n+  ce->store_parameter(_obj->as_register(), 0);\n+  if (res != rax) {\n+    \/\/ This preserves rax and allows it to be used as return-register,\n+    \/\/ without messing with the stack.\n+    __ xchgptr(rax, res);\n+  }\n+  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_klass_id)));\n+  if (res != rax) {\n+    \/\/ Swap back rax, and move result to correct register.\n+    __ xchgptr(rax, res);\n+  }\n+  __ jmp(_continuation);\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -3528,3 +3528,2 @@\n-  CodeEmitInfo* info = op->info();\n-  if (info != NULL) {\n-    add_debug_info_for_null_check_here(info);\n+  if (op->info() != NULL) {\n+    add_debug_info_for_null_check_here(op->info());\n@@ -3532,1 +3531,0 @@\n-\n@@ -3534,4 +3532,16 @@\n-  if (UseCompressedClassPointers) {\n-    __ movl(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-    __ decode_klass_not_null(result, rscratch1);\n-  } else\n+  Register tmp = rscratch1;\n+  assert_different_registers(tmp, obj);\n+  assert_different_registers(tmp, result);\n+\n+  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+  __ movq(tmp, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  __ xorq(tmp, markWord::unlocked_value);\n+  __ testb(tmp, markWord::lock_mask_in_place);\n+  __ jcc(Assembler::notZero, *op->stub()->entry());\n+\n+  \/\/ Fast-path: shift and decode Klass*.\n+  __ movq(result, tmp);\n+  __ shrq(result, markWord::klass_shift);\n+  __ decode_klass_not_null(result, tmp);\n+#else\n+  __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n@@ -3539,1 +3549,0 @@\n-    __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":18,"deletions":9,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1114,1 +1114,11 @@\n-\n+#ifdef _LP64\n+    case load_klass_id:\n+      {\n+        StubFrame f(sasm, \"load_klass\", dont_gc_arguments);\n+        sasm->save_live_registers_no_oop_map(true);\n+        f.load_argument(0, c_rarg0); \/\/ obj\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_klass_runtime), c_rarg0);\n+        sasm->restore_live_registers_except_rax(true);\n+      }\n+      break;\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -552,0 +552,19 @@\n+class LoadKlassStub: public CodeStub {\n+private:\n+  LIR_Opr          _obj;\n+  LIR_Opr          _result;\n+\n+public:\n+  LoadKlassStub(LIR_Opr obj, LIR_Opr result) :\n+    CodeStub(), _obj(obj), _result(result) {};\n+\n+  virtual void emit_code(LIR_Assembler* e);\n+  virtual void visit(LIR_OpVisitState* visitor) {\n+    visitor->do_input(_obj);\n+    visitor->do_output(_result);\n+  }\n+#ifndef PRODUCT\n+virtual void print_name(outputStream* out) const { out->print(\"LoadKlassStub\"); }\n+#endif \/\/ PRODUCT\n+};\n+\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -885,0 +885,1 @@\n+      do_stub(opLoadKlass->_stub);\n@@ -1061,0 +1062,1 @@\n+  masm->append_code_stub(stub());\n@@ -1981,0 +1983,1 @@\n+  out->print(\"[lbl:\" INTPTR_FORMAT \"]\", p2i(stub()->entry()));\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1831,0 +1831,1 @@\n+  CodeStub* _stub;\n@@ -1832,1 +1833,1 @@\n-  LIR_OpLoadKlass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info)\n+  LIR_OpLoadKlass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info, CodeStub* stub)\n@@ -1835,1 +1836,1 @@\n-    {}\n+    , _stub(stub) {}\n@@ -1838,0 +1839,1 @@\n+  CodeStub* stub()     const { return _stub; }\n@@ -2286,1 +2288,1 @@\n-  void load_klass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info) { append(new LIR_OpLoadKlass(obj, result, info)); }\n+  void load_klass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info, CodeStub* stub) { append(new LIR_OpLoadKlass(obj, result, info, stub)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1235,1 +1235,3 @@\n-  __ load_klass(obj, klass, null_check_info);\n+  CodeStub* slow_path = new LoadKlassStub(obj, klass);\n+  __ load_klass(obj, klass, null_check_info, slow_path);\n+  __ branch_destination(slow_path->continuation());\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -241,0 +241,1 @@\n+  case load_klass_id:\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  stub(load_klass)                   \\\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -180,1 +180,3 @@\n-  return oop(o)->klass();\n+  oop obj = oop(o);\n+  assert(oopDesc::is_oop(obj), \"need a valid oop here: \" PTR_FORMAT, p2i(o));\n+  return obj->klass();\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -377,0 +377,1 @@\n+    assert(header.is_marked(), \"only decode when actually forwarded\");\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}