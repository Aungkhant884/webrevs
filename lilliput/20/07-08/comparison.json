{"files":[{"patch":"@@ -257,1 +257,12 @@\n-  \/\/ Currently not needed.\n+  __ bind(_entry);\n+  Register res = _result->as_register();\n+  ce->store_parameter(_obj->as_register(), 0);\n+  if (res != r0) {\n+    __ push(RegSet::of(r0), sp);\n+  }\n+  __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::load_klass_id)));\n+  if (res != r0) {\n+    __ mov(res, r0);\n+    __ pop(RegSet::of(r0), sp);\n+  }\n+  __ b(_continuation);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2587,0 +2587,1 @@\n+  Register tmp = rscratch1;\n@@ -2593,6 +2594,14 @@\n-  if (UseCompressedClassPointers) {\n-    __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n-    __ decode_klass_not_null(result);\n-  } else {\n-    __ ldr(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n-  }\n+  assert(UseCompressedClassPointers, \"expects UseCompressedClassPointers\");\n+\n+  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+  __ ldr(tmp, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  __ eor(tmp, tmp, markWord::unlocked_value);\n+  __ tst(tmp, markWord::lock_mask_in_place);\n+  __ br(Assembler::NE, *op->stub()->entry());\n+\n+  \/\/ Fast-path: shift and decode Klass*.\n+  __ mov(result, tmp);\n+  __ lsr(result, result, markWord::klass_shift);\n+  __ decode_klass_not_null(result);\n+\n+  __ bind(*op->stub()->continuation());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -276,2 +276,2 @@\n-static OopMap* save_live_registers(StubAssembler* sasm,\n-                                   bool save_fpu_registers = true) {\n+static void save_live_registers_no_oop_map(StubAssembler* sasm,\n+                                              bool save_fpu_registers = true) {\n@@ -291,0 +291,1 @@\n+}\n@@ -292,0 +293,3 @@\n+static OopMap* save_live_registers(StubAssembler* sasm,\n+                                   bool save_fpu_registers = true) {\n+  save_live_registers_no_oop_map(sasm, save_fpu_registers);\n@@ -718,0 +722,10 @@\n+    case load_klass_id:\n+      {\n+        StubFrame f(sasm, \"load_klass\", dont_gc_arguments);\n+        save_live_registers_no_oop_map(sasm, true);\n+        f.load_argument(0, r0); \/\/ obj\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_klass_runtime), r0);\n+        restore_live_registers_except_r0(sasm, true);\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -306,1 +306,0 @@\n-  assert(res == rax, \"need result to be in rax\");\n@@ -308,0 +307,5 @@\n+  if (res != rax) {\n+    \/\/ This preserves rax and allows it to be used as return-register,\n+    \/\/ without messing with the stack.\n+    __ xchgptr(rax, res);\n+  }\n@@ -309,0 +313,4 @@\n+  if (res != rax) {\n+    \/\/ Swap back rax, and move result to correct register.\n+    __ xchgptr(rax, res);\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3523,1 +3523,0 @@\n-  assert(result == rax, \"need result to be in rax\");\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-    case metaDataTag: opr = FrameMap::rax_metadata_opr;break;\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRGenerator_x86.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1255,1 +1255,1 @@\n-  LIR_Opr klass = result_register_for(as_ValueType(T_METADATA));\n+  LIR_Opr klass = new_register(T_METADATA);\n@@ -1329,1 +1329,1 @@\n-  LIR_Opr klass = result_register_for(as_ValueType(T_METADATA));\n+  LIR_Opr klass = new_register(T_METADATA);\n@@ -3579,1 +3579,1 @@\n-  LIR_Opr klass = result_register_for(as_ValueType(T_METADATA));\n+  LIR_Opr klass = new_register(T_METADATA);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-MetadataType*   metadataType = NULL;\n@@ -69,1 +68,0 @@\n-  metadataType = new (arena) MetadataType();\n@@ -135,1 +133,0 @@\n-    case T_METADATA:return metadataType;\n","filename":"src\/hotspot\/share\/c1\/c1_ValueType.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -333,1 +333,1 @@\n-    LIR_Opr src_klass = gen->result_register_for(as_ValueType(T_METADATA));\n+    LIR_Opr src_klass = gen->new_register(T_METADATA);\n","filename":"src\/hotspot\/share\/gc\/shared\/c1\/barrierSetC1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}