{"files":[{"patch":"@@ -114,1 +114,1 @@\n-  assert(dest_attr.is_in_cset() == (obj->forwardee() == obj),\n+  assert(dest_attr.is_in_cset() == (obj->is_forwarded() && obj->forwardee() == obj),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"jfr\/leakprofiler\/sampling\/objectSample.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -39,9 +41,0 @@\n-EdgeStore::EdgeStore() : _edges(NULL) {\n-  _edges = new EdgeHashTable(this);\n-}\n-\n-EdgeStore::~EdgeStore() {\n-  assert(_edges != NULL, \"invariant\");\n-  delete _edges;\n-}\n-\n@@ -227,1 +220,69 @@\n-\/\/ Install the immediate edge into the mark word of the leak candidate object\n+static GrowableArray<const StoredEdge*>* _leak_context_edges = nullptr;\n+\n+EdgeStore::EdgeStore() : _edges(new EdgeHashTable(this)) {}\n+\n+EdgeStore::~EdgeStore() {\n+  assert(_edges != NULL, \"invariant\");\n+  delete _edges;\n+  delete _leak_context_edges;\n+  _leak_context_edges = nullptr;\n+}\n+\n+static int leak_context_edge_idx(const ObjectSample* sample) {\n+  assert(sample != nullptr, \"invariant\");\n+  return static_cast<int>(sample->object()->mark().value()) >> markWord::lock_bits;\n+}\n+\n+bool EdgeStore::has_leak_context(const ObjectSample* sample) const {\n+  return leak_context_edge_idx(sample) != 0;\n+}\n+\n+const StoredEdge* EdgeStore::get(const ObjectSample* sample) const {\n+  assert(sample != nullptr, \"invariant\");\n+  if (_leak_context_edges != nullptr) {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+    const int idx = leak_context_edge_idx(sample);\n+    if (idx > 0) {\n+      return _leak_context_edges->at(idx);\n+    }\n+  }\n+  return get(UnifiedOopRef::encode_in_native(sample->object_addr()));\n+}\n+\n+#ifdef ASSERT\n+\/\/ max_idx to ensure idx fit in lower 32-bits of markword together with lock bits.\n+static constexpr const int max_idx =  right_n_bits(32 - markWord::lock_bits);\n+\n+static void store_idx_precondition(oop sample_object, int idx) {\n+  assert(sample_object != NULL, \"invariant\");\n+  assert(sample_object->mark().is_marked(), \"invariant\");\n+  assert(idx > 0, \"invariant\");\n+  assert(idx <= max_idx, \"invariant\");\n+}\n+#endif\n+\n+static void store_idx_in_markword(oop sample_object, int idx) {\n+  DEBUG_ONLY(store_idx_precondition(sample_object, idx);)\n+  const markWord idx_mark_word(sample_object->mark().value() | idx << markWord::lock_bits);\n+  sample_object->set_mark(idx_mark_word);\n+  assert(sample_object->mark().is_marked(), \"must still be marked\");\n+}\n+\n+static const int initial_size = 64;\n+\n+static int save(const StoredEdge* edge) {\n+  assert(edge != nullptr, \"invariant\");\n+  if (_leak_context_edges == nullptr) {\n+    _leak_context_edges = new (ResourceObj::C_HEAP, mtTracing)GrowableArray<const StoredEdge*>(initial_size, mtTracing);\n+    _leak_context_edges->append(nullptr); \/\/ next idx now at 1, for disambiguation in markword.\n+  }\n+  return _leak_context_edges->append(edge);\n+}\n+\n+\/\/ We associate the leak context edge with the leak candidate object by saving the\n+\/\/ edge in an array and storing the array idx (shifted) into the markword of the candidate object.\n+static void associate_with_candidate(const StoredEdge* leak_context_edge) {\n+  assert(leak_context_edge != nullptr, \"invariant\");\n+  store_idx_in_markword(leak_context_edge->pointee(), save(leak_context_edge));\n+}\n+\n@@ -232,4 +293,1 @@\n-  oop sample_object = edge->pointee();\n-  assert(sample_object != NULL, \"invariant\");\n-  assert(sample_object->mark().is_marked(), \"invariant\");\n-  sample_object->set_mark(markWord::from_pointer(leak_context_edge));\n+  associate_with_candidate(leak_context_edge);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.cpp","additions":73,"deletions":15,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+class ObjectSample;\n@@ -82,0 +83,1 @@\n+  const StoredEdge* get(const ObjectSample* sample) const;\n@@ -93,0 +95,1 @@\n+  bool has_leak_context(const ObjectSample* sample) const;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-    _store->push(ObjectSampleMarkWord(obj, obj->mark()));\n+    markWord mark = obj->mark();\n+    _store->push(ObjectSampleMarkWord(obj, mark));\n@@ -73,1 +74,6 @@\n-    obj->set_mark(markWord::prototype().set_marked());\n+#ifdef _LP64\n+    if (mark.has_displaced_mark_helper()) {\n+      mark = mark.displaced_mark_helper();\n+    }\n+#endif\n+    obj->set_mark(markWord::prototype().set_marked() LP64_ONLY(.set_narrow_klass(mark.narrow_klass())));\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/objectSampleMarker.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-    if (!sample->object()->mark().is_marked()) {\n+    if (edge_store->has_leak_context(sample)) {\n@@ -141,12 +141,1 @@\n-  traceid gc_root_id = 0;\n-  const Edge* edge = NULL;\n-  if (SafepointSynchronize::is_at_safepoint()) {\n-    if (!sample->object()->mark().is_marked()) {\n-      edge = (const Edge*)(sample->object())->mark().to_pointer();\n-    }\n-  }\n-  if (edge == NULL) {\n-    edge = edge_store->get(UnifiedOopRef::encode_in_native(sample->object_addr()));\n-  } else {\n-    gc_root_id = edge_store->gc_root_id(edge);\n-  }\n+  const StoredEdge* const edge = edge_store->get(sample);\n@@ -154,0 +143,1 @@\n+  assert(edge->pointee() == sample->object(), \"invariant\");\n@@ -156,0 +146,1 @@\n+  const traceid gc_root_id = edge->gc_root_id();\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"}]}