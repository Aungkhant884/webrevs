{"files":[{"patch":"@@ -79,0 +79,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -89,2 +90,0 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -1525,2 +1524,0 @@\n-  _forwarding = new SlidingForwarding(heap_rs.region(), HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n-\n@@ -1676,0 +1673,3 @@\n+  auto addr_to_idx = [](const void* addr) { return (size_t)G1CollectedHeap::heap()->addr_to_region(addr); };\n+  GCForwarding::initialize(addr_to_idx, max_regions());\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,0 @@\n-class SlidingForwarding;\n@@ -256,2 +255,0 @@\n-  SlidingForwarding* _forwarding;\n-\n@@ -271,4 +268,0 @@\n-  SlidingForwarding* forwarding() const {\n-    return _forwarding;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -211,0 +211,1 @@\n+  GCForwarding::begin();\n@@ -223,0 +224,2 @@\n+  GCForwarding::end();\n+\n@@ -334,2 +337,0 @@\n-  _heap->forwarding()->clear();\n-\n@@ -347,4 +348,3 @@\n-  \/\/ TODO: Disabled for now because it violates sliding-forwarding assumption.\n-\/\/  if (scope()->do_maximal_compaction() || !has_free_compaction_targets) {\n-\/\/    phase2c_prepare_serial_compaction();\n-\/\/  }\n+  if (scope()->do_maximal_compaction() || !has_free_compaction_targets) {\n+    phase2c_prepare_serial_compaction();\n+  }\n@@ -369,55 +369,55 @@\n-\/\/uint G1FullCollector::truncate_parallel_cps() {\n-\/\/  uint lowest_current = (uint)-1;\n-\/\/  for (uint i = 0; i < workers(); i++) {\n-\/\/    G1FullGCCompactionPoint* cp = compaction_point(i);\n-\/\/    if (cp->has_regions()) {\n-\/\/      lowest_current = MIN2(lowest_current, cp->current_region()->hrm_index());\n-\/\/    }\n-\/\/  }\n-\n-\/\/  for (uint i = 0; i < workers(); i++) {\n-\/\/    G1FullGCCompactionPoint* cp = compaction_point(i);\n-\/\/    if (cp->has_regions()) {\n-\/\/      cp->remove_at_or_above(lowest_current);\n-\/\/    }\n-\/\/  }\n-\/\/  return lowest_current;\n-\/\/}\n-\n-\/\/void G1FullCollector::phase2c_prepare_serial_compaction() {\n-\/\/  GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare serial compaction\", scope()->timer());\n-\/\/  \/\/ At this point, we know that after parallel compaction there will be regions that\n-\/\/  \/\/ are partially compacted into. Thus, the last compaction region of all\n-\/\/  \/\/ compaction queues still have space in them. We try to re-compact these regions\n-\/\/  \/\/ in serial to avoid a premature OOM when the mutator wants to allocate the first\n-\/\/  \/\/ eden region after gc.\n-\/\/\n-\/\/  \/\/ For maximum compaction, we need to re-prepare all objects above the lowest\n-\/\/  \/\/ region among the current regions for all thread compaction points. It may\n-\/\/  \/\/ happen that due to the uneven distribution of objects to parallel threads, holes\n-\/\/  \/\/ have been created as threads compact to different target regions between the\n-\/\/  \/\/ lowest and the highest region in the tails of the compaction points.\n-\/\/\n-\/\/  uint start_serial = truncate_parallel_cps();\n-\/\/  assert(start_serial < _heap->max_reserved_regions(), \"Called on empty parallel compaction queues\");\n-\/\/\n-\/\/  G1FullGCCompactionPoint* serial_cp = serial_compaction_point();\n-\/\/  assert(!serial_cp->is_initialized(), \"sanity!\");\n-\/\/\n-\/\/  HeapRegion* start_hr = _heap->region_at(start_serial);\n-\/\/  serial_cp->add(start_hr);\n-\/\/  serial_cp->initialize(start_hr);\n-\/\/\n-\/\/  HeapWord* dense_prefix_top = compaction_top(start_hr);\n-\/\/  G1SerialRePrepareClosure re_prepare(serial_cp, dense_prefix_top);\n-\/\/\n-\/\/  for (uint i = start_serial + 1; i < _heap->max_reserved_regions(); i++) {\n-\/\/    if (is_compaction_target(i)) {\n-\/\/      HeapRegion* current = _heap->region_at(i);\n-\/\/      set_compaction_top(current, current->bottom());\n-\/\/      serial_cp->add(current);\n-\/\/      current->apply_to_marked_objects(mark_bitmap(), &re_prepare);\n-\/\/    }\n-\/\/  }\n-\/\/  serial_cp->update();\n-\/\/}\n+uint G1FullCollector::truncate_parallel_cps() {\n+  uint lowest_current = (uint)-1;\n+  for (uint i = 0; i < workers(); i++) {\n+    G1FullGCCompactionPoint* cp = compaction_point(i);\n+    if (cp->has_regions()) {\n+      lowest_current = MIN2(lowest_current, cp->current_region()->hrm_index());\n+    }\n+  }\n+\n+  for (uint i = 0; i < workers(); i++) {\n+    G1FullGCCompactionPoint* cp = compaction_point(i);\n+    if (cp->has_regions()) {\n+      cp->remove_at_or_above(lowest_current);\n+    }\n+  }\n+  return lowest_current;\n+}\n+\n+void G1FullCollector::phase2c_prepare_serial_compaction() {\n+  GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare serial compaction\", scope()->timer());\n+  \/\/ At this point, we know that after parallel compaction there will be regions that\n+  \/\/ are partially compacted into. Thus, the last compaction region of all\n+  \/\/ compaction queues still have space in them. We try to re-compact these regions\n+  \/\/ in serial to avoid a premature OOM when the mutator wants to allocate the first\n+  \/\/ eden region after gc.\n+\n+  \/\/ For maximum compaction, we need to re-prepare all objects above the lowest\n+  \/\/ region among the current regions for all thread compaction points. It may\n+  \/\/ happen that due to the uneven distribution of objects to parallel threads, holes\n+  \/\/ have been created as threads compact to different target regions between the\n+  \/\/ lowest and the highest region in the tails of the compaction points.\n+\n+  uint start_serial = truncate_parallel_cps();\n+  assert(start_serial < _heap->max_reserved_regions(), \"Called on empty parallel compaction queues\");\n+\n+  G1FullGCCompactionPoint* serial_cp = serial_compaction_point();\n+  assert(!serial_cp->is_initialized(), \"sanity!\");\n+\n+  HeapRegion* start_hr = _heap->region_at(start_serial);\n+  serial_cp->add(start_hr);\n+  serial_cp->initialize(start_hr);\n+\n+  HeapWord* dense_prefix_top = compaction_top(start_hr);\n+  G1SerialRePrepareClosure re_prepare(serial_cp, dense_prefix_top);\n+\n+  for (uint i = start_serial + 1; i < _heap->max_reserved_regions(); i++) {\n+    if (is_compaction_target(i)) {\n+      HeapRegion* current = _heap->region_at(i);\n+      set_compaction_top(current, current->bottom());\n+      serial_cp->add(current);\n+      current->apply_to_marked_objects(mark_bitmap(), &re_prepare);\n+    }\n+  }\n+  serial_cp->update();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":62,"deletions":62,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -97,2 +97,1 @@\n-  const SlidingForwarding* const forwarding = G1CollectedHeap::heap()->forwarding();\n-  marker->preserved_stack()->adjust_during_full_gc(forwarding);\n+  marker->preserved_stack()->adjust_during_full_gc();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -45,2 +45,2 @@\n-  if (obj->is_forwarded()) {\n-    HeapWord* destination = cast_from_oop<HeapWord*>(_forwarding->forwardee(obj));\n+  if (GCForwarding::is_forwarded(obj)) {\n+    HeapWord* destination = cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class SlidingForwarding;\n@@ -55,1 +54,0 @@\n-    const SlidingForwarding* const _forwarding;\n@@ -58,3 +56,1 @@\n-    G1CompactRegionClosure(G1CMBitMap* bitmap) :\n-      _bitmap(bitmap),\n-      _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n+    G1CompactRegionClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -95,1 +95,1 @@\n-void G1FullGCCompactionPoint::forward(SlidingForwarding* const forwarding, oop object, size_t size) {\n+void G1FullGCCompactionPoint::forward(oop object, size_t size) {\n@@ -105,2 +105,2 @@\n-    forwarding->forward_to(object, cast_to_oop(_compaction_top));\n-    assert(object->is_forwarded(), \"must be forwarded\");\n+    GCForwarding::forward_to(object, cast_to_oop(_compaction_top));\n+    assert(GCForwarding::is_forwarded(object), \"must be forwarded\");\n@@ -108,1 +108,1 @@\n-    assert(!object->is_forwarded(), \"must not be forwarded\");\n+    assert(!GCForwarding::is_forwarded(object), \"must not be forwarded\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-class SlidingForwarding;\n@@ -56,1 +55,1 @@\n-  void forward(SlidingForwarding* const forwarding, oop object, size_t size);\n+  void forward(oop object, size_t size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -36,1 +35,0 @@\n-class SlidingForwarding;\n@@ -80,1 +78,0 @@\n-  const SlidingForwarding* const _forwarding;\n@@ -84,3 +81,1 @@\n-  G1AdjustClosure(G1FullCollector* collector) :\n-    _collector(collector),\n-    _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n+  G1AdjustClosure(G1FullCollector* collector) : _collector(collector) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -69,2 +69,2 @@\n-  if (obj->is_forwarded()) {\n-    oop forwardee = _forwarding->forwardee(obj);\n+  if (GCForwarding::is_forwarded(obj)) {\n+    oop forwardee = GCForwarding::forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -111,1 +110,1 @@\n-    _cp(cp), _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n+    _cp(cp) { }\n@@ -115,1 +114,1 @@\n-  _cp->forward(_forwarding, object, size);\n+  _cp->forward(object, size);\n@@ -121,0 +120,1 @@\n+    GCForwarding::begin_region(hr->hrm_index(), _bitmap->count_marked(MemRegion(hr->bottom(), hr->top())));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class SlidingForwarding;\n@@ -96,1 +95,0 @@\n-    SlidingForwarding* const _forwarding;\n@@ -106,11 +104,11 @@\n-\/\/class G1SerialRePrepareClosure : public StackObj {\n-\/\/  G1FullGCCompactionPoint* _cp;\n-\/\/  HeapWord* _dense_prefix_top;\n-\/\/\n-\/\/public:\n-\/\/  G1SerialRePrepareClosure(G1FullGCCompactionPoint* hrcp, HeapWord* dense_prefix_top) :\n-\/\/    _cp(hrcp),\n-\/\/    _dense_prefix_top(dense_prefix_top) { }\n-\/\/\n-\/\/  inline size_t apply(oop obj);\n-\/\/};\n+class G1SerialRePrepareClosure : public StackObj {\n+  G1FullGCCompactionPoint* _cp;\n+  HeapWord* _dense_prefix_top;\n+\n+public:\n+  G1SerialRePrepareClosure(G1FullGCCompactionPoint* hrcp, HeapWord* dense_prefix_top) :\n+    _cp(hrcp),\n+    _dense_prefix_top(dense_prefix_top) { }\n+\n+  inline size_t apply(oop obj);\n+};\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -114,15 +114,15 @@\n-\/\/inline size_t G1SerialRePrepareClosure::apply(oop obj) {\n-\/\/  if (obj->is_forwarded()) {\n-\/\/    \/\/ We skip objects compiled into the first region or\n-\/\/    \/\/ into regions not part of the serial compaction point.\n-\/\/    if (cast_from_oop<HeapWord*>(obj->forwardee()) < _dense_prefix_top) {\n-\/\/      return obj->size();\n-\/\/    }\n-\/\/  }\n-\/\/\n-\/\/  \/\/ Get size and forward.\n-\/\/  size_t size = obj->size();\n-\/\/  _cp->forward(obj, size);\n-\/\/\n-\/\/  return size;\n-\/\/}\n+inline size_t G1SerialRePrepareClosure::apply(oop obj) {\n+  if (GCForwarding::is_forwarded(obj)) {\n+    \/\/ We skip objects compiled into the first region or\n+    \/\/ into regions not part of the serial compaction point.\n+    if (cast_from_oop<HeapWord*>(GCForwarding::forwardee(obj)) < _dense_prefix_top) {\n+      return obj->size();\n+    }\n+  }\n+\n+  \/\/ Get size and forward.\n+  size_t size = obj->size();\n+  _cp->forward(obj, size);\n+\n+  return size;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -838,1 +838,10 @@\n-    from()->set_next_compaction_space(to());\n+    \/\/ Ensure that compaction spaces are in address-order.\n+    if (from()->bottom() < to()->bottom()) {\n+      eden()->set_next_compaction_space(from());\n+      from()->set_next_compaction_space(to());\n+      to()->set_next_compaction_space(nullptr);\n+    } else {\n+      eden()->set_next_compaction_space(to());\n+      to()->set_next_compaction_space(from());\n+      from()->set_next_compaction_space(nullptr);\n+    }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -95,0 +96,4 @@\n+  GCForwarding::begin();\n+  GCForwarding::begin_region(0, _young_marked_objects);\n+  GCForwarding::begin_region(1, _old_marked_objects);\n+\n@@ -107,0 +112,2 @@\n+  GCForwarding::end();\n+\n@@ -183,0 +190,3 @@\n+  _young_marked_objects = 0;\n+  _old_marked_objects = 0;\n+\n@@ -259,2 +269,0 @@\n-  AdjustPointerClosure adjust_pointer_closure(gch->forwarding());\n-  CLDToOopClosure      adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -33,0 +32,1 @@\n+#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -67,0 +67,1 @@\n+CLDToOopClosure    MarkSweep::adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_stw_fullgc_adjust);\n@@ -148,2 +149,2 @@\n-void PreservedMark::adjust_pointer(const SlidingForwarding* const forwarding) {\n-  MarkSweep::adjust_pointer(forwarding, &_obj);\n+void PreservedMark::adjust_pointer() {\n+  MarkSweep::adjust_pointer(&_obj);\n@@ -205,0 +206,6 @@\n+\n+  if (GenCollectedHeap::heap()->is_in_young(obj)) {\n+    _young_marked_objects++;\n+  } else {\n+    _old_marked_objects++;\n+  }\n@@ -223,2 +230,1 @@\n-void MarkSweep::adjust_marks() {\n-  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n+AdjustPointerClosure MarkSweep::adjust_pointer_closure;\n@@ -226,0 +232,1 @@\n+void MarkSweep::adjust_marks() {\n@@ -228,1 +235,1 @@\n-    _preserved_marks[i].adjust_pointer(forwarding);\n+    _preserved_marks[i].adjust_pointer();\n@@ -235,1 +242,1 @@\n-    p->adjust_pointer(forwarding);\n+    p->adjust_pointer();\n@@ -260,0 +267,3 @@\n+size_t MarkSweep::_young_marked_objects = 0;\n+size_t MarkSweep::_old_marked_objects = 0;\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-class SlidingForwarding;\n@@ -119,1 +118,4 @@\n- public:\n+  static size_t _young_marked_objects;\n+  static size_t _old_marked_objects;\n+\n+public:\n@@ -128,0 +130,2 @@\n+  static AdjustPointerClosure adjust_pointer_closure;\n+  static CLDToOopClosure      adjust_cld_closure;\n@@ -144,1 +148,1 @@\n-  static size_t adjust_pointers(const SlidingForwarding* const forwarding, oop obj);\n+  static size_t adjust_pointers(oop obj);\n@@ -148,1 +152,1 @@\n-  template <class T> static inline void adjust_pointer(const SlidingForwarding* const forwarding, T* p);\n+  template <class T> static inline void adjust_pointer(T* p);\n@@ -182,2 +186,0 @@\n-private:\n-  const SlidingForwarding* const _forwarding;\n@@ -185,1 +187,0 @@\n-  AdjustPointerClosure(const SlidingForwarding* forwarding) : _forwarding(forwarding) {}\n@@ -199,1 +200,1 @@\n-  void adjust_pointer(const SlidingForwarding* const forwarding);\n+  void adjust_pointer();\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -43,1 +43,1 @@\n-template <class T> inline void MarkSweep::adjust_pointer(const SlidingForwarding* const forwarding, T* p) {\n+template <class T> inline void MarkSweep::adjust_pointer(T* p) {\n@@ -49,4 +49,2 @@\n-    markWord header = obj->mark();\n-    if (header.is_marked()) {\n-      oop new_obj = forwarding->forwardee(obj);\n-      assert(new_obj != NULL, \"must be forwarded\");\n+    if (GCForwarding::is_forwarded(obj)) {\n+      oop new_obj = GCForwarding::forwardee(obj);\n@@ -60,1 +58,1 @@\n-void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(_forwarding, p); }\n+void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(p); }\n@@ -64,3 +62,2 @@\n-inline size_t MarkSweep::adjust_pointers(const SlidingForwarding* const forwarding, oop obj) {\n-  AdjustPointerClosure cl(forwarding);\n-  return obj->oop_iterate_size(&cl);\n+inline size_t MarkSweep::adjust_pointers(oop obj) {\n+  return obj->oop_iterate_size(&MarkSweep::adjust_pointer_closure);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/forwardingTable.hpp\"\n+\n+PerRegionTable::PerRegionTable() : _used(false), _num_forwardings(0), _insertion_idx(0), _table(nullptr) {\n+}\n+\n+PerRegionTable::~PerRegionTable() {\n+  if (_table != nullptr) {\n+    FREE_C_HEAP_ARRAY(FwdTableEntry, _table);\n+  }\n+}\n+\n+void PerRegionTable::initialize(intx num_forwardings) {\n+  assert(!_used, \"init per-region table only once\");\n+  _used = true;\n+  _num_forwardings = num_forwardings;\n+  _insertion_idx = 0;\n+  _table = NEW_C_HEAP_ARRAY(FwdTableEntry, num_forwardings, mtGC);\n+  for (intx i = 0; i < num_forwardings; i++) {\n+    _table[i] = FwdTableEntry();\n+  }\n+}\n+\n+void ForwardingTable::begin() {\n+  assert(_table == nullptr, \"must not have been initialized\");\n+  _table = NEW_C_HEAP_ARRAY(PerRegionTable, _max_regions, mtGC);\n+  for (size_t i = 0; i < _max_regions; i++) {\n+    _table[i] = PerRegionTable();\n+  }\n+}\n+\n+void ForwardingTable::begin_region(size_t idx, size_t num_forwardings) {\n+  assert(_table != nullptr, \"must have been initialized\");\n+  _table[idx].initialize(num_forwardings);\n+}\n+\n+void ForwardingTable::end() {\n+  assert(_table != nullptr, \"must have been initialized\");\n+  for (size_t i = 0; i < _max_regions; i++) {\n+    _table[i].~PerRegionTable();\n+  }\n+  FREE_C_HEAP_ARRAY(PerRegionTable, _table);\n+  _table = nullptr;\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/forwardingTable.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_FORWARDINGTABLE_HPP\n+#define SHARE_GC_SHARED_FORWARDINGTABLE_HPP\n+\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/\/ TODO: Address range and num-regions permitting, we could switch to\n+\/\/ a more compact encoding:\n+\/\/ - N bits to encode number of words from start of from region\n+\/\/ - M bits to encode number of words from start of to-region\n+\/\/ - X bits to encode to-region index\n+\/\/ from-region index is known implicitely.\n+\/\/ For example, we could do M = N = 24 bits and X = 16 bits.\n+class FwdTableEntry {\n+private:\n+  HeapWord* _from;\n+  HeapWord* _to;\n+public:\n+  FwdTableEntry() : _from(nullptr), _to(nullptr) {}\n+  HeapWord* from() const { return _from; }\n+  HeapWord* to()   const { return _to;   }\n+\n+  inline void forward_to(HeapWord* from, HeapWord* to);\n+};\n+\n+\/*\n+ * The actual per-region forwarding table.\n+ *\/\n+class PerRegionTable : public CHeapObj<mtGC> {\n+private:\n+  bool _used;\n+  intx _num_forwardings;\n+  intx _insertion_idx;\n+  FwdTableEntry* _table;\n+\n+  inline intx lookup(HeapWord* from);\n+  inline void reforward(HeapWord* from, HeapWord* to);\n+\n+public:\n+  PerRegionTable();\n+  void initialize(intx num_forwardings);\n+  ~PerRegionTable();\n+  inline void forward_to(HeapWord* from, HeapWord* to);\n+  inline HeapWord* forwardee(HeapWord* from);\n+};\n+\n+\/*\n+ * A forwarding-table implementation that's used by several full (sliding-) GCs.\n+ * It exploits a number of properties:\n+ * - Adding forwardings is single-threaded per region.\n+ * - Adding forwarding happens in sequential order, except in some exceptional situations.\n+ * - We know in advance how many forwardings we are going to insert.\n+ * - Forwardings are never removed, except wholesale when we're done.\n+*\n+ * We maintain a number of per-region forwarding tables, one per region. These can\n+ * easily be indexed by region-number. In order for this to work, the GC must pass\n+ * a function pointer to the fwd table which finds the region that contains a given\n+ * oop.\n+ *\n+ * Each per-region table is essentially a dense array of forwarding entries which are\n+ * (oop, oop) - tuples. Each table holds exactly N entries, where N is the number\n+ * of forwardings in the region. Entries in the table are always sorted by\n+ * original (from-) address of the forwarding entries.\n+ *\n+ * Insertion of new forwardings usually happens in sequential order, which makes\n+ * insertion trivial in these very common cases. The single exception is G1 serial\n+ * compaction, which is a last-last-ditch attempt to squeeze out some more space. In\n+ * this case we accept that we need to insert entries in the middle and copy all\n+ * subsequent entries upwards.\n+ *\n+ * Lookup is a straightforward binary search of entries.\n+ *\n+ * It is important that code that wishes to use this forwarding table follow this lifecycle:\n+ * - Allocate the ForwardingTable once, e.g. when the CollectedHeap is initialized.\n+ *   This establishes how many regions will be used at maximum and also establishes the\n+ *   fuction which maps heap addresses to region indices.\n+ * - When forwarding starts, call begin(). This initializes the array that holds the per-region\n+ *   tables.\n+ * - When forwarding of a particular region starts (usually by a GC worker thread), call\n+ *   begin_region(). This initializes the corresponding per-region table.\n+ * - Insert and look-up forwardings.\n+ * - When forwaring is finished, call end(). This will dispose all internal data structures.\n+ *\/\n+class ForwardingTable : public CHeapObj<mtGC> {\n+private:\n+  AddrToIdxFn const _addr_to_idx;\n+  size_t const _max_regions;\n+\n+  PerRegionTable* _table;\n+\n+public:\n+  ForwardingTable(AddrToIdxFn addr_to_idx, size_t max_regions): _addr_to_idx(addr_to_idx), _max_regions(max_regions), _table(nullptr) {}\n+\n+  void begin();\n+  void begin_region(size_t idx, size_t num_forwardings);\n+  void end();\n+\n+  inline void forward_to(oop from, oop to);\n+  inline oop forwardee(oop from);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_FORWARDINGABLE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/forwardingTable.hpp","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_FORWARDINGTABLE_INLINE_HPP\n+#define SHARE_GC_SHARED_FORWARDINGTABLE_INLINE_HPP\n+\n+#include \"gc\/shared\/forwardingTable.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+inline void FwdTableEntry::forward_to(HeapWord* from, HeapWord* to) {\n+  _from = from;\n+  _to = to;\n+}\n+\n+\/\/ When found, returns theindex into _table\n+\/\/ When not found, returns a negative value i from which the insertion index can be derived:\n+\/\/ insertion_idx = -(i + 1)\n+inline intx PerRegionTable::lookup(HeapWord* from) {\n+  intx left = 0;\n+  intx right = _insertion_idx - 1;\n+  while (true) {\n+    if (left > right) {\n+      assert(left >= 0 && left <= _insertion_idx, \"must be in bounds and positive\");\n+      assert(left == 0 || _table[left - 1].from() < from, \"correct insertion point\");\n+      assert(left == _insertion_idx || _table[left].from() > from, \"correction insertion point\");\n+      intx ins_pt_encoded = -left - 1;\n+      assert(ins_pt_encoded < 0, \"must be negative\");\n+      assert(-(ins_pt_encoded + 1) == left, \"check decoding\");\n+      return ins_pt_encoded;\n+    }\n+    intx middle = (left + right) \/ 2;\n+    HeapWord* middle_val = _table[middle].from();\n+    if (middle_val < from) {\n+      left = middle + 1;\n+    } else if (middle_val > from) {\n+      right = middle - 1;\n+    } else {\n+      assert(middle_val == from, \"must have found forwarding\");\n+      return middle;\n+    }\n+  }\n+}\n+\n+inline void PerRegionTable::reforward(HeapWord* from, HeapWord* to) {\n+  intx idx = lookup(from);\n+  if (idx < 0) {\n+    intx ins_idx = -(idx + 1);\n+    assert(ins_idx >= 0 && ins_idx < _insertion_idx, \"insertion index must be within bounds\");\n+    assert(_insertion_idx < _num_forwardings, \"must have space for insertion\");\n+    assert(_insertion_idx > 0, \"otherwise entry would be appended\");\n+    assert(ins_idx == 0 || _table[ins_idx - 1].from() < from, \"must insert in order\");\n+    assert(_table[ins_idx].from() > from, \"must insert in order\");\n+    for (intx i = _insertion_idx - 1; i >= ins_idx; i--) {\n+      _table[i + 1] = _table[i];\n+    }\n+    _table[ins_idx].forward_to(from, to);\n+    _insertion_idx++;\n+  } else {\n+    _table[idx].forward_to(from, to);\n+  }\n+}\n+\n+inline void PerRegionTable::forward_to(HeapWord* from, HeapWord* to) {\n+  if (_insertion_idx > 0 && _table[_insertion_idx - 1].from() >= from) {\n+    assert(UseG1GC, \"happens only with G1 serial compaction, _insertion_idx: \" INTX_FORMAT \", entry: \" PTR_FORMAT \" from: \" PTR_FORMAT, _insertion_idx, p2i(_table[_insertion_idx-1].from()), p2i(from));\n+    reforward(from, to);\n+    return;\n+  }\n+  assert(_insertion_idx < _num_forwardings, \"must be within bounds: _insertion_idx: \" INTX_FORMAT \", _num_forwardings: \" INTX_FORMAT, _insertion_idx, _num_forwardings);\n+  assert(_used, \"per region table must have been initialized\");\n+  _table[_insertion_idx].forward_to(from, to);\n+  _insertion_idx++;\n+}\n+\n+inline HeapWord* PerRegionTable::forwardee(HeapWord* from) {\n+  intx idx = lookup(from);\n+  if (idx < 0) {\n+    return nullptr;\n+  } else {\n+    return _table[idx].to();\n+  }\n+}\n+\n+inline void ForwardingTable::forward_to(oop from, oop to) {\n+  assert(_table != nullptr, \"must have been initialized\");\n+  size_t idx = _addr_to_idx(from);\n+  assert(idx < _max_regions, \"must be within bounds\");\n+  \/\/tty->print_cr(\"forward_to: from: \" PTR_FORMAT \", to: \" PTR_FORMAT \", idx: \" SIZE_FORMAT, p2i(from), p2i(to), idx);\n+  _table[idx].forward_to(cast_from_oop<HeapWord*>(from), cast_from_oop<HeapWord*>(to));\n+}\n+\n+inline oop ForwardingTable::forwardee(oop from) {\n+  assert(_table != nullptr, \"must have been initialized\");\n+  size_t idx = _addr_to_idx(from);\n+  assert(idx < _max_regions, \"must be within bounds: idx: \" SIZE_FORMAT \", _max_regions: \" SIZE_FORMAT, idx, _max_regions);\n+  HeapWord* to = _table[idx].forwardee(cast_from_oop<HeapWord*>(from));\n+  \/\/tty->print_cr(\"forwardee: from: \" PTR_FORMAT \", to: \" PTR_FORMAT \", idx: \" SIZE_FORMAT, p2i(from), p2i(to), idx);\n+  return cast_to_oop(to);\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_FORWARDINGTABLE_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/forwardingTable.inline.hpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"gc\/shared\/forwardingTable.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+ForwardingTable* GCForwarding::_forwarding_table = nullptr;\n+\n+void GCForwarding::initialize(AddrToIdxFn addr_to_idx, size_t max_regions) {\n+  if (UseCompactObjectHeaders) {\n+    assert(_forwarding_table == nullptr, \"only call this once\");\n+    _forwarding_table = new ForwardingTable(addr_to_idx, max_regions);\n+  }\n+}\n+\n+void GCForwarding::begin() {\n+  if (UseCompactObjectHeaders) {\n+    assert(_forwarding_table != nullptr, \"expect forwarding table initialized\");\n+    _forwarding_table->begin();\n+  }\n+}\n+\n+void GCForwarding::begin_region(size_t idx, size_t num_forwardings) {\n+  if (UseCompactObjectHeaders) {\n+    assert(_forwarding_table != nullptr, \"expect forwarding table initialized\");\n+    _forwarding_table->begin_region(idx, num_forwardings);\n+  }\n+}\n+\n+void GCForwarding::end() {\n+  if (UseCompactObjectHeaders) {\n+    assert(_forwarding_table != nullptr, \"expect forwarding table initialized\");\n+    _forwarding_table->end();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCFORWARDING_HPP\n+#define SHARE_GC_SHARED_GCFORWARDING_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class ForwardingTable;\n+\n+using AddrToIdxFn = size_t (*)(const void*);\n+\n+class GCForwarding : public AllStatic {\n+private:\n+  static ForwardingTable* _forwarding_table;\n+public:\n+\n+  static void initialize(AddrToIdxFn addr_to_idx, size_t max_regions);\n+  static void begin();\n+  static void begin_region(size_t idx, size_t num_forwardings);\n+  static void end();\n+\n+  static inline bool is_forwarded(oop obj);\n+  static inline oop forwardee(oop obj);\n+  static inline void forward_to(oop obj, oop fwd);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_GCFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n+\n+#include \"gc\/shared\/forwardingTable.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+inline bool GCForwarding::is_forwarded(oop obj) {\n+  if (UseCompactObjectHeaders) {\n+    assert(_forwarding_table != nullptr, \"expect forwarding table initialized\");\n+    return _forwarding_table->forwardee(obj) != nullptr;\n+  } else {\n+    return obj->is_forwarded();\n+  }\n+}\n+\n+inline oop GCForwarding::forwardee(oop obj) {\n+  if (UseCompactObjectHeaders) {\n+    assert(_forwarding_table != nullptr, \"expect forwarding table initialized\");\n+    return _forwarding_table->forwardee(obj);\n+  } else {\n+    return obj->forwardee();\n+  }\n+}\n+\n+inline void GCForwarding::forward_to(oop obj, oop fwd) {\n+  if (UseCompactObjectHeaders) {\n+    assert(_forwarding_table != nullptr, \"expect forwarding table initialized\");\n+    _forwarding_table->forward_to(obj, fwd);\n+    assert(is_forwarded(obj), \"must be forwarded\");\n+    assert(forwardee(obj) == fwd, \"must be forwarded to correct forwardee\");\n+  } else {\n+    obj->forward_to(fwd);\n+  }\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_GCFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcForwarding.inline.hpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -57,1 +58,0 @@\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -106,0 +106,5 @@\n+  auto addr_to_idx = [](const void* addr) {\n+    if (GenCollectedHeap::heap()->is_in_young(addr)) return (size_t)0;\n+    else return (size_t)1;\n+  };\n+  GCForwarding::initialize(addr_to_idx, 2);\n@@ -120,1 +125,0 @@\n-  _forwarding = new SlidingForwarding(_reserved);\n@@ -1039,1 +1043,0 @@\n-  _forwarding->clear();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-class SlidingForwarding;\n@@ -91,2 +90,0 @@\n-  SlidingForwarding* _forwarding;\n-\n@@ -318,4 +315,0 @@\n-  SlidingForwarding* forwarding() const {\n-    return _forwarding;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -63,0 +63,11 @@\n+size_t MarkBitMap::count_marked(MemRegion mr) {\n+  MemRegion intersection = mr.intersection(_covered);\n+  assert(!intersection.is_empty(),\n+         \"Given range from \" PTR_FORMAT \" to \" PTR_FORMAT \" is completely outside the heap\",\n+         p2i(mr.start()), p2i(mr.end()));\n+  \/\/ convert address range into offset range\n+  size_t beg = addr_to_offset(intersection.start());\n+  size_t end = addr_to_offset(intersection.end());\n+  return _bm.count_one_bits(beg, end);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,0 +101,2 @@\n+\n+  size_t count_marked(MemRegion mr);\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -44,2 +44,0 @@\n-\/\/ TODO: This method is unused, except in the gunit test. Change the test\n-\/\/ to exercise the updated method below instead, and remove this one.\n@@ -52,14 +50,2 @@\n-    if (obj->is_forwarded()) {\n-      elem->set_oop(obj->forwardee());\n-    }\n-  }\n-}\n-\n-void PreservedMarks::adjust_during_full_gc(const SlidingForwarding* const forwarding) {\n-  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n-  while (!iter.is_empty()) {\n-    OopAndMarkWord* elem = iter.next_addr();\n-\n-    oop obj = elem->get_oop();\n-    if (obj->is_forwarded()) {\n-      elem->set_oop(forwarding->forwardee(obj));\n+    if (GCForwarding::is_forwarded(obj)) {\n+      elem->set_oop(GCForwarding::forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class SlidingForwarding;\n@@ -67,2 +66,0 @@\n-  \/\/ TODO: This method is unused, except in the gunit test. Change the test\n-  \/\/ to exercise the updated method below instead, and remove this one.\n@@ -71,2 +68,0 @@\n-  void adjust_during_full_gc(const SlidingForwarding* const forwarding);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n-\n-#ifdef _LP64\n-HeapWord* const SlidingForwarding::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n-#endif\n-\n-SlidingForwarding::SlidingForwarding(MemRegion heap)\n-#ifdef _LP64\n-        : _heap_start(heap.start()),\n-          _num_regions(((heap.end() - heap.start()) >> NUM_COMPRESSED_BITS) + 1),\n-          _region_size_words_shift(NUM_COMPRESSED_BITS),\n-          _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * 2, mtGC)) {\n-  assert(_region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n-#else\n-  {\n-#endif\n-}\n-\n-SlidingForwarding::SlidingForwarding(MemRegion heap, size_t region_size_words_shift)\n-#ifdef _LP64\n-        : _heap_start(heap.start()),\n-          _num_regions(((heap.end() - heap.start()) >> region_size_words_shift) + 1),\n-          _region_size_words_shift(region_size_words_shift),\n-          _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * (ONE << NUM_REGION_BITS), mtGC)) {\n-  assert(region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n-#else\n-  {\n-#endif\n-}\n-\n-SlidingForwarding::~SlidingForwarding() {\n-#ifdef _LP64\n-  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n-#endif\n-}\n-\n-void SlidingForwarding::clear() {\n-#ifdef _LP64\n-  size_t max = _num_regions * (ONE << NUM_REGION_BITS);\n-  for (size_t i = 0; i < max; i++) {\n-    _target_base_table[i] = UNUSED_BASE;\n-  }\n-#endif\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n-#define SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/memRegion.hpp\"\n-#include \"oops\/oopsHierarchy.hpp\"\n-\n-\/**\n- * SlidingForwarding is a method to store forwarding information in a compressed form into the object header,\n- * that has been specifically designed for sliding compaction GCs.\n- * It avoids overriding the compressed class pointer in the upper bits of the header, which would otherwise\n- * be lost. SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n- *\n- * The idea is to use a pointer compression scheme very similar to the one that is used for compressed oops.\n- * We divide the heap into number of logical regions. Each region spans maximum of 2^NUM_BITS words.\n- * We take advantage of the fact that sliding compaction can forward objects from one region to a maximum of\n- * two regions (including itself, but that does not really matter). We need 1 bit to indicate which region is forwarded\n- * into. We also currently require the two lowest header bits to indicate that the object is forwarded.\n- *\n- * For addressing, we need a table with N*2 entries, for N logical regions. For each region, it gives the base\n- * address of the two target regions, or a special placeholder if not used.\n- *\n- * Adding a forwarding then works as follows:\n- * Given an original address 'orig', and a 'target' address:\n- * - Look-up first target base of region of orig. If not yet used,\n- *   establish it to be the base of region of target address. Use that base in step 3.\n- * - Else, if first target base is already used, check second target base. This must either be unused, or the\n- *   base of the region of our target address. If unused, establish it to be the base of the region of our target\n- *   address. Use that base for next step.\n- * - Now we found a base address. Encode the target address with that base into lowest NUM_BITS bits, and shift\n- *   that up by 3 bits. Set the 3rd bit if we used the secondary target base, otherwise leave it at 0. Set the\n- *   lowest two bits to indicate that the object has been forwarded. Store that in the lowest NUM_BITS+3 bits of the\n- *   original object's header.\n- *\n- * Similarily, looking up the target address, given an original object address works as follows:\n- * - Load lowest NUM_BITS + 3 from original object header. Extract target region bit and compressed address bits.\n- * - Depending on target region bit, load base address from the target base table by looking up the corresponding entry\n- *   for the region of the original object.\n- * - Decode the target address by using the target base address and the compressed address bits.\n- *\/\n-\n-class SlidingForwarding : public CHeapObj<mtGC> {\n-#ifdef _LP64\n-private:\n-  static const int NUM_REGION_BITS = 1;\n-\n-  static const uintptr_t ONE = 1ULL;\n-\n-  static const size_t NUM_REGIONS = ONE << NUM_REGION_BITS;\n-\n-  \/\/ We need the lowest three bits to indicate a forwarded object and self-forwarding.\n-  static const int BASE_SHIFT = 3;\n-\n-  \/\/ The compressed address bits start here.\n-  static const int COMPRESSED_BITS_SHIFT = BASE_SHIFT + NUM_REGION_BITS;\n-\n-  \/\/ How many bits we use for the compressed pointer (we are going to need one more bit to indicate target region, and\n-  \/\/ two lowest bits to mark objects as forwarded)\n-  static const int NUM_COMPRESSED_BITS = 32 - BASE_SHIFT - NUM_REGION_BITS;\n-\n-  \/\/ Indicates an usused base address in the target base table. We cannot use 0, because that may already be\n-  \/\/ a valid base address in zero-based heaps. 0x1 is safe because heap base addresses must be aligned by 2^X.\n-  static HeapWord* const UNUSED_BASE;\n-\n-  HeapWord*  const _heap_start;\n-  size_t     const _num_regions;\n-  size_t     const _region_size_words_shift;\n-  HeapWord** const _target_base_table;\n-\n-  inline size_t region_index_containing(HeapWord* addr) const;\n-  inline bool region_contains(HeapWord* region_base, HeapWord* addr) const;\n-\n-  inline uintptr_t encode_forwarding(HeapWord* original, HeapWord* target);\n-  inline HeapWord* decode_forwarding(HeapWord* original, uintptr_t encoded) const;\n-\n-#endif\n-\n-public:\n-  SlidingForwarding(MemRegion heap);\n-  SlidingForwarding(MemRegion heap, size_t num_regions);\n-  ~SlidingForwarding();\n-\n-  void clear();\n-  inline void forward_to(oop original, oop target);\n-  inline oop forwardee(oop original) const;\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n-#define SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n-\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-\n-#ifdef _LP64\n-size_t SlidingForwarding::region_index_containing(HeapWord* addr) const {\n-  assert(addr >= _heap_start, \"sanity: addr: \" PTR_FORMAT \" heap base: \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n-  size_t index = ((size_t) (addr - _heap_start)) >> _region_size_words_shift;\n-  assert(index < _num_regions, \"Region index is in bounds: \" PTR_FORMAT, p2i(addr));\n-  return index;\n-}\n-\n-bool SlidingForwarding::region_contains(HeapWord* region_base, HeapWord* addr) const {\n-  return uintptr_t(addr - region_base) < (ONE << _region_size_words_shift);\n-}\n-\n-\n-uintptr_t SlidingForwarding::encode_forwarding(HeapWord* original, HeapWord* target) {\n-  size_t orig_idx = region_index_containing(original);\n-  size_t base_table_idx = orig_idx * 2;\n-  size_t target_idx = region_index_containing(target);\n-  HeapWord* encode_base;\n-  uintptr_t region_idx;\n-  for (region_idx = 0; region_idx < NUM_REGIONS; region_idx++) {\n-    encode_base = _target_base_table[base_table_idx + region_idx];\n-    if (encode_base == UNUSED_BASE) {\n-      encode_base = _heap_start + target_idx * (ONE << _region_size_words_shift);\n-      _target_base_table[base_table_idx + region_idx] = encode_base;\n-      break;\n-    } else if (region_contains(encode_base, target)) {\n-      break;\n-    }\n-  }\n-  if (region_idx >= NUM_REGIONS) {\n-    tty->print_cr(\"target: \" PTR_FORMAT, p2i(target));\n-    for (region_idx = 0; region_idx < NUM_REGIONS; region_idx++) {\n-      tty->print_cr(\"region_idx: \" INTPTR_FORMAT \", encode_base: \" PTR_FORMAT, region_idx, p2i(_target_base_table[base_table_idx + region_idx]));\n-    }\n-  }\n-  assert(region_idx < NUM_REGIONS, \"need to have found an encoding base\");\n-  assert(target >= encode_base, \"target must be above encode base, target:\" PTR_FORMAT \", encoded_base: \" PTR_FORMAT \",  target_idx: \" SIZE_FORMAT \", heap start: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT,\n-         p2i(target), p2i(encode_base), target_idx, p2i(_heap_start), region_idx);\n-  assert(region_contains(encode_base, target), \"region must contain target: original: \" PTR_FORMAT \", target: \" PTR_FORMAT \", encode_base: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT, p2i(original), p2i(target), p2i(encode_base), region_idx);\n-  uintptr_t encoded = (((uintptr_t)(target - encode_base)) << COMPRESSED_BITS_SHIFT) |\n-                      (region_idx << BASE_SHIFT) | markWord::marked_value;\n-  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n-  return encoded;\n-}\n-\n-HeapWord* SlidingForwarding::decode_forwarding(HeapWord* original, uintptr_t encoded) const {\n-  assert((encoded & markWord::marked_value) == markWord::marked_value, \"must be marked as forwarded\");\n-  size_t orig_idx = region_index_containing(original);\n-  size_t region_idx = (encoded >> BASE_SHIFT) & right_n_bits(NUM_REGION_BITS);\n-  size_t base_table_idx = orig_idx * 2 + region_idx;\n-  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n-  assert(decoded >= _heap_start, \"must be above heap start, encoded: \" INTPTR_FORMAT \", region_idx: \" SIZE_FORMAT \", base: \" PTR_FORMAT, encoded, region_idx, p2i(_target_base_table[base_table_idx]));\n-  return decoded;\n-}\n-#endif\n-\n-void SlidingForwarding::forward_to(oop original, oop target) {\n-#ifdef _LP64\n-  markWord header = original->mark();\n-  if (header.has_displaced_mark_helper()) {\n-    header = header.displaced_mark_helper();\n-  }\n-  uintptr_t encoded = encode_forwarding(cast_from_oop<HeapWord*>(original), cast_from_oop<HeapWord*>(target));\n-  assert((encoded & markWord::klass_mask_in_place) == 0, \"encoded forwardee must not overlap with Klass*: \" PTR_FORMAT, encoded);\n-  header = markWord((header.value() & markWord::klass_mask_in_place) | encoded);\n-  original->set_mark(header);\n-#else\n-  original->forward_to(target);\n-#endif\n-}\n-\n-oop SlidingForwarding::forwardee(oop original) const {\n-#ifdef _LP64\n-  markWord header = original->mark();\n-  uintptr_t encoded = header.value() & ~markWord::klass_mask_in_place;\n-  HeapWord* forwardee = decode_forwarding(cast_from_oop<HeapWord*>(original), encoded);\n-  return cast_to_oop(forwardee);\n-#else\n-  return original->forwardee();\n-#endif\n-}\n-\n-#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -256,1 +256,1 @@\n-                                    CompactPoint* cp, HeapWord* compact_top, SlidingForwarding* const forwarding) {\n+                                    CompactPoint* cp, HeapWord* compact_top) {\n@@ -279,1 +279,1 @@\n-    forwarding->forward_to(q, cast_to_oop(compact_top));\n+    GCForwarding::forward_to(q, cast_to_oop(compact_top));\n@@ -285,1 +285,1 @@\n-    assert(!q->is_forwarded(), \"should not be forwarded\");\n+    assert(!GCForwarding::is_forwarded(q), \"should not be forwarded\");\n@@ -327,1 +327,0 @@\n-  SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -333,1 +332,1 @@\n-      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top, forwarding);\n+      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top);\n@@ -349,1 +348,1 @@\n-        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top, forwarding);\n+        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top);\n@@ -392,1 +391,0 @@\n-  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -404,1 +402,1 @@\n-      size_t size = MarkSweep::adjust_pointers(forwarding, cast_to_oop(cur_obj));\n+      size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_obj));\n@@ -445,2 +443,0 @@\n-  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n-\n@@ -449,1 +445,1 @@\n-    if (!cast_to_oop(cur_obj)->is_forwarded()) {\n+    if (!GCForwarding::is_forwarded(cast_to_oop(cur_obj))) {\n@@ -460,1 +456,1 @@\n-      HeapWord* compaction_top = cast_from_oop<HeapWord*>(forwarding->forwardee(cast_to_oop(cur_obj)));\n+      HeapWord* compaction_top = cast_from_oop<HeapWord*>(GCForwarding::forwardee(cast_to_oop(cur_obj)));\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":9,"deletions":13,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,1 +59,0 @@\n-class SlidingForwarding;\n@@ -388,1 +387,1 @@\n-                    HeapWord* compact_top, SlidingForwarding* const forwarding);\n+                    HeapWord* compact_top);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/gcForwarding.inline.hpp\"\n@@ -191,1 +191,0 @@\n-    heap->forwarding()->clear();\n@@ -226,0 +225,1 @@\n+    GCForwarding::begin();\n@@ -237,0 +237,1 @@\n+    GCForwarding::end();\n@@ -302,3 +303,2 @@\n-  PreservedMarks*    const _preserved_marks;\n-  SlidingForwarding* const _forwarding;\n-  ShenandoahHeap*    const _heap;\n+  PreservedMarks*          const _preserved_marks;\n+  ShenandoahHeap*          const _heap;\n@@ -316,1 +316,0 @@\n-    _forwarding(ShenandoahHeap::heap()->forwarding()),\n@@ -370,1 +369,1 @@\n-    _forwarding->forward_to(p, cast_to_oop(_compact_point));\n+    GCForwarding::forward_to(p, cast_to_oop(_compact_point));\n@@ -423,0 +422,2 @@\n+        size_t num_marked = _heap->complete_marking_context()->count_marked(MemRegion(from_region->bottom(), from_region->top()));\n+        GCForwarding::begin_region(from_region->index(), num_marked);\n@@ -444,1 +445,0 @@\n-  SlidingForwarding* forwarding = heap->forwarding();\n@@ -477,0 +477,1 @@\n+        GCForwarding::begin_region(r->index(), 1);\n@@ -479,1 +480,1 @@\n-        forwarding->forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n+        GCForwarding::forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -730,2 +731,1 @@\n-  ShenandoahHeap*           const _heap;\n-  const SlidingForwarding*  const _forwarding;\n+  ShenandoahHeap* const _heap;\n@@ -740,2 +740,2 @@\n-      if (obj->is_forwarded()) {\n-        oop forw = _forwarding->forwardee(obj);\n+      if (GCForwarding::is_forwarded(obj)) {\n+        oop forw = GCForwarding::forwardee(obj);\n@@ -750,1 +750,0 @@\n-    _forwarding(_heap->forwarding()),\n@@ -812,2 +811,1 @@\n-    const SlidingForwarding* const forwarding = ShenandoahHeap::heap()->forwarding();\n-    _preserved_marks->get(worker_id)->adjust_during_full_gc(forwarding);\n+    _preserved_marks->get(worker_id)->adjust_during_full_gc();\n@@ -843,3 +841,2 @@\n-  ShenandoahHeap*          const _heap;\n-  const SlidingForwarding* const _forwarding;\n-  uint                     const _worker_id;\n+  ShenandoahHeap* const _heap;\n+  uint            const _worker_id;\n@@ -849,1 +846,1 @@\n-    _heap(ShenandoahHeap::heap()), _forwarding(_heap->forwarding()), _worker_id(worker_id) {}\n+    _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}\n@@ -854,1 +851,1 @@\n-    if (p->is_forwarded()) {\n+    if (GCForwarding::is_forwarded(p)) {\n@@ -856,1 +853,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(_forwarding->forwardee(p));\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(GCForwarding::forwardee(p));\n@@ -953,1 +950,0 @@\n-  const SlidingForwarding* const forwarding = heap->forwarding();\n@@ -959,1 +955,1 @@\n-      if (!old_obj->is_forwarded()) {\n+      if (!GCForwarding::is_forwarded(old_obj)) {\n@@ -968,1 +964,1 @@\n-      size_t new_start = heap->heap_region_index_containing(forwarding->forwardee(old_obj));\n+      size_t new_start = heap->heap_region_index_containing(GCForwarding::forwardee(old_obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":21,"deletions":25,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -36,1 +37,0 @@\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -198,2 +198,0 @@\n-  _forwarding = new SlidingForwarding(_heap_region, ShenandoahHeapRegion::region_size_words_shift());\n-\n@@ -410,0 +408,3 @@\n+  auto addr_to_idx = [](const void* addr) { return ShenandoahHeap::heap()->heap_region_index_containing(addr); };\n+  GCForwarding::initialize(addr_to_idx, num_regions());\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-class SlidingForwarding;\n@@ -232,1 +231,0 @@\n-  SlidingForwarding* _forwarding;\n@@ -249,2 +247,0 @@\n-  SlidingForwarding* forwarding() const { return _forwarding; }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,0 +123,19 @@\n+size_t ShenandoahMarkBitMap::count_marked(MemRegion mr) const {\n+  MemRegion intersection = mr.intersection(_covered);\n+  assert(!intersection.is_empty(),\n+         \"Given range from \" PTR_FORMAT \" to \" PTR_FORMAT \" is completely outside the heap\",\n+          p2i(mr.start()), p2i(mr.end()));\n+  \/\/ convert address range into offset range\n+  HeapWord* beg = intersection.start();\n+  HeapWord* end = intersection.end();\n+  size_t sum = 0;\n+  \/\/ We could probably be smarter here, but the complication is that we use\n+  \/\/ two bits per object for strong vs weak marking.\n+  for (HeapWord* current = beg; current < end; current++) {\n+    if (is_marked(current)) {\n+      sum++;\n+    }\n+  }\n+  return sum;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  size_t count_marked(MemRegion mr) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+size_t ShenandoahMarkingContext::count_marked(MemRegion mr) const {\n+  return _mark_bit_map.count_marked(mr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  size_t count_marked(MemRegion mr) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/forwardingTable.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(ForwardingTable, empty) {\n+  ForwardingTable ft([](const void*) -> size_t { return 0; }, 1);\n+  ft.begin();\n+  ft.begin_region(0, 1);\n+  oopDesc obj;\n+  ASSERT_EQ(ft.forwardee(&obj), nullptr);\n+  ft.end();\n+}\n+\n+TEST_VM(ForwardingTable, single) {\n+  ForwardingTable ft([](const void*) -> size_t { return 0; }, 1);\n+  ft.begin();\n+  ft.begin_region(0, 1);\n+  oopDesc obj1;\n+  oopDesc obj2;\n+  ft.forward_to(&obj1, &obj2);\n+  ASSERT_EQ(ft.forwardee(&obj1), cast_to_oop(&obj2));\n+  ft.end();\n+}\n+\n+TEST_VM(ForwardingTable, ten) {\n+  ForwardingTable ft([](const void*) -> size_t { return 0; }, 1);\n+  ft.begin();\n+  ft.begin_region(0, 10);\n+  oopDesc obj0,  obj1,  obj2,  obj3,  obj4,  obj5,  obj6,  obj7,  obj8,  obj9;\n+  oopDesc obj0_, obj1_, obj2_, obj3_, obj4_, obj5_, obj6_, obj7_, obj8_, obj9_;\n+  ft.forward_to(&obj0, &obj0_);\n+  ft.forward_to(&obj1, &obj1_);\n+  ft.forward_to(&obj2, &obj2_);\n+  ft.forward_to(&obj3, &obj3_);\n+  ft.forward_to(&obj4, &obj4_);\n+  ft.forward_to(&obj5, &obj5_);\n+  ft.forward_to(&obj6, &obj6_);\n+  ft.forward_to(&obj7, &obj7_);\n+  ft.forward_to(&obj8, &obj8_);\n+  ft.forward_to(&obj9, &obj9_);\n+  ASSERT_EQ(ft.forwardee(&obj0), cast_to_oop(&obj0_));\n+  ASSERT_EQ(ft.forwardee(&obj1), cast_to_oop(&obj1_));\n+  ASSERT_EQ(ft.forwardee(&obj2), cast_to_oop(&obj2_));\n+  ASSERT_EQ(ft.forwardee(&obj3), cast_to_oop(&obj3_));\n+  ASSERT_EQ(ft.forwardee(&obj4), cast_to_oop(&obj4_));\n+  ASSERT_EQ(ft.forwardee(&obj5), cast_to_oop(&obj5_));\n+  ASSERT_EQ(ft.forwardee(&obj6), cast_to_oop(&obj6_));\n+  ASSERT_EQ(ft.forwardee(&obj7), cast_to_oop(&obj7_));\n+  ASSERT_EQ(ft.forwardee(&obj8), cast_to_oop(&obj8_));\n+  ASSERT_EQ(ft.forwardee(&obj9), cast_to_oop(&obj9_));\n+  ft.end();\n+}\n+\n+\/\/ Inserting in reverse order should still work, albeit slow.\n+TEST_VM(ForwardingTable, ten_reverse) {\n+  ForwardingTable ft([](const void*) -> size_t { return 0; }, 1);\n+  ft.begin();\n+  ft.begin_region(0, 10);\n+  oopDesc obj0,  obj1,  obj2,  obj3,  obj4,  obj5,  obj6,  obj7,  obj8,  obj9;\n+  oopDesc obj0_, obj1_, obj2_, obj3_, obj4_, obj5_, obj6_, obj7_, obj8_, obj9_;\n+  ft.forward_to(&obj9, &obj9_);\n+  ft.forward_to(&obj8, &obj8_);\n+  ft.forward_to(&obj7, &obj7_);\n+  ft.forward_to(&obj6, &obj6_);\n+  ft.forward_to(&obj5, &obj5_);\n+  ft.forward_to(&obj4, &obj4_);\n+  ft.forward_to(&obj3, &obj3_);\n+  ft.forward_to(&obj2, &obj2_);\n+  ft.forward_to(&obj1, &obj1_);\n+  ft.forward_to(&obj0, &obj0_);\n+  ASSERT_EQ(ft.forwardee(&obj0), cast_to_oop(&obj0_));\n+  ASSERT_EQ(ft.forwardee(&obj1), cast_to_oop(&obj1_));\n+  ASSERT_EQ(ft.forwardee(&obj2), cast_to_oop(&obj2_));\n+  ASSERT_EQ(ft.forwardee(&obj3), cast_to_oop(&obj3_));\n+  ASSERT_EQ(ft.forwardee(&obj4), cast_to_oop(&obj4_));\n+  ASSERT_EQ(ft.forwardee(&obj5), cast_to_oop(&obj5_));\n+  ASSERT_EQ(ft.forwardee(&obj6), cast_to_oop(&obj6_));\n+  ASSERT_EQ(ft.forwardee(&obj7), cast_to_oop(&obj7_));\n+  ASSERT_EQ(ft.forwardee(&obj8), cast_to_oop(&obj8_));\n+  ASSERT_EQ(ft.forwardee(&obj9), cast_to_oop(&obj9_));\n+  ft.end();\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_forwardingTable.cpp","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -58,0 +58,3 @@\n+  bool old_compact_headers = UseCompactObjectHeaders;\n+  UseCompactObjectHeaders = false;\n+\n@@ -81,3 +84,0 @@\n-  \/\/ TODO: This is the only use of PM::adjust_during_full_gc().\n-  \/\/ GCs use the variant with a forwarding structure here,\n-  \/\/ test that variant, and remove the method.\n@@ -91,0 +91,2 @@\n+\n+  UseCompactObjectHeaders = old_compact_headers;\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"}]}