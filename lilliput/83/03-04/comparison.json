{"files":[{"patch":"@@ -27,0 +27,2 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/ostream.hpp\"\n@@ -28,1 +30,3 @@\n-PerRegionTable::PerRegionTable() : _used(false), _num_forwardings(0), _insertion_idx(0), _table(nullptr) {\n+const float PerRegionTable::LOAD_FACTOR = 0.9f;\n+\n+PerRegionTable::PerRegionTable() : _used(false), _table_size_bits(0), _table_size(0), _max_psl(0), _table(nullptr) {\n@@ -40,4 +44,5 @@\n-  _num_forwardings = num_forwardings;\n-  _insertion_idx = 0;\n-  _table = NEW_C_HEAP_ARRAY(FwdTableEntry, num_forwardings, mtGC);\n-  for (intx i = 0; i < num_forwardings; i++) {\n+  _table_size = round_up_power_of_2((uintx)((float)num_forwardings \/ LOAD_FACTOR));\n+  _table_size_bits = log2i_exact(_table_size);\n+  _max_psl = 0;\n+  _table = NEW_C_HEAP_ARRAY(FwdTableEntry, _table_size, mtGC);\n+  for (uintx i = 0; i < _table_size; i++) {\n@@ -64,0 +69,1 @@\n+  \/\/tty->print_cr(\"Max-PSLs for \" SIZE_FORMAT \" tables\", _max_regions);\n@@ -65,0 +71,1 @@\n+    \/\/tty->print_cr(\"table[\" SIZE_FORMAT \"]: \" UINTX_FORMAT, i, _table[i].max_psl());\n","filename":"src\/hotspot\/share\/gc\/shared\/forwardingTable.cpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/gcForwarding.hpp\"\n@@ -32,0 +31,2 @@\n+using AddrToIdxFn = size_t (*)(const void*);\n+\n@@ -56,0 +57,2 @@\n+  static const float LOAD_FACTOR;\n+\n@@ -57,2 +60,3 @@\n-  intx _num_forwardings;\n-  intx _insertion_idx;\n+  int _table_size_bits;\n+  uintx _table_size;\n+  uintx _max_psl;\n@@ -61,3 +65,2 @@\n-  inline intx lookup(HeapWord* from);\n-  inline void reforward(HeapWord* from, HeapWord* to);\n-\n+  inline uintx home_index(HeapWord* from) const;\n+  inline uintx psl(uintx idx, uintx home) const;\n@@ -70,0 +73,2 @@\n+\n+  uintx max_psl() const { return _max_psl; }\n","filename":"src\/hotspot\/share\/gc\/shared\/forwardingTable.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/oop.inline.hpp\"\n@@ -37,27 +38,7 @@\n-\/\/ When found, returns the index into _table\n-\/\/ When not found, returns a negative value i from which the insertion index can be derived:\n-\/\/ insertion_idx = -(i + 1)\n-inline intx PerRegionTable::lookup(HeapWord* from) {\n-  intx left = 0;\n-  intx right = _insertion_idx - 1;\n-  while (true) {\n-    if (left > right) {\n-      assert(left >= 0 && left <= _insertion_idx, \"must be in bounds and positive\");\n-      assert(left == 0 || _table[left - 1].from() < from, \"correct insertion point\");\n-      assert(left == _insertion_idx || _table[left].from() > from, \"correction insertion point\");\n-      intx ins_pt_encoded = -left - 1;\n-      assert(ins_pt_encoded < 0, \"must be negative\");\n-      assert(-(ins_pt_encoded + 1) == left, \"check decoding\");\n-      return ins_pt_encoded;\n-    }\n-    intx middle = (left + right) \/ 2;\n-    HeapWord* middle_val = _table[middle].from();\n-    if (middle_val < from) {\n-      left = middle + 1;\n-    } else if (middle_val > from) {\n-      right = middle - 1;\n-    } else {\n-      assert(middle_val == from, \"must have found forwarding\");\n-      return middle;\n-    }\n-  }\n+inline uintx murmur3_hash(uintx k) {\n+  k ^= k >> 33;\n+  k *= 0xff51afd7ed558ccdLLU;\n+  k ^= k >> 33;\n+  k *= 0xc4ceb9fe1a85ec53LLU;\n+  k ^= k >> 33;\n+  return k;\n@@ -66,16 +47,3 @@\n-inline void PerRegionTable::reforward(HeapWord* from, HeapWord* to) {\n-  intx idx = lookup(from);\n-  if (idx < 0) {\n-    intx ins_idx = -(idx + 1);\n-    assert(ins_idx >= 0 && ins_idx < _insertion_idx, \"insertion index must be within bounds\");\n-    assert(_insertion_idx < _num_forwardings, \"must have space for insertion\");\n-    assert(_insertion_idx > 0, \"otherwise entry would be appended\");\n-    assert(ins_idx == 0 || _table[ins_idx - 1].from() < from, \"must insert in order\");\n-    assert(_table[ins_idx].from() > from, \"must insert in order\");\n-    for (intx i = _insertion_idx - 1; i >= ins_idx; i--) {\n-      _table[i + 1] = _table[i];\n-    }\n-    _table[ins_idx].forward_to(from, to);\n-    _insertion_idx++;\n-  } else {\n-    _table[idx].forward_to(from, to);\n+inline uintx PerRegionTable::home_index(HeapWord* from) const {\n+  if (_table_size_bits == 0) {\n+    return 0; \/\/ Single-element table would underflow the right-shift and hit UB\n@@ -83,0 +51,23 @@\n+\n+  uint64_t val = reinterpret_cast<uint64_t>(from);\n+  val *= 0xbf58476d1ce4e5b9ull;\n+  val ^= val >> 56;\n+  val *= 0x94d049bb133111ebull;\n+  val = (val * 11400714819323198485llu) >> (64 - _table_size_bits);\n+  assert(val < _table_size, \"must fit in table: val: \" UINT64_FORMAT \", table-size: \" UINTX_FORMAT \", table-size-bits: %d\", val, _table_size, _table_size_bits);\n+  return reinterpret_cast<uintx>(val);\n+  \/\/uintx hash = murmur3_hash(reinterpret_cast<uintx>(from));\n+  \/\/return hash % _table_size;\n+}\n+\n+inline uintx PerRegionTable::psl(uintx idx, uintx home) const {\n+  \/\/ Calculate distance between idx and home, accounting for\n+  \/\/ wrap-around.\n+  \/\/ By adding the table-size to idx, we ensure that the resulting\n+  \/\/ index is larger than home. Then we can subtract home and\n+  \/\/ modulo with table-size (by masking, table-size is power-of-2)\n+  \/\/ to get the actual difference.\n+  assert(home < _table_size, \"home index must be within table\");\n+  uintx psl = (idx + _table_size - home) & (_table_size - 1);\n+  assert(psl < _table_size, \"must be within table size\");\n+  return psl;\n@@ -86,4 +77,31 @@\n-  if (_insertion_idx > 0 && _table[_insertion_idx - 1].from() >= from) {\n-    assert(UseG1GC, \"happens only with G1 serial compaction, _insertion_idx: \" INTX_FORMAT \", entry: \" PTR_FORMAT \" from: \" PTR_FORMAT, _insertion_idx, p2i(_table[_insertion_idx-1].from()), p2i(from));\n-    reforward(from, to);\n-    return;\n+  uintx home_idx = home_index(from);\n+  uintx end = home_idx + _table_size;\n+  uintx mask = _table_size - 1;\n+  \/\/tty->print_cr(\"Inserting: \" PTR_FORMAT \", home index: \" UINTX_FORMAT, p2i(from), home_idx);\n+  for (uintx i = home_idx; i < end; i++) {\n+    uintx idx = i & mask;\n+    uintx my_psl = psl(idx, home_idx);\n+    HeapWord* entry = _table[idx].from();\n+    if (entry == nullptr || entry == from) {\n+      \/\/tty->print_cr(\"Inserted at idx: \" UINTX_FORMAT, idx);\n+      \/\/ We found an empty slot or a slot containing the key we are looking for.\n+      _table[idx].forward_to(from, to);\n+      _max_psl = MAX2(my_psl, _max_psl);\n+      return;\n+    }\n+    \/\/ See if we shall swap the existing entry with the new one.\n+    \/\/ See: https:\/\/programming.guide\/robin-hood-hashing.html\n+    \/\/ PSL = probe sequence length.\n+    uintx other_home_idx = home_index(entry);\n+    uintx other_psl = psl(idx, other_home_idx);\n+    \/\/tty->print_cr(\"My PSL: \" UINTX_FORMAT \", other PSL: \" UINTX_FORMAT, my_psl, other_psl);\n+    if (my_psl > other_psl) {\n+      \/\/ Take from the rich, give to the poor :-)\n+      HeapWord* new_to = _table[idx].to();\n+      _table[idx].forward_to(from, to);\n+      from = entry;\n+      to = new_to;\n+      \/\/tty->print_cr(\"swap, no inserting: \" PTR_FORMAT, p2i(from));\n+      home_idx = other_home_idx;\n+      _max_psl = MAX2(my_psl, _max_psl);\n+    }\n@@ -91,4 +109,1 @@\n-  assert(_insertion_idx < _num_forwardings, \"must be within bounds: _insertion_idx: \" INTX_FORMAT \", _num_forwardings: \" INTX_FORMAT, _insertion_idx, _num_forwardings);\n-  assert(_used, \"per region table must have been initialized\");\n-  _table[_insertion_idx].forward_to(from, to);\n-  _insertion_idx++;\n+  guarantee(false, \"overflow while inserting\");\n@@ -98,2 +113,1 @@\n-  intx idx = lookup(from);\n-  if (idx < 0) {\n+  if (!_used) {\n@@ -101,2 +115,0 @@\n-  } else {\n-    return _table[idx].to();\n@@ -104,0 +116,45 @@\n+  \/\/if (_max_psl > 0) tty->print_cr(\"Max-PSL: \" UINTX_FORMAT, _max_psl);\n+  uintx home_idx = home_index(from);\n+  uintx mask = _table_size - 1;\n+  \/\/tty->print_cr(\"Searching: \" PTR_FORMAT \", home index: \" UINTX_FORMAT, p2i(from), home_idx);\n+  for (uintx i = home_idx; i <= home_idx + _max_psl; i++) {\n+    \/\/tty->print_cr(\"checking index: \" UINTX_FORMAT, i);\n+    uintx idx = i & mask;\n+    HeapWord* entry = _table[idx].from();\n+    if (entry == from) {\n+      \/\/tty->print_cr(\"Found at idx: \" UINTX_FORMAT, idx);\n+      return _table[idx].to();\n+    } else if (entry == nullptr) {\n+      \/\/tty->print_cr(\"Found null at idx: \" UINTX_FORMAT, idx);\n+      return nullptr;\n+    } else {\n+      uintx my_psl = psl(idx, home_idx);\n+      uintx other_psl = psl(idx, home_index(entry));\n+      if (other_psl < my_psl) {\n+        \/\/tty->print_cr(\"Found smaller PSL at idx: \" UINTX_FORMAT, idx);\n+        return nullptr;\n+      }\n+    }\n+  }\n+  \/*\n+  uintx middle = home_idx + _max_psl \/ 2;\n+  HeapWord* entry = _table[middle].from();\n+  if (entry == from) {\n+    return _table[middle].to();\n+  }\n+\n+  uintx mask = _table_size - 1;\n+  for (uintx i = 1; i <= (_max_psl + 1) \/ 2; i++) {\n+    uintx left = (middle + _table_size - i) & mask;\n+    entry = _table[left].from();\n+    if (entry == from) {\n+      return _table[left].to();\n+    }\n+    uintx right = (middle + i) & mask;\n+    entry = _table[right].from();\n+    if (entry == from) {\n+      return _table[right].to();\n+    }\n+  }\n+  *\/\n+  return nullptr;\n","filename":"src\/hotspot\/share\/gc\/shared\/forwardingTable.inline.hpp","additions":112,"deletions":55,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -368,1 +368,3 @@\n-    _preserved_marks->push_if_necessary(p, p->mark());\n+    if (!UseCompactObjectHeaders) {\n+      _preserved_marks->push_if_necessary(p, p->mark());\n+    }\n@@ -479,1 +481,3 @@\n-        _preserved_marks->get(0)->push_if_necessary(old_obj, old_obj->mark());\n+        if (!UseCompactObjectHeaders) {\n+          _preserved_marks->get(0)->push_if_necessary(old_obj, old_obj->mark());\n+        }\n@@ -858,1 +862,3 @@\n-      new_obj->init_mark();\n+      if (!UseCompactObjectHeaders) {\n+        new_obj->init_mark();\n+      }\n@@ -973,1 +979,3 @@\n-      new_obj->init_mark();\n+      if (!UseCompactObjectHeaders) {\n+        new_obj->init_mark();\n+      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"}]}