{"files":[{"patch":"@@ -41,0 +41,1 @@\n+  _objEdgeHashTable = new ObjEdgeHashTable();\n@@ -46,0 +47,2 @@\n+  assert(_objEdgeHashTable != NULL, \"invariant\");\n+  delete _objEdgeHashTable;\n@@ -235,1 +238,1 @@\n-  sample_object->set_mark(markWord::from_pointer(leak_context_edge));\n+  map_obj_to_edge(sample_object, leak_context_edge);\n@@ -319,0 +322,16 @@\n+\n+void EdgeStore::map_obj_to_edge(oop obj, Edge* edge) {\n+  ObjEdgeEntry entry(obj, edge);\n+  ObjEdgeHashEntry& result = _objEdgeHashTable->put(uintptr_t(cast_from_oop<void*>(obj)), entry);\n+  assert(result.value().obj() == obj, \"invariant\");\n+}\n+\n+Edge* EdgeStore::get_edge_for_object(oop obj) {\n+  ObjEdgeHashEntry* result = _objEdgeHashTable->lookup_only(uintptr_t(cast_from_oop<void*>(obj)));\n+  if (result != NULL) {\n+    assert(result->value().obj() == obj, \"invariant\");\n+    return result->value().edge();\n+  } else {\n+    return nullptr;\n+  }\n+}\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -60,0 +60,25 @@\n+class ObjEdgeEntry {\n+private:\n+  oop _obj;\n+  Edge* _edge;\n+public:\n+  ObjEdgeEntry(oop obj, Edge* edge) : _obj(obj), _edge(edge) {}\n+  oop obj() const { return _obj; }\n+  Edge* edge() const { return _edge; }\n+};\n+\n+class ObjEdgeTableCallback : public JfrCHeapObj  {\n+public:\n+  void on_link(HashTableHost<ObjEdgeEntry, uintptr_t, JfrHashtableEntry, ObjEdgeTableCallback>::HashEntry* entry) {\n+    entry->set_id(cast_from_oop<uintptr_t>(entry->value().obj()));\n+  }\n+  void on_unlink(HashTableHost<ObjEdgeEntry, uintptr_t, JfrHashtableEntry, ObjEdgeTableCallback>::HashEntry* entry) {\n+    \/\/ Nothing to do.\n+  }\n+  bool on_equals(uintptr_t hash, HashTableHost<ObjEdgeEntry, uintptr_t, JfrHashtableEntry, ObjEdgeTableCallback>::HashEntry* entry) {\n+    \/\/ Curiously, JfrHashtable uses the hash for comparison. Therefore we use the object address as hash.\n+    \/\/ This is not ideal, but works.\n+    return true;\n+  }\n+};\n+\n@@ -63,0 +88,2 @@\n+  typedef HashTableHost<ObjEdgeEntry, uintptr_t, JfrHashtableEntry, ObjEdgeTableCallback> ObjEdgeHashTable;\n+  typedef ObjEdgeHashTable::HashEntry ObjEdgeHashEntry;\n@@ -75,0 +102,1 @@\n+  ObjEdgeHashTable* _objEdgeHashTable;\n@@ -106,0 +134,3 @@\n+\n+  void map_obj_to_edge(oop obj, Edge* edge);\n+  Edge* get_edge_for_object(oop obj);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.hpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-    _store->push(ObjectSampleMarkWord(obj, obj->mark()));\n+    markWord orig = obj->mark();\n+    _store->push(ObjectSampleMarkWord(obj, orig));\n@@ -72,2 +73,5 @@\n-    assert(!obj->mark().is_marked(), \"should only mark an object once\");\n-    obj->set_mark(markWord::prototype().set_marked());\n+    assert(!orig.is_marked(), \"should only mark an object once\");\n+    if (orig.has_displaced_mark_helper()) {\n+      orig = orig.displaced_mark_helper();\n+    }\n+    obj->set_mark(markWord::prototype().set_marked().set_narrow_klass(orig.narrow_klass()));\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/objectSampleMarker.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -144,3 +144,1 @@\n-    if (!sample->object()->mark().is_marked()) {\n-      edge = (const Edge*)(sample->object())->mark().to_pointer();\n-    }\n+    edge = edge_store->get_edge_for_object(sample->object());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/eventEmitter.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}