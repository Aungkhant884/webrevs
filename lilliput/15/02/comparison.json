{"files":[{"patch":"@@ -59,1 +59,1 @@\n-  jmpb(next);\n+  jmp(next);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4532,4 +4532,47 @@\n-  if (UseCompressedClassPointers) {\n-    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n-    decode_klass_not_null(dst, tmp);\n-  } else\n+  assert(UseCompressedClassPointers, \"expect compressed class pointers\");\n+\n+  Label slow, done;\n+  movq(tmp, Address(src, oopDesc::mark_offset_in_bytes()));\n+  \/\/ NOTE: While it would seem nice to use xorb instead (for which we don't have an encoding in our assembler),\n+  \/\/ the encoding for xorq uses the signed version (0x81\/6) of xor, which encodes as compact as xorb would,\n+  \/\/ and does't make a difference performance-wise.\n+  xorq(tmp, markWord::unlocked_value);\n+  testb(tmp, markWord::lock_mask_in_place);\n+  jccb(Assembler::notZero, slow);\n+\n+  movq(dst, tmp);\n+  shrq(dst, markWord::klass_shift);\n+  decode_klass_not_null(dst, tmp);\n+  jmpb(done);\n+  bind(slow);\n+\n+  if (dst != rax) {\n+    push(rax);\n+  }\n+  push(rdi);\n+  push(rsi);\n+  push(rdx);\n+  push(rcx);\n+  push(r8);\n+  push(r9);\n+  push(r10);\n+  push(r11);\n+\n+  MacroAssembler::call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_klass_runtime), src);\n+\n+  pop(r11);\n+  pop(r10);\n+  pop(r9);\n+  pop(r8);\n+  pop(rcx);\n+  pop(rdx);\n+  pop(rsi);\n+  pop(rdi);\n+  if (dst != rax) {\n+    mov(dst, rax);\n+    pop(rax);\n+  }\n+\n+  bind(done);\n+#else\n+  movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n@@ -4537,1 +4580,0 @@\n-    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":47,"deletions":5,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-        __ null_check(receiver_reg, oopDesc::klass_offset_in_bytes());\n+        __ null_check(receiver_reg, oopDesc::mark_offset_in_bytes());\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3660,1 +3660,1 @@\n-  __ null_check(recv, oopDesc::klass_offset_in_bytes());\n+  __ null_check(recv, oopDesc::mark_offset_in_bytes());\n@@ -3753,1 +3753,1 @@\n-  __ null_check(rcx, oopDesc::klass_offset_in_bytes());\n+  __ null_check(rcx, oopDesc::mark_offset_in_bytes());\n@@ -3777,1 +3777,1 @@\n-  __ null_check(rcx, oopDesc::klass_offset_in_bytes());\n+  __ null_check(rcx, oopDesc::mark_offset_in_bytes());\n@@ -4188,1 +4188,1 @@\n-  __ jmpb(resolved);\n+  __ jmp(resolved);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-  const ptrdiff_t estimate = 136;\n+  const ptrdiff_t estimate = 199;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -176,0 +177,5 @@\n+JRT_LEAF(Klass*, oopDesc::load_klass_runtime(oopDesc* o))\n+  assert(o != NULL, \"null-check\");\n+  return oop(o)->klass();\n+JRT_END\n+\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -313,0 +313,3 @@\n+  \/\/ Runtime entry\n+  static Klass* load_klass_runtime(oopDesc* o);\n+\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}