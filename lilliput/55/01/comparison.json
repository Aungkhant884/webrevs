{"files":[{"patch":"@@ -0,0 +1,1763 @@\n+name: Pre-submit tests\n+\n+on:\n+  push:\n+    branches-ignore:\n+      - master\n+      - pr\/*\n+  workflow_dispatch:\n+    inputs:\n+      platforms:\n+        description: \"Platform(s) to execute on\"\n+        required: true\n+        default: \"Linux additional (hotspot only), Linux x64, Linux x86, Windows aarch64, Windows x64, macOS x64\"\n+\n+concurrency:\n+  group: ${{ github.workflow }}-${{ github.ref }}\n+  cancel-in-progress: true\n+\n+jobs:\n+  prerequisites:\n+    name: Prerequisites\n+    runs-on: \"ubuntu-20.04\"\n+    outputs:\n+      should_run: ${{ steps.check_submit.outputs.should_run }}\n+      bundle_id: ${{ steps.check_bundle_id.outputs.bundle_id }}\n+      jdk_version: ${{ steps.check_jdk_versions.outputs.jdk_version }}\n+      platform_linux_additional: ${{ steps.check_platforms.outputs.platform_linux_additional }}\n+      platform_linux_x64: ${{ steps.check_platforms.outputs.platform_linux_x64 }}\n+      platform_linux_x86: ${{ steps.check_platforms.outputs.platform_linux_x86 }}\n+      platform_windows_aarch64: ${{ steps.check_platforms.outputs.platform_windows_aarch64 }}\n+      platform_windows_x64: ${{ steps.check_platforms.outputs.platform_windows_x64 }}\n+      platform_macos_x64: ${{ steps.check_platforms.outputs.platform_macos_x64 }}\n+      platform_macos_aarch64: ${{ steps.check_platforms.outputs.platform_macos_aarch64 }}\n+      dependencies: ${{ steps.check_deps.outputs.dependencies }}\n+\n+    steps:\n+      - name: Check if submit tests should actually run depending on secrets and manual triggering\n+        id: check_submit\n+        run: echo \"::set-output name=should_run::${{ github.event.inputs.platforms != '' || (!secrets.JDK_SUBMIT_FILTER || startsWith(github.ref, 'refs\/heads\/submit\/')) }}\"\n+\n+      - name: Check which platforms should be included\n+        id: check_platforms\n+        run: |\n+          echo \"::set-output name=platform_linux_additional::${{ contains(github.event.inputs.platforms, 'linux additional (hotspot only)') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux additional (hotspot only)'))) }}\"\n+          echo \"::set-output name=platform_linux_x64::${{ contains(github.event.inputs.platforms, 'linux x64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux x64'))) }}\"\n+          echo \"::set-output name=platform_linux_x86::${{ contains(github.event.inputs.platforms, 'linux x86') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'linux x86'))) }}\"\n+          echo \"::set-output name=platform_windows_aarch64::${{ contains(github.event.inputs.platforms, 'windows aarch64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'windows aarch64'))) }}\"\n+          echo \"::set-output name=platform_windows_x64::${{ contains(github.event.inputs.platforms, 'windows x64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'windows x64'))) }}\"\n+          echo \"::set-output name=platform_macos_x64::${{ contains(github.event.inputs.platforms, 'macos x64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'macos x64'))) }}\"\n+          echo \"::set-output name=platform_macos_aarch64::${{ contains(github.event.inputs.platforms, 'macos aarch64') || (github.event.inputs.platforms == '' && (secrets.JDK_SUBMIT_PLATFORMS == '' || contains(secrets.JDK_SUBMIT_PLATFORMS, 'macos aarch64'))) }}\"\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n+      - name: Determine unique bundle identifier\n+        id: check_bundle_id\n+        run: echo \"::set-output name=bundle_id::${GITHUB_ACTOR}_${GITHUB_SHA:0:8}\"\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+        with:\n+          path: jdk\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n+      - name: Determine versions and locations to be used for dependencies\n+        id: check_deps\n+        run: \"echo ::set-output name=dependencies::`cat make\/conf\/version-numbers.conf make\/conf\/test-dependencies | sed -e '1i {' -e 's\/#.*\/\/g' -e 's\/\\\"\/\/g' -e 's\/\\\\(.*\\\\)=\\\\(.*\\\\)\/\\\"\\\\1\\\": \\\"\\\\2\\\",\/g' -e '$s\/,\\\\s\\\\{0,\\\\}$\/\\\\}\/'`\"\n+        working-directory: jdk\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n+      - name: Print extracted dependencies to the log\n+        run: \"echo '${{ steps.check_deps.outputs.dependencies }}'\"\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n+      - name: Determine full JDK versions\n+        id: check_jdk_versions\n+        shell: bash\n+        run: |\n+          FEATURE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\n+          INTERIM=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_INTERIM }}\n+          UPDATE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\n+          if [ \"x${UPDATE}\" != \"x0\" ]; then\n+             V=${FEATURE}.${INTERIM}.${UPDATE}\n+          elif [ \"x${INTERIM}\" != \"x0\" ]; then\n+             V={FEATURE}.${INTERIM}\n+          else\n+             V=${FEATURE}\n+          fi\n+          echo \"::set-output name=jdk_version::${V}\"\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n+      - name: Determine the jtreg ref to checkout\n+        run: \"echo JTREG_REF=jtreg-${{ fromJson(steps.check_deps.outputs.dependencies).JTREG_VERSION }}+${{ fromJson(steps.check_deps.outputs.dependencies).JTREG_BUILD }} >> $GITHUB_ENV\"\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n+      - name: Check if a jtreg image is present in the cache\n+        id: jtreg\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/jtreg\/\n+          key: jtreg-${{ env.JTREG_REF }}-v1\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n+      - name: Checkout the jtreg source\n+        uses: actions\/checkout@v3\n+        with:\n+          repository: \"openjdk\/jtreg\"\n+          ref: ${{ env.JTREG_REF }}\n+          path: jtreg\n+        if: steps.check_submit.outputs.should_run != 'false' && steps.jtreg.outputs.cache-hit != 'true'\n+\n+      - name: Build jtreg\n+        run: bash make\/build.sh --jdk ${JAVA_HOME_8_X64}\n+        working-directory: jtreg\n+        if: steps.check_submit.outputs.should_run != 'false' && steps.jtreg.outputs.cache-hit != 'true'\n+\n+      - name: Move jtreg image to destination folder\n+        run: mv build\/images\/jtreg ~\/\n+        working-directory: jtreg\n+        if: steps.check_submit.outputs.should_run != 'false' && steps.jtreg.outputs.cache-hit != 'true'\n+\n+      - name: Store jtreg for use by later steps\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ steps.check_bundle_id.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n+  linux_x64_build:\n+    name: Linux x64\n+    runs-on: \"ubuntu-20.04\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && (needs.prerequisites.outputs.platform_linux_x64 != 'false' || needs.prerequisites.outputs.platform_linux_additional == 'true')\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build release\n+          - build debug\n+        include:\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256} ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | sha256sum -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Checkout gtest sources\n+        uses: actions\/checkout@v3\n+        with:\n+          repository: \"google\/googletest\"\n+          ref: \"release-${{ fromJson(needs.prerequisites.outputs.dependencies).GTEST_VERSION }}\"\n+          path: gtest\n+\n+      - name: Install dependencies\n+        run: |\n+          sudo apt-get update\n+          sudo apt-get install gcc-10=10.3.0-1ubuntu1~20.04 g++-10=10.3.0-1ubuntu1~20.04 libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n+          sudo update-alternatives --install \/usr\/bin\/gcc gcc \/usr\/bin\/gcc-10 100 --slave \/usr\/bin\/g++ g++ \/usr\/bin\/g++-10\n+\n+      - name: Configure\n+        run: >\n+          bash configure\n+          --with-conf-name=linux-x64\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-boot-jdk=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\n+          --with-jtreg=${HOME}\/jtreg\n+          --with-gtest=${GITHUB_WORKSPACE}\/gtest\n+          --with-default-make-target=\"product-bundles test-bundles\"\n+          --with-zlib=system\n+          --enable-jtreg-failure-handler\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: make CONF_NAME=linux-x64\n+        working-directory: jdk\n+\n+      - name: Persist test bundles\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: |\n+            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+\n+  linux_x64_test:\n+    name: Linux x64\n+    runs-on: \"ubuntu-20.04\"\n+    needs:\n+      - prerequisites\n+      - linux_x64_build\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        test:\n+          - jdk\/tier1 part 1\n+          - jdk\/tier1 part 2\n+          - jdk\/tier1 part 3\n+          - langtools\/tier1\n+          - hs\/tier1 common\n+          - hs\/tier1 compiler\n+          - hs\/tier1 gc\n+          - hs\/tier1 runtime\n+          - hs\/tier1 serviceability\n+        include:\n+          - test: jdk\/tier1 part 1\n+            suites: test\/jdk\/:tier1_part1\n+          - test: jdk\/tier1 part 2\n+            suites: test\/jdk\/:tier1_part2\n+          - test: jdk\/tier1 part 3\n+            suites: test\/jdk\/:tier1_part3\n+          - test: langtools\/tier1\n+            suites: test\/langtools\/:tier1\n+          - test: hs\/tier1 common\n+            suites: test\/hotspot\/jtreg\/:tier1_common\n+            artifact: -debug\n+          - test: hs\/tier1 compiler\n+            suites: test\/hotspot\/jtreg\/:tier1_compiler\n+            artifact: -debug\n+          - test: hs\/tier1 gc\n+            suites: test\/hotspot\/jtreg\/:tier1_gc\n+            artifact: -debug\n+          - test: hs\/tier1 runtime\n+            suites: test\/hotspot\/jtreg\/:tier1_runtime\n+            artifact: -debug\n+          - test: hs\/tier1 serviceability\n+            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256} ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | sha256sum -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Restore build artifacts\n+        id: build_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x64${{ matrix.artifact }}\n+        continue-on-error: true\n+\n+      - name: Restore build artifacts (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x64${{ matrix.artifact }}\n+        if: steps.build_restore.outcome == 'failure'\n+\n+      - name: Unpack jdk\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }}\"\n+\n+      - name: Unpack tests\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}\"\n+\n+      - name: Find root of jdk image dir\n+        run: |\n+          imageroot=`find ${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin${{ matrix.artifact }} -name release -type f`\n+          echo \"imageroot=`dirname ${imageroot}`\" >> $GITHUB_ENV\n+\n+      - name: Run tests\n+        id: run_tests\n+        run: >\n+          JDK_IMAGE_DIR=${{ env.imageroot }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin-tests${{ matrix.artifact }}\n+          BOOT_JDK=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\n+          JT_HOME=${HOME}\/jtreg\n+          make test-prebuilt\n+          CONF_NAME=run-test-prebuilt\n+          LOG_CMDLINES=true\n+          JTREG_VERBOSE=fail,error,time\n+          TEST=\"${{ matrix.suites }}\"\n+          TEST_OPTS_JAVA_OPTIONS=\n+          JTREG_KEYWORDS=\"!headful\"\n+          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+\n+      - name: Check that all tests executed successfully\n+        if: steps.run_tests.outcome != 'skipped'\n+        run: >\n+          if ! grep --include=test-summary.txt -lqr build\/*\/test-results -e \"TEST SUCCESS\" ; then\n+            cat build\/*\/test-results\/*\/text\/newfailures.txt ;\n+            cat build\/*\/test-results\/*\/text\/other_errors.txt ;\n+            exit 1 ;\n+          fi\n+\n+      - name: Create suitable test log artifact name\n+        if: always()\n+        run: echo \"logsuffix=`echo ${{ matrix.test }} | sed -e 's!\/!_!'g -e 's! !_!'g`\" >> $GITHUB_ENV\n+\n+      - name: Package test results\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-results\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n+          .\n+        continue-on-error: true\n+\n+      - name: Package test support\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          .\n+          -i *.jtr\n+          -i *\/hs_err*.log\n+          -i *\/replay*.log\n+        continue-on-error: true\n+\n+      - name: Persist test results\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/linux-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+      - name: Persist test outputs\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/linux-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+  linux_additional_build:\n+    name: Linux additional\n+    runs-on: \"ubuntu-20.04\"\n+    needs:\n+      - prerequisites\n+      - linux_x64_build\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_linux_additional != 'false'\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - hs x64 build only\n+          - hs x64 zero build only\n+          - hs x64 minimal build only\n+          - hs x64 optimized build only\n+          - hs aarch64 build only\n+          - hs arm build only\n+        include:\n+          - flavor: hs x64 build only\n+            flags: --enable-debug --disable-precompiled-headers\n+          - flavor: hs x64 zero build only\n+            flags: --enable-debug --disable-precompiled-headers --with-jvm-variants=zero\n+          - flavor: hs x64 minimal build only\n+            flags: --enable-debug --disable-precompiled-headers --with-jvm-variants=minimal\n+          - flavor: hs x64 optimized build only\n+            flags: --with-debug-level=optimized --disable-precompiled-headers\n+          - flavor: hs aarch64 build only\n+            flags: --enable-debug --disable-precompiled-headers\n+            debian-arch: arm64\n+            gnu-arch: aarch64\n+          - flavor: hs arm build only\n+            flags: --enable-debug --disable-precompiled-headers\n+            debian-arch: armhf\n+            gnu-arch: arm\n+            gnu-flavor: eabihf\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256} ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | sha256sum -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore build JDK\n+        id: build_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x64_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x64\n+        continue-on-error: true\n+\n+      - name: Restore build JDK (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x64_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x64\n+        if: steps.build_restore.outcome == 'failure'\n+\n+      - name: Unpack build JDK\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin\"\n+          tar -xf \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin.tar.gz\" -C \"${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin\"\n+\n+      - name: Find root of build JDK image dir\n+        run: |\n+          build_jdk_root=`find ${HOME}\/jdk-linux-x64\/jdk-${{ env.JDK_VERSION }}-internal_linux-x64_bin -name release -type f`\n+          echo \"build_jdk_root=`dirname ${build_jdk_root}`\" >> $GITHUB_ENV\n+\n+      - name: Update apt\n+        run: sudo apt-get update\n+\n+      - name: Install native host dependencies\n+        run: |\n+          sudo apt-get install gcc-10=10.3.0-1ubuntu1~20.04 g++-10=10.3.0-1ubuntu1~20.04 libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n+          sudo update-alternatives --install \/usr\/bin\/gcc gcc \/usr\/bin\/gcc-10 100 --slave \/usr\/bin\/g++ g++ \/usr\/bin\/g++-10\n+        if: matrix.debian-arch == ''\n+\n+      - name: Install cross-compilation host dependencies\n+        run: sudo apt-get install gcc-10-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}=10.3.0-1ubuntu1~20.04cross1 g++-10-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}=10.3.0-1ubuntu1~20.04cross1\n+        if: matrix.debian-arch != ''\n+\n+      - name: Cache sysroot\n+        id: cache-sysroot\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/sysroot-${{ matrix.debian-arch }}\/\n+          key: sysroot-${{ matrix.debian-arch }}-${{ hashFiles('jdk\/.github\/workflows\/submit.yml') }}\n+        if: matrix.debian-arch != ''\n+\n+      - name: Install sysroot host dependencies\n+        run: sudo apt-get install debootstrap qemu-user-static\n+        if: matrix.debian-arch != '' && steps.cache-sysroot.outputs.cache-hit != 'true'\n+\n+      - name: Create sysroot\n+        run: >\n+          sudo qemu-debootstrap\n+          --arch=${{ matrix.debian-arch }}\n+          --verbose\n+          --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev\n+          --resolve-deps\n+          buster\n+          ~\/sysroot-${{ matrix.debian-arch }}\n+          http:\/\/httpredir.debian.org\/debian\/\n+        if: matrix.debian-arch != '' && steps.cache-sysroot.outputs.cache-hit != 'true'\n+\n+      - name: Prepare sysroot for caching\n+        run: |\n+          sudo chroot ~\/sysroot-${{ matrix.debian-arch }} symlinks -cr .\n+          sudo chown ${USER} -R ~\/sysroot-${{ matrix.debian-arch }}\n+          rm -rf ~\/sysroot-${{ matrix.debian-arch }}\/{dev,proc,run,sys}\n+        if: matrix.debian-arch != '' && steps.cache-sysroot.outputs.cache-hit != 'true'\n+\n+      - name: Configure cross compiler\n+        run: |\n+          echo \"CC=${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}-gcc-10\" >> $GITHUB_ENV\n+          echo \"CXX=${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}-g++-10\" >> $GITHUB_ENV\n+        if: matrix.debian-arch != ''\n+\n+      - name: Configure cross specific flags\n+        run: >\n+          echo \"cross_flags=\n+          --openjdk-target=${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-flavor}}\n+          --with-sysroot=${HOME}\/sysroot-${{ matrix.debian-arch }}\/\n+          \" >> $GITHUB_ENV\n+        if: matrix.debian-arch != ''\n+\n+      - name: Configure\n+        run: >\n+          bash configure\n+          --with-conf-name=linux-${{ matrix.gnu-arch }}-hotspot\n+          ${{ matrix.flags }}\n+          ${{ env.cross_flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-boot-jdk=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\n+          --with-build-jdk=${{ env.build_jdk_root }}\n+          --with-default-make-target=\"hotspot\"\n+          --with-zlib=system\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: make CONF_NAME=linux-${{ matrix.gnu-arch }}-hotspot\n+        working-directory: jdk\n+\n+  linux_x86_build:\n+    name: Linux x86\n+    runs-on: \"ubuntu-20.04\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_linux_x86 != 'false'\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build release\n+          - build debug\n+        include:\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    # Reduced 32-bit build uses the same boot JDK as 64-bit build\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256} ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | sha256sum -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Checkout gtest sources\n+        uses: actions\/checkout@v3\n+        with:\n+          repository: \"google\/googletest\"\n+          ref: \"release-${{ fromJson(needs.prerequisites.outputs.dependencies).GTEST_VERSION }}\"\n+          path: gtest\n+\n+      # Roll in the multilib environment and its dependencies.\n+      # Some multilib libraries do not have proper inter-dependencies, so we have to\n+      # install their dependencies manually. Additionally, upgrading apt solves\n+      # the libc6 installation bugs until base image catches up, see JDK-8260460.\n+      - name: Install dependencies\n+        run: |\n+          sudo dpkg --add-architecture i386\n+          sudo apt-get update\n+          sudo apt-get install --only-upgrade apt\n+          sudo apt-get install gcc-10-multilib g++-10-multilib libfreetype6-dev:i386 libxrandr-dev:i386 libxtst-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libcups2-dev:i386 libasound2-dev:i386\n+          sudo update-alternatives --install \/usr\/bin\/gcc gcc \/usr\/bin\/gcc-10 100 --slave \/usr\/bin\/g++ g++ \/usr\/bin\/g++-10\n+\n+      - name: Configure\n+        run: >\n+          bash configure\n+          --with-conf-name=linux-x86\n+          --with-target-bits=32\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-boot-jdk=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\n+          --with-jtreg=${HOME}\/jtreg\n+          --with-gtest=${GITHUB_WORKSPACE}\/gtest\n+          --with-default-make-target=\"product-bundles test-bundles\"\n+          --with-zlib=system\n+          --enable-jtreg-failure-handler\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: make CONF_NAME=linux-x86\n+        working-directory: jdk\n+\n+      - name: Persist test bundles\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x86${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: |\n+            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\n+\n+  linux_x86_test:\n+    name: Linux x86\n+    runs-on: \"ubuntu-20.04\"\n+    needs:\n+      - prerequisites\n+      - linux_x86_build\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        test:\n+          - jdk\/tier1 part 1\n+          - jdk\/tier1 part 2\n+          - jdk\/tier1 part 3\n+          - langtools\/tier1\n+          - hs\/tier1 common\n+          - hs\/tier1 compiler\n+          - hs\/tier1 gc\n+          - hs\/tier1 runtime\n+          - hs\/tier1 serviceability\n+        include:\n+          - test: jdk\/tier1 part 1\n+            suites: test\/jdk\/:tier1_part1\n+          - test: jdk\/tier1 part 2\n+            suites: test\/jdk\/:tier1_part2\n+          - test: jdk\/tier1 part 3\n+            suites: test\/jdk\/:tier1_part3\n+          - test: langtools\/tier1\n+            suites: test\/langtools\/:tier1\n+          - test: hs\/tier1 common\n+            suites: test\/hotspot\/jtreg\/:tier1_common\n+            artifact: -debug\n+          - test: hs\/tier1 compiler\n+            suites: test\/hotspot\/jtreg\/:tier1_compiler\n+            artifact: -debug\n+          - test: hs\/tier1 gc\n+            suites: test\/hotspot\/jtreg\/:tier1_gc\n+            artifact: -debug\n+          - test: hs\/tier1 runtime\n+            suites: test\/hotspot\/jtreg\/:tier1_runtime\n+            artifact: -debug\n+          - test: hs\/tier1 serviceability\n+            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n+            artifact: -debug\n+\n+    # Reduced 32-bit build uses the same boot JDK as 64-bit build\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).LINUX_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256} ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | sha256sum -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Restore build artifacts\n+        id: build_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x86${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x86${{ matrix.artifact }}\n+        continue-on-error: true\n+\n+      - name: Restore build artifacts (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-linux-x86${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-linux-x86${{ matrix.artifact }}\n+        if: steps.build_restore.outcome == 'failure'\n+\n+      - name: Unpack jdk\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }}\"\n+\n+      - name: Unpack tests\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}\"\n+\n+      - name: Find root of jdk image dir\n+        run: |\n+          imageroot=`find ${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin${{ matrix.artifact }} -name release -type f`\n+          echo \"imageroot=`dirname ${imageroot}`\" >> $GITHUB_ENV\n+\n+      - name: Run tests\n+        id: run_tests\n+        run: >\n+          JDK_IMAGE_DIR=${{ env.imageroot }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_linux-x86_bin-tests${{ matrix.artifact }}\n+          BOOT_JDK=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\n+          JT_HOME=${HOME}\/jtreg\n+          make test-prebuilt\n+          CONF_NAME=run-test-prebuilt\n+          LOG_CMDLINES=true\n+          JTREG_VERBOSE=fail,error,time\n+          TEST=\"${{ matrix.suites }}\"\n+          TEST_OPTS_JAVA_OPTIONS=\n+          JTREG_KEYWORDS=\"!headful\"\n+          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+\n+      - name: Check that all tests executed successfully\n+        if: steps.run_tests.outcome != 'skipped'\n+        run: >\n+          if ! grep --include=test-summary.txt -lqr build\/*\/test-results -e \"TEST SUCCESS\" ; then\n+            cat build\/*\/test-results\/*\/text\/newfailures.txt ;\n+            cat build\/*\/test-results\/*\/text\/other_errors.txt ;\n+            exit 1 ;\n+          fi\n+\n+      - name: Create suitable test log artifact name\n+        if: always()\n+        run: echo \"logsuffix=`echo ${{ matrix.test }} | sed -e 's!\/!_!'g -e 's! !_!'g`\" >> $GITHUB_ENV\n+\n+      - name: Package test results\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-results\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x86${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n+          .\n+        continue-on-error: true\n+\n+      - name: Package test support\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/linux-x86${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          .\n+          -i *.jtr\n+          -i *\/hs_err*.log\n+          -i *\/replay*.log\n+        continue-on-error: true\n+\n+      - name: Persist test results\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/linux-x86${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+      - name: Persist test outputs\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/linux-x86${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+  windows_aarch64_build:\n+    name: Windows aarch64\n+    runs-on: \"windows-2019\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_windows_aarch64 != 'false'\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build debug\n+        include:\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n+      - name: Restore cygwin packages from cache\n+        id: cygwin\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/packages\n+          key: cygwin-packages-${{ runner.os }}-v1\n+\n+      - name: Install cygwin\n+        run: |\n+          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages cygwin=3.2.0-1,autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n+\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+          & curl -L \"$env:BOOT_JDK_URL\" -o \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash = Get-FileHash -Algorithm SHA256 \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash.Hash -eq $env:BOOT_JDK_SHA256\n+          & tar -xf \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\" -C \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\"\n+          Get-ChildItem \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\\*\\*\" | Move-Item -Destination \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Ensure a specific version of MSVC is installed\n+        run: >\n+          Start-Process -FilePath 'C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vs_installer.exe' -Wait -NoNewWindow -ArgumentList\n+          'modify --installPath \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\" --quiet\n+          --add Microsoft.VisualStudio.Component.VC.14.29.arm64'\n+\n+      - name: Configure\n+        run: >\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          $env:Path = $env:Path -split \";\" -match \"C:\\\\Windows|PowerShell|cygwin\" -join \";\" ;\n+          $env:BOOT_JDK = cygpath \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\" ;\n+          & bash configure\n+          --with-conf-name=windows-aarch64\n+          --with-msvc-toolset-version=14.29\n+          --openjdk-target=aarch64-unknown-cygwin\n+          ${{ matrix.flags }}\n+          --with-version-opt=\"$env:GITHUB_ACTOR-$env:GITHUB_SHA\"\n+          --with-boot-jdk=\"$env:BOOT_JDK\"\n+          --with-default-make-target=\"hotspot\"\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: |\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          $env:Path = $env:Path -split \";\" -match \"C:\\\\Windows|PowerShell|cygwin\" -join \";\" ;\n+          & make CONF_NAME=windows-aarch64\n+        working-directory: jdk\n+\n+  windows_x64_build:\n+    name: Windows x64\n+    runs-on: \"windows-2019\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_windows_x64 != 'false'\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build release\n+          - build debug\n+        include:\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n+      - name: Restore cygwin packages from cache\n+        id: cygwin\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/packages\n+          key: cygwin-packages-${{ runner.os }}-v1\n+\n+      - name: Install cygwin\n+        run: |\n+          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages cygwin=3.2.0-1,autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n+\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+          & curl -L \"$env:BOOT_JDK_URL\" -o \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash = Get-FileHash -Algorithm SHA256 \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash.Hash -eq $env:BOOT_JDK_SHA256\n+          & tar -xf \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\" -C \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\"\n+          Get-ChildItem \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\\*\\*\" | Move-Item -Destination \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Checkout gtest sources\n+        uses: actions\/checkout@v3\n+        with:\n+          repository: \"google\/googletest\"\n+          ref: \"release-${{ fromJson(needs.prerequisites.outputs.dependencies).GTEST_VERSION }}\"\n+          path: gtest\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Ensure a specific version of MSVC is installed\n+        run: >\n+          Start-Process -FilePath 'C:\\Program Files (x86)\\Microsoft Visual Studio\\Installer\\vs_installer.exe' -Wait -NoNewWindow -ArgumentList\n+          'modify --installPath \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\" --quiet\n+          --add Microsoft.VisualStudio.Component.VC.14.28.x86.x64'\n+\n+      - name: Configure\n+        run: >\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          $env:Path = $env:Path -split \";\" -match \"C:\\\\Windows|PowerShell|cygwin\" -join \";\" ;\n+          $env:BOOT_JDK = cygpath \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\" ;\n+          $env:JT_HOME = cygpath \"$HOME\/jtreg\" ;\n+          $env:GTEST = cygpath \"$env:GITHUB_WORKSPACE\/gtest\" ;\n+          & bash configure\n+          --with-conf-name=windows-x64\n+          --with-msvc-toolset-version=14.28\n+          ${{ matrix.flags }}\n+          --with-version-opt=\"$env:GITHUB_ACTOR-$env:GITHUB_SHA\"\n+          --with-boot-jdk=\"$env:BOOT_JDK\"\n+          --with-jtreg=\"$env:JT_HOME\"\n+          --with-gtest=\"$env:GTEST\"\n+          --with-default-make-target=\"product-bundles test-bundles\"\n+          --enable-jtreg-failure-handler\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: |\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          $env:Path = $env:Path -split \";\" -match \"C:\\\\Windows|PowerShell|cygwin\" -join \";\" ;\n+          & make CONF_NAME=windows-x64\n+        working-directory: jdk\n+\n+      - name: Persist test bundles\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          name: transient_jdk-windows-x64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: |\n+            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}.zip\n+            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\n+\n+  windows_x64_test:\n+    name: Windows x64\n+    runs-on: \"windows-2019\"\n+    needs:\n+      - prerequisites\n+      - windows_x64_build\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        test:\n+          - jdk\/tier1 part 1\n+          - jdk\/tier1 part 2\n+          - jdk\/tier1 part 3\n+          - langtools\/tier1\n+          - hs\/tier1 common\n+          - hs\/tier1 compiler\n+          - hs\/tier1 gc\n+          - hs\/tier1 runtime\n+          - hs\/tier1 serviceability\n+        include:\n+          - test: jdk\/tier1 part 1\n+            suites: test\/jdk\/:tier1_part1\n+          - test: jdk\/tier1 part 2\n+            suites: test\/jdk\/:tier1_part2\n+          - test: jdk\/tier1 part 3\n+            suites: test\/jdk\/:tier1_part3\n+          - test: langtools\/tier1\n+            suites: test\/langtools\/:tier1\n+          - test: hs\/tier1 common\n+            suites: test\/hotspot\/jtreg\/:tier1_common\n+            artifact: -debug\n+          - test: hs\/tier1 compiler\n+            suites: test\/hotspot\/jtreg\/:tier1_compiler\n+            artifact: -debug\n+          - test: hs\/tier1 gc\n+            suites: test\/hotspot\/jtreg\/:tier1_gc\n+            artifact: -debug\n+          - test: hs\/tier1 runtime\n+            suites: test\/hotspot\/jtreg\/:tier1_runtime\n+            artifact: -debug\n+          - test: hs\/tier1 serviceability\n+            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+          & curl -L \"$env:BOOT_JDK_URL\" -o \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash = Get-FileHash -Algorithm SHA256 \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash.Hash -eq $env:BOOT_JDK_SHA256\n+          & tar -xf \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\" -C \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\"\n+          Get-ChildItem \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\\*\\*\" | Move-Item -Destination \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore cygwin installer from cache\n+        id: cygwin-installer\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/setup-x86_64.exe\n+          key: cygwin-installer\n+\n+      - name: Download cygwin installer\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+        if: steps.cygwin-installer.outputs.cache-hit != 'true'\n+\n+      - name: Restore cygwin packages from cache\n+        id: cygwin\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/cygwin\/packages\n+          key: cygwin-packages-${{ runner.os }}-v1\n+\n+      - name: Install cygwin\n+        run: |\n+          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages cygwin=3.2.0-1,autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Restore build artifacts\n+        id: build_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-windows-x64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-windows-x64${{ matrix.artifact }}\n+        continue-on-error: true\n+\n+      - name: Restore build artifacts (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-windows-x64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-windows-x64${{ matrix.artifact }}\n+        if: steps.build_restore.outcome == 'failure'\n+\n+      - name: Unpack jdk\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}.zip\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}\"\n+\n+      - name: Unpack symbols\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols\"\n+          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }}-symbols\"\n+\n+      - name: Unpack tests\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}\"\n+\n+      - name: Find root of jdk image dir\n+        run: echo (\"imageroot=\" + (Get-ChildItem -Path $HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin${{ matrix.artifact }} -Filter release -Recurse -ErrorAction SilentlyContinue -Force).DirectoryName) | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8\n+\n+      - name: Run tests\n+        id: run_tests\n+        run: >\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          $env:Path = $env:Path -split \";\" -match \"C:\\\\Windows|PowerShell|cygwin\" -join \";\" ;\n+          $env:JDK_IMAGE_DIR = cygpath \"${{ env.imageroot }}\" ;\n+          $env:SYMBOLS_IMAGE_DIR = cygpath \"${{ env.imageroot }}\" ;\n+          $env:TEST_IMAGE_DIR = cygpath \"$HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_windows-x64_bin-tests${{ matrix.artifact }}\" ;\n+          $env:BOOT_JDK = cygpath \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\" ;\n+          $env:JT_HOME = cygpath \"$HOME\/jtreg\" ;\n+          & make test-prebuilt\n+          CONF_NAME=run-test-prebuilt\n+          LOG_CMDLINES=true\n+          JTREG_VERBOSE=fail,error,time\n+          TEST=${{ matrix.suites }}\n+          TEST_OPTS_JAVA_OPTIONS=\n+          JTREG_KEYWORDS=\"!headful\"\n+          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+\n+      - name: Check that all tests executed successfully\n+        if: steps.run_tests.outcome != 'skipped'\n+        run: >\n+          if ((Get-ChildItem -Path build\\*\\test-results\\test-summary.txt -Recurse | Select-String -Pattern \"TEST SUCCESS\" ).Count -eq 0) {\n+            Get-Content -Path build\\*\\test-results\\*\\*\\newfailures.txt ;\n+            Get-Content -Path build\\*\\test-results\\*\\*\\other_errors.txt ;\n+            exit 1\n+          }\n+\n+      - name: Create suitable test log artifact name\n+        if: always()\n+        run: echo (\"logsuffix=\" + (\"${{ matrix.test }}\" -replace \"\/\", \"_\" -replace \" \", \"_\")) | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8\n+\n+      - name: Package test results\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-results\/\n+        run: >\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          zip -r9\n+          \"$HOME\/windows-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n+          .\n+        continue-on-error: true\n+\n+      - name: Package test support\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          zip -r9\n+          \"$HOME\/windows-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          .\n+          -i *.jtr\n+          -i *\/hs_err*.log\n+          -i *\/replay*.log\n+        continue-on-error: true\n+\n+      - name: Persist test results\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/windows-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+      - name: Persist test outputs\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/windows-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+  macos_x64_build:\n+    name: macOS x64\n+    runs-on: \"macos-10.15\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_macos_x64 != 'false'\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build release\n+          - build debug\n+        include:\n+          - flavor: build release\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p ${HOME}\/bootjdk\/${BOOT_JDK_VERSION} || true\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256}  ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | shasum -a 256 -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Checkout gtest sources\n+        uses: actions\/checkout@v3\n+        with:\n+          repository: \"google\/googletest\"\n+          ref: \"release-${{ fromJson(needs.prerequisites.outputs.dependencies).GTEST_VERSION }}\"\n+          path: gtest\n+\n+      - name: Install dependencies\n+        run: brew install make\n+\n+      - name: Select Xcode version\n+        run: sudo xcode-select --switch \/Applications\/Xcode_11.3.1.app\/Contents\/Developer\n+\n+      - name: Configure\n+        run: >\n+          bash configure\n+          --with-conf-name=macos-x64\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-boot-jdk=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/Contents\/Home\n+          --with-jtreg=${HOME}\/jtreg\n+          --with-gtest=${GITHUB_WORKSPACE}\/gtest\n+          --with-default-make-target=\"product-bundles test-bundles\"\n+          --with-zlib=system\n+          --enable-jtreg-failure-handler\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: make CONF_NAME=macos-x64\n+        working-directory: jdk\n+\n+      - name: Persist test bundles\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          name: transient_jdk-macos-x64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: |\n+            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+\n+  macos_aarch64_build:\n+    name: macOS aarch64\n+    runs-on: \"macos-10.15\"\n+    needs: prerequisites\n+    if: needs.prerequisites.outputs.should_run != 'false' && needs.prerequisites.outputs.platform_macos_aarch64 != 'false'\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        flavor:\n+          - build release\n+          - build debug\n+        include:\n+          - flavor: build release\n+          - flavor: build debug\n+            flags: --enable-debug\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+        with:\n+          path: jdk\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p ${HOME}\/bootjdk\/${BOOT_JDK_VERSION} || true\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256}  ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | shasum -a 256 -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Checkout gtest sources\n+        uses: actions\/checkout@v3\n+        with:\n+          repository: \"google\/googletest\"\n+          ref: \"release-${{ fromJson(needs.prerequisites.outputs.dependencies).GTEST_VERSION }}\"\n+          path: gtest\n+\n+      - name: Install dependencies\n+        run: brew install make\n+\n+      - name: Select Xcode version\n+        run: sudo xcode-select --switch \/Applications\/Xcode_12.4.app\/Contents\/Developer\n+\n+      - name: Configure\n+        run: >\n+          bash configure\n+          --with-conf-name=macos-aarch64\n+          --openjdk-target=aarch64-apple-darwin\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-boot-jdk=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/Contents\/Home\n+          --with-jtreg=${HOME}\/jtreg\n+          --with-gtest=${GITHUB_WORKSPACE}\/gtest\n+          --with-default-make-target=\"product-bundles test-bundles\"\n+          --with-zlib=system\n+          --enable-jtreg-failure-handler\n+        working-directory: jdk\n+\n+      - name: Build\n+        run: make CONF_NAME=macos-aarch64\n+        working-directory: jdk\n+\n+      - name: Persist test bundles\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          name: transient_jdk-macos-aarch64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: |\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-aarch64_bin${{ matrix.artifact }}.tar.gz\n+            jdk\/build\/macos-aarch64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal_macos-aarch64_bin-tests${{ matrix.artifact }}.tar.gz\n+\n+\n+  macos_x64_test:\n+    name: macOS x64\n+    runs-on: \"macos-10.15\"\n+    needs:\n+      - prerequisites\n+      - macos_x64_build\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        test:\n+          - jdk\/tier1 part 1\n+          - jdk\/tier1 part 2\n+          - jdk\/tier1 part 3\n+          - langtools\/tier1\n+          - hs\/tier1 common\n+          - hs\/tier1 compiler\n+          - hs\/tier1 gc\n+          - hs\/tier1 runtime\n+          - hs\/tier1 serviceability\n+        include:\n+          - test: jdk\/tier1 part 1\n+            suites: test\/jdk\/:tier1_part1\n+          - test: jdk\/tier1 part 2\n+            suites: test\/jdk\/:tier1_part2\n+          - test: jdk\/tier1 part 3\n+            suites: test\/jdk\/:tier1_part3\n+          - test: langtools\/tier1\n+            suites: test\/langtools\/:tier1\n+          - test: hs\/tier1 common\n+            suites: test\/hotspot\/jtreg\/:tier1_common\n+            artifact: -debug\n+          - test: hs\/tier1 compiler\n+            suites: test\/hotspot\/jtreg\/:tier1_compiler\n+            artifact: -debug\n+          - test: hs\/tier1 gc\n+            suites: test\/hotspot\/jtreg\/:tier1_gc\n+            artifact: -debug\n+          - test: hs\/tier1 runtime\n+            suites: test\/hotspot\/jtreg\/:tier1_runtime\n+            artifact: -debug\n+          - test: hs\/tier1 serviceability\n+            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n+            artifact: -debug\n+\n+    env:\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).MACOS_X64_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v3\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v3\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p ${HOME}\/bootjdk\/${BOOT_JDK_VERSION} || true\n+          wget -O \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" \"${BOOT_JDK_URL}\"\n+          echo \"${BOOT_JDK_SHA256}  ${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" | shasum -a 256 -c >\/dev\/null -\n+          tar -xf \"${HOME}\/bootjdk\/${BOOT_JDK_FILENAME}\" -C \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\"\n+          mv \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"*\/* \"${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        continue-on-error: true\n+\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Restore build artifacts\n+        id: build_restore\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-macos-x64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-macos-x64${{ matrix.artifact }}\n+        continue-on-error: true\n+\n+      - name: Restore build artifacts (retry)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          name: transient_jdk-macos-x64${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-macos-x64${{ matrix.artifact }}\n+        if: steps.build_restore.outcome == 'failure'\n+\n+      - name: Unpack jdk\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }}\"\n+\n+      - name: Unpack tests\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}\"\n+\n+      - name: Install dependencies\n+        run: brew install make\n+\n+      - name: Select Xcode version\n+        run: sudo xcode-select --switch \/Applications\/Xcode_11.3.1.app\/Contents\/Developer\n+\n+      - name: Find root of jdk image dir\n+        run: |\n+          imageroot=`find ${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin${{ matrix.artifact }} -name release -type f`\n+          echo \"imageroot=`dirname ${imageroot}`\" >> $GITHUB_ENV\n+\n+      - name: Run tests\n+        id: run_tests\n+        run: >\n+          JDK_IMAGE_DIR=${{ env.imageroot }}\n+          TEST_IMAGE_DIR=${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal_macos-x64_bin-tests${{ matrix.artifact }}\n+          BOOT_JDK=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/Contents\/Home\n+          JT_HOME=${HOME}\/jtreg\n+          gmake test-prebuilt\n+          CONF_NAME=run-test-prebuilt\n+          LOG_CMDLINES=true\n+          JTREG_VERBOSE=fail,error,time\n+          TEST=${{ matrix.suites }}\n+          TEST_OPTS_JAVA_OPTIONS=\n+          JTREG_KEYWORDS=\"!headful\"\n+          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+\n+      - name: Check that all tests executed successfully\n+        if: steps.run_tests.outcome != 'skipped'\n+        run: >\n+          if ! grep --include=test-summary.txt -lqr build\/*\/test-results -e \"TEST SUCCESS\" ; then\n+            cat build\/*\/test-results\/*\/text\/newfailures.txt ;\n+            cat build\/*\/test-results\/*\/text\/other_errors.txt ;\n+            exit 1 ;\n+          fi\n+\n+      - name: Create suitable test log artifact name\n+        if: always()\n+        run: echo \"logsuffix=`echo ${{ matrix.test }} | sed -e 's!\/!_!'g -e 's! !_!'g`\" >> $GITHUB_ENV\n+\n+      - name: Package test results\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-results\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/macos-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n+          .\n+        continue-on-error: true\n+\n+      - name: Package test support\n+        if: always()\n+        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          zip -r9\n+          \"$HOME\/macos-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          .\n+          -i *.jtr\n+          -i *\/hs_err*.log\n+          -i *\/replay*.log\n+        continue-on-error: true\n+\n+      - name: Persist test results\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/macos-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+      - name: Persist test outputs\n+        if: always()\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          path: ~\/macos-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+  artifacts:\n+    name: Post-process artifacts\n+    runs-on: \"ubuntu-20.04\"\n+    if: always()\n+    continue-on-error: true\n+    needs:\n+      - prerequisites\n+      - linux_additional_build\n+      - windows_aarch64_build\n+      - linux_x64_test\n+      - linux_x86_test\n+      - windows_x64_test\n+      - macos_x64_test\n+      - macos_aarch64_build\n+\n+    steps:\n+      - name: Determine current artifacts endpoint\n+        id: actions_runtime\n+        uses: actions\/github-script@v6\n+        with:\n+          script: \"return { url: process.env['ACTIONS_RUNTIME_URL'], token: process.env['ACTIONS_RUNTIME_TOKEN'] }\"\n+\n+      - name: Display current artifacts\n+        run: >\n+          curl -s -H 'Accept: application\/json;api-version=6.0-preview'\n+          -H 'Authorization: Bearer ${{ fromJson(steps.actions_runtime.outputs.result).token }}'\n+          '${{ fromJson(steps.actions_runtime.outputs.result).url }}_apis\/pipelines\/workflows\/${{ github.run_id }}\/artifacts?api-version=6.0-preview'\n+\n+      - name: Delete transient artifacts\n+        run: >\n+          for url in `\n+          curl -s -H 'Accept: application\/json;api-version=6.0-preview'\n+          -H 'Authorization: Bearer ${{ fromJson(steps.actions_runtime.outputs.result).token }}'\n+          '${{ fromJson(steps.actions_runtime.outputs.result).url }}_apis\/pipelines\/workflows\/${{ github.run_id }}\/artifacts?api-version=6.0-preview' |\n+          jq -r -c '.value | map(select(.name|startswith(\"transient_\"))) | .[].url'`; do\n+          curl -s -H 'Accept: application\/json;api-version=6.0-preview'\n+          -H 'Authorization: Bearer ${{ fromJson(steps.actions_runtime.outputs.result).token }}'\n+          -X DELETE \"${url}\";\n+          done\n+\n+      - name: Fetch remaining artifacts (test results)\n+        uses: actions\/download-artifact@v3\n+        with:\n+          path: test-results\n+\n+      - name: Delete remaining artifacts\n+        run: >\n+          for url in `\n+          curl -s -H 'Accept: application\/json;api-version=6.0-preview'\n+          -H 'Authorization: Bearer ${{ fromJson(steps.actions_runtime.outputs.result).token }}'\n+          '${{ fromJson(steps.actions_runtime.outputs.result).url }}_apis\/pipelines\/workflows\/${{ github.run_id }}\/artifacts?api-version=6.0-preview' |\n+          jq -r -c '.value | .[].url'`; do\n+          curl -s -H 'Accept: application\/json;api-version=6.0-preview'\n+          -H 'Authorization: Bearer ${{ fromJson(steps.actions_runtime.outputs.result).token }}'\n+          -X DELETE \"${url}\";\n+          done\n+\n+      - name: Upload a combined test results artifact\n+        uses: actions\/upload-artifact@v3\n+        with:\n+          name: test-results_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: test-results\n","filename":".github\/workflows\/submit.yml","additions":1763,"deletions":0,"binary":false,"changes":1763,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=lilliput\n@@ -7,1 +7,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,reviewers,executable,symlink,message,hg-tag,whitespace,problemlists\n@@ -21,3 +21,0 @@\n-[checks \"merge\"]\n-message=Merge\n-\n@@ -25,1 +22,1 @@\n-reviewers=1\n+committers=1\n@@ -31,3 +28,0 @@\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n","filename":".jcheck\/conf","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -7172,1 +7172,1 @@\n-instruct loadNKlass(iRegNNoSp dst, memory4 mem)\n+instruct loadNKlass(iRegNNoSp dst, memory4 mem, rFlagsReg cr)\n@@ -7175,0 +7175,1 @@\n+  effect(TEMP_DEF dst, KILL cr);\n@@ -7179,4 +7180,6 @@\n-\n-  ins_encode(aarch64_enc_ldrw(dst, mem));\n-\n-  ins_pipe(iload_reg_mem);\n+  ins_encode %{\n+    assert($mem$$disp == oopDesc::klass_offset_in_bytes(), \"expect correct offset\");\n+    assert($mem$$index$$Register == noreg, \"expect no index\");\n+    __ load_nklass($dst$$Register, $mem$$base$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -256,0 +256,25 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  __ bind(_entry);\n+  Register res = _result->as_register();\n+  ce->store_parameter(_obj->as_register(), 0);\n+  if (res != r0) {\n+    \/\/ Note: we cannot push\/pop r0 around the call, because that\n+    \/\/ would mess with the stack pointer sp, and we need that to\n+    \/\/ remain intact for store_paramater\/load_argument to work correctly.\n+    \/\/ We swap r0 and res instead, which preserves current r0 in res.\n+    \/\/ The preserved value is later saved and restored around the\n+    \/\/ call in Runtime1::load_klass_id.\n+    __ mov(rscratch1, r0);\n+    __ mov(r0, res);\n+    __ mov(res, rscratch1);\n+  }\n+  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_klass_id)));\n+  if (res != r0) {\n+    \/\/ Swap back r0 and res. This brings the call return value\n+    \/\/ from r0 into res, and the preserved value in res back into r0.\n+    __ mov(rscratch1, r0);\n+    __ mov(r0, res);\n+    __ mov(res, rscratch1);\n+  }\n+  __ b(_continuation);\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1232,1 +1232,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n@@ -2290,2 +2290,0 @@\n-  Address src_klass_addr = Address(src, oopDesc::klass_offset_in_bytes());\n-  Address dst_klass_addr = Address(dst, oopDesc::klass_offset_in_bytes());\n@@ -2352,9 +2350,4 @@\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(tmp, src_klass_addr);\n-        __ ldrw(rscratch1, dst_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(tmp, src_klass_addr);\n-        __ ldr(rscratch1, dst_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      assert(UseCompressedClassPointers, \"Lilliput\");\n+      __ load_nklass(tmp, src);\n+      __ load_nklass(rscratch1, dst);\n+      __ cmpw(tmp, rscratch1);\n@@ -2375,2 +2368,4 @@\n-      __ load_klass(src, src);\n-      __ load_klass(dst, dst);\n+      __ load_klass(tmp, src);\n+      __ mov(src, tmp);\n+      __ load_klass(tmp, dst);\n+      __ mov(dst, tmp);\n@@ -2486,0 +2481,1 @@\n+    assert(UseCompressedClassPointers, \"Lilliput\");\n@@ -2487,8 +2483,2 @@\n-\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(rscratch1, dst_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(rscratch1, dst_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ load_nklass(rscratch1, dst);\n+      __ cmpw(tmp, rscratch1);\n@@ -2496,7 +2486,2 @@\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(rscratch1, src_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(rscratch1, src_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ load_nklass(rscratch1, src);\n+      __ cmpw(tmp, rscratch1);\n@@ -2505,7 +2490,2 @@\n-      if (UseCompressedClassPointers) {\n-        __ ldrw(rscratch1, dst_klass_addr);\n-        __ cmpw(tmp, rscratch1);\n-      } else {\n-        __ ldr(rscratch1, dst_klass_addr);\n-        __ cmp(tmp, rscratch1);\n-      }\n+      __ load_nklass(rscratch1, dst);\n+      __ cmpw(tmp, rscratch1);\n@@ -2585,0 +2565,1 @@\n+  Register tmp = rscratch1;\n@@ -2591,6 +2572,14 @@\n-  if (UseCompressedClassPointers) {\n-    __ ldrw(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n-    __ decode_klass_not_null(result);\n-  } else {\n-    __ ldr(result, Address (obj, oopDesc::klass_offset_in_bytes()));\n-  }\n+  assert(UseCompressedClassPointers, \"expects UseCompressedClassPointers\");\n+\n+  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+  __ ldr(tmp, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  __ eor(tmp, tmp, markWord::unlocked_value);\n+  __ tst(tmp, markWord::lock_mask_in_place);\n+  __ br(Assembler::NE, *op->stub()->entry());\n+\n+  \/\/ Fast-path: shift and decode Klass*.\n+  __ mov(result, tmp);\n+  __ lsr(result, result, markWord::klass_shift);\n+\n+  __ bind(*op->stub()->continuation());\n+  __ decode_klass_not_null(result);\n@@ -2657,1 +2646,2 @@\n-      __ load_klass(recv, recv);\n+      __ load_klass(rscratch1, recv);\n+      __ mov(recv, rscratch1);\n@@ -2751,1 +2741,2 @@\n-      __ load_klass(tmp, tmp);\n+      __ load_klass(rscratch1, tmp);\n+      __ mov(tmp, rscratch1);\n@@ -2764,1 +2755,2 @@\n-          __ load_klass(tmp, tmp);\n+          __ load_klass(rscratch1, tmp);\n+          __ mov(tmp, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":37,"deletions":45,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -166,2 +166,1 @@\n-  \/\/ This assumes that all prototype bits fit in an int32_t\n-  mov(t1, (int32_t)(intptr_t)markWord::prototype().value());\n+  ldr(t1, Address(klass, Klass::prototype_header_offset()));\n@@ -170,7 +169,0 @@\n-  if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n-    encode_klass_not_null(t1, klass);\n-    strw(t1, Address(obj, oopDesc::klass_offset_in_bytes()));\n-  } else {\n-    str(klass, Address(obj, oopDesc::klass_offset_in_bytes()));\n-  }\n-\n@@ -179,2 +171,0 @@\n-  } else if (UseCompressedClassPointers) {\n-    store_klass_gap(obj, zr);\n@@ -198,0 +188,6 @@\n+  \/\/ Zero first 4 bytes, if start offset is not word aligned.\n+  if (!is_aligned(hdr_size_in_bytes, BytesPerWord)) {\n+    strw(zr, Address(obj, hdr_size_in_bytes));\n+    hdr_size_in_bytes += BytesPerInt;\n+  }\n+\n@@ -247,1 +243,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, int f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, int f, Register klass, Label& slow_case) {\n@@ -260,1 +256,1 @@\n-  mov(arr_size, (int32_t)header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  mov(arr_size, (int32_t)base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -269,1 +265,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, t1, t2);\n+  initialize_body(obj, arr_size, base_offset_in_bytes, t1, t2);\n@@ -286,1 +282,1 @@\n-  assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()), \"must add explicit null check\");\n+  assert(!MacroAssembler::needs_explicit_null_check(oopDesc::mark_offset_in_bytes()), \"must add explicit null check\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -276,2 +276,2 @@\n-static OopMap* save_live_registers(StubAssembler* sasm,\n-                                   bool save_fpu_registers = true) {\n+static void save_live_registers_no_oop_map(StubAssembler* sasm,\n+                                              bool save_fpu_registers = true) {\n@@ -291,0 +291,1 @@\n+}\n@@ -292,0 +293,3 @@\n+static OopMap* save_live_registers(StubAssembler* sasm,\n+                                   bool save_fpu_registers = true) {\n+  save_live_registers_no_oop_map(sasm, save_fpu_registers);\n@@ -674,0 +678,10 @@\n+    case load_klass_id:\n+      {\n+        StubFrame f(sasm, \"load_klass\", dont_gc_arguments);\n+        save_live_registers_no_oop_map(sasm, true);\n+        f.load_argument(0, r0); \/\/ obj\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_nklass_runtime), r0);\n+        restore_live_registers_except_r0(sasm, true);\n+      }\n+      break;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"macroAssembler_aarch64.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return MacroAssembler::klass_decode_mode_for_base(p) != MacroAssembler::KlassDecodeNone;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT_X\n+               \", Encoding mode %s\",\n+               p2i(base()), shift(), KlassEncodingMetaspaceMax,\n+               MacroAssembler::describe_klass_decode_mode(MacroAssembler::klass_decode_mode()));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -1638,1 +1638,2 @@\n-  load_klass(obj, obj);\n+  load_klass(rscratch1, obj);\n+  mov(obj, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"logging\/log.hpp\"\n@@ -48,0 +49,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -4044,6 +4046,32 @@\n-void MacroAssembler::load_klass(Register dst, Register src) {\n-  if (UseCompressedClassPointers) {\n-    ldrw(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n-    decode_klass_not_null(dst);\n-  } else {\n-    ldr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+\/\/ Loads the obj's Klass* into dst.\n+\/\/ src and dst must be distinct registers\n+\/\/ Preserves all registers (incl src, rscratch1 and rscratch2), but clobbers condition flags\n+void MacroAssembler::load_nklass(Register dst, Register src) {\n+  assert(UseCompressedClassPointers, \"expects UseCompressedClassPointers\");\n+\n+  assert_different_registers(src, dst);\n+\n+  Label slow, done;\n+\n+  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+  ldr(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n+  eor(dst, dst, markWord::unlocked_value);\n+  tst(dst, markWord::lock_mask_in_place);\n+  br(Assembler::NE, slow);\n+\n+  \/\/ Fast-path: shift and decode Klass*.\n+  lsr(dst, dst, markWord::klass_shift);\n+  b(done);\n+\n+  bind(slow);\n+  RegSet saved_regs = RegSet::of(lr);\n+  \/\/ We need r0 as argument and return register for the call. Preserve it, if necessary.\n+  if (dst != r0) {\n+    saved_regs += RegSet::of(r0);\n+  }\n+  push(saved_regs, sp);\n+  mov(r0, src);\n+  assert(StubRoutines::load_nklass() != NULL, \"Must have stub\");\n+  far_call(RuntimeAddress(StubRoutines::load_nklass()));\n+  if (dst != r0) {\n+    mov(dst, r0);\n@@ -4051,0 +4079,7 @@\n+  pop(saved_regs, sp);\n+  bind(done);\n+}\n+\n+void MacroAssembler::load_klass(Register dst, Register src) {\n+  load_nklass(dst, src);\n+  decode_klass_not_null(dst);\n@@ -4084,14 +4119,10 @@\n-  if (UseCompressedClassPointers) {\n-    ldrw(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n-    if (CompressedKlassPointers::base() == NULL) {\n-      cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());\n-      return;\n-    } else if (((uint64_t)CompressedKlassPointers::base() & 0xffffffff) == 0\n-               && CompressedKlassPointers::shift() == 0) {\n-      \/\/ Only the bottom 32 bits matter\n-      cmpw(trial_klass, tmp);\n-      return;\n-    }\n-    decode_klass_not_null(tmp);\n-  } else {\n-    ldr(tmp, Address(oop, oopDesc::klass_offset_in_bytes()));\n+  assert(UseCompressedClassPointers, \"Lilliput\");\n+  load_nklass(tmp, oop);\n+  if (CompressedKlassPointers::base() == NULL) {\n+    cmp(trial_klass, tmp, LSL, CompressedKlassPointers::shift());\n+    return;\n+  } else if (((uint64_t)CompressedKlassPointers::base() & 0xffffffff) == 0\n+             && CompressedKlassPointers::shift() == 0) {\n+    \/\/ Only the bottom 32 bits matter\n+    cmpw(trial_klass, tmp);\n+    return;\n@@ -4099,0 +4130,1 @@\n+  decode_klass_not_null(tmp);\n@@ -4102,18 +4134,0 @@\n-void MacroAssembler::store_klass(Register dst, Register src) {\n-  \/\/ FIXME: Should this be a store release?  concurrent gcs assumes\n-  \/\/ klass length is valid if klass field is not null.\n-  if (UseCompressedClassPointers) {\n-    encode_klass_not_null(src);\n-    strw(src, Address(dst, oopDesc::klass_offset_in_bytes()));\n-  } else {\n-    str(src, Address(dst, oopDesc::klass_offset_in_bytes()));\n-  }\n-}\n-\n-void MacroAssembler::store_klass_gap(Register dst, Register src) {\n-  if (UseCompressedClassPointers) {\n-    \/\/ Store to klass gap in destination\n-    strw(src, Address(dst, oopDesc::klass_gap_offset_in_bytes()));\n-  }\n-}\n-\n@@ -4254,0 +4268,14 @@\n+\/\/ Returns a static string\n+const char* MacroAssembler::describe_klass_decode_mode(MacroAssembler::KlassDecodeMode mode) {\n+  switch (mode) {\n+  case KlassDecodeNone: return \"none\";\n+  case KlassDecodeZero: return \"zero\";\n+  case KlassDecodeXor:  return \"xor\";\n+  case KlassDecodeMovk: return \"movk\";\n+  default:\n+    ShouldNotReachHere();\n+  }\n+  return NULL;\n+}\n+\n+\/\/ Return the current narrow Klass pointer decode mode.\n@@ -4255,2 +4283,4 @@\n-  assert(UseCompressedClassPointers, \"not using compressed class pointers\");\n-  assert(Metaspace::initialized(), \"metaspace not initialized yet\");\n+  if (_klass_decode_mode == KlassDecodeNone) {\n+    \/\/ First time initialization\n+    assert(UseCompressedClassPointers, \"not using compressed class pointers\");\n+    assert(Metaspace::initialized(), \"metaspace not initialized yet\");\n@@ -4258,2 +4288,5 @@\n-  if (_klass_decode_mode != KlassDecodeNone) {\n-    return _klass_decode_mode;\n+    _klass_decode_mode = klass_decode_mode_for_base(CompressedKlassPointers::base());\n+    guarantee(_klass_decode_mode != KlassDecodeNone,\n+              PTR_FORMAT \" is not a valid encoding base on aarch64\",\n+              p2i(CompressedKlassPointers::base()));\n+    log_info(metaspace)(\"klass decode mode initialized: %s\", describe_klass_decode_mode(_klass_decode_mode));\n@@ -4261,0 +4294,2 @@\n+  return _klass_decode_mode;\n+}\n@@ -4262,2 +4297,4 @@\n-  assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift()\n-         || 0 == CompressedKlassPointers::shift(), \"decode alg wrong\");\n+\/\/ Given an arbitrary base address, return the KlassDecodeMode that would be used. Return KlassDecodeNone\n+\/\/ if base address is not valid for encoding.\n+MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode_for_base(address base) {\n+  assert(CompressedKlassPointers::shift() != 0, \"not lilliput?\");\n@@ -4265,2 +4302,4 @@\n-  if (CompressedKlassPointers::base() == NULL) {\n-    return (_klass_decode_mode = KlassDecodeZero);\n+  const uint64_t base_u64 = (uint64_t) base;\n+\n+  if (base_u64 == 0) {\n+    return KlassDecodeZero;\n@@ -4269,7 +4308,3 @@\n-  if (operand_valid_for_logical_immediate(\n-        \/*is32*\/false, (uint64_t)CompressedKlassPointers::base())) {\n-    const uint64_t range_mask =\n-      (1ULL << log2i(CompressedKlassPointers::range())) - 1;\n-    if (((uint64_t)CompressedKlassPointers::base() & range_mask) == 0) {\n-      return (_klass_decode_mode = KlassDecodeXor);\n-    }\n+  if (operand_valid_for_logical_immediate(false, base_u64) &&\n+      ((base_u64 & (KlassEncodingMetaspaceMax - 1)) == 0)) {\n+    return KlassDecodeXor;\n@@ -4278,4 +4313,4 @@\n-  const uint64_t shifted_base =\n-    (uint64_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n-  guarantee((shifted_base & 0xffff0000ffffffff) == 0,\n-            \"compressed class base bad alignment\");\n+  const uint64_t shifted_base = base_u64 >> CompressedKlassPointers::shift();\n+  if ((shifted_base & 0xffff0000ffffffff) == 0) {\n+    return KlassDecodeMovk;\n+  }\n@@ -4283,1 +4318,1 @@\n-  return (_klass_decode_mode = KlassDecodeMovk);\n+  return KlassDecodeNone;\n@@ -4287,0 +4322,2 @@\n+  assert (UseCompressedClassPointers, \"should only be used for compressed headers\");\n+  assert(CompressedKlassPointers::shift() != 0, \"not lilliput?\");\n@@ -4289,5 +4326,1 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      lsr(dst, src, LogKlassAlignmentInBytes);\n-    } else {\n-      if (dst != src) mov(dst, src);\n-    }\n+    lsr(dst, src, LogKlassAlignmentInBytes);\n@@ -4297,6 +4330,2 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      eor(dst, src, (uint64_t)CompressedKlassPointers::base());\n-      lsr(dst, dst, LogKlassAlignmentInBytes);\n-    } else {\n-      eor(dst, src, (uint64_t)CompressedKlassPointers::base());\n-    }\n+    eor(dst, src, (uint64_t)CompressedKlassPointers::base());\n+    lsr(dst, dst, LogKlassAlignmentInBytes);\n@@ -4306,5 +4335,1 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      ubfx(dst, src, LogKlassAlignmentInBytes, 32);\n-    } else {\n-      movw(dst, src);\n-    }\n+    ubfx(dst, src, LogKlassAlignmentInBytes, MaxNarrowKlassPointerBits);\n@@ -4326,0 +4351,2 @@\n+  assert(CompressedKlassPointers::shift() != 0, \"not lilliput?\");\n+\n@@ -4328,5 +4355,1 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      lsl(dst, src, LogKlassAlignmentInBytes);\n-    } else {\n-      if (dst != src) mov(dst, src);\n-    }\n+    if (dst != src) mov(dst, src);\n@@ -4336,6 +4359,2 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      lsl(dst, src, LogKlassAlignmentInBytes);\n-      eor(dst, dst, (uint64_t)CompressedKlassPointers::base());\n-    } else {\n-      eor(dst, src, (uint64_t)CompressedKlassPointers::base());\n-    }\n+    lsl(dst, src, LogKlassAlignmentInBytes);\n+    eor(dst, dst, (uint64_t)CompressedKlassPointers::base());\n@@ -4348,0 +4367,3 @@\n+    \/\/ Invalid base should have been gracefully handled via klass_decode_mode() in VM initialization.\n+    assert((shifted_base & 0xffff0000ffffffff) == 0, \"incompatible base\");\n+\n@@ -4350,5 +4372,1 @@\n-\n-    if (CompressedKlassPointers::shift() != 0) {\n-      lsl(dst, dst, LogKlassAlignmentInBytes);\n-    }\n-\n+    lsl(dst, dst, LogKlassAlignmentInBytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":108,"deletions":90,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -89,0 +89,2 @@\n+ public:\n+\n@@ -96,1 +98,9 @@\n-  KlassDecodeMode klass_decode_mode();\n+  \/\/ Return the current narrow Klass pointer decode mode. Initialized on first call.\n+  static KlassDecodeMode klass_decode_mode();\n+\n+  \/\/ Given an arbitrary base address, return the KlassDecodeMode that would be used. Return KlassDecodeNone\n+  \/\/ if base address is not valid for encoding.\n+  static KlassDecodeMode klass_decode_mode_for_base(address base);\n+\n+  \/\/ Returns a static string\n+  static const char* describe_klass_decode_mode(KlassDecodeMode mode);\n@@ -99,0 +109,1 @@\n+\n@@ -842,0 +853,1 @@\n+  void load_nklass(Register dst, Register src);\n@@ -843,1 +855,0 @@\n-  void store_klass(Register dst, Register src);\n@@ -869,2 +880,0 @@\n-  void store_klass_gap(Register dst, Register src);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -325,1 +325,1 @@\n-        __ null_check(receiver_reg, oopDesc::klass_offset_in_bytes());\n+        __ null_check(receiver_reg, oopDesc::mark_offset_in_bytes());\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -597,2 +597,12 @@\n-    __ load_klass(r0, r0);  \/\/ get klass\n-    __ cbz(r0, error);      \/\/ if klass is NULL it is broken\n+    \/\/ NOTE: We used to load the Klass* here, and compare that to zero.\n+    \/\/ However, with current Lilliput implementation, that would require\n+    \/\/ checking the locking bits and calling into the runtime, which\n+    \/\/ clobbers the condition flags, which may be live around this call.\n+    \/\/ OTOH, this is a simple NULL-check, and we can simply load the upper\n+    \/\/ 32bit of the header as narrowKlass, and compare that to 0. The\n+    \/\/ worst that can happen (rarely) is that the object is locked and\n+    \/\/ we have lock pointer bits in the upper 32bits. We can't get a false\n+    \/\/ negative.\n+    assert(oopDesc::klass_offset_in_bytes() % 4 == 0, \"must be 4 byte aligned\");\n+    __ ldrw(r0, Address(r0, oopDesc::klass_offset_in_bytes()));  \/\/ get klass\n+    __ cbzw(r0, error);      \/\/ if klass is NULL it is broken\n@@ -6647,0 +6657,23 @@\n+  \/\/ Pass object argument in r0 (which has to be preserved outside this stub)\n+  \/\/ Pass back result in r0\n+  \/\/ Clobbers rscratch1\n+  address generate_load_nklass() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"load_nklass\");\n+\n+    address start = __ pc();\n+\n+    __ set_last_Java_frame(sp, rfp, lr, rscratch1);\n+    __ enter();\n+    __ push(RegSet::of(rscratch1, rscratch2), sp);\n+    __ push_call_clobbered_registers_except(r0);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_nklass_runtime), 1);\n+    __ pop_call_clobbered_registers_except(r0);\n+    __ pop(RegSet::of(rscratch1, rscratch2), sp);\n+    __ leave();\n+    __ reset_last_Java_frame(true);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -7814,0 +7847,2 @@\n+\n+    StubRoutines::_load_nklass = generate_load_nklass();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":37,"deletions":2,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -3239,1 +3239,1 @@\n-  __ null_check(recv, oopDesc::klass_offset_in_bytes());\n+  __ null_check(recv, oopDesc::mark_offset_in_bytes());\n@@ -3329,1 +3329,1 @@\n-  __ null_check(r2, oopDesc::klass_offset_in_bytes());\n+  __ null_check(r2, oopDesc::mark_offset_in_bytes());\n@@ -3346,1 +3346,1 @@\n-  __ null_check(r2, oopDesc::klass_offset_in_bytes());\n+  __ null_check(r2, oopDesc::mark_offset_in_bytes());\n@@ -3534,1 +3534,1 @@\n-    __ mov(rscratch1, (intptr_t)markWord::prototype().value());\n+    __ ldr(rscratch1, Address(r4, Klass::prototype_header_offset()));\n@@ -3536,2 +3536,0 @@\n-    __ store_klass_gap(r0, zr);  \/\/ zero klass gap for compressed oops\n-    __ store_klass(r0, r4);      \/\/ store klass last\n@@ -3667,1 +3665,2 @@\n-  __ load_klass(r3, r3);\n+  __ load_klass(rscratch1, r3);\n+  __ mov(r3, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -215,1 +215,1 @@\n-  const ptrdiff_t estimate = 124;\n+  const ptrdiff_t estimate = 168;\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -246,0 +246,4 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/arm\/c1_CodeStubs_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -974,1 +974,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n","filename":"src\/hotspot\/cpu\/arm\/c1_LIRAssembler_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-                                       int header_size, int element_size,\n+                                       int header_size_in_bytes, int element_size,\n@@ -163,1 +163,0 @@\n-  const int header_size_in_bytes = header_size * BytesPerWord;\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-                      int header_size, int element_size,\n+                      int header_size_in_bytes, int element_size,\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -320,0 +320,4 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/c1_CodeStubs_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return true;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT, p2i(base()), shift(),\n+               KlassEncodingMetaspaceMax);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/compressedKlass_ppc64.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -273,0 +273,5 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  \/\/ Currently not needed.\n+  Unimplemented();\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/c1_CodeStubs_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return true;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT, p2i(base()), shift(),\n+               KlassEncodingMetaspaceMax);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/compressedKlass_s390.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -303,0 +303,20 @@\n+void LoadKlassStub::emit_code(LIR_Assembler* ce) {\n+  __ bind(_entry);\n+#ifdef _LP64\n+  Register res = _result->as_register();\n+  ce->store_parameter(_obj->as_register(), 0);\n+  if (res != rax) {\n+    \/\/ This preserves rax and allows it to be used as return-register,\n+    \/\/ without messing with the stack.\n+    __ xchgptr(rax, res);\n+  }\n+  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_klass_id)));\n+  if (res != rax) {\n+    \/\/ Swap back rax, and move result to correct register.\n+    __ xchgptr(rax, res);\n+  }\n+  __ jmp(_continuation);\n+#else\n+  __ should_not_reach_here();\n+#endif\n+}\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1638,1 +1638,1 @@\n-                      arrayOopDesc::header_size(op->type()),\n+                      arrayOopDesc::base_offset_in_bytes(op->type()),\n@@ -3069,0 +3069,1 @@\n+  Register tmp2 = LP64_ONLY(rscratch2) NOT_LP64(noreg);\n@@ -3193,0 +3194,1 @@\n+#ifndef _LP64\n@@ -3195,1 +3197,1 @@\n-\n+#endif\n@@ -3260,7 +3262,8 @@\n-      if (UseCompressedClassPointers) {\n-        __ movl(tmp, src_klass_addr);\n-        __ cmpl(tmp, dst_klass_addr);\n-      } else {\n-        __ movptr(tmp, src_klass_addr);\n-        __ cmpptr(tmp, dst_klass_addr);\n-      }\n+#ifdef _LP64\n+      __ load_nklass(tmp, src);\n+      __ load_nklass(tmp2, dst);\n+      __ cmpl(tmp, tmp2);\n+#else\n+      __ movptr(tmp, src_klass_addr);\n+      __ cmpptr(tmp, dst_klass_addr);\n+#endif\n@@ -3422,5 +3425,2 @@\n-    if (UseCompressedClassPointers) {\n-      __ encode_klass_not_null(tmp, rscratch1);\n-    }\n-#endif\n-\n+    assert(UseCompressedClassPointers, \"Lilliput\");\n+    __ encode_klass_not_null(tmp, rscratch1);\n@@ -3428,3 +3428,12 @@\n-\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);\n-      else                   __ cmpptr(tmp, dst_klass_addr);\n+      __ load_nklass(tmp2, dst);\n+      __ cmpl(tmp, tmp2);\n+      __ jcc(Assembler::notEqual, halt);\n+      __ load_nklass(tmp2, src);\n+      __ cmpl(tmp, tmp2);\n+      __ jcc(Assembler::equal, known_ok);\n+    } else {\n+      __ load_nklass(tmp2, dst);\n+      __ cmpl(tmp, tmp2);\n+#else\n+    if (basic_type != T_OBJECT) {\n+      __ cmpptr(tmp, dst_klass_addr);\n@@ -3432,2 +3441,1 @@\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, src_klass_addr);\n-      else                   __ cmpptr(tmp, src_klass_addr);\n+      __ cmpptr(tmp, src_klass_addr);\n@@ -3436,2 +3444,2 @@\n-      if (UseCompressedClassPointers)          __ cmpl(tmp, dst_klass_addr);\n-      else                   __ cmpptr(tmp, dst_klass_addr);\n+      __ cmpptr(tmp, dst_klass_addr);\n+#endif\n@@ -3526,3 +3534,2 @@\n-  CodeEmitInfo* info = op->info();\n-  if (info != NULL) {\n-    add_debug_info_for_null_check_here(info);\n+  if (op->info() != NULL) {\n+    add_debug_info_for_null_check_here(op->info());\n@@ -3530,1 +3537,0 @@\n-\n@@ -3532,4 +3538,20 @@\n-  if (UseCompressedClassPointers) {\n-    __ movl(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n-    __ decode_klass_not_null(result, rscratch1);\n-  } else\n+  Register tmp = rscratch1;\n+  assert_different_registers(tmp, obj);\n+  assert_different_registers(tmp, result);\n+\n+  \/\/ Check if we can take the (common) fast path, if obj is unlocked.\n+  __ movq(tmp, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  __ xorq(tmp, markWord::unlocked_value);\n+  __ testb(tmp, markWord::lock_mask_in_place);\n+  __ jcc(Assembler::notZero, *op->stub()->entry());\n+\n+  \/\/ Fast-path: shift and decode Klass*.\n+  __ movq(result, tmp);\n+  __ shrq(result, markWord::klass_shift);\n+\n+  __ bind(*op->stub()->continuation());\n+  __ decode_klass_not_null(result, tmp);\n+#else\n+  __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n+  \/\/ Not really needed, but bind the label anyway to make compiler happy.\n+  __ bind(*op->stub()->continuation());\n@@ -3537,1 +3559,0 @@\n-    __ movptr(result, Address(obj, oopDesc::klass_offset_in_bytes()));\n@@ -3643,4 +3664,0 @@\n-#ifndef ASSERT\n-      __ jmpb(next);\n-    }\n-#else\n@@ -3649,0 +3666,1 @@\n+#ifdef ASSERT\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":52,"deletions":34,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -147,8 +147,5 @@\n-  assert_different_registers(obj, klass, len);\n-  movptr(Address(obj, oopDesc::mark_offset_in_bytes()), checked_cast<int32_t>(markWord::prototype().value()));\n-#ifdef _LP64\n-  if (UseCompressedClassPointers) { \/\/ Take care not to kill klass\n-    movptr(t1, klass);\n-    encode_klass_not_null(t1, rscratch1);\n-    movl(Address(obj, oopDesc::klass_offset_in_bytes()), t1);\n-  } else\n+  assert_different_registers(obj, klass, len, t1, t2);\n+  movptr(t1, Address(klass, Klass::prototype_header_offset()));\n+  movptr(Address(obj, oopDesc::mark_offset_in_bytes()), t1);\n+#ifndef _LP64\n+  movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n@@ -156,3 +153,0 @@\n-  {\n-    movptr(Address(obj, oopDesc::klass_offset_in_bytes()), klass);\n-  }\n@@ -163,6 +157,0 @@\n-#ifdef _LP64\n-  else if (UseCompressedClassPointers) {\n-    xorptr(t1, t1);\n-    store_klass_gap(obj, t1);\n-  }\n-#endif\n@@ -246,1 +234,1 @@\n-void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int header_size, Address::ScaleFactor f, Register klass, Label& slow_case) {\n+void C1_MacroAssembler::allocate_array(Register obj, Register len, Register t1, Register t2, int base_offset_in_bytes, Address::ScaleFactor f, Register klass, Label& slow_case) {\n@@ -259,1 +247,1 @@\n-  movptr(arr_size, header_size * BytesPerWord + MinObjAlignmentInBytesMask);\n+  movptr(arr_size, (int32_t)base_offset_in_bytes + MinObjAlignmentInBytesMask);\n@@ -269,1 +257,1 @@\n-  initialize_body(obj, arr_size, header_size * BytesPerWord, len_zero);\n+  initialize_body(obj, arr_size, base_offset_in_bytes, len_zero);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1043,1 +1043,11 @@\n-\n+#ifdef _LP64\n+    case load_klass_id:\n+      {\n+        StubFrame f(sasm, \"load_klass\", dont_gc_arguments);\n+        sasm->save_live_registers_no_oop_map(true);\n+        f.load_argument(0, c_rarg0); \/\/ obj\n+        __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_nklass_runtime), c_rarg0);\n+        sasm->restore_live_registers_except_rax(true);\n+      }\n+      break;\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"macroAssembler_x86.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+#ifdef _LP64\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return MacroAssembler::klass_decode_mode_for_base(p) != MacroAssembler::KlassDecodeNone;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT_X\n+               \", Encoding mode %s\",\n+               p2i(base()), shift(), KlassEncodingMetaspaceMax,\n+               MacroAssembler::describe_klass_decode_mode(MacroAssembler::klass_decode_mode()));\n+}\n+\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -59,1 +59,1 @@\n-  jmpb(next);\n+  jmp(next);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"logging\/log.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -4121,1 +4123,1 @@\n-  assert((offset_in_bytes & (BytesPerWord - 1)) == 0, \"offset must be a multiple of BytesPerWord\");\n+  assert((offset_in_bytes & (BytesPerInt - 1)) == 0, \"offset must be a multiple of BytesPerInt\");\n@@ -4127,0 +4129,13 @@\n+  \/\/ Emit single 32bit store to clear leading bytes, if necessary.\n+  xorptr(temp, temp);    \/\/ use _zero reg to clear memory (shorter code)\n+#ifdef _LP64\n+  if (!is_aligned(offset_in_bytes, BytesPerWord)) {\n+    movl(Address(address, offset_in_bytes), temp);\n+    offset_in_bytes += BytesPerInt;\n+    decrement(length_in_bytes, BytesPerInt);\n+  }\n+  assert((offset_in_bytes & (BytesPerWord - 1)) == 0, \"offset must be a multiple of BytesPerWord\");\n+  testptr(length_in_bytes, length_in_bytes);\n+  jcc(Assembler::zero, done);\n+#endif\n+\n@@ -4139,1 +4154,0 @@\n-  xorptr(temp, temp);    \/\/ use _zero reg to clear memory (shorter code)\n@@ -5071,3 +5085,0 @@\n-void MacroAssembler::load_klass(Register dst, Register src, Register tmp) {\n-  assert_different_registers(src, tmp);\n-  assert_different_registers(dst, tmp);\n@@ -5075,6 +5086,30 @@\n-  if (UseCompressedClassPointers) {\n-    movl(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n-    decode_klass_not_null(dst, tmp);\n-  } else\n-#endif\n-    movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n+void MacroAssembler::load_nklass(Register dst, Register src) {\n+  assert_different_registers(src, dst);\n+  assert(UseCompressedClassPointers, \"expect compressed class pointers\");\n+\n+  Label slow, done;\n+  movq(dst, Address(src, oopDesc::mark_offset_in_bytes()));\n+  \/\/ NOTE: While it would seem nice to use xorb instead (for which we don't have an encoding in our assembler),\n+  \/\/ the encoding for xorq uses the signed version (0x81\/6) of xor, which encodes as compact as xorb would,\n+  \/\/ and does't make a difference performance-wise.\n+  xorq(dst, markWord::unlocked_value);\n+  testb(dst, markWord::lock_mask_in_place);\n+  jccb(Assembler::notZero, slow);\n+\n+  shrq(dst, markWord::klass_shift);\n+  jmp(done);\n+  bind(slow);\n+\n+  if (dst != rax) {\n+    push(rax);\n+  }\n+  if (src != rax) {\n+    mov(rax, src);\n+  }\n+  call(RuntimeAddress(StubRoutines::load_nklass()));\n+  if (dst != rax) {\n+    mov(dst, rax);\n+    pop(rax);\n+  }\n+\n+  bind(done);\n@@ -5082,0 +5117,1 @@\n+#endif\n@@ -5083,1 +5119,1 @@\n-void MacroAssembler::store_klass(Register dst, Register src, Register tmp) {\n+void MacroAssembler::load_klass(Register dst, Register src, Register tmp, bool null_check_src) {\n@@ -5087,4 +5123,18 @@\n-  if (UseCompressedClassPointers) {\n-    encode_klass_not_null(src, tmp);\n-    movl(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n-  } else\n+  assert(UseCompressedClassPointers, \"expect compressed class pointers\");\n+  Register d = dst;\n+  if (src == dst) {\n+    d = tmp;\n+  }\n+  if (null_check_src) {\n+    null_check(src, oopDesc::mark_offset_in_bytes());\n+  }\n+  load_nklass(d, src);\n+  if (src == dst) {\n+    mov(dst, d);\n+  }\n+  decode_klass_not_null(dst, tmp);\n+#else\n+  if (null_check_src) {\n+    null_check(src, oopDesc::klass_offset_in_bytes());\n+  }\n+  movptr(dst, Address(src, oopDesc::klass_offset_in_bytes()));\n@@ -5092,1 +5142,0 @@\n-    movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n@@ -5095,0 +5144,6 @@\n+#ifndef _LP64\n+void MacroAssembler::store_klass(Register dst, Register src) {\n+  movptr(Address(dst, oopDesc::klass_offset_in_bytes()), src);\n+}\n+#endif\n+\n@@ -5141,7 +5196,0 @@\n-void MacroAssembler::store_klass_gap(Register dst, Register src) {\n-  if (UseCompressedClassPointers) {\n-    \/\/ Store to klass gap in destination\n-    movl(Address(dst, oopDesc::klass_gap_offset_in_bytes()), src);\n-  }\n-}\n-\n@@ -5299,0 +5347,62 @@\n+MacroAssembler::KlassDecodeMode MacroAssembler::_klass_decode_mode = KlassDecodeNone;\n+\n+\/\/ Returns a static string\n+const char* MacroAssembler::describe_klass_decode_mode(MacroAssembler::KlassDecodeMode mode) {\n+  switch (mode) {\n+  case KlassDecodeNone: return \"none\";\n+  case KlassDecodeZero: return \"zero\";\n+  case KlassDecodeXor:  return \"xor\";\n+  case KlassDecodeAdd:  return \"add\";\n+  default:\n+    ShouldNotReachHere();\n+  }\n+  return NULL;\n+}\n+\n+\/\/ Return the current narrow Klass pointer decode mode.\n+MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode() {\n+  if (_klass_decode_mode == KlassDecodeNone) {\n+    \/\/ First time initialization\n+    assert(UseCompressedClassPointers, \"not using compressed class pointers\");\n+    assert(Metaspace::initialized(), \"metaspace not initialized yet\");\n+\n+    _klass_decode_mode = klass_decode_mode_for_base(CompressedKlassPointers::base());\n+    guarantee(_klass_decode_mode != KlassDecodeNone,\n+              PTR_FORMAT \" is not a valid encoding base on aarch64\",\n+              p2i(CompressedKlassPointers::base()));\n+    log_info(metaspace)(\"klass decode mode initialized: %s\", describe_klass_decode_mode(_klass_decode_mode));\n+  }\n+  return _klass_decode_mode;\n+}\n+\n+\/\/ Given an arbitrary base address, return the KlassDecodeMode that would be used. Return KlassDecodeNone\n+\/\/ if base address is not valid for encoding.\n+MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode_for_base(address base) {\n+  assert(CompressedKlassPointers::shift() != 0, \"not lilliput?\");\n+\n+  const uint64_t base_u64 = (uint64_t) base;\n+\n+  if (base_u64 == 0) {\n+    return KlassDecodeZero;\n+  }\n+\n+  if ((base_u64 & (KlassEncodingMetaspaceMax - 1)) == 0) {\n+    return KlassDecodeXor;\n+  }\n+\n+  \/\/ Note that there is no point in optimizing for shift=3 since lilliput\n+  \/\/ will use larger shifts\n+\n+  \/\/ The add+shift mode for decode_and_move_klass_not_null() requires the base to be\n+  \/\/  shiftable-without-loss. So, this is the minimum restriction on x64 for a valid\n+  \/\/  encoding base. This does not matter in reality since the shift values we use for\n+  \/\/  Lilliput, while large, won't be larger than a page size. And the encoding base\n+  \/\/  will be quite likely page aligned since it usually falls to the beginning of\n+  \/\/  either CDS or CCS.\n+  if ((base_u64 & (KlassAlignmentInBytes - 1)) == 0) {\n+    return KlassDecodeAdd;\n+  }\n+\n+  return KlassDecodeNone;\n+}\n+\n@@ -5301,1 +5411,12 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  switch (klass_decode_mode()) {\n+  case KlassDecodeZero: {\n+    shrq(r, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeXor: {\n+    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    xorq(r, tmp);\n+    shrq(r, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeAdd: {\n@@ -5304,0 +5425,2 @@\n+    shrq(r, CompressedKlassPointers::shift());\n+    break;\n@@ -5305,3 +5428,2 @@\n-  if (CompressedKlassPointers::shift() != 0) {\n-    assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-    shrq(r, LogKlassAlignmentInBytes);\n+  default:\n+    ShouldNotReachHere();\n@@ -5313,1 +5435,13 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  switch (klass_decode_mode()) {\n+  case KlassDecodeZero: {\n+    movptr(dst, src);\n+    shrq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeXor: {\n+    mov64(dst, (int64_t)CompressedKlassPointers::base());\n+    xorq(dst, src);\n+    shrq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeAdd: {\n@@ -5316,2 +5450,2 @@\n-  } else {\n-    movptr(dst, src);\n+    shrq(dst, CompressedKlassPointers::shift());\n+    break;\n@@ -5319,3 +5453,2 @@\n-  if (CompressedKlassPointers::shift() != 0) {\n-    assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-    shrq(dst, LogKlassAlignmentInBytes);\n+  default:\n+    ShouldNotReachHere();\n@@ -5327,8 +5460,5 @@\n-  \/\/ Note: it will change flags\n-  assert(UseCompressedClassPointers, \"should only be used for compressed headers\");\n-  \/\/ Cannot assert, unverified entry point counts instructions (see .ad file)\n-  \/\/ vtableStubs also counts instructions in pd_code_size_limit.\n-  \/\/ Also do not verify_oop as this is called by verify_oop.\n-  if (CompressedKlassPointers::shift() != 0) {\n-    assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-    shlq(r, LogKlassAlignmentInBytes);\n+  const uint64_t base_u64 = (uint64_t)CompressedKlassPointers::base();\n+  switch (klass_decode_mode()) {\n+  case KlassDecodeZero: {\n+    shlq(r, CompressedKlassPointers::shift());\n+    break;\n@@ -5336,2 +5466,11 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+  case KlassDecodeXor: {\n+    assert((base_u64 & (KlassEncodingMetaspaceMax - 1)) == 0,\n+           \"base \" UINT64_FORMAT_X \" invalid for xor mode\", base_u64); \/\/ should have been handled at VM init.\n+    shlq(r, CompressedKlassPointers::shift());\n+    mov64(tmp, base_u64);\n+    xorq(r, tmp);\n+    break;\n+  }\n+  case KlassDecodeAdd: {\n+    shlq(r, CompressedKlassPointers::shift());\n+    mov64(tmp, base_u64);\n@@ -5339,0 +5478,4 @@\n+    break;\n+  }\n+  default:\n+    ShouldNotReachHere();\n@@ -5344,3 +5487,1 @@\n-  \/\/ Note: it will change flags\n-  assert (UseCompressedClassPointers, \"should only be used for compressed headers\");\n-  \/\/ Cannot assert, unverified entry point counts instructions (see .ad file)\n+  \/\/ Note: Cannot assert, unverified entry point counts instructions (see .ad file)\n@@ -5350,18 +5491,28 @@\n-  if (CompressedKlassPointers::base() == NULL &&\n-      CompressedKlassPointers::shift() == 0) {\n-    \/\/ The best case scenario is that there is no base or shift. Then it is already\n-    \/\/ a pointer that needs nothing but a register rename.\n-    movl(dst, src);\n-  } else {\n-    if (CompressedKlassPointers::base() != NULL) {\n-      mov64(dst, (int64_t)CompressedKlassPointers::base());\n-    } else {\n-      xorq(dst, dst);\n-    }\n-    if (CompressedKlassPointers::shift() != 0) {\n-      assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-      assert(LogKlassAlignmentInBytes == Address::times_8, \"klass not aligned on 64bits?\");\n-      leaq(dst, Address(dst, src, Address::times_8, 0));\n-    } else {\n-      addq(dst, src);\n-    }\n+  const uint64_t base_u64 = (uint64_t)CompressedKlassPointers::base();\n+\n+  switch (klass_decode_mode()) {\n+  case KlassDecodeZero: {\n+    movq(dst, src);\n+    shlq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeXor: {\n+    assert((base_u64 & (KlassEncodingMetaspaceMax - 1)) == 0,\n+           \"base \" UINT64_FORMAT_X \" invalid for xor mode\", base_u64); \/\/ should have been handled at VM init.\n+    const uint64_t base_right_shifted = base_u64 >> CompressedKlassPointers::shift();\n+    mov64(dst, base_right_shifted);\n+    xorq(dst, src);\n+    shlq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeAdd: {\n+    assert((base_u64 & (KlassAlignmentInBytes - 1)) == 0,\n+           \"base \" UINT64_FORMAT_X \" invalid for add mode\", base_u64); \/\/ should have been handled at VM init.\n+    const uint64_t base_right_shifted = base_u64 >> CompressedKlassPointers::shift();\n+    mov64(dst, base_right_shifted);\n+    addq(dst, src);\n+    shlq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  default:\n+    ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":216,"deletions":65,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -82,0 +82,23 @@\n+ public:\n+\n+  enum KlassDecodeMode {\n+    KlassDecodeNone,\n+    KlassDecodeZero,\n+    KlassDecodeXor,\n+    KlassDecodeAdd\n+  };\n+\n+  \/\/ Return the current narrow Klass pointer decode mode. Initialized on first call.\n+  static KlassDecodeMode klass_decode_mode();\n+\n+  \/\/ Given an arbitrary base address, return the KlassDecodeMode that would be used. Return KlassDecodeNone\n+  \/\/ if base address is not valid for encoding.\n+  static KlassDecodeMode klass_decode_mode_for_base(address base);\n+\n+  \/\/ Returns a static string\n+  static const char* describe_klass_decode_mode(KlassDecodeMode mode);\n+\n+ private:\n+\n+  static KlassDecodeMode _klass_decode_mode;\n+\n@@ -350,2 +373,6 @@\n-  void load_klass(Register dst, Register src, Register tmp);\n-  void store_klass(Register dst, Register src, Register tmp);\n+  void load_klass(Register dst, Register src, Register tmp, bool null_check_src = false);\n+#ifdef _LP64\n+  void load_nklass(Register dst, Register src);\n+#else\n+  void store_klass(Register dst, Register src);\n+#endif\n@@ -370,2 +397,0 @@\n-  void store_klass_gap(Register dst, Register src);\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -382,2 +382,1 @@\n-        __ null_check(receiver_reg, oopDesc::klass_offset_in_bytes());\n-        __ load_klass(temp1_recv_klass, receiver_reg, temp2);\n+        __ load_klass(temp1_recv_klass, receiver_reg, temp2, true);\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3312,0 +3312,40 @@\n+  \/\/ Call stub to call runtime oopDesc::load_nklass_runtime().\n+  \/\/ rax: call argument (object)\n+  \/\/ rax: return object's narrowKlass\n+  \/\/ Preserves all caller-saved registers, except rax\n+#ifdef _LP64\n+address StubGenerator::generate_load_nklass() {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark(this, \"StubRoutines\", \"load_nklass\");\n+  address start = __ pc();\n+  __ enter(); \/\/ save rbp\n+\n+  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n+  __ push_FPU_state();\n+\n+  __ push(rdi);\n+  __ push(rsi);\n+  __ push(rdx);\n+  __ push(rcx);\n+  __ push(r8);\n+  __ push(r9);\n+  __ push(r10);\n+  __ push(r11);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_nklass_runtime), rax);\n+  __ pop(r11);\n+  __ pop(r10);\n+  __ pop(r9);\n+  __ pop(r8);\n+  __ pop(rcx);\n+  __ pop(rdx);\n+  __ pop(rsi);\n+  __ pop(rdi);\n+\n+  __ pop_FPU_state();\n+\n+  __ leave();\n+  __ ret(0);\n+  return start;\n+}\n+#endif \/\/ _LP64\n+\n@@ -3681,0 +3721,4 @@\n+#ifdef _LP64\n+  StubRoutines::_load_nklass = generate_load_nklass();\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -475,0 +475,3 @@\n+#ifdef _LP64\n+  address generate_load_nklass();\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3661,2 +3661,1 @@\n-  __ null_check(recv, oopDesc::klass_offset_in_bytes());\n-  __ load_klass(rax, recv, rscratch1);\n+  __ load_klass(rax, recv, rscratch1, true);\n@@ -3753,2 +3752,1 @@\n-  __ null_check(rcx, oopDesc::klass_offset_in_bytes());\n-  __ load_klass(rlocals, rcx, rscratch1);\n+  __ load_klass(rlocals, rcx, rscratch1, true);\n@@ -3776,2 +3774,1 @@\n-  __ null_check(rcx, oopDesc::klass_offset_in_bytes());\n-  __ load_klass(rdx, rcx, rscratch1);\n+  __ load_klass(rdx, rcx, rscratch1, true);\n@@ -3999,2 +3996,0 @@\n-    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes()),\n-              (intptr_t)markWord::prototype().value()); \/\/ header\n@@ -4002,3 +3997,4 @@\n-#ifdef _LP64\n-    __ xorl(rsi, rsi); \/\/ use zero reg to clear memory (shorter code)\n-    __ store_klass_gap(rax, rsi);  \/\/ zero klass gap for compressed oops\n+    __ movptr(rbx, Address(rcx, Klass::prototype_header_offset()));\n+    __ movptr(Address(rax, oopDesc::mark_offset_in_bytes ()), rbx);\n+#ifndef _LP64\n+    __ store_klass(rax, rcx);  \/\/ klass\n@@ -4006,1 +4002,0 @@\n-    __ store_klass(rax, rcx, rscratch1);  \/\/ klass\n@@ -4158,1 +4153,1 @@\n-  __ jmpb(resolved);\n+  __ jmp(resolved);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -220,1 +220,2 @@\n-  const ptrdiff_t estimate = 136;\n+  \/\/ Lilliput: expanded since load_klass is significantly and decode_klass somewhat larger.\n+  const ptrdiff_t estimate = 155;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5299,1 +5299,1 @@\n-instruct loadNKlass(rRegN dst, memory mem)\n+instruct loadNKlass(rRegN dst, indOffset8 mem, rFlagsReg cr)\n@@ -5302,1 +5302,1 @@\n-\n+  effect(TEMP_DEF dst, KILL cr);\n@@ -5306,1 +5306,3 @@\n-    __ movl($dst$$Register, $mem$$Address);\n+    assert($mem$$disp == oopDesc::klass_offset_in_bytes(), \"expect correct offset 4, but got: %d\", $mem$$disp);\n+    assert($mem$$index == 4, \"expect no index register: %d\", $mem$$index);\n+    __ load_nklass($dst$$Register, $mem$$base$$Register);\n@@ -5308,1 +5310,1 @@\n-  ins_pipe(ialu_reg_mem); \/\/ XXX\n+  ins_pipe(pipe_slow); \/\/ XXX\n@@ -12606,0 +12608,3 @@\n+\/\/ Disabled because the compressed Klass* in header cannot be safely\n+\/\/ accessed. TODO: Re-enable it as soon as synchronization does not\n+\/\/ overload the upper header bits anymore.\n@@ -12608,0 +12613,1 @@\n+  predicate(false);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+#ifdef _LP64\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return true;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT, p2i(base()), shift(),\n+               KlassEncodingMetaspaceMax);\n+}\n+\n+#endif \/\/ _LP64\n+\n","filename":"src\/hotspot\/cpu\/zero\/compressedKlass_zero.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -557,0 +557,19 @@\n+class LoadKlassStub: public CodeStub {\n+private:\n+  LIR_Opr          _obj;\n+  LIR_Opr          _result;\n+\n+public:\n+  LoadKlassStub(LIR_Opr obj, LIR_Opr result) :\n+    CodeStub(), _obj(obj), _result(result) {};\n+\n+  virtual void emit_code(LIR_Assembler* e);\n+  virtual void visit(LIR_OpVisitState* visitor) {\n+    visitor->do_input(_obj);\n+    visitor->do_output(_result);\n+  }\n+#ifndef PRODUCT\n+virtual void print_name(outputStream* out) const { out->print(\"LoadKlassStub\"); }\n+#endif \/\/ PRODUCT\n+};\n+\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -890,0 +890,1 @@\n+      do_stub(opLoadKlass->_stub);\n@@ -1070,0 +1071,1 @@\n+  masm->append_code_stub(stub());\n@@ -2038,0 +2040,1 @@\n+  out->print(\"[lbl:\" INTPTR_FORMAT \"]\", p2i(stub()->entry()));\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1904,0 +1904,1 @@\n+  CodeStub* _stub;\n@@ -1905,1 +1906,1 @@\n-  LIR_OpLoadKlass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info)\n+  LIR_OpLoadKlass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info, CodeStub* stub)\n@@ -1908,1 +1909,1 @@\n-    {}\n+    , _stub(stub) {}\n@@ -1911,0 +1912,1 @@\n+  CodeStub* stub()     const { return _stub; }\n@@ -2374,1 +2376,1 @@\n-  void load_klass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info) { append(new LIR_OpLoadKlass(obj, result, info)); }\n+  void load_klass(LIR_Opr obj, LIR_Opr result, CodeEmitInfo* info, CodeStub* stub) { append(new LIR_OpLoadKlass(obj, result, info, stub)); }\n","filename":"src\/hotspot\/share\/c1\/c1_LIR.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1244,1 +1244,2 @@\n-  __ load_klass(obj, klass, null_check_info);\n+  CodeStub* slow_path = new LoadKlassStub(obj, klass);\n+  __ load_klass(obj, klass, null_check_info, slow_path);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -247,0 +247,1 @@\n+  case load_klass_id:\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+  stub(load_klass)                   \\\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -43,0 +44,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -221,2 +223,4 @@\n-    \/\/ See RunTimeClassInfo::get_for()\n-    _estimated_metaspaceobj_bytes += align_up(BytesPerWord, SharedSpaceObjectAlignment);\n+    \/\/ See ArchiveBuilder::make_shallow_copies: make sure we have enough space for both maximum\n+    \/\/ Klass alignment as well as the RuntimeInfo* pointer we will embed in front of a Klass.\n+    _estimated_metaspaceobj_bytes += align_up(BytesPerWord, KlassAlignmentInBytes) +\n+        align_up(sizeof(void*), SharedSpaceObjectAlignment);\n@@ -619,4 +623,5 @@\n-    \/\/ Save a pointer immediate in front of an InstanceKlass, so\n-    \/\/ we can do a quick lookup from InstanceKlass* -> RunTimeClassInfo*\n-    \/\/ without building another hashtable. See RunTimeClassInfo::get_for()\n-    \/\/ in systemDictionaryShared.cpp.\n+    \/\/ Reserve space for a pointer immediately in front of an InstanceKlass. That space will\n+    \/\/ later be used to store the RuntimeClassInfo* pointer directly in front of the archived\n+    \/\/ InstanceKlass, in order to have a quick lookup InstanceKlass* -> RunTimeClassInfo*\n+    \/\/ without building another hashtable. See RunTimeClassInfo::get_for()\/::set_for() for\n+    \/\/ details.\n@@ -628,0 +633,3 @@\n+    dest = dump_region->allocate(bytes, KlassAlignmentInBytes);\n+  } else {\n+    dest = dump_region->allocate(bytes);\n@@ -629,1 +637,0 @@\n-  dest = dump_region->allocate(bytes);\n@@ -648,1 +655,2 @@\n-  log_trace(cds)(\"Copy: \" PTR_FORMAT \" ==> \" PTR_FORMAT \" %d\", p2i(src), p2i(dest), bytes);\n+  log_trace(cds)(\"Copy: \" PTR_FORMAT \" ==> \" PTR_FORMAT \" %d (%s)\", p2i(src), p2i(dest), bytes,\n+                 MetaspaceObj::type_name(ref->msotype()));\n@@ -652,0 +660,2 @@\n+\n+  DEBUG_ONLY(_alloc_stats.verify((int)dump_region->used(), src_info->read_only()));\n@@ -748,0 +758,7 @@\n+    Klass* requested_k = to_requested(k);\n+#ifdef _LP64\n+    narrowKlass nk = CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n+    k->set_prototype_header(markWord::prototype().set_narrow_klass(nk));\n+#else\n+    k->set_prototype_header(markWord::prototype());\n+#endif\n@@ -839,1 +856,3 @@\n-  o->set_narrow_klass(nk);\n+#ifdef _LP64\n+  o->set_mark(o->mark().set_narrow_klass(nk));\n+#endif\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":28,"deletions":9,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -46,3 +47,13 @@\n-\/\/ Metaspace::allocate() requires that all blocks must be aligned with KlassAlignmentInBytes.\n-\/\/ We enforce the same alignment rule in blocks allocated from the shared space.\n-const int SharedSpaceObjectAlignment = KlassAlignmentInBytes;\n+\/\/ CDS has three alignments to deal with:\n+\/\/ - SharedSpaceObjectAlignment, always 8 bytes: used for placing arbitrary structures.\n+\/\/   These may contain 64-bit members (not larger, we know that much). Therefore we\n+\/\/   need to use 64-bit alignment on both 32-bit and 64-bit platforms. We reuse metaspace\n+\/\/   minimal alignment for this, which follows the same logic.\n+\/\/ - With CompressedClassPointers=1, we need to store Klass structures with a large\n+\/\/   alignment (Lilliput specific narrow Klass pointer encoding) - KlassAlignmentInBytes.\n+\/\/ - Header data and tags are squeezed in with word alignment, which happens to be 4 bytes\n+\/\/   on 32-bit. See ReadClosure::do_xxx() and DumpRegion::append_intptr().\n+const int SharedSpaceObjectAlignment = metaspace::MetaspaceMinAlignmentBytes;\n+\n+\/\/ standard alignment should be sufficient for storing 64-bit values.\n+STATIC_ASSERT(SharedSpaceObjectAlignment >= sizeof(uint64_t));\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -208,3 +208,13 @@\n-char* DumpRegion::allocate(size_t num_bytes) {\n-  char* p = (char*)align_up(_top, (size_t)SharedSpaceObjectAlignment);\n-  char* newtop = p + align_up(num_bytes, (size_t)SharedSpaceObjectAlignment);\n+char* DumpRegion::allocate(size_t num_bytes, size_t alignment) {\n+  \/\/ We align the starting address of each allocation.\n+  char* p = (char*)align_up(_top, alignment);\n+  char* newtop = p + num_bytes;\n+  \/\/ Leave _top always SharedSpaceObjectAlignment aligned. But not more -\n+  \/\/  if we allocate with large alignments, lets not waste the gaps.\n+  \/\/ Ideally we would not need to align _top to anything here but CDS has\n+  \/\/  a number of implicit alignment assumptions. Leaving this unaligned\n+  \/\/  here will trip of at least ReadClosure (assuming word alignment) and\n+  \/\/  DumpAllocStats (will get confused about counting bytes on 32-bit\n+  \/\/  platforms if we align to anything less than SharedSpaceObjectAlignment\n+  \/\/  here).\n+  newtop = align_up(newtop, SharedSpaceObjectAlignment);\n@@ -212,1 +222,1 @@\n-  memset(p, 0, newtop - p);\n+  memset(p, 0, newtop - p); \/\/ todo: needed? debug_only?\n@@ -216,0 +226,4 @@\n+char* DumpRegion::allocate(size_t num_bytes) {\n+  return allocate(num_bytes, SharedSpaceObjectAlignment);\n+}\n+\n@@ -312,1 +326,1 @@\n-  assert(tag == old_tag, \"old tag doesn't match\");\n+  assert(tag == old_tag, \"tag doesn't match (%d, expected %d)\", old_tag, tag);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -146,1 +146,2 @@\n-      _max_delta(max_delta), _is_packed(false) {}\n+      _max_delta(max_delta), _is_packed(false),\n+      _rs(NULL), _vs(NULL) {}\n@@ -149,0 +150,1 @@\n+  \/\/ Allocate with default alignment (SharedSpaceObjectAlignment)\n@@ -150,0 +152,2 @@\n+  \/\/ Allocate with an arbitrary alignment.\n+  char* allocate(size_t num_bytes, size_t alignment);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,0 +105,12 @@\n+\n+#ifdef ASSERT\n+void DumpAllocStats::verify(int expected_byte_size, bool read_only) const {\n+  int bytes = 0;\n+  const int what = (int)(read_only ? RO : RW);\n+  for (int type = 0; type < int(_number_of_types); type ++) {\n+    bytes += _bytes[what][type];\n+  }\n+  assert(bytes == expected_byte_size, \"counter mismatch (%s: %d vs %d)\",\n+         (read_only ? \"RO\" : \"RW\"), bytes, expected_byte_size);\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  DEBUG_ONLY(void verify(int expected_byte_size, bool read_only) const;)\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -311,1 +312,8 @@\n-    archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original));\n+\n+    assert(SafepointSynchronize::is_at_safepoint(), \"resolving displaced headers only at safepoint\");\n+    markWord mark = obj->mark();\n+    if (mark.has_displaced_mark_helper()) {\n+      mark = mark.displaced_mark_helper();\n+    }\n+    narrowKlass nklass = mark.narrow_klass();\n+    archived_oop->set_mark(markWord::prototype().copy_set_hash(hash_original) LP64_ONLY(.set_narrow_klass(nklass)));\n@@ -548,1 +556,2 @@\n-    oopDesc::set_mark(mem, markWord::prototype());\n+    oopDesc::set_mark(mem, k->prototype_header());\n+#ifndef _LP64\n@@ -550,0 +559,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -1312,0 +1313,5 @@\n+#ifdef ASSERT\n+    if (UseCompressedClassPointers) {\n+      CompressedKlassPointers::verify_klass_pointer(record->_klass);\n+    }\n+#endif\n@@ -1313,1 +1319,0 @@\n-    assert(check_alignment(record->_klass), \"Address not aligned\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,2 +105,2 @@\n-  static const int first_vtableStub_size =  64;\n-  static const int first_itableStub_size = 256;\n+  static const int first_vtableStub_size = 256;\n+  static const int first_itableStub_size = 512;\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,2 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -1588,0 +1590,2 @@\n+  _forwarding = new SlidingForwarding(heap_rs.region(), HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+class SlidingForwarding;\n@@ -232,0 +233,2 @@\n+  SlidingForwarding* _forwarding;\n+\n@@ -245,0 +248,4 @@\n+  SlidingForwarding* forwarding() const {\n+    return _forwarding;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -320,0 +321,2 @@\n+  _heap->forwarding()->clear();\n+\n@@ -327,3 +330,4 @@\n-  if (!has_free_compaction_targets) {\n-    phase2c_prepare_serial_compaction();\n-  }\n+  \/\/ TODO: Disabled for now because it violates sliding-forwarding assumption.\n+  \/\/ if (!has_free_compaction_targets) {\n+  \/\/   phase2c_prepare_serial_compaction();\n+  \/\/ }\n@@ -349,1 +353,2 @@\n-  GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare serial compaction\", scope()->timer());\n+  ShouldNotReachHere(); \/\/ Disabled in Lilliput.\n+  \/\/GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare serial compaction\", scope()->timer());\n@@ -355,0 +360,1 @@\n+  \/*\n@@ -361,0 +367,1 @@\n+  *\/\n@@ -364,0 +371,1 @@\n+  \/*\n@@ -379,0 +387,1 @@\n+  *\/\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -97,1 +97,2 @@\n-  marker->preserved_stack()->adjust_during_full_gc();\n+  const SlidingForwarding* const forwarding = G1CollectedHeap::heap()->forwarding();\n+  marker->preserved_stack()->adjust_during_full_gc(forwarding);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCAdjustTask.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -82,1 +83,1 @@\n-    HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+    HeapWord* destination = cast_from_oop<HeapWord*>(_forwarding->forwardee(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class SlidingForwarding;\n@@ -54,0 +55,1 @@\n+    const SlidingForwarding* const _forwarding;\n@@ -56,1 +58,3 @@\n-    G1CompactRegionClosure(G1CMBitMap* bitmap) : _bitmap(bitmap) { }\n+    G1CompactRegionClosure(G1CMBitMap* bitmap) :\n+      _bitmap(bitmap),\n+      _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -94,1 +95,1 @@\n-void G1FullGCCompactionPoint::forward(oop object, size_t size) {\n+void G1FullGCCompactionPoint::forward(SlidingForwarding* const forwarding, oop object, size_t size) {\n@@ -104,1 +105,1 @@\n-    object->forward_to(cast_to_oop(_compaction_top));\n+    forwarding->forward_to(object, cast_to_oop(_compaction_top));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+class SlidingForwarding;\n@@ -55,1 +56,1 @@\n-  void forward(oop object, size_t size);\n+  void forward(SlidingForwarding* const forwarding, oop object, size_t size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n@@ -35,0 +36,1 @@\n+class SlidingForwarding;\n@@ -84,0 +86,1 @@\n+  const SlidingForwarding* const _forwarding;\n@@ -87,1 +90,3 @@\n-  G1AdjustClosure(G1FullCollector* collector) : _collector(collector) { }\n+  G1AdjustClosure(G1FullCollector* collector) :\n+    _collector(collector),\n+    _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -89,1 +90,1 @@\n-    oop forwardee = obj->forwardee();\n+    oop forwardee = _forwarding->forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -146,1 +147,1 @@\n-    _cp(cp) { }\n+    _cp(cp), _forwarding(G1CollectedHeap::heap()->forwarding()) { }\n@@ -150,1 +151,1 @@\n-  _cp->forward(object, size);\n+  _cp->forward(_forwarding, object, size);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class SlidingForwarding;\n@@ -111,0 +112,1 @@\n+    SlidingForwarding* const _forwarding;\n@@ -120,11 +122,11 @@\n-class G1SerialRePrepareClosure : public StackObj {\n-  G1FullGCCompactionPoint* _cp;\n-  HeapRegion* _current;\n-\n-public:\n-  G1SerialRePrepareClosure(G1FullGCCompactionPoint* hrcp, HeapRegion* hr) :\n-    _cp(hrcp),\n-    _current(hr) { }\n-\n-  inline size_t apply(oop obj);\n-};\n+\/\/class G1SerialRePrepareClosure : public StackObj {\n+\/\/  G1FullGCCompactionPoint* _cp;\n+\/\/  HeapRegion* _current;\n+\/\/\n+\/\/public:\n+\/\/  G1SerialRePrepareClosure(G1FullGCCompactionPoint* hrcp, HeapRegion* hr) :\n+\/\/    _cp(hrcp),\n+\/\/    _current(hr) { }\n+\/\/\n+\/\/  inline size_t apply(oop obj);\n+\/\/};\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -112,13 +112,13 @@\n-inline size_t G1SerialRePrepareClosure::apply(oop obj) {\n-  \/\/ We only re-prepare objects forwarded within the current region, so\n-  \/\/ skip objects that are already forwarded to another region.\n-  if (obj->is_forwarded() && !_current->is_in(obj->forwardee())) {\n-    return obj->size();\n-  }\n-\n-  \/\/ Get size and forward.\n-  size_t size = obj->size();\n-  _cp->forward(obj, size);\n-\n-  return size;\n-}\n+\/\/inline size_t G1SerialRePrepareClosure::apply(oop obj) {\n+\/\/  \/\/ We only re-prepare objects forwarded within the current region, so\n+\/\/  \/\/ skip objects that are already forwarded to another region.\n+\/\/  if (obj->is_forwarded() && !_current->is_in(obj->forwardee())) {\n+\/\/    return obj->size();\n+\/\/  }\n+\/\/\n+\/\/  \/\/ Get size and forward.\n+\/\/  size_t size = obj->size();\n+\/\/  _cp->forward(obj, size);\n+\/\/\n+\/\/  return size;\n+\/\/}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -237,1 +237,1 @@\n-      forwardee = cast_to_oop(m.decode_pointer());\n+      forwardee = obj->forwardee(m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-    obj = cast_to_oop(m.decode_pointer());\n+    obj = obj->forwardee(m);\n@@ -223,1 +223,0 @@\n-  assert(from_obj->is_objArray(), \"must be obj array\");\n@@ -253,1 +252,0 @@\n-  assert(from_obj->is_objArray(), \"precondition\");\n@@ -380,1 +378,1 @@\n-                                                  oop const old, size_t word_sz, uint age,\n+                                                  oop const old, Klass* klass, size_t word_sz, uint age,\n@@ -384,1 +382,1 @@\n-    _g1h->gc_tracer_stw()->report_promotion_in_new_plab_event(old->klass(), word_sz * HeapWordSize, age,\n+    _g1h->gc_tracer_stw()->report_promotion_in_new_plab_event(klass, word_sz * HeapWordSize, age,\n@@ -388,1 +386,1 @@\n-    _g1h->gc_tracer_stw()->report_promotion_outside_plab_event(old->klass(), word_sz * HeapWordSize, age,\n+    _g1h->gc_tracer_stw()->report_promotion_outside_plab_event(klass, word_sz * HeapWordSize, age,\n@@ -396,0 +394,1 @@\n+                                                   Klass* klass,\n@@ -418,1 +417,1 @@\n-      report_promotion_event(*dest_attr, old, word_sz, age, obj_ptr, node_index);\n+      report_promotion_event(*dest_attr, old, klass, word_sz, age, obj_ptr, node_index);\n@@ -453,0 +452,4 @@\n+  if (old_mark.is_marked()) {\n+    \/\/ Already forwarded by somebody else, return forwardee.\n+    return old->forwardee(old_mark);\n+  }\n@@ -455,0 +458,3 @@\n+#ifdef _LP64\n+  Klass* klass = old_mark.safe_klass();\n+#else\n@@ -456,0 +462,1 @@\n+#endif\n@@ -468,1 +475,1 @@\n-    obj_ptr = allocate_copy_slow(&dest_attr, old, word_sz, age, node_index);\n+    obj_ptr = allocate_copy_slow(&dest_attr, old, klass, word_sz, age, node_index);\n@@ -621,1 +628,1 @@\n-  oop forward_ptr = old->forward_to_atomic(old, m, memory_order_relaxed);\n+  oop forward_ptr = old->forward_to_self_atomic(m, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":16,"deletions":9,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+                               Klass* klass,\n@@ -197,1 +198,1 @@\n-                              oop const old, size_t word_sz, uint age,\n+                              oop const old, Klass* klass, size_t word_sz, uint age,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-              touched_words = MIN2((size_t)align_object_size(typeArrayOopDesc::header_size(T_INT)),\n+              touched_words = MIN2((size_t)align_object_size(align_up(typeArrayOopDesc::base_offset_in_bytes(T_INT), HeapWordSize) \/ HeapWordSize),\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-    HeapWord* test_addr = cast_from_oop<HeapWord*>(obj) + 1;\n+    HeapWord* test_addr = cast_from_oop<HeapWord*>(obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -296,1 +296,0 @@\n-  assert(old->is_objArray(), \"invariant\");\n@@ -334,1 +333,1 @@\n-  if (obj->forward_to_atomic(obj, obj_mark) == NULL) {\n+  if (obj->forward_to_self_atomic(obj_mark) == NULL) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  inline void promotion_trace_event(oop new_obj, oop old_obj, size_t obj_size,\n+  inline void promotion_trace_event(oop new_obj, oop old_obj, Klass* klass, size_t obj_size,\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-inline void PSPromotionManager::promotion_trace_event(oop new_obj, oop old_obj,\n+inline void PSPromotionManager::promotion_trace_event(oop new_obj, oop old_obj, Klass* klass,\n@@ -79,1 +79,1 @@\n-        gc_tracer->report_promotion_in_new_plab_event(old_obj->klass(), obj_bytes,\n+        gc_tracer->report_promotion_in_new_plab_event(klass, obj_bytes,\n@@ -86,1 +86,1 @@\n-        gc_tracer->report_promotion_outside_plab_event(old_obj->klass(), obj_bytes,\n+        gc_tracer->report_promotion_outside_plab_event(klass, obj_bytes,\n@@ -150,1 +150,1 @@\n-    return cast_to_oop(m.decode_pointer());\n+    return o->forwardee(m);\n@@ -166,1 +166,6 @@\n-  size_t new_obj_size = o->size();\n+#ifdef _LP64\n+  Klass* klass = test_mark.safe_klass();\n+#else\n+  Klass* klass = o->klass();\n+#endif\n+  size_t new_obj_size = o->size_given_klass(klass);\n@@ -181,1 +186,1 @@\n-          promotion_trace_event(new_obj, o, new_obj_size, age, false, NULL);\n+          promotion_trace_event(new_obj, o, klass, new_obj_size, age, false, NULL);\n@@ -191,1 +196,1 @@\n-            promotion_trace_event(new_obj, o, new_obj_size, age, false, &_young_lab);\n+            promotion_trace_event(new_obj, o, klass, new_obj_size, age, false, &_young_lab);\n@@ -217,1 +222,1 @@\n-          promotion_trace_event(new_obj, o, new_obj_size, age, true, NULL);\n+          promotion_trace_event(new_obj, o, klass, new_obj_size, age, true, NULL);\n@@ -227,1 +232,1 @@\n-            promotion_trace_event(new_obj, o, new_obj_size, age, true, &_old_lab);\n+            promotion_trace_event(new_obj, o, klass, new_obj_size, age, true, &_old_lab);\n@@ -250,3 +255,5 @@\n-  \/\/ Parallel GC claims with a release - so other threads might access this object\n-  \/\/ after claiming and they should see the \"completed\" object.\n-  ContinuationGCSupport::transform_stack_chunk(new_obj);\n+  if (!new_obj->mark().is_marked()) {\n+    \/\/ Parallel GC claims with a release - so other threads might access this object\n+    \/\/ after claiming and they should see the \"completed\" object.\n+    ContinuationGCSupport::transform_stack_chunk(new_obj);\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -679,0 +679,10 @@\n+#ifdef _LP64\n+        oop forwardee = obj->forwardee();\n+        markWord header = forwardee->mark();\n+        if (header.has_displaced_mark_helper()) {\n+          header = header.displaced_mark_helper();\n+        }\n+        assert(UseCompressedClassPointers, \"assume +UseCompressedClassPointers\");\n+        narrowKlass nklass = header.narrow_klass();\n+        obj->set_mark(markWord::prototype().set_narrow_klass(nklass));\n+#else\n@@ -680,0 +690,1 @@\n+#endif\n@@ -703,1 +714,1 @@\n-  old->forward_to(old);\n+  old->forward_to_self();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -267,0 +267,2 @@\n+  AdjustPointerClosure adjust_pointer_closure(gch->forwarding());\n+  CLDToOopClosure adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_strong);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -66,1 +67,0 @@\n-CLDToOopClosure    MarkSweep::adjust_cld_closure(&adjust_pointer_closure, ClassLoaderData::_claim_strong);\n@@ -148,2 +148,2 @@\n-void PreservedMark::adjust_pointer() {\n-  MarkSweep::adjust_pointer(&_obj);\n+void PreservedMark::adjust_pointer(const SlidingForwarding* const forwarding) {\n+  MarkSweep::adjust_pointer(forwarding, &_obj);\n@@ -176,2 +176,0 @@\n-AdjustPointerClosure MarkSweep::adjust_pointer_closure;\n-\n@@ -179,0 +177,2 @@\n+  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n+\n@@ -181,1 +181,1 @@\n-    _preserved_marks[i].adjust_pointer();\n+    _preserved_marks[i].adjust_pointer(forwarding);\n@@ -188,1 +188,1 @@\n-    p->adjust_pointer();\n+    p->adjust_pointer(forwarding);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+class SlidingForwarding;\n@@ -131,2 +132,0 @@\n-  static AdjustPointerClosure adjust_pointer_closure;\n-  static CLDToOopClosure      adjust_cld_closure;\n@@ -149,1 +148,1 @@\n-  static size_t adjust_pointers(oop obj);\n+  static size_t adjust_pointers(const SlidingForwarding* const forwarding, oop obj);\n@@ -157,1 +156,1 @@\n-  template <class T> static inline void adjust_pointer(T* p);\n+  template <class T> static inline void adjust_pointer(const SlidingForwarding* const forwarding, T* p);\n@@ -195,0 +194,2 @@\n+private:\n+  const SlidingForwarding* const _forwarding;\n@@ -196,0 +197,1 @@\n+  AdjustPointerClosure(const SlidingForwarding* forwarding) : _forwarding(forwarding) {}\n@@ -209,1 +211,1 @@\n-  void adjust_pointer();\n+  void adjust_pointer(const SlidingForwarding* const forwarding);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -54,1 +55,1 @@\n-  obj->set_mark(markWord::prototype().set_marked());\n+  obj->set_mark(obj->klass()->prototype_header().set_marked());\n@@ -92,1 +93,1 @@\n-template <class T> inline void MarkSweep::adjust_pointer(T* p) {\n+template <class T> inline void MarkSweep::adjust_pointer(const SlidingForwarding* const forwarding, T* p) {\n@@ -98,2 +99,4 @@\n-    if (obj->is_forwarded()) {\n-      oop new_obj = obj->forwardee();\n+    markWord header = obj->mark();\n+    if (header.is_marked()) {\n+      oop new_obj = forwarding->forwardee(obj);\n+      assert(new_obj != NULL, \"must be forwarded\");\n@@ -107,1 +110,1 @@\n-void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(p); }\n+void AdjustPointerClosure::do_oop_work(T* p)           { MarkSweep::adjust_pointer(_forwarding, p); }\n@@ -112,2 +115,3 @@\n-inline size_t MarkSweep::adjust_pointers(oop obj) {\n-  return obj->oop_iterate_size(&MarkSweep::adjust_pointer_closure);\n+inline size_t MarkSweep::adjust_pointers(const SlidingForwarding* const forwarding, oop obj) {\n+  AdjustPointerClosure cl(forwarding);\n+  return obj->oop_iterate_size(&cl);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -226,4 +226,0 @@\n-  if (is_in(object->klass_or_null())) {\n-    return false;\n-  }\n-\n@@ -256,2 +252,4 @@\n-  _filler_array_max_size = align_object_size(filler_array_hdr_size() +\n-                                             max_len \/ elements_per_word);\n+  int header_size_in_bytes = arrayOopDesc::base_offset_in_bytes(T_INT);\n+  assert(header_size_in_bytes % sizeof(jint) == 0, \"must be aligned to int\");\n+  int header_size_in_ints = header_size_in_bytes \/ sizeof(jint);\n+  _filler_array_max_size = align_object_size((header_size_in_ints + max_len) \/ elements_per_word);\n@@ -419,1 +417,3 @@\n-  size_t max_int_size = typeArrayOopDesc::header_size(T_INT) +\n+  int header_size_in_bytes = typeArrayOopDesc::base_offset_in_bytes(T_INT);\n+  assert(header_size_in_bytes % sizeof(jint) == 0, \"header size must align to int\");\n+  size_t max_int_size = header_size_in_bytes \/ HeapWordSize +\n@@ -425,4 +425,0 @@\n-size_t CollectedHeap::filler_array_hdr_size() {\n-  return align_object_offset(arrayOopDesc::header_size(T_INT)); \/\/ align to Long\n-}\n-\n@@ -430,1 +426,2 @@\n-  return align_object_size(filler_array_hdr_size()); \/\/ align to MinObjAlignment\n+  int aligned_header_size_words = align_up(arrayOopDesc::base_offset_in_bytes(T_INT), HeapWordSize) \/ HeapWordSize;\n+  return align_object_size(aligned_header_size_words); \/\/ align to MinObjAlignment\n@@ -434,2 +431,3 @@\n-  Copy::fill_to_words(start + filler_array_hdr_size(),\n-                      words - filler_array_hdr_size(), value);\n+  int payload_start = align_up(arrayOopDesc::base_offset_in_bytes(T_INT), HeapWordSize) \/ HeapWordSize;\n+  Copy::fill_to_words(start + payload_start,\n+                      words - payload_start, value);\n@@ -459,2 +457,3 @@\n-  const size_t payload_size = words - filler_array_hdr_size();\n-  const size_t len = payload_size * HeapWordSize \/ sizeof(jint);\n+  const size_t payload_size_bytes = words * HeapWordSize - arrayOopDesc::base_offset_in_bytes(T_INT);\n+  assert(payload_size_bytes % sizeof(jint) == 0, \"must be int aligned\");\n+  const size_t len = payload_size_bytes \/ sizeof(jint);\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -166,1 +166,0 @@\n-  static inline size_t filler_array_hdr_size();\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -127,0 +128,1 @@\n+  _forwarding = new SlidingForwarding(_reserved);\n@@ -1070,0 +1072,1 @@\n+  _forwarding->clear();\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+class SlidingForwarding;\n@@ -90,0 +91,2 @@\n+  SlidingForwarding* _forwarding;\n+\n@@ -323,0 +326,4 @@\n+  SlidingForwarding* forwarding() const {\n+    return _forwarding;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -403,0 +404,15 @@\n+JVMFlag::Error CompressedClassSpaceSizeConstraintFunc(size_t value, bool verbose) {\n+#ifdef _LP64\n+  \/\/ There is no minimal value check, although class space will be transparently enlarged\n+  \/\/ to a multiple of metaspace root chunk size (4m).\n+  \/\/ The max. value of class space size depends on narrow klass pointer encoding range size\n+  \/\/ and CDS, see metaspace.cpp.\n+  if (value > Metaspace::max_class_space_size()) {\n+    JVMFlag::printError(verbose, \"CompressedClassSpaceSize \" SIZE_FORMAT \" too large (max: \" SIZE_FORMAT \")\\n\",\n+                        value, Metaspace::max_class_space_size());\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+#endif\n+  return JVMFlag::SUCCESS;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+ f(size_t, CompressedClassSpaceSizeConstraintFunc)             \\\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -400,1 +400,0 @@\n-  oopDesc::set_klass_gap(mem, 0);\n@@ -406,2 +405,0 @@\n-  \/\/ May be bootstrapping\n-  oopDesc::set_mark(mem, markWord::prototype());\n@@ -411,0 +408,4 @@\n+#ifdef _LP64\n+  oopDesc::release_set_mark(mem, _klass->prototype_header());\n+#else\n+  oopDesc::set_mark(mem, _klass->prototype_header());\n@@ -412,0 +413,1 @@\n+#endif\n@@ -425,1 +427,1 @@\n-  const size_t hs = arrayOopDesc::header_size(array_klass->element_type());\n+  const size_t hs = align_up(arrayOopDesc::base_offset_in_bytes(array_klass->element_type()), HeapWordSize) \/ HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -265,0 +266,1 @@\n+        ObjectMonitor::maybe_deflate_dead(ptr);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.inline.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -43,0 +44,2 @@\n+\/\/ TODO: This method is unused, except in the gunit test. Change the test\n+\/\/ to exercise the updated method below instead, and remove this one.\n@@ -55,0 +58,12 @@\n+void PreservedMarks::adjust_during_full_gc(const SlidingForwarding* const forwarding) {\n+  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n+  while (!iter.is_empty()) {\n+    OopAndMarkWord* elem = iter.next_addr();\n+\n+    oop obj = elem->get_oop();\n+    if (obj->is_forwarded()) {\n+      elem->set_oop(forwarding->forwardee(obj));\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class SlidingForwarding;\n@@ -66,0 +67,2 @@\n+  \/\/ TODO: This method is unused, except in the gunit test. Change the test\n+  \/\/ to exercise the updated method below instead, and remove this one.\n@@ -68,0 +71,2 @@\n+  void adjust_during_full_gc(const SlidingForwarding* const forwarding);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+\n+#ifdef _LP64\n+HeapWord* const SlidingForwarding::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n+#endif\n+\n+SlidingForwarding::SlidingForwarding(MemRegion heap)\n+#ifdef _LP64\n+        : _heap_start(heap.start()),\n+          _num_regions(((heap.end() - heap.start()) >> NUM_COMPRESSED_BITS) + 1),\n+          _region_size_words_shift(NUM_COMPRESSED_BITS),\n+          _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * 2, mtGC)) {\n+  assert(_region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n+#else\n+  {\n+#endif\n+}\n+\n+SlidingForwarding::SlidingForwarding(MemRegion heap, size_t region_size_words_shift)\n+#ifdef _LP64\n+        : _heap_start(heap.start()),\n+          _num_regions(((heap.end() - heap.start()) >> region_size_words_shift) + 1),\n+          _region_size_words_shift(region_size_words_shift),\n+          _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * (ONE << NUM_REGION_BITS), mtGC)) {\n+  assert(region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n+#else\n+  {\n+#endif\n+}\n+\n+SlidingForwarding::~SlidingForwarding() {\n+#ifdef _LP64\n+  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n+#endif\n+}\n+\n+void SlidingForwarding::clear() {\n+#ifdef _LP64\n+  size_t max = _num_regions * (ONE << NUM_REGION_BITS);\n+  for (size_t i = 0; i < max; i++) {\n+    _target_base_table[i] = UNUSED_BASE;\n+  }\n+#endif\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/**\n+ * SlidingForwarding is a method to store forwarding information in a compressed form into the object header,\n+ * that has been specifically designed for sliding compaction GCs.\n+ * It avoids overriding the compressed class pointer in the upper bits of the header, which would otherwise\n+ * be lost. SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n+ *\n+ * The idea is to use a pointer compression scheme very similar to the one that is used for compressed oops.\n+ * We divide the heap into number of logical regions. Each region spans maximum of 2^NUM_BITS words.\n+ * We take advantage of the fact that sliding compaction can forward objects from one region to a maximum of\n+ * two regions (including itself, but that does not really matter). We need 1 bit to indicate which region is forwarded\n+ * into. We also currently require the two lowest header bits to indicate that the object is forwarded.\n+ *\n+ * For addressing, we need a table with N*2 entries, for N logical regions. For each region, it gives the base\n+ * address of the two target regions, or a special placeholder if not used.\n+ *\n+ * Adding a forwarding then works as follows:\n+ * Given an original address 'orig', and a 'target' address:\n+ * - Look-up first target base of region of orig. If not yet used,\n+ *   establish it to be the base of region of target address. Use that base in step 3.\n+ * - Else, if first target base is already used, check second target base. This must either be unused, or the\n+ *   base of the region of our target address. If unused, establish it to be the base of the region of our target\n+ *   address. Use that base for next step.\n+ * - Now we found a base address. Encode the target address with that base into lowest NUM_BITS bits, and shift\n+ *   that up by 3 bits. Set the 3rd bit if we used the secondary target base, otherwise leave it at 0. Set the\n+ *   lowest two bits to indicate that the object has been forwarded. Store that in the lowest NUM_BITS+3 bits of the\n+ *   original object's header.\n+ *\n+ * Similarily, looking up the target address, given an original object address works as follows:\n+ * - Load lowest NUM_BITS + 3 from original object header. Extract target region bit and compressed address bits.\n+ * - Depending on target region bit, load base address from the target base table by looking up the corresponding entry\n+ *   for the region of the original object.\n+ * - Decode the target address by using the target base address and the compressed address bits.\n+ *\/\n+\n+class SlidingForwarding : public CHeapObj<mtGC> {\n+#ifdef _LP64\n+private:\n+  static const int NUM_REGION_BITS = 1;\n+\n+  static const uintptr_t ONE = 1ULL;\n+\n+  static const size_t NUM_REGIONS = ONE << NUM_REGION_BITS;\n+\n+  \/\/ We need the lowest three bits to indicate a forwarded object and self-forwarding.\n+  static const int BASE_SHIFT = 3;\n+\n+  \/\/ The compressed address bits start here.\n+  static const int COMPRESSED_BITS_SHIFT = BASE_SHIFT + NUM_REGION_BITS;\n+\n+  \/\/ How many bits we use for the compressed pointer (we are going to need one more bit to indicate target region, and\n+  \/\/ two lowest bits to mark objects as forwarded)\n+  static const int NUM_COMPRESSED_BITS = 32 - BASE_SHIFT - NUM_REGION_BITS;\n+\n+  \/\/ Indicates an usused base address in the target base table. We cannot use 0, because that may already be\n+  \/\/ a valid base address in zero-based heaps. 0x1 is safe because heap base addresses must be aligned by 2^X.\n+  static HeapWord* const UNUSED_BASE;\n+\n+  HeapWord*  const _heap_start;\n+  size_t     const _num_regions;\n+  size_t     const _region_size_words_shift;\n+  HeapWord** const _target_base_table;\n+\n+  inline size_t region_index_containing(HeapWord* addr) const;\n+  inline bool region_contains(HeapWord* region_base, HeapWord* addr) const;\n+\n+  inline uintptr_t encode_forwarding(HeapWord* original, HeapWord* target);\n+  inline HeapWord* decode_forwarding(HeapWord* original, uintptr_t encoded) const;\n+\n+#endif\n+\n+public:\n+  SlidingForwarding(MemRegion heap);\n+  SlidingForwarding(MemRegion heap, size_t num_regions);\n+  ~SlidingForwarding();\n+\n+  void clear();\n+  inline void forward_to(oop original, oop target);\n+  inline oop forwardee(oop original) const;\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+#ifdef _LP64\n+size_t SlidingForwarding::region_index_containing(HeapWord* addr) const {\n+  assert(addr >= _heap_start, \"sanity: addr: \" PTR_FORMAT \" heap base: \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n+  size_t index = ((size_t) (addr - _heap_start)) >> _region_size_words_shift;\n+  assert(index < _num_regions, \"Region index is in bounds: \" PTR_FORMAT, p2i(addr));\n+  return index;\n+}\n+\n+bool SlidingForwarding::region_contains(HeapWord* region_base, HeapWord* addr) const {\n+  return uintptr_t(addr - region_base) < (ONE << _region_size_words_shift);\n+}\n+\n+\n+uintptr_t SlidingForwarding::encode_forwarding(HeapWord* original, HeapWord* target) {\n+  size_t orig_idx = region_index_containing(original);\n+  size_t base_table_idx = orig_idx * 2;\n+  size_t target_idx = region_index_containing(target);\n+  HeapWord* encode_base;\n+  uintptr_t region_idx;\n+  for (region_idx = 0; region_idx < NUM_REGIONS; region_idx++) {\n+    encode_base = _target_base_table[base_table_idx + region_idx];\n+    if (encode_base == UNUSED_BASE) {\n+      encode_base = _heap_start + target_idx * (ONE << _region_size_words_shift);\n+      _target_base_table[base_table_idx + region_idx] = encode_base;\n+      break;\n+    } else if (region_contains(encode_base, target)) {\n+      break;\n+    }\n+  }\n+  if (region_idx >= NUM_REGIONS) {\n+    tty->print_cr(\"target: \" PTR_FORMAT, p2i(target));\n+    for (region_idx = 0; region_idx < NUM_REGIONS; region_idx++) {\n+      tty->print_cr(\"region_idx: \" INTPTR_FORMAT \", encode_base: \" PTR_FORMAT, region_idx, p2i(_target_base_table[base_table_idx + region_idx]));\n+    }\n+  }\n+  assert(region_idx < NUM_REGIONS, \"need to have found an encoding base\");\n+  assert(target >= encode_base, \"target must be above encode base, target:\" PTR_FORMAT \", encoded_base: \" PTR_FORMAT \",  target_idx: \" SIZE_FORMAT \", heap start: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT,\n+         p2i(target), p2i(encode_base), target_idx, p2i(_heap_start), region_idx);\n+  assert(region_contains(encode_base, target), \"region must contain target: original: \" PTR_FORMAT \", target: \" PTR_FORMAT \", encode_base: \" PTR_FORMAT \", region_idx: \" INTPTR_FORMAT, p2i(original), p2i(target), p2i(encode_base), region_idx);\n+  uintptr_t encoded = (((uintptr_t)(target - encode_base)) << COMPRESSED_BITS_SHIFT) |\n+                      (region_idx << BASE_SHIFT) | markWord::marked_value;\n+  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n+  return encoded;\n+}\n+\n+HeapWord* SlidingForwarding::decode_forwarding(HeapWord* original, uintptr_t encoded) const {\n+  assert((encoded & markWord::marked_value) == markWord::marked_value, \"must be marked as forwarded\");\n+  size_t orig_idx = region_index_containing(original);\n+  size_t region_idx = (encoded >> BASE_SHIFT) & right_n_bits(NUM_REGION_BITS);\n+  size_t base_table_idx = orig_idx * 2 + region_idx;\n+  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n+  assert(decoded >= _heap_start, \"must be above heap start, encoded: \" INTPTR_FORMAT \", region_idx: \" SIZE_FORMAT \", base: \" PTR_FORMAT, encoded, region_idx, p2i(_target_base_table[base_table_idx]));\n+  return decoded;\n+}\n+#endif\n+\n+void SlidingForwarding::forward_to(oop original, oop target) {\n+#ifdef _LP64\n+  markWord header = original->mark();\n+  if (header.has_displaced_mark_helper()) {\n+    header = header.displaced_mark_helper();\n+  }\n+  uintptr_t encoded = encode_forwarding(cast_from_oop<HeapWord*>(original), cast_from_oop<HeapWord*>(target));\n+  assert((encoded & markWord::klass_mask_in_place) == 0, \"encoded forwardee must not overlap with Klass*: \" PTR_FORMAT, encoded);\n+  header = markWord((header.value() & markWord::klass_mask_in_place) | encoded);\n+  original->set_mark(header);\n+#else\n+  original->forward_to(target);\n+#endif\n+}\n+\n+oop SlidingForwarding::forwardee(oop original) const {\n+#ifdef _LP64\n+  markWord header = original->mark();\n+  uintptr_t encoded = header.value() & ~markWord::klass_mask_in_place;\n+  HeapWord* forwardee = decode_forwarding(cast_from_oop<HeapWord*>(original), encoded);\n+  return cast_to_oop(forwardee);\n+#else\n+  return original->forwardee();\n+#endif\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -352,1 +353,1 @@\n-                                    CompactPoint* cp, HeapWord* compact_top) {\n+                                    CompactPoint* cp, HeapWord* compact_top, SlidingForwarding* const forwarding) {\n@@ -375,1 +376,1 @@\n-    q->forward_to(cast_to_oop(compact_top));\n+    forwarding->forward_to(q, cast_to_oop(compact_top));\n@@ -423,0 +424,1 @@\n+  SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -428,1 +430,1 @@\n-      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top);\n+      compact_top = cp->space->forward(cast_to_oop(cur_obj), size, cp, compact_top, forwarding);\n@@ -444,1 +446,1 @@\n-        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top);\n+        compact_top = cp->space->forward(obj, obj->size(), cp, compact_top, forwarding);\n@@ -487,0 +489,1 @@\n+  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n@@ -498,1 +501,1 @@\n-      size_t size = MarkSweep::adjust_pointers(cast_to_oop(cur_obj));\n+      size_t size = MarkSweep::adjust_pointers(forwarding, cast_to_oop(cur_obj));\n@@ -539,0 +542,2 @@\n+  const SlidingForwarding* const forwarding = GenCollectedHeap::heap()->forwarding();\n+\n@@ -552,1 +557,1 @@\n-      HeapWord* compaction_top = cast_from_oop<HeapWord*>(cast_to_oop(cur_obj)->forwardee());\n+      HeapWord* compaction_top = cast_from_oop<HeapWord*>(forwarding->forwardee(cast_to_oop(cur_obj)));\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+class SlidingForwarding;\n@@ -401,1 +402,1 @@\n-                    HeapWord* compact_top);\n+                    HeapWord* compact_top, SlidingForwarding* const forwarding);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/genCollectedHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+      ObjectMonitor::maybe_deflate_dead(p);\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -200,1 +201,1 @@\n-  Klass* obj_klass = obj->klass_or_null();\n+  Klass* obj_klass = ShenandoahObjectUtils::klass(obj);\n@@ -232,1 +233,1 @@\n-    if (obj_klass != fwd->klass()) {\n+    if (obj_klass != ShenandoahObjectUtils::klass(fwd)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -79,1 +80,4 @@\n-  markWord old_mark = obj->mark();\n+\n+  markWord old_mark = ObjectSynchronizer::read_stable_mark(obj);\n+  assert(!old_mark.is_being_inflated(), \"must not see INFLATING marker here\");\n+\n@@ -84,0 +88,4 @@\n+  \/\/ Ensure that the copy has the correct mark-word, in case it happened to copy with\n+  \/\/ INFLATING marker.\n+  update->set_mark(old_mark);\n+\n@@ -85,5 +93,12 @@\n-  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n-  if (prev_mark == old_mark) {\n-    return update;\n-  } else {\n-    return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n+  while (true) {\n+    markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n+    if (prev_mark == old_mark) {\n+      return update;\n+    } else if (prev_mark == markWord::INFLATING()) {\n+      \/\/ This happens when we encounter a stack-locked object in from-space.\n+      \/\/ Busy-wait for completion.\n+      SpinPause();\n+    } else {\n+      assert(prev_mark.is_marked(), \"must be forwarded\");\n+      return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -186,0 +187,1 @@\n+    heap->forwarding()->clear();\n@@ -296,2 +298,3 @@\n-  PreservedMarks*          const _preserved_marks;\n-  ShenandoahHeap*          const _heap;\n+  PreservedMarks*    const _preserved_marks;\n+  SlidingForwarding* const _forwarding;\n+  ShenandoahHeap*    const _heap;\n@@ -309,0 +312,1 @@\n+    _forwarding(ShenandoahHeap::heap()->forwarding()),\n@@ -362,1 +366,1 @@\n-    p->forward_to(cast_to_oop(_compact_point));\n+    _forwarding->forward_to(p, cast_to_oop(_compact_point));\n@@ -436,0 +440,1 @@\n+  SlidingForwarding* forwarding = heap->forwarding();\n@@ -470,1 +475,1 @@\n-        old_obj->forward_to(cast_to_oop(heap->get_region(start)->bottom()));\n+        forwarding->forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -721,1 +726,2 @@\n-  ShenandoahHeap* const _heap;\n+  ShenandoahHeap*           const _heap;\n+  const SlidingForwarding*  const _forwarding;\n@@ -731,1 +737,1 @@\n-        oop forw = obj->forwardee();\n+        oop forw = _forwarding->forwardee(obj);\n@@ -740,0 +746,1 @@\n+    _forwarding(_heap->forwarding()),\n@@ -801,1 +808,2 @@\n-    _preserved_marks->get(worker_id)->adjust_during_full_gc();\n+    const SlidingForwarding* const forwarding = ShenandoahHeap::heap()->forwarding();\n+    _preserved_marks->get(worker_id)->adjust_during_full_gc(forwarding);\n@@ -831,2 +839,3 @@\n-  ShenandoahHeap* const _heap;\n-  uint            const _worker_id;\n+  ShenandoahHeap*          const _heap;\n+  const SlidingForwarding* const _forwarding;\n+  uint                     const _worker_id;\n@@ -836,1 +845,1 @@\n-    _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}\n+    _heap(ShenandoahHeap::heap()), _forwarding(_heap->forwarding()), _worker_id(worker_id) {}\n@@ -843,1 +852,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(p->forwardee());\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(_forwarding->forwardee(p));\n@@ -940,0 +949,1 @@\n+  const SlidingForwarding* const forwarding = heap->forwarding();\n@@ -954,1 +964,1 @@\n-      size_t new_start = heap->heap_region_index_containing(old_obj->forwardee());\n+      size_t new_start = heap->heap_region_index_containing(forwarding->forwardee(old_obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":22,"deletions":12,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n@@ -196,0 +197,2 @@\n+  _forwarding = new SlidingForwarding(_heap_region, ShenandoahHeapRegion::region_size_words_shift());\n+\n@@ -952,1 +955,1 @@\n-    if (!p->is_forwarded()) {\n+    if (!ShenandoahForwarding::is_forwarded(p)) {\n@@ -1297,0 +1300,1 @@\n+    shenandoah_assert_not_in_cset_except(NULL, obj, cancelled_gc());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+class SlidingForwarding;\n@@ -230,0 +231,1 @@\n+  SlidingForwarding* _forwarding;\n@@ -246,0 +248,2 @@\n+  SlidingForwarding* forwarding() const { return _forwarding; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -300,1 +301,1 @@\n-  size_t size = p->size();\n+  size_t size = ShenandoahObjectUtils::size(p);\n@@ -338,2 +339,7 @@\n-  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n-\n+  if (!copy_val->mark().is_marked()) {\n+    \/\/ If we copied a mark-word that indicates 'forwarded' state, then\n+    \/\/ another thread beat us, and this new copy will never be published.\n+    \/\/ ContinuationGCSupport would get a corrupt Klass* in that case,\n+    \/\/ so don't even attempt it.\n+    ContinuationGCSupport::relativize_stack_chunk(copy_val);\n+  }\n@@ -519,1 +525,1 @@\n-    size_t size = obj->size();\n+    size_t size = ShenandoahObjectUtils::size(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class Klass;\n+\n+class ShenandoahObjectUtils : public AllStatic {\n+public:\n+#ifdef _LP64\n+  static inline markWord stable_mark(oop obj);\n+#endif\n+  static inline Klass* klass(oop obj);\n+  static inline size_t size(oop obj);\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+\/\/ This is a variant of ObjectSynchronizer::stable_mark(), which does the same thing, but also\n+\/\/ handles forwarded objects. This is intended to be used by concurrent evacuation only. No other\n+\/\/ code is supposed to observe from-space objects.\n+#ifdef _LP64\n+markWord ShenandoahObjectUtils::stable_mark(oop obj) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  for (;;) {\n+    assert(heap->is_in(obj), \"object not in heap: \" PTR_FORMAT, p2i(obj));\n+    markWord mark = obj->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  Inflated     - just return mark from inflated monitor\n+    \/\/ *  Stack-locked - coerce it to inflating, and then return displaced mark\n+    \/\/ *  INFLATING    - busy wait for conversion to complete\n+    \/\/ *  Neutral      - return mark\n+    \/\/ *  Marked       - object is forwarded, try again on forwardee\n+\n+    \/\/ Most common case first.\n+    if (mark.is_neutral()) {\n+      return mark;\n+    }\n+\n+    \/\/ If object is already forwarded, then resolve it, and try again.\n+    if (mark.is_marked()) {\n+      if (heap->is_full_gc_move_in_progress()) {\n+        \/\/ In these cases, we want to return the header as-is: the Klass* would not be overloaded.\n+        return mark;\n+      }\n+      obj = cast_to_oop(mark.decode_pointer());\n+      continue;\n+    }\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      \/\/ It is safe to access the object monitor because all Java and GC worker threads\n+      \/\/ participate in the monitor deflation protocol (i.e, they react to handshakes and STS requests).\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n+      return dmw;\n+    }\n+\n+    \/\/ CASE: inflating\n+    if (mark.is_being_inflated()) {\n+      \/\/ Interference, try again.\n+      continue;\n+    }\n+\n+    \/\/ CASE: stack-locked\n+    if (mark.has_locker()) {\n+      if (Thread::current()->is_lock_owned((address)mark.locker())) {\n+        \/\/ This thread owns the lock. We can safely access it.\n+        markWord dmw = mark.displaced_mark_helper();\n+        assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n+        return dmw;\n+      }\n+\n+      \/\/ Else we try to install INFLATING into the header. This will (temporarily) prevent other\n+      \/\/ threads from stack-locking or evacuating the object.\n+      markWord cmp = obj->cas_set_mark(markWord::INFLATING(), mark);\n+      if (cmp != mark) {\n+        continue;       \/\/ Interference -- just retry\n+      }\n+\n+      \/\/ We've successfully installed INFLATING (0) into the mark-word.\n+      \/\/ This is the only case where 0 will appear in a mark-word.\n+      \/\/ Only the singular thread that successfully swings the mark-word\n+      \/\/ to 0 can fetch the stack-lock and safely read the displaced header.\n+\n+      \/\/ fetch the displaced mark from the owner's stack.\n+      \/\/ The owner can't die or unwind past the lock while our INFLATING\n+      \/\/ object is in the mark.  Furthermore the owner can't complete\n+      \/\/ an unlock on the object, either. No other thread can do evacuation, either.\n+      markWord dmw = mark.displaced_mark_helper();\n+      \/\/ Catch if the object's header is not neutral (not locked and\n+      \/\/ not marked is what we care about here).\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+\n+      \/\/ Must preserve store ordering. The monitor state must\n+      \/\/ be stable at the time of publishing the monitor address.\n+      guarantee(obj->mark() == markWord::INFLATING(), \"invariant\");\n+      \/\/ Release semantics so that above set_object() is seen first.\n+      obj->release_set_mark(mark);\n+\n+      return dmw;\n+    }\n+  }\n+}\n+#endif\n+\n+Klass* ShenandoahObjectUtils::klass(oop obj) {\n+#ifdef _LP64\n+  markWord header = stable_mark(obj);\n+  assert(header.narrow_klass() != 0, \"klass must not be NULL: \" INTPTR_FORMAT, header.value());\n+  return header.klass();\n+#else\n+  return obj->klass();\n+#endif\n+}\n+\n+size_t ShenandoahObjectUtils::size(oop obj) {\n+  Klass* kls = klass(obj);\n+  return obj->size_given_klass(kls);\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.inline.hpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -101,1 +102,1 @@\n-      if (is_instance_ref_klass(obj->klass())) {\n+      if (is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n@@ -128,1 +129,1 @@\n-    Klass* obj_klass = obj->klass_or_null();\n+    Klass* obj_klass = ShenandoahObjectUtils::klass(obj);\n@@ -143,1 +144,1 @@\n-        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj->size()) <= obj_reg->top(),\n+        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + ShenandoahObjectUtils::size(obj)) <= obj_reg->top(),\n@@ -147,1 +148,1 @@\n-        size_t humongous_end = humongous_start + (obj->size() >> ShenandoahHeapRegion::region_size_words_shift());\n+        size_t humongous_end = humongous_start + (ShenandoahObjectUtils::size(obj) >> ShenandoahHeapRegion::region_size_words_shift());\n@@ -164,1 +165,1 @@\n-          Atomic::add(&_ld[obj_reg->index()], (uint) obj->size(), memory_order_relaxed);\n+          Atomic::add(&_ld[obj_reg->index()], (uint) ShenandoahObjectUtils::size(obj), memory_order_relaxed);\n@@ -205,1 +206,1 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd->size()) <= fwd_reg->top(),\n+      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + ShenandoahObjectUtils::size(fwd)) <= fwd_reg->top(),\n@@ -308,1 +309,2 @@\n-    obj->oop_iterate(this);\n+    Klass* klass = ShenandoahObjectUtils::klass(obj);\n+    obj->oop_iterate_backwards(this, klass);\n@@ -588,1 +590,1 @@\n-    if (!is_instance_ref_klass(obj->klass())) {\n+    if (!is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  product(bool, ShenandoahSuspendibleWorkers, false, EXPERIMENTAL,          \\\n+  product(bool, ShenandoahSuspendibleWorkers, true, EXPERIMENTAL,           \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -301,1 +301,0 @@\n-        assert(!UseCompressedClassPointers, \"should only happen without compressed class pointers\");\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -109,0 +109,3 @@\n+\n+  \/\/ Cannot currently support stack-locking with Lilliput and ZGC.\n+  FLAG_SET_DEFAULT(UseHeavyMonitors, true);\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -147,4 +147,0 @@\n-    \/\/ Get the size of the object before calling the closure, which\n-    \/\/ might overwrite the object in case we are relocating in-place.\n-    const size_t size = ZUtils::object_size(addr);\n-\n@@ -155,1 +151,1 @@\n-    const uintptr_t next_addr = align_up(addr + size, 1 << page_object_alignment_shift);\n+    const uintptr_t next_addr = align_up(addr + 1, 1 << page_object_alignment_shift);\n","filename":"src\/hotspot\/share\/gc\/z\/zLiveMap.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,3 +46,4 @@\n-  const size_t segment_max = ZUtils::bytes_to_words(64 * K);\n-  const size_t skip = arrayOopDesc::header_size(ArrayKlass::cast(_klass)->element_type());\n-  size_t remaining = _word_size - skip;\n+  const size_t segment_max = 64 * K;\n+  const size_t skip = arrayOopDesc::base_offset_in_bytes(ArrayKlass::cast(_klass)->element_type());\n+  size_t byte_size = _word_size * BytesPerWord;\n+  size_t remaining = byte_size - skip;\n@@ -53,1 +54,1 @@\n-    Copy::zero_to_words(mem + (_word_size - remaining), segment);\n+    Copy::zero_to_bytes(((char*)mem) + (byte_size - remaining), segment);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -335,0 +336,4 @@\n+\n+    if (SuspendibleThreadSet::should_yield()) {\n+      SuspendibleThreadSet::yield();\n+    }\n@@ -406,0 +411,1 @@\n+    SuspendibleThreadSetJoiner sts_joiner;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2004,0 +2004,3 @@\n+#ifdef _LP64\n+              oopDesc::release_set_mark(result, ik->prototype_header());\n+#else\n@@ -2005,1 +2008,0 @@\n-              oopDesc::set_klass_gap(result, 0);\n@@ -2007,1 +2009,1 @@\n-\n+#endif\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,2 @@\n-    _store->push(ObjectSampleMarkWord(obj, obj->mark()));\n+    markWord mark = obj->mark();\n+    _store->push(ObjectSampleMarkWord(obj, mark));\n@@ -73,1 +74,6 @@\n-    obj->set_mark(markWord::prototype().set_marked());\n+#ifdef _LP64\n+    if (mark.has_displaced_mark_helper()) {\n+      mark = mark.displaced_mark_helper();\n+    }\n+#endif\n+    obj->set_mark(markWord::prototype().set_marked() LP64_ONLY(.set_narrow_klass(mark.narrow_klass())));\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/objectSampleMarker.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2203,1 +2203,1 @@\n-  return arrayOopDesc::header_size(type) * HeapWordSize;\n+  return arrayOopDesc::base_offset_in_bytes(type);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,1 +270,0 @@\n-  volatile_nonstatic_field(oopDesc,            _metadata._klass,                              Klass*)                                \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -39,0 +40,2 @@\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/align.hpp\"\n@@ -40,0 +43,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -59,0 +63,2 @@\n+  const int klass_alignment_words = KlassAlignmentInBytes \/ BytesPerWord;\n+\n@@ -63,0 +69,1 @@\n+      metaspace::MetaspaceMinAlignmentWords,\n@@ -69,0 +76,1 @@\n+    \/\/ Klass instances live in class space and must be aligned correctly.\n@@ -74,0 +82,1 @@\n+        klass_alignment_words,\n@@ -77,0 +86,5 @@\n+  } else {\n+    \/\/ note for lilliput, this path should be restricted to 32bit only. There, klass alignment\n+    \/\/  should be compatible with metaspace minimal alignment since we store Klass structures\n+    \/\/  in regular metaspace.\n+    NOT_LP64(STATIC_ASSERT(metaspace::MetaspaceMinAlignmentBytes == KlassAlignmentInBytes));\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -835,2 +836,2 @@\n-  \/\/  of ccs\".\n-  \/\/ Before Elastic Metaspace that did not happen due to the fact that every Metachunk\n+  \/\/  of ccs\". See CompressedKlassPointers::decode().\n+  \/\/ Before JEP 387 that did not happen due to the fact that every Metachunk\n@@ -870,0 +871,14 @@\n+#ifdef _LP64\n+\/\/ The largest allowed size for class space\n+size_t Metaspace::max_class_space_size() {\n+  \/\/ This is a bit fuzzy. Max value of class space size depends on narrow klass pointer\n+  \/\/ encoding range size and CDS, since class space shares encoding range with CDS. CDS\n+  \/\/ archives are usually pretty small though, so to keep matters simple, for now we\n+  \/\/ just assume a reasonable default (this is hackish; improve!).\n+  const size_t slice_for_cds = M * 128;\n+  assert(KlassEncodingMetaspaceMax >= (slice_for_cds * 2), \"rethink this\");\n+  const size_t max_class_space_size = KlassEncodingMetaspaceMax - slice_for_cds;\n+  return max_class_space_size;\n+}\n+#endif \/\/ _LP64\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -112,0 +112,3 @@\n+  \/\/ The largest allowed size for class space\n+  LP64_ONLY(static size_t max_class_space_size();)\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,0 +55,5 @@\n+    \/\/ Attention alignment: the resulting block must have the right alignment\n+    \/\/  for the enclosing arena. ATM this works, since the arena aligns allocated block\n+    \/\/  size. If we ever switch to a different model (e.g. aligning the start\n+    \/\/  address of allocated blocks instead of the request size) this should be\n+    \/\/  rewritten).\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeBlocks.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_METASPACE_ALIGNMENT_HPP\n+#define SHARE_MEMORY_METASPACE_ALIGNMENT_HPP\n+\n+#include \"memory\/metaspace\/chunklevel.hpp\"\n+#include \"memory\/metaspace\/freeBlocks.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+namespace metaspace {\n+\n+\/\/ The minimal alignment: good enough to store structures with 64bit wide members (also on 32-bit).\n+\/\/ Should we ever store longer values, revise.\n+static const int LogMetaspaceMinimalAlignment = LogBytesPerLong;\n+static const int MetaspaceMinAlignmentBytes = 1 << LogMetaspaceMinimalAlignment;\n+static const int MetaspaceMinAlignmentWords = MetaspaceMinAlignmentBytes \/ BytesPerWord;\n+\n+\/\/ The maximum possible alignment is the smallest chunk size (note that the buddy allocator places\n+\/\/ chunks at chunk-size-aligned boundaries, therefore the start address is guaranteed to be aligned).\n+\/\/ We cannot guarantee allocation alignment beyond this value.\n+static const int MetaspaceMaxAlignmentWords = chunklevel::MIN_CHUNK_WORD_SIZE;\n+\n+\/\/ Given a net allocation word size and an alignment value, return the raw word size we actually\n+\/\/ allocate internally.\n+inline size_t get_raw_word_size_for_requested_word_size(size_t net_word_size,\n+                                                        size_t alignment_words) {\n+\n+  \/\/ The alignment should be between the minimum alignment but cannot be larger than the smallest chunk size\n+  assert(is_power_of_2(alignment_words), \"invalid alignment\");\n+  assert(alignment_words >= MetaspaceMinAlignmentWords &&\n+         alignment_words <= MetaspaceMaxAlignmentWords,\n+         \"invalid alignment (\" SIZE_FORMAT \")\", alignment_words);\n+\n+  \/\/ Deallocated metablocks are kept in a binlist which means blocks need to have\n+  \/\/ a minimal size\n+  size_t raw_word_size = MAX2(net_word_size, FreeBlocks::MinWordSize);\n+\n+  raw_word_size = align_up(raw_word_size, alignment_words);\n+\n+  return raw_word_size;\n+}\n+\n+} \/\/ namespace metaspace\n+\n+#endif \/\/ SHARE_MEMORY_METASPACE_ALIGNMENT_HPP\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceAlignment.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -110,1 +111,1 @@\n-MetaspaceArena::MetaspaceArena(ChunkManager* chunk_manager, const ArenaGrowthPolicy* growth_policy,\n+MetaspaceArena::MetaspaceArena(ChunkManager* chunk_manager, const ArenaGrowthPolicy* growth_policy, int alignment_words,\n@@ -117,0 +118,1 @@\n+  _alignment_words(alignment_words),\n@@ -123,0 +125,1 @@\n+\n@@ -227,1 +230,1 @@\n-  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size);\n+  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size, _alignment_words);\n@@ -271,1 +274,1 @@\n-  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size);\n+  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size, _alignment_words);\n@@ -371,1 +374,1 @@\n-  size_t raw_word_size = get_raw_word_size_for_requested_word_size(word_size);\n+  size_t raw_word_size = get_raw_word_size_for_requested_word_size(word_size, _alignment_words);\n@@ -485,2 +488,2 @@\n-  st->print_cr(\"growth-policy \" PTR_FORMAT \", lock \" PTR_FORMAT \", cm \" PTR_FORMAT \", fbl \" PTR_FORMAT,\n-                p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));\n+  st->print_cr(\"growth-policy \" PTR_FORMAT \", alignment %d, lock \" PTR_FORMAT \", cm \" PTR_FORMAT \", fbl \" PTR_FORMAT,\n+                p2i(_growth_policy), _alignment_words * BytesPerWord, p2i(_lock), p2i(_chunk_manager), p2i(_fbl));\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+  \/\/ Alignment alignment, in words.\n+  const int _alignment_words;\n+\n@@ -167,1 +170,1 @@\n-  MetaspaceArena(ChunkManager* chunk_manager, const ArenaGrowthPolicy* growth_policy,\n+  MetaspaceArena(ChunkManager* chunk_manager, const ArenaGrowthPolicy* growth_policy, int alignment_words,\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -171,18 +172,0 @@\n-\/\/ Given a net allocation word size, return the raw word size we actually allocate.\n-\/\/ Note: externally visible for gtests.\n-\/\/static\n-size_t get_raw_word_size_for_requested_word_size(size_t word_size) {\n-  size_t byte_size = word_size * BytesPerWord;\n-\n-  \/\/ Deallocated metablocks are kept in a binlist which limits their minimal\n-  \/\/  size to at least the size of a binlist item (2 words).\n-  byte_size = MAX2(byte_size, FreeBlocks::MinWordSize * BytesPerWord);\n-\n-  \/\/ Metaspace allocations are aligned to word size.\n-  byte_size = align_up(byte_size, AllocationAlignmentByteSize);\n-\n-  size_t raw_word_size = byte_size \/ BytesPerWord;\n-  assert(raw_word_size * BytesPerWord == byte_size, \"Sanity\");\n-  return raw_word_size;\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,21 +38,0 @@\n-\/\/ Metaspace allocation alignment:\n-\n-\/\/ 1) Metaspace allocations have to be aligned such that 64bit values are aligned\n-\/\/  correctly.\n-\/\/\n-\/\/ 2) Klass* structures allocated from Metaspace have to be aligned to KlassAlignmentInBytes.\n-\/\/\n-\/\/ At the moment LogKlassAlignmentInBytes is 3, so KlassAlignmentInBytes == 8,\n-\/\/  so (1) and (2) can both be fulfilled with an alignment of 8. Should we increase\n-\/\/  KlassAlignmentInBytes at any time this will increase the necessary alignment as well. In\n-\/\/  that case we may think about introducing a separate alignment just for the class space\n-\/\/  since that alignment would only be needed for Klass structures.\n-\n-static const size_t AllocationAlignmentByteSize = 8;\n-STATIC_ASSERT(AllocationAlignmentByteSize == (size_t)KlassAlignmentInBytes);\n-\n-static const size_t AllocationAlignmentWordSize = AllocationAlignmentByteSize \/ BytesPerWord;\n-\n-\/\/ Returns the raw word size allocated for a given net allocation\n-size_t get_raw_word_size_for_requested_word_size(size_t word_size);\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/compressedOops.hpp\"\n@@ -108,0 +109,6 @@\n+    out->cr();\n+    out->print_cr(\"KlassAlignmentInBytes: %d\", KlassAlignmentInBytes);\n+    out->print(\"KlassEncodingMetaspaceMax: \");\n+    print_human_readable_size(out, KlassEncodingMetaspaceMax, scale);\n+    out->cr();\n+    CompressedKlassPointers::print_mode(out);\n@@ -109,1 +116,1 @@\n-    out->print(\"No class space\");\n+    out->print_cr(\"No class space\");\n@@ -111,1 +118,0 @@\n-  out->cr();\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceReporter.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -100,1 +101,2 @@\n-    arena = new MetaspaceArena(_context->cm(), growth_policy, lock, &_used_words_counter, _name);\n+    arena = new MetaspaceArena(_context->cm(), growth_policy, MetaspaceMinAlignmentWords,\n+                               lock, &_used_words_counter, _name);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/testHelpers.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -552,0 +552,4 @@\n+    \/\/ Note Lilliput: the advantages of this strategy were questionable before\n+    \/\/  (since CDS=off + Compressed oops + heap large enough to suffocate us out of lower 32g\n+    \/\/  is rare) and with Lilliput the encoding range drastically shrank. We may just do away\n+    \/\/  with this altogether.\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,2 +53,1 @@\n-    size_t hs = align_up(length_offset_in_bytes() + sizeof(int),\n-                              HeapWordSize);\n+    size_t hs = length_offset_in_bytes() + sizeof(int);\n@@ -74,0 +73,5 @@\n+#ifdef _LP64\n+    if (type == T_OBJECT || type == T_ARRAY) {\n+      return !UseCompressedOops;\n+    }\n+#endif\n@@ -82,2 +86,1 @@\n-    return UseCompressedClassPointers ? klass_gap_offset_in_bytes() :\n-                               sizeof(arrayOopDesc);\n+    return sizeof(arrayOopDesc);\n@@ -88,1 +91,4 @@\n-    return header_size(type) * HeapWordSize;\n+    size_t typesize_in_bytes = header_size_in_bytes();\n+    return (int)(element_type_should_be_aligned(type)\n+                 ? align_up(typesize_in_bytes, BytesPerLong)\n+                 : typesize_in_bytes);\n@@ -125,11 +131,0 @@\n-  \/\/ Should only be called with constants as argument\n-  \/\/ (will not constant fold otherwise)\n-  \/\/ Returns the header size in words aligned to the requirements of the\n-  \/\/ array object type.\n-  static int header_size(BasicType type) {\n-    size_t typesize_in_bytes = header_size_in_bytes();\n-    return (int)(element_type_should_be_aligned(type)\n-      ? align_object_offset(typesize_in_bytes\/HeapWordSize)\n-      : typesize_in_bytes\/HeapWordSize);\n-  }\n-\n@@ -144,4 +139,2 @@\n-    const size_t max_element_words_per_size_t =\n-      align_down((SIZE_MAX\/HeapWordSize - header_size(type)), MinObjAlignment);\n-    const size_t max_elements_per_size_t =\n-      HeapWordSize * max_element_words_per_size_t \/ type2aelembytes(type);\n+    const size_t max_size_bytes = align_down(SIZE_MAX - base_offset_in_bytes(type), MinObjAlignmentInBytes);\n+    const size_t max_elements_per_size_t = max_size_bytes \/ type2aelembytes(type);\n@@ -153,1 +146,2 @@\n-      return align_down(max_jint - header_size(type), MinObjAlignment);\n+      int header_size_words = align_up(base_offset_in_bytes(type), HeapWordSize) \/ HeapWordSize;\n+      return align_down(max_jint - header_size_words, MinObjAlignment);\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":15,"deletions":21,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+address CompressedKlassPointers::_base = NULL;\n+int CompressedKlassPointers::_shift_copy = 0;\n+\n+\/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n+\/\/  cover, choose base, shift and range.\n+\/\/  The address range is the expected range of uncompressed Klass pointers we\n+\/\/  will encounter (and the implicit promise that there will be no Klass\n+\/\/  structures outside this range).\n+void CompressedKlassPointers::initialize(address addr, size_t len) {\n+#ifdef _LP64\n+  assert(UseCompressedClassPointers, \"Sanity\");\n+\n+  assert(len <= (size_t)KlassEncodingMetaspaceMax, \"Range \" SIZE_FORMAT \" too large \"\n+         \"- cannot be contained fully in narrow Klass pointer encoding range.\", len);\n+\n+  if (UseSharedSpaces || DumpSharedSpaces) {\n+\n+    \/\/ Special requirements if CDS is active:\n+    \/\/ Encoding base and shift must be the same between dump and run time.\n+    \/\/   CDS takes care that the SharedBaseAddress and CompressedClassSpaceSize\n+    \/\/   are the same. Archive size will be probably different at runtime, but\n+    \/\/   it can only be smaller than at, never larger, since archives get\n+    \/\/   shrunk at the end of the dump process.\n+    \/\/   From that it follows that the range [addr, len) we are handed in at\n+    \/\/   runtime will start at the same address then at dumptime, and its len\n+    \/\/   may be smaller at runtime then it was at dump time.\n+    \/\/\n+    \/\/ To be very careful here, we avoid any optimizations and just keep using\n+    \/\/  the same address and shift value. Specifically we avoid using zero-based\n+    \/\/  encoding. We also set the expected value range to 4G (encoding range\n+    \/\/  cannot be larger than that).\n+\n+    _base = addr;\n+\n+  } else {\n+\n+    \/\/ (Note that this case is almost not worth optimizing for. CDS is typically on.)\n+    if ((addr + len) <= (address)KlassEncodingMetaspaceMax) {\n+      _base = 0;\n+    } else {\n+      _base = addr;\n+    }\n+  }\n+\n+  assert(is_valid_base(_base), \"Address \" PTR_FORMAT \" was chosen as encoding base for range [\"\n+                               PTR_FORMAT \", \" PTR_FORMAT \") but is not a valid encoding base\",\n+                               p2i(_base), p2i(addr), p2i(addr + len));\n+\n+  \/\/ For SA\n+  _shift_copy = LogKlassAlignmentInBytes;\n+\n+#else\n+  ShouldNotReachHere(); \/\/ 64-bit only\n+#endif\n+}\n+\n+\/\/ 64-bit platforms define these functions on a per-platform base. They are not needed for\n+\/\/  32-bit (in fact, the whole setup is not needed and could be excluded from compilation,\n+\/\/  but that is a question for another RFE).\n+#ifndef _LP64\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  ShouldNotReachHere(); \/\/ 64-bit only\n+  return false;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_COMPRESSEDKLASS_HPP\n+#define SHARE_OOPS_COMPRESSEDKLASS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+class Klass;\n+\n+\/\/ Narrow Klass pointer constants;\n+#ifdef _LP64\n+const int LogKlassAlignmentInBytes = 9; \/\/ 512 byte alignment (Lilliput)\n+#else\n+const int LogKlassAlignmentInBytes = 3; \/\/ traditional 64-bit alignment\n+#endif\n+\n+const int KlassAlignmentInBytes    = 1 << LogKlassAlignmentInBytes;\n+\n+\/\/ Max. allowed size of compressed class pointer, in bits\n+const  int      MaxNarrowKlassPointerBits = 22;\n+\n+\/\/ Mask to mask in the bits which are valid to be set in a narrow Klass pointer\n+const uint64_t  NarrowKlassPointerBitMask = ((((uint64_t)1) << MaxNarrowKlassPointerBits) - 1);\n+\n+\/\/ Maximal size of compressed class pointer encoding range (2G with 22bit class ptr and 9 bit alignment).\n+const  uint64_t KlassEncodingMetaspaceMax = UCONST64(1) << (MaxNarrowKlassPointerBits + LogKlassAlignmentInBytes);\n+\n+\/\/ If compressed klass pointers then use narrowKlass.\n+typedef uint32_t narrowKlass;\n+\n+class CompressedKlassPointers : public AllStatic {\n+  friend class VMStructs;\n+  friend class ArchiveBuilder;\n+\n+  static address _base;\n+\n+  \/\/ Shift is actually a constant; we keep this just for the SA (see vmStructs.cpp and\n+  \/\/ sun\/jvm\/hotspot\/oops\/CompressedKlassPointers.java)\n+  static int _shift_copy;\n+\n+  \/\/ The decode\/encode versions taking an explicit base are for the sole use of CDS\n+  \/\/ (see ArchiveBuilder).\n+  static inline Klass* decode_raw(narrowKlass v, address base);\n+  static inline Klass* decode_not_null(narrowKlass v, address base);\n+  static inline narrowKlass encode_not_null(Klass* v, address base);\n+  DEBUG_ONLY(static inline void verify_klass_pointer(const Klass* v, address base));\n+\n+public:\n+\n+  \/\/ Given an address p, return true if p can be used as an encoding base.\n+  \/\/  (Some platforms have restrictions of what constitutes a valid base\n+  \/\/   address).\n+  static bool is_valid_base(address p);\n+\n+  \/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n+  \/\/  cover, choose base, shift and range.\n+  \/\/  The address range is the expected range of uncompressed Klass pointers we\n+  \/\/  will encounter (and the implicit promise that there will be no Klass\n+  \/\/  structures outside this range).\n+  static void initialize(address addr, size_t len);\n+\n+  static void     print_mode(outputStream* st);\n+\n+  \/\/ The encoding base. Note: this is not necessarily the base address of the\n+  \/\/ class space nor the base address of the CDS archive.\n+  static address  base()             { return  _base; }\n+\n+  \/\/ End of the encoding range.\n+  static address  end()              { return base() + KlassEncodingMetaspaceMax; }\n+\n+  \/\/ Shift == LogKlassAlignmentInBytes (TODO: unify)\n+  static int      shift()            { return  LogKlassAlignmentInBytes; }\n+\n+  static bool is_null(Klass* v)      { return v == NULL; }\n+  static bool is_null(narrowKlass v) { return v == 0; }\n+\n+  static inline Klass* decode_raw(narrowKlass v);\n+  static inline Klass* decode_not_null(narrowKlass v);\n+  static inline Klass* decode(narrowKlass v);\n+  static inline narrowKlass encode_not_null(Klass* v);\n+  static inline narrowKlass encode(Klass* v);\n+\n+  DEBUG_ONLY(static inline void verify_klass_pointer(const Klass* v));\n+  DEBUG_ONLY(static inline void verify_narrow_klass_pointer(narrowKlass v);)\n+\n+};\n+\n+#endif \/\/ SHARE_OOPS_COMPRESSEDOOPS_HPP\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_COMPRESSEDKLASS_INLINE_HPP\n+#define SHARE_OOPS_COMPRESSEDKLASS_INLINE_HPP\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\n+static inline bool check_alignment(Klass* v) {\n+  return (intptr_t)v % KlassAlignmentInBytes == 0;\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v) {\n+  return decode_raw(v, base());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base) {\n+  return (Klass*)(void*)((uintptr_t)narrow_base +((uintptr_t)v << shift()));\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v) {\n+  return decode_not_null(v, base());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v, address narrow_base) {\n+  assert(!is_null(v), \"narrow klass value can never be zero\");\n+  Klass* result = decode_raw(v, narrow_base);\n+  DEBUG_ONLY(verify_klass_pointer(result, narrow_base));\n+  return result;\n+}\n+\n+inline Klass* CompressedKlassPointers::decode(narrowKlass v) {\n+  return is_null(v) ? (Klass*)NULL : decode_not_null(v);\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v) {\n+  return encode_not_null(v, base());\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v, address narrow_base) {\n+  DEBUG_ONLY(verify_klass_pointer(v, narrow_base));\n+  uint64_t v2 = (uint64_t)(pointer_delta((void*)v, narrow_base, 1));\n+  v2 >>= shift();\n+  assert(v2 <= UINT_MAX, \"narrow klass pointer overflow\");\n+  narrowKlass result = (narrowKlass)v2;\n+  DEBUG_ONLY(verify_narrow_klass_pointer(result));\n+  assert(decode_not_null(result, narrow_base) == v, \"reversibility\");\n+  return result;\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode(Klass* v) {\n+  return is_null(v) ? (narrowKlass)0 : encode_not_null(v);\n+}\n+\n+#ifdef ASSERT\n+inline void CompressedKlassPointers::verify_klass_pointer(const Klass* v, address narrow_base) {\n+  assert(is_aligned(v, KlassAlignmentInBytes), \"misaligned Klass* pointer (\" PTR_FORMAT \")\", p2i(v));\n+  address end = narrow_base + KlassEncodingMetaspaceMax;\n+  assert((address)v >= narrow_base && (address)v < end,\n+         \"Klass (\" PTR_FORMAT \") located outside encoding range [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+         p2i(v), p2i(narrow_base), p2i(end));\n+}\n+\n+inline void CompressedKlassPointers::verify_klass_pointer(const Klass* v) {\n+  verify_klass_pointer(v, base());\n+}\n+\n+inline void CompressedKlassPointers::verify_narrow_klass_pointer(narrowKlass v) {\n+  \/\/ Make sure we only use the lower n bits\n+  assert((((uint64_t)v) & ~NarrowKlassPointerBitMask) == 0, \"%x: not a valid narrow klass pointer\", v);\n+}\n+#endif\n+\n+#endif \/\/ SHARE_OOPS_COMPRESSEDOOPS_HPP\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.inline.hpp","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -180,123 +180,0 @@\n-\n-\/\/ For UseCompressedClassPointers.\n-NarrowPtrStruct CompressedKlassPointers::_narrow_klass = { NULL, 0, true };\n-\n-\/\/ CompressedClassSpaceSize set to 1GB, but appear 3GB away from _narrow_ptrs_base during CDS dump.\n-\/\/ (Todo: we should #ifdef out CompressedKlassPointers for 32bit completely and fix all call sites which\n-\/\/  are compiled for 32bit to LP64_ONLY).\n-size_t CompressedKlassPointers::_range = 0;\n-\n-\n-\/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n-\/\/  cover, choose base, shift and range.\n-\/\/  The address range is the expected range of uncompressed Klass pointers we\n-\/\/  will encounter (and the implicit promise that there will be no Klass\n-\/\/  structures outside this range).\n-void CompressedKlassPointers::initialize(address addr, size_t len) {\n-#ifdef _LP64\n-  assert(is_valid_base(addr), \"Address must be a valid encoding base\");\n-  address const end = addr + len;\n-\n-  address base;\n-  int shift;\n-  size_t range;\n-\n-  if (UseSharedSpaces || DumpSharedSpaces) {\n-\n-    \/\/ Special requirements if CDS is active:\n-    \/\/ Encoding base and shift must be the same between dump and run time.\n-    \/\/   CDS takes care that the SharedBaseAddress and CompressedClassSpaceSize\n-    \/\/   are the same. Archive size will be probably different at runtime, but\n-    \/\/   it can only be smaller than at, never larger, since archives get\n-    \/\/   shrunk at the end of the dump process.\n-    \/\/   From that it follows that the range [addr, len) we are handed in at\n-    \/\/   runtime will start at the same address then at dumptime, and its len\n-    \/\/   may be smaller at runtime then it was at dump time.\n-    \/\/\n-    \/\/ To be very careful here, we avoid any optimizations and just keep using\n-    \/\/  the same address and shift value. Specifically we avoid using zero-based\n-    \/\/  encoding. We also set the expected value range to 4G (encoding range\n-    \/\/  cannot be larger than that).\n-\n-    base = addr;\n-\n-    \/\/ JDK-8265705\n-    \/\/ This is a temporary fix for aarch64: there, if the range-to-be-encoded is located\n-    \/\/  below 32g, either encoding base should be zero or base should be aligned to 4G\n-    \/\/  and shift should be zero. The simplest way to fix this for now is to force\n-    \/\/  shift to zero for both runtime and dumptime.\n-    \/\/ Note however that this is not a perfect solution. Ideally this whole function\n-    \/\/  should be CDS agnostic, that would simplify it - and testing - a lot. See JDK-8267141\n-    \/\/  for details.\n-    shift = 0;\n-\n-    \/\/ This must be true since at dumptime cds+ccs is 4G, at runtime it can\n-    \/\/  only be smaller, see comment above.\n-    assert(len <= 4 * G, \"Encoding range cannot be larger than 4G\");\n-    range = 4 * G;\n-\n-  } else {\n-\n-    \/\/ Otherwise we attempt to use a zero base if the range fits in lower 32G.\n-    if (end <= (address)KlassEncodingMetaspaceMax) {\n-      base = 0;\n-    } else {\n-      base = addr;\n-    }\n-\n-    \/\/ Highest offset a Klass* can ever have in relation to base.\n-    range = end - base;\n-\n-    \/\/ We may not even need a shift if the range fits into 32bit:\n-    const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);\n-    if (range < UnscaledClassSpaceMax) {\n-      shift = 0;\n-    } else {\n-      shift = LogKlassAlignmentInBytes;\n-    }\n-\n-  }\n-\n-  set_base(base);\n-  set_shift(shift);\n-  set_range(range);\n-#else\n-  fatal(\"64bit only.\");\n-#endif\n-}\n-\n-\/\/ Given an address p, return true if p can be used as an encoding base.\n-\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n-bool CompressedKlassPointers::is_valid_base(address p) {\n-#ifdef AARCH64\n-  \/\/ Below 32G, base must be aligned to 4G.\n-  \/\/ Above that point, base must be aligned to 32G\n-  if (p < (address)(32 * G)) {\n-    return is_aligned(p, 4 * G);\n-  }\n-  return is_aligned(p, (4 << LogKlassAlignmentInBytes) * G);\n-#else\n-  return true;\n-#endif\n-}\n-\n-void CompressedKlassPointers::print_mode(outputStream* st) {\n-  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n-               \"Narrow klass range: \" SIZE_FORMAT_X, p2i(base()), shift(),\n-               range());\n-}\n-\n-void CompressedKlassPointers::set_base(address base) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _narrow_klass._base   = base;\n-}\n-\n-void CompressedKlassPointers::set_shift(int shift)       {\n-  assert(shift == 0 || shift == LogKlassAlignmentInBytes, \"invalid shift for klass ptrs\");\n-  _narrow_klass._shift   = shift;\n-}\n-\n-void CompressedKlassPointers::set_range(size_t range) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _range = range;\n-}\n","filename":"src\/hotspot\/share\/oops\/compressedOops.cpp","additions":0,"deletions":123,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -142,53 +142,0 @@\n-\/\/ For UseCompressedClassPointers.\n-class CompressedKlassPointers : public AllStatic {\n-  friend class VMStructs;\n-\n-  static NarrowPtrStruct _narrow_klass;\n-\n-  \/\/ Together with base, this defines the address range within which Klass\n-  \/\/  structures will be located: [base, base+range). While the maximal\n-  \/\/  possible encoding range is 4|32G for shift 0|3, if we know beforehand\n-  \/\/  the expected range of Klass* pointers will be smaller, a platform\n-  \/\/  could use this info to optimize encoding.\n-  static size_t _range;\n-\n-  static void set_base(address base);\n-  static void set_range(size_t range);\n-\n-public:\n-\n-  static void set_shift(int shift);\n-\n-\n-  \/\/ Given an address p, return true if p can be used as an encoding base.\n-  \/\/  (Some platforms have restrictions of what constitutes a valid base\n-  \/\/   address).\n-  static bool is_valid_base(address p);\n-\n-  \/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n-  \/\/  cover, choose base, shift and range.\n-  \/\/  The address range is the expected range of uncompressed Klass pointers we\n-  \/\/  will encounter (and the implicit promise that there will be no Klass\n-  \/\/  structures outside this range).\n-  static void initialize(address addr, size_t len);\n-\n-  static void     print_mode(outputStream* st);\n-\n-  static address  base()               { return  _narrow_klass._base; }\n-  static size_t   range()              { return  _range; }\n-  static int      shift()              { return  _narrow_klass._shift; }\n-\n-  static bool is_null(Klass* v)      { return v == NULL; }\n-  static bool is_null(narrowKlass v) { return v == 0; }\n-\n-  static inline Klass* decode_raw(narrowKlass v, address base);\n-  static inline Klass* decode_raw(narrowKlass v);\n-  static inline Klass* decode_not_null(narrowKlass v);\n-  static inline Klass* decode_not_null(narrowKlass v, address base);\n-  static inline Klass* decode(narrowKlass v);\n-  static inline narrowKlass encode_not_null(Klass* v);\n-  static inline narrowKlass encode_not_null(Klass* v, address base);\n-  static inline narrowKlass encode(Klass* v);\n-\n-};\n-\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -116,46 +116,0 @@\n-static inline bool check_alignment(Klass* v) {\n-  return (intptr_t)v % KlassAlignmentInBytes == 0;\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v) {\n-  return decode_raw(v, base());\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base) {\n-  return (Klass*)((uintptr_t)narrow_base +((uintptr_t)v << shift()));\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v) {\n-  return decode_not_null(v, base());\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v, address narrow_base) {\n-  assert(!is_null(v), \"narrow klass value can never be zero\");\n-  Klass* result = decode_raw(v, narrow_base);\n-  assert(check_alignment(result), \"address not aligned: \" PTR_FORMAT, p2i(result));\n-  return result;\n-}\n-\n-inline Klass* CompressedKlassPointers::decode(narrowKlass v) {\n-  return is_null(v) ? (Klass*)NULL : decode_not_null(v);\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v) {\n-  return encode_not_null(v, base());\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v, address narrow_base) {\n-  assert(!is_null(v), \"klass value can never be zero\");\n-  assert(check_alignment(v), \"Address not aligned\");\n-  uint64_t pd = (uint64_t)(pointer_delta(v, narrow_base, 1));\n-  assert(KlassEncodingMetaspaceMax > pd, \"change encoding max if new encoding\");\n-  uint64_t result = pd >> shift();\n-  assert((result & CONST64(0xffffffff00000000)) == 0, \"narrow klass pointer overflow\");\n-  assert(decode_not_null(result, narrow_base) == v, \"reversibility\");\n-  return (narrowKlass)result;\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode(Klass* v) {\n-  return is_null(v) ? (narrowKlass)0 : encode_not_null(v);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/compressedOops.inline.hpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -41,4 +41,1 @@\n-    return (UseCompressedClassPointers) ?\n-            klass_gap_offset_in_bytes() :\n-            sizeof(instanceOopDesc);\n-\n+    return sizeof(instanceOopDesc);\n","filename":"src\/hotspot\/share\/oops\/instanceOop.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  static void trace_reference_gc(const char *s, oop obj) NOT_DEBUG_RETURN;\n+  void trace_reference_gc(const char *s, oop obj) NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-  if (java_lang_ref_Reference::is_phantom(obj)) {\n+  if (reference_type() == REF_PHANTOM) {\n","filename":"src\/hotspot\/share\/oops\/instanceRefKlass.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -54,0 +55,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -199,1 +201,3 @@\n-  return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);\n+  MetaWord* p = Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);\n+  assert(is_aligned(p, KlassAlignmentInBytes), \"metaspace returned badly aligned memory.\");\n+  return p;\n@@ -207,0 +211,1 @@\n+                           _prototype_header(markWord::prototype() LP64_ONLY(.set_klass(this))),\n@@ -751,0 +756,2 @@\n+     st->print(BULLET\"prototype_header: \" INTPTR_FORMAT, _prototype_header.value());\n+     st->cr();\n@@ -774,0 +781,4 @@\n+  if (UseCompressedClassPointers) {\n+    assert(is_aligned(this, KlassAlignmentInBytes), \"misaligned Klass structure\");\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -168,0 +168,2 @@\n+  markWord _prototype_header;   \/\/ Used to initialize objects' header\n+\n@@ -670,0 +672,4 @@\n+  markWord prototype_header() const      { return _prototype_header; }\n+  inline void set_prototype_header(markWord header);\n+  static ByteSize prototype_header_offset() { return in_ByteSize(offset_of(Klass, _prototype_header)); }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,0 +55,4 @@\n+inline void Klass::set_prototype_header(markWord header) {\n+  _prototype_header = header;\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n@@ -43,1 +43,1 @@\n-\/\/  unused:25 hash:31 -->| unused_gap:1  age:4  unused_gap:1  lock:2 (normal object)\n+\/\/  nklass:32 hash:25 -->| unused_gap:1  age:4  unused_gap:1  lock:2 (normal object)\n@@ -104,4 +104,6 @@\n-  static const int first_unused_gap_bits          = 1;\n-  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - first_unused_gap_bits;\n-  static const int hash_bits                      = max_hash_bits > 31 ? 31 : max_hash_bits;\n-  static const int second_unused_gap_bits         = LP64_ONLY(1) NOT_LP64(0);\n+  static const int self_forwarded_bits            = 1;\n+  static const int max_hash_bits                  = BitsPerWord - age_bits - lock_bits - self_forwarded_bits;\n+  static const int hash_bits                      = max_hash_bits > 25 ? 25 : max_hash_bits;\n+#ifdef _LP64\n+  static const int klass_bits                     = 32;\n+#endif\n@@ -110,2 +112,6 @@\n-  static const int age_shift                      = lock_bits + first_unused_gap_bits;\n-  static const int hash_shift                     = age_shift + age_bits + second_unused_gap_bits;\n+  static const int self_forwarded_shift           = lock_shift + lock_bits;\n+  static const int age_shift                      = self_forwarded_shift + self_forwarded_bits;\n+  static const int hash_shift                     = age_shift + age_bits;\n+#ifdef _LP64\n+  static const int klass_shift                    = hash_shift + hash_bits;\n+#endif\n@@ -115,0 +121,2 @@\n+  static const uintptr_t self_forwarded_mask      = right_n_bits(self_forwarded_bits);\n+  static const uintptr_t self_forwarded_mask_in_place = self_forwarded_mask << self_forwarded_shift;\n@@ -120,0 +128,5 @@\n+#ifdef _LP64\n+  static const uintptr_t klass_mask               = right_n_bits(klass_bits);\n+  static const uintptr_t klass_mask_in_place      = klass_mask << klass_shift;\n+#endif\n+\n@@ -234,0 +247,9 @@\n+#ifdef _LP64\n+  inline Klass* klass() const;\n+  inline Klass* klass_or_null() const;\n+  inline Klass* safe_klass() const;\n+  inline markWord set_klass(const Klass* klass) const;\n+  inline narrowKlass narrow_klass() const;\n+  inline markWord set_narrow_klass(const narrowKlass klass) const;\n+#endif\n+\n@@ -247,0 +269,8 @@\n+\n+  inline bool self_forwarded() const {\n+    return mask_bits(value(), self_forwarded_mask_in_place) != 0;\n+  }\n+\n+  inline markWord set_self_forwarded() const {\n+    return markWord(value() | self_forwarded_mask_in_place | marked_value);\n+  }\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_MARKWORD_INLINE_HPP\n+#define SHARE_OOPS_MARKWORD_INLINE_HPP\n+\n+#include \"oops\/compressedKlass.inline.hpp\"\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+\n+#ifdef _LP64\n+narrowKlass markWord::narrow_klass() const {\n+  return narrowKlass(value() >> klass_shift);\n+}\n+\n+Klass* markWord::klass() const {\n+  assert(!CompressedKlassPointers::is_null(narrow_klass()), \"narrow klass must not be null: \" INTPTR_FORMAT, value());\n+  return CompressedKlassPointers::decode_not_null(narrow_klass());\n+}\n+\n+Klass* markWord::klass_or_null() const {\n+  return CompressedKlassPointers::decode(narrow_klass());\n+}\n+\n+markWord markWord::set_narrow_klass(const narrowKlass nklass) const {\n+  return markWord((value() & ~klass_mask_in_place) | ((uintptr_t) nklass << klass_shift));\n+}\n+\n+Klass* markWord::safe_klass() const {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"only call at safepoint\");\n+  markWord m = *this;\n+  if (m.has_displaced_mark_helper()) {\n+    m = m.displaced_mark_helper();\n+  }\n+  return CompressedKlassPointers::decode_not_null(m.narrow_klass());\n+}\n+\n+markWord markWord::set_klass(const Klass* klass) const {\n+  assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n+  \/\/ TODO: Don't cast to non-const, change CKP::encode() to accept const Klass* instead.\n+  narrowKlass nklass = CompressedKlassPointers::encode(const_cast<Klass*>(klass));\n+  return set_narrow_klass(nklass);\n+}\n+#endif\n+\n+#endif \/\/ SHARE_OOPS_MARKWORD_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -159,1 +159,0 @@\n-  assert(obj->is_objArray(), \"must be object array\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  assert (obj->is_array(), \"obj must be array\");\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,23 +54,3 @@\n-  \/\/ Give size of objArrayOop in HeapWords minus the header\n-  static int array_size(int length) {\n-    const uint OopsPerHeapWord = HeapWordSize\/heapOopSize;\n-    assert(OopsPerHeapWord >= 1 && (HeapWordSize % heapOopSize == 0),\n-           \"Else the following (new) computation would be in error\");\n-    uint res = ((uint)length + OopsPerHeapWord - 1)\/OopsPerHeapWord;\n-#ifdef ASSERT\n-    \/\/ The old code is left in for sanity-checking; it'll\n-    \/\/ go away pretty soon. XXX\n-    \/\/ Without UseCompressedOops, this is simply:\n-    \/\/ oop->length() * HeapWordsPerOop;\n-    \/\/ With narrowOops, HeapWordsPerOop is 1\/2 or equal 0 as an integer.\n-    \/\/ The oop elements are aligned up to wordSize\n-    const uint HeapWordsPerOop = heapOopSize\/HeapWordSize;\n-    uint old_res;\n-    if (HeapWordsPerOop > 0) {\n-      old_res = length * HeapWordsPerOop;\n-    } else {\n-      old_res = align_up((uint)length, OopsPerHeapWord)\/OopsPerHeapWord;\n-    }\n-    assert(res == old_res, \"Inconsistency between old and new.\");\n-#endif  \/\/ ASSERT\n-    return res;\n+  \/\/ Give size of objArrayOop in bytes minus the header\n+  static size_t array_size_in_bytes(int length) {\n+    return (size_t)length * heapOopSize;\n@@ -96,1 +76,0 @@\n-  static int header_size()    { return arrayOopDesc::header_size(T_OBJECT); }\n@@ -101,5 +80,5 @@\n-    uint asz = array_size(length);\n-    uint osz = align_object_size(header_size() + asz);\n-    assert(osz >= asz,   \"no overflow\");\n-    assert((int)osz > 0, \"no overflow\");\n-    return (size_t)osz;\n+    size_t asz = array_size_in_bytes(length);\n+    size_t size_words = align_up(base_offset_in_bytes() + asz, HeapWordSize) \/ HeapWordSize;\n+    size_t osz = align_object_size(size_words);\n+    assert(osz < max_jint, \"no overflow\");\n+    return osz;\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":8,"deletions":29,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -150,13 +152,0 @@\n-bool oopDesc::has_klass_gap() {\n-  \/\/ Only has a klass gap when compressed class pointers are used.\n-  return UseCompressedClassPointers;\n-}\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-void oopDesc::set_narrow_klass(narrowKlass nk) {\n-  assert(DumpSharedSpaces, \"Used by CDS only. Do not abuse!\");\n-  assert(UseCompressedClassPointers, \"must be\");\n-  _metadata._compressed_klass = nk;\n-}\n-#endif\n-\n@@ -164,7 +153,8 @@\n-  if (UseCompressedClassPointers) {\n-    narrowKlass narrow_klass = obj->_metadata._compressed_klass;\n-    if (narrow_klass == 0) return NULL;\n-    return (void*)CompressedKlassPointers::decode_raw(narrow_klass);\n-  } else {\n-    return obj->_metadata._klass;\n-  }\n+  \/\/ TODO: Remove method altogether and replace with calls to obj->klass() ?\n+  \/\/ OTOH, we may eventually get rid of locking in header, and then no\n+  \/\/ longer have to deal with that anymore.\n+#ifdef _LP64\n+  return obj->klass();\n+#else\n+  return obj->_klass;\n+#endif\n@@ -184,0 +174,15 @@\n+#ifdef _LP64\n+JRT_LEAF(narrowKlass, oopDesc::load_nklass_runtime(oopDesc* o))\n+  assert(o != NULL, \"null-check\");\n+  oop obj = oop(o);\n+  assert(oopDesc::is_oop(obj), \"need a valid oop here: \" PTR_FORMAT, p2i(o));\n+  markWord header = obj->mark();\n+  if (!header.is_neutral()) {\n+    header = ObjectSynchronizer::stable_mark(obj);\n+  }\n+  assert(header.is_neutral(), \"expect neutral header here\");\n+  narrowKlass nklass = header.narrow_klass();\n+  return nklass;\n+JRT_END\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":25,"deletions":20,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -57,4 +58,3 @@\n-  union _metadata {\n-    Klass*      _klass;\n-    narrowKlass _compressed_klass;\n-  } _metadata;\n+#ifndef _LP64\n+  Klass*            _klass;\n+#endif\n@@ -78,0 +78,1 @@\n+  static inline void release_set_mark(HeapWord* mem, markWord m);\n@@ -89,1 +90,1 @@\n-  void set_narrow_klass(narrowKlass nk) NOT_CDS_JAVA_HEAP_RETURN;\n+#ifndef _LP64\n@@ -92,3 +93,1 @@\n-\n-  \/\/ For klass field compression\n-  static inline void set_klass_gap(HeapWord* mem, int z);\n+#endif\n@@ -260,0 +259,1 @@\n+  inline void forward_to_self();\n@@ -266,0 +266,1 @@\n+  inline oop forward_to_self_atomic(markWord compare, atomic_memory_order order = memory_order_conservative);\n@@ -268,0 +269,1 @@\n+  inline oop forwardee(markWord header) const;\n@@ -306,2 +308,0 @@\n-  static bool has_klass_gap();\n-\n@@ -310,4 +310,7 @@\n-  static int klass_offset_in_bytes()     { return offset_of(oopDesc, _metadata._klass); }\n-  static int klass_gap_offset_in_bytes() {\n-    assert(has_klass_gap(), \"only applicable to compressed klass pointers\");\n-    return klass_offset_in_bytes() + sizeof(narrowKlass);\n+  static int klass_offset_in_bytes()     {\n+#ifdef _LP64\n+    STATIC_ASSERT(markWord::klass_shift % 8 == 0);\n+    return mark_offset_in_bytes() + markWord::klass_shift \/ 8;\n+#else\n+    return offset_of(oopDesc, _klass);\n+#endif\n@@ -320,0 +323,5 @@\n+  \/\/ Runtime entry\n+#ifdef _LP64\n+  static narrowKlass load_nklass_runtime(oopDesc* o);\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -36,1 +37,1 @@\n-#include \"oops\/markWord.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n@@ -40,0 +41,2 @@\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n@@ -72,0 +75,4 @@\n+void oopDesc::release_set_mark(HeapWord* mem, markWord m) {\n+  Atomic::release_store((markWord*)(((char*)mem) + mark_offset_in_bytes()), m);\n+}\n+\n@@ -81,1 +88,8 @@\n-  set_mark(markWord::prototype());\n+#ifdef _LP64\n+  markWord header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n+  assert(UseCompressedClassPointers, \"expect compressed klass pointers\");\n+  header = markWord((header.value() & markWord::klass_mask_in_place) | markWord::prototype().value());\n+#else\n+  markWord header = markWord::prototype();\n+#endif\n+  set_mark(header);\n@@ -85,4 +99,5 @@\n-  if (UseCompressedClassPointers) {\n-    return CompressedKlassPointers::decode_not_null(_metadata._compressed_klass);\n-  } else {\n-    return _metadata._klass;\n+#ifdef _LP64\n+  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+  markWord header = mark();\n+  if (!header.is_neutral()) {\n+    header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n@@ -90,0 +105,4 @@\n+  return header.klass();\n+#else\n+  return _klass;\n+#endif\n@@ -93,4 +112,5 @@\n-  if (UseCompressedClassPointers) {\n-    return CompressedKlassPointers::decode(_metadata._compressed_klass);\n-  } else {\n-    return _metadata._klass;\n+#ifdef _LP64\n+  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+  markWord header = mark();\n+  if (!header.is_neutral()) {\n+    header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n@@ -98,0 +118,4 @@\n+  return header.klass_or_null();\n+#else\n+  return _klass;\n+#endif\n@@ -101,5 +125,5 @@\n-  if (UseCompressedClassPointers) {\n-    narrowKlass nklass = Atomic::load_acquire(&_metadata._compressed_klass);\n-    return CompressedKlassPointers::decode(nklass);\n-  } else {\n-    return Atomic::load_acquire(&_metadata._klass);\n+#ifdef _LP64\n+  assert(UseCompressedClassPointers, \"only with compressed class pointers\");\n+  markWord header = mark_acquire();\n+  if (!header.is_neutral()) {\n+    header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n@@ -107,0 +131,4 @@\n+  return header.klass_or_null();\n+#else\n+  return Atomic::load_acquire(&_klass);\n+#endif\n@@ -109,0 +137,1 @@\n+#ifndef _LP64\n@@ -111,5 +140,1 @@\n-  if (UseCompressedClassPointers) {\n-    _metadata._compressed_klass = CompressedKlassPointers::encode_not_null(k);\n-  } else {\n-    _metadata._klass = k;\n-  }\n+  _klass = k;\n@@ -128,6 +153,1 @@\n-\n-void oopDesc::set_klass_gap(HeapWord* mem, int v) {\n-  if (UseCompressedClassPointers) {\n-    *(int*)(((char*)mem) + klass_gap_offset_in_bytes()) = v;\n-  }\n-}\n+#endif\n@@ -262,1 +282,1 @@\n-  assert(m.decode_pointer() == p, \"encoding must be reversible\");\n+  assert(forwardee(m) == p, \"encoding must be reversable\");\n@@ -266,0 +286,17 @@\n+void oopDesc::forward_to_self() {\n+#ifdef _LP64\n+  verify_forwardee(this);\n+  markWord m = mark();\n+  \/\/ If mark is displaced, we need to preserve the Klass* from real header.\n+  assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+  if (m.has_displaced_mark_helper()) {\n+    m = m.displaced_mark_helper();\n+  }\n+  m = m.set_self_forwarded();\n+  assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversable\");\n+  set_mark(m);\n+#else\n+  forward_to(oop(this));\n+#endif\n+}\n+\n@@ -269,1 +306,20 @@\n-  assert(m.decode_pointer() == p, \"encoding must be reversible\");\n+  assert(forwardee(m) == p, \"encoding must be reversable\");\n+  markWord old_mark = cas_set_mark(m, compare, order);\n+  if (old_mark == compare) {\n+    return NULL;\n+  } else {\n+    return forwardee(old_mark);\n+  }\n+}\n+\n+oop oopDesc::forward_to_self_atomic(markWord compare, atomic_memory_order order) {\n+#ifdef _LP64\n+  verify_forwardee(this);\n+  markWord m = compare;\n+  \/\/ If mark is displaced, we need to preserve the Klass* from real header.\n+  assert(SafepointSynchronize::is_at_safepoint(), \"we can only safely fetch the displaced header at safepoint\");\n+  if (m.has_displaced_mark_helper()) {\n+    m = m.displaced_mark_helper();\n+  }\n+  m = m.set_self_forwarded();\n+  assert(forwardee(m) == cast_to_oop(this), \"encoding must be reversable\");\n@@ -274,1 +330,2 @@\n-    return cast_to_oop(old_mark.decode_pointer());\n+    assert(old_mark.is_marked(), \"must be marked here\");\n+    return forwardee(old_mark);\n@@ -276,0 +333,3 @@\n+#else\n+  return forward_to_atomic(oop(this), compare, order);\n+#endif\n@@ -282,2 +342,14 @@\n-  assert(is_forwarded(), \"only decode when actually forwarded\");\n-  return cast_to_oop(mark().decode_pointer());\n+  return forwardee(mark());\n+}\n+\n+oop oopDesc::forwardee(markWord header) const {\n+  assert(header.is_marked(), \"must be forwarded\");\n+#ifdef _LP64\n+  if (header.self_forwarded()) {\n+    return cast_to_oop(this);\n+  } else\n+#endif\n+  {\n+    assert(header.is_marked(), \"only decode when actually forwarded\");\n+    return cast_to_oop(header.decode_pointer());\n+  }\n@@ -338,1 +410,0 @@\n-  assert(k == klass(), \"wrong klass\");\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":103,"deletions":32,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-\/\/ If compressed klass pointers then use narrowKlass.\n-typedef juint  narrowKlass;\n-\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -231,1 +231,0 @@\n-  assert(obj->is_typeArray(),\"must be a type array\");\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-  assert(obj->is_typeArray(),\"must be a type array\");\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1574,3 +1574,3 @@\n-  Node* mark_node = NULL;\n-  \/\/ For now only enable fast locking for non-array types\n-  mark_node = phase->MakeConX(markWord::prototype().value());\n+  Node* klass_node = in(AllocateNode::KlassNode);\n+  Node* proto_adr = phase->transform(new AddPNode(klass_node, klass_node, phase->MakeConX(in_bytes(Klass::prototype_header_offset()))));\n+  Node* mark_node = LoadNode::make(*phase, control, mem, proto_adr, TypeRawPtr::BOTTOM, TypeX_X, TypeX_X->basic_type(), MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1660,0 +1660,1 @@\n+#ifndef _LP64\n@@ -1661,0 +1662,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -311,1 +311,1 @@\n-    const size_t hs = arrayOopDesc::header_size(elem_type);\n+    const size_t hs_bytes = arrayOopDesc::base_offset_in_bytes(elem_type);\n@@ -313,1 +313,1 @@\n-    const size_t aligned_hs = align_object_offset(hs);\n+    const size_t aligned_hs_bytes = align_up(hs_bytes, BytesPerLong);\n@@ -315,2 +315,2 @@\n-    if (aligned_hs > hs) {\n-      Copy::zero_to_words(obj+hs, aligned_hs-hs);\n+    if (aligned_hs_bytes > hs_bytes) {\n+      Copy::zero_to_bytes(obj + hs_bytes, aligned_hs_bytes - hs_bytes);\n@@ -319,0 +319,1 @@\n+    const size_t aligned_hs = aligned_hs_bytes \/ HeapWordSize;\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4856,1 +4856,2 @@\n-    int header_size = objArrayOopDesc::header_size() * wordSize;\n+    BasicType basic_elem_type = elem()->basic_type();\n+    int header_size = arrayOopDesc::base_offset_in_bytes(basic_elem_type);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  ( arrayOopDesc::header_size(T_DOUBLE) * HeapWordSize \\\n+  ( arrayOopDesc::base_offset_in_bytes(T_DOUBLE) \\\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1610,3 +1610,0 @@\n-      if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n-        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n-      }\n@@ -1618,1 +1615,0 @@\n-\n@@ -1623,25 +1619,14 @@\n-  \/\/ On some architectures, the use of UseCompressedClassPointers implies the use of\n-  \/\/ UseCompressedOops. The reason is that the rheap_base register of said platforms\n-  \/\/ is reused to perform some optimized spilling, in order to use rheap_base as a\n-  \/\/ temp register. But by treating it as any other temp register, spilling can typically\n-  \/\/ be completely avoided instead. So it is better not to perform this trick. And by\n-  \/\/ not having that reliance, large heaps, or heaps not supporting compressed oops,\n-  \/\/ can still use compressed class pointers.\n-  if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS && !UseCompressedOops) {\n-    if (UseCompressedClassPointers) {\n-      warning(\"UseCompressedClassPointers requires UseCompressedOops\");\n-    }\n-    FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n-  } else {\n-    \/\/ Turn on UseCompressedClassPointers too\n-    if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {\n-      FLAG_SET_ERGO(UseCompressedClassPointers, true);\n-    }\n-    \/\/ Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.\n-    if (UseCompressedClassPointers) {\n-      if (CompressedClassSpaceSize > KlassEncodingMetaspaceMax) {\n-        warning(\"CompressedClassSpaceSize is too large for UseCompressedClassPointers\");\n-        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n-      }\n-    }\n-  }\n+  if (!UseCompressedClassPointers) {\n+    \/\/ Lilliput requires compressed class pointers. Default shall reflect that.\n+    \/\/ If user specifies -UseCompressedClassPointers, it should be reverted with\n+    \/\/ a warning.\n+    assert(!FLAG_IS_DEFAULT(UseCompressedClassPointers), \"Wrong default for UseCompressedClassPointers\");\n+    warning(\"Lilliput reqires compressed class pointers.\");\n+    FLAG_SET_ERGO(UseCompressedClassPointers, true);\n+  }\n+  \/\/ Assert validity of compressed class space size. User arg should have been checked at this point\n+  \/\/ (see CompressedClassSpaceSizeConstraintFunc()), so no need to be nice about it, this fires in\n+  \/\/ case the default is wrong.\n+  assert(CompressedClassSpaceSize <= Metaspace::max_class_space_size(),\n+         \"CompressedClassSpaceSize \" SIZE_FORMAT \" too large (max: \" SIZE_FORMAT \")\",\n+         CompressedClassSpaceSize, Metaspace::max_class_space_size());\n@@ -1810,3 +1795,0 @@\n-          if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n-            FLAG_SET_ERGO(UseCompressedClassPointers, false);\n-          }\n@@ -4211,0 +4193,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":15,"deletions":32,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-  product(bool, UseCompressedClassPointers, false,                          \\\n+  product(bool, UseCompressedClassPointers, true,                           \\\n@@ -1053,1 +1053,1 @@\n-  develop(bool, UseHeavyMonitors, false,                                    \\\n+  product(bool, UseHeavyMonitors, false, DIAGNOSTIC,                        \\\n@@ -1414,1 +1414,1 @@\n-          range(1*M, 3*G)                                                   \\\n+          constraint(CompressedClassSpaceSizeConstraintFunc,AtParse)        \\\n@@ -1416,1 +1416,1 @@\n-  develop(size_t, CompressedClassSpaceBaseAddress, 0,                       \\\n+  product(size_t, CompressedClassSpaceBaseAddress, 0, DIAGNOSTIC,           \\\n@@ -1990,0 +1990,6 @@\n+  product(bool, HeapObjectStats, false, DIAGNOSTIC,                         \\\n+             \"Enable gathering of heap object statistics\")                  \\\n+                                                                            \\\n+  product(size_t, HeapObjectStatsSamplingInterval, 500, DIAGNOSTIC,         \\\n+             \"Heap object statistics sampling interval (ms)\")               \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -603,0 +603,16 @@\n+\/\/ We might access the dead object headers for parsable heap walk, make sure\n+\/\/ headers are in correct shape, e.g. monitors deflated.\n+void ObjectMonitor::maybe_deflate_dead(oop* p) {\n+  oop obj = *p;\n+  assert(obj != NULL, \"must not yet been cleared\");\n+  markWord mark = obj->mark();\n+  if (mark.has_monitor()) {\n+    ObjectMonitor* monitor = mark.monitor();\n+    if (p == monitor->_object.ptr_raw()) {\n+      assert(monitor->object_peek() == obj, \"lock object must match\");\n+      markWord dmw = monitor->header();\n+      obj->set_mark(dmw);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -334,0 +334,2 @@\n+  static void maybe_deflate_dead(oop* p);\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -176,0 +176,2 @@\n+address StubRoutines::_load_nklass = NULL;\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,3 @@\n- public:\n+  static address _load_nklass;\n+\n+public:\n@@ -431,0 +433,2 @@\n+  static address load_nklass()         { return _load_nklass; }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -752,1 +753,1 @@\n-static markWord read_stable_mark(oop obj) {\n+markWord ObjectSynchronizer::read_stable_mark(oop obj) {\n@@ -812,0 +813,67 @@\n+\/\/ Safely load a mark word from an object, even with racing stack-locking or monitor inflation.\n+\/\/ The protocol is a partial inflation-protocol: it installs INFLATING into the object's mark\n+\/\/ word in order to prevent an stack-locks or inflations from interferring (or detect such\n+\/\/ interference and retry), but then, instead of creating and installing a monitor, simply\n+\/\/ read and return the real mark word.\n+markWord ObjectSynchronizer::stable_mark(oop object) {\n+  for (;;) {\n+    const markWord mark = read_stable_mark(object);\n+    assert(!mark.is_being_inflated(), \"read_stable_mark must prevent inflating mark\");\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  Inflated     - just return mark from inflated monitor\n+    \/\/ *  Stack-locked - coerce it to inflating, and then return displaced mark\n+    \/\/ *  Neutral      - return mark\n+    \/\/ *  Marked       - return mark\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      return dmw;\n+    }\n+\n+    \/\/ CASE: stack-locked\n+    \/\/ Could be stack-locked either by this thread or by some other thread.\n+    if (mark.has_locker()) {\n+      BasicLock* lock = mark.locker();\n+      if (Thread::current()->is_lock_owned((address)lock)) {\n+        \/\/ If locked by this thread, it is safe to access the displaced header.\n+        markWord dmw = lock->displaced_header();\n+        assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+        return dmw;\n+      }\n+\n+      \/\/ Otherwise, attempt to temporarily install INFLATING into the mark-word,\n+      \/\/ to prevent inflation or unlocking by competing thread.\n+      markWord cmp = object->cas_set_mark(markWord::INFLATING(), mark);\n+      if (cmp != mark) {\n+        continue;       \/\/ Interference -- just retry\n+      }\n+\n+      \/\/ fetch the displaced mark from the owner's stack.\n+      \/\/ The owner can't die or unwind past the lock while our INFLATING\n+      \/\/ object is in the mark.  Furthermore the owner can't complete\n+      \/\/ an unlock on the object, either.\n+      markWord dmw = mark.displaced_mark_helper();\n+      \/\/ Catch if the object's header is not neutral (not locked and\n+      \/\/ not marked is what we care about here).\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+\n+      \/\/ Must preserve store ordering. The monitor state must\n+      \/\/ be stable at the time of publishing the monitor address.\n+      assert(object->mark() == markWord::INFLATING(), \"invariant\");\n+      \/\/ Release semantics so that above set_object() is seen first.\n+      object->release_set_mark(mark);\n+\n+      return dmw;\n+    }\n+\n+    \/\/ CASE: neutral or marked (for GC)\n+    \/\/ Catch if the object's header is not neutral or marked (it must not be locked).\n+    assert(mark.is_neutral() || mark.is_marked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    return mark;\n+  }\n+}\n+\n@@ -1480,0 +1548,10 @@\n+class VM_RendezvousGCThreads : public VM_Operation {\n+public:\n+  bool evaluate_at_safepoint() const override { return false; }\n+  VMOp_Type type() const override { return VMOp_RendezvousGCThreads; }\n+  void doit() override {\n+    SuspendibleThreadSet::synchronize();\n+    SuspendibleThreadSet::desynchronize();\n+  };\n+};\n+\n@@ -1532,0 +1610,3 @@\n+      \/\/ Also, we sync and desync GC threads around the handshake, so that they can\n+      \/\/ safely read the mark-word and look-through to the object-monitor, without\n+      \/\/ being afraid that the object-monitor is going away.\n@@ -1534,0 +1615,2 @@\n+      VM_RendezvousGCThreads sync_gc;\n+      VMThread::execute(&sync_gc);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":84,"deletions":1,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -184,0 +184,5 @@\n+  \/\/ Read mark-word and spin-wait as long as INFLATING is observed.\n+  static markWord read_stable_mark(oop obj);\n+\n+  static markWord stable_mark(oop obj);\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  template(HeapObjectStatistics)                  \\\n@@ -92,0 +93,1 @@\n+  template(RendezvousGCThreads)                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -202,2 +202,1 @@\n-  volatile_nonstatic_field(oopDesc,            _metadata._klass,                              Klass*)                                \\\n-  volatile_nonstatic_field(oopDesc,            _metadata._compressed_klass,                   narrowKlass)                           \\\n+  NOT_LP64(volatile_nonstatic_field(oopDesc,   _klass,                                        Klass*))                               \\\n@@ -382,2 +381,2 @@\n-     static_field(CompressedKlassPointers,     _narrow_klass._base,                           address)                               \\\n-     static_field(CompressedKlassPointers,     _narrow_klass._shift,                          int)                                   \\\n+     static_field(CompressedKlassPointers,     _base,                           address)                                             \\\n+     static_field(CompressedKlassPointers,     _shift_copy,                          int)                                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"logging\/logTag.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"services\/heapObjectStatistics.hpp\"\n+#include \"utilities\/copy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+HeapObjectStatistics* HeapObjectStatistics::_instance = NULL;\n+\n+class HeapObjectStatsObjectClosure : public ObjectClosure {\n+private:\n+  HeapObjectStatistics* const _stats;\n+public:\n+  HeapObjectStatsObjectClosure() : _stats(HeapObjectStatistics::instance()) {}\n+  void do_object(oop obj) {\n+    _stats->visit_object(obj);\n+  }\n+};\n+\n+class VM_HeapObjectStatistics : public VM_Operation {\n+public:\n+  VMOp_Type type() const { return VMOp_HeapObjectStatistics; }\n+  bool doit_prologue() {\n+    Heap_lock->lock();\n+    return true;\n+  }\n+\n+  void doit_epilogue() {\n+    Heap_lock->unlock();\n+  }\n+\n+  void doit() {\n+    assert(SafepointSynchronize::is_at_safepoint(), \"all threads are stopped\");\n+    assert(Heap_lock->is_locked(), \"should have the Heap_lock\");\n+\n+    CollectedHeap* heap = Universe::heap();\n+    heap->ensure_parsability(false);\n+\n+    HeapObjectStatistics* stats = HeapObjectStatistics::instance();\n+    stats->begin_sample();\n+\n+    HeapObjectStatsObjectClosure cl;\n+    heap->object_iterate(&cl);\n+  }\n+};\n+\n+HeapObjectStatisticsTask::HeapObjectStatisticsTask() : PeriodicTask(HeapObjectStatsSamplingInterval) {}\n+\n+void HeapObjectStatisticsTask::task() {\n+  VM_HeapObjectStatistics vmop;\n+  VMThread::execute(&vmop);\n+}\n+\n+void HeapObjectStatistics::initialize() {\n+  assert(_instance == NULL, \"Don't init twice\");\n+  if (HeapObjectStats) {\n+    _instance = new HeapObjectStatistics();\n+    _instance->start();\n+  }\n+}\n+\n+void HeapObjectStatistics::shutdown() {\n+  if (HeapObjectStats) {\n+    assert(_instance != NULL, \"Must be initialized\");\n+    LogTarget(Info, heap, stats) lt;\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ResourceMark rm;\n+      _instance->print(&ls);\n+    }\n+    _instance->stop();\n+    delete _instance;\n+    _instance = NULL;\n+  }\n+}\n+\n+HeapObjectStatistics* HeapObjectStatistics::instance() {\n+  assert(_instance != NULL, \"Must be initialized\");\n+  return _instance;\n+}\n+\n+void HeapObjectStatistics::increase_counter(uint64_t& counter, uint64_t val) {\n+  uint64_t oldval = counter;\n+  uint64_t newval = counter + val;\n+  if (newval < oldval) {\n+    log_warning(heap, stats)(\"HeapObjectStats counter overflow: resulting statistics will be useless\");\n+  }\n+  counter = newval;\n+}\n+\n+HeapObjectStatistics::HeapObjectStatistics() :\n+  _task(), _num_samples(0), _num_objects(0), _num_ihashed(0), _num_locked(0), _lds(0) { }\n+\n+void HeapObjectStatistics::start() {\n+  _task.enroll();\n+}\n+\n+void HeapObjectStatistics::stop() {\n+  _task.disenroll();\n+}\n+\n+void HeapObjectStatistics::begin_sample() {\n+  _num_samples++;\n+}\n+\n+void HeapObjectStatistics::visit_object(oop obj) {\n+  increase_counter(_num_objects);\n+  markWord mark = obj->mark();\n+  if (!mark.has_no_hash()) {\n+    increase_counter(_num_ihashed);\n+    if (mark.age() > 0) {\n+      increase_counter(_num_ihashed_moved);\n+    }\n+  }\n+  if (mark.is_locked()) {\n+    increase_counter(_num_locked);\n+  }\n+#ifdef ASSERT\n+#ifdef _LP64\n+  if (!mark.has_displaced_mark_helper()) {\n+    assert(mark.narrow_klass() == CompressedKlassPointers::encode(obj->klass_or_null()), \"upper 32 mark bits must be narrow klass: mark: \" INTPTR_FORMAT \", compressed-klass: \" INTPTR_FORMAT, (intptr_t)mark.narrow_klass(), (intptr_t)CompressedKlassPointers::encode(obj->klass_or_null()));\n+  }\n+#endif\n+#endif\n+  increase_counter(_lds, obj->size());\n+}\n+\n+void HeapObjectStatistics::print(outputStream* out) const {\n+  if (!HeapObjectStats) {\n+    return;\n+  }\n+  if (_num_samples == 0 || _num_objects == 0) {\n+    return;\n+  }\n+\n+  out->print_cr(\"Number of samples:  \" UINT64_FORMAT, _num_samples);\n+  out->print_cr(\"Average number of objects: \" UINT64_FORMAT, _num_objects \/ _num_samples);\n+  out->print_cr(\"Average object size: \" UINT64_FORMAT \" bytes, %.1f words\", (_lds * HeapWordSize) \/ _num_objects, (float) _lds \/ _num_objects);\n+  out->print_cr(\"Average number of hashed objects: \" UINT64_FORMAT \" (%.2f%%)\", _num_ihashed \/ _num_samples, (float) (_num_ihashed * 100.0) \/ _num_objects);\n+  out->print_cr(\"Average number of moved hashed objects: \" UINT64_FORMAT \" (%.2f%%)\", _num_ihashed_moved \/ _num_samples, (float) (_num_ihashed_moved * 100.0) \/ _num_objects);\n+  out->print_cr(\"Average number of locked objects: \" UINT64_FORMAT \" (%.2f%%)\", _num_locked \/ _num_samples, (float) (_num_locked * 100) \/ _num_objects);\n+  out->print_cr(\"Average LDS: \" UINT64_FORMAT \" bytes\", _lds * HeapWordSize \/ _num_samples);\n+  out->print_cr(\"Avg LDS with (assumed) 64bit header: \" UINT64_FORMAT \" bytes (%.1f%%)\", (_lds - _num_objects) * HeapWordSize \/ _num_samples, ((float) _lds - _num_objects) * 100.0 \/ _lds);\n+}\n","filename":"src\/hotspot\/share\/services\/heapObjectStatistics.cpp","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_HEAPOBJECTSTATISTICS_HPP\n+#define SHARE_SERVICES_HEAPOBJECTSTATISTICS_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/task.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+\n+class outputStream;\n+\n+class HeapObjectStatisticsTask : public PeriodicTask {\n+public:\n+  HeapObjectStatisticsTask();\n+  void task();\n+};\n+\n+class HeapObjectStatistics : public CHeapObj<mtGC> {\n+private:\n+  static HeapObjectStatistics* _instance;\n+\n+  HeapObjectStatisticsTask _task;\n+  uint64_t _num_samples;\n+  uint64_t _num_objects;\n+  uint64_t _num_ihashed;\n+  uint64_t _num_ihashed_moved;\n+  uint64_t _num_locked;\n+  uint64_t _lds;\n+\n+  static void increase_counter(uint64_t& counter, uint64_t val = 1);\n+\n+  void print(outputStream* out) const;\n+\n+public:\n+  static void initialize();\n+  static void shutdown();\n+\n+  static HeapObjectStatistics* instance();\n+\n+  HeapObjectStatistics();\n+  void start();\n+  void stop();\n+\n+  void begin_sample();\n+  void visit_object(oop object);\n+};\n+\n+#endif \/\/ SHARE_SERVICES_HEAPOBJECTSTATISTICS_HPP\n","filename":"src\/hotspot\/share\/services\/heapObjectStatistics.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -581,5 +581,0 @@\n-const int LogKlassAlignmentInBytes = 3;\n-const int LogKlassAlignment        = LogKlassAlignmentInBytes - LogHeapWordSize;\n-const int KlassAlignmentInBytes    = 1 << LogKlassAlignmentInBytes;\n-const int KlassAlignment           = KlassAlignmentInBytes \/ HeapWordSize;\n-\n@@ -593,5 +588,0 @@\n-\/\/ Maximal size of compressed class space. Above this limit compression is not possible.\n-\/\/ Also upper bound for placement of zero based class space. (Class space is further limited\n-\/\/ to be < 3G, see arguments.cpp.)\n-const  uint64_t KlassEncodingMetaspaceMax = (uint64_t(max_juint) + 1) << LogKlassAlignmentInBytes;\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -398,0 +398,5 @@\n+    \/\/ Todo: Lilliput: this is a hack. The real problem is the assumption that size\n+    \/\/  of a narrow Klass pointer can be expressed in number of bytes (getKlassPtrSize).\n+    \/\/  That assumption is present in a number of files here. Better would be\n+    \/\/  to change this to getKlassPtrSizeInBits, or to do it some other way.\n+    value &= (1 << 22) - 1; \/\/ narrow klass pointer size is 22 bits.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerBase.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    baseField = type.getAddressField(\"_narrow_klass._base\");\n-    shiftField = type.getCIntegerField(\"_narrow_klass._shift\");\n+    baseField = type.getAddressField(\"_base\");\n+    shiftField = type.getCIntegerField(\"_shift_copy\");\n@@ -72,0 +72,1 @@\n+        System.out.println(\"base: \" + baseField.getValue().minus(null));\n@@ -77,1 +78,3 @@\n-    return (int)shiftField.getValue();\n+\n+      System.out.println(\"shift: \" + (int)shiftField.getValue());\n+      return (int)shiftField.getValue();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/CompressedKlassPointers.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -76,1 +76,2 @@\n-    final int hubOffset = getFieldOffset(\"oopDesc::_metadata._klass\", Integer.class, \"Klass*\");\n+    \/\/ TODO: Lilliput. Probably ok.\n+    final int hubOffset = 4; \/\/ getFieldOffset(\"oopDesc::_metadata._klass\", Integer.class, \"Klass*\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  static markWord originalMark() { return markWord(markWord::lock_mask_in_place); }\n+  static markWord originalMark() { return markWord(markWord::unlocked_value); }\n@@ -81,0 +81,3 @@\n+  \/\/ TODO: This is the only use of PM::adjust_during_full_gc().\n+  \/\/ GCs use the variant with a forwarding structure here,\n+  \/\/ test that variant, and remove the method.\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -53,5 +54,0 @@\n-\/\/ See metaspaceArena.cpp : needed for predicting commit sizes.\n-namespace metaspace {\n-  extern size_t get_raw_word_size_for_requested_word_size(size_t net_word_size);\n-}\n-\n@@ -65,0 +61,1 @@\n+  int _alignment_words;\n@@ -67,1 +64,2 @@\n-  void initialize(const ArenaGrowthPolicy* growth_policy, const char* name = \"gtest-MetaspaceArena\") {\n+  void initialize(const ArenaGrowthPolicy* growth_policy, int alignment_words,\n+                  const char* name = \"gtest-MetaspaceArena\") {\n@@ -74,1 +72,1 @@\n-      _arena = new MetaspaceArena(&_context.cm(), _growth_policy, _lock, &_used_words_counter, name);\n+      _arena = new MetaspaceArena(&_context.cm(), _growth_policy, alignment_words, _lock, &_used_words_counter, name);\n@@ -88,1 +86,1 @@\n-    initialize(ArenaGrowthPolicy::policy_for_space_type(space_type, is_class), name);\n+    initialize(ArenaGrowthPolicy::policy_for_space_type(space_type, is_class), metaspace::MetaspaceMinAlignmentWords, name);\n@@ -96,1 +94,1 @@\n-    initialize(growth_policy, name);\n+    initialize(growth_policy, metaspace::MetaspaceMinAlignmentWords, name);\n@@ -284,1 +282,1 @@\n-    allocated += metaspace::get_raw_word_size_for_requested_word_size(s);\n+    allocated += metaspace::get_raw_word_size_for_requested_word_size(s, metaspace::MetaspaceMinAlignmentWords);\n@@ -341,1 +339,1 @@\n-    allocated += metaspace::get_raw_word_size_for_requested_word_size(s);\n+    allocated += metaspace::get_raw_word_size_for_requested_word_size(s, metaspace::MetaspaceMinAlignmentWords);\n@@ -598,1 +596,1 @@\n-    words_allocated += metaspace::get_raw_word_size_for_requested_word_size(alloc_words);\n+    words_allocated += metaspace::get_raw_word_size_for_requested_word_size(alloc_words, metaspace::MetaspaceMinAlignmentWords);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -55,5 +56,0 @@\n-\/\/ See metaspaceArena.cpp : needed for predicting commit sizes.\n-namespace metaspace {\n-  extern size_t get_raw_word_size_for_requested_word_size(size_t net_word_size);\n-}\n-\n@@ -64,1 +60,2 @@\n-  MetaspaceArena* _arena;\n+  const SizeRange _allocation_range;\n+  const int _alignment_words;\n@@ -66,0 +63,1 @@\n+  MetaspaceArena* _arena;\n@@ -67,2 +65,0 @@\n-\n-  const SizeRange _allocation_range;\n@@ -90,1 +86,2 @@\n-  MemRangeCounter _alloc_count;\n+  MemRangeCounter _alloc_count_net; \/\/ net used bytes\n+  MemRangeCounter _alloc_count_raw; \/\/ net used bytes + internal overhead\n@@ -102,2 +99,2 @@\n-    assert(_dealloc_count.total_size() <= _alloc_count.total_size() &&\n-           _dealloc_count.count() <= _alloc_count.count(), \"Sanity\");\n+    assert(_dealloc_count.total_size() <= _alloc_count_net.total_size() &&\n+           _dealloc_count.count() <= _alloc_count_net.count(), \"Sanity\");\n@@ -119,1 +116,1 @@\n-    const size_t at_least_allocated = _alloc_count.total_size() - _dealloc_count.total_size();\n+    const size_t at_least_allocated = _alloc_count_net.total_size() - _dealloc_count.total_size();\n@@ -122,3 +119,6 @@\n-    const size_t max_word_overhead_per_alloc =\n-        4 + (metaspace::Settings::use_allocation_guard() ? 4 : 0);\n-    const size_t at_most_allocated = _alloc_count.total_size() + max_word_overhead_per_alloc * _alloc_count.count();\n+    size_t max_word_overhead_per_alloc = align_up(4, _alignment_words);\n+    \/\/ Guard fences come as a separate, secondary block\n+    if (metaspace::Settings::use_allocation_guard()) {\n+      max_word_overhead_per_alloc *= 2;\n+    }\n+    const size_t at_most_allocated = _alloc_count_raw.total_size() + max_word_overhead_per_alloc * _alloc_count_raw.count();\n@@ -128,1 +128,0 @@\n-\n@@ -135,1 +134,1 @@\n-  MetaspaceArenaTestBed(ChunkManager* cm, const ArenaGrowthPolicy* alloc_sequence,\n+  MetaspaceArenaTestBed(ChunkManager* cm, const ArenaGrowthPolicy* alloc_sequence, int alignment_words,\n@@ -137,0 +136,2 @@\n+    _allocation_range(allocation_range),\n+    _alignment_words(alignment_words),\n@@ -139,1 +140,0 @@\n-    _allocation_range(allocation_range),\n@@ -142,1 +142,1 @@\n-    _alloc_count(),\n+    _alloc_count_net(),\n@@ -149,1 +149,1 @@\n-    _arena = new MetaspaceArena(cm, alloc_sequence, _lock, used_words_counter, \"gtest-MetaspaceArenaTestBed-sm\");\n+    _arena = new MetaspaceArena(cm, alloc_sequence, alignment_words, _lock, used_words_counter, \"gtest-MetaspaceArenaTestBed-sm\");\n@@ -172,2 +172,2 @@\n-  size_t words_allocated() const        { return _alloc_count.total_size(); }\n-  int num_allocations() const           { return _alloc_count.count(); }\n+  size_t words_allocated() const        { return _alloc_count_net.total_size(); }\n+  int num_allocations() const           { return _alloc_count_net.count(); }\n@@ -177,0 +177,4 @@\n+  size_t calc_expected_usage_for_allocated_words(size_t word_size) {\n+    return metaspace::get_raw_word_size_for_requested_word_size(word_size, _alignment_words);\n+  }\n+\n@@ -182,1 +186,1 @@\n-      EXPECT_TRUE(is_aligned(p, sizeof(MetaWord)));\n+      EXPECT_TRUE(is_aligned(p, _alignment_words * BytesPerWord));\n@@ -189,2 +193,3 @@\n-      _alloc_count.add(word_size);\n-      if ((_alloc_count.count() % 20) == 0) {\n+      _alloc_count_net.add(word_size);\n+      _alloc_count_raw.add(calc_expected_usage_for_allocated_words(word_size));\n+      if ((_alloc_count_net.count() % 20) == 0) {\n@@ -232,1 +237,1 @@\n-  void create_new_test_bed_at(int slotindex, const ArenaGrowthPolicy* growth_policy, SizeRange allocation_range) {\n+  void create_new_test_bed_at(int slotindex, const ArenaGrowthPolicy* growth_policy, int alignment_words, SizeRange allocation_range) {\n@@ -234,1 +239,1 @@\n-    MetaspaceArenaTestBed* bed = new MetaspaceArenaTestBed(&_context.cm(), growth_policy,\n+    MetaspaceArenaTestBed* bed = new MetaspaceArenaTestBed(&_context.cm(), growth_policy, alignment_words,\n@@ -245,1 +250,4 @@\n-    create_new_test_bed_at(slotindex, growth_policy, allocation_range);\n+    const int alignment_bytes =\n+        1 << IntRange(metaspace::LogMetaspaceMinimalAlignment,\n+                      metaspace::LogMetaspaceMinimalAlignment + 7).random_value(); \/\/ zw 8 byte and 1K\n+    create_new_test_bed_at(slotindex, growth_policy, alignment_bytes \/ BytesPerWord, allocation_range);\n@@ -258,9 +266,0 @@\n-  \/\/ Create test beds for all slots\n-  void create_all_test_beds() {\n-    for (int slot = 0; slot < _testbeds.size(); slot++) {\n-      if (_testbeds.slot_is_null(slot)) {\n-        create_random_test_bed_at(slot);\n-      }\n-    }\n-  }\n-\n@@ -302,1 +301,1 @@\n-                metaspace::get_raw_word_size_for_requested_word_size(bed->size_of_last_failed_allocation()));\n+                bed->calc_expected_usage_for_allocated_words(bed->size_of_last_failed_allocation()));\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":37,"deletions":38,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#ifndef _LP64\n@@ -40,0 +41,1 @@\n+#endif\n","filename":"test\/hotspot\/gtest\/oops\/test_typeArrayOop.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -126,0 +126,34 @@\n+# Missing Lilliput support to load Klass*\n+serviceability\/sa\/CDSJMapClstats.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbCDSCore.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbCDSJstackPrintAll.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbDumpheap.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-core\n+serviceability\/sa\/ClhsdbFindPC.java#no-xcomp-process\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-core\n+serviceability\/sa\/ClhsdbFindPC.java#xcomp-process\n+serviceability\/sa\/ClhsdbInspect.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbJdis.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbJhisto.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id0 1234567 generic-all\n+serviceability\/sa\/ClhsdbJstack.java#id1 1234567 generic-all\n+serviceability\/sa\/ClhsdbPrintAs.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbPstack.java#core 1234567 generic-all\n+serviceability\/sa\/ClhsdbPstack.java#process 1234567 generic-all\n+serviceability\/sa\/ClhsdbSource.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbThread.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbThreadContext.java 1234567 generic-all\n+serviceability\/sa\/ClhsdbWhere.java 1234567 generic-all\n+serviceability\/sa\/DeadlockDetectionTest.java 1234567 generic-all\n+serviceability\/sa\/JhsdbThreadInfoTest.java 1234567 generic-all\n+serviceability\/sa\/TestClhsdbJstackLock.java 1234567 generic-all\n+serviceability\/sa\/TestHeapDumpForInvokeDynamic.java 1234567 generic-all\n+serviceability\/sa\/TestJhsdbJstackLineNumbers.java 1234567 generic-all\n+serviceability\/sa\/TestJhsdbJstackLock.java 1234567 generic-all\n+serviceability\/sa\/TestJhsdbJstackMixed.java 1234567 generic-all\n+serviceability\/sa\/TestObjectMonitorIterate.java 1234567 generic-all\n+serviceability\/sa\/TestSysProps.java 1234567 generic-all\n+serviceability\/sa\/jmap-hprof\/JMapHProfLargeHeapTest.java 1234567 generic-all\n+serviceability\/sa\/sadebugd\/DebugdConnectTest.java 1234567 generic-all\n+serviceability\/sa\/sadebugd\/DisableRegistryTest.java 1234567 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+TieredCompilation -XX:TieredStopAtLevel=1 -Xcomp -XX:-UseCompressedClassPointers -XX:CompileOnly=TestArrayCopyToFromObject.test TestArrayCopyToFromObject\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestArrayCopyToFromObject.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-    public static final String LOAD_KLASS  = START + \"LoadK\" + MID + END;\n+    public static final String LOAD_KLASS  = START + \"LoadN?K\" + MID + END;\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,5 +36,0 @@\n- *                                 -XX:+UseCompressedOops -XX:-UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n@@ -43,5 +38,0 @@\n- *                                 compiler.unsafe.OpaqueAccesses\n- * @run main\/bootclasspath\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions\n- *                                 -XX:-TieredCompilation -Xbatch\n- *                                 -XX:-UseCompressedOops -XX:-UseCompressedClassPointers\n- *                                 -XX:CompileCommand=dontinline,compiler.unsafe.OpaqueAccesses::test*\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/OpaqueAccesses.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.arguments;\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Platform;\n-\n-\/*\n- * @test\n- * @bug 8015107\n- * @summary Tests that VM prints a warning when -XX:CompressedClassSpaceSize\n- *          is used together with -XX:-UseCompressedClassPointers\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver gc.arguments.TestCompressedClassFlags\n- *\/\n-public class TestCompressedClassFlags {\n-    public static void main(String[] args) throws Exception {\n-        if (Platform.is64bit()) {\n-            OutputAnalyzer output = runJava(\"-XX:CompressedClassSpaceSize=1g\",\n-                                            \"-XX:-UseCompressedClassPointers\",\n-                                            \"-version\");\n-            output.shouldContain(\"warning\");\n-            output.shouldNotContain(\"error\");\n-            output.shouldHaveExitValue(0);\n-        }\n-    }\n-\n-    private static OutputAnalyzer runJava(String ... args) throws Exception {\n-        ProcessBuilder pb = GCArguments.createJavaProcessBuilder(args);\n-        return new OutputAnalyzer(pb.start());\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestCompressedClassFlags.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -129,1 +129,3 @@\n-    String compressedClassSpaceSizeArg = \"-XX:CompressedClassSpaceSize=\" + 2 * getCompressedClassSpaceSize();\n+    \/\/ Lilliput: do not assume a max. class space size, since that is subject to change. Instead, use a value slightly smaller\n+    \/\/  than what the parent VM runs with (which is the default size).\n+    String compressedClassSpaceSizeArg = \"-XX:CompressedClassSpaceSize=\" + (getCompressedClassSpaceSize() - 1);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsErgoTools.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        dump_args.addAll(Arrays.asList(new String[] { \"-Xshare:dump\", \"-Xlog:cds\" }));\n+        dump_args.addAll(Arrays.asList(new String[] { \"-Xshare:dump\", \"-Xlog:cds*\", \"-Xlog:metaspace*\" }));\n@@ -64,0 +64,1 @@\n+        output.reportDiagnosticSummary();\n@@ -73,1 +74,1 @@\n-            load_args.addAll(Arrays.asList(new String[] { \"-Xshare:on\", \"-version\" }));\n+            load_args.addAll(Arrays.asList(new String[] { \"-Xshare:on\", \"-Xlog:cds*\", \"-Xlog:metaspace*\", \"-version\" }));\n@@ -77,0 +78,1 @@\n+            output.reportDiagnosticSummary();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestSharedArchiveWithPreTouch.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.test.lib.Platform;\n@@ -75,1 +76,1 @@\n-    private static final int OBJECT_SIZE_HIGH = 3250;\n+    private static final int OBJECT_SIZE_HIGH = Platform.is64bit() ? 3266 : 3258;\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABPromotion.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-        return Platform.is64bit() && InputArguments.contains(\"-XX:+UseCompressedClassPointers\");\n+        return Platform.is64bit();\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/TestMetaspacePerfCounters.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n- * @run driver gc.metaspace.TestSizeTransitions false -XX:+UseSerialGC\n- * @run driver gc.metaspace.TestSizeTransitions true  -XX:+UseSerialGC\n+ * @run driver gc.metaspace.TestSizeTransitions -XX:+UseSerialGC\n@@ -46,2 +45,1 @@\n- * @run driver gc.metaspace.TestSizeTransitions false -XX:+UseParallelGC\n- * @run driver gc.metaspace.TestSizeTransitions true  -XX:+UseParallelGC\n+ * @run driver gc.metaspace.TestSizeTransitions -XX:+UseParallelGC\n@@ -54,2 +52,1 @@\n- * @run driver gc.metaspace.TestSizeTransitions false -XX:+UseG1GC\n- * @run driver gc.metaspace.TestSizeTransitions true  -XX:+UseG1GC\n+ * @run driver gc.metaspace.TestSizeTransitions -XX:+UseG1GC\n@@ -93,2 +90,2 @@\n-    \/\/ args: <use-coops> <gc-arg>\n-    if (args.length != 2) {\n+    \/\/ args: <gc-arg>\n+    if (args.length != 1) {\n@@ -99,8 +96,1 @@\n-    final boolean useCompressedKlassPointers = Boolean.parseBoolean(args[0]);\n-    final String gcArg = args[1];\n-\n-    if (!hasCompressedKlassPointers && useCompressedKlassPointers) {\n-       \/\/ No need to run this configuration.\n-       System.out.println(\"Skipping test.\");\n-       return;\n-    }\n+    final String gcArg = args[0];\n@@ -109,3 +99,0 @@\n-    if (hasCompressedKlassPointers) {\n-      jvmArgs.add(useCompressedKlassPointers ? \"-XX:+UseCompressedClassPointers\" : \"-XX:-UseCompressedClassPointers\");\n-    }\n@@ -127,1 +114,1 @@\n-    if (useCompressedKlassPointers) {\n+    if (hasCompressedKlassPointers) {\n","filename":"test\/hotspot\/jtreg\/gc\/metaspace\/TestSizeTransitions.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n- *   -Xmx1G -XX:G1HeapRegionSize=8m -XX:MaxGCPauseMillis=1000 gc.stress.TestMultiThreadStressRSet 60 16\n+ *   -Xmx1100M -XX:G1HeapRegionSize=8m -XX:MaxGCPauseMillis=1000 gc.stress.TestMultiThreadStressRSet 60 16\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/TestMultiThreadStressRSet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,11 +30,0 @@\n-\n-\/* @test\n- * @bug 8264008\n- * @summary Run metaspace utils related gtests with compressed class pointers off\n- * @requires vm.bits == 64\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.xml\n- * @requires vm.flagless\n- * @run main\/native GTestWrapper --gtest_filter=MetaspaceUtils* -XX:-UseCompressedClassPointers\n- *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/MetaspaceUtilsGtests.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ These tests test that narrow Klass pointer encoding\/decoding work.\n+\/\/\n+\/\/ Note that we do not enforce the encoding base directly. We enforce base and size of the compressed class space.\n+\/\/ The hotspot then decides on the best encoding range and scheme to chose for the given range.\n+\/\/\n+\/\/ So what we really test here is that for a given range-to-encode:\n+\/\/  - the chosen encoding range and architecture-specific mode makes sense - e.g. if range fits into low address\n+\/\/    space, use base=0 and zero-based encoding.\n+\/\/  - and that the chosen encoding actually works by starting a simple program which loads a bunch of classes.\n+\/\/\n+\/\/  In order for that to work, we have to switch of CDS. Switching off CDS means the hotspot choses the encoding base\n+\/\/  based on the class space base address (we just know this - see CompressedKlassPointers::initialize() - and if this\n+\/\/  changes, we may have to adapt this test).\n+\/\/\n+\/\/  Switching off CDS also means we use the class space much more fully. More Klass structures stored in that range\n+\/\/  and we exercise the ability of Metaspace to allocate Klass structures with the correct alignment, compatible to\n+\/\/  encoding.\n+\n+\/*\n+ * @test id=x64-area-beyond-encoding-range-use-xor\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class CompressedClassPointerEncoding {\n+\n+    \/\/ Replace:\n+    \/\/ $1 with force base address\n+    \/\/ $2 with compressed class space size\n+    final static String[] vmOptionsTemplate = new String[] {\n+      \"-XX:CompressedClassSpaceBaseAddress=$1\",\n+      \"-XX:CompressedClassSpaceSize=$2\",\n+      \"-Xshare:off\",                         \/\/ Disable CDS\n+      \"-Xlog:metaspace*\",                    \/\/ for analysis\n+      \"-XX:+PrintMetaspaceStatisticsAtExit\", \/\/ for analysis\n+      \"-version\"\n+    };\n+\n+    \/\/ Replace:\n+    \/\/ $1 with expected ccs base address (extended hex printed)\n+    \/\/ $2 with expected encoding base (extended hex printed)\n+    \/\/ $3 with expected encoding shift\n+    \/\/ $4 with expected encoding range\n+    \/\/ $5 with expected encoding mode\n+    final String[] expectedOutputTemplate = new String[] {\n+            \".*Sucessfully forced class space address to $1.*\",\n+            \".*CDS archive(s) not mapped.*\",\n+            \".*Narrow klass base: $2, Narrow klass shift: $3, Narrow klass range: $4, Encoding mode $5.*\"\n+    };\n+\n+    final static long M = 1024 * 1024;\n+    final static long G = 1024 * M;\n+\n+    final static long expectedShift = 9;\n+    final static long expectedEncodingRange = 2 * G;\n+    final static long defaultCCSSize = 32 * M;\n+\n+    enum EPlatform {\n+        \/\/ Add more where needed\n+        \/\/ (Note: this would be useful in Platform.java)\n+        linux_aarch64,\n+        linux_x64,\n+        unknown\n+    };\n+\n+    static EPlatform getCurrentPlatform() {\n+        if (Platform.isAArch64() && Platform.isLinux()) {\n+            return EPlatform.linux_aarch64;\n+        } else if (Platform.isX64() && Platform.isLinux()) {\n+            return EPlatform.linux_x64;\n+        }\n+        return EPlatform.unknown;\n+    }\n+\n+    static class TestDetails {\n+        public final EPlatform platform;\n+        public final String name;\n+        public final long[] baseAdressesToTry;\n+        public final long compressedClassSpaceSize;\n+        public final long expectedEncodingBase;\n+        public final String expectedEncodingMode;\n+\n+        public TestDetails(EPlatform platform, String name, long[] baseAdressesToTry,\n+                           long compressedClassSpaceSize, long expectedEncodingBase, String expectedEncodingMode) {\n+            this.platform = platform;\n+            this.name = name;\n+            this.baseAdressesToTry = baseAdressesToTry;\n+            this.compressedClassSpaceSize = compressedClassSpaceSize;\n+            this.expectedEncodingBase = expectedEncodingBase;\n+            this.expectedEncodingMode = expectedEncodingMode;\n+        }\n+\n+        \/\/ Simplified, common version: one base address (which we assume always works) and 32G ccs size\n+        public TestDetails(EPlatform platform, String name, long baseAdress,\n+                           long expectedEncodingBase, String expectedEncodingMode) {\n+            this(platform, name, new long[]{ baseAdress }, defaultCCSSize,\n+                 expectedEncodingBase, expectedEncodingMode);\n+        }\n+    };\n+\n+    static TestDetails[] testDetails = new TestDetails[] {\n+\n+            \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+            \/\/\/\/\/\/ x64 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+            \/\/ CCS base beyond encoding range (base=2G). Base does does not intersect the uncompressed klass pointer\n+            \/\/ bits. Encoding cannot be zero, and we should use xor+shift mode.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-beyond-encoding-range-use-xor\",\n+                    2 * G,\n+                    2 * G,\n+                    \"xor\"),\n+\n+            \/\/ CCS partly contained in encoding range. We cannot use zero based encoding. We cannot use xor either,\n+            \/\/ since the first part of the ccs intersects the encoding range. Encoding hould use add+shift.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-partly-within-encoding-range-use-add\",\n+                    0x7fc00000,\n+                    2 * G,\n+                    \"add\"),\n+\n+            \/\/ CCS (just) fully contained in encoding range (base=2G-ccs size). Expect zero-based encoding.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-within-encoding-range-use-zero\",\n+                    0x7e000000, \/\/ 2G - 32M (ccs size)\n+                    0,\n+                    \"zero\"),\n+\n+            \/\/ CCS located far beyond the zero-based limit. Base does not intersect with narrow Klass pointer bits.\n+            \/\/ We should use xor.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-far-out-no-low-bits-use-xor\",\n+                    0x800000000L, \/\/ 32G\n+                    0x800000000L,\n+                    \"xor\"),\n+\n+            \/\/ CCS located far beyond the zero-based limit. Base address intersects with narrow Klass pointer bits.\n+            \/\/ We should use add.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-far-out-with-low-bits-use-add\",\n+                    0x800800000L, \/\/ 32G + 8M (4M is minimum ccs alignment)\n+                    0x800800000L,\n+                    \"xor\"),\n+\n+            \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+            \/\/\/\/\/\/ aarch64 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\n+            \/\/ CCS with a base which is a valid immediate, does not intersect the uncompressed klass pointer bits,\n+            \/\/ should use xor+shift\n+            new TestDetails(EPlatform.linux_aarch64,\n+                    \"aarch64-area-beyond-encoding-range-base-valid-immediate-use-xor\",\n+                    0x800000000L, \/\/ 32G\n+                    800000000L,\n+                    \"xor\")\n+\n+            \/\/ ... add more\n+\n+    };\n+\n+    \/\/ Helper function. Given a string, replace $1 ... $n with\n+    \/\/ replacement_strings[0] ... replacement_strings[n]\n+    static private String replacePlaceholdersInString(String original, String ...replacement_strings) {\n+        String result = original;\n+        int repl_id = 1; \/\/ 1 based\n+        for (String replacement : replacement_strings) {\n+            String placeholder = \"$\" + repl_id;\n+            result = result.replace(placeholder, replacement);\n+            repl_id ++;\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Helper function. Given a string array, replace $1 ... $n with\n+    \/\/ replacement_strings[0] ... replacement_strings[n]\n+    static private String[] replacePlaceholdersInArray(String[] original, String ...replacement_strings) {\n+        String[] copy = new String[original.length];\n+        for (int n = 0; n < copy.length; n ++) {\n+            copy[n] = replacePlaceholdersInString(original[n], replacement_strings);\n+        }\n+        return copy;\n+    }\n+\n+    static void runTest(TestDetails details) throws IOException {\n+        System.err.println(\"----------------------------------------------------\");\n+        System.err.println(\"Running Test: \" + details.name);\n+        System.err.println(details);\n+\n+        long ccsBaseAddress = details.baseAdressesToTry[0];\n+        String ccsBaseAddressAsHex = String.format(\"0x%016x\", ccsBaseAddress);\n+\n+        \/\/ VM Options: replace:\n+        \/\/ $1 with force base address\n+        \/\/ $2 with compressed class space size\n+        String[] vmOptions = replacePlaceholdersInArray(vmOptionsTemplate,\n+                ccsBaseAddressAsHex,              \/\/ $1\n+                (details.compressedClassSpaceSize \/ M) + \"M\");    \/\/ $2\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(vmOptions);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        System.err.println(\"----------------------------------------------------\");\n+        System.err.println(Arrays.toString(vmOptions));\n+        output.reportDiagnosticSummary();\n+        System.err.println(\"----------------------------------------------------\");\n+\n+        output.shouldHaveExitValue(0);\n+\n+    }\n+\n+    static void runTestsForPlatform(EPlatform platform) throws IOException {\n+        for (TestDetails details : testDetails) {\n+            if (details.platform == platform) {\n+                runTest(details);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTestsForPlatform(getCurrentPlatform());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointerEncoding.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -57,0 +57,3 @@\n+    \/* Lilliput: cannot work due to drastically reduced narrow klass pointer range (atm 2g and that may get\n+       smaller still). There is an argument for improving CDS\/CCS reservation and make it more likely to run\n+       zero-based, but that logic has to be rethought.\n@@ -71,0 +74,1 @@\n+     *\/\n@@ -74,0 +78,1 @@\n+    \/* Lilliput: See comment above.\n@@ -88,0 +93,1 @@\n+    *\/\n@@ -92,0 +98,2 @@\n+    \/* Lilliput: I am not sure what the point of this test CCS reservation is independent from\n+       heap. See below the desparate attempts to predict heap reservation on PPC. Why do we even care?\n@@ -112,0 +120,1 @@\n+     *\/\n@@ -117,0 +126,1 @@\n+    \/* Lilliput: narrow klass pointer range drastically reduced. See comments under smallHeapTest().\n@@ -136,0 +146,1 @@\n+    *\/\n@@ -138,0 +149,4 @@\n+    \/* Lilliput: not sure what the point of this test is. The ability to have a class space if heap uses\n+       large pages? Why would that be a problem? Kept alive for now since it makes no problems even with\n+       smaller class pointers.\n+     *\/\n@@ -198,0 +213,1 @@\n+    \/* Lilliput: narrow klass pointer range drastically reduced. See comments under smallHeapTest().\n@@ -213,0 +229,1 @@\n+    *\/\n@@ -214,0 +231,1 @@\n+    \/* Lilliput: narrow klass pointer range drastically reduced. See comments under smallHeapTest().\n@@ -233,0 +251,1 @@\n+    *\/\n@@ -234,0 +253,1 @@\n+    \/* Lilliput: narrow klass pointer range drastically reduced. See comments under smallHeapTest().\n@@ -253,0 +273,1 @@\n+    *\/\n@@ -321,4 +342,4 @@\n-        smallHeapTest();\n-        smallHeapTestWith1G();\n-        largeHeapTest();\n-        largeHeapAbove32GTest();\n+        \/\/ smallHeapTest();\n+        \/\/ smallHeapTestWith1G();\n+        \/\/ largeHeapTest();\n+        \/\/ largeHeapAbove32GTest();\n@@ -336,3 +357,3 @@\n-            smallHeapTestNoCoop();\n-            smallHeapTestWith1GNoCoop();\n-            largeHeapTestNoCoop();\n+            \/\/ smallHeapTestNoCoop();\n+            \/\/ smallHeapTestWith1GNoCoop();\n+            \/\/ largeHeapTestNoCoop();\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointers.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -41,0 +41,7 @@\n+    \/\/ Sizes beyond this will be rejected by hotspot arg parsing\n+    \/\/ (Lilliput: see Metaspace::max_class_space_size() for details)\n+    static final long max_class_space_size = 2013265920;\n+\n+    \/\/ Below this size class space will be silently enlarged to a multiple of this size\n+    static final long min_class_space_size = 4194304;\n+\n@@ -44,6 +51,0 @@\n-        \/\/ Minimum size is 1MB\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:CompressedClassSpaceSize=0\",\n-                                                   \"-version\");\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"outside the allowed range\")\n-              .shouldHaveExitValue(1);\n@@ -58,0 +59,1 @@\n+        \/\/\/\/\/\/\/\/\/\/\/\n@@ -59,2 +61,4 @@\n-        \/\/ Maximum size is 3GB\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:CompressedClassSpaceSize=4g\",\n+        \/\/ Going below the minimum size for class space (one root chunk size = atm 4M) should be transparently\n+        \/\/ handled by the hotspot, which should round up class space size and not report an error.\n+        pb = ProcessTools.createJavaProcessBuilder(\"-XX:CompressedClassSpaceSize=1m\",\n+                                                   \"-Xlog:gc+metaspace=trace\",\n@@ -63,2 +67,2 @@\n-        output.shouldContain(\"outside the allowed range\")\n-              .shouldHaveExitValue(1);\n+        output.shouldMatch(\"Compressed class space.*\" + min_class_space_size)\n+              .shouldHaveExitValue(0);\n@@ -66,0 +70,1 @@\n+        \/\/\/\/\/\/\/\/\/\/\/\n@@ -67,7 +72,4 @@\n-        \/\/ Make sure the minimum size is set correctly and printed\n-        \/\/ (Note: ccs size shall be rounded up to the minimum size of 4m since metaspace reservations\n-        \/\/  are done in a 4m granularity. Note that this is **reserved** size and does not affect rss.\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\",\n-                                                   \"-XX:CompressedClassSpaceSize=1m\",\n-                                                   \"-Xlog:gc+metaspace=trace\",\n-                                                   \"-version\");\n+        \/\/ Try 0. Same result expected.\n+        pb = ProcessTools.createJavaProcessBuilder(\"-XX:CompressedClassSpaceSize=0\",\n+                \"-Xlog:gc+metaspace=trace\",\n+                \"-version\");\n@@ -75,2 +77,2 @@\n-        output.shouldMatch(\"Compressed class space.*4194304\")\n-              .shouldHaveExitValue(0);\n+        output.shouldMatch(\"Compressed class space.*\" + min_class_space_size)\n+                .shouldHaveExitValue(0);\n@@ -78,0 +80,1 @@\n+        \/\/\/\/\/\/\/\/\/\/\/\n@@ -79,1 +82,1 @@\n-        \/\/ Make sure the maximum size is set correctly and printed\n+        \/\/ Try max allowed size, which should be accepted\n@@ -81,1 +84,1 @@\n-                                                   \"-XX:CompressedClassSpaceSize=3g\",\n+                                                   \"-XX:CompressedClassSpaceSize=\" + max_class_space_size,\n@@ -85,1 +88,1 @@\n-        output.shouldMatch(\"Compressed class space.*3221225472\")\n+        output.shouldMatch(\"Compressed class space.*\" + max_class_space_size)\n@@ -88,0 +91,1 @@\n+        \/\/\/\/\/\/\/\/\/\/\/\n@@ -89,3 +93,5 @@\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:-UseCompressedClassPointers\",\n-                                                   \"-XX:CompressedClassSpaceSize=1m\",\n-                                                   \"-version\");\n+        \/\/ Set max allowed size + 1, which should graciously fail\n+        pb = ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\",\n+                \"-XX:CompressedClassSpaceSize=\" + (max_class_space_size + 1),\n+                \"-Xlog:gc+metaspace=trace\",\n+                \"-version\");\n@@ -93,2 +99,3 @@\n-        output.shouldContain(\"Setting CompressedClassSpaceSize has no effect when compressed class pointers are not used\")\n-              .shouldHaveExitValue(0);\n+        output.shouldContain(\"CompressedClassSpaceSize \" + (max_class_space_size + 1) + \" too large (max: \" + max_class_space_size)\n+              .shouldHaveExitValue(1);\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassSpaceSize.java","additions":34,"deletions":27,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=default\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm BaseOffsets\n+ *\/\n+\/*\n+ * @test id=no-coops\n+ * @library \/test\/lib\n+ * @requires vm.bits == \"64\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run main\/othervm -XX:-UseCompressedOops BaseOffsets\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import jdk.internal.misc.Unsafe;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+\n+public class BaseOffsets {\n+\n+    static class LIClass {\n+        public int i;\n+    }\n+\n+    \/\/ @0:  8 byte header,  @8: int field\n+    static final long INT_OFFSET  = 8L;\n+\n+    static public void main(String[] args) {\n+        Unsafe unsafe = Unsafe.getUnsafe();\n+        Class c = LIClass.class;\n+        Field[] fields = c.getFields();\n+        for (int i = 0; i < fields.length; i++) {\n+            long offset = unsafe.objectFieldOffset(fields[i]);\n+            if (fields[i].getType() == int.class) {\n+                Asserts.assertEquals(offset, INT_OFFSET, \"Misplaced int field\");\n+            } else {\n+                Asserts.fail(\"Unexpected field type\");\n+            }\n+        }\n+\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(boolean[].class), 12, \"Misplaced boolean array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(byte[].class),    12, \"Misplaced byte    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(char[].class),    12, \"Misplaced char    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(short[].class),   12, \"Misplaced short   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(int[].class),     12, \"Misplaced int     array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(long[].class),    16, \"Misplaced long    array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(float[].class),   12, \"Misplaced float   array base\");\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(double[].class),  16, \"Misplaced double  array base\");\n+        boolean narrowOops = System.getProperty(\"java.vm.compressedOopsMode\") != null ||\n+                             !Platform.is64bit();\n+        int expected_objary_offset = narrowOops ? 12 : 16;\n+        Asserts.assertEquals(unsafe.arrayBaseOffset(Object[].class),  expected_objary_offset, \"Misplaced object  array base\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/BaseOffsets.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -41,1 +41,0 @@\n- * @run main\/othervm -XX:+UseCompressedOops -XX:-UseCompressedClassPointers FieldDensityTest\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/FieldDensityTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    static final long INT_OFFSET  = Platform.is64bit() ? 12L : 16L;\n-    static final long LONG_OFFSET = Platform.is64bit() ? 16L :  8L;\n+    static final long INT_OFFSET  = 16L;\n+    static final long LONG_OFFSET = 8L;\n","filename":"test\/hotspot\/jtreg\/runtime\/FieldLayout\/OldLayoutCheck.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,20 +70,0 @@\n-\/*\n- * @test id=test-64bit-noccs\n- * @summary Test the VM.metaspace command\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run main\/othervm -Dwithout-compressed-class-space -XX:MaxMetaspaceSize=201M -Xmx100M -XX:-UseCompressedOops -XX:-UseCompressedClassPointers PrintMetaspaceDcmd\n- *\/\n-\n- \/*\n- * @test id=test-nospecified\n- * @summary Test the VM.metaspace command\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run main\/othervm -Dno-specified-flag -Xmx100M -XX:-UseCompressedOops -XX:-UseCompressedClassPointers PrintMetaspaceDcmd\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/Metaspace\/PrintMetaspaceDcmd.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-      processArgs.add(\"-XX:MaxMetaspaceSize=3m\");\n+      processArgs.add(\"-XX:MaxMetaspaceSize=2m\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/MaxMetaspaceSize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,2 +70,0 @@\n-        testTable.add( new TestVector(\"-XX:+UseCompressedClassPointers\", \"-XX:-UseCompressedClassPointers\",\n-           \"The saved state of UseCompressedOops and UseCompressedClassPointers is different from runtime, CDS will be disabled.\", 1) );\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CommandLineFlagComboNegative.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-        public boolean useCompressedClassPointers;   \/\/ UseCompressedClassPointers\n@@ -52,1 +51,1 @@\n-        public ConfArg(boolean useCompressedOops, boolean useCompressedClassPointers, String msg, int code) {\n+        public ConfArg(boolean useCompressedOops, String msg, int code) {\n@@ -54,1 +53,0 @@\n-            this.useCompressedClassPointers = useCompressedClassPointers;\n@@ -69,1 +67,1 @@\n-            *          UseCompressedOops   UseCompressedClassPointers  Result\n+            *          UseCompressedOops   Result\n@@ -71,5 +69,3 @@\n-            *    dump: on                  on\n-            *    test: on                  on                          Pass\n-            *          on                  off                         Fail\n-            *          off                 on                          Fail\n-            *          off                 off                         Fail\n+            *    dump: on\n+            *    test: on                  Pass\n+            *          off                 Fail\n@@ -77,15 +73,3 @@\n-            *    dump: on                  off\n-            *    test: on                  off                         Pass\n-            *          on                  on                          Fail\n-            *          off                 on                          Pass\n-            *          off                 off                         Fail\n-            *    3.\n-            *    dump: off                 on\n-            *    test: off                 on                          Pass\n-            *          on                  on                          Fail\n-            *          on                  off                         Fail\n-            *    4.\n-            *    dump: off                 off\n-            *    test: off                 off                         Pass\n-            *          on                  on                          Fail\n-            *          on                  off                         Fail\n+            *    dump: off\n+            *    test: off                 Pass\n+            *          on                  Fail\n@@ -94,1 +78,1 @@\n-            if (dumpArg.useCompressedOops && dumpArg.useCompressedClassPointers) {\n+            if (dumpArg.useCompressedOops) {\n@@ -96,1 +80,1 @@\n-                    .add(new ConfArg(true, true, HELLO_STRING, PASS));\n+                    .add(new ConfArg(true, HELLO_STRING, PASS));\n@@ -98,15 +82,1 @@\n-                    .add(new ConfArg(true, false, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(false, true, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(false, false, EXEC_ABNORMAL_MSG, FAIL));\n-\n-            }  else if(dumpArg.useCompressedOops && !dumpArg.useCompressedClassPointers) {\n-                execArgs\n-                    .add(new ConfArg(true, false, HELLO_STRING, PASS));\n-                execArgs\n-                    .add(new ConfArg(true, true, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(false, true, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(false, false, EXEC_ABNORMAL_MSG, FAIL));\n+                    .add(new ConfArg(false, EXEC_ABNORMAL_MSG, FAIL));\n@@ -114,3 +84,1 @@\n-            } else if (!dumpArg.useCompressedOops && dumpArg.useCompressedClassPointers) {\n-                execArgs\n-                    .add(new ConfArg(false, true, HELLO_STRING, PASS));\n+            } else if (!dumpArg.useCompressedOops) {\n@@ -118,1 +86,1 @@\n-                    .add(new ConfArg(true, true, EXEC_ABNORMAL_MSG, FAIL));\n+                    .add(new ConfArg(false, HELLO_STRING, PASS));\n@@ -120,8 +88,1 @@\n-                    .add(new ConfArg(true, false, EXEC_ABNORMAL_MSG, FAIL));\n-            } else if (!dumpArg.useCompressedOops && !dumpArg.useCompressedClassPointers) {\n-                execArgs\n-                    .add(new ConfArg(false, false, HELLO_STRING, PASS));\n-                execArgs\n-                    .add(new ConfArg(true, true, EXEC_ABNORMAL_MSG, FAIL));\n-                execArgs\n-                    .add(new ConfArg(true, false, EXEC_ABNORMAL_MSG, FAIL));\n+                    .add(new ConfArg(true, EXEC_ABNORMAL_MSG, FAIL));\n@@ -137,5 +98,0 @@\n-    public static String getCompressedClassPointersArg(boolean on) {\n-        if (on) return \"-XX:+UseCompressedClassPointers\";\n-        else    return \"-XX:-UseCompressedClassPointers\";\n-    }\n-\n@@ -147,5 +103,1 @@\n-            .add(new RunArg(new ConfArg(true, true, null, PASS)));\n-        runList\n-            .add(new RunArg(new ConfArg(true, false, null, PASS)));\n-        runList\n-            .add(new RunArg(new ConfArg(false, true, null, PASS)));\n+            .add(new RunArg(new ConfArg(true, null, PASS)));\n@@ -153,1 +105,1 @@\n-            .add(new RunArg(new ConfArg(false, false, null, PASS)));\n+            .add(new RunArg(new ConfArg(false, null, PASS)));\n@@ -165,1 +117,0 @@\n-                      getCompressedClassPointersArg(t.dumpArg.useCompressedClassPointers),\n@@ -178,1 +129,0 @@\n-                                      getCompressedClassPointersArg(c.useCompressedClassPointers),\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCombinedCompressedFlags.java","additions":16,"deletions":66,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -75,13 +75,1 @@\n-         System.out.println(\"3. Run with -UseCompressedOops -UseCompressedClassPointers\");\n-         out = TestCommon\n-                   .exec(helloJar,\n-                         \"-XX:+UseSerialGC\",\n-                         \"-XX:-UseCompressedOops\",\n-                         \"-XX:-UseCompressedClassPointers\",\n-                         \"-Xlog:cds\",\n-                         \"Hello\");\n-         out.shouldContain(UNABLE_TO_USE_ARCHIVE);\n-         out.shouldContain(ERR_MSG);\n-         out.shouldHaveExitValue(1);\n-\n-         System.out.println(\"4. Run with -UseCompressedOops +UseCompressedClassPointers\");\n+         System.out.println(\"3. Run with -UseCompressedOops +UseCompressedClassPointers\");\n@@ -98,13 +86,1 @@\n-         System.out.println(\"5. Run with +UseCompressedOops -UseCompressedClassPointers\");\n-         out = TestCommon\n-                   .exec(helloJar,\n-                         \"-XX:+UseSerialGC\",\n-                         \"-XX:+UseCompressedOops\",\n-                         \"-XX:-UseCompressedClassPointers\",\n-                         \"-Xlog:cds\",\n-                         \"Hello\");\n-         out.shouldContain(UNABLE_TO_USE_ARCHIVE);\n-         out.shouldContain(ERR_MSG);\n-         out.shouldHaveExitValue(1);\n-\n-         System.out.println(\"6. Run with +UseCompressedOops +UseCompressedClassPointers\");\n+         System.out.println(\"4. Run with +UseCompressedOops +UseCompressedClassPointers\");\n@@ -122,12 +98,1 @@\n-         System.out.println(\"7. Dump with -UseCompressedOops -UseCompressedClassPointers\");\n-         out = TestCommon\n-                   .dump(helloJar,\n-                         new String[] {\"Hello\"},\n-                         \"-XX:+UseSerialGC\",\n-                         \"-XX:-UseCompressedOops\",\n-                         \"-XX:+UseCompressedClassPointers\",\n-                         \"-Xlog:cds\");\n-         out.shouldContain(\"Dumping shared data to file:\");\n-         out.shouldHaveExitValue(0);\n-\n-         System.out.println(\"8. Run with ZGC\");\n+         System.out.println(\"5. Run with ZGC\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestZGCWithCDS.java","additions":3,"deletions":38,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-                       Platform.is64bit() ? 549755813632L: 4294967168L);\n+                       4294967168L);\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbLongConstant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,2 +134,1 @@\n-        runCheck(new String[] {\"-XX:+IgnoreUnrecognizedVMOptions\", \"-XX:-UseCompressedClassPointers\"},\n-                 BadFailOnConstraint.create(Loads.class, \"load()\", 1, 1, \"Load\"),\n+        runCheck(BadFailOnConstraint.create(Loads.class, \"load()\", 1, 1, \"Load\"),\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -375,1 +375,1 @@\n-        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = roundUp(8, OBJ_ALIGN);\n@@ -382,1 +382,1 @@\n-        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = roundUp(8, OBJ_ALIGN);\n@@ -392,1 +392,1 @@\n-        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = roundUp(8, OBJ_ALIGN);\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,1 +73,2 @@\n-        int objectHeaderSize = bytesPerWord * 3; \/\/ length will be aligned on 64 bits\n+        \/\/ length will be in klass-gap on 64 bits, extra field on 32 bits.\n+        int objectHeaderSize = bytesPerWord * (runsOn32Bit ? 3 : 2);\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/objectcount\/ObjectCountEventVerifier.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,0 +74,3 @@\n+\n+\n+jdk\/jshell\/ToolTabSnippetTest.java 1234567 generic-all\n","filename":"test\/langtools\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}