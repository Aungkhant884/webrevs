{"files":[{"patch":"@@ -2,0 +2,1 @@\n+\n","filename":".github\/workflows\/submit.yml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -309,1 +309,1 @@\n-    obj->oop_iterate(this, klass);\n+    obj->oop_iterate_backwards(this, klass);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    return ((value() & lock_mask_in_place) == monitor_value);\n+    return ((value() & monitor_value) != 0);\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,3 +271,0 @@\n-  template <typename OopClosureType>\n-  inline void oop_iterate(OopClosureType* cl, Klass* klass);\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -384,5 +384,0 @@\n-template <typename OopClosureType>\n-void oopDesc::oop_iterate(OopClosureType* cl, Klass* klass) {\n-  OopIteratorClosureDispatch::oop_oop_iterate(cl, this, klass);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -61,1 +60,0 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n@@ -737,1 +735,1 @@\n-static markWord read_stable_mark(const oop obj) {\n+static markWord read_stable_mark(oop obj) {\n@@ -802,1 +800,1 @@\n-markWord ObjectSynchronizer::stable_mark(oop object) {\n+markWord ObjectSynchronizer::safe_load_mark(oop object) {\n@@ -812,2 +810,0 @@\n-    assert(!mark.is_marked() || !UseShenandoahGC || ShenandoahHeap::heap()->is_full_gc_in_progress(), \"should not see marked header here\");\n-\n@@ -818,1 +814,1 @@\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n@@ -829,0 +825,1 @@\n+      read_stable_mark(object);\n@@ -866,1 +863,1 @@\n-    assert(mark.is_neutral() || mark.is_marked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n@@ -871,0 +868,22 @@\n+markWord ObjectSynchronizer::stable_mark(const oop obj) {\n+  markWord mark = read_stable_mark(obj);\n+  if (!mark.is_neutral() && !mark.is_marked()) {\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* monitor = mark.monitor();\n+      mark = monitor->header();\n+      assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    } else if (SafepointSynchronize::is_at_safepoint() || Thread::current()->is_lock_owned((address) mark.locker())) {\n+      \/\/ This is a stack lock owned by the calling thread so fetch the\n+      \/\/ displaced markWord from the BasicLock on the stack.\n+      assert(mark.has_displaced_mark_helper(), \"must be displaced header here\");\n+      mark = mark.displaced_mark_helper();\n+      assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    } else {\n+      mark = safe_load_mark(obj);\n+      assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+      assert(!mark.is_marked(), \"no forwarded objects here\");\n+    }\n+  }\n+  return mark;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -182,0 +182,2 @@\n+  static markWord safe_load_mark(oop obj);\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}