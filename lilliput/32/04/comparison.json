{"files":[{"patch":"@@ -2,1 +2,0 @@\n-\n@@ -205,1 +204,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -561,1 +559,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -660,1 +657,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -937,1 +933,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -1050,1 +1045,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -1358,1 +1352,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -1460,1 +1453,0 @@\n-          --with-jvm-features=-shenandoahgc\n","filename":".github\/workflows\/submit.yml","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -147,0 +148,5 @@\n+  \/\/ When safely accessing the object header, deal with concurrently-forwarded\n+  \/\/ objects. This may change the obj argument to the forwarded object.\n+  \/\/ Returns true, if caller should retry (e.g. with forwarded object), false otherwise.\n+  virtual bool load_header_handle_forwarding(oop& obj, markWord header) const { return false; }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -139,0 +139,12 @@\n+\n+bool ShenandoahBarrierSet::load_header_handle_forwarding(oop& obj, markWord header) const {\n+  assert(header.is_marked(), \"only forwarded objects here\");\n+  if (!_heap->is_full_gc_move_in_progress()) {\n+    oop fwd = cast_to_oop(header.decode_pointer());\n+    if (_heap->is_in(fwd)) {\n+      obj = fwd;\n+      return true;\n+    }\n+  }\n+  return false;\n+ }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -84,0 +84,2 @@\n+  bool load_header_handle_forwarding(oop& obj, markWord header) const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -34,0 +35,8 @@\n+static inline markWord stable_mark(oop obj) {\n+  markWord mark = obj->mark();\n+  if (mark.is_neutral()) {\n+    return mark;\n+  }\n+  return ObjectSynchronizer::read_stable_mark(obj);\n+}\n+\n@@ -44,1 +53,1 @@\n-  markWord mark = obj->mark();\n+  markWord mark = stable_mark(obj);\n@@ -46,3 +55,3 @@\n-    HeapWord* fwdptr = (HeapWord*) mark.clear_lock_bits().to_pointer();\n-    if (fwdptr != NULL) {\n-      return cast_to_oop(fwdptr);\n+    oop fwd = cast_to_oop(mark.decode_pointer());\n+    if (ShenandoahHeap::heap()->is_in(fwd)) {\n+      return fwd;\n@@ -59,1 +68,1 @@\n-  markWord mark = obj->mark();\n+  markWord mark = stable_mark(obj);\n@@ -75,1 +84,1 @@\n-  return obj->mark().is_marked();\n+  return stable_mark(obj).is_marked();\n@@ -79,1 +88,1 @@\n-  markWord old_mark = obj->mark();\n+  markWord old_mark = stable_mark(obj);\n@@ -84,6 +93,11 @@\n-  markWord new_mark = markWord::encode_pointer_as_mark(update);\n-  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n-  if (prev_mark == old_mark) {\n-    return update;\n-  } else {\n-    return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n+  while (true) {\n+    markWord new_mark = markWord::encode_pointer_as_mark(update);\n+    markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n+    if (prev_mark == old_mark) {\n+      return update;\n+    } else if (prev_mark == markWord::INFLATING()) {\n+      \/\/ This happens when we encounter a stack-locked object in from-space. Busy for completion.\n+      continue;\n+    } else {\n+      return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":27,"deletions":13,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -953,1 +953,1 @@\n-    if (!p->is_forwarded()) {\n+    if (!ShenandoahForwarding::is_forwarded(p)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  product(bool, ShenandoahSuspendibleWorkers, false, EXPERIMENTAL,          \\\n+  product(bool, ShenandoahSuspendibleWorkers, true, EXPERIMENTAL,           \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-    return ((value() & monitor_value) != 0);\n+    return ((value() & lock_mask_in_place) == monitor_value);\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -735,1 +736,1 @@\n-static markWord read_stable_mark(oop obj) {\n+markWord ObjectSynchronizer::read_stable_mark(const oop obj) {\n@@ -800,1 +801,1 @@\n-markWord ObjectSynchronizer::safe_load_mark(oop object) {\n+markWord ObjectSynchronizer::stable_mark(oop object) {\n@@ -802,0 +803,2 @@\n+    assert(object != nullptr, \"null object\");\n+    assert(Universe::heap()->is_in(object), \"object not in heap: \" PTR_FORMAT, p2i(object));\n@@ -809,0 +812,12 @@\n+    \/\/ *  Marked       - object is forwarded, try again on forwardee (GC specific)\n+\n+    \/\/ CASE: Forwarded\n+    if (mark.is_marked()) {\n+      DEBUG_ONLY(oop orig = object;)\n+      if (BarrierSet::barrier_set()->load_header_handle_forwarding(object, mark)) {\n+        assert(orig != object, \"need to see forwarded object\");\n+        assert(object != nullptr, \"null object\");\n+        assert(Universe::heap()->is_in(object), \"object not in heap: \" PTR_FORMAT \", orig: \" PTR_FORMAT \", header: \" INTPTR_FORMAT, p2i(object), p2i(orig), mark.value());\n+        continue;\n+      }\n+    }\n@@ -814,1 +829,1 @@\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n@@ -863,1 +878,1 @@\n-    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    assert(mark.is_neutral() || mark.is_marked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n@@ -868,22 +883,0 @@\n-markWord ObjectSynchronizer::stable_mark(const oop obj) {\n-  markWord mark = read_stable_mark(obj);\n-  if (!mark.is_neutral() && !mark.is_marked()) {\n-    if (mark.has_monitor()) {\n-      ObjectMonitor* monitor = mark.monitor();\n-      mark = monitor->header();\n-      assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n-    } else if (SafepointSynchronize::is_at_safepoint() || Thread::current()->is_lock_owned((address) mark.locker())) {\n-      \/\/ This is a stack lock owned by the calling thread so fetch the\n-      \/\/ displaced markWord from the BasicLock on the stack.\n-      assert(mark.has_displaced_mark_helper(), \"must be displaced header here\");\n-      mark = mark.displaced_mark_helper();\n-      assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n-    } else {\n-      mark = safe_load_mark(obj);\n-      assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n-      assert(!mark.is_marked(), \"no forwarded objects here\");\n-    }\n-  }\n-  return mark;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -182,2 +182,0 @@\n-  static markWord safe_load_mark(oop obj);\n-\n@@ -189,0 +187,1 @@\n+  static markWord read_stable_mark(const oop obj);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}