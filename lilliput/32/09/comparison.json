{"files":[{"patch":"@@ -205,1 +205,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -561,1 +560,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -660,1 +658,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -937,1 +934,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -1050,1 +1046,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -1358,1 +1353,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -1460,1 +1454,0 @@\n-          --with-jvm-features=-shenandoahgc\n","filename":".github\/workflows\/submit.yml","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/objectMarker.hpp\"\n@@ -50,0 +51,1 @@\n+#include \"prims\/jvmtiTagMap.hpp\"\n@@ -654,0 +656,8 @@\n+\n+ObjectMarker* CollectedHeap::init_object_marker() {\n+  if (UseBitmapObjectMarker) {\n+    return new BitmapObjectMarker(_reserved);\n+  } else {\n+    return new HeaderObjectMarker();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+class ObjectMarker;\n+class ObjectMarkerController;\n@@ -99,0 +101,1 @@\n+  friend class ObjectMarkerController;\n@@ -430,0 +433,2 @@\n+  virtual ObjectMarker* init_object_marker();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -696,1 +696,5 @@\n-          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)               \\\n+                                                                            \\\n+  develop(bool, UseBitmapObjectMarker, false,                               \\\n+          \"Use bitmap based ObjectMarker\")                                  \\\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"gc\/shared\/collectedHeap.hpp\"\n+#include \"gc\/shared\/markBitMap.inline.hpp\"\n+#include \"gc\/shared\/objectMarker.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/virtualspace.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+\n+ObjectMarker* ObjectMarkerController::_marker = NULL;\n+\n+ObjectMarkerController::ObjectMarkerController() {\n+  \/\/ prepare heap for iteration\n+  CollectedHeap* heap = Universe::heap();\n+  heap->ensure_parsability(false);  \/\/ no need to retire TLABs\n+  _marker = heap->init_object_marker();\n+}\n+\n+ObjectMarkerController::~ObjectMarkerController() {\n+  delete _marker;\n+  _marker = NULL;\n+}\n+\n+void ObjectMarkerController::mark(oop o) {\n+  assert(_marker != NULL, \"need object marker\");\n+  _marker->mark(o);\n+}\n+\n+bool ObjectMarkerController::is_marked(oop o) {\n+  assert(_marker != NULL, \"need object marker\");\n+  return _marker->is_marked(o);\n+}\n+\n+void ObjectMarkerController::set_needs_reset(bool needs_reset) {\n+  assert(_marker != NULL, \"need object marker\");\n+  return _marker->set_needs_reset(needs_reset);\n+}\n+\n+class RestoreMarksClosure : public ObjectClosure {\n+public:\n+  void do_object(oop o) {\n+    if (o != NULL) {\n+      markWord mark = o->mark();\n+      if (mark.is_marked()) {\n+        o->init_mark();\n+      }\n+    }\n+  }\n+};\n+\n+HeaderObjectMarker::HeaderObjectMarker() :\n+ _saved_oop_stack(new (ResourceObj::C_HEAP, mtGC) GrowableArray<oop>(4000, mtGC)),\n+ _saved_mark_stack(new (ResourceObj::C_HEAP, mtGC) GrowableArray<markWord>(4000, mtGC)),\n+ _needs_reset(false) {\n+}\n+\n+\/\/ object marking done, so restore headers\n+HeaderObjectMarker::~HeaderObjectMarker() {\n+  \/\/ iterate over all objects and restore the mark bits to\n+  \/\/ their initial value\n+  RestoreMarksClosure blk;\n+  if (_needs_reset) {\n+    Universe::heap()->object_iterate(&blk);\n+  }\n+\n+  \/\/ Now restore the interesting headers\n+  for (int i = 0; i < _saved_oop_stack->length(); i++) {\n+    oop o = _saved_oop_stack->at(i);\n+    markWord mark = _saved_mark_stack->at(i);\n+    o->set_mark(mark);\n+  }\n+\n+  \/\/ free the stacks\n+  delete _saved_oop_stack;\n+  delete _saved_mark_stack;\n+}\n+\n+void HeaderObjectMarker::set_needs_reset(bool needs_reset) {\n+  _needs_reset = needs_reset;\n+}\n+\n+\/\/ mark an object\n+void HeaderObjectMarker::mark(oop o) {\n+  assert(Universe::heap()->is_in(o), \"sanity check\");\n+  assert(!o->mark().is_marked(), \"should only mark an object once\");\n+\n+  \/\/ object's mark word\n+  markWord mark = o->mark();\n+\n+  if (o->mark_must_be_preserved(mark)) {\n+    _saved_mark_stack->push(mark);\n+    _saved_oop_stack->push(o);\n+  }\n+\n+  \/\/ mark the object\n+  o->set_mark(o->klass()->prototype_header().set_marked());\n+}\n+\n+\/\/ return true if object is marked\n+bool HeaderObjectMarker::is_marked(oop o) {\n+  return o->mark().is_marked();\n+}\n+\n+BitmapObjectMarker::BitmapObjectMarker(MemRegion heap_region) :\n+  _mark_bit_map(),\n+  _bitmap_region() {\n+  size_t bitmap_size = MarkBitMap::compute_size(heap_region.byte_size());\n+  ReservedSpace bitmap(bitmap_size);\n+  _bitmap_region = MemRegion((HeapWord*) bitmap.base(), bitmap.size() \/ HeapWordSize);\n+  _mark_bit_map.initialize(heap_region, _bitmap_region);\n+\n+  os::commit_memory_or_exit((char*)_bitmap_region.start(), _bitmap_region.byte_size(), false,\n+                          \"Could not commit native memory for auxiliary marking bitmap for JVMTI object marking\");\n+  _mark_bit_map.clear();\n+}\n+\n+BitmapObjectMarker::~BitmapObjectMarker() {\n+  if (!os::uncommit_memory((char*)_bitmap_region.start(), _bitmap_region.byte_size())) {\n+    log_warning(gc)(\"Could not uncommit native memory for auxiliary marking bitmap for JVMTI object marking\");\n+  }\n+}\n+\n+void BitmapObjectMarker::mark(oop o) {\n+  assert(Universe::heap()->is_in(o), \"sanity check\");\n+  assert(!is_marked(o), \"should only mark an object once\");\n+  _mark_bit_map.mark(o);\n+}\n+\n+bool BitmapObjectMarker::is_marked(oop o) {\n+  assert(Universe::heap()->is_in(o), \"sanity check\");\n+  return _mark_bit_map.is_marked(o);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/objectMarker.cpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_OBJECTMARKER_HPP\n+#define SHARE_GC_SHARED_OBJECTMARKER_HPP\n+\n+#include \"gc\/shared\/markBitMap.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/\/ ObjectMarker is used to support the marking objects when walking the\n+\/\/ heap.\n+class ObjectMarker : public CHeapObj<mtGC>{\n+public:\n+  virtual ~ObjectMarker() {};\n+  virtual void mark(oop o) = 0;\n+  virtual bool is_marked(oop o) = 0;\n+\n+  virtual void set_needs_reset(bool needs_reset) {};\n+};\n+\n+\/\/ Stack allocated class to help ensure that ObjectMarker is used\n+\/\/ correctly. Constructor initializes ObjectMarker, destructor calls\n+\/\/ ObjectMarker's done() function to restore object headers.\n+class ObjectMarkerController : public StackObj {\n+private:\n+  static ObjectMarker* _marker;\n+public:\n+  ObjectMarkerController();\n+  ~ObjectMarkerController();\n+\n+  static void mark(oop o);\n+  static bool is_marked(oop o);\n+\n+  static void set_needs_reset(bool needs_reset);\n+};\n+\n+\/\/ ObjectMarker is used to support the marking objects when walking the\n+\/\/ heap.\n+\/\/\n+\/\/ This implementation uses the existing mark bits in an object for\n+\/\/ marking. Objects that are marked must later have their headers restored.\n+\/\/ As most objects are unlocked and don't have their identity hash computed\n+\/\/ we don't have to save their headers. Instead we save the headers that\n+\/\/ are \"interesting\". Later when the headers are restored this implementation\n+\/\/ restores all headers to their initial value and then restores the few\n+\/\/ objects that had interesting headers.\n+\/\/\n+\/\/ Future work: This implementation currently uses growable arrays to save\n+\/\/ the oop and header of interesting objects. As an optimization we could\n+\/\/ use the same technique as the GC and make use of the unused area\n+\/\/ between top() and end().\n+class HeaderObjectMarker : public ObjectMarker {\n+private:\n+  GrowableArray<oop>* _saved_oop_stack;\n+  GrowableArray<markWord>* _saved_mark_stack;\n+  bool _needs_reset;\n+public:\n+  HeaderObjectMarker();\n+  ~HeaderObjectMarker();\n+  void mark(oop o) override;\n+  bool is_marked(oop o) override;\n+  void set_needs_reset(bool needs_reset) override;\n+};\n+\n+\/\/ Implementation that uses a bitmap.\n+class BitmapObjectMarker : public ObjectMarker {\n+private:\n+  MarkBitMap _mark_bit_map;\n+  MemRegion  _bitmap_region;\n+public:\n+  BitmapObjectMarker(MemRegion heap_region);\n+  ~BitmapObjectMarker();\n+\n+  void mark(oop o) override;\n+  bool is_marked(oop o) override;\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_OBJECTMARKER_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/objectMarker.hpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -200,12 +201,12 @@\n-  Klass* obj_klass = obj->klass_or_null();\n-  if (obj_klass == NULL) {\n-    print_failure(_safe_unknown, obj, interior_loc, NULL, \"Shenandoah assert_correct failed\",\n-                  \"Object klass pointer should not be NULL\",\n-                  file,line);\n-  }\n-\n-  if (!Metaspace::contains(obj_klass)) {\n-    print_failure(_safe_unknown, obj, interior_loc, NULL, \"Shenandoah assert_correct failed\",\n-                  \"Object klass pointer must go to metaspace\",\n-                  file,line);\n-  }\n+\/\/  Klass* obj_klass = ShenandoahObjectUtils::klass(obj) ; \/\/ obj->klass_or_null();\n+\/\/  if (obj_klass == NULL) {\n+\/\/    print_failure(_safe_unknown, obj, interior_loc, NULL, \"Shenandoah assert_correct failed\",\n+\/\/                  \"Object klass pointer should not be NULL\",\n+\/\/                  file,line);\n+\/\/  }\n+\/\/\n+\/\/  if (!Metaspace::contains(obj_klass)) {\n+\/\/    print_failure(_safe_unknown, obj, interior_loc, NULL, \"Shenandoah assert_correct failed\",\n+\/\/                  \"Object klass pointer must go to metaspace\",\n+\/\/                  file,line);\n+\/\/  }\n@@ -232,5 +233,5 @@\n-    if (obj_klass != fwd->klass()) {\n-      print_failure(_safe_oop, obj, interior_loc, NULL, \"Shenandoah assert_correct failed\",\n-                    \"Forwardee klass disagrees with object class\",\n-                    file, line);\n-    }\n+\/\/    if (obj_klass != ShenandoahObjectUtils::klass(fwd)) {\n+\/\/      print_failure(_safe_oop, obj, interior_loc, NULL, \"Shenandoah assert_correct failed\",\n+\/\/                    \"Forwardee klass disagrees with object class\",\n+\/\/                    file, line);\n+\/\/    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -46,3 +47,3 @@\n-    HeapWord* fwdptr = (HeapWord*) mark.clear_lock_bits().to_pointer();\n-    if (fwdptr != NULL) {\n-      return cast_to_oop(fwdptr);\n+    oop fwd = cast_to_oop(mark.decode_pointer());\n+    if (ShenandoahHeap::heap()->is_in(fwd)) {\n+      return fwd;\n@@ -70,1 +71,3 @@\n-  shenandoah_assert_correct(NULL, obj);\n+  \/\/ Note (Lilliput): We used to assert correct object here, but this attempts to load the\n+  \/\/ object's Klass* which will access the header, which will not work if object is forwarded.\n+  \/\/ shenandoah_assert_correct(NULL, obj);\n@@ -84,6 +87,11 @@\n-  markWord new_mark = markWord::encode_pointer_as_mark(update);\n-  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n-  if (prev_mark == old_mark) {\n-    return update;\n-  } else {\n-    return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n+  while (true) {\n+    markWord new_mark = markWord::encode_pointer_as_mark(update);\n+    markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n+    if (prev_mark == old_mark) {\n+      return update;\n+    } else if (prev_mark == markWord::INFLATING()) {\n+      \/\/ This happens when we encounter a stack-locked object in from-space. Busy for completion.\n+      continue;\n+    } else {\n+      return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":18,"deletions":10,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/objectMarker.hpp\"\n@@ -953,1 +954,1 @@\n-    if (!p->is_forwarded()) {\n+    if (!ShenandoahForwarding::is_forwarded(p)) {\n@@ -1241,1 +1242,4 @@\n-      obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+\n+      \/\/ We must not expose from-space oops to the rest of runtime, or else it\n+      \/\/ will call klass() on it, which might fail because of unexpected header.\n+      obj = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(obj);\n@@ -1284,0 +1288,1 @@\n+  assert(SafepointSynchronize::is_at_safepoint(), \"can only safely iterate objects at safepoint\");\n@@ -1293,0 +1298,2 @@\n+  set_heap_walk_in_progress(true);\n+\n@@ -1297,0 +1304,1 @@\n+    shenandoah_assert_not_in_cset_except(NULL, obj, cancelled_gc());\n@@ -1302,0 +1310,1 @@\n+  set_heap_walk_in_progress(false);\n@@ -1910,0 +1919,4 @@\n+void ShenandoahHeap::set_heap_walk_in_progress(bool in_progress) {\n+  _heap_walk_in_progress.set_cond(in_progress);\n+}\n+\n@@ -2311,0 +2324,4 @@\n+\n+ObjectMarker* ShenandoahHeap::init_object_marker() {\n+  return new BitmapObjectMarker(_reserved);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+class ObjectMarker;\n@@ -173,1 +174,4 @@\n-\/\/ ---------- Heap counters and metrics\n+private:\n+  ObjectMarker* init_object_marker();\n+\n+  \/\/ ---------- Heap counters and metrics\n@@ -275,0 +279,3 @@\n+\n+    \/\/ JVMTI Heap-walk is in progress, need to ignore forwarding (JVMTI does its own marking).\n+    HEAP_WALK_BITPOS = 5,\n@@ -293,0 +300,1 @@\n+  ShenandoahSharedFlag   _heap_walk_in_progress;\n@@ -310,0 +318,1 @@\n+  void set_heap_walk_in_progress(bool in_progress);\n@@ -324,0 +333,1 @@\n+  inline bool is_heap_walk_in_progress() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -48,0 +49,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -299,1 +301,1 @@\n-  size_t size = p->size();\n+  size_t size = ShenandoahObjectUtils::size(p);\n@@ -428,0 +430,4 @@\n+inline bool ShenandoahHeap::is_heap_walk_in_progress() const {\n+  return _heap_walk_in_progress.is_set();\n+}\n+\n@@ -516,1 +522,1 @@\n-    size_t size = obj->size();\n+    size_t size = ShenandoahObjectUtils::size(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class Klass;\n+\n+class ShenandoahObjectUtils : public AllStatic {\n+public:\n+  static inline markWord stable_mark(oop obj);\n+  static inline Klass* klass(oop obj);\n+  static inline size_t size(oop obj);\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.hpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+\/\/ This is a variant of ObjectSynchronizer::safe_load_mark(), which does the same thing, but also\n+\/\/ handles forwarded objects. This is intended to be used by concurrent evacuation only. No other\n+\/\/ code is supposed to observe from-space objects.\n+markWord ShenandoahObjectUtils::stable_mark(oop obj) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  for (;;) {\n+    assert(heap->is_in(obj), \"object not in heap: \" PTR_FORMAT, p2i(obj));\n+    markWord mark = obj->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  Inflated     - just return mark from inflated monitor\n+    \/\/ *  Stack-locked - coerce it to inflating, and then return displaced mark\n+    \/\/ *  INFLATING    - busy wait for conversion to complete\n+    \/\/ *  Neutral      - return mark\n+    \/\/ *  Marked       - object is forwarded, try again on forwardee\n+\n+    \/\/ Most common case first.\n+    if (mark.is_neutral()) {\n+      return mark;\n+    }\n+\n+    \/\/ If object is already forwarded, then resolve it, and try again.\n+    if (mark.is_marked()) {\n+      if (heap->is_full_gc_move_in_progress() || heap->is_heap_walk_in_progress()) {\n+        \/\/ In these cases, we want to return the header as-is: the Klass* would not be overloaded.\n+        return mark;\n+      }\n+      obj = cast_to_oop(mark.decode_pointer());\n+      continue;\n+    }\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      \/\/ It is safe to access the object monitor because all Java and GC worker threads\n+      \/\/ participate in the monitor deflation protocol (i.e, they react to handshakes and STS requests).\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n+      return dmw;\n+    }\n+\n+    \/\/ CASE: inflating\n+    if (mark.is_being_inflated()) {\n+      \/\/ Interference, try again.\n+      continue;\n+    }\n+\n+    \/\/ CASE: stack-locked\n+    if (mark.has_locker()) {\n+      if (Thread::current()->is_lock_owned((address)mark.locker())) {\n+        \/\/ This thread owns the lock. We can safely access it.\n+        markWord dmw = mark.displaced_mark_helper();\n+        assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n+        return dmw;\n+      }\n+\n+      \/\/ Else we try to install INFLATING into the header. This will (temporarily) prevent other\n+      \/\/ threads from stack-locking or evacuating the object.\n+      markWord cmp = obj->cas_set_mark(markWord::INFLATING(), mark);\n+      if (cmp != mark) {\n+        continue;       \/\/ Interference -- just retry\n+      }\n+\n+      \/\/ We've successfully installed INFLATING (0) into the mark-word.\n+      \/\/ This is the only case where 0 will appear in a mark-word.\n+      \/\/ Only the singular thread that successfully swings the mark-word\n+      \/\/ to 0 can fetch the stack-lock and safely read the displaced header.\n+\n+      \/\/ fetch the displaced mark from the owner's stack.\n+      \/\/ The owner can't die or unwind past the lock while our INFLATING\n+      \/\/ object is in the mark.  Furthermore the owner can't complete\n+      \/\/ an unlock on the object, either. No other thread can do evacuation, either.\n+      markWord dmw = mark.displaced_mark_helper();\n+      \/\/ Catch if the object's header is not neutral (not locked and\n+      \/\/ not marked is what we care about here).\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+\n+      \/\/ Must preserve store ordering. The monitor state must\n+      \/\/ be stable at the time of publishing the monitor address.\n+      guarantee(obj->mark() == markWord::INFLATING(), \"invariant\");\n+      \/\/ Release semantics so that above set_object() is seen first.\n+      obj->release_set_mark(mark);\n+\n+      return dmw;\n+    }\n+  }\n+}\n+\n+Klass* ShenandoahObjectUtils::klass(oop obj) {\n+  markWord header = stable_mark(obj);\n+  assert(header.narrow_klass() != 0, \"klass must not be NULL: \" INTPTR_FORMAT, header.value());\n+  return header.klass();\n+}\n+\n+size_t ShenandoahObjectUtils::size(oop obj) {\n+  Klass* kls = klass(obj);\n+  return obj->size_given_klass(kls);\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.inline.hpp","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -100,1 +101,1 @@\n-      if (is_instance_ref_klass(obj->klass())) {\n+      if (is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n@@ -127,1 +128,1 @@\n-    Klass* obj_klass = obj->klass_or_null();\n+    Klass* obj_klass = ShenandoahObjectUtils::klass(obj);\n@@ -142,1 +143,1 @@\n-        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj->size()) <= obj_reg->top(),\n+        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + ShenandoahObjectUtils::size(obj)) <= obj_reg->top(),\n@@ -146,1 +147,1 @@\n-        size_t humongous_end = humongous_start + (obj->size() >> ShenandoahHeapRegion::region_size_words_shift());\n+        size_t humongous_end = humongous_start + (ShenandoahObjectUtils::size(obj) >> ShenandoahHeapRegion::region_size_words_shift());\n@@ -163,1 +164,1 @@\n-          Atomic::add(&_ld[obj_reg->index()], (uint) obj->size(), memory_order_relaxed);\n+          Atomic::add(&_ld[obj_reg->index()], (uint) ShenandoahObjectUtils::size(obj), memory_order_relaxed);\n@@ -204,1 +205,1 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd->size()) <= fwd_reg->top(),\n+      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + ShenandoahObjectUtils::size(fwd)) <= fwd_reg->top(),\n@@ -307,1 +308,2 @@\n-    obj->oop_iterate(this);\n+    Klass* klass = ShenandoahObjectUtils::klass(obj);\n+    obj->oop_iterate_backwards(this, klass);\n@@ -587,1 +589,1 @@\n-    if (!is_instance_ref_klass(obj->klass())) {\n+    if (!is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  product(bool, ShenandoahSuspendibleWorkers, false, EXPERIMENTAL,          \\\n+  product(bool, ShenandoahSuspendibleWorkers, true, EXPERIMENTAL,           \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/objectMarker.hpp\"\n@@ -1334,128 +1335,0 @@\n-\n-\/\/ ObjectMarker is used to support the marking objects when walking the\n-\/\/ heap.\n-\/\/\n-\/\/ This implementation uses the existing mark bits in an object for\n-\/\/ marking. Objects that are marked must later have their headers restored.\n-\/\/ As most objects are unlocked and don't have their identity hash computed\n-\/\/ we don't have to save their headers. Instead we save the headers that\n-\/\/ are \"interesting\". Later when the headers are restored this implementation\n-\/\/ restores all headers to their initial value and then restores the few\n-\/\/ objects that had interesting headers.\n-\/\/\n-\/\/ Future work: This implementation currently uses growable arrays to save\n-\/\/ the oop and header of interesting objects. As an optimization we could\n-\/\/ use the same technique as the GC and make use of the unused area\n-\/\/ between top() and end().\n-\/\/\n-\n-\/\/ An ObjectClosure used to restore the mark bits of an object\n-class RestoreMarksClosure : public ObjectClosure {\n- public:\n-  void do_object(oop o) {\n-    if (o != NULL) {\n-      markWord mark = o->mark();\n-      if (mark.is_marked()) {\n-        o->init_mark();\n-      }\n-    }\n-  }\n-};\n-\n-\/\/ ObjectMarker provides the mark and visited functions\n-class ObjectMarker : AllStatic {\n- private:\n-  \/\/ saved headers\n-  static GrowableArray<oop>* _saved_oop_stack;\n-  static GrowableArray<markWord>* _saved_mark_stack;\n-  static bool _needs_reset;                  \/\/ do we need to reset mark bits?\n-\n- public:\n-  static void init();                       \/\/ initialize\n-  static void done();                       \/\/ clean-up\n-\n-  static inline void mark(oop o);           \/\/ mark an object\n-  static inline bool visited(oop o);        \/\/ check if object has been visited\n-\n-  static inline bool needs_reset()            { return _needs_reset; }\n-  static inline void set_needs_reset(bool v)  { _needs_reset = v; }\n-};\n-\n-GrowableArray<oop>* ObjectMarker::_saved_oop_stack = NULL;\n-GrowableArray<markWord>* ObjectMarker::_saved_mark_stack = NULL;\n-bool ObjectMarker::_needs_reset = true;  \/\/ need to reset mark bits by default\n-\n-\/\/ initialize ObjectMarker - prepares for object marking\n-void ObjectMarker::init() {\n-  assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"must be at a safepoint\");\n-\n-  \/\/ prepare heap for iteration\n-  Universe::heap()->ensure_parsability(false);  \/\/ no need to retire TLABs\n-\n-  \/\/ create stacks for interesting headers\n-  _saved_mark_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<markWord>(4000, mtServiceability);\n-  _saved_oop_stack = new (ResourceObj::C_HEAP, mtServiceability) GrowableArray<oop>(4000, mtServiceability);\n-}\n-\n-\/\/ Object marking is done so restore object headers\n-void ObjectMarker::done() {\n-  \/\/ iterate over all objects and restore the mark bits to\n-  \/\/ their initial value\n-  RestoreMarksClosure blk;\n-  if (needs_reset()) {\n-    Universe::heap()->object_iterate(&blk);\n-  } else {\n-    \/\/ We don't need to reset mark bits on this call, but reset the\n-    \/\/ flag to the default for the next call.\n-    set_needs_reset(true);\n-  }\n-\n-  \/\/ now restore the interesting headers\n-  for (int i = 0; i < _saved_oop_stack->length(); i++) {\n-    oop o = _saved_oop_stack->at(i);\n-    markWord mark = _saved_mark_stack->at(i);\n-    o->set_mark(mark);\n-  }\n-\n-  \/\/ free the stacks\n-  delete _saved_oop_stack;\n-  delete _saved_mark_stack;\n-}\n-\n-\/\/ mark an object\n-inline void ObjectMarker::mark(oop o) {\n-  assert(Universe::heap()->is_in(o), \"sanity check\");\n-  assert(!o->mark().is_marked(), \"should only mark an object once\");\n-\n-  \/\/ object's mark word\n-  markWord mark = o->mark();\n-\n-  if (o->mark_must_be_preserved(mark)) {\n-    _saved_mark_stack->push(mark);\n-    _saved_oop_stack->push(o);\n-  }\n-\n-  \/\/ mark the object\n-  o->set_mark(o->klass()->prototype_header().set_marked());\n-}\n-\n-\/\/ return true if object is marked\n-inline bool ObjectMarker::visited(oop o) {\n-  return o->mark().is_marked();\n-}\n-\n-\/\/ Stack allocated class to help ensure that ObjectMarker is used\n-\/\/ correctly. Constructor initializes ObjectMarker, destructor calls\n-\/\/ ObjectMarker's done() function to restore object headers.\n-class ObjectMarkerController : public StackObj {\n- public:\n-  ObjectMarkerController() {\n-    ObjectMarker::init();\n-  }\n-  ~ObjectMarkerController() {\n-    ObjectMarker::done();\n-  }\n-};\n-\n-\n@@ -1603,1 +1476,1 @@\n-    if (!ObjectMarker::visited(obj)) visit_stack()->push(obj);\n+    if (!ObjectMarkerController::is_marked(obj)) visit_stack()->push(obj);\n@@ -2890,2 +2763,2 @@\n-  assert(!ObjectMarker::visited(o), \"can't visit same object more than once\");\n-  ObjectMarker::mark(o);\n+  assert(!ObjectMarkerController::is_marked(o), \"can't visit same object more than once\");\n+  ObjectMarkerController::mark(o);\n@@ -2929,6 +2802,0 @@\n-    \/\/ If either collect_stack_roots() or collect_simple_roots()\n-    \/\/ returns false at this point, then there are no mark bits\n-    \/\/ to reset.\n-    ObjectMarker::set_needs_reset(false);\n-\n-    \/\/ Calling collect_stack_roots() before collect_simple_roots()\n@@ -2942,1 +2809,1 @@\n-    ObjectMarker::set_needs_reset(true);\n+    ObjectMarkerController::set_needs_reset(true);\n@@ -2954,1 +2821,1 @@\n-      if (!ObjectMarker::visited(o)) {\n+      if (!ObjectMarkerController::is_marked(o)) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":6,"deletions":139,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/markBitMap.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}