{"files":[{"patch":"@@ -205,1 +205,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -562,1 +561,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -661,1 +659,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -950,1 +947,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -1074,1 +1070,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -1394,1 +1389,0 @@\n-          --with-jvm-features=-shenandoahgc\n@@ -1496,1 +1490,0 @@\n-          --with-jvm-features=-shenandoahgc\n","filename":".github\/workflows\/submit.yml","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -200,1 +201,1 @@\n-  Klass* obj_klass = obj->klass_or_null();\n+  Klass* obj_klass = ShenandoahObjectUtils::klass(obj);\n@@ -232,1 +233,1 @@\n-    if (obj_klass != fwd->klass()) {\n+    if (obj_klass != ShenandoahObjectUtils::klass(fwd)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -79,1 +79,4 @@\n-  markWord old_mark = obj->mark();\n+\n+  markWord old_mark = ObjectSynchronizer::read_stable_mark(obj);\n+  assert(!old_mark.is_being_inflated(), \"must not see INFLATING marker here\");\n+\n@@ -84,0 +87,4 @@\n+  \/\/ Ensure that the copy has the correct mark-word, in case it happened to copy with\n+  \/\/ INFLATING marker.\n+  update->set_mark(old_mark);\n+\n@@ -85,5 +92,13 @@\n-  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n-  if (prev_mark == old_mark) {\n-    return update;\n-  } else {\n-    return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n+  while (true) {\n+    markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n+    if (prev_mark == old_mark) {\n+      return update;\n+    } else if (prev_mark == markWord::INFLATING()) {\n+      \/\/ This happens when we encounter a stack-locked object in from-space.\n+      \/\/ Busy-wait for completion.\n+      SpinPause();\n+      continue;\n+    } else {\n+      assert(prev_mark.is_marked(), \"must be forwarded\");\n+      return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -953,1 +953,1 @@\n-    if (!p->is_forwarded()) {\n+    if (!ShenandoahForwarding::is_forwarded(p)) {\n@@ -1241,1 +1241,4 @@\n-      obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+\n+      \/\/ We must not expose from-space oops to the rest of runtime, or else it\n+      \/\/ will call klass() on it, which might fail because of unexpected header.\n+      obj = ShenandoahBarrierSet::barrier_set()->load_reference_barrier(obj);\n@@ -1297,0 +1300,1 @@\n+    shenandoah_assert_not_in_cset_except(NULL, obj, cancelled_gc());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -299,1 +300,1 @@\n-  size_t size = p->size();\n+  size_t size = ShenandoahObjectUtils::size(p);\n@@ -516,1 +517,1 @@\n-    size_t size = obj->size();\n+    size_t size = ShenandoahObjectUtils::size(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class Klass;\n+\n+class ShenandoahObjectUtils : public AllStatic {\n+public:\n+#ifdef _LP64\n+  static inline markWord stable_mark(oop obj);\n+#endif\n+  static inline Klass* klass(oop obj);\n+  static inline size_t size(oop obj);\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_INLINE_HPP\n+\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"oops\/markWord.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n+#include \"runtime\/thread.hpp\"\n+\n+\/\/ This is a variant of ObjectSynchronizer::stable_mark(), which does the same thing, but also\n+\/\/ handles forwarded objects. This is intended to be used by concurrent evacuation only. No other\n+\/\/ code is supposed to observe from-space objects.\n+#ifdef _LP64\n+markWord ShenandoahObjectUtils::stable_mark(oop obj) {\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n+  for (;;) {\n+    assert(heap->is_in(obj), \"object not in heap: \" PTR_FORMAT, p2i(obj));\n+    markWord mark = obj->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  Inflated     - just return mark from inflated monitor\n+    \/\/ *  Stack-locked - coerce it to inflating, and then return displaced mark\n+    \/\/ *  INFLATING    - busy wait for conversion to complete\n+    \/\/ *  Neutral      - return mark\n+    \/\/ *  Marked       - object is forwarded, try again on forwardee\n+\n+    \/\/ Most common case first.\n+    if (mark.is_neutral()) {\n+      return mark;\n+    }\n+\n+    \/\/ If object is already forwarded, then resolve it, and try again.\n+    if (mark.is_marked()) {\n+      if (heap->is_full_gc_move_in_progress()) {\n+        \/\/ In these cases, we want to return the header as-is: the Klass* would not be overloaded.\n+        return mark;\n+      }\n+      obj = cast_to_oop(mark.decode_pointer());\n+      continue;\n+    }\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      \/\/ It is safe to access the object monitor because all Java and GC worker threads\n+      \/\/ participate in the monitor deflation protocol (i.e, they react to handshakes and STS requests).\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n+      return dmw;\n+    }\n+\n+    \/\/ CASE: inflating\n+    if (mark.is_being_inflated()) {\n+      \/\/ Interference, try again.\n+      continue;\n+    }\n+\n+    \/\/ CASE: stack-locked\n+    if (mark.has_locker()) {\n+      if (Thread::current()->is_lock_owned((address)mark.locker())) {\n+        \/\/ This thread owns the lock. We can safely access it.\n+        markWord dmw = mark.displaced_mark_helper();\n+        assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT \", original mark: \" INTPTR_FORMAT, dmw.value(), mark.value());\n+        return dmw;\n+      }\n+\n+      \/\/ Else we try to install INFLATING into the header. This will (temporarily) prevent other\n+      \/\/ threads from stack-locking or evacuating the object.\n+      markWord cmp = obj->cas_set_mark(markWord::INFLATING(), mark);\n+      if (cmp != mark) {\n+        continue;       \/\/ Interference -- just retry\n+      }\n+\n+      \/\/ We've successfully installed INFLATING (0) into the mark-word.\n+      \/\/ This is the only case where 0 will appear in a mark-word.\n+      \/\/ Only the singular thread that successfully swings the mark-word\n+      \/\/ to 0 can fetch the stack-lock and safely read the displaced header.\n+\n+      \/\/ fetch the displaced mark from the owner's stack.\n+      \/\/ The owner can't die or unwind past the lock while our INFLATING\n+      \/\/ object is in the mark.  Furthermore the owner can't complete\n+      \/\/ an unlock on the object, either. No other thread can do evacuation, either.\n+      markWord dmw = mark.displaced_mark_helper();\n+      \/\/ Catch if the object's header is not neutral (not locked and\n+      \/\/ not marked is what we care about here).\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+\n+      \/\/ Must preserve store ordering. The monitor state must\n+      \/\/ be stable at the time of publishing the monitor address.\n+      guarantee(obj->mark() == markWord::INFLATING(), \"invariant\");\n+      \/\/ Release semantics so that above set_object() is seen first.\n+      obj->release_set_mark(mark);\n+\n+      return dmw;\n+    }\n+  }\n+}\n+#endif\n+\n+Klass* ShenandoahObjectUtils::klass(oop obj) {\n+#ifdef _LP64\n+  markWord header = stable_mark(obj);\n+  assert(header.narrow_klass() != 0, \"klass must not be NULL: \" INTPTR_FORMAT, header.value());\n+  return header.klass();\n+#else\n+  return obj->klass();\n+#endif\n+}\n+\n+size_t ShenandoahObjectUtils::size(oop obj) {\n+  Klass* kls = klass(obj);\n+  return obj->size_given_klass(kls);\n+}\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHOBJECTUTILS_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahObjectUtils.inline.hpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shenandoah\/shenandoahObjectUtils.inline.hpp\"\n@@ -100,1 +101,1 @@\n-      if (is_instance_ref_klass(obj->klass())) {\n+      if (is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n@@ -127,1 +128,1 @@\n-    Klass* obj_klass = obj->klass_or_null();\n+    Klass* obj_klass = ShenandoahObjectUtils::klass(obj);\n@@ -142,1 +143,1 @@\n-        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + obj->size()) <= obj_reg->top(),\n+        check(ShenandoahAsserts::_safe_unknown, obj, (obj_addr + ShenandoahObjectUtils::size(obj)) <= obj_reg->top(),\n@@ -146,1 +147,1 @@\n-        size_t humongous_end = humongous_start + (obj->size() >> ShenandoahHeapRegion::region_size_words_shift());\n+        size_t humongous_end = humongous_start + (ShenandoahObjectUtils::size(obj) >> ShenandoahHeapRegion::region_size_words_shift());\n@@ -163,1 +164,1 @@\n-          Atomic::add(&_ld[obj_reg->index()], (uint) obj->size(), memory_order_relaxed);\n+          Atomic::add(&_ld[obj_reg->index()], (uint) ShenandoahObjectUtils::size(obj), memory_order_relaxed);\n@@ -204,1 +205,1 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + fwd->size()) <= fwd_reg->top(),\n+      check(ShenandoahAsserts::_safe_oop, obj, (fwd_addr + ShenandoahObjectUtils::size(fwd)) <= fwd_reg->top(),\n@@ -307,1 +308,2 @@\n-    obj->oop_iterate(this);\n+    Klass* klass = ShenandoahObjectUtils::klass(obj);\n+    obj->oop_iterate_backwards(this, klass);\n@@ -587,1 +589,1 @@\n-    if (!is_instance_ref_klass(obj->klass())) {\n+    if (!is_instance_ref_klass(ShenandoahObjectUtils::klass(obj))) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-  product(bool, ShenandoahSuspendibleWorkers, false, EXPERIMENTAL,          \\\n+  product(bool, ShenandoahSuspendibleWorkers, true, EXPERIMENTAL,           \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -735,1 +735,1 @@\n-static markWord read_stable_mark(oop obj) {\n+markWord ObjectSynchronizer::read_stable_mark(oop obj) {\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,0 +187,3 @@\n+  \/\/ Read mark-word and spin-wait as long as INFLATING is observed.\n+  static markWord read_stable_mark(oop obj);\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}