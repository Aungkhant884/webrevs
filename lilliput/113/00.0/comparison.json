{"files":[{"patch":"@@ -34,6 +34,0 @@\n-      apt-gcc-version:\n-        required: true\n-        type: string\n-      apt-gcc-cross-version:\n-        required: true\n-        type: string\n@@ -76,1 +70,1 @@\n-        uses: actions\/checkout@v3\n+        uses: actions\/checkout@v4\n@@ -98,6 +92,5 @@\n-              gcc-${{ inputs.gcc-major-version }}=${{ inputs.apt-gcc-version }} \\\n-              g++-${{ inputs.gcc-major-version }}=${{ inputs.apt-gcc-version }} \\\n-              gcc-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-cross-version }} \\\n-              g++-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-cross-version }} \\\n-              libxrandr-dev libxtst-dev libcups2-dev libasound2-dev \\\n-              debian-ports-archive-keyring\n+              gcc-${{ inputs.gcc-major-version }} \\\n+              g++-${{ inputs.gcc-major-version }} \\\n+              gcc-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}} \\\n+              g++-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}} \\\n+              libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n@@ -122,1 +115,1 @@\n-          --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype6-dev,libpng-dev\n+          --include=fakeroot,symlinks,build-essential,libx11-dev,libxext-dev,libxrender-dev,libxrandr-dev,libxtst-dev,libxt-dev,libcups2-dev,libfontconfig1-dev,libasound2-dev,libfreetype-dev,libpng-dev\n@@ -125,1 +118,0 @@\n-          $(test -n \"${{ matrix.debian-keyring }}\" && echo \"--keyring=${{ matrix.debian-keyring }}\")\n@@ -138,1 +130,2 @@\n-          rm -rf sysroot\/usr\/lib\/{apt,udev,systemd}\n+          rm -rf sysroot\/usr\/lib\/{apt,gcc,udev,systemd}\n+          rm -rf sysroot\/usr\/libexec\/gcc\n","filename":".github\/workflows\/build-cross-compile.yml","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -181,1 +181,2 @@\n-      printf \"%.0f\", c; \\\n+      c = c + 0.5; \\\n+      printf \"%d\", c; \\\n@@ -870,1 +871,1 @@\n-  clean-workdir-$1:\n+  clean-outputdirs-$1:\n@@ -872,0 +873,1 @@\n+\t$$(RM) -r $$($1_TEST_RESULTS_DIR)\n@@ -874,1 +876,1 @@\n-      $$(JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \\\n+      $$(JTREG_JAVA) $$($1_JTREG_LAUNCHER_OPTIONS) \\\n@@ -917,1 +919,1 @@\n-  run-test-$1: pre-run-test clean-workdir-$1\n+  run-test-$1: pre-run-test clean-outputdirs-$1\n@@ -954,1 +956,1 @@\n-  $1: run-test-$1 parse-test-$1 clean-workdir-$1\n+  $1: run-test-$1 parse-test-$1 clean-outputdirs-$1\n@@ -956,1 +958,1 @@\n-  TARGETS += $1 run-test-$1 parse-test-$1 clean-workdir-$1\n+  TARGETS += $1 run-test-$1 parse-test-$1 clean-outputdirs-$1\n","filename":"make\/RunTests.gmk","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1724,2 +1724,2 @@\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n-    st->print(\"pacia  lr, rfp\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n+    st->print(\"paciaz\\n\\t\");\n@@ -1854,2 +1854,2 @@\n-    st->print(\"autia lr, rfp\\n\\t\");\n-    st->print(\"ldr zr, [lr]\\n\\t\");\n+    st->print(\"autiaz\\n\\t\");\n+    st->print(\"ldr  zr, [lr]\\n\\t\");\n@@ -3819,196 +3819,0 @@\n-  enc_class aarch64_enc_fast_lock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    \/\/ Load markWord from object into displaced_header.\n-    __ ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      __ load_klass(tmp, oop);\n-      __ ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-      __ tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n-      __ br(Assembler::NE, cont);\n-    }\n-\n-    \/\/ Check for existing monitor\n-    __ tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n-      __ orr(tmp, disp_hdr, markWord::unlocked_value);\n-\n-      \/\/ Initialize the box. (Must happen before we update the object mark!)\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ Compare object markWord with an unlocked value (tmp) and if\n-      \/\/ equal exchange the stack address of our box with object markWord.\n-      \/\/ On failure disp_hdr contains the possibly locked markWord.\n-      __ cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n-                 \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n-      __ br(Assembler::EQ, cont);\n-\n-      assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-      \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n-      \/\/ object, will have now locked it will continue at label cont\n-\n-      \/\/ Check if the owner is self by comparing the value in the\n-      \/\/ markWord of object (disp_hdr) with the stack pointer.\n-      __ mov(rscratch1, sp);\n-      __ sub(disp_hdr, disp_hdr, rscratch1);\n-      __ mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n-      \/\/ If condition is true we are cont and hence we can store 0 as the\n-      \/\/ displaced header in the box, which indicates that it is a recursive lock.\n-      __ ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n-      __ str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ fast_lock(oop, disp_hdr, tmp, rscratch1, no_count);\n-      __ b(count);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-\n-    \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n-    \/\/ otherwise m->owner may contain a thread or a stack address.\n-    \/\/\n-    \/\/ Try to CAS m->owner from NULL to current thread.\n-    __ add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n-    __ cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n-               \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n-\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n-      \/\/ lock. The fast-path monitor unlock code checks for\n-      \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n-      \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n-      __ mov(tmp, (address)markWord::unused_mark().value());\n-      __ str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    }\n-    __ br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n-\n-    __ cmp(rscratch1, rthread);\n-    __ br(Assembler::NE, cont); \/\/ Check for recursive locking\n-\n-    \/\/ Recursive lock case\n-    __ increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n-    \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n-  enc_class aarch64_enc_fast_unlock(iRegP object, iRegP box, iRegP tmp, iRegP tmp2) %{\n-    C2_MacroAssembler _masm(&cbuf);\n-    Register oop = as_Register($object$$reg);\n-    Register box = as_Register($box$$reg);\n-    Register disp_hdr = as_Register($tmp$$reg);\n-    Register tmp = as_Register($tmp2$$reg);\n-    Label cont;\n-    Label object_has_monitor;\n-    Label count, no_count;\n-\n-    assert_different_registers(oop, box, tmp, disp_hdr);\n-\n-    if (LockingMode == LM_LEGACY) {\n-      \/\/ Find the lock address and load the displaced header from the stack.\n-      __ ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-\n-      \/\/ If the displaced header is 0, we have a recursive unlock.\n-      __ cmp(disp_hdr, zr);\n-      __ br(Assembler::EQ, cont);\n-    }\n-\n-    \/\/ Handle existing monitor.\n-    __ ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n-    __ tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n-\n-    if (LockingMode == LM_MONITOR) {\n-      __ tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n-      __ b(cont);\n-    } else if (LockingMode == LM_LEGACY) {\n-      \/\/ Check if it is still a light weight lock, this is is true if we\n-      \/\/ see the stack address of the basicLock in the markWord of the\n-      \/\/ object.\n-\n-      __ cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n-                 \/*release*\/ true, \/*weak*\/ false, tmp);\n-      __ b(cont);\n-    } else {\n-      assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n-      __ fast_unlock(oop, tmp, box, disp_hdr, no_count);\n-      __ b(count);\n-    }\n-\n-    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n-\n-    \/\/ Handle existing monitor.\n-    __ bind(object_has_monitor);\n-    STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n-    __ add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n-\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n-      Register tmp2 = disp_hdr;\n-      __ ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n-      \/\/ We cannot use tbnz here, the target might be too far away and cannot\n-      \/\/ be encoded.\n-      __ tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n-      C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n-      Compile::current()->output()->add_stub(stub);\n-      __ br(Assembler::NE, stub->entry());\n-      __ bind(stub->continuation());\n-    }\n-\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-\n-    Label notRecursive;\n-    __ cbz(disp_hdr, notRecursive);\n-\n-    \/\/ Recursive lock\n-    __ sub(disp_hdr, disp_hdr, 1u);\n-    __ str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n-    __ cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n-    __ b(cont);\n-\n-    __ bind(notRecursive);\n-    __ ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n-    __ ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n-    __ orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n-    __ cmp(rscratch1, zr); \/\/ Sets flags for result\n-    __ cbnz(rscratch1, cont);\n-    \/\/ need a release store here\n-    __ lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n-    __ stlr(zr, tmp); \/\/ set unowned\n-\n-    __ bind(cont);\n-    \/\/ flag == EQ indicates success\n-    \/\/ flag == NE indicates failure\n-    __ br(Assembler::NE, no_count);\n-\n-    __ bind(count);\n-    __ decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-    __ bind(no_count);\n-  %}\n-\n@@ -16633,1 +16437,1 @@\n-instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2)\n+instruct cmpFastLock(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -16636,1 +16440,1 @@\n-  effect(TEMP tmp, TEMP tmp2);\n+  effect(TEMP tmp, TEMP tmp2, TEMP tmp3);\n@@ -16643,1 +16447,3 @@\n-  ins_encode(aarch64_enc_fast_lock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_lock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+  %}\n@@ -16656,1 +16462,3 @@\n-  ins_encode(aarch64_enc_fast_unlock(object, box, tmp, tmp2));\n+  ins_encode %{\n+    __ fast_unlock($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register);\n+  %}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":12,"deletions":204,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -437,1 +437,1 @@\n-      __ unlock_object(r5, r4, r0, *stub->entry());\n+      __ unlock_object(r5, r4, r0, r6, *stub->entry());\n@@ -1299,3 +1299,2 @@\n-  Label profile_cast_success, profile_cast_failure;\n-  Label *success_target = should_profile ? &profile_cast_success : success;\n-  Label *failure_target = should_profile ? &profile_cast_failure : failure;\n+  Label* success_target = success;\n+  Label* failure_target = failure;\n@@ -1317,18 +1316,27 @@\n-    if (should_profile) {\n-      Label not_null;\n-      __ cbnz(obj, not_null);\n-      \/\/ Object is null; update MDO and exit\n-      Register mdo  = klass_RInfo;\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address data_addr\n-        = __ form_address(rscratch2, mdo,\n-                          md->byte_offset_of_slot(data, DataLayout::flags_offset()),\n-                          0);\n-      __ ldrb(rscratch1, data_addr);\n-      __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());\n-      __ strb(rscratch1, data_addr);\n-      __ b(*obj_is_null);\n-      __ bind(not_null);\n-    } else {\n-      __ cbz(obj, *obj_is_null);\n-    }\n+  if (should_profile) {\n+    Register mdo  = klass_RInfo;\n+    __ mov_metadata(mdo, md->constant_encoding());\n+    Label not_null;\n+    __ cbnz(obj, not_null);\n+    \/\/ Object is null; update MDO and exit\n+    Address data_addr\n+      = __ form_address(rscratch2, mdo,\n+                        md->byte_offset_of_slot(data, DataLayout::flags_offset()),\n+                        0);\n+    __ ldrb(rscratch1, data_addr);\n+    __ orr(rscratch1, rscratch1, BitData::null_seen_byte_constant());\n+    __ strb(rscratch1, data_addr);\n+    __ b(*obj_is_null);\n+    __ bind(not_null);\n+\n+    Label update_done;\n+    Register recv = k_RInfo;\n+    __ load_klass(recv, obj);\n+    type_profile_helper(mdo, md, data, recv, &update_done);\n+    Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+    __ addptr(counter_addr, DataLayout::counter_increment);\n+\n+    __ bind(update_done);\n+  } else {\n+    __ cbz(obj, *obj_is_null);\n+  }\n@@ -1388,20 +1396,0 @@\n-  if (should_profile) {\n-    Register mdo  = klass_RInfo, recv = k_RInfo;\n-    __ bind(profile_cast_success);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    __ load_klass(recv, obj);\n-    Label update_done;\n-    type_profile_helper(mdo, md, data, recv, success);\n-    __ b(*success);\n-\n-    __ bind(profile_cast_failure);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address counter_addr\n-      = __ form_address(rscratch2, mdo,\n-                        md->byte_offset_of_slot(data, CounterData::count_offset()),\n-                        0);\n-    __ ldr(rscratch1, counter_addr);\n-    __ sub(rscratch1, rscratch1, DataLayout::counter_increment);\n-    __ str(rscratch1, counter_addr);\n-    __ b(*failure);\n-  }\n@@ -1439,3 +1427,3 @@\n-    Label profile_cast_success, profile_cast_failure, done;\n-    Label *success_target = should_profile ? &profile_cast_success : &done;\n-    Label *failure_target = should_profile ? &profile_cast_failure : stub->entry();\n+    Label done;\n+    Label* success_target = &done;\n+    Label* failure_target = stub->entry();\n@@ -1445,2 +1433,0 @@\n-      __ cbnz(value, not_null);\n-      \/\/ Object is null; update MDO and exit\n@@ -1449,0 +1435,2 @@\n+      __ cbnz(value, not_null);\n+      \/\/ Object is null; update MDO and exit\n@@ -1458,0 +1446,8 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, value);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ addptr(counter_addr, DataLayout::counter_increment);\n+      __ bind(update_done);\n@@ -1478,19 +1474,0 @@\n-    if (should_profile) {\n-      Register mdo  = klass_RInfo, recv = k_RInfo;\n-      __ bind(profile_cast_success);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      __ load_klass(recv, value);\n-      Label update_done;\n-      type_profile_helper(mdo, md, data, recv, &done);\n-      __ b(done);\n-\n-      __ bind(profile_cast_failure);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ lea(rscratch2, counter_addr);\n-      __ ldr(rscratch1, Address(rscratch2));\n-      __ sub(rscratch1, rscratch1, DataLayout::counter_increment);\n-      __ str(rscratch1, Address(rscratch2));\n-      __ b(*stub->entry());\n-    }\n-\n@@ -2529,0 +2506,1 @@\n+  Register temp = op->scratch_opr()->as_register();\n@@ -2538,1 +2516,1 @@\n-    int null_check_offset = __ lock_object(hdr, obj, lock, *op->stub()->entry());\n+    int null_check_offset = __ lock_object(hdr, obj, lock, temp, *op->stub()->entry());\n@@ -2545,1 +2523,1 @@\n-    __ unlock_object(hdr, obj, lock, *op->stub()->entry());\n+    __ unlock_object(hdr, obj, lock, temp, *op->stub()->entry());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":46,"deletions":68,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+int C1_MacroAssembler::lock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -66,1 +66,1 @@\n-  assert_different_registers(hdr, obj, disp_hdr);\n+  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n@@ -86,1 +86,1 @@\n-    fast_lock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_lock(obj, hdr, temp, rscratch2, slow_case);\n@@ -128,1 +128,1 @@\n-void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Label& slow_case) {\n+void C1_MacroAssembler::unlock_object(Register hdr, Register obj, Register disp_hdr, Register temp, Label& slow_case) {\n@@ -131,1 +131,1 @@\n-  assert(hdr != obj && hdr != disp_hdr && obj != disp_hdr, \"registers must be different\");\n+  assert_different_registers(hdr, obj, disp_hdr, temp, rscratch2);\n@@ -152,1 +152,1 @@\n-    fast_unlock(obj, hdr, rscratch1, rscratch2, slow_case);\n+    lightweight_unlock(obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,0 +48,196 @@\n+void C2_MacroAssembler::fast_lock(Register objectReg, Register boxReg, Register tmpReg,\n+                                  Register tmp2Reg, Register tmp3Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  \/\/ Load markWord from object into displaced_header.\n+  ldr(disp_hdr, Address(oop, oopDesc::mark_offset_in_bytes()));\n+\n+  if (DiagnoseSyncOnValueBasedClasses != 0) {\n+    load_klass(tmp, oop);\n+    ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n+    tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    br(Assembler::NE, cont);\n+  }\n+\n+  \/\/ Check for existing monitor\n+  tbnz(disp_hdr, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Set tmp to be (markWord of object | UNLOCK_VALUE).\n+    orr(tmp, disp_hdr, markWord::unlocked_value);\n+\n+    \/\/ Initialize the box. (Must happen before we update the object mark!)\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ Compare object markWord with an unlocked value (tmp) and if\n+    \/\/ equal exchange the stack address of our box with object markWord.\n+    \/\/ On failure disp_hdr contains the possibly locked markWord.\n+    cmpxchg(oop, tmp, box, Assembler::xword, \/*acquire*\/ true,\n+            \/*release*\/ true, \/*weak*\/ false, disp_hdr);\n+    br(Assembler::EQ, cont);\n+\n+    assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+    \/\/ If the compare-and-exchange succeeded, then we found an unlocked\n+    \/\/ object, will have now locked it will continue at label cont\n+\n+    \/\/ Check if the owner is self by comparing the value in the\n+    \/\/ markWord of object (disp_hdr) with the stack pointer.\n+    mov(rscratch1, sp);\n+    sub(disp_hdr, disp_hdr, rscratch1);\n+    mov(tmp, (address) (~(os::vm_page_size()-1) | markWord::lock_mask_in_place));\n+    \/\/ If condition is true we are cont and hence we can store 0 as the\n+    \/\/ displaced header in the box, which indicates that it is a recursive lock.\n+    ands(tmp\/*==0?*\/, disp_hdr, tmp);   \/\/ Sets flags for result\n+    str(tmp\/*==0, perhaps*\/, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_lock(oop, disp_hdr, tmp, tmp3Reg, no_count);\n+    b(count);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+\n+  \/\/ The object's monitor m is unlocked iff m->owner == NULL,\n+  \/\/ otherwise m->owner may contain a thread or a stack address.\n+  \/\/\n+  \/\/ Try to CAS m->owner from NULL to current thread.\n+  add(tmp, disp_hdr, (in_bytes(ObjectMonitor::owner_offset())-markWord::monitor_value));\n+  cmpxchg(tmp, zr, rthread, Assembler::xword, \/*acquire*\/ true,\n+          \/*release*\/ true, \/*weak*\/ false, rscratch1); \/\/ Sets flags for result\n+\n+  if (LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ Store a non-null value into the box to avoid looking like a re-entrant\n+    \/\/ lock. The fast-path monitor unlock code checks for\n+    \/\/ markWord::monitor_value so use markWord::unused_mark which has the\n+    \/\/ relevant bit set, and also matches ObjectSynchronizer::enter.\n+    mov(tmp, (address)markWord::unused_mark().value());\n+    str(tmp, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+  }\n+  br(Assembler::EQ, cont); \/\/ CAS success means locking succeeded\n+\n+  cmp(rscratch1, rthread);\n+  br(Assembler::NE, cont); \/\/ Check for recursive locking\n+\n+  \/\/ Recursive lock case\n+  increment(Address(disp_hdr, in_bytes(ObjectMonitor::recursions_offset()) - markWord::monitor_value), 1);\n+  \/\/ flag == EQ still from the cmp above, checking if this is a reentrant lock\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  increment(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n+void C2_MacroAssembler::fast_unlock(Register objectReg, Register boxReg, Register tmpReg,\n+                                    Register tmp2Reg) {\n+  Register oop = objectReg;\n+  Register box = boxReg;\n+  Register disp_hdr = tmpReg;\n+  Register tmp = tmp2Reg;\n+  Label cont;\n+  Label object_has_monitor;\n+  Label count, no_count;\n+\n+  assert_different_registers(oop, box, tmp, disp_hdr);\n+\n+  if (LockingMode == LM_LEGACY) {\n+    \/\/ Find the lock address and load the displaced header from the stack.\n+    ldr(disp_hdr, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n+\n+    \/\/ If the displaced header is 0, we have a recursive unlock.\n+    cmp(disp_hdr, zr);\n+    br(Assembler::EQ, cont);\n+  }\n+\n+  \/\/ Handle existing monitor.\n+  ldr(tmp, Address(oop, oopDesc::mark_offset_in_bytes()));\n+  tbnz(tmp, exact_log2(markWord::monitor_value), object_has_monitor);\n+\n+  if (LockingMode == LM_MONITOR) {\n+    tst(oop, oop); \/\/ Set NE to indicate 'failure' -> take slow-path. We know that oop != 0.\n+    b(cont);\n+  } else if (LockingMode == LM_LEGACY) {\n+    \/\/ Check if it is still a light weight lock, this is is true if we\n+    \/\/ see the stack address of the basicLock in the markWord of the\n+    \/\/ object.\n+\n+    cmpxchg(oop, box, disp_hdr, Assembler::xword, \/*acquire*\/ false,\n+            \/*release*\/ true, \/*weak*\/ false, tmp);\n+    b(cont);\n+  } else {\n+    assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+    lightweight_unlock(oop, tmp, box, disp_hdr, no_count);\n+    b(count);\n+  }\n+\n+  assert(oopDesc::mark_offset_in_bytes() == 0, \"offset of _mark is not 0\");\n+\n+  \/\/ Handle existing monitor.\n+  bind(object_has_monitor);\n+  STATIC_ASSERT(markWord::monitor_value <= INT_MAX);\n+  add(tmp, tmp, -(int)markWord::monitor_value); \/\/ monitor\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    \/\/ If the owner is anonymous, we need to fix it -- in an outline stub.\n+    Register tmp2 = disp_hdr;\n+    ldr(tmp2, Address(tmp, ObjectMonitor::owner_offset()));\n+    \/\/ We cannot use tbnz here, the target might be too far away and cannot\n+    \/\/ be encoded.\n+    tst(tmp2, (uint64_t)ObjectMonitor::ANONYMOUS_OWNER);\n+    C2HandleAnonOMOwnerStub* stub = new (Compile::current()->comp_arena()) C2HandleAnonOMOwnerStub(tmp, tmp2);\n+    Compile::current()->output()->add_stub(stub);\n+    br(Assembler::NE, stub->entry());\n+    bind(stub->continuation());\n+  }\n+\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+\n+  Label notRecursive;\n+  cbz(disp_hdr, notRecursive);\n+\n+  \/\/ Recursive lock\n+  sub(disp_hdr, disp_hdr, 1u);\n+  str(disp_hdr, Address(tmp, ObjectMonitor::recursions_offset()));\n+  cmp(disp_hdr, disp_hdr); \/\/ Sets flags for result\n+  b(cont);\n+\n+  bind(notRecursive);\n+  ldr(rscratch1, Address(tmp, ObjectMonitor::EntryList_offset()));\n+  ldr(disp_hdr, Address(tmp, ObjectMonitor::cxq_offset()));\n+  orr(rscratch1, rscratch1, disp_hdr); \/\/ Will be 0 if both are 0.\n+  cmp(rscratch1, zr); \/\/ Sets flags for result\n+  cbnz(rscratch1, cont);\n+  \/\/ need a release store here\n+  lea(tmp, Address(tmp, ObjectMonitor::owner_offset()));\n+  stlr(zr, tmp); \/\/ set unowned\n+\n+  bind(cont);\n+  \/\/ flag == EQ indicates success\n+  \/\/ flag == NE indicates failure\n+  br(Assembler::NE, no_count);\n+\n+  bind(count);\n+  decrement(Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  bind(no_count);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":196,"deletions":0,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -38,0 +38,5 @@\n+  \/\/ Code used by cmpFastLock and cmpFastUnlock mach instructions in .ad file.\n+  \/\/ See full description in macroAssembler_aarch64.cpp.\n+  void fast_lock(Register object, Register box, Register tmp, Register tmp2, Register tmp3);\n+  void fast_unlock(Register object, Register box, Register tmp, Register tmp2);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1199,0 +1199,104 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register temp_itbl_klass,\n+                                                  Register scan_temp,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  \/\/ 'method_result' is only used as output register at the very end of this method.\n+  \/\/ Until then we can reuse it as 'holder_offset'.\n+  Register holder_offset = method_result;\n+  assert_different_registers(resolved_klass, recv_klass, holder_klass, temp_itbl_klass, scan_temp, holder_offset);\n+\n+  int vtable_start_offset = in_bytes(Klass::vtable_start_offset());\n+  int itable_offset_entry_size = itableOffsetEntry::size() * wordSize;\n+  int ioffset = in_bytes(itableOffsetEntry::interface_offset());\n+  int ooffset = in_bytes(itableOffsetEntry::offset_offset());\n+\n+  Label L_loop_search_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  ldrw(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  add(recv_klass, recv_klass, vtable_start_offset + ioffset);\n+  \/\/ itableOffsetEntry[] itable = recv_klass + Klass::vtable_start_offset() + sizeof(vtableEntry) * recv_klass->_vtable_len;\n+  \/\/ temp_itbl_klass = itable[0]._interface;\n+  int vtblEntrySize = vtableEntry::size_in_bytes();\n+  assert(vtblEntrySize == wordSize, \"ldr lsl shift amount must be 3\");\n+  ldr(temp_itbl_klass, Address(recv_klass, scan_temp, Address::lsl(exact_log2(vtblEntrySize))));\n+  mov(holder_offset, zr);\n+  \/\/ scan_temp = &(itable[0]._interface)\n+  lea(scan_temp, Address(recv_klass, scan_temp, Address::lsl(exact_log2(vtblEntrySize))));\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  cmp(resolved_klass, holder_klass);\n+  br(Assembler::NE, L_loop_search_resolved_entry);\n+  cmp(holder_klass, temp_itbl_klass);\n+  br(Assembler::EQ, L_holder_found);\n+  cbz(temp_itbl_klass, L_no_such_interface);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     temp_itbl_klass = *(scan_temp += itable_offset_entry_size);\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/       goto L_holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (temp_itbl_klass != 0);\n+  \/\/   goto L_no_such_interface \/\/ Not found.\n+  Label L_search_holder;\n+  bind(L_search_holder);\n+    ldr(temp_itbl_klass, Address(pre(scan_temp, itable_offset_entry_size)));\n+    cmp(holder_klass, temp_itbl_klass);\n+    br(Assembler::EQ, L_holder_found);\n+    cbnz(temp_itbl_klass, L_search_holder);\n+\n+  b(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   while (true) {\n+  \/\/     temp_itbl_klass = *(scan_temp += itable_offset_entry_size);\n+  \/\/     if (temp_itbl_klass == 0) {\n+  \/\/       goto L_no_such_interface;\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/        holder_offset = scan_temp;\n+  \/\/     }\n+  \/\/   }\n+  \/\/\n+  Label L_loop_search_resolved;\n+  bind(L_loop_search_resolved);\n+    ldr(temp_itbl_klass, Address(pre(scan_temp, itable_offset_entry_size)));\n+  bind(L_loop_search_resolved_entry);\n+    cbz(temp_itbl_klass, L_no_such_interface);\n+    cmp(resolved_klass, temp_itbl_klass);\n+    br(Assembler::EQ, L_resolved_found);\n+    cmp(holder_klass, temp_itbl_klass);\n+    br(Assembler::NE, L_loop_search_resolved);\n+    mov(holder_offset, scan_temp);\n+    b(L_loop_search_resolved);\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  cbz(holder_offset, L_search_holder);\n+  mov(scan_temp, holder_offset);\n+\n+  \/\/ Finally, scan_temp contains holder_klass vtable offset\n+  bind(L_holder_found);\n+  ldrw(method_result, Address(scan_temp, ooffset - ioffset));\n+  add(recv_klass, recv_klass, itable_index * wordSize + in_bytes(itableMethodEntry::method_offset())\n+    - vtable_start_offset - ioffset); \/\/ substract offsets to restore the original value of recv_klass\n+  ldr(method_result, Address(recv_klass, method_result, Address::uxtw(0)));\n+}\n+\n@@ -2738,0 +2842,4 @@\n+#ifdef ASSERT\n+    \/\/ Poison rscratch1 which is written on !UseLSE branch\n+    mov(rscratch1, 0x1f1f1f1f1f1f1f1f);\n+#endif\n@@ -6011,1 +6119,1 @@\n-\/\/ Uses the FP as the modifier.\n+\/\/ Uses value zero as the modifier.\n@@ -6016,4 +6124,1 @@\n-    \/\/ The standard convention for C code is to use paciasp, which uses SP as the modifier. This\n-    \/\/ works because in C code, FP and SP match on function entry. In the JDK, SP and FP may not\n-    \/\/ match, so instead explicitly use the FP.\n-    pacia(lr, rfp);\n+    paciaz();\n@@ -6025,2 +6130,1 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses value zero as the modifier.\n@@ -6028,1 +6132,1 @@\n-void MacroAssembler::protect_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::protect_return_address(Register return_reg) {\n@@ -6030,3 +6134,1 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n-    ldr(temp_reg, Address(rfp));\n-    pacia(return_reg, temp_reg);\n+    paciza(return_reg);\n@@ -6038,0 +6140,1 @@\n+\/\/ Uses value zero as the modifier.\n@@ -6039,1 +6142,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg) {\n+void MacroAssembler::authenticate_return_address() {\n@@ -6041,2 +6144,2 @@\n-    autia(return_reg, rfp);\n-    check_return_address(return_reg);\n+    autiaz();\n+    check_return_address();\n@@ -6048,2 +6151,1 @@\n-\/\/ Uses the FP from the start of the function as the modifier - which is stored at the address of\n-\/\/ the current FP.\n+\/\/ Uses value zero as the modifier.\n@@ -6051,1 +6153,1 @@\n-void MacroAssembler::authenticate_return_address(Register return_reg, Register temp_reg) {\n+void MacroAssembler::authenticate_return_address(Register return_reg) {\n@@ -6053,3 +6155,1 @@\n-    assert(PreserveFramePointer, \"PreserveFramePointer must be set for ROP protection\");\n-    ldr(temp_reg, Address(rfp));\n-    autia(return_reg, temp_reg);\n+    autiza(return_reg);\n@@ -6258,1 +6358,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -6265,1 +6365,1 @@\n-void MacroAssembler::fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n@@ -6267,1 +6367,1 @@\n-  assert_different_registers(obj, hdr, t1, t2);\n+  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n@@ -6279,0 +6379,1 @@\n+  \/\/ Clobbers rscratch1 when UseLSE is false\n@@ -6290,1 +6391,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -6297,1 +6398,1 @@\n-void MacroAssembler::fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow) {\n@@ -6299,1 +6400,1 @@\n-  assert_different_registers(obj, hdr, t1, t2);\n+  assert_different_registers(obj, hdr, t1, t2, rscratch1);\n@@ -6339,0 +6440,1 @@\n+  \/\/ Clobbers rscratch1 when UseLSE is false\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":128,"deletions":26,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -720,3 +720,3 @@\n-  void protect_return_address(Register return_reg, Register temp_reg);\n-  void authenticate_return_address(Register return_reg = lr);\n-  void authenticate_return_address(Register return_reg, Register temp_reg);\n+  void protect_return_address(Register return_reg);\n+  void authenticate_return_address();\n+  void authenticate_return_address(Register return_reg);\n@@ -948,0 +948,9 @@\n+  void lookup_interface_method_stub(Register recv_klass,\n+                                    Register holder_klass,\n+                                    Register resolved_klass,\n+                                    Register method_result,\n+                                    Register temp_reg,\n+                                    Register temp_reg2,\n+                                    int itable_index,\n+                                    Label& L_no_such_interface);\n+\n@@ -1588,2 +1597,2 @@\n-  void fast_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n-  void fast_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register t1, Register t2, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#include \"oops\/method.hpp\"\n+#include \"oops\/method.inline.hpp\"\n@@ -2208,0 +2208,12 @@\n+  if (_desc->bytecode() != Bytecodes::_return_register_finalizer) {\n+    Label no_safepoint;\n+    __ ldr(rscratch1, Address(rthread, JavaThread::polling_word_offset()));\n+    __ tbz(rscratch1, log2i_exact(SafepointMechanism::poll_bit()), no_safepoint);\n+    __ push(state);\n+    __ push_cont_fastpath(rthread);\n+    __ call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::at_safepoint));\n+    __ pop_cont_fastpath(rthread);\n+    __ pop(state);\n+    __ bind(no_safepoint);\n+  }\n+\n@@ -3869,1 +3881,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -3879,2 +3891,4 @@\n-    __ ldr(c_rarg3, monitor_block_top); \/\/ points to current entry,\n-                                        \/\/ starting with top-most entry\n+    __ ldr(c_rarg3, monitor_block_top); \/\/ derelativize pointer\n+    __ lea(c_rarg3, Address(rfp, c_rarg3, Address::lsl(Interpreter::logStackElementSize)));\n+    \/\/ c_rarg3 points to current entry, starting with top-most entry\n+\n@@ -3915,1 +3929,2 @@\n-    __ mov(rscratch1, sp);\n+    __ sub(rscratch1, sp, rfp);\n+    __ asr(rscratch1, rscratch1, Interpreter::logStackElementSize);\n@@ -3918,1 +3933,4 @@\n-    __ ldr(c_rarg1, monitor_block_bot);   \/\/ c_rarg1: old expression stack bottom\n+    __ ldr(c_rarg1, monitor_block_bot);   \/\/ derelativize pointer\n+    __ lea(c_rarg1, Address(rfp, c_rarg1, Address::lsl(Interpreter::logStackElementSize)));\n+    \/\/ c_rarg1 points to the old expression stack bottom\n+\n@@ -3922,1 +3940,3 @@\n-    __ str(c_rarg1, monitor_block_bot);   \/\/ set new monitor block bottom\n+    __ sub(rscratch1, c_rarg1, rfp);      \/\/ relativize pointer\n+    __ asr(rscratch1, rscratch1, Interpreter::logStackElementSize);\n+    __ str(rscratch1, monitor_block_bot);  \/\/ set new monitor block bottom\n@@ -3972,1 +3992,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -3979,2 +3999,4 @@\n-    __ ldr(c_rarg1, monitor_block_top); \/\/ points to current entry,\n-                                        \/\/ starting with top-most entry\n+    __ ldr(c_rarg1, monitor_block_top); \/\/ derelativize pointer\n+    __ lea(c_rarg1, Address(rfp, c_rarg1, Address::lsl(Interpreter::logStackElementSize)));\n+    \/\/ c_rarg1 points to current entry, starting with top-most entry\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":32,"deletions":10,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-    fast_lock_2(obj \/* obj *\/, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n+    lightweight_lock(obj \/* obj *\/, t1, t2, t3, 1 \/* savemask - save t1 *\/, slow_case);\n@@ -284,2 +284,2 @@\n-    fast_unlock_2(obj \/* object *\/, t1, t2, t3, 1 \/* savemask (save t1) *\/,\n-                    slow_case);\n+    lightweight_unlock(obj \/* object *\/, t1, t2, t3, 1 \/* savemask (save t1) *\/,\n+                       slow_case);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1704,1 +1704,1 @@\n-      __ fast_lock(obj_reg, swap_reg, tmp, t0, slow_path_lock);\n+      __ lightweight_lock(obj_reg, swap_reg, tmp, t0, slow_path_lock);\n@@ -1832,1 +1832,1 @@\n-      __ fast_unlock(obj_reg, old_hdr, swap_reg, t0, slow_path_unlock);\n+      __ lightweight_unlock(obj_reg, old_hdr, swap_reg, t0, slow_path_unlock);\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1698,3 +1698,2 @@\n-  Label profile_cast_success, profile_cast_failure;\n-  Label *success_target = op->should_profile() ? &profile_cast_success : success;\n-  Label *failure_target = op->should_profile() ? &profile_cast_failure : failure;\n+  Label* success_target = success;\n+  Label* failure_target = failure;\n@@ -1716,1 +1715,1 @@\n-  __ cmpptr(obj, NULL_WORD);\n+  __ testptr(obj, obj);\n@@ -1719,2 +1718,0 @@\n-    __ jccb(Assembler::notEqual, not_null);\n-    \/\/ Object is null; update MDO and exit\n@@ -1723,0 +1720,2 @@\n+    __ jccb(Assembler::notEqual, not_null);\n+    \/\/ Object is null; update MDO and exit\n@@ -1728,0 +1727,10 @@\n+\n+    Label update_done;\n+    Register recv = k_RInfo;\n+    __ load_klass(recv, obj, tmp_load_klass);\n+    type_profile_helper(mdo, md, data, recv, &update_done);\n+\n+    Address nonprofiled_receiver_count_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+    __ addptr(nonprofiled_receiver_count_addr, DataLayout::counter_increment);\n+\n+    __ bind(update_done);\n@@ -1795,1 +1804,1 @@\n-        __ cmpl(klass_RInfo, 0);\n+        __ testl(klass_RInfo, klass_RInfo);\n@@ -1809,1 +1818,1 @@\n-      __ cmpl(k_RInfo, 0);\n+      __ testl(k_RInfo, k_RInfo);\n@@ -1814,14 +1823,0 @@\n-  if (op->should_profile()) {\n-    Register mdo  = klass_RInfo, recv = k_RInfo;\n-    __ bind(profile_cast_success);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    __ load_klass(recv, obj, tmp_load_klass);\n-    type_profile_helper(mdo, md, data, recv, success);\n-    __ jmp(*success);\n-\n-    __ bind(profile_cast_failure);\n-    __ mov_metadata(mdo, md->constant_encoding());\n-    Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-    __ subptr(counter_addr, DataLayout::counter_increment);\n-    __ jmp(*failure);\n-  }\n@@ -1858,3 +1853,3 @@\n-    Label profile_cast_success, profile_cast_failure, done;\n-    Label *success_target = op->should_profile() ? &profile_cast_success : &done;\n-    Label *failure_target = op->should_profile() ? &profile_cast_failure : stub->entry();\n+    Label done;\n+    Label* success_target = &done;\n+    Label* failure_target = stub->entry();\n@@ -1862,1 +1857,1 @@\n-    __ cmpptr(value, NULL_WORD);\n+    __ testptr(value, value);\n@@ -1865,2 +1860,0 @@\n-      __ jccb(Assembler::notEqual, not_null);\n-      \/\/ Object is null; update MDO and exit\n@@ -1869,0 +1862,2 @@\n+      __ jccb(Assembler::notEqual, not_null);\n+      \/\/ Object is null; update MDO and exit\n@@ -1874,0 +1869,9 @@\n+\n+      Label update_done;\n+      Register recv = k_RInfo;\n+      __ load_klass(recv, value, tmp_load_klass);\n+      type_profile_helper(mdo, md, data, recv, &update_done);\n+\n+      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n+      __ addptr(counter_addr, DataLayout::counter_increment);\n+      __ bind(update_done);\n@@ -1893,1 +1897,1 @@\n-    __ cmpl(k_RInfo, 0);\n+    __ testl(k_RInfo, k_RInfo);\n@@ -1897,15 +1901,0 @@\n-    if (op->should_profile()) {\n-      Register mdo  = klass_RInfo, recv = k_RInfo;\n-      __ bind(profile_cast_success);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      __ load_klass(recv, value, tmp_load_klass);\n-      type_profile_helper(mdo, md, data, recv, &done);\n-      __ jmpb(done);\n-\n-      __ bind(profile_cast_failure);\n-      __ mov_metadata(mdo, md->constant_encoding());\n-      Address counter_addr(mdo, md->byte_offset_of_slot(data, CounterData::count_offset()));\n-      __ subptr(counter_addr, DataLayout::counter_increment);\n-      __ jmp(*stub->entry());\n-    }\n-\n@@ -2050,1 +2039,1 @@\n-    __ jcc (acond, skip);\n+    __ jccb(acond, skip);\n@@ -2667,1 +2656,6 @@\n-        __ cmpl(reg1, c->as_jint());\n+        jint i = c->as_jint();\n+        if (i == 0) {\n+          __ testl(reg1, reg1);\n+        } else {\n+          __ cmpl(reg1, i);\n+        }\n@@ -2673,1 +2667,1 @@\n-          __ cmpptr(reg1, NULL_WORD);\n+          __ testptr(reg1, reg1);\n@@ -2681,1 +2675,1 @@\n-          __ cmpptr(reg1, NULL_WORD);\n+          __ testptr(reg1, reg1);\n@@ -3150,1 +3144,1 @@\n-    __ cmpl(rax, 0);\n+    __ testl(rax, rax);\n@@ -3284,1 +3278,1 @@\n-      __ cmpl(src, 0);\n+      __ testl(src, src);\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":44,"deletions":50,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -72,1 +73,1 @@\n-    fast_lock_impl(obj, hdr, thread, tmp, slow_case);\n+    lightweight_lock(obj, hdr, thread, tmp, slow_case);\n@@ -138,1 +139,1 @@\n-    fast_unlock_impl(obj, disp_hdr, hdr, slow_case);\n+    lightweight_unlock(obj, disp_hdr, hdr, slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -624,1 +625,1 @@\n-    fast_lock_impl(objReg, tmpReg, thread, scrReg, NO_COUNT);\n+    lightweight_lock(objReg, tmpReg, thread, scrReg, NO_COUNT);\n@@ -928,1 +929,1 @@\n-      fast_unlock_impl(objReg, boxReg, tmpReg, NO_COUNT);\n+      lightweight_unlock(objReg, boxReg, tmpReg, NO_COUNT);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -9317,0 +9318,11 @@\n+void MacroAssembler::evpaddq(XMMRegister dst, KRegister mask, XMMRegister nds, AddressLiteral src, bool merge, int vector_len, Register rscratch) {\n+  assert(rscratch != noreg || always_reachable(src), \"missing\");\n+\n+  if (reachable(src)) {\n+    Assembler::evpaddq(dst, mask, nds, as_Address(src), merge, vector_len);\n+  } else {\n+    lea(rscratch, src);\n+    Assembler::evpaddq(dst, mask, nds, Address(rscratch, 0), merge, vector_len);\n+  }\n+}\n+\n@@ -9837,1 +9849,1 @@\n-\/\/ Implements fast-locking.\n+\/\/ Implements lightweight-locking.\n@@ -9845,1 +9857,1 @@\n-void MacroAssembler::fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow) {\n@@ -9873,1 +9885,1 @@\n-\/\/ Implements fast-unlocking.\n+\/\/ Implements lightweight-unlocking.\n@@ -9880,1 +9892,1 @@\n-void MacroAssembler::fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -1802,0 +1803,3 @@\n+  using Assembler::evpaddq;\n+  void evpaddq(XMMRegister dst, KRegister mask, XMMRegister nds, AddressLiteral src, bool merge, int vector_len, Register rscratch = noreg);\n+\n@@ -2033,2 +2037,2 @@\n-  void fast_lock_impl(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n-  void fast_unlock_impl(Register obj, Register hdr, Register tmp, Label& slow);\n+  void lightweight_lock(Register obj, Register hdr, Register thread, Register tmp, Label& slow);\n+  void lightweight_unlock(Register obj, Register hdr, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,19 +92,4 @@\n-#if defined(TARGET_COMPILER_gcc) && !defined(_WIN64)\n-  jfloat retval;\n-  const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n-  if (!is_LP64 || UseAVX < 1 || !UseFMA) {\n-  asm (\"\\\n-1:               \\n\\\n-fprem            \\n\\\n-fnstsw %%ax      \\n\\\n-test   $0x4,%%ah \\n\\\n-jne    1b        \\n\\\n-\"\n-    :\"=t\"(retval)\n-    :\"0\"(x), \"u\"(y)\n-    :\"cc\", \"ax\");\n-  } else {\n-    assert(StubRoutines::fmod() != nullptr, \"\");\n-    jdouble (*addr)(jdouble, jdouble) = (double (*)(double, double))StubRoutines::fmod();\n-    jdouble dx = (jdouble) x;\n-    jdouble dy = (jdouble) y;\n+  assert(StubRoutines::fmod() != nullptr, \"\");\n+  jdouble (*addr)(jdouble, jdouble) = (double (*)(double, double))StubRoutines::fmod();\n+  jdouble dx = (jdouble) x;\n+  jdouble dy = (jdouble) y;\n@@ -113,3 +98,1 @@\n-    retval = (jfloat) (*addr)(dx, dy);\n-  }\n-  return retval;\n+  return (jfloat) (*addr)(dx, dy);\n@@ -119,16 +102,2 @@\n-  jdouble retval;\n-  const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);\n-  if (!is_LP64 || UseAVX < 1 || !UseFMA) {\n-  asm (\"\\\n-1:               \\n\\\n-fprem            \\n\\\n-fnstsw %%ax      \\n\\\n-test   $0x4,%%ah \\n\\\n-jne    1b        \\n\\\n-\"\n-    :\"=t\"(retval)\n-    :\"0\"(x), \"u\"(y)\n-    :\"cc\", \"ax\");\n-  } else {\n-    assert(StubRoutines::fmod() != nullptr, \"\");\n-    jdouble (*addr)(jdouble, jdouble) = (double (*)(double, double))StubRoutines::fmod();\n+  assert(StubRoutines::fmod() != nullptr, \"\");\n+  jdouble (*addr)(jdouble, jdouble) = (double (*)(double, double))StubRoutines::fmod();\n@@ -136,3 +105,1 @@\n-    retval = (*addr)(x, y);\n-  }\n-  return retval;\n+  return (*addr)(x, y);\n@@ -140,1 +107,0 @@\n-#endif \/\/ TARGET_COMPILER_gcc && !_WIN64\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":8,"deletions":42,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"oops\/methodCounters.hpp\"\n@@ -4364,1 +4365,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -4378,2 +4379,4 @@\n-    __ movptr(rtop, monitor_block_top); \/\/ points to current entry,\n-                                        \/\/ starting with top-most entry\n+    __ movptr(rtop, monitor_block_top); \/\/ derelativize pointer\n+    __ lea(rtop, Address(rbp, rtop, Address::times_ptr));\n+    \/\/ rtop points to current entry, starting with top-most entry\n+\n@@ -4411,0 +4414,1 @@\n+    __ lea(rmon, Address(rbp, rmon, Address::times_ptr));\n@@ -4414,1 +4418,1 @@\n-    __ movptr(monitor_block_bot, rmon); \/\/ set new monitor block bottom\n+    __ subptr(monitor_block_bot, entry_size \/ wordSize); \/\/ set new monitor block bottom\n@@ -4461,1 +4465,1 @@\n-  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;\n+  const int entry_size = frame::interpreter_frame_monitor_size_in_bytes();\n@@ -4471,2 +4475,4 @@\n-    __ movptr(rtop, monitor_block_top); \/\/ points to current entry,\n-                                        \/\/ starting with top-most entry\n+    __ movptr(rtop, monitor_block_top); \/\/ derelativize pointer\n+    __ lea(rtop, Address(rbp, rtop, Address::times_ptr));\n+    \/\/ rtop points to current entry, starting with top-most entry\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -7668,1 +7668,1 @@\n-\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7680,0 +7680,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7692,0 +7693,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7705,0 +7707,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7718,0 +7721,2 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n+\n@@ -7838,0 +7843,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7850,0 +7856,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7862,0 +7869,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7875,0 +7883,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -7888,0 +7897,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8008,0 +8018,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8020,0 +8031,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8573,0 +8585,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8585,0 +8598,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8598,0 +8612,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8611,0 +8626,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8623,0 +8639,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8636,0 +8653,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_carry_flag, PD::Flag_sets_parity_flag);\n@@ -8662,0 +8680,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8674,0 +8693,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8686,0 +8706,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8698,0 +8719,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8710,0 +8732,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -8722,0 +8745,1 @@\n+  flag(PD::Flag_sets_overflow_flag, PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag);\n@@ -9203,0 +9227,1 @@\n+\n@@ -9857,0 +9882,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9933,0 +9959,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9946,0 +9973,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9960,0 +9988,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9973,0 +10002,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -9987,0 +10017,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10001,0 +10032,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10015,0 +10047,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10028,0 +10061,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10041,0 +10075,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10056,0 +10091,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10071,0 +10107,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10086,0 +10123,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10101,0 +10139,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10118,0 +10157,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10131,0 +10171,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10144,0 +10185,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10158,0 +10200,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10171,0 +10214,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10185,0 +10229,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10200,0 +10245,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10224,0 +10270,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10237,0 +10284,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10251,0 +10299,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10264,0 +10313,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10278,0 +10328,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10296,0 +10347,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10335,0 +10387,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10348,0 +10401,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10362,0 +10416,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10376,0 +10431,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10407,0 +10463,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10421,0 +10478,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10434,0 +10492,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10447,0 +10506,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10462,0 +10522,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10477,0 +10538,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_clears_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10492,0 +10554,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10507,0 +10570,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_clears_overflow_flag);\n@@ -10524,0 +10588,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10536,0 +10601,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10550,0 +10616,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10563,0 +10630,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10577,0 +10645,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10591,0 +10660,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10623,0 +10693,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10647,0 +10718,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10660,0 +10732,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10674,0 +10747,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -10688,0 +10762,1 @@\n+  flag(PD::Flag_sets_sign_flag, PD::Flag_sets_zero_flag, PD::Flag_sets_parity_flag, PD::Flag_clears_overflow_flag, PD::Flag_clears_carry_flag);\n@@ -13883,0 +13958,18 @@\n+\/\/ These peephole rules matches instructions which set flags and are followed by a testI\/L_reg\n+\/\/ The test instruction is redudanent in case the downstream instuctions (like JCC or CMOV) only use flags that are already set by the previous instruction\n+\n+\/\/int variant\n+peephole\n+%{\n+  peepmatch (testI_reg);\n+  peepprocedure (test_may_remove);\n+%}\n+\n+\/\/long variant\n+peephole\n+%{\n+  peepmatch (testL_reg);\n+  peepprocedure (test_may_remove);\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":94,"deletions":1,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/methodCounters.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/systemDictionary.hpp\"\n@@ -329,0 +330,6 @@\n+template <typename T>\n+void update_buffered_object_field(address buffered_obj, int field_offset, T value) {\n+  T* field_addr = cast_to_oop(buffered_obj)->field_addr<T>(field_offset);\n+  *field_addr = value;\n+}\n+\n@@ -354,0 +361,14 @@\n+  \/\/ These native pointers will be restored explicitly at run time.\n+  if (java_lang_Module::is_instance(src_obj)) {\n+    update_buffered_object_field<ModuleEntry*>(to, java_lang_Module::module_entry_offset(), nullptr);\n+  } else if (java_lang_ClassLoader::is_instance(src_obj)) {\n+#ifdef ASSERT\n+    \/\/ We only archive these loaders\n+    if (src_obj != SystemDictionary::java_platform_loader() &&\n+        src_obj != SystemDictionary::java_system_loader()) {\n+      assert(src_obj->klass()->name()->equals(\"jdk\/internal\/loader\/ClassLoaders$BootClassLoader\"), \"must be\");\n+    }\n+#endif\n+    update_buffered_object_field<ClassLoaderData*>(to, java_lang_ClassLoader::loader_data_offset(), nullptr);\n+  }\n+\n@@ -470,1 +491,1 @@\n-    int src_hash = src_obj->identity_hash();\n+    intptr_t src_hash = src_obj->identity_hash();\n@@ -478,2 +499,2 @@\n-    DEBUG_ONLY(int archived_hash = fake_oop->identity_hash());\n-    assert(src_hash == archived_hash, \"Different hash codes: original %x, archived %x\", src_hash, archived_hash);\n+    DEBUG_ONLY(intptr_t archived_hash = fake_oop->identity_hash());\n+    assert(src_hash == archived_hash, \"Different hash codes: original \" INTPTR_FORMAT \", archived \" INTPTR_FORMAT, src_hash, archived_hash);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-  _num_module_paths = ClassLoader::num_module_path_entries();\n+  _num_module_paths = ClassLoader::num_module_path_entries();\n@@ -359,1 +359,1 @@\n-  if (ent->is_jar() && !ent->is_signed() && ent->manifest() != nullptr) {\n+  if (ent->is_jar() && ent->manifest() != nullptr) {\n@@ -613,23 +613,0 @@\n-\n-  \/\/ The return value indicates if the JAR is signed or not\n-  bool check_is_signed() {\n-    u1* attr = _current;\n-    bool isSigned = false;\n-    while (_current < _buffer_end) {\n-      if (*_current == '\\n') {\n-        *_current = '\\0';\n-        u1* value = (u1*)strchr((char*)attr, ':');\n-        if (value != nullptr) {\n-          assert(*(value+1) == ' ', \"Unrecognized format\" );\n-          if (strstr((char*)attr, \"-Digest\") != nullptr) {\n-            isSigned = true;\n-            break;\n-          }\n-        }\n-        *_current = '\\n'; \/\/ restore\n-        attr = _current + 1;\n-      }\n-      _current ++;\n-    }\n-    return isSigned;\n-  }\n@@ -648,12 +625,8 @@\n-    if (stream->check_is_signed()) {\n-      ent->set_is_signed();\n-    } else {\n-      \/\/ Copy the manifest into the shared archive\n-      manifest = ClassLoaderExt::read_raw_manifest(THREAD, cpe, &manifest_size);\n-      Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n-                                                      manifest_size,\n-                                                      CHECK);\n-      char* p = (char*)(buf->data());\n-      memcpy(p, manifest, manifest_size);\n-      ent->set_manifest(buf);\n-    }\n+    \/\/ Copy the manifest into the shared archive\n+    manifest = ClassLoaderExt::read_raw_manifest(THREAD, cpe, &manifest_size);\n+    Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n+                                                    manifest_size,\n+                                                    CHECK);\n+    char* p = (char*)(buf->data());\n+    memcpy(p, manifest, manifest_size);\n+    ent->set_manifest(buf);\n@@ -1688,0 +1661,14 @@\n+\/*\n+ * Same as os::map_memory() but also pretouches if AlwaysPreTouch is enabled.\n+ *\/\n+char* map_memory(int fd, const char* file_name, size_t file_offset,\n+                 char *addr, size_t bytes, bool read_only,\n+                 bool allow_exec, MEMFLAGS flags = mtNone) {\n+  char* mem = os::map_memory(fd, file_name, file_offset, addr, bytes,\n+                             AlwaysPreTouch ? false : read_only,\n+                             allow_exec, flags);\n+  if (mem != nullptr && AlwaysPreTouch) {\n+    os::pretouch_memory(mem, mem + bytes);\n+  }\n+  return mem;\n+}\n@@ -1823,3 +1810,3 @@\n-    char* base = os::map_memory(_fd, _full_path, r->file_offset(),\n-                                requested_addr, size, r->read_only(),\n-                                r->allow_exec(), mtClassShared);\n+    char* base = map_memory(_fd, _full_path, r->file_offset(),\n+                            requested_addr, size, r->read_only(),\n+                            r->allow_exec(), mtClassShared);\n@@ -1851,2 +1838,2 @@\n-  char* bitmap_base = os::map_memory(_fd, _full_path, r->file_offset(),\n-                                     requested_addr, r->used_aligned(), read_only, allow_exec, mtClassShared);\n+  char* bitmap_base = map_memory(_fd, _full_path, r->file_offset(),\n+                                 requested_addr, r->used_aligned(), read_only, allow_exec, mtClassShared);\n@@ -2132,3 +2119,3 @@\n-  char* base = os::map_memory(_fd, _full_path, r->file_offset(),\n-                              addr, _mapped_heap_memregion.byte_size(), r->read_only(),\n-                              r->allow_exec());\n+  char* base = map_memory(_fd, _full_path, r->file_offset(),\n+                          addr, _mapped_heap_memregion.byte_size(), r->read_only(),\n+                          r->allow_exec());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":32,"deletions":45,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    signed_jar_entry,\n@@ -93,4 +92,0 @@\n-  bool is_signed()        const { return _type == signed_jar_entry; }\n-  void set_is_signed() {\n-    _type = signed_jar_entry;\n-  }\n@@ -221,1 +216,1 @@\n-  jshort _num_module_paths;             \/\/ number of module path entries\n+  int    _num_module_paths;             \/\/ number of module path entries\n@@ -281,1 +276,1 @@\n-  jshort num_module_paths()                const { return _num_module_paths; }\n+  int    num_module_paths()                const { return _num_module_paths; }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -666,7 +666,0 @@\n-\n-#if INCLUDE_CDS_JAVA_HEAP\n-  \/\/ Restore the java loaders that were cleared at dump time\n-  if (use_full_module_graph()) {\n-    HeapShared::restore_loader_data();\n-  }\n-#endif\n@@ -1331,2 +1324,6 @@\n-      \/\/ Reserve at any address, but leave it up to the platform to choose a good one.\n-      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size);\n+      \/\/ We did not manage to reserve at the preferred address, or were instructed to relocate. In that\n+      \/\/ case we reserve whereever possible, but the start address needs to be encodable as narrow Klass\n+      \/\/ encoding base since the archived heap objects contain nKlass IDs precalculated toward the start\n+      \/\/ of the shared Metaspace. That prevents us from using zero-based encoding and therefore we won't\n+      \/\/ try allocating in low-address regions.\n+      total_space_rs = Metaspace::reserve_address_space_for_compressed_classes(total_range_size, false \/* try_in_low_address_ranges *\/);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -233,2 +233,3 @@\n-        tty->print_cr(\"Decoding VtableStub %s[%d]@\" INTX_FORMAT,\n-                      is_vtable_stub? \"vtbl\": \"itbl\", vtable_index, p2i(VtableStub::receiver_location()));\n+        tty->print_cr(\"Decoding VtableStub %s[%d]@\" PTR_FORMAT \" [\" PTR_FORMAT \", \" PTR_FORMAT \"] (\" SIZE_FORMAT \" bytes)\",\n+                      is_vtable_stub? \"vtbl\": \"itbl\", vtable_index, p2i(VtableStub::receiver_location()),\n+                      p2i(s->code_begin()), p2i(s->code_end()), pointer_delta(s->code_end(), s->code_begin(), 1));\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2205,2 +2205,2 @@\n-  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n-            capacity()\/K, heap_used\/K);\n+  st->print(\" total reserved %zuK, committed %zuK, used %zuK\",\n+            _hrm.reserved().byte_size()\/K, capacity()\/K, heap_used\/K);\n@@ -2222,1 +2222,1 @@\n-    const int* node_ids = _numa->node_ids();\n+    const uint* node_ids = _numa->node_ids();\n@@ -2225,1 +2225,1 @@\n-      st->print(\"%d=%u \", node_ids[node_index], num_free_regions);\n+      st->print(\"%u=%u \", node_ids[node_index], num_free_regions);\n@@ -3015,2 +3015,1 @@\n-      \/\/ HeapRegion::add_code_root_locked() avoids adding duplicate entries.\n-      hr->add_code_root_locked(_nm);\n+      hr->add_code_root(_nm);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -181,2 +181,1 @@\n-  uint queue_size;\n-  queue_size = claimed_stack_depth()->max_elems();\n+  uint queue_size = claimed_stack_depth()->max_elems();\n@@ -187,3 +186,1 @@\n-    \/\/ don't let the target stack size to be more than 1\/4 of the entries\n-    _target_stack_size = (uint) MIN2((uint) GCDrainStackTargetSize,\n-                                     (uint) (queue_size \/ 4));\n+    _target_stack_size = GCDrainStackTargetSize;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -340,1 +340,1 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  SerialHeap* gch = SerialHeap::heap();\n@@ -559,1 +559,1 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  SerialHeap* gch = SerialHeap::heap();\n@@ -695,1 +695,1 @@\n-                        GenCollectedHeap::heap()->incremental_collection_will_fail(false \/* don't consult_young *\/) ?\n+                        SerialHeap::heap()->incremental_collection_will_fail(false \/* don't consult_young *\/) ?\n@@ -719,1 +719,1 @@\n-    GCPolicyCounters* gc_counters = GenCollectedHeap::heap()->counters();\n+    GCPolicyCounters* gc_counters = SerialHeap::heap()->counters();\n@@ -849,2 +849,0 @@\n-    \/\/ Inform the next generation that a promotion failure occurred.\n-    _old_gen->promotion_failure_occurred();\n@@ -1014,2 +1012,1 @@\n-    GenCollectedHeap* gch = GenCollectedHeap::heap();\n-    _old_gen = gch->old_gen();\n+    _old_gen = SerialHeap::heap()->old_gen();\n@@ -1028,1 +1025,1 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  SerialHeap* gch = SerialHeap::heap();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"gc\/serial\/serialHeap.hpp\"\n@@ -44,1 +45,0 @@\n-#include \"gc\/shared\/genCollectedHeap.hpp\"\n@@ -72,1 +72,1 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  SerialHeap* gch = SerialHeap::heap();\n@@ -137,1 +137,1 @@\n-  DefNewGeneration* young_gen = (DefNewGeneration*)GenCollectedHeap::heap()->young_gen();\n+  DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n@@ -155,1 +155,1 @@\n-    DefNewGeneration* young_gen = (DefNewGeneration*)GenCollectedHeap::heap()->young_gen();\n+    DefNewGeneration* young_gen = (DefNewGeneration*)SerialHeap::heap()->young_gen();\n@@ -168,1 +168,1 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  SerialHeap* gch = SerialHeap::heap();\n@@ -179,1 +179,1 @@\n-    gch->process_roots(GenCollectedHeap::SO_None,\n+    gch->process_roots(SerialHeap::SO_None,\n@@ -233,1 +233,1 @@\n-  GenCollectedHeap::heap()->prepare_for_compaction();\n+  SerialHeap::heap()->prepare_for_compaction();\n@@ -236,1 +236,1 @@\n-class GenAdjustPointersClosure: public GenCollectedHeap::GenClosure {\n+class GenAdjustPointersClosure: public SerialHeap::GenClosure {\n@@ -244,1 +244,1 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n+  SerialHeap* gch = SerialHeap::heap();\n@@ -255,1 +255,1 @@\n-    gch->process_roots(GenCollectedHeap::SO_AllCodeCache,\n+    gch->process_roots(SerialHeap::SO_AllCodeCache,\n@@ -266,1 +266,1 @@\n-    gch->process_roots(GenCollectedHeap::SO_AllCodeCache,\n+    gch->process_roots(SerialHeap::SO_AllCodeCache,\n@@ -279,1 +279,1 @@\n-class GenCompactClosure: public GenCollectedHeap::GenClosure {\n+class GenCompactClosure: public SerialHeap::GenClosure {\n@@ -291,1 +291,1 @@\n-  GenCollectedHeap::heap()->generation_iterate(&blk, true);\n+  SerialHeap::heap()->generation_iterate(&blk, true);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-\/\/ GenCollectedHeap using a four-phase pointer forwarding algorithm.  All\n+\/\/ SerialHeap using a four-phase pointer forwarding algorithm.  All\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-  \/\/ that of GenCollectedHeap::ensure_parsability().\n+  \/\/ that of ParallelScavengeHeap::ensure_parsability().\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -687,1 +687,1 @@\n-  product(uintx, GCDrainStackTargetSize, 64,                                \\\n+  product(uint, GCDrainStackTargetSize, 64,                                 \\\n@@ -690,1 +690,1 @@\n-          range(0, max_juint)                                               \\\n+          range(0, 8 * 1024)                                                \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"gc\/shared\/adaptiveSizePolicy.hpp\"\n@@ -838,5 +837,0 @@\n-void GenCollectedHeap::oop_iterate(OopIterateClosure* cl) {\n-  _young_gen->oop_iterate(cl);\n-  _old_gen->oop_iterate(cl);\n-}\n-\n@@ -848,10 +842,0 @@\n-Space* GenCollectedHeap::space_containing(const void* addr) const {\n-  Space* res = _young_gen->space_containing(addr);\n-  if (res != nullptr) {\n-    return res;\n-  }\n-  res = _old_gen->space_containing(addr);\n-  assert(res != nullptr, \"Could not find containing space\");\n-  return res;\n-}\n-\n@@ -1075,13 +1059,0 @@\n-\n-class GenEnsureParsabilityClosure: public GenCollectedHeap::GenClosure {\n- public:\n-  void do_generation(Generation* gen) {\n-    gen->ensure_parsability();\n-  }\n-};\n-\n-void GenCollectedHeap::ensure_parsability(bool retire_tlabs) {\n-  CollectedHeap::ensure_parsability(retire_tlabs);\n-  GenEnsureParsabilityClosure ep_cl;\n-  generation_iterate(&ep_cl, false);\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -50,103 +50,0 @@\n-HeapWord* DirtyCardToOopClosure::get_actual_top(HeapWord* top,\n-                                                HeapWord* top_obj) {\n-  if (top_obj != nullptr && top_obj < (_sp->toContiguousSpace())->top()) {\n-    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-      \/\/ An arrayOop is starting on the dirty card - since we do exact\n-      \/\/ store checks for objArrays we are done.\n-    } else {\n-      \/\/ Otherwise, it is possible that the object starting on the dirty\n-      \/\/ card spans the entire card, and that the store happened on a\n-      \/\/ later card.  Figure out where the object ends.\n-      assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n-             \"Block size and object size mismatch\");\n-      top = top_obj + cast_to_oop(top_obj)->size();\n-    }\n-  } else {\n-    top = (_sp->toContiguousSpace())->top();\n-  }\n-  return top;\n-}\n-\n-void DirtyCardToOopClosure::walk_mem_region(MemRegion mr,\n-                                            HeapWord* bottom,\n-                                            HeapWord* top) {\n-  \/\/ Note that this assumption won't hold if we have a concurrent\n-  \/\/ collector in this space, which may have freed up objects after\n-  \/\/ they were dirtied and before the stop-the-world GC that is\n-  \/\/ examining cards here.\n-  assert(bottom < top, \"ought to be at least one obj on a dirty card.\");\n-\n-  walk_mem_region_with_cl(mr, bottom, top, _cl);\n-}\n-\n-\/\/ We get called with \"mr\" representing the dirty region\n-\/\/ that we want to process. Because of imprecise marking,\n-\/\/ we may need to extend the incoming \"mr\" to the right,\n-\/\/ and scan more. However, because we may already have\n-\/\/ scanned some of that extended region, we may need to\n-\/\/ trim its right-end back some so we do not scan what\n-\/\/ we (or another worker thread) may already have scanned\n-\/\/ or planning to scan.\n-void DirtyCardToOopClosure::do_MemRegion(MemRegion mr) {\n-  HeapWord* bottom = mr.start();\n-  HeapWord* last = mr.last();\n-  HeapWord* top = mr.end();\n-  HeapWord* bottom_obj;\n-  HeapWord* top_obj;\n-\n-  assert(_last_bottom == nullptr || top <= _last_bottom,\n-         \"Not decreasing\");\n-  NOT_PRODUCT(_last_bottom = mr.start());\n-\n-  bottom_obj = _sp->block_start(bottom);\n-  top_obj    = _sp->block_start(last);\n-\n-  assert(bottom_obj <= bottom, \"just checking\");\n-  assert(top_obj    <= top,    \"just checking\");\n-\n-  \/\/ Given what we think is the top of the memory region and\n-  \/\/ the start of the object at the top, get the actual\n-  \/\/ value of the top.\n-  top = get_actual_top(top, top_obj);\n-\n-  \/\/ If the previous call did some part of this region, don't redo.\n-  if (_min_done != nullptr && _min_done < top) {\n-    top = _min_done;\n-  }\n-\n-  \/\/ Top may have been reset, and in fact may be below bottom,\n-  \/\/ e.g. the dirty card region is entirely in a now free object\n-  \/\/ -- something that could happen with a concurrent sweeper.\n-  bottom = MIN2(bottom, top);\n-  MemRegion extended_mr = MemRegion(bottom, top);\n-  assert(bottom <= top &&\n-         (_min_done == nullptr || top <= _min_done),\n-         \"overlap!\");\n-\n-  \/\/ Walk the region if it is not empty; otherwise there is nothing to do.\n-  if (!extended_mr.is_empty()) {\n-    walk_mem_region(extended_mr, bottom_obj, top);\n-  }\n-\n-  _min_done = bottom;\n-}\n-\n-void DirtyCardToOopClosure::walk_mem_region_with_cl(MemRegion mr,\n-                                                    HeapWord* bottom,\n-                                                    HeapWord* top,\n-                                                    OopIterateClosure* cl) {\n-  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);\n-  if (bottom < top) {\n-    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();\n-    while (next_obj < top) {\n-      \/* Bottom lies entirely below top, so we can call the *\/\n-      \/* non-memRegion version of oop_iterate below. *\/\n-      cast_to_oop(bottom)->oop_iterate(cl);\n-      bottom = next_obj;\n-      next_obj = bottom + cast_to_oop(bottom)->size();\n-    }\n-    \/* Last object. *\/\n-    cast_to_oop(bottom)->oop_iterate(cl, mr);\n-  }\n-}\n-\n@@ -549,5 +446,0 @@\n-void Space::oop_iterate(OopIterateClosure* blk) {\n-  ObjectToOopClosure blk2(blk);\n-  object_iterate(&blk2);\n-}\n-\n@@ -559,10 +451,0 @@\n-void ContiguousSpace::oop_iterate(OopIterateClosure* blk) {\n-  if (is_empty()) return;\n-  HeapWord* obj_addr = bottom();\n-  HeapWord* t = top();\n-  \/\/ Could call objects iterate, but this is easier.\n-  while (obj_addr < t) {\n-    obj_addr += cast_to_oop(obj_addr)->oop_iterate_size(blk);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":118,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -166,5 +166,0 @@\n-  \/\/ Iterate over all the ref-containing fields of all objects in the\n-  \/\/ space, calling \"cl.do_oop\" on each.  Fields in objects allocated by\n-  \/\/ applications of the closure are not included in the iteration.\n-  virtual void oop_iterate(OopIterateClosure* cl);\n-\n@@ -219,6 +214,0 @@\n-\n-  \/\/ IF \"this\" is a ContiguousSpace, return it, else return null.\n-  virtual ContiguousSpace* toContiguousSpace() {\n-    return nullptr;\n-  }\n-\n@@ -229,59 +218,0 @@\n-\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n-\/\/ sub-classes). It knows how to filter out objects that are outside of the\n-\/\/ _boundary.\n-\/\/ (Note that because of the imprecise nature of the write barrier, this may\n-\/\/ iterate over oops beyond the region.)\n-\/\/\n-\/\/ Assumptions:\n-\/\/ 1. That the actual top of any area in a memory region\n-\/\/    contained by the space is bounded by the end of the contiguous\n-\/\/    region of the space.\n-\/\/ 2. That the space is really made up of objects and not just\n-\/\/    blocks.\n-\n-class DirtyCardToOopClosure: public MemRegionClosure {\n-protected:\n-  OopIterateClosure* _cl;\n-  Space* _sp;\n-  HeapWord* _min_done;          \/\/ Need a downwards traversal to compensate\n-                                \/\/ imprecise write barrier; this is the\n-                                \/\/ lowest location already done (or,\n-                                \/\/ alternatively, the lowest address that\n-                                \/\/ shouldn't be done again.  null means infinity.)\n-  NOT_PRODUCT(HeapWord* _last_bottom;)\n-\n-  \/\/ Get the actual top of the area on which the closure will\n-  \/\/ operate, given where the top is assumed to be (the end of the\n-  \/\/ memory region passed to do_MemRegion) and where the object\n-  \/\/ at the top is assumed to start. For example, an object may\n-  \/\/ start at the top but actually extend past the assumed top,\n-  \/\/ in which case the top becomes the end of the object.\n-  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n-\n-  \/\/ Walk the given memory region from bottom to (actual) top\n-  \/\/ looking for objects and applying the oop closure (_cl) to\n-  \/\/ them. The base implementation of this treats the area as\n-  \/\/ blocks, where a block may or may not be an object. Sub-\n-  \/\/ classes should override this to provide more accurate\n-  \/\/ or possibly more efficient walking.\n-  void walk_mem_region(MemRegion mr, HeapWord* bottom, HeapWord* top);\n-\n-  \/\/ Walk the given memory region, from bottom to top, applying\n-  \/\/ the given oop closure to (possibly) all objects found. The\n-  \/\/ given oop closure may or may not be the same as the oop\n-  \/\/ closure with which this closure was created, as it may\n-  \/\/ be a filtering closure which makes use of the _boundary.\n-  \/\/ We offer two signatures, so the FilteringClosure static type is\n-  \/\/ apparent.\n-  void walk_mem_region_with_cl(MemRegion mr,\n-                               HeapWord* bottom, HeapWord* top,\n-                               OopIterateClosure* cl);\n-public:\n-  DirtyCardToOopClosure(Space* sp, OopIterateClosure* cl) :\n-    _cl(cl), _sp(sp), _min_done(nullptr) {\n-    NOT_PRODUCT(_last_bottom = nullptr);\n-  }\n-\n-  void do_MemRegion(MemRegion mr) override;\n-};\n-\n@@ -459,1 +389,0 @@\n-  void oop_iterate(OopIterateClosure* cl) override;\n@@ -495,5 +424,0 @@\n-  \/\/ Checked dynamic downcasts.\n-  ContiguousSpace* toContiguousSpace() override {\n-    return this;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":0,"deletions":76,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -884,15 +884,5 @@\n-    \/\/ strategy is to try again, as long as GC makes progress.\n-    \/\/\n-    \/\/ Then, we need to make sure the allocation was retried after at least one\n-    \/\/ Full GC, which means we want to try more than ShenandoahFullGCThreshold times.\n-\n-    size_t tries = 0;\n-\n-    while (result == nullptr && _progress_last_gc.is_set()) {\n-      tries++;\n-      control_thread()->handle_alloc_failure(req);\n-      result = allocate_memory_under_lock(req, in_new_region);\n-    }\n-\n-    while (result == nullptr && tries <= ShenandoahFullGCThreshold) {\n-      tries++;\n+    \/\/ strategy is to try again, as long as GC makes progress (or until at least\n+    \/\/ one full GC has completed).\n+    size_t original_count = shenandoah_policy()->full_gc_count();\n+    while (result == nullptr\n+        && (_progress_last_gc.is_set() || original_count == shenandoah_policy()->full_gc_count())) {\n@@ -902,1 +892,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -174,1 +175,1 @@\n-  JNI_JVMCIENV(JVMCI::compilation_tick(thread), env);\n+  JVMCIENV_FROM_JNI(JVMCI::compilation_tick(thread), env);\n@@ -624,4 +625,1 @@\n-    resolved_klass = SystemDictionary::resolve_or_null(class_name, class_loader, protection_domain, CHECK_NULL);\n-    if (resolved_klass == nullptr) {\n-      JVMCI_THROW_MSG_NULL(NoClassDefFoundError, str);\n-    }\n+    resolved_klass = SystemDictionary::resolve_or_fail(class_name, class_loader, protection_domain, true, CHECK_NULL);\n@@ -780,3 +778,5 @@\n-  for (int i = 0; i < cp->resolved_indy_entries_length(); i++) {\n-    if (cp->resolved_indy_entry_at(i)->constant_pool_index() == index) {\n-      indy_index = i;\n+  if (is_indy) {\n+    for (int i = 0; i < cp->resolved_indy_entries_length(); i++) {\n+      if (cp->resolved_indy_entry_at(i)->constant_pool_index() == index) {\n+        indy_index = i;\n+      }\n@@ -848,0 +848,5 @@\n+C2V_VMENTRY_0(jint, bootstrapArgumentIndexAt, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint cpi, jint index))\n+  constantPoolHandle cp(THREAD, UNPACK_PAIR(ConstantPool, cp));\n+  return cp->bootstrap_argument_index_at(cpi, index);\n+C2V_END\n+\n@@ -913,1 +918,1 @@\n-C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_NULL(jobject, lookupAppendixInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint which))\n@@ -915,1 +920,1 @@\n-  oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, index);\n+  oop appendix_oop = ConstantPool::appendix_at_if_loaded(cp, which);\n@@ -1284,0 +1289,12 @@\n+static MethodData* get_profiling_method_data(const methodHandle& method, TRAPS) {\n+  MethodData* method_data = method->method_data();\n+  if (method_data == nullptr) {\n+    method->build_profiling_method_data(method, CHECK_NULL);\n+    method_data = method->method_data();\n+    if (method_data == nullptr) {\n+      THROW_MSG_NULL(vmSymbols::java_lang_OutOfMemoryError(), \"cannot allocate MethodData\")\n+    }\n+  }\n+  return method_data;\n+}\n+\n@@ -1299,3 +1316,1 @@\n-    ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n-    method_data = MethodData::allocate(loader_data, method, CHECK);\n-    method->set_method_data(method_data);\n+    method_data = get_profiling_method_data(method, CHECK);\n@@ -2446,6 +2461,3 @@\n-    bool jni_enomem_is_fatal = false;\n-    JVMCIEnv __peer_jvmci_env__(thread, false, jni_enomem_is_fatal, __FILE__, __LINE__);\n-    JVMCIEnv* peerEnv = &__peer_jvmci_env__;\n-    if (peerEnv->has_jni_enomem()) {\n-      JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n-    }\n+    PEER_JVMCIENV_FROM_THREAD(THREAD, false);\n+    PEER_JVMCIENV->check_init(JVMCI_CHECK_NULL);\n+\n@@ -2454,2 +2466,2 @@\n-    if (peerEnv->has_pending_exception()) {\n-      peerEnv->describe_pending_exception(tty);\n+    if (PEER_JVMCIENV->has_pending_exception()) {\n+      PEER_JVMCIENV->describe_pending_exception(tty);\n@@ -2525,1 +2537,1 @@\n-}\n+C2V_END\n@@ -2614,6 +2626,2 @@\n-      bool jni_enomem_is_fatal = false;\n-      JVMCIEnv __peer_jvmci_env__(thread, false, jni_enomem_is_fatal, __FILE__, __LINE__);\n-      JVMCIEnv* peerJVMCIEnv = &__peer_jvmci_env__;\n-      if (peerJVMCIEnv->has_jni_enomem()) {\n-        JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n-      }\n+      PEER_JVMCIENV_FROM_THREAD(THREAD, false);\n+      PEER_JVMCIENV->check_init(JVMCI_CHECK_0);\n@@ -2622,3 +2630,3 @@\n-      JVMCIObject receiver = runtime->get_HotSpotJVMCIRuntime(peerJVMCIEnv);\n-      if (peerJVMCIEnv->has_pending_exception()) {\n-        peerJVMCIEnv->describe_pending_exception(tty);\n+      JVMCIObject receiver = runtime->get_HotSpotJVMCIRuntime(PEER_JVMCIENV);\n+      if (PEER_JVMCIENV->has_pending_exception()) {\n+        PEER_JVMCIENV->describe_pending_exception(tty);\n@@ -2714,7 +2722,2 @@\n-  bool jni_enomem_is_fatal = false;\n-  JVMCIEnv __peer_jvmci_env__(thread, !JVMCIENV->is_hotspot(), jni_enomem_is_fatal, __FILE__, __LINE__);\n-  JVMCIEnv* peerEnv = &__peer_jvmci_env__;\n-  JVMCIEnv* thisEnv = JVMCIENV;\n-  if (peerEnv->has_jni_enomem()) {\n-      JVMCI_THROW_MSG_0(OutOfMemoryError, \"JNI_ENOMEM creating or attaching to libjvmci\");\n-  }\n+  PEER_JVMCIENV_FROM_THREAD(THREAD, !JVMCIENV->is_hotspot());\n+  PEER_JVMCIENV->check_init(JVMCI_CHECK_0);\n@@ -2722,0 +2725,1 @@\n+  JVMCIEnv* thisEnv = JVMCIENV;\n@@ -2726,1 +2730,1 @@\n-    result = peerEnv->get_jvmci_method(method, JVMCI_CHECK_0);\n+    result = PEER_JVMCIENV->get_jvmci_method(method, JVMCI_CHECK_0);\n@@ -2731,1 +2735,1 @@\n-    result = peerEnv->get_jvmci_type(klass_handle, JVMCI_CHECK_0);\n+    result = PEER_JVMCIENV->get_jvmci_type(klass_handle, JVMCI_CHECK_0);\n@@ -2734,1 +2738,1 @@\n-    result = peerEnv->get_jvmci_primitive_type(type);\n+    result = PEER_JVMCIENV->get_jvmci_primitive_type(type);\n@@ -2738,1 +2742,1 @@\n-    result = peerEnv->get_object_constant(constant());\n+    result = PEER_JVMCIENV->get_object_constant(constant());\n@@ -2740,1 +2744,1 @@\n-    if (peerEnv->is_hotspot()) {\n+    if (PEER_JVMCIENV->is_hotspot()) {\n@@ -2763,1 +2767,1 @@\n-      result = peerEnv->new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);\n+      result = PEER_JVMCIENV->new_HotSpotNmethod(mh, cstring, isDefault, compileIdSnapshot, JVMCI_CHECK_0);\n@@ -2771,1 +2775,1 @@\n-        peerEnv->initialize_installed_code(result, nm, JVMCI_CHECK_0);\n+        PEER_JVMCIENV->initialize_installed_code(result, nm, JVMCI_CHECK_0);\n@@ -2773,1 +2777,1 @@\n-        if (peerEnv->is_hotspot()) {\n+        if (PEER_JVMCIENV->is_hotspot()) {\n@@ -2791,1 +2795,1 @@\n-    peerEnv->call_HotSpotJVMCIRuntime_postTranslation(result, JVMCI_CHECK_0);\n+    PEER_JVMCIENV->call_HotSpotJVMCIRuntime_postTranslation(result, JVMCI_CHECK_0);\n@@ -2794,1 +2798,1 @@\n-  if (peerEnv->transfer_pending_exception(thread, thisEnv)) {\n+  if (PEER_JVMCIENV->transfer_pending_exception(thread, thisEnv)) {\n@@ -2797,2 +2801,2 @@\n-  return (jlong) peerEnv->make_global(result).as_jobject();\n-}\n+  return (jlong) PEER_JVMCIENV->make_global(result).as_jobject();\n+C2V_END\n@@ -2811,1 +2815,1 @@\n-}\n+C2V_END\n@@ -2817,1 +2821,1 @@\n-}\n+C2V_END\n@@ -2833,1 +2837,1 @@\n-}\n+C2V_END\n@@ -2849,1 +2853,1 @@\n-}\n+C2V_END\n@@ -2871,1 +2875,1 @@\n-}\n+C2V_END\n@@ -2985,1 +2989,1 @@\n-}\n+C2V_END\n@@ -2989,6 +2993,1 @@\n-  MethodData* method_data = method->method_data();\n-  if (method_data == nullptr) {\n-    ClassLoaderData* loader_data = method->method_holder()->class_loader_data();\n-    method_data = MethodData::allocate(loader_data, method, CHECK_0);\n-    method->set_method_data(method_data);\n-  }\n+  MethodData* method_data = get_profiling_method_data(method, CHECK_0);\n@@ -2996,1 +2995,1 @@\n-}\n+C2V_END\n@@ -3000,1 +2999,1 @@\n-}\n+C2V_END\n@@ -3008,1 +3007,1 @@\n-}\n+C2V_END\n@@ -3020,1 +3019,1 @@\n-}\n+C2V_END\n@@ -3024,1 +3023,1 @@\n-}\n+C2V_END\n@@ -3034,1 +3033,1 @@\n-}\n+C2V_END\n@@ -3041,1 +3040,1 @@\n-}\n+C2V_END\n@@ -3051,1 +3050,1 @@\n-}\n+C2V_END\n@@ -3061,1 +3060,1 @@\n-}\n+C2V_END\n@@ -3070,1 +3069,1 @@\n-}\n+C2V_END\n@@ -3082,1 +3081,1 @@\n-}\n+C2V_END\n@@ -3094,1 +3093,43 @@\n-}\n+C2V_END\n+\n+C2V_VMENTRY(void, getOopMapAt, (JNIEnv* env, jobject, ARGUMENT_PAIR(method),\n+                 jint bci, jlongArray oop_map_handle))\n+  methodHandle method(THREAD, UNPACK_PAIR(Method, method));\n+  if (bci < 0 || bci >= method->code_size()) {\n+    JVMCI_THROW_MSG(IllegalArgumentException,\n+                err_msg(\"bci %d is out of bounds [0 .. %d)\", bci, method->code_size()));\n+  }\n+  InterpreterOopMap mask;\n+  OopMapCache::compute_one_oop_map(method, bci, &mask);\n+  if (!mask.has_valid_mask()) {\n+    JVMCI_THROW_MSG(IllegalArgumentException, err_msg(\"bci %d is not valid\", bci));\n+  }\n+  if (mask.number_of_entries() == 0) {\n+    return;\n+  }\n+\n+  int nslots = method->max_locals() + method->max_stack();\n+  int nwords = ((nslots - 1) \/ 64) + 1;\n+  JVMCIPrimitiveArray oop_map = JVMCIENV->wrap(oop_map_handle);\n+  int oop_map_len = JVMCIENV->get_length(oop_map);\n+  if (nwords > oop_map_len) {\n+    JVMCI_THROW_MSG(IllegalArgumentException,\n+                err_msg(\"oop map too short: %d > %d\", nwords, oop_map_len));\n+  }\n+\n+  jlong* oop_map_buf = NEW_RESOURCE_ARRAY_IN_THREAD_RETURN_NULL(THREAD, jlong, nwords);\n+  if (oop_map_buf == nullptr) {\n+    JVMCI_THROW_MSG(InternalError, err_msg(\"could not allocate %d longs\", nwords));\n+  }\n+  for (int i = 0; i < nwords; i++) {\n+    oop_map_buf[i] = 0L;\n+  }\n+\n+  BitMapView oop_map_view = BitMapView((BitMap::bm_word_t*) oop_map_buf, nwords * BitsPerLong);\n+  for (int i = 0; i < nslots; i++) {\n+    if (mask.is_oop(i)) {\n+      oop_map_view.set_bit(i);\n+    }\n+  }\n+  JVMCIENV->copy_longs_from((jlong*)oop_map_buf, oop_map, 0, nwords);\n+C2V_END\n@@ -3155,0 +3196,1 @@\n+  {CC \"bootstrapArgumentIndexAt\",                     CC \"(\" HS_CONSTANT_POOL2 \"II)I\",                                                      FN_PTR(bootstrapArgumentIndexAt)},\n@@ -3253,0 +3295,1 @@\n+  {CC \"getOopMapAt\",                                  CC \"(\" HS_METHOD2 \"I[J)V\",                                                            FN_PTR(getOopMapAt)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":117,"deletions":74,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -584,1 +584,3 @@\n-    log_trace(cds, unshareable)(\"restore: %s\", external_name());\n+    oop class_loader = loader_data->class_loader();\n+    log_trace(cds, unshareable)(\"restore: %s with class loader: %s\", external_name(),\n+      class_loader != nullptr ? class_loader->klass()->external_name() : \"boot\");\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"oops\/arrayKlass.inline.hpp\"\n+#include \"oops\/arrayKlass.hpp\"\n@@ -308,57 +308,0 @@\n-\n-ArrayKlass* ObjArrayKlass::array_klass(int n, TRAPS) {\n-\n-  assert(dimension() <= n, \"check order of chain\");\n-  int dim = dimension();\n-  if (dim == n) return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-\n-    ResourceMark rm(THREAD);\n-    {\n-      \/\/ Ensure atomic creation of higher dimensions\n-      MutexLocker mu(THREAD, MultiArray_lock);\n-\n-      \/\/ Check if another thread beat us\n-      if (higher_dimension() == nullptr) {\n-\n-        \/\/ Create multi-dim klass object and link them together\n-        ObjArrayKlass* ak =\n-          ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);\n-        ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(ak);\n-        assert(ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n-    }\n-  }\n-\n-  ObjArrayKlass *ak = higher_dimension();\n-  THREAD->check_possible_safepoint();\n-  return ak->array_klass(n, THREAD);\n-}\n-\n-ArrayKlass* ObjArrayKlass::array_klass_or_null(int n) {\n-\n-  assert(dimension() <= n, \"check order of chain\");\n-  int dim = dimension();\n-  if (dim == n) return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-    return nullptr;\n-  }\n-\n-  ObjArrayKlass *ak = higher_dimension();\n-  return ak->array_klass_or_null(n);\n-}\n-\n-ArrayKlass* ObjArrayKlass::array_klass(TRAPS) {\n-  return array_klass(dimension() +  1, THREAD);\n-}\n-\n-ArrayKlass* ObjArrayKlass::array_klass_or_null() {\n-  return array_klass_or_null(dimension() +  1);\n-}\n-\n@@ -456,1 +399,1 @@\n-  int print_len = MIN2((intx) oa->length(), MaxElementPrintSize);\n+  int print_len = MIN2(oa->length(), MaxElementPrintSize);\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":2,"deletions":59,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"oops\/arrayKlass.inline.hpp\"\n+#include \"oops\/arrayKlass.hpp\"\n@@ -173,57 +173,0 @@\n-\/\/ create a klass of array holding typeArrays\n-ArrayKlass* TypeArrayKlass::array_klass(int n, TRAPS) {\n-  int dim = dimension();\n-  assert(dim <= n, \"check order of chain\");\n-    if (dim == n)\n-      return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-\n-    ResourceMark rm;\n-    JavaThread *jt = THREAD;\n-    {\n-      \/\/ Atomic create higher dimension and link into list\n-      MutexLocker mu(THREAD, MultiArray_lock);\n-\n-      if (higher_dimension() == nullptr) {\n-        Klass* oak = ObjArrayKlass::allocate_objArray_klass(\n-              class_loader_data(), dim + 1, this, CHECK_NULL);\n-        ObjArrayKlass* h_ak = ObjArrayKlass::cast(oak);\n-        h_ak->set_lower_dimension(this);\n-        \/\/ use 'release' to pair with lock-free load\n-        release_set_higher_dimension(h_ak);\n-        assert(h_ak->is_objArray_klass(), \"incorrect initialization of ObjArrayKlass\");\n-      }\n-    }\n-  }\n-\n-  ObjArrayKlass* h_ak = higher_dimension();\n-  THREAD->check_possible_safepoint();\n-  return h_ak->array_klass(n, THREAD);\n-}\n-\n-\/\/ return existing klass of array holding typeArrays\n-ArrayKlass* TypeArrayKlass::array_klass_or_null(int n) {\n-  int dim = dimension();\n-  assert(dim <= n, \"check order of chain\");\n-    if (dim == n)\n-      return this;\n-\n-  \/\/ lock-free read needs acquire semantics\n-  if (higher_dimension_acquire() == nullptr) {\n-    return nullptr;\n-  }\n-\n-  ObjArrayKlass* h_ak = higher_dimension();\n-  return h_ak->array_klass_or_null(n);\n-}\n-\n-ArrayKlass* TypeArrayKlass::array_klass(TRAPS) {\n-  return array_klass(dimension() +  1, THREAD);\n-}\n-\n-ArrayKlass* TypeArrayKlass::array_klass_or_null() {\n-  return array_klass_or_null(dimension() +  1);\n-}\n-\n@@ -347,1 +290,1 @@\n-  int print_len = MIN2((intx) ta->length(), MaxElementPrintSize);\n+  int print_len = MIN2(ta->length(), MaxElementPrintSize);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":2,"deletions":59,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -363,1 +363,2 @@\n-void Compile::remove_useless_nodes(GrowableArray<Node*>& node_list, Unique_Node_List& useful) {\n+template<typename N, ENABLE_IF_SDEFN(std::is_base_of<Node, N>::value)>\n+void Compile::remove_useless_nodes(GrowableArray<N*>& node_list, Unique_Node_List& useful) {\n@@ -365,2 +366,2 @@\n-    Node* n = node_list.at(i);\n-    if (!useful.member(n)) {\n+    N* node = node_list.at(i);\n+    if (!useful.member(node)) {\n@@ -392,0 +393,3 @@\n+  if (dead->is_ParsePredicate()) {\n+    remove_parse_predicate(dead->as_ParsePredicate());\n+  }\n@@ -439,1 +443,1 @@\n-  remove_useless_nodes(_parse_predicate_opaqs, useful); \/\/ remove useless Parse Predicate opaque nodes\n+  remove_useless_nodes(_parse_predicates,   useful); \/\/ remove useless Parse Predicate nodes\n@@ -634,1 +638,1 @@\n-                  _parse_predicate_opaqs (comp_arena(), 8, 0, nullptr),\n+                  _parse_predicates  (comp_arena(), 8, 0, nullptr),\n@@ -1814,3 +1818,3 @@\n-\/\/ Remove the opaque nodes that protect the Parse Predicates so that all unused\n-\/\/ checks and uncommon_traps will be eliminated from the ideal graph.\n-void Compile::cleanup_parse_predicates(PhaseIterGVN& igvn) const {\n+\/\/ Mark all ParsePredicateNodes as useless. They will later be removed from the graph in IGVN together with their\n+\/\/ uncommon traps if no Runtime Predicates were created from the Parse Predicates.\n+void Compile::mark_parse_predicate_nodes_useless(PhaseIterGVN& igvn) {\n@@ -1820,4 +1824,4 @@\n-  for (int i = parse_predicate_count(); i > 0; i--) {\n-    Node* n = parse_predicate_opaque1_node(i - 1);\n-    assert(n->Opcode() == Op_Opaque1, \"must be\");\n-    igvn.replace_node(n, n->in(1));\n+  for (int i = 0; i < parse_predicate_count(); i++) {\n+    ParsePredicateNode* parse_predicate = _parse_predicates.at(i);\n+    parse_predicate->mark_useless();\n+    igvn._worklist.push(parse_predicate);\n@@ -1825,1 +1829,1 @@\n-  assert(parse_predicate_count() == 0, \"should be clean!\");\n+  _parse_predicates.clear();\n@@ -1858,0 +1862,1 @@\n+    assert(C->parse_predicate_count() == 0, \"all parse predicates should have been removed now\");\n@@ -2103,1 +2108,1 @@\n-              cg->print_inlining_late(msg);\n+              cg->print_inlining_late(InliningResult::FAILURE, msg);\n@@ -5129,1 +5134,1 @@\n-bool Compile::should_print_igv(int level) {\n+bool Compile::should_print_igv(const int level) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, inline_msg);\n+    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -123,1 +123,1 @@\n-      C->print_inlining(callee, jvms->depth() - 1, bci, inline_msg);\n+      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -149,1 +149,1 @@\n-    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, msg);\n+    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -151,1 +151,1 @@\n-      C->print_inlining(callee, jvms->depth() - 1, bci, msg);\n+      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -192,1 +192,1 @@\n-    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, inline_msg);\n+    CompileTask::print_inlining_ul(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -194,1 +194,1 @@\n-      C->print_inlining(callee, jvms->depth() - 1, bci, inline_msg);\n+      C->print_inlining(callee, jvms->depth() - 1, bci, InliningResult::SUCCESS, inline_msg);\n@@ -210,1 +210,1 @@\n-    CompileTask::print_inlining_ul(kit.callee(), jvms->depth() - 1, bci, msg);\n+    CompileTask::print_inlining_ul(kit.callee(), jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -212,1 +212,1 @@\n-      C->print_inlining(kit.callee(), jvms->depth() - 1, bci, msg);\n+      C->print_inlining(kit.callee(), jvms->depth() - 1, bci, InliningResult::FAILURE, msg);\n@@ -296,0 +296,3 @@\n+  case vmIntrinsics::_arraySort:                return inline_array_sort();\n+  case vmIntrinsics::_arrayPartition:           return inline_array_partition();\n+\n@@ -2893,0 +2896,1 @@\n+  Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n@@ -2901,0 +2905,1 @@\n+    sync_kit(ideal);\n@@ -2903,3 +2908,0 @@\n-    Node* vt_oop = _gvn.transform(must_be_not_null(argument(0), true)); \/\/ VirtualThread this argument\n-\n-    sync_kit(ideal);\n@@ -2910,1 +2912,0 @@\n-    Node* vt_oop = _gvn.transform(argument(0)); \/\/ this argument - VirtualThread oop\n@@ -5024,2 +5025,2 @@\n-      Node* obj_size  = nullptr;\n-      Node* alloc_obj = new_array(obj_klass, obj_length, 0, &obj_size, \/*deoptimize_on_exception=*\/true);\n+      Node* array_size = nullptr; \/\/ Size of the array without object alignment padding.\n+      Node* alloc_obj = new_array(obj_klass, obj_length, 0, &array_size, \/*deoptimize_on_exception=*\/true);\n@@ -5058,1 +5059,1 @@\n-        copy_to_clone(obj, alloc_obj, obj_size, true);\n+        copy_to_clone(obj, alloc_obj, array_size, true);\n@@ -5098,1 +5099,1 @@\n-      Node* obj_size  = nullptr;\n+      Node* obj_size = nullptr; \/\/ Total object size, including object alignment padding.\n@@ -5366,0 +5367,95 @@\n+\/\/------------------------------inline_array_partition-----------------------\n+bool LibraryCallKit::inline_array_partition() {\n+\n+  const char *stubName = \"array_partition_stub\";\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+  Node* indexPivot1     = argument(6);\n+  Node* indexPivot2     = argument(7);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  address stubAddr = nullptr;\n+  stubAddr = StubRoutines::select_array_partition_function();\n+  \/\/ stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+  \/\/ get the address of the array\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  \/\/ create the pivotIndices array of type int and size = 2\n+  Node* size = intcon(2);\n+  Node* klass_node = makecon(TypeKlassPtr::make(ciTypeArrayKlass::make(T_INT)));\n+  Node* pivotIndices = new_array(klass_node, size, 0);  \/\/ no arguments to push\n+  AllocateArrayNode* alloc = tightly_coupled_allocation(pivotIndices);\n+  guarantee(alloc != nullptr, \"created above\");\n+  Node* pivotIndices_adr = basic_plus_adr(pivotIndices, arrayOopDesc::base_offset_in_bytes(T_INT));\n+\n+  \/\/ pass the basic type enum to the stub\n+  Node* elemType = intcon(bt);\n+\n+  \/\/ Call the stub\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_partition_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, elemType, fromIndex, toIndex, pivotIndices_adr,\n+                    indexPivot1, indexPivot2);\n+\n+  if (!stopped()) {\n+    set_result(pivotIndices);\n+  }\n+\n+  return true;\n+}\n+\n+\n+\/\/------------------------------inline_array_sort-----------------------\n+bool LibraryCallKit::inline_array_sort() {\n+\n+  const char *stubName;\n+  stubName = \"arraysort_stub\";\n+\n+  Node* elementType     = null_check(argument(0));\n+  Node* obj             = argument(1);\n+  Node* offset          = argument(2);\n+  Node* fromIndex       = argument(4);\n+  Node* toIndex         = argument(5);\n+\n+  const TypeInstPtr* elem_klass = gvn().type(elementType)->isa_instptr();\n+  ciType* elem_type = elem_klass->const_oop()->as_instance()->java_mirror_type();\n+  BasicType bt = elem_type->basic_type();\n+  address stubAddr = nullptr;\n+  stubAddr = StubRoutines::select_arraysort_function();\n+  \/\/stub not loaded\n+  if (stubAddr == nullptr) {\n+    return false;\n+  }\n+\n+  \/\/ get address of the array\n+  const TypeAryPtr* obj_t = _gvn.type(obj)->isa_aryptr();\n+  if (obj_t == nullptr || obj_t->elem() == Type::BOTTOM ) {\n+    return false; \/\/ failed input validation\n+  }\n+  Node* obj_adr = make_unsafe_address(obj, offset);\n+\n+  \/\/ pass the basic type enum to the stub\n+  Node* elemType = intcon(bt);\n+\n+  \/\/ Call the stub.\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::array_sort_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    obj_adr, elemType, fromIndex, toIndex);\n+\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":112,"deletions":16,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -540,1 +540,1 @@\n-      if (sfpt_ctl->is_Proj() && sfpt_ctl->as_Proj()->is_uncommon_trap_proj(Deoptimization::Reason_none)) {\n+      if (sfpt_ctl->is_Proj() && sfpt_ctl->as_Proj()->is_uncommon_trap_proj()) {\n@@ -2322,1 +2322,1 @@\n-    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn);\n+    Node* not_subtype_ctrl = Phase::gen_subtype_check(subklass, superklass, &ctrl, nullptr, _igvn, check->method(), check->bci());\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -596,2 +596,7 @@\n-          const TypeX *ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n-          if (ac->modifies(ld_offs_t->_lo, ld_offs_t->_hi, phase, can_see_stored_value)) {\n+          const TypeX* ld_offs_t = phase->type(ld_offs)->isa_intptr_t();\n+          assert(!ld_offs_t->empty(), \"dead reference should be checked already\");\n+          \/\/ Take into account vector or unsafe access size\n+          jlong ld_size_in_bytes = (jlong)memory_size();\n+          jlong offset_hi = ld_offs_t->_hi + ld_size_in_bytes - 1;\n+          offset_hi = MIN2(offset_hi, (jlong)(TypeX::MAX->_hi)); \/\/ Take care for overflow in 32-bit VM\n+          if (ac->modifies(ld_offs_t->_lo, (intptr_t)offset_hi, phase, can_see_stored_value)) {\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -863,0 +863,43 @@\n+const TypeFunc* OptoRuntime::array_partition_Type() {\n+  \/\/ create input type (domain)\n+  int num_args = 7;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;  \/\/ array\n+  fields[argp++] = TypeInt::INT;      \/\/ element type\n+  fields[argp++] = TypeInt::INT;      \/\/ low\n+  fields[argp++] = TypeInt::INT;      \/\/ end\n+  fields[argp++] = TypePtr::NOTNULL;  \/\/ pivot_indices (int array)\n+  fields[argp++] = TypeInt::INT;      \/\/ indexPivot1\n+  fields[argp++] = TypeInt::INT;      \/\/ indexPivot2\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n+const TypeFunc* OptoRuntime::array_sort_Type() {\n+  \/\/ create input type (domain)\n+  int num_args      = 4;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ array\n+  fields[argp++] = TypeInt::INT;    \/\/ element type\n+  fields[argp++] = TypeInt::INT;    \/\/ fromIndex\n+  fields[argp++] = TypeInt::INT;    \/\/ toIndex\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n@@ -1569,4 +1612,1 @@\n-  \/\/ This needs authenticating, but to do that here requires the fp of the previous frame.\n-  \/\/ A better way of doing it would be authenticate in the caller by adding a\n-  \/\/ AuthPAuthNode and using it in GraphKit::gen_stub. For now, just strip it.\n-  AARCH64_PORT_ONLY(ret_pc = pauth_strip_pointer(ret_pc));\n+  AARCH64_PORT_ONLY(ret_pc = pauth_strip_verifiable(ret_pc));\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":44,"deletions":4,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -4752,1 +4753,1 @@\n-  jint max_hi = max_array_length(elem()->basic_type());\n+  jint max_hi = max_array_length(elem()->array_element_basic_type());\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-UNSAFE_ENTRY(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {\n+UNSAFE_LEAF(jlong, Unsafe_AllocateMemory0(JNIEnv *env, jobject unsafe, jlong size)) {\n@@ -348,1 +348,1 @@\n-UNSAFE_ENTRY(jlong, Unsafe_ReallocateMemory0(JNIEnv *env, jobject unsafe, jlong addr, jlong size)) {\n+UNSAFE_LEAF(jlong, Unsafe_ReallocateMemory0(JNIEnv *env, jobject unsafe, jlong addr, jlong size)) {\n@@ -359,1 +359,1 @@\n-UNSAFE_ENTRY(void, Unsafe_FreeMemory0(JNIEnv *env, jobject unsafe, jlong addr)) {\n+UNSAFE_LEAF(void, Unsafe_FreeMemory0(JNIEnv *env, jobject unsafe, jlong addr)) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -526,0 +527,6 @@\n+  { \"DoReserveCopyInSuperWord\",     JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+\n+#ifdef LINUX\n+  { \"UseHugeTLBFS\",                 JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+  { \"UseSHM\",                       JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n+#endif\n@@ -1905,2 +1912,1 @@\n-\n-#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64)\n+#if !defined(X86) && !defined(AARCH64) && !defined(RISCV64) && !defined(ARM) && !defined(PPC64) && !defined(S390)\n@@ -1913,9 +1919,0 @@\n-  if (UseHeavyMonitors) {\n-    if (FLAG_IS_CMDLINE(LockingMode) && LockingMode != LM_MONITOR) {\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"Conflicting -XX:+UseHeavyMonitors and -XX:LockingMode=%d flags\\n\", LockingMode);\n-      return false;\n-    }\n-    FLAG_SET_CMDLINE(LockingMode, LM_MONITOR);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -437,0 +437,4 @@\n+  product(uint64_t, AbortVMOnSafepointTimeoutDelay, 0, DIAGNOSTIC,          \\\n+          \"Delay in milliseconds for option AbortVMOnSafepointTimeout\")     \\\n+          range(0, max_jlong)                                               \\\n+                                                                            \\\n@@ -560,1 +564,1 @@\n-  product(intx, HeapDumpGzipLevel, 0, MANAGEABLE,                           \\\n+  product(int, HeapDumpGzipLevel, 0, MANAGEABLE,                            \\\n@@ -1062,4 +1066,0 @@\n-  develop(bool, UseHeavyMonitors, false,                                    \\\n-          \"(Deprecated) Use heavyweight instead of lightweight Java \"       \\\n-          \"monitors\")                                                       \\\n-                                                                            \\\n@@ -1068,1 +1068,1 @@\n-          \"+UseHeavyMonitors\")                                              \\\n+          \"-XX:LockingMode=0 (LM_MONITOR)\")                                 \\\n@@ -1322,1 +1322,1 @@\n-  notproduct(intx, MaxElementPrintSize, 256,                                \\\n+  notproduct(int, MaxElementPrintSize, 256,                                 \\\n@@ -1426,0 +1426,3 @@\n+  develop(bool, RandomizeClassSpaceLocation, true,                          \\\n+          \"Randomize location of class space.\")                             \\\n+                                                                            \\\n@@ -1464,1 +1467,1 @@\n-  product(uintx, MaxMetaspaceFreeRatio,    70,                              \\\n+  product(uint, MaxMetaspaceFreeRatio,    70,                               \\\n@@ -1470,1 +1473,1 @@\n-  product(uintx, MinMetaspaceFreeRatio,    40,                              \\\n+  product(uint, MinMetaspaceFreeRatio,    40,                               \\\n@@ -1892,4 +1895,0 @@\n-  product(size_t, ArrayAllocatorMallocLimit, SIZE_MAX, EXPERIMENTAL,        \\\n-          \"Allocation less than this value will be allocated \"              \\\n-          \"using malloc. Larger allocations will use mmap.\")                \\\n-                                                                            \\\n@@ -1986,1 +1985,1 @@\n-  product(int, LockingMode, LM_LEGACY, EXPERIMENTAL,                        \\\n+  product(int, LockingMode, LM_LIGHTWEIGHT,                                 \\\n@@ -1989,2 +1988,2 @@\n-          \"1: monitors & legacy stack-locking (LM_LEGACY, default), \"       \\\n-          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT)\")         \\\n+          \"1: monitors & legacy stack-locking (LM_LEGACY), \"                \\\n+          \"2: monitors & new lightweight locking (LM_LIGHTWEIGHT, default)\") \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -367,1 +368,1 @@\n-  void      release_object() { _object.release(_oop_storage); _object.set_null(); }\n+  void      release_object() { _object.release(_oop_storage); }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -1644,2 +1644,2 @@\n-    SuspendibleThreadSet::synchronize();\n-    SuspendibleThreadSet::desynchronize();\n+    Universe::heap()->safepoint_synchronize_begin();\n+    Universe::heap()->safepoint_synchronize_end();\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -666,1 +666,1 @@\n-  MutexLocker::post_initialize();\n+  MutexLockerImpl::post_initialize();\n@@ -705,0 +705,1 @@\n+  bool init_compilation = true;\n@@ -706,1 +707,1 @@\n-  bool force_JVMCI_intialization = false;\n+  bool force_JVMCI_initialization = false;\n@@ -710,6 +711,11 @@\n-    force_JVMCI_intialization = EagerJVMCI || JVMCIPrintProperties || JVMCILibDumpJNIConfig;\n-\n-    if (!force_JVMCI_intialization) {\n-      \/\/ 8145270: Force initialization of JVMCI runtime otherwise requests for blocking\n-      \/\/ compilations via JVMCI will not actually block until JVMCI is initialized.\n-      force_JVMCI_intialization = UseJVMCICompiler && (!UseInterpreter || !BackgroundCompilation);\n+    force_JVMCI_initialization = EagerJVMCI || JVMCIPrintProperties || JVMCILibDumpJNIConfig;\n+    if (!force_JVMCI_initialization && UseJVMCICompiler && !UseJVMCINativeLibrary && (!UseInterpreter || !BackgroundCompilation)) {\n+      \/\/ Force initialization of jarjvmci otherwise requests for blocking\n+      \/\/ compilations will not actually block until jarjvmci is initialized.\n+      force_JVMCI_initialization = true;\n+    }\n+    if (JVMCIPrintProperties || JVMCILibDumpJNIConfig) {\n+      \/\/ Both JVMCILibDumpJNIConfig and JVMCIPrintProperties exit the VM\n+      \/\/ so compilation should be disabled. This prevents dumping or\n+      \/\/ printing from happening more than once.\n+      init_compilation = false;\n@@ -719,5 +725,2 @@\n-  CompileBroker::compilation_init_phase1(CHECK_JNI_ERR);\n-  \/\/ Postpone completion of compiler initialization to after JVMCI\n-  \/\/ is initialized to avoid timeouts of blocking compilations.\n-  if (JVMCI_ONLY(!force_JVMCI_intialization) NOT_JVMCI(true)) {\n-    CompileBroker::compilation_init_phase2();\n+  if (init_compilation) {\n+    CompileBroker::compilation_init(CHECK_JNI_ERR);\n@@ -767,1 +770,1 @@\n-  if (force_JVMCI_intialization) {\n+  if (force_JVMCI_initialization) {\n@@ -769,1 +772,0 @@\n-    CompileBroker::compilation_init_phase2();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":17,"deletions":15,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-                   static_ptr_volatile_field,                                                                                        \\\n+                   volatile_static_field,                                                                                            \\\n@@ -207,0 +207,1 @@\n+                volatile_static_field,                                                                                               \\\n@@ -460,1 +461,1 @@\n-     static_field(PerfMemory,                  _initialized,                                  int)                                   \\\n+     volatile_static_field(PerfMemory,         _initialized,                                  int)                                   \\\n@@ -490,1 +491,1 @@\n-  static_ptr_volatile_field(ClassLoaderDataGraph, _head,                                      ClassLoaderData*)                      \\\n+  volatile_static_field(ClassLoaderDataGraph, _head,                                          ClassLoaderData*)                      \\\n@@ -651,1 +652,1 @@\n-  static_ptr_volatile_field(ThreadsSMRSupport, _java_thread_list,                             ThreadsList*)                          \\\n+  volatile_static_field(ThreadsSMRSupport, _java_thread_list,                                 ThreadsList*)                          \\\n@@ -2705,1 +2706,1 @@\n-             GENERATE_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY,\n+             GENERATE_VOLATILE_STATIC_VM_STRUCT_ENTRY,\n@@ -2907,1 +2908,1 @@\n-             CHECK_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY,\n+             CHECK_VOLATILE_STATIC_VM_STRUCT_ENTRY,\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-\/\/ This macro generates a VMStructEntry line for a static pointer volatile field,\n+\/\/ This macro generates a VMStructEntry line for a static volatile field,\n@@ -171,2 +171,2 @@\n-#define GENERATE_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY(typeName, fieldName, type)    \\\n- { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 1, 0, (void *)&typeName::fieldName },\n+#define GENERATE_VOLATILE_STATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)    \\\n+  { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 1, 0, (type*)&typeName::fieldName },\n@@ -211,1 +211,1 @@\n-\/\/ This macro checks the type of a static pointer volatile VMStructEntry by comparing pointer types,\n+\/\/ This macro checks the type of a static volatile VMStructEntry by comparing pointer types,\n@@ -213,1 +213,1 @@\n-#define CHECK_STATIC_PTR_VOLATILE_VM_STRUCT_ENTRY(typeName, fieldName, type)       \\\n+#define CHECK_VOLATILE_STATIC_VM_STRUCT_ENTRY(typeName, fieldName, type)       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -731,10 +731,0 @@\n-  \/** Utility routine for building a long from two \"unsigned\" 32-bit\n-      ints in <b>platform-dependent<\/b> order *\/\n-  public long buildLongFromIntsPD(int oneHalf, int otherHalf) {\n-    if (isBigEndian) {\n-      return (((long) otherHalf) << 32) | (((long) oneHalf) & 0x00000000FFFFFFFFL);\n-    } else{\n-      return (((long) oneHalf) << 32) | (((long) otherHalf) & 0x00000000FFFFFFFFL);\n-    }\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,0 +69,2 @@\n+    private static final int HEAP_WORD_SIZE = Platform.is32bit() ? 4 : 8;\n+\n@@ -73,1 +75,0 @@\n-\n@@ -77,3 +78,3 @@\n-    private static final int OBJECT_SIZE_SMALL = 10;\n-    private static final int OBJECT_SIZE_MEDIUM = 100;\n-    private static final int OBJECT_SIZE_HIGH   = COMPACT_HEADERS ? 3266 : 3250;\n+    private static final int OBJECT_SIZE_SMALL  = 10 * HEAP_WORD_SIZE;\n+    private static final int OBJECT_SIZE_MEDIUM = 128 * HEAP_WORD_SIZE;\n+    private static final int OBJECT_SIZE_HIGH   = 3072 * HEAP_WORD_SIZE;\n@@ -101,1 +102,2 @@\n-        new TestCase(WASTE_PCT_MEDIUM, PLAB_SIZE_MEDIUM, OBJECT_SIZE_HIGH, GC_NUM_MEDIUM, YOUNG_SIZE_LOW, PLAB_FIXED, true, true),\n+        new TestCase(WASTE_PCT_MEDIUM, PLAB_SIZE_MEDIUM, OBJECT_SIZE_HIGH, GC_NUM_MEDIUM, YOUNG_SIZE_LOW, PLAB_FIXED, true, false),\n+        new TestCase(WASTE_PCT_HIGH, PLAB_SIZE_MEDIUM, OBJECT_SIZE_HIGH, GC_NUM_MEDIUM, YOUNG_SIZE_LOW, PLAB_FIXED, true, true),\n@@ -111,2 +113,0 @@\n-        new TestCase(WASTE_PCT_MEDIUM, PLAB_SIZE_SMALL, OBJECT_SIZE_MEDIUM, GC_NUM_MEDIUM, YOUNG_SIZE_LOW, PLAB_DYNAMIC, true, true),\n-        new TestCase(WASTE_PCT_HIGH, PLAB_SIZE_HIGH, OBJECT_SIZE_MEDIUM, GC_NUM_SMALL, YOUNG_SIZE_HIGH, PLAB_DYNAMIC, true, true),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABPromotion.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -696,1 +696,3 @@\n-                \"mixed\"\n+                \"mixed\",\n+                \/\/ -XmxmNNNm added by run-test framework for non-hotspot tests\n+                \"mx\"\n@@ -701,4 +703,6 @@\n-                              \/\/ remove -X\n-                              .map(s -> s.substring(2))\n-                              \/\/ remove :.* from flags with values\n-                              .map(s -> s.contains(\":\") ? s.substring(0, s.indexOf(':')) : s)\n+                          \/\/ remove -X\n+                          .map(s -> s.substring(2))\n+                          \/\/ remove :.* from flags with values\n+                          .map(s -> s.contains(\":\") ? s.substring(0, s.indexOf(':')) : s)\n+                          \/\/ remove size like 4G, 768m which might be set for non-hotspot tests\n+                          .map(s -> s.replaceAll(\"(\\\\d+)[mMgGkK]\", \"\"))\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"}]}