{"files":[{"patch":"@@ -42,0 +42,3 @@\n+\n+\/\/\/\/\/ x64 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n@@ -49,1 +52,83 @@\n- * @run driver CompressedClassPointerEncoding\n+ * @run driver CompressedClassPointerEncoding x64-area-beyond-encoding-range-use-xor\n+ *\/\n+\n+\/*\n+ * @test id=x64-area-partly-within-encoding-range-use-add\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding x64-area-partly-within-encoding-range-use-add\n+ *\/\n+\n+\/*\n+ * @test id=x64-area-within-encoding-range-use-zero\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding x64-area-within-encoding-range-use-zero\n+ *\/\n+\n+\/*\n+ * @test id=x64-area-far-out-no-low-bits-use-xor\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding x64-area-far-out-no-low-bits-use-xor\n+ *\/\n+\n+\/*\n+ * @test id=x64-area-far-out-with-low-bits-use-add\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding x64-area-far-out-with-low-bits-use-add\n+ *\/\n+\n+\/\/\/\/\/ aarch64 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\/*\n+ * @test id=aarch64-xor\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding aarch64-xor\n+ *\/\n+\n+\/*\n+ * @test id=aarch64-movk-1\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding aarch64-movk-1\n+ *\/\n+\n+\/*\n+ * @test id=aarch64-movk-2\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding aarch64-movk-2\n+ *\/\n+\n+\/*\n+ * @test id=aarch64-movk-3\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding aarch64-movk-3\n@@ -55,0 +140,1 @@\n+import jtreg.SkippedException;\n@@ -58,0 +144,1 @@\n+import java.util.regex.Pattern;\n@@ -61,24 +148,0 @@\n-    \/\/ Replace:\n-    \/\/ $1 with force base address\n-    \/\/ $2 with compressed class space size\n-    final static String[] vmOptionsTemplate = new String[] {\n-      \"-XX:CompressedClassSpaceBaseAddress=$1\",\n-      \"-XX:CompressedClassSpaceSize=$2\",\n-      \"-Xshare:off\",                         \/\/ Disable CDS\n-      \"-Xlog:metaspace*\",                    \/\/ for analysis\n-      \"-XX:+PrintMetaspaceStatisticsAtExit\", \/\/ for analysis\n-      \"-version\"\n-    };\n-\n-    \/\/ Replace:\n-    \/\/ $1 with expected ccs base address (extended hex printed)\n-    \/\/ $2 with expected encoding base (extended hex printed)\n-    \/\/ $3 with expected encoding shift\n-    \/\/ $4 with expected encoding range\n-    \/\/ $5 with expected encoding mode\n-    final String[] expectedOutputTemplate = new String[] {\n-            \".*Sucessfully forced class space address to $1.*\",\n-            \".*CDS archive(s) not mapped.*\",\n-            \".*Narrow klass base: $2, Narrow klass shift: $3, Narrow klass range: $4, Encoding mode $5.*\"\n-    };\n-\n@@ -88,3 +151,7 @@\n-    final static long expectedShift = 9;\n-    final static long expectedEncodingRange = 2 * G;\n-    final static long defaultCCSSize = 32 * M;\n+    final static int narrowKlassBitSize = 22;\n+    final static int narrowKlassShift = 9;\n+    final static long narrowKlassValueSpan = (long)1 << narrowKlassBitSize;\n+    final static long encodingRangeSpan = narrowKlassValueSpan << narrowKlassShift;\n+\n+    final static long defaultCCSSize = 128 * M;\n+    final static long ccsGranularity = 16 * M; \/\/ root chunk size\n@@ -92,7 +159,0 @@\n-    enum EPlatform {\n-        \/\/ Add more where needed\n-        \/\/ (Note: this would be useful in Platform.java)\n-        linux_aarch64,\n-        linux_x64,\n-        unknown\n-    };\n@@ -100,8 +160,0 @@\n-    static EPlatform getCurrentPlatform() {\n-        if (Platform.isAArch64() && Platform.isLinux()) {\n-            return EPlatform.linux_aarch64;\n-        } else if (Platform.isX64() && Platform.isLinux()) {\n-            return EPlatform.linux_x64;\n-        }\n-        return EPlatform.unknown;\n-    }\n@@ -110,1 +162,0 @@\n-        public final EPlatform platform;\n@@ -112,1 +163,1 @@\n-        public final long[] baseAdressesToTry;\n+        public final long ccsBaseAddress;\n@@ -116,0 +167,4 @@\n+        \/\/ The test relies on -XX:CompressedClassSpaceBaseAddress to force the CCS base address to a certain value.\n+        \/\/ That can fail due to ASLR. This switch, if true, tolerates those failures. Lets keep it to false for now. The\n+        \/\/ danger of setting it true is that we may not notice if all tests start to fail due to other reasons.\n+        public final boolean tolerateCCSMappingError;\n@@ -117,3 +172,2 @@\n-        public TestDetails(EPlatform platform, String name, long[] baseAdressesToTry,\n-                           long compressedClassSpaceSize, long expectedEncodingBase, String expectedEncodingMode) {\n-            this.platform = platform;\n+        public TestDetails(String name, long ccsBaseAddress,\n+                           long expectedEncodingBase, String expectedEncodingMode, boolean tolerateCCSMappingError) {\n@@ -121,2 +175,2 @@\n-            this.baseAdressesToTry = baseAdressesToTry;\n-            this.compressedClassSpaceSize = compressedClassSpaceSize;\n+            this.ccsBaseAddress = ccsBaseAddress;\n+            this.compressedClassSpaceSize = defaultCCSSize;\n@@ -125,7 +179,1 @@\n-        }\n-\n-        \/\/ Simplified, common version: one base address (which we assume always works) and 32G ccs size\n-        public TestDetails(EPlatform platform, String name, long baseAdress,\n-                           long expectedEncodingBase, String expectedEncodingMode) {\n-            this(platform, name, new long[]{ baseAdress }, defaultCCSSize,\n-                 expectedEncodingBase, expectedEncodingMode);\n+            this.tolerateCCSMappingError = tolerateCCSMappingError;\n@@ -135,1 +183,21 @@\n-    static TestDetails[] testDetails = new TestDetails[] {\n+    static void runTestWithName(String name) throws IOException {\n+\n+        \/\/ How this works:\n+        \/\/ 1) we enforce a CCS base address with -XX:CompressedClassSpaceBaseAddress. This bypasses the automatic\n+        \/\/    CCS placement we do in Metaspace\/CDS initialization; CCS begins at that address.\n+        \/\/ 2) We set CCS size to 128M.\n+        \/\/ 3) We expect the zero-based encoding range to be [0...8G)\n+        \/\/ 4) Depending on how CCS base address looks like, we expect different encoding mechanisms from the platforms.\n+        \/\/    These are somewhat platform dependent.\n+        \/\/    a) If CCS range fits completely into the zero-based encoding range, we expect zero-based encoding to be used\n+        \/\/    b) If CCs range lies partly or completely outside the zero-based encoding range, zero-base encoding cannot work.\n+        \/\/    c) for (b), depending on the platform and how the CCS base address looks like, different mechanisms\n+        \/\/       should be chosen to decode the Klass*. Typically, if CCS base address does not intersect with\n+        \/\/       the narrow Klass pointer bit range 0..24, CCS base address and narrow Klass pointer can be appended\n+        \/\/       (e.g. xor), otherwise we would expect some form of shift+add\n+\n+        String expectedMode;\n+        long ccsBaseAddress;\n+        long expectedEncodingRangeStart;\n+        boolean tolerateMappingFailure = false;\n+        switch (name) {\n@@ -140,42 +208,41 @@\n-            \/\/ CCS base beyond encoding range (base=2G). Base does does not intersect the uncompressed klass pointer\n-            \/\/ bits. Encoding cannot be zero, and we should use xor+shift mode.\n-            new TestDetails(EPlatform.linux_x64,\n-                    \"x64-area-beyond-encoding-range-use-xor\",\n-                    2 * G,\n-                    2 * G,\n-                    \"xor\"),\n-\n-            \/\/ CCS partly contained in encoding range. We cannot use zero based encoding. We cannot use xor either,\n-            \/\/ since the first part of the ccs intersects the encoding range. Encoding hould use add+shift.\n-            \/*\n-            new TestDetails(EPlatform.linux_x64,\n-                    \"x64-area-partly-within-encoding-range-use-add\",\n-                    0x7fc00000,\n-                    2 * G,\n-                    \"add\"),\n-            *\/\n-\n-            \/\/ CCS (just) fully contained in encoding range (base=2G-ccs size). Expect zero-based encoding.\n-            new TestDetails(EPlatform.linux_x64,\n-                    \"x64-area-within-encoding-range-use-zero\",\n-                    0x7e000000, \/\/ 2G - 32M (ccs size)\n-                    0,\n-                    \"zero\"),\n-\n-            \/\/ CCS located far beyond the zero-based limit. Base does not intersect with narrow Klass pointer bits.\n-            \/\/ We should use xor.\n-            new TestDetails(EPlatform.linux_x64,\n-                    \"x64-area-far-out-no-low-bits-use-xor\",\n-                    0x800000000L, \/\/ 32G\n-                    0x800000000L,\n-                    \"xor\"),\n-\n-            \/\/ CCS located far beyond the zero-based limit. Base address intersects with narrow Klass pointer bits.\n-            \/\/ We should use add.\n-            \/*\n-            new TestDetails(EPlatform.linux_x64,\n-                    \"x64-area-far-out-with-low-bits-use-add\",\n-                    0x800800000L, \/\/ 32G + 8M (4M is minimum ccs alignment)\n-                    0x800800000L,\n-                    \"xor\"),\n-            *\/\n+            case \"x64-area-beyond-encoding-range-use-xor\":\n+                \/\/ CCS base starts just (beyond) zero-based encoding range.\n+                \/\/ - Encoding cannot be zero-based\n+                \/\/ - We should be able to use xor mode since CCS base address does not intersect with max left-shifted narrow Klass pointer\n+                ccsBaseAddress = encodingRangeSpan;\n+                expectedEncodingRangeStart = ccsBaseAddress;\n+                expectedMode = \"xor\";\n+                break;\n+            case \"x64-area-partly-within-encoding-range-use-add\":\n+                \/\/ CCS partly contained within zero-based encoding range, but last part (a single granule) outside.\n+                \/\/ - Encoding cannot be zero-based\n+                \/\/ - We cannot use xor since CCS base address intersects with max left-shifted narrow Klass pointer\n+                ccsBaseAddress = encodingRangeSpan - defaultCCSSize + ccsGranularity;\n+                expectedEncodingRangeStart = ccsBaseAddress;\n+                expectedMode = \"add\";\n+                break;\n+            case \"x64-area-within-encoding-range-use-zero\":\n+                \/\/ CCS fully contained within zero-based encoding range\n+                \/\/ - Encoding can be zero-based\n+                ccsBaseAddress = encodingRangeSpan - defaultCCSSize;\n+                expectedEncodingRangeStart = 0;\n+                expectedMode = \"zero\";\n+                break;\n+            case \"x64-area-far-out-no-low-bits-use-xor\":\n+                \/\/ CCS located far beyond zero-based encoding range, at a nicely aligned base.\n+                \/\/ - Encoding cannot be zero-based\n+                \/\/ - We should be able to use xor mode since CCS base address does not intersect with\n+                \/\/   max left-shifted narrow Klass pointer\n+                ccsBaseAddress = encodingRangeSpan * 4; \/\/ 32G\n+                expectedEncodingRangeStart = ccsBaseAddress;\n+                expectedMode = \"xor\";\n+                break;\n+            case \"x64-area-far-out-with-low-bits-use-add\":\n+                \/\/ CCS located far beyond zero-based encoding range, but address is unfit for xor mode.\n+                \/\/ - Encoding cannot be zero-based\n+                \/\/ - We cannot use xor since CCS base address has lower bits set that intersect with\n+                \/\/   max left-shifted narrow Klass pointer\n+                ccsBaseAddress = (encodingRangeSpan * 4) + ccsGranularity; \/\/ 32G + a bit\n+                expectedEncodingRangeStart = ccsBaseAddress;\n+                expectedMode = \"add\";\n+                break;\n@@ -186,0 +253,37 @@\n+            case \"aarch64-xor\":\n+                \/\/ CCS with a base which is a valid immediate, does not intersect the uncompressed klass pointer bits,\n+                \/\/ should use xor+shift\n+                ccsBaseAddress = 0x1000000000L;\n+                expectedEncodingRangeStart = ccsBaseAddress;\n+                expectedMode = \"xor\";\n+                break;\n+\n+            \/\/ Attempt to test movk:\n+            \/\/ Addresses that would need movk mode are quite high for lilliput (9 bit shift), with the lowest\n+            \/\/ needing 40bits. Therefore the following tests may fail because CCS cannot be mapped. This depends on\n+            \/\/ how the kernel was compiled (39, 42 or 48 bit virtual addresses).\n+            \/\/ Therefore we tolerate mapping failures for the following tests.\n+            case \"aarch64-movk-1\":\n+                ccsBaseAddress = 0x00000a0000000000L;\n+                expectedEncodingRangeStart = ccsBaseAddress;\n+                expectedMode = \"movk\";\n+                tolerateMappingFailure = true;\n+                break;\n+\n+            case \"aarch64-movk-2\":\n+                ccsBaseAddress = 0x120000000000L;\n+                expectedEncodingRangeStart = ccsBaseAddress;\n+                expectedMode = \"movk\";\n+                tolerateMappingFailure = true;\n+                break;\n+\n+            case \"aarch64-movk-3\":\n+                ccsBaseAddress = 0x160000000000L;\n+                expectedEncodingRangeStart = ccsBaseAddress;\n+                expectedMode = \"movk\";\n+                tolerateMappingFailure = true;\n+                break;\n+\n+            default:\n+                throw new RuntimeException(\"Bad test name: \" + name);\n+        }\n@@ -187,9 +291,3 @@\n-            \/\/ CCS with a base which is a valid immediate, does not intersect the uncompressed klass pointer bits,\n-            \/\/ should use xor+shift\n-            new TestDetails(EPlatform.linux_aarch64,\n-                    \"aarch64-area-beyond-encoding-range-base-valid-immediate-use-xor\",\n-                    0x800000000L, \/\/ 32G\n-                    800000000L,\n-                    \"xor\")\n-\n-            \/\/ ... add more\n+        TestDetails details = new TestDetails(name, ccsBaseAddress, expectedEncodingRangeStart, expectedMode, tolerateMappingFailure);\n+        runTest(details);\n+    }\n@@ -197,1 +295,1 @@\n-    };\n+    ;\n@@ -227,2 +325,13 @@\n-        long ccsBaseAddress = details.baseAdressesToTry[0];\n-        String ccsBaseAddressAsHex = String.format(\"0x%016x\", ccsBaseAddress);\n+        \/\/ Replace:\n+        \/\/ $1 with force base address\n+        \/\/ $2 with compressed class space size\n+        String[] vmOptionsTemplate = new String[] {\n+                \"-XX:CompressedClassSpaceBaseAddress=$1\",\n+                \"-XX:CompressedClassSpaceSize=$2\",\n+                \"-Xshare:off\",                         \/\/ Disable CDS\n+                \"-Xlog:metaspace*\",                    \/\/ for analysis\n+                \"-XX:+PrintMetaspaceStatisticsAtExit\", \/\/ for analysis\n+                \"-version\"\n+        };\n+\n+        String ccsBaseAddressAsHex = String.format(\"0x%016x\", details.ccsBaseAddress);\n@@ -245,3 +354,7 @@\n-        output.shouldHaveExitValue(0);\n-\n-    }\n+        if (details.tolerateCCSMappingError) {\n+            String template = \"CompressedClassSpaceBaseAddress=$1 given, but reserving class space failed\";\n+            String pat = replacePlaceholdersInString(template, ccsBaseAddressAsHex);\n+            if (output.getStdout().contains(pat)) {\n+                throw new SkippedException(\"Skipping test: failed to force CCS to base address \" + ccsBaseAddressAsHex);\n+            }\n+        }\n@@ -249,4 +362,32 @@\n-    static void runTestsForPlatform(EPlatform platform) throws IOException {\n-        for (TestDetails details : testDetails) {\n-            if (details.platform == platform) {\n-                runTest(details);\n+        \/\/ Replace:\n+        \/\/ $1 with expected ccs base address (extended hex printed)\n+        \/\/ $2 with expected encoding base (extended hex printed)\n+        \/\/ $3 with expected encoding shift\n+        \/\/ $4 with expected encoding range\n+        \/\/ $5 with expected encoding mode\n+        String[] expectedOutputTemplate = new String[] {\n+                \"Successfully forced class space address to $1\",\n+                \"CDS archive(s) not mapped\",\n+                \"CompressedClassSpaceSize: 128.00 MB\",\n+                \"KlassAlignmentInBytes: 512\",\n+                \"KlassEncodingMetaspaceMax: 2.00 GB\",\n+                \"Narrow klass base: $2, Narrow klass shift: $3, Narrow klass range: $4, Encoding mode $5\"\n+        };\n+\n+        String expectedOutput[] = replacePlaceholdersInArray(expectedOutputTemplate,\n+                ccsBaseAddressAsHex, \/\/ $1\n+                String.format(\"0x%016x\", details.expectedEncodingBase), \/\/ $2\n+                Long.toString(narrowKlassShift), \/\/ $3\n+                String.format(\"0x%x\", encodingRangeSpan), \/\/ $4\n+                details.expectedEncodingMode  \/\/ $5\n+        );\n+\n+        String[] lines = output.asLines().toArray(new String[0]);\n+        int found = 0;\n+        int lineno = 0;\n+        while (lineno < lines.length && found < expectedOutput.length) {\n+            String pat = expectedOutput[found];\n+            String line = lines[lineno];\n+            if (line.contains(pat)) {\n+                System.out.println(\"Found: \" + pat + \" at line \" + lineno);\n+                found ++;\n@@ -254,0 +395,4 @@\n+            lineno++;\n+        }\n+        if (found < expectedOutput.length) {\n+            throw new RuntimeException(\"Not all expected pattern found. First missing: \" + expectedOutput[found]);\n@@ -255,0 +400,2 @@\n+\n+        output.shouldHaveExitValue(0);\n@@ -258,1 +405,1 @@\n-        runTestsForPlatform(getCurrentPlatform());\n+        runTestWithName(args[0]);\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointerEncoding.java","additions":267,"deletions":120,"binary":false,"changes":387,"status":"modified"}]}