{"files":[{"patch":"@@ -43,1 +43,1 @@\n-\/\/\/\/\/ x64 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ x64\n@@ -95,1 +95,1 @@\n-\/\/\/\/\/ aarch64 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ aarch64\n@@ -153,1 +153,1 @@\n-    final static long narrowKlassValueSpan = (long)1 << narrowKlassBitSize;\n+    final static long narrowKlassValueSpan = 1L << narrowKlassBitSize;\n@@ -168,2 +168,1 @@\n-        \/\/ That can fail due to ASLR. This switch, if true, tolerates those failures. Lets keep it to false for now. The\n-        \/\/ danger of setting it true is that we may not notice if all tests start to fail due to other reasons.\n+        \/\/ That can fail due to ASLR. If tolerateCCSMappingError is true, we tolerate this.\n@@ -189,9 +188,7 @@\n-        \/\/ 3) We expect the zero-based encoding range to be [0...8G)\n-        \/\/ 4) Depending on how CCS base address looks like, we expect different encoding mechanisms from the platforms.\n-        \/\/    These are somewhat platform dependent.\n-        \/\/    a) If CCS range fits completely into the zero-based encoding range, we expect zero-based encoding to be used\n-        \/\/    b) If CCs range lies partly or completely outside the zero-based encoding range, zero-base encoding cannot work.\n-        \/\/    c) for (b), depending on the platform and how the CCS base address looks like, different mechanisms\n-        \/\/       should be chosen to decode the Klass*. Typically, if CCS base address does not intersect with\n-        \/\/       the narrow Klass pointer bit range 0..24, CCS base address and narrow Klass pointer can be appended\n-        \/\/       (e.g. xor), otherwise we would expect some form of shift+add\n+        \/\/ 3) We expect the zero-based encoding range to be [0...<max encoding span>)\n+        \/\/ 4) Depending on where CCS is located wrt the zero-based encoding range, we expect different encoding\n+        \/\/    platform dependent mechanisms. For example,\n+        \/\/    a) If CCS range fits completely into the zero-based encoding range, we expect zero-based encoding\n+        \/\/    b) If CCs range lies partly or completely outside the zero-based encoding range, zero-base encoding\n+        \/\/       cannot work. Typically, if CCS base address and Klass* offset range can be appended, something like\n+        \/\/       xor would be used, otherwise some for of add+shift\n@@ -211,1 +208,1 @@\n-                \/\/ - We should be able to use xor mode since CCS base address does not intersect with max left-shifted narrow Klass pointer\n+                \/\/ - We should be able to use xor mode since CCS base address and Klass* offset range don't intersect\n@@ -236,1 +233,1 @@\n-                ccsBaseAddress = encodingRangeSpan * 4; \/\/ 32G\n+                ccsBaseAddress = encodingRangeSpan * 4;\n@@ -245,1 +242,1 @@\n-                ccsBaseAddress = (encodingRangeSpan * 4) + ccsGranularity; \/\/ 32G + a bit\n+                ccsBaseAddress = (encodingRangeSpan * 4) + ccsGranularity;\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointerEncoding.java","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"}]}