{"files":[{"patch":"@@ -7240,1 +7240,11 @@\n-    __ load_nklass($dst$$Register, $mem$$base$$Register);\n+    Register dst = $dst$$Register;\n+    Register obj = $mem$$base$$Register;\n+    C2LoadNKlassStub* stub = new (Compile::current()->comp_arena()) C2LoadNKlassStub(dst);\n+    Compile::current()->output()->add_stub(stub);\n+    __ ldr(dst, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    \/\/ NOTE: We can't use tbnz here, because the target is sometimes too far away\n+    \/\/ and cannot be encoded.\n+    __ tst(dst, markWord::monitor_value);\n+    __ br(Assembler::NE, stub->entry());\n+    __ bind(stub->continuation());\n+    __ lsr(dst, dst, markWord::klass_shift);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -258,21 +259,2 @@\n-  Register res = _result->as_register();\n-  ce->store_parameter(_obj->as_register(), 0);\n-  if (res != r0) {\n-    \/\/ Note: we cannot push\/pop r0 around the call, because that\n-    \/\/ would mess with the stack pointer sp, and we need that to\n-    \/\/ remain intact for store_paramater\/load_argument to work correctly.\n-    \/\/ We swap r0 and res instead, which preserves current r0 in res.\n-    \/\/ The preserved value is later saved and restored around the\n-    \/\/ call in Runtime1::load_klass_id.\n-    __ mov(rscratch1, r0);\n-    __ mov(r0, res);\n-    __ mov(res, rscratch1);\n-  }\n-  __ far_call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_klass_id)));\n-  if (res != r0) {\n-    \/\/ Swap back r0 and res. This brings the call return value\n-    \/\/ from r0 into res, and the preserved value in res back into r0.\n-    __ mov(rscratch1, r0);\n-    __ mov(r0, res);\n-    __ mov(res, rscratch1);\n-  }\n+  Register d = _result->as_register();\n+  __ ldr(d, Address(d, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":3,"deletions":21,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2565,1 +2565,0 @@\n-  Register tmp = rscratch1;\n@@ -2575,3 +2574,2 @@\n-  __ ldr(tmp, Address(obj, oopDesc::mark_offset_in_bytes()));\n-  __ eor(tmp, tmp, markWord::unlocked_value);\n-  __ tst(tmp, markWord::lock_mask_in_place);\n+  __ ldr(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  __ tst(result, markWord::monitor_value);\n@@ -2579,0 +2577,1 @@\n+  __ bind(*op->stub()->continuation());\n@@ -2580,2 +2579,1 @@\n-  \/\/ Fast-path: shift and decode Klass*.\n-  __ mov(result, tmp);\n+  \/\/ Shift and decode Klass*.\n@@ -2583,2 +2581,0 @@\n-\n-  __ bind(*op->stub()->continuation());\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -678,10 +678,0 @@\n-    case load_klass_id:\n-      {\n-        StubFrame f(sasm, \"load_klass\", dont_gc_arguments);\n-        save_live_registers_no_oop_map(sasm, true);\n-        f.load_argument(0, r0); \/\/ obj\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_nklass_runtime), r0);\n-        restore_live_registers_except_r0(sasm, true);\n-      }\n-      break;\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -77,0 +78,11 @@\n+int C2LoadNKlassStub::max_size() const {\n+  return 8;\n+}\n+\n+void C2LoadNKlassStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+  Register d = dst();\n+  __ ldr(d, Address(d, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n+  __ b(continuation());\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_CodeStubs_aarch64.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4037,3 +4037,1 @@\n-  assert_different_registers(src, dst);\n-\n-  Label slow, done;\n+  Label fast;\n@@ -4043,3 +4041,5 @@\n-  eor(dst, dst, markWord::unlocked_value);\n-  tst(dst, markWord::lock_mask_in_place);\n-  br(Assembler::NE, slow);\n+  tst(dst, markWord::monitor_value);\n+  br(Assembler::NE, fast);\n+\n+  \/\/ Fetch displaced header\n+  ldr(dst, Address(dst, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n@@ -4048,0 +4048,1 @@\n+  bind(fast);\n@@ -4049,17 +4050,0 @@\n-  b(done);\n-\n-  bind(slow);\n-  RegSet saved_regs = RegSet::of(lr);\n-  \/\/ We need r0 as argument and return register for the call. Preserve it, if necessary.\n-  if (dst != r0) {\n-    saved_regs += RegSet::of(r0);\n-  }\n-  push(saved_regs, sp);\n-  mov(r0, src);\n-  assert(StubRoutines::load_nklass() != NULL, \"Must have stub\");\n-  far_call(RuntimeAddress(StubRoutines::load_nklass()));\n-  if (dst != r0) {\n-    mov(dst, r0);\n-  }\n-  pop(saved_regs, sp);\n-  bind(done);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":7,"deletions":23,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -6820,23 +6820,0 @@\n-  \/\/ Pass object argument in r0 (which has to be preserved outside this stub)\n-  \/\/ Pass back result in r0\n-  \/\/ Clobbers rscratch1\n-  address generate_load_nklass() {\n-    __ align(CodeEntryAlignment);\n-    StubCodeMark mark(this, \"StubRoutines\", \"load_nklass\");\n-\n-    address start = __ pc();\n-\n-    __ set_last_Java_frame(sp, rfp, lr, rscratch1);\n-    __ enter();\n-    __ push(RegSet::of(rscratch1, rscratch2), sp);\n-    __ push_call_clobbered_registers_except(r0);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_nklass_runtime), 1);\n-    __ pop_call_clobbered_registers_except(r0);\n-    __ pop(RegSet::of(rscratch1, rscratch2), sp);\n-    __ leave();\n-    __ reset_last_Java_frame(true);\n-    __ ret(lr);\n-\n-    return start;\n-  }\n-\n@@ -8010,2 +7987,0 @@\n-\n-    StubRoutines::_load_nklass = generate_load_nklass();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -306,12 +307,2 @@\n-  Register res = _result->as_register();\n-  ce->store_parameter(_obj->as_register(), 0);\n-  if (res != rax) {\n-    \/\/ This preserves rax and allows it to be used as return-register,\n-    \/\/ without messing with the stack.\n-    __ xchgptr(rax, res);\n-  }\n-  __ call(RuntimeAddress(Runtime1::entry_for(Runtime1::load_klass_id)));\n-  if (res != rax) {\n-    \/\/ Swap back rax, and move result to correct register.\n-    __ xchgptr(rax, res);\n-  }\n+  Register d = _result->as_register();\n+  __ movq(d, Address(d, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3544,3 +3544,2 @@\n-  __ movq(tmp, Address(obj, oopDesc::mark_offset_in_bytes()));\n-  __ xorq(tmp, markWord::unlocked_value);\n-  __ testb(tmp, markWord::lock_mask_in_place);\n+  __ movq(result, Address(obj, oopDesc::mark_offset_in_bytes()));\n+  __ testb(result, markWord::monitor_value);\n@@ -3548,1 +3547,1 @@\n-\n+  __ bind(*op->stub()->continuation());\n@@ -3550,1 +3549,0 @@\n-  __ movq(result, tmp);\n@@ -3552,2 +3550,0 @@\n-\n-  __ bind(*op->stub()->continuation());\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1043,11 +1043,0 @@\n-#ifdef _LP64\n-    case load_klass_id:\n-      {\n-        StubFrame f(sasm, \"load_klass\", dont_gc_arguments);\n-        sasm->save_live_registers_no_oop_map(true);\n-        f.load_argument(0, c_rarg0); \/\/ obj\n-        __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_nklass_runtime), c_rarg0);\n-        sasm->restore_live_registers_except_rax(true);\n-      }\n-      break;\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -86,0 +87,13 @@\n+#ifdef _LP64\n+int C2LoadNKlassStub::max_size() const {\n+  return 10;\n+}\n+\n+void C2LoadNKlassStub::emit(C2_MacroAssembler& masm) {\n+  __ bind(entry());\n+  Register d = dst();\n+  __ movq(d, Address(d, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n+  __ jmp(continuation());\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -5099,1 +5099,0 @@\n-  assert_different_registers(src, dst);\n@@ -5102,1 +5101,1 @@\n-  Label slow, done;\n+  Label fast;\n@@ -5104,6 +5103,2 @@\n-  \/\/ NOTE: While it would seem nice to use xorb instead (for which we don't have an encoding in our assembler),\n-  \/\/ the encoding for xorq uses the signed version (0x81\/6) of xor, which encodes as compact as xorb would,\n-  \/\/ and does't make a difference performance-wise.\n-  xorq(dst, markWord::unlocked_value);\n-  testb(dst, markWord::lock_mask_in_place);\n-  jccb(Assembler::notZero, slow);\n+  testb(dst, markWord::monitor_value);\n+  jccb(Assembler::zero, fast);\n@@ -5111,15 +5106,2 @@\n-  shrq(dst, markWord::klass_shift);\n-  jmp(done);\n-  bind(slow);\n-\n-  if (dst != rax) {\n-    push(rax);\n-  }\n-  if (src != rax) {\n-    mov(rax, src);\n-  }\n-  call(RuntimeAddress(StubRoutines::load_nklass()));\n-  if (dst != rax) {\n-    mov(dst, rax);\n-    pop(rax);\n-  }\n+  \/\/ Fetch displaced header\n+  movq(dst, Address(dst, OM_OFFSET_NO_MONITOR_VALUE_TAG(header)));\n@@ -5127,1 +5109,2 @@\n-  bind(done);\n+  bind(fast);\n+  shrq(dst, markWord::klass_shift);\n@@ -5136,4 +5119,0 @@\n-  Register d = dst;\n-  if (src == dst) {\n-    d = tmp;\n-  }\n@@ -5143,4 +5122,1 @@\n-  load_nklass(d, src);\n-  if (src == dst) {\n-    mov(dst, d);\n-  }\n+  load_nklass(dst, src);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -3405,40 +3405,0 @@\n-  \/\/ Call stub to call runtime oopDesc::load_nklass_runtime().\n-  \/\/ rax: call argument (object)\n-  \/\/ rax: return object's narrowKlass\n-  \/\/ Preserves all caller-saved registers, except rax\n-#ifdef _LP64\n-address StubGenerator::generate_load_nklass() {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark(this, \"StubRoutines\", \"load_nklass\");\n-  address start = __ pc();\n-  __ enter(); \/\/ save rbp\n-\n-  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n-  __ push_FPU_state();\n-\n-  __ push(rdi);\n-  __ push(rsi);\n-  __ push(rdx);\n-  __ push(rcx);\n-  __ push(r8);\n-  __ push(r9);\n-  __ push(r10);\n-  __ push(r11);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, oopDesc::load_nklass_runtime), rax);\n-  __ pop(r11);\n-  __ pop(r10);\n-  __ pop(r9);\n-  __ pop(r8);\n-  __ pop(rcx);\n-  __ pop(rdx);\n-  __ pop(rsi);\n-  __ pop(rdi);\n-\n-  __ pop_FPU_state();\n-\n-  __ leave();\n-  __ ret(0);\n-  return start;\n-}\n-#endif \/\/ _LP64\n-\n@@ -3820,4 +3780,0 @@\n-#ifdef _LP64\n-  StubRoutines::_load_nklass = generate_load_nklass();\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -5325,1 +5325,9 @@\n-    __ load_nklass($dst$$Register, $mem$$base$$Register);\n+    Register dst = $dst$$Register;\n+    Register obj = $mem$$base$$Register;\n+    C2LoadNKlassStub* stub = new (Compile::current()->comp_arena()) C2LoadNKlassStub(dst);\n+    Compile::current()->output()->add_stub(stub);\n+    __ movq(dst, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    __ testb(dst, markWord::monitor_value);\n+    __ jcc(Assembler::notZero, stub->entry());\n+    __ bind(stub->continuation());\n+    __ shrq(dst, markWord::klass_shift);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -559,1 +559,0 @@\n-  LIR_Opr          _obj;\n@@ -563,2 +562,2 @@\n-  LoadKlassStub(LIR_Opr obj, LIR_Opr result) :\n-    CodeStub(), _obj(obj), _result(result) {};\n+  LoadKlassStub(LIR_Opr result) :\n+    CodeStub(), _result(result) {};\n@@ -568,1 +567,1 @@\n-    visitor->do_input(_obj);\n+    visitor->do_temp(_result);\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1244,1 +1244,1 @@\n-  CodeStub* slow_path = new LoadKlassStub(obj, klass);\n+  CodeStub* slow_path = new LoadKlassStub(klass);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -247,1 +247,0 @@\n-  case load_klass_id:\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  stub(load_klass)                   \\\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -171,15 +171,0 @@\n-#ifdef _LP64\n-JRT_LEAF(narrowKlass, oopDesc::load_nklass_runtime(oopDesc* o))\n-  assert(o != NULL, \"null-check\");\n-  oop obj = oop(o);\n-  assert(oopDesc::is_oop(obj), \"need a valid oop here: \" PTR_FORMAT, p2i(o));\n-  markWord header = obj->mark();\n-  if (!header.is_neutral()) {\n-    header = ObjectSynchronizer::stable_mark(obj);\n-  }\n-  assert(header.is_neutral() || header.is_fast_locked(), \"expect neutral or fast-locked header here\");\n-  narrowKlass nklass = header.narrow_klass();\n-  return nklass;\n-JRT_END\n-#endif\n-\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+  inline markWord resolve_mark() const;\n+\n@@ -324,5 +326,0 @@\n-  \/\/ Runtime entry\n-#ifdef _LP64\n-  static narrowKlass load_nklass_runtime(oopDesc* o);\n-#endif\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -87,0 +88,9 @@\n+markWord oopDesc::resolve_mark() const {\n+  markWord hdr = mark();\n+  if (hdr.has_monitor()) {\n+    ObjectMonitor* monitor = hdr.monitor();\n+    return monitor->header();\n+  }\n+  return hdr;\n+}\n+\n@@ -89,1 +99,1 @@\n-  markWord header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n+  markWord header = resolve_mark();\n@@ -101,4 +111,1 @@\n-  markWord header = mark();\n-  if (!header.is_neutral()) {\n-    header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n-  }\n+  markWord header = resolve_mark();\n@@ -114,4 +121,1 @@\n-  markWord header = mark();\n-  if (!header.is_neutral()) {\n-    header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n-  }\n+  markWord header = resolve_mark();\n@@ -128,2 +132,2 @@\n-  if (!header.is_neutral()) {\n-    header = ObjectSynchronizer::stable_mark(cast_to_oop(this));\n+  if (header.has_monitor()) {\n+    header = header.monitor()->header();\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -97,0 +97,12 @@\n+#ifdef _LP64\n+class C2LoadNKlassStub : public C2CodeStub {\n+private:\n+  Register _dst;\n+public:\n+  C2LoadNKlassStub(Register dst) : C2CodeStub(), _dst(dst) {}\n+  Register dst() { return _dst; }\n+  int max_size() const;\n+  void emit(C2_MacroAssembler& masm);\n+};\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -215,0 +215,1 @@\n+  static int header_offset_in_bytes()      { return offset_of(ObjectMonitor, _header); }\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -174,2 +174,0 @@\n-address StubRoutines::_load_nklass = NULL;\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,3 +263,1 @@\n-  static address _load_nklass;\n-\n-public:\n+ public:\n@@ -429,2 +427,0 @@\n-  static address load_nklass()         { return _load_nklass; }\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -798,1 +798,1 @@\n-markWord ObjectSynchronizer::read_stable_mark(oop obj) {\n+static markWord read_stable_mark(oop obj) {\n@@ -858,67 +858,0 @@\n-\/\/ Safely load a mark word from an object, even with racing stack-locking or monitor inflation.\n-\/\/ The protocol is a partial inflation-protocol: it installs INFLATING into the object's mark\n-\/\/ word in order to prevent an stack-locks or inflations from interferring (or detect such\n-\/\/ interference and retry), but then, instead of creating and installing a monitor, simply\n-\/\/ read and return the real mark word.\n-markWord ObjectSynchronizer::stable_mark(oop object) {\n-  for (;;) {\n-    const markWord mark = read_stable_mark(object);\n-    assert(!mark.is_being_inflated(), \"read_stable_mark must prevent inflating mark\");\n-\n-    \/\/ The mark can be in one of the following states:\n-    \/\/ *  Inflated     - just return mark from inflated monitor\n-    \/\/ *  Stack-locked - coerce it to inflating, and then return displaced mark\n-    \/\/ *  Neutral      - return mark\n-    \/\/ *  Marked       - return mark\n-\n-    \/\/ CASE: inflated\n-    if (mark.has_monitor()) {\n-      ObjectMonitor* inf = mark.monitor();\n-      markWord dmw = inf->header();\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n-      return dmw;\n-    }\n-\n-    \/\/ CASE: stack-locked\n-    \/\/ Could be stack-locked either by this thread or by some other thread.\n-    if (mark.has_locker()) {\n-      BasicLock* lock = mark.locker();\n-      if (Thread::current()->is_lock_owned((address)lock)) {\n-        \/\/ If locked by this thread, it is safe to access the displaced header.\n-        markWord dmw = lock->displaced_header();\n-        assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n-        return dmw;\n-      }\n-\n-      \/\/ Otherwise, attempt to temporarily install INFLATING into the mark-word,\n-      \/\/ to prevent inflation or unlocking by competing thread.\n-      markWord cmp = object->cas_set_mark(markWord::INFLATING(), mark);\n-      if (cmp != mark) {\n-        continue;       \/\/ Interference -- just retry\n-      }\n-\n-      \/\/ fetch the displaced mark from the owner's stack.\n-      \/\/ The owner can't die or unwind past the lock while our INFLATING\n-      \/\/ object is in the mark.  Furthermore the owner can't complete\n-      \/\/ an unlock on the object, either.\n-      markWord dmw = mark.displaced_mark_helper();\n-      \/\/ Catch if the object's header is not neutral (not locked and\n-      \/\/ not marked is what we care about here).\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n-\n-      \/\/ Must preserve store ordering. The monitor state must\n-      \/\/ be stable at the time of publishing the monitor address.\n-      assert(object->mark() == markWord::INFLATING(), \"invariant\");\n-      \/\/ Release semantics so that above set_object() is seen first.\n-      object->release_set_mark(mark);\n-\n-      return dmw;\n-    }\n-\n-    \/\/ CASE: neutral or marked (for GC)\n-    \/\/ Catch if the object's header is not neutral or marked (it must not be locked).\n-    assert(mark.is_neutral() || mark.is_marked() || mark.is_fast_locked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n-    return mark;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1,"deletions":68,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -173,5 +173,0 @@\n-  \/\/ Read mark-word and spin-wait as long as INFLATING is observed.\n-  static markWord read_stable_mark(oop obj);\n-\n-  static markWord stable_mark(oop obj);\n-\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}