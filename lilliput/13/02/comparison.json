{"files":[{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"macroAssembler_aarch64.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return MacroAssembler::klass_decode_mode_for_base(p) != MacroAssembler::KlassDecodeNone;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT_X\n+               \", Encoding mode %s\",\n+               p2i(base()), shift(), KlassEncodingMetaspaceMax,\n+               MacroAssembler::describe_klass_decode_mode(MacroAssembler::klass_decode_mode()));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"logging\/log.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -3904,0 +3906,14 @@\n+\/\/ Returns a static string\n+const char* MacroAssembler::describe_klass_decode_mode(MacroAssembler::KlassDecodeMode mode) {\n+  switch (mode) {\n+  case KlassDecodeNone: return \"none\";\n+  case KlassDecodeZero: return \"zero\";\n+  case KlassDecodeXor:  return \"xor\";\n+  case KlassDecodeMovk: return \"movk\";\n+  default:\n+    ShouldNotReachHere();\n+  }\n+  return NULL;\n+}\n+\n+\/\/ Return the current narrow Klass pointer decode mode.\n@@ -3905,2 +3921,4 @@\n-  assert(UseCompressedClassPointers, \"not using compressed class pointers\");\n-  assert(Metaspace::initialized(), \"metaspace not initialized yet\");\n+  if (_klass_decode_mode == KlassDecodeNone) {\n+    \/\/ First time initialization\n+    assert(UseCompressedClassPointers, \"not using compressed class pointers\");\n+    assert(Metaspace::initialized(), \"metaspace not initialized yet\");\n@@ -3908,2 +3926,5 @@\n-  if (_klass_decode_mode != KlassDecodeNone) {\n-    return _klass_decode_mode;\n+    _klass_decode_mode = klass_decode_mode_for_base(CompressedKlassPointers::base());\n+    guarantee(_klass_decode_mode != KlassDecodeNone,\n+              PTR_FORMAT \" is not a valid encoding base on aarch64\",\n+              p2i(CompressedKlassPointers::base()));\n+    log_info(metaspace)(\"klass decode mode initialized: %s\", describe_klass_decode_mode(_klass_decode_mode));\n@@ -3911,0 +3932,7 @@\n+  return _klass_decode_mode;\n+}\n+\n+\/\/ Given an arbitrary base address, return the KlassDecodeMode that would be used. Return KlassDecodeNone\n+\/\/ if base address is not valid for encoding.\n+MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode_for_base(address base) {\n+  assert(CompressedKlassPointers::shift() != 0, \"not lilliput?\");\n@@ -3912,2 +3940,1 @@\n-  assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift()\n-         || 0 == CompressedKlassPointers::shift(), \"decode alg wrong\");\n+  const uint64_t base_u64 = (uint64_t) base;\n@@ -3915,2 +3942,2 @@\n-  if (CompressedKlassPointers::base() == NULL) {\n-    return (_klass_decode_mode = KlassDecodeZero);\n+  if (base_u64 == 0) {\n+    return KlassDecodeZero;\n@@ -3919,7 +3946,3 @@\n-  if (operand_valid_for_logical_immediate(\n-        \/*is32*\/false, (uint64_t)CompressedKlassPointers::base())) {\n-    const uint64_t range_mask =\n-      (1ULL << log2i(CompressedKlassPointers::range())) - 1;\n-    if (((uint64_t)CompressedKlassPointers::base() & range_mask) == 0) {\n-      return (_klass_decode_mode = KlassDecodeXor);\n-    }\n+  if (operand_valid_for_logical_immediate(false, base_u64) &&\n+      ((base_u64 & (KlassEncodingMetaspaceMax - 1)) == 0)) {\n+    return KlassDecodeXor;\n@@ -3928,4 +3951,4 @@\n-  const uint64_t shifted_base =\n-    (uint64_t)CompressedKlassPointers::base() >> CompressedKlassPointers::shift();\n-  guarantee((shifted_base & 0xffff0000ffffffff) == 0,\n-            \"compressed class base bad alignment\");\n+  const uint64_t shifted_base = base_u64 >> CompressedKlassPointers::shift();\n+  if ((shifted_base & 0xffff0000ffffffff) == 0) {\n+    return KlassDecodeMovk;\n+  }\n@@ -3933,1 +3956,1 @@\n-  return (_klass_decode_mode = KlassDecodeMovk);\n+  return KlassDecodeNone;\n@@ -3937,0 +3960,2 @@\n+  assert (UseCompressedClassPointers, \"should only be used for compressed headers\");\n+  assert(CompressedKlassPointers::shift() != 0, \"not lilliput?\");\n@@ -3939,5 +3964,1 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      lsr(dst, src, LogKlassAlignmentInBytes);\n-    } else {\n-      if (dst != src) mov(dst, src);\n-    }\n+    lsr(dst, src, LogKlassAlignmentInBytes);\n@@ -3947,6 +3968,2 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      eor(dst, src, (uint64_t)CompressedKlassPointers::base());\n-      lsr(dst, dst, LogKlassAlignmentInBytes);\n-    } else {\n-      eor(dst, src, (uint64_t)CompressedKlassPointers::base());\n-    }\n+    eor(dst, src, (uint64_t)CompressedKlassPointers::base());\n+    lsr(dst, dst, LogKlassAlignmentInBytes);\n@@ -3956,5 +3973,1 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      ubfx(dst, src, LogKlassAlignmentInBytes, 32);\n-    } else {\n-      movw(dst, src);\n-    }\n+    ubfx(dst, src, LogKlassAlignmentInBytes, MaxNarrowKlassPointerBits);\n@@ -3976,0 +3989,2 @@\n+  assert(CompressedKlassPointers::shift() != 0, \"not lilliput?\");\n+\n@@ -3978,5 +3993,1 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      lsl(dst, src, LogKlassAlignmentInBytes);\n-    } else {\n-      if (dst != src) mov(dst, src);\n-    }\n+    if (dst != src) mov(dst, src);\n@@ -3986,6 +3997,2 @@\n-    if (CompressedKlassPointers::shift() != 0) {\n-      lsl(dst, src, LogKlassAlignmentInBytes);\n-      eor(dst, dst, (uint64_t)CompressedKlassPointers::base());\n-    } else {\n-      eor(dst, src, (uint64_t)CompressedKlassPointers::base());\n-    }\n+    lsl(dst, src, LogKlassAlignmentInBytes);\n+    eor(dst, dst, (uint64_t)CompressedKlassPointers::base());\n@@ -3998,0 +4005,3 @@\n+    \/\/ Invalid base should have been gracefully handled via klass_decode_mode() in VM initialization.\n+    assert((shifted_base & 0xffff0000ffffffff) == 0, \"incompatible base\");\n+\n@@ -4000,5 +4010,1 @@\n-\n-    if (CompressedKlassPointers::shift() != 0) {\n-      lsl(dst, dst, LogKlassAlignmentInBytes);\n-    }\n-\n+    lsl(dst, dst, LogKlassAlignmentInBytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":58,"deletions":52,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -85,0 +85,2 @@\n+ public:\n+\n@@ -92,1 +94,9 @@\n-  KlassDecodeMode klass_decode_mode();\n+  \/\/ Return the current narrow Klass pointer decode mode. Initialized on first call.\n+  static KlassDecodeMode klass_decode_mode();\n+\n+  \/\/ Given an arbitrary base address, return the KlassDecodeMode that would be used. Return KlassDecodeNone\n+  \/\/ if base address is not valid for encoding.\n+  static KlassDecodeMode klass_decode_mode_for_base(address base);\n+\n+  \/\/ Returns a static string\n+  static const char* describe_klass_decode_mode(KlassDecodeMode mode);\n@@ -95,0 +105,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return true;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT, p2i(base()), shift(),\n+               KlassEncodingMetaspaceMax);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/compressedKlass_ppc64.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return true;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT, p2i(base()), shift(),\n+               KlassEncodingMetaspaceMax);\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/compressedKlass_s390.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"macroAssembler_x86.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+#ifdef _LP64\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return MacroAssembler::klass_decode_mode_for_base(p) != MacroAssembler::KlassDecodeNone;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT_X\n+               \", Encoding mode %s\",\n+               p2i(base()), shift(), KlassEncodingMetaspaceMax,\n+               MacroAssembler::describe_klass_decode_mode(MacroAssembler::klass_decode_mode()));\n+}\n+\n+#endif \/\/ _LP64\n","filename":"src\/hotspot\/cpu\/x86\/compressedKlass_x86.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -72,6 +72,0 @@\n-#if INCLUDE_JVMCI\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS EnableJVMCI\n-#else\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"logging\/log.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -53,0 +55,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -4811,0 +4814,62 @@\n+MacroAssembler::KlassDecodeMode MacroAssembler::_klass_decode_mode = KlassDecodeNone;\n+\n+\/\/ Returns a static string\n+const char* MacroAssembler::describe_klass_decode_mode(MacroAssembler::KlassDecodeMode mode) {\n+  switch (mode) {\n+  case KlassDecodeNone: return \"none\";\n+  case KlassDecodeZero: return \"zero\";\n+  case KlassDecodeXor:  return \"xor\";\n+  case KlassDecodeAdd:  return \"add\";\n+  default:\n+    ShouldNotReachHere();\n+  }\n+  return NULL;\n+}\n+\n+\/\/ Return the current narrow Klass pointer decode mode.\n+MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode() {\n+  if (_klass_decode_mode == KlassDecodeNone) {\n+    \/\/ First time initialization\n+    assert(UseCompressedClassPointers, \"not using compressed class pointers\");\n+    assert(Metaspace::initialized(), \"metaspace not initialized yet\");\n+\n+    _klass_decode_mode = klass_decode_mode_for_base(CompressedKlassPointers::base());\n+    guarantee(_klass_decode_mode != KlassDecodeNone,\n+              PTR_FORMAT \" is not a valid encoding base on aarch64\",\n+              p2i(CompressedKlassPointers::base()));\n+    log_info(metaspace)(\"klass decode mode initialized: %s\", describe_klass_decode_mode(_klass_decode_mode));\n+  }\n+  return _klass_decode_mode;\n+}\n+\n+\/\/ Given an arbitrary base address, return the KlassDecodeMode that would be used. Return KlassDecodeNone\n+\/\/ if base address is not valid for encoding.\n+MacroAssembler::KlassDecodeMode MacroAssembler::klass_decode_mode_for_base(address base) {\n+  assert(CompressedKlassPointers::shift() != 0, \"not lilliput?\");\n+\n+  const uint64_t base_u64 = (uint64_t) base;\n+\n+  if (base_u64 == 0) {\n+    return KlassDecodeZero;\n+  }\n+\n+  if ((base_u64 & (KlassEncodingMetaspaceMax - 1)) == 0) {\n+    return KlassDecodeXor;\n+  }\n+\n+  \/\/ Note that there is no point in optimizing for shift=3 since lilliput\n+  \/\/ will use larger shifts\n+\n+  \/\/ The add+shift mode for decode_and_move_klass_not_null() requires the base to be\n+  \/\/  shiftable-without-loss. So, this is the minimum restriction on x64 for a valid\n+  \/\/  encoding base. This does not matter in reality since the shift values we use for\n+  \/\/  Lilliput, while large, won't be larger than a page size. And the encoding base\n+  \/\/  will be quite likely page aligned since it usually falls to the beginning of\n+  \/\/  either CDS or CCS.\n+  if ((base_u64 & (KlassAlignmentInBytes - 1)) == 0) {\n+    return KlassDecodeAdd;\n+  }\n+\n+  return KlassDecodeNone;\n+}\n+\n@@ -4813,1 +4878,12 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  switch (klass_decode_mode()) {\n+  case KlassDecodeZero: {\n+    shrq(r, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeXor: {\n+    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+    xorq(r, tmp);\n+    shrq(r, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeAdd: {\n@@ -4816,0 +4892,2 @@\n+    shrq(r, CompressedKlassPointers::shift());\n+    break;\n@@ -4817,3 +4895,2 @@\n-  if (CompressedKlassPointers::shift() != 0) {\n-    assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-    shrq(r, LogKlassAlignmentInBytes);\n+  default:\n+    ShouldNotReachHere();\n@@ -4825,1 +4902,13 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n+  switch (klass_decode_mode()) {\n+  case KlassDecodeZero: {\n+    movptr(dst, src);\n+    shrq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeXor: {\n+    mov64(dst, (int64_t)CompressedKlassPointers::base());\n+    xorq(dst, src);\n+    shrq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeAdd: {\n@@ -4828,2 +4917,2 @@\n-  } else {\n-    movptr(dst, src);\n+    shrq(dst, CompressedKlassPointers::shift());\n+    break;\n@@ -4831,3 +4920,2 @@\n-  if (CompressedKlassPointers::shift() != 0) {\n-    assert (LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-    shrq(dst, LogKlassAlignmentInBytes);\n+  default:\n+    ShouldNotReachHere();\n@@ -4839,8 +4927,5 @@\n-  \/\/ Note: it will change flags\n-  assert(UseCompressedClassPointers, \"should only be used for compressed headers\");\n-  \/\/ Cannot assert, unverified entry point counts instructions (see .ad file)\n-  \/\/ vtableStubs also counts instructions in pd_code_size_limit.\n-  \/\/ Also do not verify_oop as this is called by verify_oop.\n-  if (CompressedKlassPointers::shift() != 0) {\n-    assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-    shlq(r, LogKlassAlignmentInBytes);\n+  const uint64_t base_u64 = (uint64_t)CompressedKlassPointers::base();\n+  switch (klass_decode_mode()) {\n+  case KlassDecodeZero: {\n+    shlq(r, CompressedKlassPointers::shift());\n+    break;\n@@ -4848,2 +4933,11 @@\n-  if (CompressedKlassPointers::base() != NULL) {\n-    mov64(tmp, (int64_t)CompressedKlassPointers::base());\n+  case KlassDecodeXor: {\n+    assert((base_u64 & (KlassEncodingMetaspaceMax - 1)) == 0,\n+           \"base \" UINT64_FORMAT_X \" invalid for xor mode\", base_u64); \/\/ should have been handled at VM init.\n+    shlq(r, CompressedKlassPointers::shift());\n+    mov64(tmp, base_u64);\n+    xorq(r, tmp);\n+    break;\n+  }\n+  case KlassDecodeAdd: {\n+    shlq(r, CompressedKlassPointers::shift());\n+    mov64(tmp, base_u64);\n@@ -4851,0 +4945,4 @@\n+    break;\n+  }\n+  default:\n+    ShouldNotReachHere();\n@@ -4856,3 +4954,1 @@\n-  \/\/ Note: it will change flags\n-  assert (UseCompressedClassPointers, \"should only be used for compressed headers\");\n-  \/\/ Cannot assert, unverified entry point counts instructions (see .ad file)\n+  \/\/ Note: Cannot assert, unverified entry point counts instructions (see .ad file)\n@@ -4862,18 +4958,28 @@\n-  if (CompressedKlassPointers::base() == NULL &&\n-      CompressedKlassPointers::shift() == 0) {\n-    \/\/ The best case scenario is that there is no base or shift. Then it is already\n-    \/\/ a pointer that needs nothing but a register rename.\n-    movl(dst, src);\n-  } else {\n-    if (CompressedKlassPointers::base() != NULL) {\n-      mov64(dst, (int64_t)CompressedKlassPointers::base());\n-    } else {\n-      xorq(dst, dst);\n-    }\n-    if (CompressedKlassPointers::shift() != 0) {\n-      assert(LogKlassAlignmentInBytes == CompressedKlassPointers::shift(), \"decode alg wrong\");\n-      assert(LogKlassAlignmentInBytes == Address::times_8, \"klass not aligned on 64bits?\");\n-      leaq(dst, Address(dst, src, Address::times_8, 0));\n-    } else {\n-      addq(dst, src);\n-    }\n+  const uint64_t base_u64 = (uint64_t)CompressedKlassPointers::base();\n+\n+  switch (klass_decode_mode()) {\n+  case KlassDecodeZero: {\n+    movq(dst, src);\n+    shlq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeXor: {\n+    assert((base_u64 & (KlassEncodingMetaspaceMax - 1)) == 0,\n+           \"base \" UINT64_FORMAT_X \" invalid for xor mode\", base_u64); \/\/ should have been handled at VM init.\n+    const uint64_t base_right_shifted = base_u64 >> CompressedKlassPointers::shift();\n+    mov64(dst, base_right_shifted);\n+    xorq(dst, src);\n+    shlq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  case KlassDecodeAdd: {\n+    assert((base_u64 & (KlassAlignmentInBytes - 1)) == 0,\n+           \"base \" UINT64_FORMAT_X \" invalid for add mode\", base_u64); \/\/ should have been handled at VM init.\n+    const uint64_t base_right_shifted = base_u64 >> CompressedKlassPointers::shift();\n+    mov64(dst, base_right_shifted);\n+    addq(dst, src);\n+    shlq(dst, CompressedKlassPointers::shift());\n+    break;\n+  }\n+  default:\n+    ShouldNotReachHere();\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":147,"deletions":41,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -81,0 +81,23 @@\n+ public:\n+\n+  enum KlassDecodeMode {\n+    KlassDecodeNone,\n+    KlassDecodeZero,\n+    KlassDecodeXor,\n+    KlassDecodeAdd\n+  };\n+\n+  \/\/ Return the current narrow Klass pointer decode mode. Initialized on first call.\n+  static KlassDecodeMode klass_decode_mode();\n+\n+  \/\/ Given an arbitrary base address, return the KlassDecodeMode that would be used. Return KlassDecodeNone\n+  \/\/ if base address is not valid for encoding.\n+  static KlassDecodeMode klass_decode_mode_for_base(address base);\n+\n+  \/\/ Returns a static string\n+  static const char* describe_klass_decode_mode(KlassDecodeMode mode);\n+\n+ private:\n+\n+  static KlassDecodeMode _klass_decode_mode;\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -221,1 +221,2 @@\n-  const ptrdiff_t estimate = 226;\n+  \/\/ Lilliput: expanded since load_klass is significantly and decode_klass somewhat larger.\n+  const ptrdiff_t estimate = 230;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  return true;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+#ifdef _LP64\n+  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n+               \"Narrow klass range: \" UINT64_FORMAT, p2i(base()), shift(),\n+               KlassEncodingMetaspaceMax);\n+#endif\n+}\n+\n","filename":"src\/hotspot\/cpu\/zero\/compressedKlass_zero.cpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n@@ -220,2 +221,4 @@\n-    \/\/ See RunTimeClassInfo::get_for()\n-    _estimated_metaspaceobj_bytes += align_up(BytesPerWord, SharedSpaceObjectAlignment);\n+    \/\/ See ArchiveBuilder::make_shallow_copies: make sure we have enough space for both maximum\n+    \/\/ Klass alignment as well as the RuntimeInfo* pointer we will embed in front of a Klass.\n+    _estimated_metaspaceobj_bytes += align_up(BytesPerWord, KlassAlignmentInBytes) +\n+        align_up(sizeof(void*), SharedSpaceObjectAlignment);\n@@ -617,4 +620,5 @@\n-    \/\/ Save a pointer immediate in front of an InstanceKlass, so\n-    \/\/ we can do a quick lookup from InstanceKlass* -> RunTimeClassInfo*\n-    \/\/ without building another hashtable. See RunTimeClassInfo::get_for()\n-    \/\/ in systemDictionaryShared.cpp.\n+    \/\/ Reserve space for a pointer immediately in front of an InstanceKlass. That space will\n+    \/\/ later be used to store the RuntimeClassInfo* pointer directly in front of the archived\n+    \/\/ InstanceKlass, in order to have a quick lookup InstanceKlass* -> RunTimeClassInfo*\n+    \/\/ without building another hashtable. See RunTimeClassInfo::get_for()\/::set_for() for\n+    \/\/ details.\n@@ -626,0 +630,3 @@\n+    dest = dump_region->allocate(bytes, KlassAlignmentInBytes);\n+  } else {\n+    dest = dump_region->allocate(bytes);\n@@ -627,1 +634,0 @@\n-  dest = dump_region->allocate(bytes);\n@@ -638,1 +644,2 @@\n-  log_trace(cds)(\"Copy: \" PTR_FORMAT \" ==> \" PTR_FORMAT \" %d\", p2i(src), p2i(dest), bytes);\n+  log_trace(cds)(\"Copy: \" PTR_FORMAT \" ==> \" PTR_FORMAT \" %d (%s)\", p2i(src), p2i(dest), bytes,\n+                 MetaspaceObj::type_name(ref->msotype()));\n@@ -642,0 +649,2 @@\n+\n+  DEBUG_ONLY(_alloc_stats.verify((int)dump_region->used(), src_info->read_only()));\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -46,3 +47,13 @@\n-\/\/ Metaspace::allocate() requires that all blocks must be aligned with KlassAlignmentInBytes.\n-\/\/ We enforce the same alignment rule in blocks allocated from the shared space.\n-const int SharedSpaceObjectAlignment = KlassAlignmentInBytes;\n+\/\/ CDS has three alignments to deal with:\n+\/\/ - SharedSpaceObjectAlignment, always 8 bytes: used for placing arbitrary structures.\n+\/\/   These may contain 64-bit members (not larger, we know that much). Therefore we\n+\/\/   need to use 64-bit alignment on both 32-bit and 64-bit platforms. We reuse metaspace\n+\/\/   minimal alignment for this, which follows the same logic.\n+\/\/ - With CompressedClassPointers=1, we need to store Klass structures with a large\n+\/\/   alignment (Lilliput specific narrow Klass pointer encoding) - KlassAlignmentInBytes.\n+\/\/ - Header data and tags are squeezed in with word alignment, which happens to be 4 bytes\n+\/\/   on 32-bit. See ReadClosure::do_xxx() and DumpRegion::append_intptr().\n+const int SharedSpaceObjectAlignment = metaspace::MetaspaceMinAlignmentBytes;\n+\n+\/\/ standard alignment should be sufficient for storing 64-bit values.\n+STATIC_ASSERT(SharedSpaceObjectAlignment >= sizeof(uint64_t));\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -205,3 +205,13 @@\n-char* DumpRegion::allocate(size_t num_bytes) {\n-  char* p = (char*)align_up(_top, (size_t)SharedSpaceObjectAlignment);\n-  char* newtop = p + align_up(num_bytes, (size_t)SharedSpaceObjectAlignment);\n+char* DumpRegion::allocate(size_t num_bytes, size_t alignment) {\n+  \/\/ We align the starting address of each allocation.\n+  char* p = (char*)align_up(_top, alignment);\n+  char* newtop = p + num_bytes;\n+  \/\/ Leave _top always SharedSpaceObjectAlignment aligned. But not more -\n+  \/\/  if we allocate with large alignments, lets not waste the gaps.\n+  \/\/ Ideally we would not need to align _top to anything here but CDS has\n+  \/\/  a number of implicit alignment assumptions. Leaving this unaligned\n+  \/\/  here will trip of at least ReadClosure (assuming word alignment) and\n+  \/\/  DumpAllocStats (will get confused about counting bytes on 32-bit\n+  \/\/  platforms if we align to anything less than SharedSpaceObjectAlignment\n+  \/\/  here).\n+  newtop = align_up(newtop, SharedSpaceObjectAlignment);\n@@ -209,1 +219,1 @@\n-  memset(p, 0, newtop - p);\n+  memset(p, 0, newtop - p); \/\/ todo: needed? debug_only?\n@@ -213,0 +223,4 @@\n+char* DumpRegion::allocate(size_t num_bytes) {\n+  return allocate(num_bytes, SharedSpaceObjectAlignment);\n+}\n+\n@@ -304,1 +318,1 @@\n-  assert(tag == old_tag, \"old tag doesn't match\");\n+  assert(tag == old_tag, \"tag doesn't match (%d, expected %d)\", old_tag, tag);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -145,1 +145,2 @@\n-      _max_delta(max_delta), _is_packed(false) {}\n+      _max_delta(max_delta), _is_packed(false),\n+      _rs(NULL), _vs(NULL) {}\n@@ -148,0 +149,1 @@\n+  \/\/ Allocate with default alignment (SharedSpaceObjectAlignment)\n@@ -149,0 +151,2 @@\n+  \/\/ Allocate with an arbitrary alignment.\n+  char* allocate(size_t num_bytes, size_t alignment);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -105,0 +105,12 @@\n+\n+#ifdef ASSERT\n+void DumpAllocStats::verify(int expected_byte_size, bool read_only) const {\n+  int bytes = 0;\n+  const int what = (int)(read_only ? RO : RW);\n+  for (int type = 0; type < int(_number_of_types); type ++) {\n+    bytes += _bytes[what][type];\n+  }\n+  assert(bytes == expected_byte_size, \"counter mismatch (%s: %d vs %d)\",\n+         (read_only ? \"RO\" : \"RW\"), bytes, expected_byte_size);\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  DEBUG_ONLY(void verify(int expected_byte_size, bool read_only) const;)\n+\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n@@ -1411,0 +1412,5 @@\n+#ifdef ASSERT\n+    if (UseCompressedClassPointers) {\n+      CompressedKlassPointers::verify_klass_pointer(record->_klass);\n+    }\n+#endif\n@@ -1412,1 +1418,0 @@\n-    assert(check_alignment(record->_klass), \"Address not aligned\");\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"memory\/metaspace.hpp\"\n@@ -403,0 +404,15 @@\n+JVMFlag::Error CompressedClassSpaceSizeConstraintFunc(size_t value, bool verbose) {\n+#ifdef _LP64\n+  \/\/ There is no minimal value check, although class space will be transparently enlarged\n+  \/\/ to a multiple of metaspace root chunk size (4m).\n+  \/\/ The max. value of class space size depends on narrow klass pointer encoding range size\n+  \/\/ and CDS, see metaspace.cpp.\n+  if (value > Metaspace::max_class_space_size()) {\n+    JVMFlag::printError(verbose, \"CompressedClassSpaceSize \" SIZE_FORMAT \" too large (max: \" SIZE_FORMAT \")\\n\",\n+                        value, Metaspace::max_class_space_size());\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+#endif\n+  return JVMFlag::SUCCESS;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+ f(size_t, CompressedClassSpaceSizeConstraintFunc)             \\\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -39,0 +40,2 @@\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/align.hpp\"\n@@ -40,0 +43,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -59,0 +63,2 @@\n+  const int klass_alignment_words = KlassAlignmentInBytes \/ BytesPerWord;\n+\n@@ -63,0 +69,1 @@\n+      metaspace::MetaspaceMinAlignmentWords,\n@@ -69,0 +76,1 @@\n+    \/\/ Klass instances live in class space and must be aligned correctly.\n@@ -74,0 +82,1 @@\n+        klass_alignment_words,\n@@ -77,0 +86,5 @@\n+  } else {\n+    \/\/ note for lilliput, this path should be restricted to 32bit only. There, klass alignment\n+    \/\/  should be compatible with metaspace minimal alignment since we store Klass structures\n+    \/\/  in regular metaspace.\n+    NOT_LP64(STATIC_ASSERT(metaspace::MetaspaceMinAlignmentBytes == KlassAlignmentInBytes));\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -835,2 +836,2 @@\n-  \/\/  of ccs\".\n-  \/\/ Before Elastic Metaspace that did not happen due to the fact that every Metachunk\n+  \/\/  of ccs\". See CompressedKlassPointers::decode().\n+  \/\/ Before JEP 387 that did not happen due to the fact that every Metachunk\n@@ -870,0 +871,14 @@\n+#ifdef _LP64\n+\/\/ The largest allowed size for class space\n+size_t Metaspace::max_class_space_size() {\n+  \/\/ This is a bit fuzzy. Max value of class space size depends on narrow klass pointer\n+  \/\/ encoding range size and CDS, since class space shares encoding range with CDS. CDS\n+  \/\/ archives are usually pretty small though, so to keep matters simple, for now we\n+  \/\/ just assume a reasonable default (this is hackish; improve!).\n+  const size_t slice_for_cds = M * 128;\n+  assert(KlassEncodingMetaspaceMax >= (slice_for_cds * 2), \"rethink this\");\n+  const size_t max_class_space_size = KlassEncodingMetaspaceMax - slice_for_cds;\n+  return max_class_space_size;\n+}\n+#endif \/\/ _LP64\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -112,0 +112,3 @@\n+  \/\/ The largest allowed size for class space\n+  LP64_ONLY(static size_t max_class_space_size();)\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,0 +55,5 @@\n+    \/\/ Attention alignment: the resulting block must have the right alignment\n+    \/\/  for the enclosing arena. ATM this works, since the arena aligns allocated block\n+    \/\/  size. If we ever switch to a different model (e.g. aligning the start\n+    \/\/  address of allocated blocks instead of the request size) this should be\n+    \/\/  rewritten).\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeBlocks.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_METASPACE_ALIGNMENT_HPP\n+#define SHARE_MEMORY_METASPACE_ALIGNMENT_HPP\n+\n+#include \"memory\/metaspace\/chunklevel.hpp\"\n+#include \"memory\/metaspace\/freeBlocks.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+namespace metaspace {\n+\n+\/\/ The minimal alignment: good enough to store structures with 64bit wide members (also on 32-bit).\n+\/\/ Should we ever store longer values, revise.\n+static const int LogMetaspaceMinimalAlignment = LogBytesPerLong;\n+static const int MetaspaceMinAlignmentBytes = 1 << LogMetaspaceMinimalAlignment;\n+static const int MetaspaceMinAlignmentWords = MetaspaceMinAlignmentBytes \/ BytesPerWord;\n+\n+\/\/ The maximum possible alignment is the smallest chunk size (note that the buddy allocator places\n+\/\/ chunks at chunk-size-aligned boundaries, therefore the start address is guaranteed to be aligned).\n+\/\/ We cannot guarantee allocation alignment beyond this value.\n+static const int MetaspaceMaxAlignmentWords = chunklevel::MIN_CHUNK_WORD_SIZE;\n+\n+\/\/ Given a net allocation word size and an alignment value, return the raw word size we actually\n+\/\/ allocate internally.\n+inline size_t get_raw_word_size_for_requested_word_size(size_t net_word_size,\n+                                                        size_t alignment_words) {\n+\n+  \/\/ The alignment should be between the minimum alignment but cannot be larger than the smallest chunk size\n+  assert(is_power_of_2(alignment_words), \"invalid alignment\");\n+  assert(alignment_words >= MetaspaceMinAlignmentWords &&\n+         alignment_words <= MetaspaceMaxAlignmentWords,\n+         \"invalid alignment (\" SIZE_FORMAT \")\", alignment_words);\n+\n+  \/\/ Deallocated metablocks are kept in a binlist which means blocks need to have\n+  \/\/ a minimal size\n+  size_t raw_word_size = MAX2(net_word_size, FreeBlocks::MinWordSize);\n+\n+  raw_word_size = align_up(raw_word_size, alignment_words);\n+\n+  return raw_word_size;\n+}\n+\n+} \/\/ namespace metaspace\n+\n+#endif \/\/ SHARE_MEMORY_METASPACE_ALIGNMENT_HPP\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceAlignment.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -110,1 +111,1 @@\n-MetaspaceArena::MetaspaceArena(ChunkManager* chunk_manager, const ArenaGrowthPolicy* growth_policy,\n+MetaspaceArena::MetaspaceArena(ChunkManager* chunk_manager, const ArenaGrowthPolicy* growth_policy, int alignment_words,\n@@ -117,0 +118,1 @@\n+  _alignment_words(alignment_words),\n@@ -123,0 +125,1 @@\n+\n@@ -227,1 +230,1 @@\n-  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size);\n+  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size, _alignment_words);\n@@ -271,1 +274,1 @@\n-  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size);\n+  const size_t raw_word_size = get_raw_word_size_for_requested_word_size(requested_word_size, _alignment_words);\n@@ -371,1 +374,1 @@\n-  size_t raw_word_size = get_raw_word_size_for_requested_word_size(word_size);\n+  size_t raw_word_size = get_raw_word_size_for_requested_word_size(word_size, _alignment_words);\n@@ -485,2 +488,2 @@\n-  st->print_cr(\"growth-policy \" PTR_FORMAT \", lock \" PTR_FORMAT \", cm \" PTR_FORMAT \", fbl \" PTR_FORMAT,\n-                p2i(_growth_policy), p2i(_lock), p2i(_chunk_manager), p2i(_fbl));\n+  st->print_cr(\"growth-policy \" PTR_FORMAT \", alignment %d, lock \" PTR_FORMAT \", cm \" PTR_FORMAT \", fbl \" PTR_FORMAT,\n+                p2i(_growth_policy), _alignment_words * BytesPerWord, p2i(_lock), p2i(_chunk_manager), p2i(_fbl));\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+  \/\/ Alignment alignment, in words.\n+  const int _alignment_words;\n+\n@@ -167,1 +170,1 @@\n-  MetaspaceArena(ChunkManager* chunk_manager, const ArenaGrowthPolicy* growth_policy,\n+  MetaspaceArena(ChunkManager* chunk_manager, const ArenaGrowthPolicy* growth_policy, int alignment_words,\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -171,18 +172,0 @@\n-\/\/ Given a net allocation word size, return the raw word size we actually allocate.\n-\/\/ Note: externally visible for gtests.\n-\/\/static\n-size_t get_raw_word_size_for_requested_word_size(size_t word_size) {\n-  size_t byte_size = word_size * BytesPerWord;\n-\n-  \/\/ Deallocated metablocks are kept in a binlist which limits their minimal\n-  \/\/  size to at least the size of a binlist item (2 words).\n-  byte_size = MAX2(byte_size, FreeBlocks::MinWordSize * BytesPerWord);\n-\n-  \/\/ Metaspace allocations are aligned to word size.\n-  byte_size = align_up(byte_size, AllocationAlignmentByteSize);\n-\n-  size_t raw_word_size = byte_size \/ BytesPerWord;\n-  assert(raw_word_size * BytesPerWord == byte_size, \"Sanity\");\n-  return raw_word_size;\n-}\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.cpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -38,21 +38,0 @@\n-\/\/ Metaspace allocation alignment:\n-\n-\/\/ 1) Metaspace allocations have to be aligned such that 64bit values are aligned\n-\/\/  correctly.\n-\/\/\n-\/\/ 2) Klass* structures allocated from Metaspace have to be aligned to KlassAlignmentInBytes.\n-\/\/\n-\/\/ At the moment LogKlassAlignmentInBytes is 3, so KlassAlignmentInBytes == 8,\n-\/\/  so (1) and (2) can both be fulfilled with an alignment of 8. Should we increase\n-\/\/  KlassAlignmentInBytes at any time this will increase the necessary alignment as well. In\n-\/\/  that case we may think about introducing a separate alignment just for the class space\n-\/\/  since that alignment would only be needed for Klass structures.\n-\n-static const size_t AllocationAlignmentByteSize = 8;\n-STATIC_ASSERT(AllocationAlignmentByteSize == (size_t)KlassAlignmentInBytes);\n-\n-static const size_t AllocationAlignmentWordSize = AllocationAlignmentByteSize \/ BytesPerWord;\n-\n-\/\/ Returns the raw word size allocated for a given net allocation\n-size_t get_raw_word_size_for_requested_word_size(size_t word_size);\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/compressedOops.hpp\"\n@@ -108,0 +109,6 @@\n+    out->cr();\n+    out->print_cr(\"KlassAlignmentInBytes: %d\", KlassAlignmentInBytes);\n+    out->print(\"KlassEncodingMetaspaceMax: \");\n+    print_human_readable_size(out, KlassEncodingMetaspaceMax, scale);\n+    out->cr();\n+    CompressedKlassPointers::print_mode(out);\n@@ -109,1 +116,1 @@\n-    out->print(\"No class space\");\n+    out->print_cr(\"No class space\");\n@@ -111,1 +118,0 @@\n-  out->cr();\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceReporter.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -99,1 +100,2 @@\n-    arena = new MetaspaceArena(_context->cm(), growth_policy, lock, &_used_words_counter, _name);\n+    arena = new MetaspaceArena(_context->cm(), growth_policy, MetaspaceMinAlignmentWords,\n+                               lock, &_used_words_counter, _name);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/testHelpers.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -532,0 +532,4 @@\n+    \/\/ Note Lilliput: the advantages of this strategy were questionable before\n+    \/\/  (since CDS=off + Compressed oops + heap large enough to suffocate us out of lower 32g\n+    \/\/  is rare) and with Lilliput the encoding range drastically shrank. We may just do away\n+    \/\/  with this altogether.\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+address CompressedKlassPointers::_base = NULL;\n+int CompressedKlassPointers::_shift_copy = 0;\n+\n+\/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n+\/\/  cover, choose base, shift and range.\n+\/\/  The address range is the expected range of uncompressed Klass pointers we\n+\/\/  will encounter (and the implicit promise that there will be no Klass\n+\/\/  structures outside this range).\n+void CompressedKlassPointers::initialize(address addr, size_t len) {\n+#ifdef _LP64\n+  assert(UseCompressedClassPointers, \"Sanity\");\n+\n+  assert(len <= (size_t)KlassEncodingMetaspaceMax, \"Range \" SIZE_FORMAT \" too large \"\n+         \"- cannot be contained fully in narrow Klass pointer encoding range.\", len);\n+\n+  if (UseSharedSpaces || DumpSharedSpaces) {\n+\n+    \/\/ Special requirements if CDS is active:\n+    \/\/ Encoding base and shift must be the same between dump and run time.\n+    \/\/   CDS takes care that the SharedBaseAddress and CompressedClassSpaceSize\n+    \/\/   are the same. Archive size will be probably different at runtime, but\n+    \/\/   it can only be smaller than at, never larger, since archives get\n+    \/\/   shrunk at the end of the dump process.\n+    \/\/   From that it follows that the range [addr, len) we are handed in at\n+    \/\/   runtime will start at the same address then at dumptime, and its len\n+    \/\/   may be smaller at runtime then it was at dump time.\n+    \/\/\n+    \/\/ To be very careful here, we avoid any optimizations and just keep using\n+    \/\/  the same address and shift value. Specifically we avoid using zero-based\n+    \/\/  encoding. We also set the expected value range to 4G (encoding range\n+    \/\/  cannot be larger than that).\n+\n+    _base = addr;\n+\n+  } else {\n+\n+    \/\/ (Note that this case is almost not worth optimizing for. CDS is typically on.)\n+    if ((addr + len) <= (address)KlassEncodingMetaspaceMax) {\n+      _base = 0;\n+    } else {\n+      _base = addr;\n+    }\n+  }\n+\n+  assert(is_valid_base(_base), \"Address \" PTR_FORMAT \" was chosen as encoding base for range [\"\n+                               PTR_FORMAT \", \" PTR_FORMAT \") but is not a valid encoding base\",\n+                               p2i(_base), p2i(addr), p2i(addr + len));\n+\n+  \/\/ For SA\n+  _shift_copy = LogKlassAlignmentInBytes;\n+\n+#else\n+  ShouldNotReachHere(); \/\/ 64-bit only\n+#endif\n+}\n+\n+\/\/ 64-bit platforms define these functions on a per-platform base. They are not needed for\n+\/\/  32-bit (in fact, the whole setup is not needed and could be excluded from compilation,\n+\/\/  but that is a question for another RFE).\n+#ifndef _LP64\n+\/\/ Given an address p, return true if p can be used as an encoding base.\n+\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n+bool CompressedKlassPointers::is_valid_base(address p) {\n+  ShouldNotReachHere(); \/\/ 64-bit only\n+  return false;\n+}\n+\n+void CompressedKlassPointers::print_mode(outputStream* st) {\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_COMPRESSEDKLASS_HPP\n+#define SHARE_OOPS_COMPRESSEDKLASS_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+class Klass;\n+\n+\/\/ Narrow Klass pointer constants;\n+#ifdef _LP64\n+const int LogKlassAlignmentInBytes = 9; \/\/ 512 byte alignment (Lilliput)\n+#else\n+const int LogKlassAlignmentInBytes = 3; \/\/ traditional 64-bit alignment\n+#endif\n+\n+const int KlassAlignmentInBytes    = 1 << LogKlassAlignmentInBytes;\n+\n+\/\/ Max. allowed size of compressed class pointer, in bits\n+const  int      MaxNarrowKlassPointerBits = 22;\n+\n+\/\/ Mask to mask in the bits which are valid to be set in a narrow Klass pointer\n+const uint64_t  NarrowKlassPointerBitMask = ((((uint64_t)1) << MaxNarrowKlassPointerBits) - 1);\n+\n+\/\/ Maximal size of compressed class pointer encoding range (2G with 22bit class ptr and 9 bit alignment).\n+const  uint64_t KlassEncodingMetaspaceMax = UCONST64(1) << (MaxNarrowKlassPointerBits + LogKlassAlignmentInBytes);\n+\n+\/\/ If compressed klass pointers then use narrowKlass.\n+typedef uint32_t narrowKlass;\n+\n+class CompressedKlassPointers : public AllStatic {\n+  friend class VMStructs;\n+  friend class ArchiveBuilder;\n+\n+  static address _base;\n+\n+  \/\/ Shift is actually a constant; we keep this just for the SA (see vmStructs.cpp and\n+  \/\/ sun\/jvm\/hotspot\/oops\/CompressedKlassPointers.java)\n+  static int _shift_copy;\n+\n+  \/\/ The decode\/encode versions taking an explicit base are for the sole use of CDS\n+  \/\/ (see ArchiveBuilder).\n+  static inline Klass* decode_raw(narrowKlass v, address base);\n+  static inline Klass* decode_not_null(narrowKlass v, address base);\n+  static inline narrowKlass encode_not_null(Klass* v, address base);\n+  DEBUG_ONLY(static inline void verify_klass_pointer(const Klass* v, address base));\n+\n+public:\n+\n+  \/\/ Given an address p, return true if p can be used as an encoding base.\n+  \/\/  (Some platforms have restrictions of what constitutes a valid base\n+  \/\/   address).\n+  static bool is_valid_base(address p);\n+\n+  \/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n+  \/\/  cover, choose base, shift and range.\n+  \/\/  The address range is the expected range of uncompressed Klass pointers we\n+  \/\/  will encounter (and the implicit promise that there will be no Klass\n+  \/\/  structures outside this range).\n+  static void initialize(address addr, size_t len);\n+\n+  static void     print_mode(outputStream* st);\n+\n+  \/\/ The encoding base. Note: this is not necessarily the base address of the\n+  \/\/ class space nor the base address of the CDS archive.\n+  static address  base()             { return  _base; }\n+\n+  \/\/ End of the encoding range.\n+  static address  end()              { return base() + KlassEncodingMetaspaceMax; }\n+\n+  \/\/ Shift == LogKlassAlignmentInBytes (TODO: unify)\n+  static int      shift()            { return  LogKlassAlignmentInBytes; }\n+\n+  static bool is_null(Klass* v)      { return v == NULL; }\n+  static bool is_null(narrowKlass v) { return v == 0; }\n+\n+  static inline Klass* decode_raw(narrowKlass v);\n+  static inline Klass* decode_not_null(narrowKlass v);\n+  static inline Klass* decode(narrowKlass v);\n+  static inline narrowKlass encode_not_null(Klass* v);\n+  static inline narrowKlass encode(Klass* v);\n+\n+  DEBUG_ONLY(static inline void verify_klass_pointer(const Klass* v));\n+  DEBUG_ONLY(static inline void verify_narrow_klass_pointer(narrowKlass v);)\n+\n+};\n+\n+#endif \/\/ SHARE_OOPS_COMPRESSEDOOPS_HPP\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_COMPRESSEDKLASS_INLINE_HPP\n+#define SHARE_OOPS_COMPRESSEDKLASS_INLINE_HPP\n+\n+#include \"oops\/compressedKlass.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\n+inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v) {\n+  return decode_raw(v, base());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base) {\n+  return (Klass*)(void*)((uintptr_t)narrow_base +((uintptr_t)v << shift()));\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v) {\n+  return decode_not_null(v, base());\n+}\n+\n+inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v, address narrow_base) {\n+  assert(!is_null(v), \"narrow klass value can never be zero\");\n+  Klass* result = decode_raw(v, narrow_base);\n+  DEBUG_ONLY(verify_klass_pointer(result, narrow_base));\n+  return result;\n+}\n+\n+inline Klass* CompressedKlassPointers::decode(narrowKlass v) {\n+  return is_null(v) ? (Klass*)NULL : decode_not_null(v);\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v) {\n+  return encode_not_null(v, base());\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v, address narrow_base) {\n+  DEBUG_ONLY(verify_klass_pointer(v, narrow_base));\n+  uint64_t v2 = (uint64_t)(pointer_delta((void*)v, narrow_base, 1));\n+  v2 >>= shift();\n+  assert(v2 <= UINT_MAX, \"narrow klass pointer overflow\");\n+  narrowKlass result = (narrowKlass)v2;\n+  DEBUG_ONLY(verify_narrow_klass_pointer(result));\n+  assert(decode_not_null(result, narrow_base) == v, \"reversibility\");\n+  return result;\n+}\n+\n+inline narrowKlass CompressedKlassPointers::encode(Klass* v) {\n+  return is_null(v) ? (narrowKlass)0 : encode_not_null(v);\n+}\n+\n+#ifdef ASSERT\n+inline void CompressedKlassPointers::verify_klass_pointer(const Klass* v, address narrow_base) {\n+  assert(is_aligned(v, KlassAlignmentInBytes), \"misaligned Klass* pointer (\" PTR_FORMAT \")\", p2i(v));\n+  address end = narrow_base + KlassEncodingMetaspaceMax;\n+  assert((address)v >= narrow_base && (address)v < end,\n+         \"Klass (\" PTR_FORMAT \") located outside encoding range [\" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+         p2i(v), p2i(narrow_base), p2i(end));\n+}\n+\n+inline void CompressedKlassPointers::verify_klass_pointer(const Klass* v) {\n+  verify_klass_pointer(v, base());\n+}\n+\n+inline void CompressedKlassPointers::verify_narrow_klass_pointer(narrowKlass v) {\n+  \/\/ Make sure we only use the lower n bits\n+  assert((((uint64_t)v) & ~NarrowKlassPointerBitMask) == 0, \"%x: not a valid narrow klass pointer\", v);\n+}\n+#endif\n+\n+#endif \/\/ SHARE_OOPS_COMPRESSEDOOPS_HPP\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.inline.hpp","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -180,123 +180,0 @@\n-\n-\/\/ For UseCompressedClassPointers.\n-NarrowPtrStruct CompressedKlassPointers::_narrow_klass = { NULL, 0, true };\n-\n-\/\/ CompressedClassSpaceSize set to 1GB, but appear 3GB away from _narrow_ptrs_base during CDS dump.\n-\/\/ (Todo: we should #ifdef out CompressedKlassPointers for 32bit completely and fix all call sites which\n-\/\/  are compiled for 32bit to LP64_ONLY).\n-size_t CompressedKlassPointers::_range = 0;\n-\n-\n-\/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n-\/\/  cover, choose base, shift and range.\n-\/\/  The address range is the expected range of uncompressed Klass pointers we\n-\/\/  will encounter (and the implicit promise that there will be no Klass\n-\/\/  structures outside this range).\n-void CompressedKlassPointers::initialize(address addr, size_t len) {\n-#ifdef _LP64\n-  assert(is_valid_base(addr), \"Address must be a valid encoding base\");\n-  address const end = addr + len;\n-\n-  address base;\n-  int shift;\n-  size_t range;\n-\n-  if (UseSharedSpaces || DumpSharedSpaces) {\n-\n-    \/\/ Special requirements if CDS is active:\n-    \/\/ Encoding base and shift must be the same between dump and run time.\n-    \/\/   CDS takes care that the SharedBaseAddress and CompressedClassSpaceSize\n-    \/\/   are the same. Archive size will be probably different at runtime, but\n-    \/\/   it can only be smaller than at, never larger, since archives get\n-    \/\/   shrunk at the end of the dump process.\n-    \/\/   From that it follows that the range [addr, len) we are handed in at\n-    \/\/   runtime will start at the same address then at dumptime, and its len\n-    \/\/   may be smaller at runtime then it was at dump time.\n-    \/\/\n-    \/\/ To be very careful here, we avoid any optimizations and just keep using\n-    \/\/  the same address and shift value. Specifically we avoid using zero-based\n-    \/\/  encoding. We also set the expected value range to 4G (encoding range\n-    \/\/  cannot be larger than that).\n-\n-    base = addr;\n-\n-    \/\/ JDK-8265705\n-    \/\/ This is a temporary fix for aarch64: there, if the range-to-be-encoded is located\n-    \/\/  below 32g, either encoding base should be zero or base should be aligned to 4G\n-    \/\/  and shift should be zero. The simplest way to fix this for now is to force\n-    \/\/  shift to zero for both runtime and dumptime.\n-    \/\/ Note however that this is not a perfect solution. Ideally this whole function\n-    \/\/  should be CDS agnostic, that would simplify it - and testing - alot. See JDK-8267141\n-    \/\/  for details.\n-    shift = 0;\n-\n-    \/\/ This must be true since at dumptime cds+ccs is 4G, at runtime it can\n-    \/\/  only be smaller, see comment above.\n-    assert(len <= 4 * G, \"Encoding range cannot be larger than 4G\");\n-    range = 4 * G;\n-\n-  } else {\n-\n-    \/\/ Otherwise we attempt to use a zero base if the range fits in lower 32G.\n-    if (end <= (address)KlassEncodingMetaspaceMax) {\n-      base = 0;\n-    } else {\n-      base = addr;\n-    }\n-\n-    \/\/ Highest offset a Klass* can ever have in relation to base.\n-    range = end - base;\n-\n-    \/\/ We may not even need a shift if the range fits into 32bit:\n-    const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);\n-    if (range < UnscaledClassSpaceMax) {\n-      shift = 0;\n-    } else {\n-      shift = LogKlassAlignmentInBytes;\n-    }\n-\n-  }\n-\n-  set_base(base);\n-  set_shift(shift);\n-  set_range(range);\n-#else\n-  fatal(\"64bit only.\");\n-#endif\n-}\n-\n-\/\/ Given an address p, return true if p can be used as an encoding base.\n-\/\/  (Some platforms have restrictions of what constitutes a valid base address).\n-bool CompressedKlassPointers::is_valid_base(address p) {\n-#ifdef AARCH64\n-  \/\/ Below 32G, base must be aligned to 4G.\n-  \/\/ Above that point, base must be aligned to 32G\n-  if (p < (address)(32 * G)) {\n-    return is_aligned(p, 4 * G);\n-  }\n-  return is_aligned(p, (4 << LogKlassAlignmentInBytes) * G);\n-#else\n-  return true;\n-#endif\n-}\n-\n-void CompressedKlassPointers::print_mode(outputStream* st) {\n-  st->print_cr(\"Narrow klass base: \" PTR_FORMAT \", Narrow klass shift: %d, \"\n-               \"Narrow klass range: \" SIZE_FORMAT_HEX, p2i(base()), shift(),\n-               range());\n-}\n-\n-void CompressedKlassPointers::set_base(address base) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _narrow_klass._base   = base;\n-}\n-\n-void CompressedKlassPointers::set_shift(int shift)       {\n-  assert(shift == 0 || shift == LogKlassAlignmentInBytes, \"invalid shift for klass ptrs\");\n-  _narrow_klass._shift   = shift;\n-}\n-\n-void CompressedKlassPointers::set_range(size_t range) {\n-  assert(UseCompressedClassPointers, \"no compressed klass ptrs?\");\n-  _range = range;\n-}\n","filename":"src\/hotspot\/share\/oops\/compressedOops.cpp","additions":0,"deletions":123,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -142,53 +142,0 @@\n-\/\/ For UseCompressedClassPointers.\n-class CompressedKlassPointers : public AllStatic {\n-  friend class VMStructs;\n-\n-  static NarrowPtrStruct _narrow_klass;\n-\n-  \/\/ Together with base, this defines the address range within which Klass\n-  \/\/  structures will be located: [base, base+range). While the maximal\n-  \/\/  possible encoding range is 4|32G for shift 0|3, if we know beforehand\n-  \/\/  the expected range of Klass* pointers will be smaller, a platform\n-  \/\/  could use this info to optimize encoding.\n-  static size_t _range;\n-\n-  static void set_base(address base);\n-  static void set_range(size_t range);\n-\n-public:\n-\n-  static void set_shift(int shift);\n-\n-\n-  \/\/ Given an address p, return true if p can be used as an encoding base.\n-  \/\/  (Some platforms have restrictions of what constitutes a valid base\n-  \/\/   address).\n-  static bool is_valid_base(address p);\n-\n-  \/\/ Given an address range [addr, addr+len) which the encoding is supposed to\n-  \/\/  cover, choose base, shift and range.\n-  \/\/  The address range is the expected range of uncompressed Klass pointers we\n-  \/\/  will encounter (and the implicit promise that there will be no Klass\n-  \/\/  structures outside this range).\n-  static void initialize(address addr, size_t len);\n-\n-  static void     print_mode(outputStream* st);\n-\n-  static address  base()               { return  _narrow_klass._base; }\n-  static size_t   range()              { return  _range; }\n-  static int      shift()              { return  _narrow_klass._shift; }\n-\n-  static bool is_null(Klass* v)      { return v == NULL; }\n-  static bool is_null(narrowKlass v) { return v == 0; }\n-\n-  static inline Klass* decode_raw(narrowKlass v, address base);\n-  static inline Klass* decode_raw(narrowKlass v);\n-  static inline Klass* decode_not_null(narrowKlass v);\n-  static inline Klass* decode_not_null(narrowKlass v, address base);\n-  static inline Klass* decode(narrowKlass v);\n-  static inline narrowKlass encode_not_null(Klass* v);\n-  static inline narrowKlass encode_not_null(Klass* v, address base);\n-  static inline narrowKlass encode(Klass* v);\n-\n-};\n-\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":0,"deletions":53,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -116,46 +116,0 @@\n-static inline bool check_alignment(Klass* v) {\n-  return (intptr_t)v % KlassAlignmentInBytes == 0;\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v) {\n-  return decode_raw(v, base());\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base) {\n-  return (Klass*)(void*)((uintptr_t)narrow_base +((uintptr_t)v << shift()));\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v) {\n-  return decode_not_null(v, base());\n-}\n-\n-inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v, address narrow_base) {\n-  assert(!is_null(v), \"narrow klass value can never be zero\");\n-  Klass* result = decode_raw(v, narrow_base);\n-  assert(check_alignment(result), \"address not aligned: \" INTPTR_FORMAT, p2i((void*) result));\n-  return result;\n-}\n-\n-inline Klass* CompressedKlassPointers::decode(narrowKlass v) {\n-  return is_null(v) ? (Klass*)NULL : decode_not_null(v);\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v) {\n-  return encode_not_null(v, base());\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v, address narrow_base) {\n-  assert(!is_null(v), \"klass value can never be zero\");\n-  assert(check_alignment(v), \"Address not aligned\");\n-  uint64_t pd = (uint64_t)(pointer_delta((void*)v, narrow_base, 1));\n-  assert(KlassEncodingMetaspaceMax > pd, \"change encoding max if new encoding\");\n-  uint64_t result = pd >> shift();\n-  assert((result & CONST64(0xffffffff00000000)) == 0, \"narrow klass pointer overflow\");\n-  assert(decode_not_null(result, narrow_base) == v, \"reversibility\");\n-  return (narrowKlass)result;\n-}\n-\n-inline narrowKlass CompressedKlassPointers::encode(Klass* v) {\n-  return is_null(v) ? (narrowKlass)0 : encode_not_null(v);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/compressedOops.inline.hpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -52,0 +53,1 @@\n+#include \"utilities\/align.hpp\"\n@@ -197,1 +199,3 @@\n-  return Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);\n+  MetaWord* p = Metaspace::allocate(loader_data, word_size, MetaspaceObj::ClassType, THREAD);\n+  assert(is_aligned(p, KlassAlignmentInBytes), \"metaspace returned badly aligned memory.\");\n+  return p;\n@@ -773,0 +777,4 @@\n+  if (UseCompressedClassPointers) {\n+    assert(is_aligned(this, KlassAlignmentInBytes), \"misaligned Klass structure\");\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"oops\/oopsHierarchy.hpp\"\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"oops\/compressedKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-\/\/ If compressed klass pointers then use narrowKlass.\n-typedef juint  narrowKlass;\n-\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1562,3 +1562,0 @@\n-      if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n-        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n-      }\n@@ -1570,1 +1567,0 @@\n-\n@@ -1575,25 +1571,14 @@\n-  \/\/ On some architectures, the use of UseCompressedClassPointers implies the use of\n-  \/\/ UseCompressedOops. The reason is that the rheap_base register of said platforms\n-  \/\/ is reused to perform some optimized spilling, in order to use rheap_base as a\n-  \/\/ temp register. But by treating it as any other temp register, spilling can typically\n-  \/\/ be completely avoided instead. So it is better not to perform this trick. And by\n-  \/\/ not having that reliance, large heaps, or heaps not supporting compressed oops,\n-  \/\/ can still use compressed class pointers.\n-  if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS && !UseCompressedOops) {\n-    if (UseCompressedClassPointers) {\n-      warning(\"UseCompressedClassPointers requires UseCompressedOops\");\n-    }\n-    FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n-  } else {\n-    \/\/ Turn on UseCompressedClassPointers too\n-    if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {\n-      FLAG_SET_ERGO(UseCompressedClassPointers, true);\n-    }\n-    \/\/ Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.\n-    if (UseCompressedClassPointers) {\n-      if (CompressedClassSpaceSize > KlassEncodingMetaspaceMax) {\n-        warning(\"CompressedClassSpaceSize is too large for UseCompressedClassPointers\");\n-        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n-      }\n-    }\n-  }\n+  if (!UseCompressedClassPointers) {\n+    \/\/ Lilliput requires compressed class pointers. Default shall reflect that.\n+    \/\/ If user specifies -UseCompressedClassPointers, it should be reverted with\n+    \/\/ a warning.\n+    assert(!FLAG_IS_DEFAULT(UseCompressedClassPointers), \"Wrong default for UseCompressedClassPointers\");\n+    warning(\"Lilliput reqires compressed class pointers.\");\n+    FLAG_SET_ERGO(UseCompressedClassPointers, true);\n+  }\n+  \/\/ Assert validity of compressed class space size. User arg should have been checked at this point\n+  \/\/ (see CompressedClassSpaceSizeConstraintFunc()), so no need to be nice about it, this fires in\n+  \/\/ case the default is wrong.\n+  assert(CompressedClassSpaceSize <= Metaspace::max_class_space_size(),\n+         \"CompressedClassSpaceSize \" SIZE_FORMAT \" too large (max: \" SIZE_FORMAT \")\",\n+         CompressedClassSpaceSize, Metaspace::max_class_space_size());\n@@ -1750,3 +1735,0 @@\n-          if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n-            FLAG_SET_ERGO(UseCompressedClassPointers, false);\n-          }\n@@ -4113,7 +4095,0 @@\n-#ifdef _LP64\n-  if (!FLAG_IS_DEFAULT(UseCompressedClassPointers) && !UseCompressedClassPointers) {\n-    warning(\"Compressed class pointers are required with Lilliput build; ignoring UsCompressedClassPointers flag.\");\n-  }\n-  UseCompressedClassPointers = true;\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":14,"deletions":39,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -1428,1 +1428,1 @@\n-          range(1*M, 3*G)                                                   \\\n+          constraint(CompressedClassSpaceSizeConstraintFunc,AtParse)        \\\n@@ -1430,1 +1430,1 @@\n-  develop(size_t, CompressedClassSpaceBaseAddress, 0,                       \\\n+  product(size_t, CompressedClassSpaceBaseAddress, 0, DIAGNOSTIC,           \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -382,2 +382,2 @@\n-     static_field(CompressedKlassPointers,     _narrow_klass._base,                           address)                               \\\n-     static_field(CompressedKlassPointers,     _narrow_klass._shift,                          int)                                   \\\n+     static_field(CompressedKlassPointers,     _base,                           address)                                             \\\n+     static_field(CompressedKlassPointers,     _shift_copy,                          int)                                            \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -524,5 +524,0 @@\n-const int LogKlassAlignmentInBytes = 3;\n-const int LogKlassAlignment        = LogKlassAlignmentInBytes - LogHeapWordSize;\n-const int KlassAlignmentInBytes    = 1 << LogKlassAlignmentInBytes;\n-const int KlassAlignment           = KlassAlignmentInBytes \/ HeapWordSize;\n-\n@@ -536,5 +531,0 @@\n-\/\/ Maximal size of compressed class space. Above this limit compression is not possible.\n-\/\/ Also upper bound for placement of zero based class space. (Class space is further limited\n-\/\/ to be < 3G, see arguments.cpp.)\n-const  uint64_t KlassEncodingMetaspaceMax = (uint64_t(max_juint) + 1) << LogKlassAlignmentInBytes;\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/compressedKlass.hpp\"\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -478,0 +478,5 @@\n+    \/\/ Todo: Lilliput: this is a hack. The real problem is the assumption that size\n+    \/\/  of a narrow Klass pointer can be expressed in number of bytes (getKlassPtrSize).\n+    \/\/  That assumption is present in a number of files here. Better would be\n+    \/\/  to change this to getKlassPtrSizeInBits, or to do it some other way.\n+    value &= (1 << 22) - 1; \/\/ narrow klass pointer size is 22 bits.\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/DebuggerBase.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-    baseField = type.getAddressField(\"_narrow_klass._base\");\n-    shiftField = type.getCIntegerField(\"_narrow_klass._shift\");\n+    baseField = type.getAddressField(\"_base\");\n+    shiftField = type.getCIntegerField(\"_shift_copy\");\n@@ -72,0 +72,1 @@\n+        System.out.println(\"base: \" + baseField.getValue().minus(null));\n@@ -77,1 +78,3 @@\n-    return (int)shiftField.getValue();\n+\n+      System.out.println(\"shift: \" + (int)shiftField.getValue());\n+      return (int)shiftField.getValue();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/CompressedKlassPointers.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -53,5 +54,0 @@\n-\/\/ See metaspaceArena.cpp : needed for predicting commit sizes.\n-namespace metaspace {\n-  extern size_t get_raw_word_size_for_requested_word_size(size_t net_word_size);\n-}\n-\n@@ -65,0 +61,1 @@\n+  int _alignment_words;\n@@ -67,1 +64,2 @@\n-  void initialize(const ArenaGrowthPolicy* growth_policy, const char* name = \"gtest-MetaspaceArena\") {\n+  void initialize(const ArenaGrowthPolicy* growth_policy, int alignment_words,\n+                  const char* name = \"gtest-MetaspaceArena\") {\n@@ -74,1 +72,1 @@\n-      _arena = new MetaspaceArena(&_context.cm(), _growth_policy, _lock, &_used_words_counter, name);\n+      _arena = new MetaspaceArena(&_context.cm(), _growth_policy, alignment_words, _lock, &_used_words_counter, name);\n@@ -88,1 +86,1 @@\n-    initialize(ArenaGrowthPolicy::policy_for_space_type(space_type, is_class), name);\n+    initialize(ArenaGrowthPolicy::policy_for_space_type(space_type, is_class), metaspace::MetaspaceMinAlignmentWords, name);\n@@ -96,1 +94,1 @@\n-    initialize(growth_policy, name);\n+    initialize(growth_policy, metaspace::MetaspaceMinAlignmentWords, name);\n@@ -284,1 +282,1 @@\n-    allocated += metaspace::get_raw_word_size_for_requested_word_size(s);\n+    allocated += metaspace::get_raw_word_size_for_requested_word_size(s, metaspace::MetaspaceMinAlignmentWords);\n@@ -341,1 +339,1 @@\n-    allocated += metaspace::get_raw_word_size_for_requested_word_size(s);\n+    allocated += metaspace::get_raw_word_size_for_requested_word_size(s, metaspace::MetaspaceMinAlignmentWords);\n@@ -598,1 +596,1 @@\n-    words_allocated += metaspace::get_raw_word_size_for_requested_word_size(alloc_words);\n+    words_allocated += metaspace::get_raw_word_size_for_requested_word_size(alloc_words, metaspace::MetaspaceMinAlignmentWords);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/metaspace\/metaspaceAlignment.hpp\"\n@@ -55,5 +56,0 @@\n-\/\/ See metaspaceArena.cpp : needed for predicting commit sizes.\n-namespace metaspace {\n-  extern size_t get_raw_word_size_for_requested_word_size(size_t net_word_size);\n-}\n-\n@@ -64,1 +60,2 @@\n-  MetaspaceArena* _arena;\n+  const SizeRange _allocation_range;\n+  const int _alignment_words;\n@@ -66,0 +63,1 @@\n+  MetaspaceArena* _arena;\n@@ -67,2 +65,0 @@\n-\n-  const SizeRange _allocation_range;\n@@ -90,1 +86,2 @@\n-  MemRangeCounter _alloc_count;\n+  MemRangeCounter _alloc_count_net; \/\/ net used bytes\n+  MemRangeCounter _alloc_count_raw; \/\/ net used bytes + internal overhead\n@@ -102,2 +99,2 @@\n-    assert(_dealloc_count.total_size() <= _alloc_count.total_size() &&\n-           _dealloc_count.count() <= _alloc_count.count(), \"Sanity\");\n+    assert(_dealloc_count.total_size() <= _alloc_count_net.total_size() &&\n+           _dealloc_count.count() <= _alloc_count_net.count(), \"Sanity\");\n@@ -119,1 +116,1 @@\n-    const size_t at_least_allocated = _alloc_count.total_size() - _dealloc_count.total_size();\n+    const size_t at_least_allocated = _alloc_count_net.total_size() - _dealloc_count.total_size();\n@@ -122,3 +119,6 @@\n-    const size_t max_word_overhead_per_alloc =\n-        4 + (metaspace::Settings::use_allocation_guard() ? 4 : 0);\n-    const size_t at_most_allocated = _alloc_count.total_size() + max_word_overhead_per_alloc * _alloc_count.count();\n+    size_t max_word_overhead_per_alloc = align_up(4, _alignment_words);\n+    \/\/ Guard fences come as a separate, secondary block\n+    if (metaspace::Settings::use_allocation_guard()) {\n+      max_word_overhead_per_alloc *= 2;\n+    }\n+    const size_t at_most_allocated = _alloc_count_raw.total_size() + max_word_overhead_per_alloc * _alloc_count_raw.count();\n@@ -128,1 +128,0 @@\n-\n@@ -135,1 +134,1 @@\n-  MetaspaceArenaTestBed(ChunkManager* cm, const ArenaGrowthPolicy* alloc_sequence,\n+  MetaspaceArenaTestBed(ChunkManager* cm, const ArenaGrowthPolicy* alloc_sequence, int alignment_words,\n@@ -137,0 +136,2 @@\n+    _allocation_range(allocation_range),\n+    _alignment_words(alignment_words),\n@@ -139,1 +140,0 @@\n-    _allocation_range(allocation_range),\n@@ -142,1 +142,1 @@\n-    _alloc_count(),\n+    _alloc_count_net(),\n@@ -149,1 +149,1 @@\n-    _arena = new MetaspaceArena(cm, alloc_sequence, _lock, used_words_counter, \"gtest-MetaspaceArenaTestBed-sm\");\n+    _arena = new MetaspaceArena(cm, alloc_sequence, alignment_words, _lock, used_words_counter, \"gtest-MetaspaceArenaTestBed-sm\");\n@@ -172,2 +172,2 @@\n-  size_t words_allocated() const        { return _alloc_count.total_size(); }\n-  int num_allocations() const           { return _alloc_count.count(); }\n+  size_t words_allocated() const        { return _alloc_count_net.total_size(); }\n+  int num_allocations() const           { return _alloc_count_net.count(); }\n@@ -177,0 +177,4 @@\n+  size_t calc_expected_usage_for_allocated_words(size_t word_size) {\n+    return metaspace::get_raw_word_size_for_requested_word_size(word_size, _alignment_words);\n+  }\n+\n@@ -182,1 +186,1 @@\n-      EXPECT_TRUE(is_aligned(p, sizeof(MetaWord)));\n+      EXPECT_TRUE(is_aligned(p, _alignment_words * BytesPerWord));\n@@ -189,2 +193,3 @@\n-      _alloc_count.add(word_size);\n-      if ((_alloc_count.count() % 20) == 0) {\n+      _alloc_count_net.add(word_size);\n+      _alloc_count_raw.add(calc_expected_usage_for_allocated_words(word_size));\n+      if ((_alloc_count_net.count() % 20) == 0) {\n@@ -232,1 +237,1 @@\n-  void create_new_test_bed_at(int slotindex, const ArenaGrowthPolicy* growth_policy, SizeRange allocation_range) {\n+  void create_new_test_bed_at(int slotindex, const ArenaGrowthPolicy* growth_policy, int alignment_words, SizeRange allocation_range) {\n@@ -234,1 +239,1 @@\n-    MetaspaceArenaTestBed* bed = new MetaspaceArenaTestBed(&_context.cm(), growth_policy,\n+    MetaspaceArenaTestBed* bed = new MetaspaceArenaTestBed(&_context.cm(), growth_policy, alignment_words,\n@@ -245,1 +250,4 @@\n-    create_new_test_bed_at(slotindex, growth_policy, allocation_range);\n+    const int alignment_bytes =\n+        1 << IntRange(metaspace::LogMetaspaceMinimalAlignment,\n+                      metaspace::LogMetaspaceMinimalAlignment + 7).random_value(); \/\/ zw 8 byte and 1K\n+    create_new_test_bed_at(slotindex, growth_policy, alignment_bytes \/ BytesPerWord, allocation_range);\n@@ -258,9 +266,0 @@\n-  \/\/ Create test beds for all slots\n-  void create_all_test_beds() {\n-    for (int slot = 0; slot < _testbeds.size(); slot++) {\n-      if (_testbeds.slot_is_null(slot)) {\n-        create_random_test_bed_at(slot);\n-      }\n-    }\n-  }\n-\n@@ -302,1 +301,1 @@\n-                metaspace::get_raw_word_size_for_requested_word_size(bed->size_of_last_failed_allocation()));\n+                bed->calc_expected_usage_for_allocated_words(bed->size_of_last_failed_allocation()));\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":37,"deletions":38,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -130,1 +130,3 @@\n-    String compressedClassSpaceSizeArg = \"-XX:CompressedClassSpaceSize=\" + 2 * getCompressedClassSpaceSize();\n+    \/\/ Lilliput: do not assume a max. class space size, since that is subject to change. Instead, use a value slightly smaller\n+    \/\/  than what the parent VM runs with (which is the default size).\n+    String compressedClassSpaceSizeArg = \"-XX:CompressedClassSpaceSize=\" + (getCompressedClassSpaceSize() - 1);\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestUseCompressedOopsErgoTools.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-        dump_args.addAll(Arrays.asList(new String[] { \"-Xshare:dump\", \"-Xlog:cds\" }));\n+        dump_args.addAll(Arrays.asList(new String[] { \"-Xshare:dump\", \"-Xlog:cds*\", \"-Xlog:metaspace*\" }));\n@@ -64,0 +64,1 @@\n+        output.reportDiagnosticSummary();\n@@ -73,1 +74,1 @@\n-            load_args.addAll(Arrays.asList(new String[] { \"-Xshare:on\", \"-version\" }));\n+            load_args.addAll(Arrays.asList(new String[] { \"-Xshare:on\", \"-Xlog:cds*\", \"-Xlog:metaspace*\", \"-version\" }));\n@@ -77,0 +78,1 @@\n+            output.reportDiagnosticSummary();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestSharedArchiveWithPreTouch.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ These tests test that narrow Klass pointer encoding\/decoding work.\n+\/\/\n+\/\/ Note that we do not enforce the encoding base directly. We enforce base and size of the compressed class space.\n+\/\/ The hotspot then decides on the best encoding range and scheme to chose for the given range.\n+\/\/\n+\/\/ So what we really test here is that for a given range-to-encode:\n+\/\/  - the chosen encoding range and architecture-specific mode makes sense - e.g. if range fits into low address\n+\/\/    space, use base=0 and zero-based encoding.\n+\/\/  - and that the chosen encoding actually works by starting a simple program which loads a bunch of classes.\n+\/\/\n+\/\/  In order for that to work, we have to switch of CDS. Switching off CDS means the hotspot choses the encoding base\n+\/\/  based on the class space base address (we just know this - see CompressedKlassPointers::initialize() - and if this\n+\/\/  changes, we may have to adapt this test).\n+\/\/\n+\/\/  Switching off CDS also means we use the class space much more fully. More Klass structures stored in that range\n+\/\/  and we exercise the ability of Metaspace to allocate Klass structures with the correct alignment, compatible to\n+\/\/  encoding.\n+\n+\/*\n+ * @test id=x64-area-beyond-encoding-range-use-xor\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires vm.flagless\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @run driver CompressedClassPointerEncoding\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class CompressedClassPointerEncoding {\n+\n+    \/\/ Replace:\n+    \/\/ $1 with force base address\n+    \/\/ $2 with compressed class space size\n+    final static String[] vmOptionsTemplate = new String[] {\n+      \"-XX:CompressedClassSpaceBaseAddress=$1\",\n+      \"-XX:CompressedClassSpaceSize=$2\",\n+      \"-Xshare:off\",                         \/\/ Disable CDS\n+      \"-Xlog:metaspace*\",                    \/\/ for analysis\n+      \"-XX:+PrintMetaspaceStatisticsAtExit\", \/\/ for analysis\n+      \"-version\"\n+    };\n+\n+    \/\/ Replace:\n+    \/\/ $1 with expected ccs base address (extended hex printed)\n+    \/\/ $2 with expected encoding base (extended hex printed)\n+    \/\/ $3 with expected encoding shift\n+    \/\/ $4 with expected encoding range\n+    \/\/ $5 with expected encoding mode\n+    final String[] expectedOutputTemplate = new String[] {\n+            \".*Sucessfully forced class space address to $1.*\",\n+            \".*CDS archive(s) not mapped.*\",\n+            \".*Narrow klass base: $2, Narrow klass shift: $3, Narrow klass range: $4, Encoding mode $5.*\"\n+    };\n+\n+    final static long M = 1024 * 1024;\n+    final static long G = 1024 * M;\n+\n+    final static long expectedShift = 9;\n+    final static long expectedEncodingRange = 2 * G;\n+    final static long defaultCCSSize = 32 * M;\n+\n+    enum EPlatform {\n+        \/\/ Add more where needed\n+        \/\/ (Note: this would be useful in Platform.java)\n+        linux_aarch64,\n+        linux_x64,\n+        unknown\n+    };\n+\n+    static EPlatform getCurrentPlatform() {\n+        if (Platform.isAArch64() && Platform.isLinux()) {\n+            return EPlatform.linux_aarch64;\n+        } else if (Platform.isX64() && Platform.isLinux()) {\n+            return EPlatform.linux_x64;\n+        }\n+        return EPlatform.unknown;\n+    }\n+\n+    static class TestDetails {\n+        public final EPlatform platform;\n+        public final String name;\n+        public final long[] baseAdressesToTry;\n+        public final long compressedClassSpaceSize;\n+        public final long expectedEncodingBase;\n+        public final String expectedEncodingMode;\n+\n+        public TestDetails(EPlatform platform, String name, long[] baseAdressesToTry,\n+                           long compressedClassSpaceSize, long expectedEncodingBase, String expectedEncodingMode) {\n+            this.platform = platform;\n+            this.name = name;\n+            this.baseAdressesToTry = baseAdressesToTry;\n+            this.compressedClassSpaceSize = compressedClassSpaceSize;\n+            this.expectedEncodingBase = expectedEncodingBase;\n+            this.expectedEncodingMode = expectedEncodingMode;\n+        }\n+\n+        \/\/ Simplified, common version: one base address (which we assume always works) and 32G ccs size\n+        public TestDetails(EPlatform platform, String name, long baseAdress,\n+                           long expectedEncodingBase, String expectedEncodingMode) {\n+            this(platform, name, new long[]{ baseAdress }, defaultCCSSize,\n+                 expectedEncodingBase, expectedEncodingMode);\n+        }\n+    };\n+\n+    static TestDetails[] testDetails = new TestDetails[] {\n+\n+            \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+            \/\/\/\/\/\/ x64 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+            \/\/ CCS base beyond encoding range (base=2G). Base does does not intersect the uncompressed klass pointer\n+            \/\/ bits. Encoding cannot be zero, and we should use xor+shift mode.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-beyond-encoding-range-use-xor\",\n+                    2 * G,\n+                    2 * G,\n+                    \"xor\"),\n+\n+            \/\/ CCS partly contained in encoding range. We cannot use zero based encoding. We cannot use xor either,\n+            \/\/ since the first part of the ccs intersects the encoding range. Encoding hould use add+shift.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-partly-within-encoding-range-use-add\",\n+                    0x7fc00000,\n+                    2 * G,\n+                    \"add\"),\n+\n+            \/\/ CCS (just) fully contained in encoding range (base=2G-ccs size). Expect zero-based encoding.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-within-encoding-range-use-zero\",\n+                    0x7e000000, \/\/ 2G - 32M (ccs size)\n+                    0,\n+                    \"zero\"),\n+\n+            \/\/ CCS located far beyond the zero-based limit. Base does not intersect with narrow Klass pointer bits.\n+            \/\/ We should use xor.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-far-out-no-low-bits-use-xor\",\n+                    0x800000000L, \/\/ 32G\n+                    0x800000000L,\n+                    \"xor\"),\n+\n+            \/\/ CCS located far beyond the zero-based limit. Base address intersects with narrow Klass pointer bits.\n+            \/\/ We should use add.\n+            new TestDetails(EPlatform.linux_x64,\n+                    \"x64-area-far-out-with-low-bits-use-add\",\n+                    0x800800000L, \/\/ 32G + 8M (4M is minimum ccs alignment)\n+                    0x800800000L,\n+                    \"xor\"),\n+\n+            \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+            \/\/\/\/\/\/ aarch64 \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\n+            \/\/ CCS with a base which is a valid immediate, does not intersect the uncompressed klass pointer bits,\n+            \/\/ should use xor+shift\n+            new TestDetails(EPlatform.linux_aarch64,\n+                    \"aarch64-area-beyond-encoding-range-base-valid-immediate-use-xor\",\n+                    0x800000000L, \/\/ 32G\n+                    800000000L,\n+                    \"xor\")\n+\n+            \/\/ ... add more\n+\n+    };\n+\n+    \/\/ Helper function. Given a string, replace $1 ... $n with\n+    \/\/ replacement_strings[0] ... replacement_strings[n]\n+    static private String replacePlaceholdersInString(String original, String ...replacement_strings) {\n+        String result = original;\n+        int repl_id = 1; \/\/ 1 based\n+        for (String replacement : replacement_strings) {\n+            String placeholder = \"$\" + repl_id;\n+            result = result.replace(placeholder, replacement);\n+            repl_id ++;\n+        }\n+        return result;\n+    }\n+\n+    \/\/ Helper function. Given a string array, replace $1 ... $n with\n+    \/\/ replacement_strings[0] ... replacement_strings[n]\n+    static private String[] replacePlaceholdersInArray(String[] original, String ...replacement_strings) {\n+        String[] copy = new String[original.length];\n+        for (int n = 0; n < copy.length; n ++) {\n+            copy[n] = replacePlaceholdersInString(original[n], replacement_strings);\n+        }\n+        return copy;\n+    }\n+\n+    static void runTest(TestDetails details) throws IOException {\n+        System.err.println(\"----------------------------------------------------\");\n+        System.err.println(\"Running Test: \" + details.name);\n+        System.err.println(details);\n+\n+        long ccsBaseAddress = details.baseAdressesToTry[0];\n+        String ccsBaseAddressAsHex = String.format(\"0x%016x\", ccsBaseAddress);\n+\n+        \/\/ VM Options: replace:\n+        \/\/ $1 with force base address\n+        \/\/ $2 with compressed class space size\n+        String[] vmOptions = replacePlaceholdersInArray(vmOptionsTemplate,\n+                ccsBaseAddressAsHex,              \/\/ $1\n+                (details.compressedClassSpaceSize \/ M) + \"M\");    \/\/ $2\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(vmOptions);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        System.err.println(\"----------------------------------------------------\");\n+        System.err.println(Arrays.toString(vmOptions));\n+        output.reportDiagnosticSummary();\n+        System.err.println(\"----------------------------------------------------\");\n+\n+        output.shouldHaveExitValue(0);\n+\n+    }\n+\n+    static void runTestsForPlatform(EPlatform platform) throws IOException {\n+        for (TestDetails details : testDetails) {\n+            if (details.platform == platform) {\n+                runTest(details);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTestsForPlatform(getCurrentPlatform());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointerEncoding.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -57,0 +57,3 @@\n+    \/* Lilliput: cannot work due to drastically reduced narrow klass pointer range (atm 2g and that may get\n+       smaller still). There is an argument for improving CDS\/CCS reservation and make it more likely to run\n+       zero-based, but that logic has to be rethought.\n@@ -71,0 +74,1 @@\n+     *\/\n@@ -74,0 +78,1 @@\n+    \/* Lilliput: See comment above.\n@@ -88,0 +93,1 @@\n+    *\/\n@@ -92,0 +98,2 @@\n+    \/* Lilliput: I am not sure what the point of this test CCS reservation is independent from\n+       heap. See below the desparate attempts to predict heap reservation on PPC. Why do we even care?\n@@ -112,0 +120,1 @@\n+     *\/\n@@ -117,0 +126,1 @@\n+    \/* Lilliput: narrow klass pointer range drastically reduced. See comments under smallHeapTest().\n@@ -136,0 +146,1 @@\n+    *\/\n@@ -138,0 +149,4 @@\n+    \/* Lilliput: not sure what the point of this test is. The ability to have a class space if heap uses\n+       large pages? Why would that be a problem? Kept alive for now since it makes no problems even with\n+       smaller class pointers.\n+     *\/\n@@ -198,0 +213,1 @@\n+    \/* Lilliput: narrow klass pointer range drastically reduced. See comments under smallHeapTest().\n@@ -213,0 +229,1 @@\n+    *\/\n@@ -214,0 +231,1 @@\n+    \/* Lilliput: narrow klass pointer range drastically reduced. See comments under smallHeapTest().\n@@ -233,0 +251,1 @@\n+    *\/\n@@ -234,0 +253,1 @@\n+    \/* Lilliput: narrow klass pointer range drastically reduced. See comments under smallHeapTest().\n@@ -253,0 +273,1 @@\n+    *\/\n@@ -321,4 +342,4 @@\n-        smallHeapTest();\n-        smallHeapTestWith1G();\n-        largeHeapTest();\n-        largeHeapAbove32GTest();\n+        \/\/ smallHeapTest();\n+        \/\/ smallHeapTestWith1G();\n+        \/\/ largeHeapTest();\n+        \/\/ largeHeapAbove32GTest();\n@@ -336,3 +357,3 @@\n-            smallHeapTestNoCoop();\n-            smallHeapTestWith1GNoCoop();\n-            largeHeapTestNoCoop();\n+            \/\/ smallHeapTestNoCoop();\n+            \/\/ smallHeapTestWith1GNoCoop();\n+            \/\/ largeHeapTestNoCoop();\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointers.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -41,0 +41,7 @@\n+    \/\/ Sizes beyond this will be rejected by hotspot arg parsing\n+    \/\/ (Lilliput: see Metaspace::max_class_space_size() for details)\n+    static final long max_class_space_size = 2013265920;\n+\n+    \/\/ Below this size class space will be silently enlarged to a multiple of this size\n+    static final long min_class_space_size = 4194304;\n+\n@@ -44,6 +51,0 @@\n-        \/\/ Minimum size is 1MB\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:CompressedClassSpaceSize=0\",\n-                                                   \"-version\");\n-        output = new OutputAnalyzer(pb.start());\n-        output.shouldContain(\"outside the allowed range\")\n-              .shouldHaveExitValue(1);\n@@ -58,0 +59,1 @@\n+        \/\/\/\/\/\/\/\/\/\/\/\n@@ -59,2 +61,4 @@\n-        \/\/ Maximum size is 3GB\n-        pb = ProcessTools.createJavaProcessBuilder(\"-XX:CompressedClassSpaceSize=4g\",\n+        \/\/ Going below the minimum size for class space (one root chunk size = atm 4M) should be transparently\n+        \/\/ handled by the hotspot, which should round up class space size and not report an error.\n+        pb = ProcessTools.createJavaProcessBuilder(\"-XX:CompressedClassSpaceSize=1m\",\n+                                                   \"-Xlog:gc+metaspace=trace\",\n@@ -63,2 +67,2 @@\n-        output.shouldContain(\"outside the allowed range\")\n-              .shouldHaveExitValue(1);\n+        output.shouldMatch(\"Compressed class space.*\" + min_class_space_size)\n+              .shouldHaveExitValue(0);\n@@ -66,0 +70,1 @@\n+        \/\/\/\/\/\/\/\/\/\/\/\n@@ -67,3 +72,11 @@\n-        \/\/ Make sure the minimum size is set correctly and printed\n-        \/\/ (Note: ccs size shall be rounded up to the minimum size of 4m since metaspace reservations\n-        \/\/  are done in a 4m granularity. Note that this is **reserved** size and does not affect rss.\n+        \/\/ Try 0. Same result expected.\n+        pb = ProcessTools.createJavaProcessBuilder(\"-XX:CompressedClassSpaceSize=0\",\n+                \"-Xlog:gc+metaspace=trace\",\n+                \"-version\");\n+        output = new OutputAnalyzer(pb.start());\n+        output.shouldMatch(\"Compressed class space.*\" + min_class_space_size)\n+                .shouldHaveExitValue(0);\n+\n+        \/\/\/\/\/\/\/\/\/\/\/\n+\n+        \/\/ Try max allowed size, which should be accepted\n@@ -71,1 +84,1 @@\n-                                                   \"-XX:CompressedClassSpaceSize=1m\",\n+                                                   \"-XX:CompressedClassSpaceSize=\" + max_class_space_size,\n@@ -75,1 +88,1 @@\n-        output.shouldMatch(\"Compressed class space.*4194304\")\n+        output.shouldMatch(\"Compressed class space.*\" + max_class_space_size)\n@@ -78,0 +91,1 @@\n+        \/\/\/\/\/\/\/\/\/\/\/\n@@ -79,1 +93,1 @@\n-        \/\/ Make sure the maximum size is set correctly and printed\n+        \/\/ Set max allowed size + 1, which should graciously fail\n@@ -81,3 +95,3 @@\n-                                                   \"-XX:CompressedClassSpaceSize=3g\",\n-                                                   \"-Xlog:gc+metaspace=trace\",\n-                                                   \"-version\");\n+                \"-XX:CompressedClassSpaceSize=\" + (max_class_space_size + 1),\n+                \"-Xlog:gc+metaspace=trace\",\n+                \"-version\");\n@@ -85,2 +99,3 @@\n-        output.shouldMatch(\"Compressed class space.*3221225472\")\n-              .shouldHaveExitValue(0);\n+        output.shouldContain(\"CompressedClassSpaceSize \" + (max_class_space_size + 1) + \" too large (max: \" + max_class_space_size)\n+              .shouldHaveExitValue(1);\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassSpaceSize.java","additions":36,"deletions":21,"binary":false,"changes":57,"status":"modified"}]}