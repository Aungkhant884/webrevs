{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -68,0 +70,3 @@\n+  template<int NUM_REGION_BITS>\n+  void adjust_during_full_gc(SlidingForwarding<NUM_REGION_BITS> * forwarding);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,0 +65,13 @@\n+template <int NUM_REGION_BITS>\n+void PreservedMarks::adjust_during_full_gc(SlidingForwarding<NUM_REGION_BITS>* forwarding) {\n+  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n+  while (!iter.is_empty()) {\n+    OopAndMarkWord* elem = iter.next_addr();\n+\n+    oop obj = elem->get_oop();\n+    if (obj->is_forwarded()) {\n+      elem->set_oop(forwarding->forwardee(obj));\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/memRegion.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/**\n+ * SlidingForwarding is a method to store forwarding information in a compressed form into the object header,\n+ * that has been specifically designed for sliding compaction GCs.\n+ * It avoids overriding the compressed class pointer in the upper bits of the header, which would otherwise\n+ * be lost. SlidingForwarding requires only small side tables and guarantees constant-time access and modification.\n+ *\n+ * The idea is to use a pointer compression scheme very similar to the one that is used for compressed oops.\n+ * We divide the heap into number of logical regions. Each region spans maximum of 2^NUM_BITS words.\n+ * We take advantage of the fact that sliding compaction can forward objects from ore region to a maximum of\n+ * two regions (including itself, but that does not really matter). We need 1 bit to indicate which region is forwarded\n+ * into. We also currently require the two lowest header bits to indicate that the object is forwarded.\n+ *\n+ * For addressing, we need a table with N*2 entries, for N logical regions. For each region, it gives the base\n+ * address of the two target regions, or a special placeholder if not used.\n+ *\n+ * Adding a forwarding then works as follows:\n+ * Given an original address 'orig', and a 'target' address:\n+ * - Look-up first target base of region of orig. If not yet used,\n+ *   establish it to be the base of region of target address. Use that base in step 3.\n+ * - Else, if first target base is already used, check second target base. This must either be unused, or the\n+ *   base of the region of our target address. If unused, establish it to be the base of the region of our target\n+ *   address. Use that base for next step.\n+ * - Now we found a base address. Encode the target address with that base into lowest NUM_BITS bits, and shift\n+ *   that up by 3 bits. Set the 3rd bit if we used the secondary target base, otherwise leave it at 0. Set the\n+ *   lowest two bits to indicate that the object has been forwarded. Store that in the lowest NUM_BITS+3 bits of the\n+ *   original object's header.\n+ *\n+ * Similarily, looking up the target address, given an original object address works as follows:\n+ * - Load lowest NUM_BITS + 3 from original object header. Extract target region bit and compressed address bits.\n+ * - Depending on target region bit, load base address from the target base table by looking up the corresponding entry\n+ *   for the region of the original object.\n+ * - Decode the target address by using the target base address and the compressed address bits.\n+ *\/\n+\n+template <int NUM_REGION_BITS>\n+class SlidingForwarding : public CHeapObj<mtGC> {\n+#ifdef _LP64\n+private:\n+\n+  static const uintptr_t ONE = 1ULL;\n+\n+  \/\/ We need the lowest two bits to indicate a forwarded object.\n+  static const int BASE_SHIFT = 2;\n+\n+  \/\/ The compressed address bits start here.\n+  static const int COMPRESSED_BITS_SHIFT = BASE_SHIFT + NUM_REGION_BITS;\n+\n+  \/\/ How many bits we use for the compressed pointer (we are going to need one more bit to indicate target region, and\n+  \/\/ two lowest bits to mark objects as forwarded)\n+  static const int NUM_COMPRESSED_BITS = 32 - BASE_SHIFT - NUM_REGION_BITS;\n+\n+  \/\/ Indicates an usused base address in the target base table. We cannot use 0, because that may already be\n+  \/\/ a valid base address in zero-based heaps. 0x1 is safe because heap base addresses must be aligned by 2^X.\n+  static HeapWord* const UNUSED_BASE;\n+\n+  HeapWord*  const _heap_start;\n+  size_t     const _num_regions;\n+  size_t           _region_size_words_shift;\n+  HeapWord** const _target_base_table;\n+\n+  size_t region_index_containing(HeapWord* addr) const;\n+  bool region_contains(HeapWord* region_base, HeapWord* addr) const;\n+\n+  uintptr_t encode_forwarding(HeapWord* original, HeapWord* target);\n+  HeapWord* decode_forwarding(HeapWord* original, uintptr_t encoded);\n+\n+#endif\n+\n+public:\n+  SlidingForwarding(MemRegion heap, size_t num_regions);\n+  ~SlidingForwarding();\n+\n+  void clear();\n+  void forward_to(oop original, oop target);\n+  oop forwardee(oop original);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+#ifdef _LP64\n+template <int NUM_REGION_BITS>\n+HeapWord* const SlidingForwarding<NUM_REGION_BITS>::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n+#endif\n+\n+template <int NUM_REGION_BITS>\n+SlidingForwarding<NUM_REGION_BITS>::SlidingForwarding(MemRegion heap, size_t region_size_words_shift)\n+#ifdef _LP64\n+: _heap_start(heap.start()),\n+  _num_regions(((heap.end() - heap.start()) >> region_size_words_shift) + 1),\n+  _region_size_words_shift(region_size_words_shift),\n+  _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * (ONE << NUM_REGION_BITS), mtGC)) {\n+  assert(region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n+#else\n+{\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+SlidingForwarding<NUM_REGION_BITS>::~SlidingForwarding() {\n+#ifdef _LP64\n+  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+void SlidingForwarding<NUM_REGION_BITS>::clear() {\n+#ifdef _LP64\n+  size_t max = _num_regions * (ONE << NUM_REGION_BITS);\n+  for (size_t i = 0; i < max; i++) {\n+    _target_base_table[i] = UNUSED_BASE;\n+  }\n+#endif\n+}\n+\n+#ifdef _LP64\n+template <int NUM_REGION_BITS>\n+size_t SlidingForwarding<NUM_REGION_BITS>::region_index_containing(HeapWord* addr) const {\n+  assert(addr >= _heap_start, \"sanity: addr: \" PTR_FORMAT \" heap base: \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n+  size_t index = ((size_t) (addr - _heap_start)) >> _region_size_words_shift;\n+  assert(index < _num_regions, \"Region index is in bounds: \" PTR_FORMAT, p2i(addr));\n+  return index;\n+}\n+\n+template <int NUM_REGION_BITS>\n+bool SlidingForwarding<NUM_REGION_BITS>::region_contains(HeapWord* region_base, HeapWord* addr) const {\n+  return (addr - region_base) < (ptrdiff_t)(ONE << _region_size_words_shift);\n+}\n+\n+template <int NUM_REGION_BITS>\n+uintptr_t SlidingForwarding<NUM_REGION_BITS>::encode_forwarding(HeapWord* original, HeapWord* target) {\n+  size_t orig_idx = region_index_containing(original);\n+  size_t base_table_idx = orig_idx * 2;\n+  size_t target_idx = region_index_containing(target);\n+  HeapWord* encode_base;\n+  uintptr_t region_idx;\n+  for (region_idx = 0; region_idx < (ONE << NUM_REGION_BITS); region_idx++) {\n+    encode_base = _target_base_table[base_table_idx + region_idx];\n+    if (encode_base == UNUSED_BASE) {\n+      encode_base = _heap_start + target_idx * (ONE << _region_size_words_shift);\n+      _target_base_table[base_table_idx + region_idx] = encode_base;\n+      break;\n+    } else if (region_contains(encode_base, target)) {\n+      break;\n+    }\n+  }\n+  assert(region_contains(encode_base, target), \"region must contain target\");\n+  uintptr_t encoded = (((uintptr_t)(target - encode_base)) << COMPRESSED_BITS_SHIFT) |\n+                      (region_idx << BASE_SHIFT) | markWord::marked_value;\n+  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n+  return encoded;\n+}\n+\n+template <int NUM_REGION_BITS>\n+HeapWord* SlidingForwarding<NUM_REGION_BITS>::decode_forwarding(HeapWord* original, uintptr_t encoded) {\n+  assert((encoded & markWord::marked_value) == markWord::marked_value, \"must be marked as forwarded\");\n+  size_t orig_idx = region_index_containing(original);\n+  size_t region_idx = (encoded >> BASE_SHIFT) & right_n_bits(NUM_REGION_BITS);\n+  size_t base_table_idx = orig_idx * 2 + region_idx;\n+  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n+  return decoded;\n+}\n+#endif\n+\n+template <int NUM_REGION_BITS>\n+void SlidingForwarding<NUM_REGION_BITS>::forward_to(oop original, oop target) {\n+#ifdef _LP64\n+  markWord header = original->mark();\n+  uintptr_t encoded = encode_forwarding(cast_from_oop<HeapWord*>(original), cast_from_oop<HeapWord*>(target));\n+  assert((encoded & markWord::klass_mask_in_place) == 0, \"encoded forwardee must not overlap with Klass*\");\n+  header = markWord((header.value() & markWord::klass_mask_in_place) | encoded);\n+  original->set_mark(header);\n+#else\n+  original->forward_to(target);\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+oop SlidingForwarding<NUM_REGION_BITS>::forwardee(oop original) {\n+#ifdef _LP64\n+  markWord header = original->mark();\n+  uintptr_t encoded = header.value() & ~markWord::klass_mask_in_place;\n+  HeapWord* forwardee = decode_forwarding(cast_from_oop<HeapWord*>(original), encoded);\n+  return cast_to_oop(forwardee);\n+#else\n+  return original->forwardee();\n+#endif\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -187,0 +188,1 @@\n+    heap->forwarding()->clear();\n@@ -299,0 +301,1 @@\n+  SlidingForwarding<1>*    const _forwarding;\n@@ -311,0 +314,1 @@\n+    _forwarding(ShenandoahHeap::heap()->forwarding()),\n@@ -364,1 +368,1 @@\n-    p->forward_to(cast_to_oop(_compact_point));\n+    _forwarding->forward_to(p, cast_to_oop(_compact_point));\n@@ -376,1 +380,1 @@\n-  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices) :\n+  ShenandoahPrepareForCompactionTask(PreservedMarksSet* preserved_marks, ShenandoahHeapRegionSet **worker_slices) :\n@@ -438,0 +442,1 @@\n+  SlidingForwarding<1>* forwarding = heap->forwarding();\n@@ -472,1 +477,1 @@\n-        old_obj->forward_to(cast_to_oop(heap->get_region(start)->bottom()));\n+        forwarding->forward_to(old_obj, cast_to_oop(heap->get_region(start)->bottom()));\n@@ -723,1 +728,2 @@\n-  ShenandoahHeap* const _heap;\n+  ShenandoahHeap*           const _heap;\n+  SlidingForwarding<1>*     const _forwarding;\n@@ -733,1 +739,1 @@\n-        oop forw = obj->forwardee();\n+        oop forw = _forwarding->forwardee(obj);\n@@ -742,0 +748,1 @@\n+    _forwarding(_heap->forwarding()),\n@@ -801,1 +808,2 @@\n-    _preserved_marks->get(worker_id)->adjust_during_full_gc();\n+    SlidingForwarding<1>* forwarding = ShenandoahHeap::heap()->forwarding();\n+    _preserved_marks->get(worker_id)->adjust_during_full_gc(forwarding);\n@@ -831,2 +839,3 @@\n-  ShenandoahHeap* const _heap;\n-  uint            const _worker_id;\n+  ShenandoahHeap*       const _heap;\n+  SlidingForwarding<1>* const _forwarding;\n+  uint                  const _worker_id;\n@@ -836,1 +845,1 @@\n-    _heap(ShenandoahHeap::heap()), _worker_id(worker_id) {}\n+    _heap(ShenandoahHeap::heap()), _forwarding(_heap->forwarding()), _worker_id(worker_id) {}\n@@ -843,1 +852,1 @@\n-      HeapWord* compact_to = cast_from_oop<HeapWord*>(p->forwardee());\n+      HeapWord* compact_to = cast_from_oop<HeapWord*>(_forwarding->forwardee(p));\n@@ -938,0 +947,1 @@\n+  SlidingForwarding<1>* forwarding = heap->forwarding();\n@@ -952,1 +962,1 @@\n-      size_t new_start = heap->heap_region_index_containing(old_obj->forwardee());\n+      size_t new_start = heap->heap_region_index_containing(forwarding->forwardee(old_obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -192,0 +193,2 @@\n+  _forwarding = new SlidingForwarding<1>(_heap_region, ShenandoahHeapRegion::region_size_words_shift());\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+template<int N>\n+class SlidingForwarding;\n@@ -230,0 +232,1 @@\n+  SlidingForwarding<1>* _forwarding;\n@@ -246,0 +249,2 @@\n+  SlidingForwarding<1>* forwarding() const { return _forwarding; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}