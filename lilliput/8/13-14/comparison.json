{"files":[{"patch":"@@ -309,4 +309,4 @@\n-  \/\/ NOTE: Disabled for now because it violates sliding-forwarding assumption.\n-\/\/  if (!task.has_freed_regions()) {\n-\/\/    task.prepare_serial_compaction();\n-\/\/  }\n+  \/\/ TODO: Disabled for now because it violates sliding-forwarding assumption.\n+  \/\/ if (!task.has_freed_regions()) {\n+  \/\/   task.prepare_serial_compaction();\n+  \/\/ }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-  assert(G1CollectedHeap::heap()->is_in_reserved(forwardee), \"should be in object space: \" PTR_FORMAT \"(\" PTR_FORMAT \", \" PTR_FORMAT \") \" INTPTR_FORMAT, p2i(forwardee), p2i(G1CollectedHeap::heap()->reserved().start()), p2i(G1CollectedHeap::heap()->reserved().end()), obj->mark().value());\n+  assert(G1CollectedHeap::heap()->is_in_reserved(forwardee), \"should be in object space\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+\/\/ TODO: This method is unused, except in the gunit test. Change the test\n+\/\/ to exercise the updated method below instead, and remove this one.\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+  \/\/ TODO: This method is unused, except in the gunit test. Change the test\n+  \/\/ to exercise the updated method below instead, and remove this one.\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * We take advantage of the fact that sliding compaction can forward objects from ore region to a maximum of\n+ * We take advantage of the fact that sliding compaction can forward objects from one region to a maximum of\n@@ -73,0 +73,2 @@\n+  static const size_t NUM_REGIONS = ONE << NUM_REGION_BITS;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  for (region_idx = 0; region_idx < (ONE << NUM_REGION_BITS); region_idx++) {\n+  for (region_idx = 0; region_idx < NUM_REGIONS; region_idx++) {\n@@ -60,1 +60,1 @@\n-  if (region_idx >= (ONE << NUM_REGION_BITS)) {\n+  if (region_idx >= NUM_REGIONS) {\n@@ -62,1 +62,1 @@\n-    for (region_idx = 0; region_idx < (ONE << NUM_REGION_BITS); region_idx++) {\n+    for (region_idx = 0; region_idx < NUM_REGIONS; region_idx++) {\n@@ -66,1 +66,1 @@\n-  assert(region_idx < (ONE << NUM_REGION_BITS), \"need to have found an encoding base\");\n+  assert(region_idx < NUM_REGIONS, \"need to have found an encoding base\");\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-  ShenandoahPrepareForCompactionTask(PreservedMarksSet* preserved_marks, ShenandoahHeapRegionSet **worker_slices) :\n+  ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices) :\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+  \/\/ TODO: This is the only use of PM::adjust_during_full_gc().\n+  \/\/ GCs use the variant with a forwarding structure here,\n+  \/\/ test that variant, and remove the method.\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_preservedMarks.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}