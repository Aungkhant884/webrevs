{"files":[{"patch":"@@ -55,12 +55,0 @@\n-void PreservedMarks::adjust_during_full_gc(SlidingForwarding* forwarding) {\n-  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n-  while (!iter.is_empty()) {\n-    OopAndMarkWord* elem = iter.next_addr();\n-\n-    oop obj = elem->get_oop();\n-    if (obj->is_forwarded()) {\n-      elem->set_oop(forwarding->forwardee(obj));\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-class SlidingForwarding;\n@@ -37,0 +36,2 @@\n+template <int N>\n+class SlidingForwarding;\n@@ -68,1 +69,3 @@\n-  void adjust_during_full_gc(SlidingForwarding* forwarding);\n+\n+  template<int NUM_REGION_BITS>\n+  void adjust_during_full_gc(SlidingForwarding<NUM_REGION_BITS> * forwarding);\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,0 +65,13 @@\n+template <int NUM_REGION_BITS>\n+void PreservedMarks::adjust_during_full_gc(SlidingForwarding<NUM_REGION_BITS>* forwarding) {\n+  StackIterator<OopAndMarkWord, mtGC> iter(_stack);\n+  while (!iter.is_empty()) {\n+    OopAndMarkWord* elem = iter.next_addr();\n+\n+    oop obj = elem->get_oop();\n+    if (obj->is_forwarded()) {\n+      elem->set_oop(forwarding->forwardee(obj));\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *2,q\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n-#include \"oops\/markWord.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-\n-#ifdef _LP64\n-HeapWord* const SlidingForwarding::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n-#endif\n-\n-SlidingForwarding::SlidingForwarding(MemRegion heap, size_t region_size_words_shift)\n-#ifdef _LP64\n-: _heap_start(heap.start()),\n-  _num_regions(((heap.end() - heap.start()) >> region_size_words_shift) + 1),\n-  _region_size_words_shift(region_size_words_shift),\n-  _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * 2, mtGC)) {\n-  assert(region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n-#else\n-{\n-#endif\n-}\n-\n-SlidingForwarding::~SlidingForwarding() {\n-#ifdef _LP64\n-  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n-#endif\n-}\n-\n-void SlidingForwarding::clear() {\n-#ifdef _LP64\n-  size_t max = _num_regions * 2;\n-  for (size_t i = 0; i < max; i++) {\n-    _target_base_table[i] = UNUSED_BASE;\n-  }\n-#endif\n-}\n-\n-#ifdef _LP64\n-size_t SlidingForwarding::region_index_containing(HeapWord* addr) const {\n-  assert(addr >= _heap_start, \"sanity: addr: \" PTR_FORMAT \" heap base: \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n-  size_t index = ((size_t) (addr - _heap_start)) >> _region_size_words_shift;\n-  assert(index < _num_regions, \"Region index is in bounds: \" PTR_FORMAT, p2i(addr));\n-  return index;\n-}\n-\n-bool SlidingForwarding::region_contains(HeapWord* region_base, HeapWord* addr) const {\n-  return (addr - region_base) < (ptrdiff_t)(ONE << _region_size_words_shift);\n-}\n-\n-uintptr_t SlidingForwarding::encode_forwarding(HeapWord* original, HeapWord* target) {\n-  size_t orig_idx = region_index_containing(original);\n-  size_t base_table_idx = orig_idx * 2;\n-  size_t target_idx = region_index_containing(target);\n-  HeapWord* encode_base = _target_base_table[base_table_idx];\n-  uintptr_t flag = 0;\n-  if (encode_base == UNUSED_BASE) {\n-    encode_base = _heap_start + target_idx * (ONE << _region_size_words_shift);\n-    _target_base_table[base_table_idx] = encode_base;\n-  } else if (!region_contains(encode_base, target)) {\n-    base_table_idx++;\n-    flag = 1;\n-    encode_base = _target_base_table[base_table_idx];\n-    if (encode_base == UNUSED_BASE) {\n-      encode_base = _heap_start + target_idx * (ONE << _region_size_words_shift);\n-      _target_base_table[base_table_idx] = encode_base;\n-    }\n-  }\n-  assert(region_contains(encode_base, target), \"region must contain target\");\n-  uintptr_t encoded = (((uintptr_t)(target - encode_base)) << COMPRESSED_BITS_SHIFT) |\n-                      (flag << REGION_INDICATOR_FLAG_SHIFT) | markWord::marked_value;\n-  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n-  return encoded;\n-}\n-\n-HeapWord* SlidingForwarding::decode_forwarding(HeapWord* original, uintptr_t encoded) {\n-  assert((encoded & markWord::marked_value) == markWord::marked_value, \"must be marked as forwarded\");\n-  size_t orig_idx = region_index_containing(original);\n-  size_t flag = (encoded >> REGION_INDICATOR_FLAG_SHIFT) & 1;\n-  size_t base_table_idx = orig_idx * 2 + flag;\n-  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n-  return decoded;\n-}\n-#endif\n-\n-void SlidingForwarding::forward_to(oop original, oop target) {\n-#ifdef _LP64\n-  markWord header = original->mark();\n-  uintptr_t encoded = encode_forwarding(cast_from_oop<HeapWord*>(original), cast_from_oop<HeapWord*>(target));\n-  assert((encoded & markWord::klass_mask_in_place) == 0, \"encoded forwardee must not overlap with Klass*\");\n-  header = markWord((header.value() & markWord::klass_mask_in_place) | encoded);\n-  original->set_mark(header);\n-#else\n-  original->forward_to(target);\n-#endif\n-}\n-\n-oop SlidingForwarding::forwardee(oop original) {\n-#ifdef _LP64\n-  markWord header = original->mark();\n-  uintptr_t encoded = header.value() & ~markWord::klass_mask_in_place;\n-  HeapWord* forwardee = decode_forwarding(cast_from_oop<HeapWord*>(original), encoded);\n-  return cast_to_oop(forwardee);\n-#else\n-  return original->forwardee();\n-#endif\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.cpp","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -66,0 +66,1 @@\n+template <int NUM_REGION_BITS>\n@@ -72,3 +73,2 @@\n-  \/\/ How many bits we use for the compressed pointer (we are going to need one more bit to indicate target region, and\n-  \/\/ two lowest bits to mark objects as forwarded)\n-  static const int NUM_COMPRESSED_BITS = 29;\n+  \/\/ We need the lowest two bits to indicate a forwarded object.\n+  static const int BASE_SHIFT = 2;\n@@ -76,2 +76,2 @@\n-  \/\/ The compressed address bits start here\n-  static const int COMPRESSED_BITS_SHIFT = 3;\n+  \/\/ The compressed address bits start here.\n+  static const int COMPRESSED_BITS_SHIFT = BASE_SHIFT + NUM_REGION_BITS;\n@@ -79,2 +79,3 @@\n-  \/\/ The region indicator flag is here.\n-  static const int REGION_INDICATOR_FLAG_SHIFT = 2;\n+  \/\/ How many bits we use for the compressed pointer (we are going to need one more bit to indicate target region, and\n+  \/\/ two lowest bits to mark objects as forwarded)\n+  static const int NUM_COMPRESSED_BITS = 32 - BASE_SHIFT - NUM_REGION_BITS;\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+#define SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"oops\/markWord.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\n+#ifdef _LP64\n+template <int NUM_REGION_BITS>\n+HeapWord* const SlidingForwarding<NUM_REGION_BITS>::UNUSED_BASE = reinterpret_cast<HeapWord*>(0x1);\n+#endif\n+\n+template <int NUM_REGION_BITS>\n+SlidingForwarding<NUM_REGION_BITS>::SlidingForwarding(MemRegion heap, size_t region_size_words_shift)\n+#ifdef _LP64\n+: _heap_start(heap.start()),\n+  _num_regions(((heap.end() - heap.start()) >> region_size_words_shift) + 1),\n+  _region_size_words_shift(region_size_words_shift),\n+  _target_base_table(NEW_C_HEAP_ARRAY(HeapWord*, _num_regions * (ONE << NUM_REGION_BITS), mtGC)) {\n+  assert(region_size_words_shift <= NUM_COMPRESSED_BITS, \"regions must not be larger than maximum addressing bits allow\");\n+#else\n+{\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+SlidingForwarding<NUM_REGION_BITS>::~SlidingForwarding() {\n+#ifdef _LP64\n+  FREE_C_HEAP_ARRAY(HeapWord*, _target_base_table);\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+void SlidingForwarding<NUM_REGION_BITS>::clear() {\n+#ifdef _LP64\n+  size_t max = _num_regions * (ONE << NUM_REGION_BITS);\n+  for (size_t i = 0; i < max; i++) {\n+    _target_base_table[i] = UNUSED_BASE;\n+  }\n+#endif\n+}\n+\n+#ifdef _LP64\n+template <int NUM_REGION_BITS>\n+size_t SlidingForwarding<NUM_REGION_BITS>::region_index_containing(HeapWord* addr) const {\n+  assert(addr >= _heap_start, \"sanity: addr: \" PTR_FORMAT \" heap base: \" PTR_FORMAT, p2i(addr), p2i(_heap_start));\n+  size_t index = ((size_t) (addr - _heap_start)) >> _region_size_words_shift;\n+  assert(index < _num_regions, \"Region index is in bounds: \" PTR_FORMAT, p2i(addr));\n+  return index;\n+}\n+\n+template <int NUM_REGION_BITS>\n+bool SlidingForwarding<NUM_REGION_BITS>::region_contains(HeapWord* region_base, HeapWord* addr) const {\n+  return (addr - region_base) < (ptrdiff_t)(ONE << _region_size_words_shift);\n+}\n+\n+template <int NUM_REGION_BITS>\n+uintptr_t SlidingForwarding<NUM_REGION_BITS>::encode_forwarding(HeapWord* original, HeapWord* target) {\n+  size_t orig_idx = region_index_containing(original);\n+  size_t base_table_idx = orig_idx * 2;\n+  size_t target_idx = region_index_containing(target);\n+  HeapWord* encode_base;\n+  uintptr_t region_idx;\n+  for (region_idx = 0; region_idx < (ONE << NUM_REGION_BITS); region_idx++) {\n+    encode_base = _target_base_table[base_table_idx + region_idx];\n+    if (encode_base == UNUSED_BASE) {\n+      encode_base = _heap_start + target_idx * (ONE << _region_size_words_shift);\n+      _target_base_table[base_table_idx + region_idx] = encode_base;\n+      break;\n+    } else if (region_contains(encode_base, target)) {\n+      break;\n+    }\n+  }\n+  assert(region_contains(encode_base, target), \"region must contain target\");\n+  uintptr_t encoded = (((uintptr_t)(target - encode_base)) << COMPRESSED_BITS_SHIFT) |\n+                      (region_idx << BASE_SHIFT) | markWord::marked_value;\n+  assert(target == decode_forwarding(original, encoded), \"must be reversible\");\n+  return encoded;\n+}\n+\n+template <int NUM_REGION_BITS>\n+HeapWord* SlidingForwarding<NUM_REGION_BITS>::decode_forwarding(HeapWord* original, uintptr_t encoded) {\n+  assert((encoded & markWord::marked_value) == markWord::marked_value, \"must be marked as forwarded\");\n+  size_t orig_idx = region_index_containing(original);\n+  size_t region_idx = (encoded >> BASE_SHIFT) & right_n_bits(NUM_REGION_BITS);\n+  size_t base_table_idx = orig_idx * 2 + region_idx;\n+  HeapWord* decoded = _target_base_table[base_table_idx] + (encoded >> COMPRESSED_BITS_SHIFT);\n+  return decoded;\n+}\n+#endif\n+\n+template <int NUM_REGION_BITS>\n+void SlidingForwarding<NUM_REGION_BITS>::forward_to(oop original, oop target) {\n+#ifdef _LP64\n+  markWord header = original->mark();\n+  uintptr_t encoded = encode_forwarding(cast_from_oop<HeapWord*>(original), cast_from_oop<HeapWord*>(target));\n+  assert((encoded & markWord::klass_mask_in_place) == 0, \"encoded forwardee must not overlap with Klass*\");\n+  header = markWord((header.value() & markWord::klass_mask_in_place) | encoded);\n+  original->set_mark(header);\n+#else\n+  original->forward_to(target);\n+#endif\n+}\n+\n+template <int NUM_REGION_BITS>\n+oop SlidingForwarding<NUM_REGION_BITS>::forwardee(oop original) {\n+#ifdef _LP64\n+  markWord header = original->mark();\n+  uintptr_t encoded = header.value() & ~markWord::klass_mask_in_place;\n+  HeapWord* forwardee = decode_forwarding(cast_from_oop<HeapWord*>(original), encoded);\n+  return cast_to_oop(forwardee);\n+#else\n+  return original->forwardee();\n+#endif\n+}\n+\n+#endif \/\/ SHARE_GC_SHARED_SLIDINGFORWARDING_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/slidingForwarding.inline.hpp","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -301,1 +301,1 @@\n-  SlidingForwarding*       const _forwarding;\n+  SlidingForwarding<1>*    const _forwarding;\n@@ -442,1 +442,1 @@\n-  SlidingForwarding* forwarding = heap->forwarding();\n+  SlidingForwarding<1>* forwarding = heap->forwarding();\n@@ -729,1 +729,1 @@\n-  SlidingForwarding*        const _forwarding;\n+  SlidingForwarding<1>*     const _forwarding;\n@@ -808,1 +808,1 @@\n-    SlidingForwarding* forwarding = ShenandoahHeap::heap()->forwarding();\n+    SlidingForwarding<1>* forwarding = ShenandoahHeap::heap()->forwarding();\n@@ -839,3 +839,3 @@\n-  ShenandoahHeap*    const _heap;\n-  SlidingForwarding* const _forwarding;\n-  uint               const _worker_id;\n+  ShenandoahHeap*       const _heap;\n+  SlidingForwarding<1>* const _forwarding;\n+  uint                  const _worker_id;\n@@ -947,1 +947,1 @@\n-  SlidingForwarding* forwarding = heap->forwarding();\n+  SlidingForwarding<1>* forwarding = heap->forwarding();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/shared\/slidingForwarding.hpp\"\n+#include \"gc\/shared\/slidingForwarding.inline.hpp\"\n@@ -193,1 +193,1 @@\n-  _forwarding = new SlidingForwarding(_heap_region, ShenandoahHeapRegion::region_size_words_shift());\n+  _forwarding = new SlidingForwarding<1>(_heap_region, ShenandoahHeapRegion::region_size_words_shift());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+template<int N>\n@@ -231,1 +232,1 @@\n-  SlidingForwarding* _forwarding;\n+  SlidingForwarding<1>* _forwarding;\n@@ -248,1 +249,1 @@\n-  SlidingForwarding* forwarding() const { return _forwarding; }\n+  SlidingForwarding<1>* forwarding() const { return _forwarding; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}