{"files":[{"patch":"@@ -743,0 +743,73 @@\n+\/\/ Safely load a mark word from an object, even with racing stack-locking or monitor inflation.\n+\/\/ The protocol is a partial inflation-protocol: it installs INFLATING into the object's mark\n+\/\/ word in order to prevent an stack-locks or inflations from interferring (or detect such\n+\/\/ interference and retry), but then, instead of creating and installing a monitor, simply\n+\/\/ read and return the real mark word.\n+markWord ObjectSynchronizer::safe_load_mark(oop object) {\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  Inflated     - just return mark from inflated monitor\n+    \/\/ *  Stack-locked - coerce it to inflating, and then return displaced mark\n+    \/\/ *  INFLATING    - busy wait for conversion to complete\n+    \/\/ *  Neutral      - return mark\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      return dmw;\n+    }\n+\n+    \/\/ CASE: inflation in progress - inflating over a stack-lock.\n+    \/\/ Some other thread is converting from stack-locked to inflated.\n+    \/\/ Only that thread can complete inflation -- other threads must wait.\n+    \/\/ The INFLATING value is transient.\n+    \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n+    \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n+    if (mark == markWord::INFLATING()) {\n+      read_stable_mark(object);\n+      continue;\n+    }\n+\n+    \/\/ CASE: stack-locked\n+    \/\/ Could be stack-locked either by this thread or by some other thread.\n+    if (mark.has_locker()) {\n+      markWord cmp = object->cas_set_mark(markWord::INFLATING(), mark);\n+      if (cmp != mark) {\n+        continue;       \/\/ Interference -- just retry\n+      }\n+\n+      \/\/ We've successfully installed INFLATING (0) into the mark-word.\n+      \/\/ This is the only case where 0 will appear in a mark-word.\n+      \/\/ Only the singular thread that successfully swings the mark-word\n+      \/\/ to 0 can perform (or more precisely, complete) inflation.\n+\n+      \/\/ fetch the displaced mark from the owner's stack.\n+      \/\/ The owner can't die or unwind past the lock while our INFLATING\n+      \/\/ object is in the mark.  Furthermore the owner can't complete\n+      \/\/ an unlock on the object, either.\n+      markWord dmw = mark.displaced_mark_helper();\n+      \/\/ Catch if the object's header is not neutral (not locked and\n+      \/\/ not marked is what we care about here).\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+\n+      \/\/ Must preserve store ordering. The monitor state must\n+      \/\/ be stable at the time of publishing the monitor address.\n+      guarantee(object->mark() == markWord::INFLATING(), \"invariant\");\n+      \/\/ Release semantics so that above set_object() is seen first.\n+      object->release_set_mark(mark);\n+\n+      return dmw;\n+    }\n+\n+    \/\/ CASE: neutral\n+    \/\/ Catch if the object's header is not neutral (not locked and\n+    \/\/ not marked is what we care about here).\n+    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    return mark;\n+  }\n+}\n+\n@@ -757,2 +830,1 @@\n-      ObjectMonitor* monitor = inflate(Thread::current(), obj, inflate_cause_vm_internal);\n-      mark = monitor->header();\n+      mark = safe_load_mark(obj);\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":74,"deletions":2,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -124,0 +124,2 @@\n+  static markWord safe_load_mark(oop obj);\n+\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}