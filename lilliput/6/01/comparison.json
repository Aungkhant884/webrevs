{"files":[{"patch":"@@ -3064,1 +3064,1 @@\n-  _preserved_marks_set.get(worker_id)->push_if_necessary(obj, m);\n+  _preserved_marks_set.get(worker_id)->push(obj, m);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -116,8 +116,0 @@\n-    } else {\n-      \/\/ Make sure object has the correct mark-word set or that it will be\n-      \/\/ fixed when restoring the preserved marks.\n-      assert(object->mark() == markWord::prototype_for_klass(object->klass()) || \/\/ Correct mark\n-             object->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-             (UseBiasedLocking && object->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n-             \"should have correct prototype obj: \" PTR_FORMAT \" mark: \" PTR_FORMAT \" prototype: \" PTR_FORMAT,\n-             p2i(object), object->mark().value(), markWord::prototype_for_klass(object->klass()).value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -57,4 +57,3 @@\n-  if (obj->mark_must_be_preserved(mark) &&\n-      \/\/ It is not necessary to preserve marks for objects in regions we do not\n-      \/\/ compact because we do not change their headers (i.e. forward them).\n-      _collector->is_compacting(obj)) {\n+  \/\/ It is not necessary to preserve marks for objects in regions we do not\n+  \/\/ compact because we do not change their headers (i.e. forward them).\n+  if (_collector->is_compacting(obj)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -82,5 +82,0 @@\n-    assert(obj->mark() == markWord::prototype_for_klass(obj->klass()) || \/\/ Correct mark\n-           obj->mark_must_be_preserved() || \/\/ Will be restored by PreservedMarksSet\n-           (UseBiasedLocking && obj->has_bias_pattern()), \/\/ Will be restored by BiasedLocking\n-           \"Must have correct prototype or be preserved, obj: \" PTR_FORMAT \", mark: \" PTR_FORMAT \", prototype: \" PTR_FORMAT,\n-           p2i(obj), obj->mark().value(), markWord::prototype_for_klass(obj->klass()).value());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCOopClosures.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-    _preserved_marks->push_if_necessary(obj, obj_mark);\n+    _preserved_marks->push(obj, obj_mark);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -683,1 +683,1 @@\n-  _preserved_marks_set.get()->push_if_necessary(old, old->mark());\n+  _preserved_marks_set.get()->push(old, old->mark());\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,3 +44,1 @@\n-  if (obj->mark_must_be_preserved(mark)) {\n-    preserve_mark(obj, mark);\n-  }\n+  preserve_mark(obj, mark);\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,2 +55,0 @@\n-  inline bool should_preserve_mark(oop obj, markWord m) const;\n-\n@@ -60,1 +58,0 @@\n-  inline void push_if_necessary(oop obj, markWord m);\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,4 +33,0 @@\n-inline bool PreservedMarks::should_preserve_mark(oop obj, markWord m) const {\n-  return obj->mark_must_be_preserved_for_promotion_failure(m);\n-}\n-\n@@ -38,1 +34,0 @@\n-  assert(should_preserve_mark(obj, m), \"pre-condition\");\n@@ -43,6 +38,0 @@\n-inline void PreservedMarks::push_if_necessary(oop obj, markWord m) {\n-  if (should_preserve_mark(obj, m)) {\n-    push(obj, m);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/preservedMarks.inline.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -363,1 +363,1 @@\n-    _preserved_marks->push_if_necessary(p, p->mark());\n+    _preserved_marks->push(p, p->mark());\n@@ -471,1 +471,1 @@\n-        _preserved_marks->get(0)->push_if_necessary(old_obj, old_obj->mark());\n+        _preserved_marks->get(0)->push(old_obj, old_obj->mark());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -239,24 +239,0 @@\n-  \/\/ Should this header be preserved during GC?\n-  template <typename KlassProxy>\n-  inline bool must_be_preserved(KlassProxy klass) const;\n-\n-  \/\/ Should this header (including its age bits) be preserved in the\n-  \/\/ case of a promotion failure during scavenge?\n-  \/\/ Note that we special case this situation. We want to avoid\n-  \/\/ calling BiasedLocking::preserve_marks()\/restore_marks() (which\n-  \/\/ decrease the number of mark words that need to be preserved\n-  \/\/ during GC) during each scavenge. During scavenges in which there\n-  \/\/ is no promotion failure, we actually don't need to call the above\n-  \/\/ routines at all, since we don't mutate and re-initialize the\n-  \/\/ marks of promoted objects using init_mark(). However, during\n-  \/\/ scavenges which result in promotion failure, we do re-initialize\n-  \/\/ the mark words of objects, meaning that we should have called\n-  \/\/ these mark word preservation routines. Currently there's no good\n-  \/\/ place in which to call them in any of the scavengers (although\n-  \/\/ guarded by appropriate locks we could make one), but the\n-  \/\/ observation is that promotion failures are quite rare and\n-  \/\/ reducing the number of mark words preserved during them isn't a\n-  \/\/ high priority.\n-  template <typename KlassProxy>\n-  inline bool must_be_preserved_for_promotion_failure(KlassProxy klass) const;\n-\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -32,39 +32,0 @@\n-\/\/ Should this header be preserved during GC?\n-template <typename KlassProxy>\n-inline bool markWord::must_be_preserved(KlassProxy klass) const {\n-  if (UseBiasedLocking) {\n-    if (has_bias_pattern()) {\n-      \/\/ Will reset bias at end of collection\n-      \/\/ Mark words of biased and currently locked objects are preserved separately\n-      return false;\n-    }\n-    markWord prototype_header = prototype_for_klass(klass);\n-    if (prototype_header.has_bias_pattern()) {\n-      \/\/ Individual instance which has its bias revoked; must return\n-      \/\/ true for correctness\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n-\/\/ Should this header be preserved in the case of a promotion failure during scavenge?\n-template <typename KlassProxy>\n-inline bool markWord::must_be_preserved_for_promotion_failure(KlassProxy klass) const {\n-  if (UseBiasedLocking) {\n-    \/\/ We don't explicitly save off the mark words of biased and\n-    \/\/ currently-locked objects during scavenges, so if during a\n-    \/\/ promotion failure we encounter either a biased mark word or a\n-    \/\/ klass which still has a biasable prototype header, we have to\n-    \/\/ preserve the mark word. This results in oversaving, but promotion\n-    \/\/ failures are rare, and this avoids adding more complex logic to\n-    \/\/ the scavengers to call new variants of\n-    \/\/ BiasedLocking::preserve_marks() \/ restore_marks() in the middle\n-    \/\/ of a scavenge when a promotion failure has first been detected.\n-    if (has_bias_pattern() || prototype_for_klass(klass).has_bias_pattern()) {\n-      return true;\n-    }\n-  }\n-  return (!is_unlocked() || !has_no_hash());\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/markWord.inline.hpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -297,5 +297,0 @@\n-  \/\/ Checks if the mark word needs to be preserved\n-  inline bool mark_must_be_preserved() const;\n-  inline bool mark_must_be_preserved(markWord m) const;\n-  inline bool mark_must_be_preserved_for_promotion_failure(markWord m) const;\n-\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -412,17 +412,0 @@\n-bool oopDesc::mark_must_be_preserved() const {\n-  return mark_must_be_preserved(mark());\n-}\n-\n-bool oopDesc::mark_must_be_preserved(markWord m) const {\n-  \/\/ There's a circular dependency between oop.inline.hpp and\n-  \/\/ markWord.inline.hpp because markWord::must_be_preserved wants to call\n-  \/\/ oopDesc::klass(). This could be solved by calling klass() here. However,\n-  \/\/ not all paths inside must_be_preserved calls klass(). Defer the call until\n-  \/\/ the klass is actually needed.\n-  return m.must_be_preserved(DeferredObjectToKlass(this));\n-}\n-\n-bool oopDesc::mark_must_be_preserved_for_promotion_failure(markWord m) const {\n-  return m.must_be_preserved_for_promotion_failure(DeferredObjectToKlass(this));\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1444,4 +1444,2 @@\n-  if (o->mark_must_be_preserved(mark)) {\n-    _saved_mark_stack->push(mark);\n-    _saved_oop_stack->push(o);\n-  }\n+  _saved_mark_stack->push(mark);\n+  _saved_oop_stack->push(o);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}