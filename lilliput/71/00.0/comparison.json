{"files":[{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1742,1 +1742,1 @@\n-    st->print(\"ldr  rscratch2, [rthread, #thread_disarmed_offset]\\n\\t\");\n+    st->print(\"ldr  rscratch2, [rthread, #thread_disarmed_guard_value_offset]\\n\\t\");\n@@ -7618,1 +7618,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -7632,1 +7632,1 @@\n-  predicate(!needs_releasing_store(n));\n+  predicate(!needs_releasing_store(n) && n->as_Store()->barrier_data() == 0);\n@@ -8033,0 +8033,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -8045,0 +8046,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -9714,0 +9716,84 @@\n+\/\/ Manifest a CmpU result in an integer register.\n+\/\/ (src1 < src2) ? -1 : ((src1 > src2) ? 1 : 0)\n+instruct cmpU3_reg_reg(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpU3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"cmpw $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpU3(reg)\"\n+  %}\n+  ins_encode %{\n+    __ cmpw($src1$$Register, $src2$$Register);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpU3_reg_imm(iRegINoSp dst, iRegI src1, immIAddSub src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpU3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"subsw zr, $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpU3(imm)\"\n+  %}\n+  ins_encode %{\n+    __ subsw(zr, $src1$$Register, (int32_t)$src2$$constant);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+\/\/ Manifest a CmpUL result in an integer register.\n+\/\/ (src1 < src2) ? -1 : ((src1 > src2) ? 1 : 0)\n+instruct cmpUL3_reg_reg(iRegINoSp dst, iRegL src1, iRegL src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpUL3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"cmp $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpUL3(reg)\"\n+  %}\n+  ins_encode %{\n+    __ cmp($src1$$Register, $src2$$Register);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct cmpUL3_reg_imm(iRegINoSp dst, iRegL src1, immLAddSub src2, rFlagsReg flags)\n+%{\n+  match(Set dst (CmpUL3 src1 src2));\n+  effect(KILL flags);\n+\n+  ins_cost(INSN_COST * 3);\n+  format %{\n+      \"subs zr, $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lo\\t# CmpUL3(imm)\"\n+  %}\n+  ins_encode %{\n+    __ subs(zr, $src1$$Register, (int32_t)$src2$$constant);\n+    __ csetw($dst$$Register, Assembler::NE);\n+    __ cnegw($dst$$Register, $dst$$Register, Assembler::LO);\n+  %}\n+\n+  ins_pipe(pipe_class_default);\n+%}\n+\n@@ -9721,1 +9807,1 @@\n-  ins_cost(INSN_COST * 6);\n+  ins_cost(INSN_COST * 3);\n@@ -9723,3 +9809,3 @@\n-      \"cmp $src1, $src2\"\n-      \"csetw $dst, ne\"\n-      \"cnegw $dst, lt\"\n+      \"cmp $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lt\\t# CmpL3(reg)\"\n@@ -9727,1 +9813,0 @@\n-  \/\/ format %{ \"CmpL3 $dst, $src1, $src2\" %}\n@@ -9742,1 +9827,1 @@\n-  ins_cost(INSN_COST * 6);\n+  ins_cost(INSN_COST * 3);\n@@ -9744,3 +9829,3 @@\n-      \"cmp $src1, $src2\"\n-      \"csetw $dst, ne\"\n-      \"cnegw $dst, lt\"\n+      \"subs zr, $src1, $src2\\n\\t\"\n+      \"csetw $dst, ne\\n\\t\"\n+      \"cnegw $dst, lt\\t# CmpL3(imm)\"\n@@ -9749,6 +9834,1 @@\n-    int32_t con = (int32_t)$src2$$constant;\n-     if (con < 0) {\n-      __ adds(zr, $src1$$Register, -con);\n-    } else {\n-      __ subs(zr, $src1$$Register, con);\n-    }\n+    __ subs(zr, $src1$$Register, (int32_t)$src2$$constant);\n@@ -11144,1 +11224,0 @@\n-\n@@ -12960,0 +13039,1 @@\n+\n@@ -13031,1 +13111,0 @@\n-\n@@ -13745,0 +13824,292 @@\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_le(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr le\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_ge(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr ge\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 3);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n@@ -15755,3 +16126,1 @@\n-instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n+\/\/ Like compI_reg_reg or compI_reg_immI0 but without match rule and second zero parameter.\n@@ -15759,2 +16128,5 @@\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+instruct compI_reg_imm0(rFlagsReg cr, iRegI src)\n+%{\n+  effect(DEF cr, USE src);\n+  ins_cost(INSN_COST);\n+  format %{ \"cmpw $src, 0\" %}\n@@ -15763,4 +16135,1 @@\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::LT);\n+    __ cmpw($src$$Register, 0);\n@@ -15768,2 +16137,1 @@\n-\n-  ins_pipe(icond_reg_reg);\n+  ins_pipe(icmp_reg_imm);\n@@ -15772,1 +16140,1 @@\n-instruct minI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct minI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -15782,19 +16150,0 @@\n-\n-%}\n-\/\/ FROM HERE\n-\n-instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n-\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n-\n-  ins_encode %{\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::GT);\n-  %}\n-\n-  ins_pipe(icond_reg_reg);\n@@ -15803,1 +16152,1 @@\n-instruct maxI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct maxI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -15807,0 +16156,1 @@\n+\n@@ -15814,0 +16164,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":404,"deletions":53,"binary":false,"changes":457,"status":"modified"},{"patch":"@@ -3176,1 +3176,2 @@\n-      assert_different_registers(obj, addr.base(), tmp, rscratch1, dst);\n+      assert_different_registers(obj, addr.base(), tmp, rscratch1);\n+      assert_different_registers(dst, addr.base(), tmp, rscratch1);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-  zero_words(t1, t2);\n+  address tpc = zero_words(t1, t2);\n@@ -214,0 +214,3 @@\n+  if (tpc == nullptr) {\n+    Compilation::current()->bailout(\"no space for trampoline stub\");\n+  }\n@@ -240,0 +243,3 @@\n+       if (Compilation::current()->bailed_out()) {\n+         return;\n+       }\n@@ -243,1 +249,5 @@\n-       zero_words(t1, con_size_in_bytes \/ BytesPerWord);\n+       address tpc = zero_words(t1, con_size_in_bytes \/ BytesPerWord);\n+       if (tpc == nullptr) {\n+         Compilation::current()->bailout(\"no space for trampoline stub\");\n+         return;\n+       }\n@@ -279,0 +289,3 @@\n+  if (Compilation::current()->bailed_out()) {\n+    return;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1105,0 +1105,1 @@\n+  InlineSkippedInstructionsCounter skipCounter(this);\n@@ -2461,1 +2462,3 @@\n-  Label done, not_weak;\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done, tagged, weak_tagged;\n+\n@@ -2463,0 +2466,7 @@\n+  tst(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  br(Assembler::NE, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp1, tmp2);\n+  verify_oop(value);\n+  b(done);\n@@ -2464,2 +2474,3 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);\n-  tbz(value, 0, not_weak);    \/\/ Test for jweak tag.\n+  bind(tagged);\n+  STATIC_ASSERT(JNIHandles::TypeTag::weak_global == 0b1);\n+  tbnz(value, 0, weak_tagged);    \/\/ Test for weak tag.\n@@ -2467,3 +2478,2 @@\n-  \/\/ Resolve jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,\n-                 Address(value, -JNIHandles::weak_tag_value), tmp1, tmp2);\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n@@ -2473,3 +2483,4 @@\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp1, tmp2);\n+  bind(weak_tagged);\n+  \/\/ Resolve jweak.\n+  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp1, tmp2);\n@@ -2477,0 +2488,24 @@\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    STATIC_ASSERT(JNIHandles::TypeTag::global == 0b10);\n+    Label valid_global_tag;\n+    tbnz(value, 1, valid_global_tag); \/\/ Test for global tag\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n+  verify_oop(value);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":45,"deletions":10,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -595,0 +595,8 @@\n+  inline void get_nzcv(Register reg) {\n+    mrs(0b011, 0b0100, 0b0010, 0b000, reg);\n+  }\n+\n+  inline void set_nzcv(Register reg) {\n+    msr(0b011, 0b0100, 0b0010, 0b000, reg);\n+  }\n+\n@@ -837,0 +845,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n@@ -1096,3 +1105,0 @@\n-private:\n-  void compare_eq(Register rn, Register rm, enum operand_size size);\n-\n@@ -1113,0 +1119,3 @@\n+private:\n+  void compare_eq(Register rn, Register rm, enum operand_size size);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1106,0 +1106,3 @@\n+    if (tr_call == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n@@ -1113,1 +1116,4 @@\n-    CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+    address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+    if (stub == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n@@ -1130,0 +1136,3 @@\n+  if (tr_call == nullptr) {\n+    fatal(\"CodeCache is full at gen_continuation_enter\");\n+  }\n@@ -1171,1 +1180,4 @@\n-  CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+  if (stub == nullptr) {\n+    fatal(\"CodeCache is full at gen_continuation_enter\");\n+  }\n@@ -1221,0 +1233,9 @@\n+    \/\/ handle pending exception thrown by freeze\n+    __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n+    Label ok;\n+    __ cbz(rscratch1, ok);\n+    __ leave();\n+    __ lea(rscratch1, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+    __ br(rscratch1);\n+    __ bind(ok);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2374,1 +2374,4 @@\n-      __ zero_words(bz_base, cnt_words);\n+      address tpc = __ zero_words(bz_base, cnt_words);\n+      if (tpc == nullptr) {\n+        fatal(\"CodeCache is full at generate_fill\");\n+      }\n@@ -5344,1 +5347,1 @@\n-      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_offset()) + 4);\n+      Address thread_epoch_addr(rthread, in_bytes(bs_nm->thread_disarmed_guard_value_offset()) + 4);\n@@ -6956,6 +6959,1 @@\n-    Label null_jobject;\n-    __ cbz(r0, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, r0, Address(r0, 0), rscratch1, rscratch2);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n@@ -6976,1 +6974,1 @@\n-    int insts_size = 512;\n+    int insts_size = 1024;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -3022,2 +3022,7 @@\n-      const Register Robj = data->as_register();\n-      assert_different_registers(Rptr, Rold, Robj);\n+      Register Robj = data->as_register();\n+      assert_different_registers(Rptr, Rold, Rtmp);\n+      assert_different_registers(Rptr, Robj, Rtmp);\n+      if (Robj == Rold) { \/\/ May happen with ZGC.\n+        __ mr(Rtmp, Robj);\n+        Robj = Rtmp;\n+      }\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1189,0 +1189,1 @@\n+  InlineSkippedInstructionsCounter skipCounter(this);\n@@ -2895,0 +2896,6 @@\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2,\n+                                     MacroAssembler::PreservationLevel preservation_level) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->resolve_global_jobject(this, value, tmp1, tmp2, preservation_level);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -1927,1 +1927,1 @@\n-  Unimplemented();\n+  __ pause();\n@@ -1970,1 +1970,2 @@\n-        assert_different_registers(obj, addr.base(), tmp, dst);\n+        assert_different_registers(obj, addr.base(), tmp);\n+        assert_different_registers(dst, addr.base(), tmp);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  assert(cache != tmp, \"must use different register\");\n+  assert_different_registers(cache, tmp);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -559,1 +559,3 @@\n-  Label done, not_weak;\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done, tagged, weak_tagged;\n+\n@@ -561,0 +563,8 @@\n+  \/\/ Test for tag.\n+  andi(t0, value, JNIHandles::tag_mask);\n+  bnez(t0, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp1, tmp2);\n+  verify_oop(value);\n+  j(done);\n@@ -562,0 +572,1 @@\n+  bind(tagged);\n@@ -563,2 +574,2 @@\n-  andi(t0, value, JNIHandles::weak_tag_mask);\n-  beqz(t0, not_weak);\n+  andi(t0, value, JNIHandles::TypeTag::weak_global);\n+  bnez(t0, weak_tagged);\n@@ -566,0 +577,6 @@\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value,\n+                 Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n+  j(done);\n+\n+  bind(weak_tagged);\n@@ -568,1 +585,1 @@\n-                 Address(value, -JNIHandles::weak_tag_value), tmp1, tmp2);\n+                 Address(value, -JNIHandles::TypeTag::weak_global), tmp1, tmp2);\n@@ -570,4 +587,22 @@\n-  j(done);\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp1, tmp2);\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  beqz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    andi(t0, value, JNIHandles::TypeTag::global); \/\/ Test for global tag.\n+    bnez(t0, valid_global_tag);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value,\n+                 Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n@@ -576,0 +611,1 @@\n+\n@@ -680,27 +716,0 @@\n-void MacroAssembler::baseOffset32(Register Rd, const Address &adr, int32_t &offset) {\n-  assert(Rd != noreg, \"Rd must not be empty register!\");\n-  guarantee(Rd != adr.base(), \"should use different registers!\");\n-  if (is_offset_in_range(adr.offset(), 32)) {\n-    int32_t imm = adr.offset();\n-    int32_t upper = imm, lower = imm;\n-    lower = (imm << 20) >> 20;\n-    upper -= lower;\n-    lui(Rd, upper);\n-    offset = lower;\n-  } else {\n-    offset = ((int32_t)adr.offset() << 20) >> 20;\n-    li(Rd, adr.offset() - offset);\n-  }\n-  add(Rd, Rd, adr.base());\n-}\n-\n-void MacroAssembler::baseOffset(Register Rd, const Address &adr, int32_t &offset) {\n-  if (is_offset_in_range(adr.offset(), 12)) {\n-    assert(Rd != noreg, \"Rd must not be empty register!\");\n-    addi(Rd, adr.base(), adr.offset());\n-    offset = 0;\n-  } else {\n-    baseOffset32(Rd, adr, offset);\n-  }\n-}\n-\n@@ -731,3 +740,4 @@\n-      int32_t offset = 0;\n-      baseOffset(Rd, adr, offset);\n-      addi(Rd, Rd, offset);\n+      Address new_adr = legitimize_address(Rd, adr);\n+      if (!(new_adr.base() == Rd && new_adr.offset() == 0)) {\n+        addi(Rd, new_adr.base(), new_adr.offset());\n+      }\n@@ -830,1 +840,1 @@\n-      assert(temp != noreg, \"temp must not be empty register!\");   \\\n+      assert(temp != noreg, \"expecting a register\");               \\\n@@ -852,2 +862,2 @@\n-        int32_t offset = 0;                                        \\\n-        baseOffset(temp, adr, offset);                             \\\n+        int32_t offset = ((int32_t)adr.offset() << 20) >> 20;      \\\n+        la(temp, Address(adr.base(), adr.offset() - offset));      \\\n@@ -2378,1 +2388,1 @@\n-Address MacroAssembler::form_address(Register Rd, Register base, long byte_offset) {\n+Address MacroAssembler::form_address(Register Rd, Register base, int64_t byte_offset) {\n@@ -2383,0 +2393,2 @@\n+  assert_different_registers(Rd, base, noreg);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":55,"deletions":43,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4,1 +4,1 @@\n- * Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -184,0 +184,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n@@ -266,1 +267,12 @@\n-  Address form_address(Register Rd, Register base, long byte_offset);\n+  Address form_address(Register Rd, Register base, int64_t byte_offset);\n+\n+  \/\/ Sometimes we get misaligned loads and stores, usually from Unsafe\n+  \/\/ accesses, and these can exceed the offset range.\n+  Address legitimize_address(Register Rd, const Address &adr) {\n+    if (adr.getMode() == Address::base_plus_offset) {\n+      if (!is_offset_in_range(adr.offset(), 12)) {\n+        return form_address(Rd, adr.base(), adr.offset());\n+      }\n+    }\n+    return adr;\n+  }\n@@ -367,0 +379,4 @@\n+  void pause() {\n+    fence(w, 0);\n+  }\n+\n@@ -670,3 +686,0 @@\n-  void baseOffset(Register Rd, const Address &adr, int32_t &offset);\n-  void baseOffset32(Register Rd, const Address &adr, int32_t &offset);\n-\n@@ -795,1 +808,1 @@\n-          int32_t offset = 0;                                                                      \\\n+          int32_t offset = ((int32_t)adr.offset() << 20) >> 20;                                    \\\n@@ -797,1 +810,1 @@\n-            baseOffset32(temp, adr, offset);                                                       \\\n+            la(temp, Address(adr.base(), adr.offset() - offset));                                  \\\n@@ -800,1 +813,1 @@\n-            baseOffset32(Rd, adr, offset);                                                         \\\n+            la(Rd, Address(adr.base(), adr.offset() - offset));                                    \\\n@@ -853,2 +866,2 @@\n-          int32_t offset = 0;                                                                      \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n+          int32_t offset = ((int32_t)adr.offset() << 20) >> 20;                                    \\\n+          la(temp, Address(adr.base(), adr.offset() - offset));                                    \\\n@@ -911,2 +924,2 @@\n-          int32_t offset= 0;                                                                       \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n+          int32_t offset = ((int32_t)adr.offset() << 20) >> 20;                                    \\\n+          la(temp, Address(adr.base(), adr.offset() - offset));                                    \\\n@@ -955,2 +968,2 @@\n-          int32_t offset = 0;                                                                      \\\n-          baseOffset32(temp, adr, offset);                                                         \\\n+          int32_t offset = ((int32_t)adr.offset() << 20) >> 20;                                    \\\n+          la(temp, Address(adr.base(), adr.offset() - offset));                                    \\\n@@ -1316,1 +1329,0 @@\n-\n@@ -1321,1 +1333,1 @@\n-    assert(temp != noreg, \"temp must not be empty register!\");\n+    assert(temp != noreg, \"expecting a register\");\n@@ -1331,2 +1343,0 @@\n-private:\n-\n@@ -1346,0 +1356,3 @@\n+\n+private:\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4,1 +4,1 @@\n-\/\/ Copyright (c) 2020, 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+\/\/ Copyright (c) 2020, 2023, Huawei Technologies Co., Ltd. All rights reserved.\n@@ -943,1 +943,1 @@\n-  int_def BRANCH_COST          (  100,  1 * DEFAULT_COST);          \/\/ branch, jmp, call\n+  int_def BRANCH_COST          (  200,  2 * DEFAULT_COST);          \/\/ branch, jmp, call\n@@ -952,0 +952,1 @@\n+  int_def CACHE_MISS_COST      ( 2000, 20 * DEFAULT_COST);          \/\/ typicall cache miss penalty\n@@ -1306,1 +1307,1 @@\n-    st->print(\"ld  t1, [xthread, #thread_disarmed_offset]\\n\\t\");\n+    st->print(\"ld  t1, [xthread, #thread_disarmed_guard_value_offset]\\n\\t\");\n@@ -1818,0 +1819,2 @@\n+    case Op_OnSpinWait:\n+      return VM_Version::supports_on_spin_wait();\n@@ -1845,0 +1848,4 @@\n+\n+    case Op_ConvF2HF:\n+    case Op_ConvHF2F:\n+      return UseZfhmin;\n@@ -3850,1 +3857,1 @@\n-    greater(0x1, \"gt\");\n+    greater(0x1, \"gtu\");\n@@ -3852,1 +3859,1 @@\n-    less(0x3, \"lt\");\n+    less(0x3, \"ltu\");\n@@ -3854,1 +3861,1 @@\n-    less_equal(0x5, \"le\");\n+    less_equal(0x5, \"leu\");\n@@ -3856,1 +3863,1 @@\n-    greater_equal(0x7, \"ge\");\n+    greater_equal(0x7, \"geu\");\n@@ -3872,1 +3879,1 @@\n-    greater(0x1, \"gt\");\n+    greater(0x1, \"gtu\");\n@@ -3874,1 +3881,1 @@\n-    less(0x3, \"lt\");\n+    less(0x3, \"ltu\");\n@@ -3876,1 +3883,1 @@\n-    less_equal(0x5, \"le\");\n+    less_equal(0x5, \"leu\");\n@@ -3878,1 +3885,1 @@\n-    greater_equal(0x7, \"ge\");\n+    greater_equal(0x7, \"geu\");\n@@ -4301,1 +4308,1 @@\n-pipe_class lmul_reg_reg(iRegI dst, iRegI src1, iRegI src2)\n+pipe_class lmul_reg_reg(iRegL dst, iRegL src1, iRegL src2)\n@@ -4327,1 +4334,1 @@\n-pipe_class ldiv_reg_reg(iRegI dst, iRegI src1, iRegI src2)\n+pipe_class ldiv_reg_reg(iRegL dst, iRegL src1, iRegL src2)\n@@ -4406,1 +4413,1 @@\n-\/\/------- Store pipeline operations -----------------------\n+\/\/------- Control transfer pipeline operations ------------\n@@ -5151,0 +5158,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -5166,0 +5174,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -7465,1 +7474,1 @@\n-  ins_pipe(ialu_reg_reg);\n+  ins_pipe(pipe_class_default);\n@@ -7484,1 +7493,1 @@\n-  ins_pipe(ialu_reg_reg);\n+  ins_pipe(pipe_class_default);\n@@ -7741,1 +7750,1 @@\n-  effect(TEMP cr);\n+  effect(KILL cr);\n@@ -7750,1 +7759,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(pipe_class_default);\n@@ -7755,1 +7764,1 @@\n-  effect(TEMP cr);\n+  effect(KILL cr);\n@@ -7764,1 +7773,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(pipe_class_default);\n@@ -7777,1 +7786,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(pipe_class_default);\n@@ -7790,1 +7799,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(pipe_class_default);\n@@ -7903,0 +7912,14 @@\n+instruct spin_wait() %{\n+  predicate(UseZihintpause);\n+  match(OnSpinWait);\n+  ins_cost(CACHE_MISS_COST);\n+\n+  format %{ \"spin_wait\" %}\n+\n+  ins_encode %{\n+    __ pause();\n+  %}\n+\n+  ins_pipe(pipe_serial);\n+%}\n+\n@@ -8172,0 +8195,38 @@\n+\/\/ float <-> half float\n+\n+instruct convHF2F_reg_reg(fRegF dst, iRegINoSp src, fRegF tmp) %{\n+  predicate(UseZfhmin);\n+  match(Set dst (ConvHF2F src));\n+  effect(TEMP tmp);\n+\n+  ins_cost(XFER_COST);\n+  format %{ \"fmv.h.x $tmp, $src\\t#@convHF2F_reg_reg\\n\\t\"\n+            \"fcvt.s.h $dst, $tmp\\t#@convHF2F_reg_reg\"\n+  %}\n+\n+  ins_encode %{\n+    __ fmv_h_x($tmp$$FloatRegister, $src$$Register);\n+    __ fcvt_s_h($dst$$FloatRegister, $tmp$$FloatRegister);\n+  %}\n+\n+  ins_pipe(fp_i2f);\n+%}\n+\n+instruct convF2HF_reg_reg(iRegINoSp dst, fRegF src, fRegF tmp) %{\n+  predicate(UseZfhmin);\n+  match(Set dst (ConvF2HF src));\n+  effect(TEMP tmp);\n+\n+  ins_cost(XFER_COST);\n+  format %{ \"fcvt.h.s $tmp, $src\\t#@convF2HF_reg_reg\\n\\t\"\n+            \"fmv.x.h $dst, $tmp\\t#@convF2HF_reg_reg\"\n+  %}\n+\n+  ins_encode %{\n+    __ fcvt_h_s($tmp$$FloatRegister, $src$$FloatRegister);\n+    __ fmv_x_h($dst$$Register, $tmp$$FloatRegister);\n+  %}\n+\n+  ins_pipe(fp_f2i);\n+%}\n+\n@@ -8269,1 +8330,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(pipe_class_default);\n@@ -8284,1 +8345,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(pipe_class_default);\n@@ -8299,1 +8360,1 @@\n-  ins_pipe(ialu_reg);\n+  ins_pipe(pipe_class_default);\n@@ -8315,1 +8376,1 @@\n-   ins_pipe(ialu_reg);\n+   ins_pipe(pipe_class_default);\n@@ -8333,1 +8394,1 @@\n-   ins_pipe(ialu_reg);\n+   ins_pipe(pipe_class_default);\n@@ -8370,1 +8431,1 @@\n-  ins_pipe(pipe_class_memory);\n+  ins_pipe(fp_load_mem_s);\n@@ -8406,1 +8467,1 @@\n-  ins_pipe(pipe_class_memory);\n+  ins_pipe(fp_load_mem_d);\n@@ -8424,1 +8485,1 @@\n-  ins_pipe(pipe_class_memory);\n+  ins_pipe(fp_store_reg_s);\n@@ -8460,1 +8521,1 @@\n-  ins_pipe(pipe_class_memory);\n+  ins_pipe(fp_store_reg_d);\n@@ -8551,0 +8612,1 @@\n+\n@@ -8650,0 +8712,90 @@\n+instruct minI_reg_reg(iRegINoSp dst, iRegI src)\n+%{\n+  match(Set dst (MinI dst src));\n+\n+  ins_cost(BRANCH_COST + ALU_COST);\n+  format %{\n+    \"ble $dst, $src, skip\\t#@minI_reg_reg\\n\\t\"\n+    \"mv  $dst, $src\\n\\t\"\n+    \"skip:\"\n+  %}\n+\n+  ins_encode %{\n+    Label Lskip;\n+    __ ble(as_Register($dst$$reg), as_Register($src$$reg), Lskip);\n+    __ mv(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ bind(Lskip);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct maxI_reg_reg(iRegINoSp dst, iRegI src)\n+%{\n+  match(Set dst (MaxI dst src));\n+\n+  ins_cost(BRANCH_COST + ALU_COST);\n+  format %{\n+    \"bge $dst, $src, skip\\t#@maxI_reg_reg\\n\\t\"\n+    \"mv  $dst, $src\\n\\t\"\n+    \"skip:\"\n+  %}\n+\n+  ins_encode %{\n+    Label Lskip;\n+    __ bge(as_Register($dst$$reg), as_Register($src$$reg), Lskip);\n+    __ mv(as_Register($dst$$reg), as_Register($src$$reg));\n+    __ bind(Lskip);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+\/\/ special case for comparing with zero\n+\/\/ n.b. this is selected in preference to the rule above because it\n+\/\/ avoids loading constant 0 into a source register\n+\n+instruct minI_reg_zero(iRegINoSp dst, immI0 zero)\n+%{\n+  match(Set dst (MinI dst zero));\n+  match(Set dst (MinI zero dst));\n+\n+  ins_cost(BRANCH_COST + ALU_COST);\n+  format %{\n+    \"blez $dst, skip\\t#@minI_reg_zero\\n\\t\"\n+    \"mv   $dst, zr\\n\\t\"\n+    \"skip:\"\n+  %}\n+\n+  ins_encode %{\n+    Label Lskip;\n+    __ blez(as_Register($dst$$reg), Lskip);\n+    __ mv(as_Register($dst$$reg), zr);\n+    __ bind(Lskip);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n+instruct maxI_reg_zero(iRegINoSp dst, immI0 zero)\n+%{\n+  match(Set dst (MaxI dst zero));\n+  match(Set dst (MaxI zero dst));\n+\n+  ins_cost(BRANCH_COST + ALU_COST);\n+  format %{\n+    \"bgez $dst, skip\\t#@maxI_reg_zero\\n\\t\"\n+    \"mv   $dst, zr\\n\\t\"\n+    \"skip:\"\n+  %}\n+\n+  ins_encode %{\n+    Label Lskip;\n+    __ bgez(as_Register($dst$$reg), Lskip);\n+    __ mv(as_Register($dst$$reg), zr);\n+    __ bind(Lskip);\n+  %}\n+\n+  ins_pipe(pipe_class_compare);\n+%}\n+\n@@ -8676,1 +8828,1 @@\n-  ins_pipe(ialu_reg_reg);\n+  ins_pipe(pipe_class_compare);\n@@ -8706,1 +8858,1 @@\n-  ins_pipe(ialu_reg_reg);\n+  ins_pipe(pipe_class_compare);\n@@ -9883,4 +10035,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovI_cmpI\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpI\\n\\t\"\n+  %}\n@@ -9894,1 +10044,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9902,4 +10052,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovI_cmpU\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpU\\n\\t\"\n+  %}\n@@ -9913,1 +10061,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9921,4 +10069,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovI_cmpL\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpL\\n\\t\"\n+  %}\n@@ -9932,1 +10078,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9940,4 +10086,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovL_cmpL\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpL\\n\\t\"\n+  %}\n@@ -9951,1 +10095,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9959,4 +10103,2 @@\n-             \"bneg$cop $op1, $op2, skip\\t#@cmovL_cmpUL\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovL_cmpUL\\n\\t\"\n+  %}\n@@ -9970,1 +10112,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n@@ -9976,0 +10118,1 @@\n+\n@@ -9977,4 +10120,2 @@\n-             \"bneg$cop $op1, $op2\\t#@cmovI_cmpUL\\n\\t\"\n-             \"mv $dst, $src\\n\\t\"\n-             \"skip:\"\n-         %}\n+    \"CMove $dst, ($op1 $cop $op2), $dst, $src\\t#@cmovI_cmpUL\\n\\t\"\n+  %}\n@@ -9988,1 +10129,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_compare);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":205,"deletions":64,"binary":false,"changes":269,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -981,0 +981,3 @@\n+    if (tr_call == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n@@ -988,1 +991,4 @@\n-    CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+    address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+    if (stub == nullptr) {\n+      fatal(\"CodeCache is full at gen_continuation_enter\");\n+    }\n@@ -1008,0 +1014,3 @@\n+  if (tr_call == nullptr) {\n+    fatal(\"CodeCache is full at gen_continuation_enter\");\n+  }\n@@ -1048,1 +1057,4 @@\n-  CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+  address stub = CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+  if (stub == nullptr) {\n+    fatal(\"CodeCache is full at gen_continuation_enter\");\n+  }\n@@ -1098,0 +1110,9 @@\n+  \/\/ handle pending exception thrown by freeze\n+  __ ld(t0, Address(xthread, in_bytes(Thread::pending_exception_offset())));\n+  Label ok;\n+  __ beqz(t0, ok);\n+  __ leave();\n+  __ la(t0, RuntimeAddress(StubRoutines::forward_exception_entry()));\n+  __ jr(t0);\n+  __ bind(ok);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3247,0 +3247,189 @@\n+int C2_MacroAssembler::arrays_hashcode_elsize(BasicType eltype) {\n+  switch (eltype) {\n+  case T_BOOLEAN: return sizeof(jboolean);\n+  case T_BYTE:  return sizeof(jbyte);\n+  case T_SHORT: return sizeof(jshort);\n+  case T_CHAR:  return sizeof(jchar);\n+  case T_INT:   return sizeof(jint);\n+  default:\n+    ShouldNotReachHere();\n+    return -1;\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elload(Register dst, Address src, BasicType eltype) {\n+  switch (eltype) {\n+  \/\/ T_BOOLEAN used as surrogate for unsigned byte\n+  case T_BOOLEAN: movzbl(dst, src);   break;\n+  case T_BYTE:    movsbl(dst, src);   break;\n+  case T_SHORT:   movswl(dst, src);   break;\n+  case T_CHAR:    movzwl(dst, src);   break;\n+  case T_INT:     movl(dst, src);     break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype) {\n+  const int vlen = Assembler::AVX_256bit;\n+  switch (eltype) {\n+  case T_BOOLEAN: vector_unsigned_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_BYTE:      vector_signed_cast(dst, dst, vlen, T_BYTE, T_INT);  break;\n+  case T_SHORT:     vector_signed_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n+  case T_CHAR:    vector_unsigned_cast(dst, dst, vlen, T_SHORT, T_INT); break;\n+  case T_INT:\n+    \/\/ do nothing\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode(Register ary1, Register cnt1, Register result,\n+                                        Register index, Register tmp2, Register tmp3, XMMRegister vnext,\n+                                        XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                                        XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                                        XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                                        BasicType eltype) {\n+  ShortBranchVerifier sbv(this);\n+  assert(UseAVX >= 2, \"AVX2 intrinsics are required\");\n+  assert_different_registers(ary1, cnt1, result, index, tmp2, tmp3);\n+  assert_different_registers(vnext, vcoef0, vcoef1, vcoef2, vcoef3, vresult0, vresult1, vresult2, vresult3, vtmp0, vtmp1, vtmp2, vtmp3);\n+\n+  Label SHORT_UNROLLED_BEGIN, SHORT_UNROLLED_LOOP_BEGIN,\n+        SHORT_UNROLLED_LOOP_EXIT,\n+        UNROLLED_SCALAR_LOOP_BEGIN, UNROLLED_SCALAR_SKIP, UNROLLED_SCALAR_RESUME,\n+        UNROLLED_VECTOR_LOOP_BEGIN,\n+        END;\n+  switch (eltype) {\n+  case T_BOOLEAN: BLOCK_COMMENT(\"arrays_hashcode(unsigned byte) {\"); break;\n+  case T_CHAR:    BLOCK_COMMENT(\"arrays_hashcode(char) {\");          break;\n+  case T_BYTE:    BLOCK_COMMENT(\"arrays_hashcode(byte) {\");          break;\n+  case T_SHORT:   BLOCK_COMMENT(\"arrays_hashcode(short) {\");         break;\n+  case T_INT:     BLOCK_COMMENT(\"arrays_hashcode(int) {\");           break;\n+  default:        BLOCK_COMMENT(\"arrays_hashcode {\");                break;\n+  }\n+\n+  \/\/ For \"renaming\" for readibility of the code\n+  XMMRegister vcoef[] = { vcoef0, vcoef1, vcoef2, vcoef3 },\n+              vresult[] = { vresult0, vresult1, vresult2, vresult3 },\n+              vtmp[] = { vtmp0, vtmp1, vtmp2, vtmp3 };\n+\n+  const int elsize = arrays_hashcode_elsize(eltype);\n+\n+  \/*\n+    if (cnt1 >= 2) {\n+      if (cnt1 >= 32) {\n+        UNROLLED VECTOR LOOP\n+      }\n+      UNROLLED SCALAR LOOP\n+    }\n+    SINGLE SCALAR\n+   *\/\n+\n+  cmpl(cnt1, 32);\n+  jcc(Assembler::less, SHORT_UNROLLED_BEGIN);\n+\n+  \/\/ cnt1 >= 32 && generate_vectorized_loop\n+  xorl(index, index);\n+\n+  \/\/ vresult = IntVector.zero(I256);\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpxor(vresult[idx], vresult[idx]);\n+  }\n+  \/\/ vnext = IntVector.broadcast(I256, power_of_31_backwards[0]);\n+  Register bound = tmp2;\n+  Register next = tmp3;\n+  lea(tmp2, ExternalAddress(StubRoutines::x86::arrays_hashcode_powers_of_31() + (0 * sizeof(jint))));\n+  movl(next, Address(tmp2, 0));\n+  movdl(vnext, next);\n+  vpbroadcastd(vnext, vnext, Assembler::AVX_256bit);\n+\n+  \/\/ index = 0;\n+  \/\/ bound = cnt1 & ~(32 - 1);\n+  movl(bound, cnt1);\n+  andl(bound, ~(32 - 1));\n+  \/\/ for (; index < bound; index += 32) {\n+  bind(UNROLLED_VECTOR_LOOP_BEGIN);\n+  \/\/ result *= next;\n+  imull(result, next);\n+  \/\/ loop fission to upfront the cost of fetching from memory, OOO execution\n+  \/\/ can then hopefully do a better job of prefetching\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvload(vtmp[idx], Address(ary1, index, Address::times(elsize), 8 * idx * elsize), eltype);\n+  }\n+  \/\/ vresult = vresult * vnext + ary1[index+8*idx:index+8*idx+7];\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpmulld(vresult[idx], vresult[idx], vnext, Assembler::AVX_256bit);\n+    arrays_hashcode_elvcast(vtmp[idx], eltype);\n+    vpaddd(vresult[idx], vresult[idx], vtmp[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ index += 32;\n+  addl(index, 32);\n+  \/\/ index < bound;\n+  cmpl(index, bound);\n+  jcc(Assembler::less, UNROLLED_VECTOR_LOOP_BEGIN);\n+  \/\/ }\n+\n+  lea(ary1, Address(ary1, bound, Address::times(elsize)));\n+  subl(cnt1, bound);\n+  \/\/ release bound\n+\n+  \/\/ vresult *= IntVector.fromArray(I256, power_of_31_backwards, 1);\n+  for (int idx = 0; idx < 4; idx++) {\n+    lea(tmp2, ExternalAddress(StubRoutines::x86::arrays_hashcode_powers_of_31() + ((8 * idx + 1) * sizeof(jint))));\n+    arrays_hashcode_elvload(vcoef[idx], Address(tmp2, 0), T_INT);\n+    vpmulld(vresult[idx], vresult[idx], vcoef[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ result += vresult.reduceLanes(ADD);\n+  for (int idx = 0; idx < 4; idx++) {\n+    reduceI(Op_AddReductionVI, 256\/(sizeof(jint) * 8), result, result, vresult[idx], vtmp[(idx * 2 + 0) % 4], vtmp[(idx * 2 + 1) % 4]);\n+  }\n+\n+  \/\/ } else if (cnt1 < 32) {\n+\n+  bind(SHORT_UNROLLED_BEGIN);\n+  \/\/ int i = 1;\n+  movl(index, 1);\n+  cmpl(index, cnt1);\n+  jcc(Assembler::greaterEqual, SHORT_UNROLLED_LOOP_EXIT);\n+\n+  \/\/ for (; i < cnt1 ; i += 2) {\n+  bind(SHORT_UNROLLED_LOOP_BEGIN);\n+  movl(tmp3, 961);\n+  imull(result, tmp3);\n+  arrays_hashcode_elload(tmp2, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n+  movl(tmp3, tmp2);\n+  shll(tmp3, 5);\n+  subl(tmp3, tmp2);\n+  addl(result, tmp3);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize)), eltype);\n+  addl(result, tmp3);\n+  addl(index, 2);\n+  cmpl(index, cnt1);\n+  jccb(Assembler::less, SHORT_UNROLLED_LOOP_BEGIN);\n+\n+  \/\/ }\n+  \/\/ if (i >= cnt1) {\n+  bind(SHORT_UNROLLED_LOOP_EXIT);\n+  jccb(Assembler::greater, END);\n+  movl(tmp2, result);\n+  shll(result, 5);\n+  subl(result, tmp2);\n+  arrays_hashcode_elload(tmp3, Address(ary1, index, Address::times(elsize), -elsize), eltype);\n+  addl(result, tmp3);\n+  \/\/ }\n+  bind(END);\n+\n+  BLOCK_COMMENT(\"} \/\/ arrays_hashcode\");\n+\n+} \/\/ arrays_hashcode\n+\n@@ -4729,0 +4918,27 @@\n+void C2_MacroAssembler::vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                                           BasicType from_elem_bt, BasicType to_elem_bt) {\n+  switch (from_elem_bt) {\n+    case T_BYTE:\n+      switch (to_elem_bt) {\n+        case T_SHORT: vpmovsxbw(dst, src, vlen_enc); break;\n+        case T_INT:   vpmovsxbd(dst, src, vlen_enc); break;\n+        case T_LONG:  vpmovsxbq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_SHORT:\n+      switch (to_elem_bt) {\n+        case T_INT:  vpmovsxwd(dst, src, vlen_enc); break;\n+        case T_LONG: vpmovsxwq(dst, src, vlen_enc); break;\n+        default: ShouldNotReachHere();\n+      }\n+      break;\n+    case T_INT:\n+      assert(to_elem_bt == T_LONG, \"\");\n+      vpmovsxdq(dst, src, vlen_enc);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":217,"deletions":1,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,3 +34,0 @@\n-  void emit_entry_barrier_stub(C2EntryBarrierStub* stub);\n-  static int entry_barrier_stub_size();\n-\n@@ -295,0 +292,13 @@\n+  void arrays_hashcode(Register str1, Register cnt1, Register result,\n+                       Register tmp1, Register tmp2, Register tmp3, XMMRegister vnext,\n+                       XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                       XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                       XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                       BasicType eltype);\n+\n+  \/\/ helper functions for arrays_hashcode\n+  int arrays_hashcode_elsize(BasicType eltype);\n+  void arrays_hashcode_elload(Register dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype);\n+  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype);\n@@ -312,0 +322,3 @@\n+\n+  void vector_signed_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                          BasicType from_elem_bt, BasicType to_elem_bt);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2039,0 +2039,1 @@\n+  InlineSkippedInstructionsCounter skipCounter(this);\n@@ -3877,3 +3878,3 @@\n-void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {\n-  const int32_t inverted_jweak_mask = ~static_cast<int32_t>(JNIHandles::weak_tag_mask);\n-  STATIC_ASSERT(inverted_jweak_mask == -2); \/\/ otherwise check this code\n+void MacroAssembler::clear_jobject_tag(Register possibly_non_local) {\n+  const int32_t inverted_mask = ~static_cast<int32_t>(JNIHandles::tag_mask);\n+  STATIC_ASSERT(inverted_mask == -4); \/\/ otherwise check this code\n@@ -3881,1 +3882,1 @@\n-  andptr(possibly_jweak, inverted_jweak_mask);\n+  andptr(possibly_non_local, inverted_mask);\n@@ -3888,1 +3889,1 @@\n-  Label done, not_weak;\n+  Label done, tagged, weak_tagged;\n@@ -3890,3 +3891,19 @@\n-  jcc(Assembler::zero, done);                \/\/ Use NULL as-is.\n-  testptr(value, JNIHandles::weak_tag_mask); \/\/ Test for jweak tag.\n-  jcc(Assembler::zero, not_weak);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+  testptr(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  jcc(Assembler::notZero, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(tagged);\n+  testptr(value, JNIHandles::TypeTag::weak_global); \/\/ Test for weak tag.\n+  jcc(Assembler::notZero, weak_tagged);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(weak_tagged);\n@@ -3895,1 +3912,1 @@\n-                 value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);\n+                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp, thread);\n@@ -3897,4 +3914,25 @@\n-  jmp(done);\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value,\n+                                            Register thread,\n+                                            Register tmp) {\n+  assert_different_registers(value, thread, tmp);\n+  Label done;\n+\n+  testptr(value, value);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    testptr(value, JNIHandles::TypeTag::global); \/\/ Test for global tag.\n+    jcc(Assembler::notZero, valid_global_tag);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n@@ -3902,0 +3940,1 @@\n+\n@@ -8357,5 +8396,7 @@\n-  BIND(L_wordByWord);\n-  jcc(Assembler::greaterEqual, L_byteByByteProlog);\n-    crc32(in_out, Address(in1, 0), 4);\n-    addq(in1, 4);\n-    jmp(L_wordByWord);\n+  jccb(Assembler::greaterEqual, L_byteByByteProlog);\n+  align(16);\n+  BIND(L_wordByWord);\n+    crc32(in_out, Address(in1, 0), 8);\n+    addq(in1, 8);\n+    cmpq(in1, tmp1);\n+    jcc(Assembler::less, L_wordByWord);\n@@ -8368,1 +8409,0 @@\n-  BIND(L_byteByByte);\n@@ -8371,0 +8411,1 @@\n+  BIND(L_byteByByte);\n@@ -8374,1 +8415,2 @@\n-    jmp(L_byteByByte);\n+    cmpl(tmp2, in2);\n+    jcc(Assembler::lessEqual, L_byteByByte);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":63,"deletions":21,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -352,1 +352,1 @@\n-  void clear_jweak_tag(Register possibly_jweak);\n+  void clear_jobject_tag(Register possibly_non_local);\n@@ -354,0 +354,1 @@\n+  void resolve_global_jobject(Register value, Register thread, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1590,0 +1590,9 @@\n+\n+  \/\/ handle pending exception thrown by freeze\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  Label ok;\n+  __ jcc(Assembler::equal, ok);\n+  __ leave();\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+  __ bind(ok);\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2763,0 +2763,2 @@\n+  Label L_continue;\n+\n@@ -2766,0 +2768,5 @@\n+    Label L_doSmall;\n+\n+    __ cmpl(len, 384);\n+    __ jcc(Assembler::lessEqual, L_doSmall);\n+\n@@ -2768,1 +2775,5 @@\n-  } else {\n+\n+    __ jmp(L_continue);\n+\n+    __ bind(L_doSmall);\n+  }\n@@ -2770,2 +2781,2 @@\n-    __ push(y);\n-    __ push(z);\n+  __ push(y);\n+  __ push(z);\n@@ -2773,5 +2784,5 @@\n-    __ crc32c_ipl_alg2_alt2(crc, buf, len,\n-                            a, j, k,\n-                            l, y, z,\n-                            c_farg0, c_farg1, c_farg2,\n-                            is_pclmulqdq_supported);\n+  __ crc32c_ipl_alg2_alt2(crc, buf, len,\n+                          a, j, k,\n+                          l, y, z,\n+                          c_farg0, c_farg1, c_farg2,\n+                          is_pclmulqdq_supported);\n@@ -2779,2 +2790,2 @@\n-    __ pop(z);\n-    __ pop(y);\n+  __ pop(z);\n+  __ pop(y);\n@@ -2782,1 +2793,2 @@\n-  }\n+\n+  __ bind(L_continue);\n@@ -3556,1 +3568,1 @@\n-  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n@@ -3571,8 +3583,1 @@\n-  Label L_null_jobject;\n-  __ testptr(rax, rax);\n-  __ jcc(Assembler::zero, L_null_jobject);\n-\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->load_at(_masm, ACCESS_READ | IN_NATIVE, T_OBJECT, rax, Address(rax, 0), c_rarg0, r15_thread);\n-\n-  __ bind(L_null_jobject);\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -231,0 +231,37 @@\n+jint StubRoutines::x86::_arrays_hashcode_powers_of_31[] =\n+{\n+     2111290369,\n+    -2010103841,\n+      350799937,\n+       11316127,\n+      693101697,\n+     -254736545,\n+      961614017,\n+       31019807,\n+    -2077209343,\n+      -67006753,\n+     1244764481,\n+    -2038056289,\n+      211350913,\n+     -408824225,\n+     -844471871,\n+     -997072353,\n+     1353309697,\n+     -510534177,\n+     1507551809,\n+     -505558625,\n+     -293403007,\n+      129082719,\n+    -1796951359,\n+     -196513505,\n+    -1807454463,\n+     1742810335,\n+      887503681,\n+       28629151,\n+         923521,\n+          29791,\n+            961,\n+             31,\n+              1,\n+};\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":38,"deletions":1,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -142,0 +142,2 @@\n+  \/\/ table for arrays_hashcode\n+  static jint _arrays_hashcode_powers_of_31[];\n@@ -332,0 +334,1 @@\n+  static address arrays_hashcode_powers_of_31() { return (address)_arrays_hashcode_powers_of_31; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -308,1 +308,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDX int register\n@@ -311,1 +311,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDI int register\n@@ -892,1 +892,1 @@\n-    st->print(\"cmpl    [r15_thread + #disarmed_offset], #disarmed_value\\t\");\n+    st->print(\"cmpl    [r15_thread + #disarmed_guard_value_offset], #disarmed_guard_value\\t\");\n@@ -6094,0 +6094,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -6106,1 +6107,1 @@\n-  predicate(UseCompressedOops && (CompressedOops::base() == NULL));\n+  predicate(UseCompressedOops && (CompressedOops::base() == NULL) && n->as_Store()->barrier_data() == 0);\n@@ -6120,0 +6121,1 @@\n+  predicate(n->as_Store()->barrier_data() == 0);\n@@ -12086,0 +12088,26 @@\n+instruct arrays_hashcode(rdi_RegP ary1, rdx_RegI cnt1, rbx_RegI result, immU8 basic_type,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2);\n+  match(Set result (VectorizedHashCode (Binary ary1 cnt1) (Binary result basic_type)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL ary1, USE_KILL cnt1,\n+         USE basic_type, KILL cr);\n+\n+  format %{ \"Array HashCode array[] $ary1,$cnt1,$result,$basic_type -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $cnt1$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, (BasicType)$basic_type$$constant);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1718,1 +1718,1 @@\n-  if (GenerateRangeChecks && needs_range_check) {\n+  if (needs_range_check) {\n@@ -2007,1 +2007,1 @@\n-  if (GenerateRangeChecks && needs_range_check) {\n+  if (needs_range_check) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-ArchiveBuilder* ArchiveBuilder::_current = NULL;\n+ArchiveBuilder* ArchiveBuilder::_current = nullptr;\n@@ -100,1 +100,1 @@\n-  assert(*field_addr != NULL, \"should have checked\");\n+  assert(*field_addr != nullptr, \"should have checked\");\n@@ -146,3 +146,3 @@\n-  _current_dump_space(NULL),\n-  _buffer_bottom(NULL),\n-  _last_verified_top(NULL),\n+  _current_dump_space(nullptr),\n+  _buffer_bottom(nullptr),\n+  _last_verified_top(nullptr),\n@@ -151,6 +151,6 @@\n-  _requested_static_archive_bottom(NULL),\n-  _requested_static_archive_top(NULL),\n-  _requested_dynamic_archive_bottom(NULL),\n-  _requested_dynamic_archive_top(NULL),\n-  _mapped_static_archive_bottom(NULL),\n-  _mapped_static_archive_top(NULL),\n+  _requested_static_archive_bottom(nullptr),\n+  _requested_static_archive_top(nullptr),\n+  _requested_dynamic_archive_bottom(nullptr),\n+  _requested_dynamic_archive_top(nullptr),\n+  _mapped_static_archive_bottom(nullptr),\n+  _mapped_static_archive_top(nullptr),\n@@ -174,1 +174,1 @@\n-  assert(_current == NULL, \"must be\");\n+  assert(_current == nullptr, \"must be\");\n@@ -180,1 +180,1 @@\n-  _current = NULL;\n+  _current = nullptr;\n@@ -212,1 +212,1 @@\n-  if (ref->obj() == NULL) {\n+  if (ref->obj() == nullptr) {\n@@ -437,1 +437,1 @@\n-    if (ref->obj() != NULL) {\n+    if (ref->obj() != nullptr) {\n@@ -446,1 +446,1 @@\n-  if (src_obj == NULL) {\n+  if (src_obj == nullptr) {\n@@ -483,1 +483,1 @@\n-  assert(ref->obj() != NULL, \"should have checked\");\n+  assert(ref->obj() != nullptr, \"should have checked\");\n@@ -485,1 +485,1 @@\n-  if (enclosing_ref != NULL) {\n+  if (enclosing_ref != nullptr) {\n@@ -487,1 +487,1 @@\n-    if (src_info == NULL) {\n+    if (src_info == nullptr) {\n@@ -651,1 +651,1 @@\n-  if (archived_vtable != NULL) {\n+  if (archived_vtable != nullptr) {\n@@ -667,1 +667,1 @@\n-  assert(p != NULL, \"must be\");\n+  assert(p != nullptr, \"must be\");\n@@ -675,1 +675,1 @@\n-  assert(src_p != NULL && *src_p != NULL, \"must be\");\n+  assert(src_p != nullptr && *src_p != nullptr, \"must be\");\n@@ -868,1 +868,1 @@\n-\/\/   [a] NULL:\n+\/\/   [a] nullptr:\n@@ -908,1 +908,1 @@\n-    if (*p == NULL) {\n+    if (*p == nullptr) {\n@@ -1086,1 +1086,1 @@\n-        if (original_oop != NULL) {\n+        if (original_oop != nullptr) {\n@@ -1165,1 +1165,1 @@\n-    if (closed_heap_regions != NULL) {\n+    if (closed_heap_regions != nullptr) {\n@@ -1168,1 +1168,1 @@\n-    if (open_heap_regions != NULL) {\n+    if (open_heap_regions != nullptr) {\n@@ -1202,1 +1202,1 @@\n-  if (closed_heap_regions != NULL) {\n+  if (closed_heap_regions != nullptr) {\n@@ -1261,1 +1261,1 @@\n-  if (closed_heap_regions != NULL) {\n+  if (closed_heap_regions != nullptr) {\n@@ -1277,1 +1277,1 @@\n-  int arr_len = regions == NULL ? 0 : regions->length();\n+  int arr_len = regions == nullptr ? 0 : regions->length();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,1 +173,1 @@\n-        _buffered_addr = NULL;\n+        _buffered_addr = nullptr;\n@@ -181,2 +181,2 @@\n-      assert(_buffered_addr == NULL, \"cannot be copied twice\");\n-      assert(addr != NULL, \"must be a valid copy\");\n+      assert(_buffered_addr == nullptr, \"cannot be copied twice\");\n+      assert(addr != nullptr, \"must be a valid copy\");\n@@ -436,1 +436,1 @@\n-    return (_current != NULL);\n+    return (_current != nullptr);\n@@ -441,1 +441,1 @@\n-    assert(_current != NULL, \"ArchiveBuilder must be active\");\n+    assert(_current != nullptr, \"ArchiveBuilder must be active\");\n@@ -461,1 +461,1 @@\n-    assert(klass != NULL && klass->is_klass(), \"must be\");\n+    assert(klass != nullptr && klass->is_klass(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-CHeapBitMap* ArchivePtrMarker::_ptrmap = NULL;\n+CHeapBitMap* ArchivePtrMarker::_ptrmap = nullptr;\n@@ -53,1 +53,1 @@\n-  assert(_ptrmap == NULL, \"initialize only once\");\n+  assert(_ptrmap == nullptr, \"initialize only once\");\n@@ -70,1 +70,1 @@\n-  assert(_ptrmap != NULL, \"not initialized\");\n+  assert(_ptrmap != nullptr, \"not initialized\");\n@@ -77,1 +77,1 @@\n-    \/\/ to nothing (NULL) vs a pointer to an objects that happens to be at the very bottom\n+    \/\/ to nothing (null) vs a pointer to an objects that happens to be at the very bottom\n@@ -81,1 +81,1 @@\n-    if (value != NULL) {\n+    if (value != nullptr) {\n@@ -95,1 +95,1 @@\n-  assert(_ptrmap != NULL, \"not initialized\");\n+  assert(_ptrmap != nullptr, \"not initialized\");\n@@ -121,1 +121,1 @@\n-    if (ptr_value != NULL) {\n+    if (ptr_value != nullptr) {\n@@ -128,1 +128,1 @@\n-      DEBUG_ONLY(log_trace(cds, reloc)(\"Clearing pointer [\" PTR_FORMAT  \"] -> NULL @ \" SIZE_FORMAT_W(9), p2i(ptr_loc), offset));\n+      DEBUG_ONLY(log_trace(cds, reloc)(\"Clearing pointer [\" PTR_FORMAT  \"] -> null @ \" SIZE_FORMAT_W(9), p2i(ptr_loc), offset));\n@@ -270,1 +270,1 @@\n-  if (next != NULL) {\n+  if (next != nullptr) {\n@@ -279,1 +279,1 @@\n-  if (*o == NULL) {\n+  if (*o == nullptr) {\n@@ -305,1 +305,1 @@\n-  assert(*p == NULL, \"initializing previous initialized pointer.\");\n+  assert(*p == nullptr, \"initializing previous initialized pointer.\");\n@@ -334,1 +334,1 @@\n-      *p = NULL;\n+      *p = nullptr;\n@@ -343,1 +343,1 @@\n-      *p = NULL;\n+      *p = nullptr;\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,3 +145,2 @@\n-    : _name(name), _base(NULL), _top(NULL), _end(NULL),\n-      _max_delta(max_delta), _is_packed(false),\n-      _rs(NULL), _vs(NULL) {}\n+    : _name(name), _base(nullptr), _top(nullptr), _end(nullptr),\n+      _max_delta(max_delta), _is_packed(false) {}\n@@ -164,1 +163,1 @@\n-    return !is_packed() && _base != NULL;\n+    return !is_packed() && _base != nullptr;\n@@ -172,1 +171,1 @@\n-  void pack(DumpRegion* next = NULL);\n+  void pack(DumpRegion* next = nullptr);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-      return NULL;\n+      return nullptr;\n","filename":"src\/hotspot\/share\/cds\/dumpAllocStats.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -64,0 +65,1 @@\n+#include \"gc\/g1\/heapRegion.hpp\"\n@@ -76,1 +78,1 @@\n-  : klass_name(k), field_name(f), klass(NULL), offset(0), type(T_ILLEGAL) {}\n+  : klass_name(k), field_name(f), klass(nullptr), offset(0), type(T_ILLEGAL) {}\n@@ -79,1 +81,1 @@\n-    return klass_name != NULL;\n+    return klass_name != nullptr;\n@@ -84,2 +86,2 @@\n-DumpedInternedStrings *HeapShared::_dumped_interned_strings = NULL;\n-GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = NULL;\n+DumpedInternedStrings *HeapShared::_dumped_interned_strings = nullptr;\n+GrowableArrayCHeap<Metadata**, mtClassShared>* HeapShared::_native_pointers = nullptr;\n@@ -94,4 +96,4 @@\n-static Array<char>* _archived_ArchiveHeapTestClass = NULL;\n-static const char* _test_class_name = NULL;\n-static const Klass* _test_class = NULL;\n-static const ArchivedKlassSubGraphInfoRecord* _test_class_record = NULL;\n+static Array<char>* _archived_ArchiveHeapTestClass = nullptr;\n+static const char* _test_class_name = nullptr;\n+static const Klass* _test_class = nullptr;\n+static const ArchivedKlassSubGraphInfoRecord* _test_class_record = nullptr;\n@@ -116,1 +118,1 @@\n-  {NULL, NULL},\n+  {nullptr, nullptr},\n@@ -126,1 +128,1 @@\n-  {NULL, NULL}, \/\/ Extra slot for -XX:ArchiveHeapTestClass\n+  {nullptr, nullptr}, \/\/ Extra slot for -XX:ArchiveHeapTestClass\n@@ -128,1 +130,1 @@\n-  {NULL, NULL},\n+  {nullptr, nullptr},\n@@ -136,1 +138,1 @@\n-  {NULL, NULL},\n+  {nullptr, nullptr},\n@@ -139,1 +141,2 @@\n-GrowableArrayCHeap<oop, mtClassShared>* HeapShared::_pending_roots = NULL;\n+KlassSubGraphInfo* HeapShared::_default_subgraph_info;\n+GrowableArrayCHeap<oop, mtClassShared>* HeapShared::_pending_roots = nullptr;\n@@ -141,0 +144,2 @@\n+OopHandle HeapShared::_scratch_basic_type_mirrors[T_VOID+1];\n+KlassToOopHandleTable* HeapShared::_scratch_java_mirror_table = nullptr;\n@@ -177,1 +182,1 @@\n-  while (klass != NULL) {\n+  while (klass != nullptr) {\n@@ -179,1 +184,1 @@\n-    if (method != NULL) {\n+    if (method != nullptr) {\n@@ -218,2 +223,2 @@\n-HeapShared::ArchivedObjectCache* HeapShared::_archived_object_cache = NULL;\n-HeapShared::OriginalObjectTable* HeapShared::_original_object_table = NULL;\n+HeapShared::ArchivedObjectCache* HeapShared::_archived_object_cache = nullptr;\n+HeapShared::OriginalObjectTable* HeapShared::_original_object_table = nullptr;\n@@ -224,1 +229,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -227,1 +232,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -237,1 +242,1 @@\n-  if (_pending_roots == NULL) {\n+  if (_pending_roots == nullptr) {\n@@ -248,1 +253,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -255,1 +260,1 @@\n-  assert(roots != NULL, \"should have been initialized\");\n+  assert(roots != nullptr, \"should have been initialized\");\n@@ -264,1 +269,1 @@\n-    assert(_pending_roots != NULL, \"sanity\");\n+    assert(_pending_roots != nullptr, \"sanity\");\n@@ -285,1 +290,1 @@\n-    roots()->obj_at_put(index, NULL);\n+    roots()->obj_at_put(index, nullptr);\n@@ -289,0 +294,9 @@\n+bool HeapShared::is_too_large_to_archive(oop o) {\n+  \/\/ TODO: To make the CDS heap mappable for all collectors, this function should\n+  \/\/ reject objects that may be too large for *any* collector.\n+  assert(UseG1GC, \"implementation limitation\");\n+  size_t sz = align_up(o->size() * HeapWordSize, ObjectAlignmentInBytes);\n+  size_t max = \/*G1*\/HeapRegion::min_region_size_in_words() * HeapWordSize;\n+  return (sz > max);\n+}\n+\n@@ -295,1 +309,1 @@\n-  if (ao != NULL) {\n+  if (ao != nullptr) {\n@@ -304,1 +318,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -308,1 +322,1 @@\n-  if (archived_oop != NULL) {\n+  if (archived_oop != nullptr) {\n@@ -334,1 +348,1 @@\n-    if (_original_object_table != NULL) {\n+    if (_original_object_table != nullptr) {\n@@ -354,5 +368,40 @@\n-void HeapShared::archive_klass_objects() {\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n-  assert(klasses != NULL, \"sanity\");\n-  for (int i = 0; i < klasses->length(); i++) {\n-    Klass* k = ArchiveBuilder::get_buffered_klass(klasses->at(i));\n+class KlassToOopHandleTable: public ResourceHashtable<Klass*, OopHandle,\n+    36137, \/\/ prime number\n+    AnyObj::C_HEAP,\n+    mtClassShared> {\n+public:\n+  oop get_oop(Klass* k) {\n+    MutexLocker ml(ScratchObjects_lock, Mutex::_no_safepoint_check_flag);\n+    OopHandle* handle = get(k);\n+    if (handle != nullptr) {\n+      return handle->resolve();\n+    } else {\n+      return nullptr;\n+    }\n+  }\n+  void set_oop(Klass* k, oop o) {\n+    MutexLocker ml(ScratchObjects_lock, Mutex::_no_safepoint_check_flag);\n+    OopHandle handle(Universe::vm_global(), o);\n+    bool is_new = put(k, handle);\n+    assert(is_new, \"cannot set twice\");\n+  }\n+  void remove_oop(Klass* k) {\n+    MutexLocker ml(ScratchObjects_lock, Mutex::_no_safepoint_check_flag);\n+    OopHandle* handle = get(k);\n+    if (handle != nullptr) {\n+      handle->release(Universe::vm_global());\n+      remove(k);\n+    }\n+  }\n+};\n+\n+void HeapShared::init_scratch_objects(TRAPS) {\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (!is_reference_type(bt)) {\n+      oop m = java_lang_Class::create_basic_type_mirror(type2name(bt), bt, CHECK);\n+      _scratch_basic_type_mirrors[i] = OopHandle(Universe::vm_global(), m);\n+    }\n+  }\n+  _scratch_java_mirror_table = new (mtClass)KlassToOopHandleTable();\n+}\n@@ -360,2 +409,5 @@\n-    \/\/ archive mirror object\n-    java_lang_Class::archive_mirror(k);\n+oop HeapShared::scratch_java_mirror(BasicType t) {\n+  assert((uint)t < T_VOID+1, \"range check\");\n+  assert(!is_reference_type(t), \"sanity\");\n+  return _scratch_basic_type_mirrors[t].resolve();\n+}\n@@ -363,4 +415,28 @@\n-    \/\/ archive the resolved_referenes array\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      ik->constants()->archive_resolved_references();\n+oop HeapShared::scratch_java_mirror(Klass* k) {\n+  return _scratch_java_mirror_table->get_oop(k);\n+}\n+\n+void HeapShared::set_scratch_java_mirror(Klass* k, oop mirror) {\n+  _scratch_java_mirror_table->set_oop(k, mirror);\n+}\n+\n+void HeapShared::remove_scratch_objects(Klass* k) {\n+  _scratch_java_mirror_table->remove_oop(k);\n+}\n+\n+void HeapShared::archive_java_mirrors() {\n+  init_seen_objects_table();\n+\n+  for (int i = T_BOOLEAN; i < T_VOID+1; i++) {\n+    BasicType bt = (BasicType)i;\n+    if (!is_reference_type(bt)) {\n+      oop m = _scratch_basic_type_mirrors[i].resolve();\n+      assert(m != nullptr, \"sanity\");\n+      oop archived_m = archive_reachable_objects_from(1, _default_subgraph_info, m, \/*is_closed_archive=*\/ false);\n+      assert(archived_m != nullptr, \"sanity\");\n+\n+      log_trace(cds, heap, mirror)(\n+        \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+        type2name(bt), p2i(m), p2i(archived_m));\n+\n+      Universe::set_archived_basic_type_mirror_index(bt, append_root(archived_m));\n@@ -369,0 +445,32 @@\n+\n+  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  assert(klasses != nullptr, \"sanity\");\n+  for (int i = 0; i < klasses->length(); i++) {\n+    Klass* orig_k = klasses->at(i);\n+    oop m = scratch_java_mirror(orig_k);\n+    if (m != nullptr) {\n+      Klass* buffered_k = ArchiveBuilder::get_buffered_klass(orig_k);\n+      oop archived_m = archive_reachable_objects_from(1, _default_subgraph_info, m, \/*is_closed_archive=*\/ false);\n+      guarantee(archived_m != nullptr, \"scratch mirrors should not point to any unachivable objects\");\n+      buffered_k->set_archived_java_mirror(append_root(archived_m));\n+      ResourceMark rm;\n+      log_trace(cds, heap, mirror)(\n+        \"Archived %s mirror object from \" PTR_FORMAT \" ==> \" PTR_FORMAT,\n+        buffered_k->external_name(), p2i(m), p2i(archived_m));\n+\n+      \/\/ archive the resolved_referenes array\n+      if (buffered_k->is_instance_klass()) {\n+        InstanceKlass* ik = InstanceKlass::cast(buffered_k);\n+        oop rr = ik->constants()->prepare_resolved_references_for_archiving();\n+        if (rr != nullptr && !is_too_large_to_archive(rr)) {\n+          oop archived_obj = HeapShared::archive_reachable_objects_from(1, _default_subgraph_info, rr,\n+                                                                        \/*is_closed_archive=*\/false);\n+          assert(archived_obj != nullptr,  \"already checked not too large to archive\");\n+          int root_index = append_root(archived_obj);\n+          ik->constants()->cache()->set_archived_references(root_index);\n+        }\n+      }\n+    }\n+  }\n+\n+  delete_seen_objects_table();\n@@ -380,1 +488,1 @@\n-  if (ptr != NULL) {\n+  if (ptr != nullptr) {\n@@ -440,1 +548,1 @@\n-        if (oop_field == NULL) {\n+        if (oop_field == nullptr) {\n@@ -465,1 +573,1 @@\n-  assert(info != NULL, \"sanity\");\n+  assert(info != nullptr, \"sanity\");\n@@ -512,0 +620,2 @@\n+    _default_subgraph_info = init_subgraph_info(vmClasses::Object_klass(), false);\n+\n@@ -527,0 +637,1 @@\n+    check_default_subgraph_classes();\n@@ -530,0 +641,21 @@\n+  StringTable::write_shared_table(_dumped_interned_strings);\n+}\n+\n+void HeapShared::copy_interned_strings() {\n+  init_seen_objects_table();\n+\n+  auto copier = [&] (oop s, bool value_ignored) {\n+    assert(s != nullptr, \"sanity\");\n+    typeArrayOop value = java_lang_String::value_no_keepalive(s);\n+    if (!HeapShared::is_too_large_to_archive(value)) {\n+      oop archived_s = archive_reachable_objects_from(1, _default_subgraph_info,\n+                                                      s, \/*is_closed_archive=*\/true);\n+      assert(archived_s != nullptr, \"already checked not too large to archive\");\n+      \/\/ Prevent string deduplication from changing the value field to\n+      \/\/ something not in the archive.\n+      java_lang_String::set_deduplication_forbidden(archived_s);\n+    }\n+  };\n+  _dumped_interned_strings->iterate_all(copier);\n+\n+  delete_seen_objects_table();\n@@ -538,1 +670,1 @@\n-  StringTable::write_to_archive(_dumped_interned_strings);\n+  copy_interned_strings();\n@@ -553,3 +685,1 @@\n-  java_lang_Class::archive_basic_type_mirrors();\n-\n-  archive_klass_objects();\n+  archive_java_mirrors();\n@@ -581,1 +711,1 @@\n-  int length = _pending_roots != NULL ? _pending_roots->length() : 0;\n+  int length = _pending_roots != nullptr ? _pending_roots->length() : 0;\n@@ -610,1 +740,1 @@\n-HeapShared::DumpTimeKlassSubGraphInfoTable* HeapShared::_dump_time_subgraph_info_table = NULL;\n+HeapShared::DumpTimeKlassSubGraphInfoTable* HeapShared::_dump_time_subgraph_info_table = nullptr;\n@@ -630,1 +760,1 @@\n-  assert(info != NULL, \"must have been initialized\");\n+  assert(info != nullptr, \"must have been initialized\");\n@@ -638,1 +768,1 @@\n-  if (_subgraph_entry_fields == NULL) {\n+  if (_subgraph_entry_fields == nullptr) {\n@@ -652,1 +782,1 @@\n-  if (_subgraph_object_klasses == NULL) {\n+  if (_subgraph_object_klasses == nullptr) {\n@@ -708,1 +838,1 @@\n-    assert(ik->package() != NULL, \"classes in java.base cannot be in unnamed package\");\n+    assert(ik->package() != nullptr, \"classes in java.base cannot be in unnamed package\");\n@@ -713,1 +843,1 @@\n-  if (!ik->module()->is_named() && ik->package() == NULL) {\n+  if (!ik->module()->is_named() && ik->package() == nullptr) {\n@@ -748,2 +878,2 @@\n-  _entry_field_records = NULL;\n-  _subgraph_object_klasses = NULL;\n+  _entry_field_records = nullptr;\n+  _subgraph_object_klasses = nullptr;\n@@ -770,1 +900,1 @@\n-  if (entry_fields != NULL) {\n+  if (entry_fields != nullptr) {\n@@ -782,1 +912,1 @@\n-  if (subgraph_object_klasses != NULL) {\n+  if (subgraph_object_klasses != nullptr) {\n@@ -809,1 +939,1 @@\n-    if (info.subgraph_object_klasses() != NULL || info.subgraph_entry_fields() != NULL) {\n+    if (info.subgraph_object_klasses() != nullptr || info.subgraph_entry_fields() != nullptr) {\n@@ -843,1 +973,1 @@\n-  if (ArchiveHeapTestClass != NULL) {\n+  if (ArchiveHeapTestClass != nullptr) {\n@@ -856,1 +986,1 @@\n-  oop roots_oop = NULL;\n+  oop roots_oop = nullptr;\n@@ -862,1 +992,1 @@\n-    if (roots_oop != NULL) {\n+    if (roots_oop != nullptr) {\n@@ -877,1 +1007,1 @@\n-  if (soc->reading() && _archived_ArchiveHeapTestClass != NULL) {\n+  if (soc->reading() && _archived_ArchiveHeapTestClass != nullptr) {\n@@ -934,1 +1064,1 @@\n-    assert(k != NULL && k->is_shared_boot_class(), \"sanity\");\n+    assert(k != nullptr && k->is_shared_boot_class(), \"sanity\");\n@@ -947,1 +1077,1 @@\n-  if (record == NULL) {\n+  if (record == nullptr) {\n@@ -970,1 +1100,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -980,1 +1110,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -986,1 +1116,1 @@\n-  if (_test_class_name != NULL && k->name()->equals(_test_class_name) && record != NULL) {\n+  if (_test_class_name != nullptr && k->name()->equals(_test_class_name) && record != nullptr) {\n@@ -994,1 +1124,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -1001,1 +1131,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1010,1 +1140,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1021,1 +1151,1 @@\n-    \/\/ NULL class loader is used.\n+    \/\/ nullptr class loader is used.\n@@ -1023,1 +1153,1 @@\n-    if (klasses != NULL) {\n+    if (klasses != nullptr) {\n@@ -1027,1 +1157,1 @@\n-          return NULL;\n+          return nullptr;\n@@ -1039,1 +1169,1 @@\n-    if (k->class_loader_data() == NULL) {\n+    if (k->class_loader_data() == nullptr) {\n@@ -1044,1 +1174,1 @@\n-    assert(k->class_loader_data() != NULL, \"must have been resolved by HeapShared::resolve_classes\");\n+    assert(k->class_loader_data() != nullptr, \"must have been resolved by HeapShared::resolve_classes\");\n@@ -1062,1 +1192,1 @@\n-  if (entry_field_records != NULL) {\n+  if (entry_field_records != nullptr) {\n@@ -1088,1 +1218,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -1090,1 +1220,1 @@\n-    if (entry_field_records != NULL) {\n+    if (entry_field_records != nullptr) {\n@@ -1147,3 +1277,5 @@\n-        LogTarget(Trace, cds, heap) log;\n-        LogStream out(log);\n-        obj->print_on(&out);\n+        if (log_is_enabled(Trace, cds, heap)) {\n+          LogTarget(Trace, cds, heap) log;\n+          LogStream out(log);\n+          obj->print_on(&out);\n+        }\n@@ -1154,1 +1286,1 @@\n-      assert(archived != NULL, \"VM should have exited with unarchivable objects for _level > 1\");\n+      assert(archived != nullptr, \"VM should have exited with unarchivable objects for _level > 1\");\n@@ -1172,1 +1304,1 @@\n-WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = NULL;\n+WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = nullptr;\n@@ -1178,2 +1310,2 @@\n-  info._subgraph_info = (walker == NULL) ? NULL : walker->subgraph_info();\n-  info._referrer = (walker == NULL) ? NULL : walker->orig_referencing_obj();\n+  info._subgraph_info = (walker == nullptr) ? nullptr : walker->subgraph_info();\n+  info._referrer = (walker == nullptr) ? nullptr : walker->orig_referencing_obj();\n@@ -1209,1 +1341,1 @@\n-  assert(orig_obj != NULL, \"must be\");\n+  assert(orig_obj != nullptr, \"must be\");\n@@ -1226,1 +1358,1 @@\n-  if (java_lang_Class::is_instance(orig_obj)) {\n+  if (java_lang_Class::is_instance(orig_obj) && subgraph_info != _default_subgraph_info) {\n@@ -1232,1 +1364,1 @@\n-  if (java_lang_String::is_instance(orig_obj) && archived_obj != NULL) {\n+  if (java_lang_String::is_instance(orig_obj) && archived_obj != nullptr) {\n@@ -1245,2 +1377,2 @@\n-  bool record_klasses_only = (archived_obj != NULL);\n-  if (archived_obj == NULL) {\n+  bool record_klasses_only = (archived_obj != nullptr);\n+  if (archived_obj == nullptr) {\n@@ -1249,1 +1381,1 @@\n-    if (archived_obj == NULL) {\n+    if (archived_obj == nullptr) {\n@@ -1259,1 +1391,1 @@\n-        return NULL;\n+        return nullptr;\n@@ -1272,1 +1404,1 @@\n-      java_lang_Module::set_module_entry(archived_obj, NULL);\n+      java_lang_Module::set_module_entry(archived_obj, nullptr);\n@@ -1277,2 +1409,2 @@\n-                java_lang_ClassLoader::loader_data(orig_obj) == NULL, \"must be\");\n-      java_lang_ClassLoader::release_set_loader_data(archived_obj, NULL);\n+                java_lang_ClassLoader::loader_data(orig_obj) == nullptr, \"must be\");\n+      java_lang_ClassLoader::release_set_loader_data(archived_obj, nullptr);\n@@ -1282,1 +1414,1 @@\n-  assert(archived_obj != NULL, \"must be\");\n+  assert(archived_obj != nullptr, \"must be\");\n@@ -1355,1 +1487,1 @@\n-    if (af == NULL) {\n+    if (af == nullptr) {\n@@ -1368,1 +1500,1 @@\n-    subgraph_info->add_subgraph_entry_field(field_offset, NULL, false);\n+    subgraph_info->add_subgraph_entry_field(field_offset, nullptr, false);\n@@ -1405,1 +1537,1 @@\n-  if (archived_obj == NULL) {\n+  if (archived_obj == nullptr) {\n@@ -1432,1 +1564,1 @@\n-      assert(find_archived_heap_object(obj) == NULL, \"must be\");\n+      assert(find_archived_heap_object(obj) == nullptr, \"must be\");\n@@ -1435,1 +1567,1 @@\n-      assert(find_archived_heap_object(obj) != NULL, \"must be\");\n+      assert(find_archived_heap_object(obj) != nullptr, \"must be\");\n@@ -1444,1 +1576,26 @@\n-HeapShared::SeenObjectsTable* HeapShared::_seen_objects_table = NULL;\n+\/\/ The \"default subgraph\" contains special objects (see heapShared.hpp) that\n+\/\/ can be accessed before we load any Java classes (including java\/lang\/Class).\n+\/\/ Make sure that these are only instances of the very few specific types\n+\/\/ that we can handle.\n+void HeapShared::check_default_subgraph_classes() {\n+  GrowableArray<Klass*>* klasses = _default_subgraph_info->subgraph_object_klasses();\n+  int num = klasses->length();\n+  for (int i = 0; i < num; i++) {\n+    Klass* subgraph_k = klasses->at(i);\n+    if (log_is_enabled(Info, cds, heap)) {\n+      ResourceMark rm;\n+      log_info(cds, heap)(\n+          \"Archived object klass (default subgraph %d) => %s\",\n+          i, subgraph_k->external_name());\n+    }\n+\n+    guarantee(subgraph_k->name()->equals(\"java\/lang\/Class\") ||\n+              subgraph_k->name()->equals(\"java\/lang\/String\") ||\n+              subgraph_k->name()->equals(\"[Ljava\/lang\/Object;\") ||\n+              subgraph_k->name()->equals(\"[C\") ||\n+              subgraph_k->name()->equals(\"[B\"),\n+              \"default subgraph can have only these objects\");\n+  }\n+}\n+\n+HeapShared::SeenObjectsTable* HeapShared::_seen_objects_table = nullptr;\n@@ -1456,1 +1613,1 @@\n-  return _seen_objects_table->get(obj) != NULL;\n+  return _seen_objects_table->get(obj) != nullptr;\n@@ -1521,1 +1678,1 @@\n-    bool is_test_class = (ArchiveHeapTestClass != NULL) && (strcmp(info->klass_name, ArchiveHeapTestClass) == 0);\n+    bool is_test_class = (ArchiveHeapTestClass != nullptr) && (strcmp(info->klass_name, ArchiveHeapTestClass) == 0);\n@@ -1557,1 +1714,1 @@\n-      if (ik->package() != NULL) {\n+      if (ik->package() != nullptr) {\n@@ -1606,2 +1763,2 @@\n-  assert(p[num_slots - 2].klass_name == NULL, \"must have empty slot that's patched below\");\n-  assert(p[num_slots - 1].klass_name == NULL, \"must have empty slot that marks the end of the list\");\n+  assert(p[num_slots - 2].klass_name == nullptr, \"must have empty slot that's patched below\");\n+  assert(p[num_slots - 1].klass_name == nullptr, \"must have empty slot that marks the end of the list\");\n@@ -1609,1 +1766,1 @@\n-  if (test_class_name != NULL) {\n+  if (test_class_name != nullptr) {\n@@ -1619,1 +1776,1 @@\n-  if (_test_class != NULL) {\n+  if (_test_class != nullptr) {\n@@ -1624,1 +1781,1 @@\n-    if (klasses == NULL) {\n+    if (klasses == nullptr) {\n@@ -1765,1 +1922,1 @@\n-    if ((*p) != NULL) {\n+    if ((*p) != nullptr) {\n@@ -1783,1 +1940,1 @@\n-  if (dumptime_addr == NULL || UseCompressedOops) {\n+  if (dumptime_addr == nullptr || UseCompressedOops) {\n@@ -1804,1 +1961,1 @@\n-  assert(REQUESTED_BASE != 0 && requested_addr != NULL, \"sanity\");\n+  assert(REQUESTED_BASE != 0 && requested_addr != nullptr, \"sanity\");\n@@ -1815,1 +1972,1 @@\n-  ArchiveBuilder* builder = DumpSharedSpaces ? ArchiveBuilder::current() : NULL;\n+  ArchiveBuilder* builder = DumpSharedSpaces ? ArchiveBuilder::current() : nullptr;\n@@ -1846,1 +2003,1 @@\n-      assert(*p != NULL, \"must be non-null\");\n+      assert(*p != nullptr, \"must be non-null\");\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":273,"deletions":116,"binary":false,"changes":389,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,4 +80,4 @@\n-DumpTimeSharedClassTable* SystemDictionaryShared::_dumptime_table = NULL;\n-DumpTimeSharedClassTable* SystemDictionaryShared::_cloned_dumptime_table = NULL;\n-DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_dumptime_lambda_proxy_class_dictionary = NULL;\n-DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_cloned_dumptime_lambda_proxy_class_dictionary = NULL;\n+DumpTimeSharedClassTable* SystemDictionaryShared::_dumptime_table = nullptr;\n+DumpTimeSharedClassTable* SystemDictionaryShared::_cloned_dumptime_table = nullptr;\n+DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_dumptime_lambda_proxy_class_dictionary = nullptr;\n+DumpTimeLambdaProxyClassDictionary* SystemDictionaryShared::_cloned_dumptime_lambda_proxy_class_dictionary = nullptr;\n@@ -93,1 +93,1 @@\n-  if (ik != NULL && !ik->shared_loading_failed()) {\n+  if (ik != nullptr && !ik->shared_loading_failed()) {\n@@ -100,1 +100,1 @@\n-      return load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, THREAD);\n+      return load_shared_class(ik, class_loader, protection_domain, nullptr, pkg_entry, THREAD);\n@@ -103,1 +103,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -113,1 +113,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -115,2 +115,2 @@\n-  if (class_name == NULL) {  \/\/ don't do this for hidden classes\n-    return NULL;\n+  if (class_name == nullptr) {  \/\/ don't do this for hidden classes\n+    return nullptr;\n@@ -122,1 +122,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -128,2 +128,2 @@\n-  if (record == NULL) {\n-    return NULL;\n+  if (record == nullptr) {\n+    return nullptr;\n@@ -136,1 +136,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -154,1 +154,1 @@\n-    if (ik->class_loader_data() != NULL) {\n+    if (ik->class_loader_data() != nullptr) {\n@@ -157,1 +157,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -174,1 +174,1 @@\n-  if (shared_klass == NULL || HAS_PENDING_EXCEPTION) {\n+  if (shared_klass == nullptr || HAS_PENDING_EXCEPTION) {\n@@ -176,1 +176,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -182,1 +182,1 @@\n-\/\/ Guaranteed to return non-NULL value for non-shared classes.\n+\/\/ Guaranteed to return non-null value for non-shared classes.\n@@ -194,1 +194,1 @@\n-  assert(info != NULL, \"must be\");\n+  assert(info != nullptr, \"must be\");\n@@ -206,1 +206,1 @@\n-  if (info == NULL) {\n+  if (info == nullptr) {\n@@ -208,1 +208,1 @@\n-    assert(info != NULL, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n+    assert(info != nullptr, \"supertypes of any classes in _dumptime_table must either be shared, or must also be in _dumptime_table\");\n@@ -240,1 +240,1 @@\n-  return (info != NULL) ? info->_is_archived_lambda_proxy : false;\n+  return (info != nullptr) ? info->_is_archived_lambda_proxy : false;\n@@ -245,1 +245,1 @@\n-  if (info != NULL) {\n+  if (info != nullptr) {\n@@ -253,1 +253,1 @@\n-  return (info != NULL) ? info->is_early_klass() : false;\n+  return (info != nullptr) ? info->is_early_klass() : false;\n@@ -283,1 +283,1 @@\n-  if (k->signers() != NULL) {\n+  if (k->signers() != nullptr) {\n@@ -320,1 +320,1 @@\n-  if (super != NULL && check_for_exclusion(super, NULL)) {\n+  if (super != nullptr && check_for_exclusion(super, nullptr)) {\n@@ -330,1 +330,1 @@\n-    if (check_for_exclusion(intf, NULL)) {\n+    if (check_for_exclusion(intf, nullptr)) {\n@@ -342,1 +342,1 @@\n-  return (class_loader == NULL ||\n+  return (class_loader == nullptr ||\n@@ -393,1 +393,1 @@\n-  InstanceKlass* k = NULL;\n+  InstanceKlass* k = nullptr;\n@@ -396,1 +396,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -410,1 +410,1 @@\n-      assert(get_loader_lock_or_null(class_loader) == NULL, \"ObjectLocker not required\");\n+      assert(get_loader_lock_or_null(class_loader) == nullptr, \"ObjectLocker not required\");\n@@ -414,1 +414,1 @@\n-        if (check != NULL) {\n+        if (check != nullptr) {\n@@ -420,1 +420,1 @@\n-      if (k != NULL) {\n+      if (k != nullptr) {\n@@ -434,1 +434,1 @@\n-static UnregisteredClassesTable* _unregistered_classes_table = NULL;\n+static UnregisteredClassesTable* _unregistered_classes_table = nullptr;\n@@ -444,1 +444,1 @@\n-  if (_unregistered_classes_table == NULL) {\n+  if (_unregistered_classes_table == nullptr) {\n@@ -470,1 +470,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -474,1 +474,1 @@\n-  if (parser == NULL) {\n+  if (parser == nullptr) {\n@@ -476,1 +476,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -490,1 +490,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -526,1 +526,1 @@\n-  if (_unregistered_classes_table != NULL) {\n+  if (_unregistered_classes_table != nullptr) {\n@@ -528,1 +528,1 @@\n-    \/\/ set it to NULL. This ensure no classes with the same name can be\n+    \/\/ set it to null. This ensure no classes with the same name can be\n@@ -532,2 +532,2 @@\n-    if (v != NULL) {\n-      *v = NULL;\n+    if (v != nullptr) {\n+      *v = nullptr;\n@@ -548,1 +548,1 @@\n-  if (k->java_super() != NULL && has_been_redefined(k->java_super())) {\n+  if (k->java_super() != nullptr && has_been_redefined(k->java_super())) {\n@@ -567,1 +567,1 @@\n-  guarantee(info != NULL, \"Class %s must be entered into _dumptime_table\", name);\n+  guarantee(info != nullptr, \"Class %s must be entered into _dumptime_table\", name);\n@@ -675,1 +675,1 @@\n-  return (p == NULL) ? false : p->failed_verification();\n+  return (p == nullptr) ? false : p->failed_verification();\n@@ -752,1 +752,1 @@\n-  assert(java_lang_Class::class_data(lambda_ik->java_mirror()) == NULL, \"must not have class data\");\n+  assert(java_lang_Class::class_data(lambda_ik->java_mirror()) == nullptr, \"must not have class data\");\n@@ -759,1 +759,1 @@\n-  assert(nest_host != NULL, \"unexpected NULL nest_host\");\n+  assert(nest_host != nullptr, \"unexpected nullptr nest_host\");\n@@ -762,1 +762,1 @@\n-  if (info != NULL && !lambda_ik->is_non_strong_hidden() && is_builtin(lambda_ik) && is_builtin(caller_ik)\n+  if (info != nullptr && !lambda_ik->is_non_strong_hidden() && is_builtin(lambda_ik) && is_builtin(caller_ik)\n@@ -790,1 +790,1 @@\n-  if (info == NULL) {\n+  if (info == nullptr) {\n@@ -793,2 +793,2 @@\n-  InstanceKlass* proxy_klass = NULL;\n-  if (info != NULL) {\n+  InstanceKlass* proxy_klass = nullptr;\n+  if (info != nullptr) {\n@@ -798,1 +798,1 @@\n-      while (curr_klass->next_link() != NULL) {\n+      while (curr_klass->next_link() != nullptr) {\n@@ -805,1 +805,1 @@\n-      prev_klass->set_next_link(NULL);\n+      prev_klass->set_next_link(nullptr);\n@@ -834,1 +834,1 @@\n-  if (caller_ik->class_loader() != NULL) {\n+  if (caller_ik->class_loader() != nullptr) {\n@@ -839,1 +839,1 @@\n-  assert(shared_nest_host != NULL, \"unexpected NULL _nest_host\");\n+  assert(shared_nest_host != nullptr, \"unexpected nullptr _nest_host\");\n@@ -844,2 +844,2 @@\n-  if (loaded_lambda == NULL) {\n-    return NULL;\n+  if (loaded_lambda == nullptr) {\n+    return nullptr;\n@@ -918,1 +918,1 @@\n-    return (oop)NULL;\n+    return (oop)nullptr;\n@@ -968,1 +968,1 @@\n-  assert(klass_loader != NULL, \"should not be called for boot loader\");\n+  assert(klass_loader != nullptr, \"should not be called for boot loader\");\n@@ -995,1 +995,1 @@\n-    assert(info != NULL, \"Sanity\");\n+    assert(info != nullptr, \"Sanity\");\n@@ -1035,1 +1035,1 @@\n-  if (bsi->arg_values() == NULL || !bsi->arg_values()->is_objArray()) {\n+  if (bsi->arg_values() == nullptr || !bsi->arg_values()->is_objArray()) {\n@@ -1278,1 +1278,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1282,1 +1282,1 @@\n-  const RunTimeClassInfo* record = NULL;\n+  const RunTimeClassInfo* record = nullptr;\n@@ -1303,1 +1303,1 @@\n-  if (record == NULL && DynamicArchive::is_mapped()) {\n+  if (record == nullptr && DynamicArchive::is_mapped()) {\n@@ -1314,1 +1314,1 @@\n-  if (record != NULL) {\n+  if (record != nullptr) {\n@@ -1324,1 +1324,1 @@\n-       return NULL;\n+       return nullptr;\n@@ -1328,1 +1328,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1453,2 +1453,2 @@\n-    assert(_table != NULL, \"_dumptime_table is NULL\");\n-    assert(_cloned_table != NULL, \"_cloned_table is NULL\");\n+    assert(_table != nullptr, \"_dumptime_table is nullptr\");\n+    assert(_cloned_table != nullptr, \"_cloned_table is nullptr\");\n@@ -1472,2 +1472,2 @@\n-    assert(_table != NULL, \"_dumptime_table is NULL\");\n-    assert(_cloned_table != NULL, \"_cloned_table is NULL\");\n+    assert(_table != nullptr, \"_dumptime_table is nullptr\");\n+    assert(_cloned_table != nullptr, \"_cloned_table is nullptr\");\n@@ -1504,1 +1504,1 @@\n-  assert(_cloned_dumptime_table == NULL, \"_cloned_dumptime_table must be cleaned\");\n+  assert(_cloned_dumptime_table == nullptr, \"_cloned_dumptime_table must be cleaned\");\n@@ -1510,1 +1510,1 @@\n-  assert(_cloned_dumptime_lambda_proxy_class_dictionary == NULL,\n+  assert(_cloned_dumptime_lambda_proxy_class_dictionary == nullptr,\n@@ -1523,1 +1523,1 @@\n-  _cloned_dumptime_table = NULL;\n+  _cloned_dumptime_table = nullptr;\n@@ -1527,1 +1527,1 @@\n-  _cloned_dumptime_lambda_proxy_class_dictionary = NULL;\n+  _cloned_dumptime_lambda_proxy_class_dictionary = nullptr;\n@@ -1539,2 +1539,2 @@\n-    bool always_exclude = SystemDictionaryShared::check_for_exclusion(caller_ik, NULL) ||\n-                          SystemDictionaryShared::check_for_exclusion(nest_host, NULL);\n+    bool always_exclude = SystemDictionaryShared::check_for_exclusion(caller_ik, nullptr) ||\n+                          SystemDictionaryShared::check_for_exclusion(nest_host, nullptr);\n@@ -1544,1 +1544,1 @@\n-      if (always_exclude || SystemDictionaryShared::check_for_exclusion(ik, NULL)) {\n+      if (always_exclude || SystemDictionaryShared::check_for_exclusion(ik, nullptr)) {\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":81,"deletions":81,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,2 +50,2 @@\n-address VtableStub::_chunk             = NULL;\n-address VtableStub::_chunk_end         = NULL;\n+address VtableStub::_chunk             = nullptr;\n+address VtableStub::_chunk_end         = nullptr;\n@@ -62,1 +62,1 @@\n-  if (_chunk == NULL || _chunk + real_size > _chunk_end) {\n+  if (_chunk == nullptr || _chunk + real_size > _chunk_end) {\n@@ -68,2 +68,2 @@\n-    if (blob == NULL) {\n-      return NULL;\n+    if (blob == nullptr) {\n+      return nullptr;\n@@ -135,1 +135,1 @@\n-      _table[i] = NULL;\n+      _table[i] = nullptr;\n@@ -219,1 +219,1 @@\n-    if (s == NULL) {\n+    if (s == nullptr) {\n@@ -227,2 +227,2 @@\n-      if (s == NULL) {\n-        return NULL;\n+      if (s == nullptr) {\n+        return nullptr;\n@@ -282,2 +282,2 @@\n-  for (s = _table[hash]; s != NULL && s != stub; s = s->next()) {}\n-  return (s == stub) ? s : NULL;\n+  for (s = _table[hash]; s != nullptr && s != stub; s = s->next()) {}\n+  return (s == stub) ? s : nullptr;\n@@ -289,1 +289,1 @@\n-  return stub_containing(pc) != NULL;\n+  return stub_containing(pc) != nullptr;\n@@ -298,1 +298,1 @@\n-    for (VtableStub* s = _table[i]; s != NULL; s = s->next()) {\n+    for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n@@ -302,1 +302,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -311,1 +311,1 @@\n-        for (VtableStub* s = _table[i]; s != NULL; s = s->next()) {\n+        for (VtableStub* s = _table[i]; s != nullptr; s = s->next()) {\n","filename":"src\/hotspot\/share\/code\/vtableStubs.cpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-#include \"gc\/shared\/gcLocker.hpp\"\n+#include \"gc\/shared\/gcLocker.inline.hpp\"\n@@ -1030,3 +1030,0 @@\n-  \/\/ Purge code root memory\n-  purge_code_root_memory();\n-\n@@ -1862,6 +1859,1 @@\n-  switch (cause) {\n-    case GCCause::_java_lang_system_gc:                 return ExplicitGCInvokesConcurrent;\n-    case GCCause::_dcmd_gc_run:                         return ExplicitGCInvokesConcurrent;\n-    case GCCause::_wb_conc_mark:                        return true;\n-    default :                                           return false;\n-  }\n+  return GCCause::is_user_requested_gc(cause) && ExplicitGCInvokesConcurrent;\n@@ -2411,0 +2403,8 @@\n+void G1CollectedHeap::pin_object(JavaThread* thread, oop obj) {\n+  GCLocker::lock_critical(thread);\n+}\n+\n+void G1CollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n+  GCLocker::unlock_critical(thread);\n+}\n+\n@@ -2490,49 +2490,0 @@\n-#ifndef PRODUCT\n-\/\/ Helpful for debugging RSet issues.\n-\n-class PrintRSetsClosure : public HeapRegionClosure {\n-private:\n-  const char* _msg;\n-  size_t _occupied_sum;\n-\n-public:\n-  bool do_heap_region(HeapRegion* r) {\n-    HeapRegionRemSet* hrrs = r->rem_set();\n-    size_t occupied = hrrs->occupied();\n-    _occupied_sum += occupied;\n-\n-    tty->print_cr(\"Printing RSet for region \" HR_FORMAT, HR_FORMAT_PARAMS(r));\n-    if (occupied == 0) {\n-      tty->print_cr(\"  RSet is empty\");\n-    } else {\n-      tty->print_cr(\"hrrs \" PTR_FORMAT, p2i(hrrs));\n-    }\n-    tty->print_cr(\"----------\");\n-    return false;\n-  }\n-\n-  PrintRSetsClosure(const char* msg) : _msg(msg), _occupied_sum(0) {\n-    tty->cr();\n-    tty->print_cr(\"========================================\");\n-    tty->print_cr(\"%s\", msg);\n-    tty->cr();\n-  }\n-\n-  ~PrintRSetsClosure() {\n-    tty->print_cr(\"Occupied Sum: \" SIZE_FORMAT, _occupied_sum);\n-    tty->print_cr(\"========================================\");\n-    tty->cr();\n-  }\n-};\n-\n-void G1CollectedHeap::print_cset_rsets() {\n-  PrintRSetsClosure cl(\"Printing CSet RSets\");\n-  collection_set_iterate_all(&cl);\n-}\n-\n-void G1CollectedHeap::print_all_rsets() {\n-  PrintRSetsClosure cl(\"Printing All RSets\");;\n-  heap_region_iterate(&cl);\n-}\n-#endif \/\/ PRODUCT\n-\n@@ -3375,4 +3326,0 @@\n-void G1CollectedHeap::purge_code_root_memory() {\n-  G1CodeRootSet::purge();\n-}\n-\n@@ -3420,1 +3367,8 @@\n-void G1CollectedHeap::start_codecache_marking_cycle_if_inactive() {\n+void G1CollectedHeap::start_codecache_marking_cycle_if_inactive(bool concurrent_mark_start) {\n+  \/\/ We can reach here with an active code cache marking cycle either because the\n+  \/\/ previous G1 concurrent marking cycle was undone (if heap occupancy after the\n+  \/\/ concurrent start young collection was below the threshold) or aborted. See\n+  \/\/ CodeCache::on_gc_marking_cycle_finish() why this is.  We must not start a new code\n+  \/\/ cache cycle then. If we are about to start a new g1 concurrent marking cycle we\n+  \/\/ still have to arm all nmethod entry barriers. They are needed for adding oop\n+  \/\/ constants to the SATB snapshot. Full GC does not need nmethods to be armed.\n@@ -3422,6 +3376,2 @@\n-    \/\/ This is the normal case when we do not call collect when a\n-    \/\/ concurrent mark is ongoing. We then start a new code marking\n-    \/\/ cycle. If, on the other hand, a concurrent mark is ongoing, we\n-    \/\/ will be conservative and use the last code marking cycle. Code\n-    \/\/ caches marked between the two concurrent marks will live a bit\n-    \/\/ longer than needed.\n+  }\n+  if (concurrent_mark_start) {\n@@ -3432,0 +3382,5 @@\n+\n+void G1CollectedHeap::finish_codecache_marking_cycle() {\n+  CodeCache::on_gc_marking_cycle_finish();\n+  CodeCache::arm_all_nmethods();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":26,"deletions":71,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -262,1 +262,1 @@\n-  \/\/ (d) cause == _wb_conc_mark or _wb_breakpoint,\n+  \/\/ (d) cause == _wb_breakpoint,\n@@ -943,1 +943,2 @@\n-  static void start_codecache_marking_cycle_if_inactive();\n+  static void start_codecache_marking_cycle_if_inactive(bool concurrent_mark_start);\n+  static void finish_codecache_marking_cycle();\n@@ -1282,2 +1283,0 @@\n-  \/\/ Free up superfluous code root memory.\n-  void purge_code_root_memory();\n@@ -1322,0 +1321,3 @@\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n+\n@@ -1337,4 +1339,0 @@\n-  \/\/ The following two methods are helpful for debugging RSet issues.\n-  void print_cset_rsets() PRODUCT_RETURN;\n-  void print_all_rsets() PRODUCT_RETURN;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-  G1CollectedHeap::start_codecache_marking_cycle_if_inactive();\n+  G1CollectedHeap::start_codecache_marking_cycle_if_inactive(false \/* concurrent_mark_start *\/);\n@@ -215,2 +215,1 @@\n-  CodeCache::on_gc_marking_cycle_finish();\n-  CodeCache::arm_all_nmethods();\n+  G1CollectedHeap::finish_codecache_marking_cycle();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,1 +171,1 @@\n-  guarantee(thr != NULL, \"No thread\");\n+  guarantee(thr != nullptr, \"No thread\");\n@@ -196,1 +196,1 @@\n-  guarantee(thr != NULL, \"No thread\");\n+  guarantee(thr != nullptr, \"No thread\");\n@@ -216,1 +216,1 @@\n-  guarantee(thr != NULL, \"No thread\");\n+  guarantee(thr != nullptr, \"No thread\");\n@@ -234,18 +234,0 @@\n-size_t MutableNUMASpace::capacity_in_words(Thread* thr) const {\n-  guarantee(thr != NULL, \"No thread\");\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1) {\n-    if (lgrp_spaces()->length() > 0) {\n-      return capacity_in_words() \/ lgrp_spaces()->length();\n-    } else {\n-      assert(false, \"There should be at least one locality group\");\n-      return 0;\n-    }\n-  }\n-  int i = lgrp_spaces()->find(&lgrp_id, LGRPSpace::equals);\n-  if (i == -1) {\n-    return 0;\n-  }\n-  return lgrp_spaces()->at(i)->space()->capacity_in_words();\n-}\n-\n@@ -379,6 +361,0 @@\n-  if (NUMAStats) {\n-    for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-      lgrp_spaces()->at(i)->accumulate_statistics(page_size());\n-    }\n-  }\n-\n@@ -408,6 +384,0 @@\n-\n-  if (NUMAStats) {\n-    for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-      lgrp_spaces()->at(i)->accumulate_statistics(page_size());\n-    }\n-  }\n@@ -620,2 +590,2 @@\n-    if (intersection.start() == NULL ||\n-        intersection.end() == NULL   ||\n+    if (intersection.start() == nullptr ||\n+        intersection.end() == nullptr   ||\n@@ -696,1 +666,1 @@\n-    if (intersection.start() == NULL || intersection.end() == NULL) {\n+    if (intersection.start() == nullptr || intersection.end() == nullptr) {\n@@ -816,1 +786,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -822,1 +792,1 @@\n-        p = NULL;\n+        p = nullptr;\n@@ -828,1 +798,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -838,1 +808,1 @@\n-  if (p != NULL && !os::numa_has_static_binding() ) {\n+  if (p != nullptr && !os::numa_has_static_binding() ) {\n@@ -843,1 +813,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -873,2 +843,1 @@\n-                SIZE_FORMAT \"K\/\" SIZE_FORMAT \"K\/\" SIZE_FORMAT\n-                \"K, large\/small pages: \" SIZE_FORMAT \"\/\" SIZE_FORMAT \"\\n\",\n+                SIZE_FORMAT \"K\/\" SIZE_FORMAT \"K\/\" SIZE_FORMAT \"K\\n\",\n@@ -878,3 +847,1 @@\n-                ls->space_stats()->_uncommited_space \/ K,\n-                ls->space_stats()->_large_pages,\n-                ls->space_stats()->_small_pages);\n+                ls->space_stats()->_uncommited_space \/ K);\n@@ -898,18 +865,13 @@\n-  if (start < end) {\n-    for (char *p = start; p < end;) {\n-      os::page_info info;\n-      if (os::get_page_info(p, &info)) {\n-        if (info.size > 0) {\n-          if (info.size > (size_t)os::vm_page_size()) {\n-            space_stats()->_large_pages++;\n-          } else {\n-            space_stats()->_small_pages++;\n-          }\n-          if (info.lgrp_id == lgrp_id()) {\n-            space_stats()->_local_space += info.size;\n-          } else {\n-            space_stats()->_remote_space += info.size;\n-          }\n-          p += info.size;\n-        } else {\n-          p += os::vm_page_size();\n+  for (char *p = start; p < end; ) {\n+    static const size_t PagesPerIteration = 128;\n+    const void* pages[PagesPerIteration];\n+    int lgrp_ids[PagesPerIteration];\n+\n+    size_t npages = 0;\n+    for (; npages < PagesPerIteration && p < end; p += os::vm_page_size()) {\n+      pages[npages++] = p;\n+    }\n+\n+    if (os::numa_get_group_ids_for_range(pages, lgrp_ids, npages)) {\n+      for (size_t i = 0; i < npages; i++) {\n+        if (lgrp_ids[i] < 0) {\n@@ -917,0 +879,4 @@\n+        } else if (lgrp_ids[i] == lgrp_id()) {\n+          space_stats()->_local_space += os::vm_page_size();\n+        } else {\n+          space_stats()->_remote_space += os::vm_page_size();\n@@ -918,2 +884,0 @@\n-      } else {\n-        return;\n@@ -950,1 +914,1 @@\n-    if (e == NULL) {\n+    if (e == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":32,"deletions":68,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -351,1 +351,1 @@\n-                      &ParallelScavengeHeap::heap()->workers() : NULL;\n+                      &ParallelScavengeHeap::heap()->workers() : nullptr;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,5 +46,5 @@\n-PaddedEnd<PSPromotionManager>* PSPromotionManager::_manager_array = NULL;\n-PSPromotionManager::PSScannerTasksQueueSet* PSPromotionManager::_stack_array_depth = NULL;\n-PreservedMarksSet*             PSPromotionManager::_preserved_marks_set = NULL;\n-PSOldGen*                      PSPromotionManager::_old_gen = NULL;\n-MutableSpace*                  PSPromotionManager::_young_space = NULL;\n+PaddedEnd<PSPromotionManager>* PSPromotionManager::_manager_array = nullptr;\n+PSPromotionManager::PSScannerTasksQueueSet* PSPromotionManager::_stack_array_depth = nullptr;\n+PreservedMarksSet*             PSPromotionManager::_preserved_marks_set = nullptr;\n+PSOldGen*                      PSPromotionManager::_old_gen = nullptr;\n+MutableSpace*                  PSPromotionManager::_young_space = nullptr;\n@@ -62,1 +62,1 @@\n-  assert(_manager_array == NULL, \"Attempt to initialize twice\");\n+  assert(_manager_array == nullptr, \"Attempt to initialize twice\");\n@@ -74,1 +74,1 @@\n-  assert(_preserved_marks_set == NULL, \"Attempt to initialize twice\");\n+  assert(_preserved_marks_set == nullptr, \"Attempt to initialize twice\");\n@@ -93,1 +93,1 @@\n-  assert(_manager_array != NULL, \"Sanity\");\n+  assert(_manager_array != nullptr, \"Sanity\");\n@@ -98,1 +98,1 @@\n-  assert(_manager_array != NULL, \"Sanity\");\n+  assert(_manager_array != nullptr, \"Sanity\");\n@@ -196,1 +196,1 @@\n-  _preserved_marks = NULL;\n+  _preserved_marks = nullptr;\n@@ -221,1 +221,1 @@\n-  assert(_preserved_marks == NULL, \"do not set it twice\");\n+  assert(_preserved_marks == nullptr, \"do not set it twice\");\n@@ -230,1 +230,2 @@\n-  totally_drain = totally_drain || (_target_stack_size == 0);\n+  const uint threshold = totally_drain ? 0\n+                                       : _target_stack_size;\n@@ -239,9 +240,1 @@\n-      process_popped_location_depth(task);\n-    }\n-\n-    if (totally_drain) {\n-      while (tq->pop_local(task)) {\n-        process_popped_location_depth(task);\n-      }\n-    } else {\n-      while (tq->size() > _target_stack_size && tq->pop_local(task)) {\n+      if (!tq->try_push_to_taskqueue(task)) {\n@@ -251,1 +244,5 @@\n-  } while ((totally_drain && !tq->taskqueue_empty()) || !tq->overflow_empty());\n+\n+    while (tq->pop_local(task, threshold)) {\n+      process_popped_location_depth(task);\n+    }\n+  } while (!tq->overflow_empty());\n@@ -333,1 +330,1 @@\n-  if (obj->forward_to_self_atomic(obj_mark) == NULL) {\n+  if (obj->forward_to_self_atomic(obj_mark) == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-  assert(_manager_array != NULL, \"access of NULL manager_array\");\n+  assert(_manager_array != nullptr, \"access of null manager_array\");\n@@ -71,1 +71,1 @@\n-  if (new_obj != NULL) {\n+  if (new_obj != nullptr) {\n@@ -74,1 +74,1 @@\n-    if (lab != NULL) {\n+    if (lab != nullptr) {\n@@ -164,1 +164,1 @@\n-  oop new_obj = NULL;\n+  oop new_obj = nullptr;\n@@ -181,1 +181,1 @@\n-      if (new_obj == NULL && !_young_gen_is_full) {\n+      if (new_obj == nullptr && !_young_gen_is_full) {\n@@ -186,1 +186,1 @@\n-          promotion_trace_event(new_obj, o, klass, new_obj_size, age, false, NULL);\n+          promotion_trace_event(new_obj, o, klass, new_obj_size, age, false, nullptr);\n@@ -192,1 +192,1 @@\n-          if (lab_base != NULL) {\n+          if (lab_base != nullptr) {\n@@ -206,1 +206,1 @@\n-  if (new_obj == NULL) {\n+  if (new_obj == nullptr) {\n@@ -216,1 +216,1 @@\n-    if (new_obj == NULL) {\n+    if (new_obj == nullptr) {\n@@ -222,1 +222,1 @@\n-          promotion_trace_event(new_obj, o, klass, new_obj_size, age, true, NULL);\n+          promotion_trace_event(new_obj, o, klass, new_obj_size, age, true, nullptr);\n@@ -228,1 +228,1 @@\n-          if(lab_base != NULL) {\n+          if(lab_base != nullptr) {\n@@ -243,1 +243,1 @@\n-      if (new_obj == NULL) {\n+      if (new_obj == nullptr) {\n@@ -250,1 +250,1 @@\n-  assert(new_obj != NULL, \"allocation should have succeeded\");\n+  assert(new_obj != nullptr, \"allocation should have succeeded\");\n@@ -264,1 +264,1 @@\n-  if (forwardee == NULL) {  \/\/ forwardee is NULL when forwarding is successful\n+  if (forwardee == nullptr) {  \/\/ forwardee is null when forwarding is successful\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,9 +79,0 @@\n-DefNewGeneration::KeepAliveClosure::\n-KeepAliveClosure(ScanWeakRefClosure* cl) : _cl(cl) {\n-  _rs = GenCollectedHeap::heap()->rem_set();\n-}\n-\n-void DefNewGeneration::KeepAliveClosure::do_oop(oop* p)       { DefNewGeneration::KeepAliveClosure::do_oop_work(p); }\n-void DefNewGeneration::KeepAliveClosure::do_oop(narrowOop* p) { DefNewGeneration::KeepAliveClosure::do_oop_work(p); }\n-\n-\n@@ -90,1 +81,2 @@\n-  DefNewGeneration::KeepAliveClosure(cl) {\n+  _cl(cl) {\n+  _rs = GenCollectedHeap::heap()->rem_set();\n@@ -130,1 +122,1 @@\n-    _scavenge_closure->set_scanned_cld(NULL);\n+    _scavenge_closure->set_scanned_cld(nullptr);\n@@ -184,1 +176,1 @@\n-  _old_gen = NULL;\n+  _old_gen = nullptr;\n@@ -274,1 +266,1 @@\n-  from()->set_next_compaction_space(NULL);\n+  from()->set_next_compaction_space(nullptr);\n@@ -285,1 +277,1 @@\n-  from()->set_next_compaction_space(NULL);\n+  from()->set_next_compaction_space(nullptr);\n@@ -485,1 +477,1 @@\n-  HeapWord* result = NULL;\n+  HeapWord* result = nullptr;\n@@ -498,1 +490,1 @@\n-                        result == NULL ? \"NULL\" : \"object\");\n+                        result == nullptr ? \"null\" : \"object\");\n@@ -549,1 +541,1 @@\n-  GCTraceTime(Trace, gc, phases) tm(\"DefNew\", NULL, heap->gc_cause());\n+  GCTraceTime(Trace, gc, phases) tm(\"DefNew\", nullptr, heap->gc_cause());\n@@ -667,1 +659,1 @@\n-  from()->set_next_compaction_space(NULL);\n+  from()->set_next_compaction_space(nullptr);\n@@ -701,1 +693,1 @@\n-  _preserved_marks_set.restore(NULL);\n+  _preserved_marks_set.restore(nullptr);\n@@ -730,1 +722,1 @@\n-  oop obj = NULL;\n+  oop obj = nullptr;\n@@ -739,1 +731,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -741,1 +733,1 @@\n-    if (obj == NULL) {\n+    if (obj == nullptr) {\n@@ -786,7 +778,0 @@\n-void DefNewGeneration::reset_saved_marks() {\n-  eden()->reset_saved_mark();\n-  to()->reset_saved_mark();\n-  from()->reset_saved_mark();\n-}\n-\n-\n@@ -837,1 +822,1 @@\n-  if (_old_gen == NULL) {\n+  if (_old_gen == nullptr) {\n@@ -947,1 +932,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":17,"deletions":32,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,2 @@\n-  assert(ref_processor() == NULL, \"no stomping\");\n-  assert(rp != NULL, \"should be non-NULL\");\n+  assert(ref_processor() == nullptr, \"no stomping\");\n+  assert(rp != nullptr, \"should be non-null\");\n@@ -137,1 +137,1 @@\n-  set_ref_processor(NULL);\n+  set_ref_processor(nullptr);\n@@ -156,1 +156,1 @@\n-  if (scratch != NULL) {\n+  if (scratch != nullptr) {\n@@ -188,1 +188,1 @@\n-    CLDClosure* weak_cld_closure = ClassUnloading ? NULL : &follow_cld_closure;\n+    CLDClosure* weak_cld_closure = ClassUnloading ? nullptr : &follow_cld_closure;\n@@ -239,7 +239,0 @@\n-\n-  \/\/ It is not required that we traverse spaces in the same order in\n-  \/\/ phase2, phase3 and phase4, but the ValidateMarkSweep live oops\n-  \/\/ tracking expects us to do so. See comment under phase4.\n-\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-\n@@ -248,1 +241,1 @@\n-  gch->prepare_for_compaction();\n+  GenCollectedHeap::heap()->prepare_for_compaction();\n@@ -291,12 +284,0 @@\n-\n-  \/\/ It is imperative that we traverse perm_gen first in phase4. All\n-  \/\/ classes must be allocated earlier than their instances, and traversing\n-  \/\/ perm_gen first makes sure that all Klass*s have moved to their new\n-  \/\/ location before any instance does a dispatch through it's klass!\n-\n-  \/\/ The ValidateMarkSweep live oops tracking expects us to traverse spaces\n-  \/\/ in the same order in phase2, phase3 and phase4. We don't quite do that\n-  \/\/ here (perm_gen first rather than last), so we tell the validate code\n-  \/\/ to use a higher index (saved from phase2) when verifying perm_gen.\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-\n@@ -306,1 +287,1 @@\n-  gch->generation_iterate(&blk, true);\n+  GenCollectedHeap::heap()->generation_iterate(&blk, true);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":8,"deletions":27,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,4 +56,4 @@\n-PreservedMark*          MarkSweep::_preserved_marks = NULL;\n-ReferenceProcessor*     MarkSweep::_ref_processor   = NULL;\n-STWGCTimer*             MarkSweep::_gc_timer        = NULL;\n-SerialOldTracer*        MarkSweep::_gc_tracer       = NULL;\n+PreservedMark*          MarkSweep::_preserved_marks = nullptr;\n+ReferenceProcessor*     MarkSweep::_ref_processor   = nullptr;\n+STWGCTimer*             MarkSweep::_gc_timer        = nullptr;\n+SerialOldTracer*        MarkSweep::_gc_tracer       = nullptr;\n@@ -61,1 +61,1 @@\n-StringDedup::Requests*  MarkSweep::_string_dedup_requests = NULL;\n+StringDedup::Requests*  MarkSweep::_string_dedup_requests = nullptr;\n","filename":"src\/hotspot\/share\/gc\/serial\/markSweep.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -637,13 +637,0 @@\n-bool CollectedHeap::supports_object_pinning() const {\n-  return false;\n-}\n-\n-oop CollectedHeap::pin_object(JavaThread* thread, oop obj) {\n-  ShouldNotReachHere();\n-  return NULL;\n-}\n-\n-void CollectedHeap::unpin_object(JavaThread* thread, oop obj) {\n-  ShouldNotReachHere();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,5 +503,5 @@\n-  \/\/ and Release*Critical() family of functions. If supported, the GC\n-  \/\/ must guarantee that pinned objects never move.\n-  virtual bool supports_object_pinning() const;\n-  virtual oop pin_object(JavaThread* thread, oop obj);\n-  virtual void unpin_object(JavaThread* thread, oop obj);\n+  \/\/ and Release*Critical() family of functions. The GC must guarantee\n+  \/\/ that pinned objects never move and don't get reclaimed as garbage.\n+  \/\/ These functions are potentially safepointing.\n+  virtual void pin_object(JavaThread* thread, oop obj) = 0;\n+  virtual void unpin_object(JavaThread* thread, oop obj) = 0;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -110,7 +110,0 @@\n-  \/\/ While there are no constraints in the GC code that HeapWordSize\n-  \/\/ be any particular value, there are multiple other areas in the\n-  \/\/ system which believe this to be true (e.g. oop->object_size in some\n-  \/\/ cases incorrectly returns the size in wordSize units rather than\n-  \/\/ HeapWordSize).\n-  guarantee(HeapWordSize == wordSize, \"HeapWordSize must equal wordSize\");\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-  virtual void do_full_collection(bool clear_all_soft_refs);\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -145,1 +145,1 @@\n-  virtual jint initialize();\n+  jint initialize() override;\n@@ -153,1 +153,1 @@\n-  void post_initialize();\n+  void post_initialize() override;\n@@ -167,1 +167,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy() { return &_soft_ref_gen_policy; }\n+  SoftRefPolicy* soft_ref_policy() override { return &_soft_ref_gen_policy; }\n@@ -177,2 +177,2 @@\n-  size_t capacity() const;\n-  size_t used() const;\n+  size_t capacity() const override;\n+  size_t used() const override;\n@@ -183,1 +183,1 @@\n-  size_t max_capacity() const;\n+  size_t max_capacity() const override;\n@@ -185,1 +185,1 @@\n-  HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded);\n+  HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded) override;\n@@ -190,1 +190,1 @@\n-  virtual void collect(GCCause::Cause cause);\n+  void collect(GCCause::Cause cause) override;\n@@ -196,1 +196,1 @@\n-  bool is_in(const void* p) const;\n+  bool is_in(const void* p) const override;\n@@ -202,1 +202,1 @@\n-  virtual bool requires_barriers(stackChunkOop obj) const;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -209,3 +209,3 @@\n-  virtual void register_nmethod(nmethod* nm);\n-  virtual void unregister_nmethod(nmethod* nm);\n-  virtual void verify_nmethod(nmethod* nm);\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override;\n@@ -217,1 +217,1 @@\n-  void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -242,6 +242,6 @@\n-  virtual size_t tlab_capacity(Thread* thr) const;\n-  virtual size_t tlab_used(Thread* thr) const;\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;\n-  virtual HeapWord* allocate_new_tlab(size_t min_size,\n-                                      size_t requested_size,\n-                                      size_t* actual_size);\n+  size_t tlab_capacity(Thread* thr) const override;\n+  size_t tlab_used(Thread* thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n+  HeapWord* allocate_new_tlab(size_t min_size,\n+                              size_t requested_size,\n+                              size_t* actual_size) override;\n@@ -260,2 +260,2 @@\n-  \/\/ Ensure parsability: override\n-  virtual void ensure_parsability(bool retire_tlabs);\n+  \/\/ Ensure parsability\n+  void ensure_parsability(bool retire_tlabs) override;\n@@ -280,2 +280,2 @@\n-  \/\/ Override.\n-  void prepare_for_verify();\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption option) override;\n@@ -283,7 +283,3 @@\n-  \/\/ Override.\n-  void verify(VerifyOption option);\n-\n-  \/\/ Override.\n-  virtual void print_on(outputStream* st) const;\n-  virtual void gc_threads_do(ThreadClosure* tc) const;\n-  virtual void print_tracing_info() const;\n+  void print_on(outputStream* st) const override;\n+  void gc_threads_do(ThreadClosure* tc) const override;\n+  void print_tracing_info() const override;\n@@ -292,1 +288,1 @@\n-  virtual bool print_location(outputStream* st, void* addr) const;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -312,1 +308,1 @@\n-  virtual bool is_maximal_no_gc() const;\n+  virtual bool is_maximal_no_gc() const override;\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#include \"metaprogramming\/conditional.hpp\"\n@@ -367,1 +366,1 @@\n-  typedef typename Conditional<std::is_const<Storage>::value, const Block*, Block*>::type BlockPtr;\n+  using BlockPtr = std::conditional_t<std::is_const<Storage>::value, const Block*, Block*>;\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,17 +53,4 @@\n-  if (top_obj != NULL) {\n-    if (_sp->block_is_obj(top_obj)) {\n-      if (_precision == CardTable::ObjHeadPreciseArray) {\n-        if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-          \/\/ An arrayOop is starting on the dirty card - since we do exact\n-          \/\/ store checks for objArrays we are done.\n-        } else {\n-          \/\/ Otherwise, it is possible that the object starting on the dirty\n-          \/\/ card spans the entire card, and that the store happened on a\n-          \/\/ later card.  Figure out where the object ends.\n-          \/\/ Use the block_size() method of the space over which\n-          \/\/ the iteration is being done.  That space (e.g. CMS) may have\n-          \/\/ specific requirements on object sizes which will\n-          \/\/ be reflected in the block_size() method.\n-          top = top_obj + cast_to_oop(top_obj)->size();\n-        }\n-      }\n+  if (top_obj != NULL && top_obj < (_sp->toContiguousSpace())->top()) {\n+    if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n+      \/\/ An arrayOop is starting on the dirty card - since we do exact\n+      \/\/ store checks for objArrays we are done.\n@@ -71,1 +58,6 @@\n-      top = top_obj;\n+      \/\/ Otherwise, it is possible that the object starting on the dirty\n+      \/\/ card spans the entire card, and that the store happened on a\n+      \/\/ later card.  Figure out where the object ends.\n+      assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n+             \"Block size and object size mismatch\");\n+      top = top_obj + cast_to_oop(top_obj)->size();\n@@ -74,1 +66,1 @@\n-    assert(top == _sp->end(), \"only case where top_obj == NULL\");\n+    top = (_sp->toContiguousSpace())->top();\n@@ -82,20 +74,7 @@\n-  \/\/ 1. Blocks may or may not be objects.\n-  \/\/ 2. Even when a block_is_obj(), it may not entirely\n-  \/\/    occupy the block if the block quantum is larger than\n-  \/\/    the object size.\n-  \/\/ We can and should try to optimize by calling the non-MemRegion\n-  \/\/ version of oop_iterate() for all but the extremal objects\n-  \/\/ (for which we need to call the MemRegion version of\n-  \/\/ oop_iterate()) To be done post-beta XXX\n-  for (; bottom < top; bottom += _sp->block_size(bottom)) {\n-    \/\/ As in the case of contiguous space above, we'd like to\n-    \/\/ just use the value returned by oop_iterate to increment the\n-    \/\/ current pointer; unfortunately, that won't work in CMS because\n-    \/\/ we'd need an interface change (it seems) to have the space\n-    \/\/ \"adjust the object size\" (for instance pad it up to its\n-    \/\/ block alignment or minimum block size restrictions. XXX\n-    if (_sp->block_is_obj(bottom) &&\n-        !_sp->obj_allocated_since_save_marks(cast_to_oop(bottom))) {\n-      cast_to_oop(bottom)->oop_iterate(_cl, mr);\n-    }\n-  }\n+  \/\/ Note that this assumption won't hold if we have a concurrent\n+  \/\/ collector in this space, which may have freed up objects after\n+  \/\/ they were dirtied and before the stop-the-world GC that is\n+  \/\/ examining cards here.\n+  assert(bottom < top, \"ought to be at least one obj on a dirty card.\");\n+\n+  walk_mem_region_with_cl(mr, bottom, top, _cl);\n@@ -119,6 +98,1 @@\n-  assert(_precision == CardTable::ObjHeadPreciseArray ||\n-         _precision == CardTable::Precise,\n-         \"Only ones we deal with for now.\");\n-\n-  assert(_precision != CardTable::ObjHeadPreciseArray ||\n-         _last_bottom == NULL || top <= _last_bottom,\n+  assert(_last_bottom == NULL || top <= _last_bottom,\n@@ -140,3 +114,1 @@\n-  if (_precision == CardTable::ObjHeadPreciseArray &&\n-      _min_done != NULL &&\n-      _min_done < top) {\n+  if (_min_done != NULL && _min_done < top) {\n@@ -152,3 +124,1 @@\n-         (_precision != CardTable::ObjHeadPreciseArray ||\n-          _min_done == NULL ||\n-          top <= _min_done),\n+         (_min_done == NULL || top <= _min_done),\n@@ -165,15 +135,13 @@\n-HeapWord* ContiguousSpaceDCTOC::get_actual_top(HeapWord* top,\n-                                               HeapWord* top_obj) {\n-  if (top_obj != NULL && top_obj < (_sp->toContiguousSpace())->top()) {\n-    if (_precision == CardTable::ObjHeadPreciseArray) {\n-      if (cast_to_oop(top_obj)->is_objArray() || cast_to_oop(top_obj)->is_typeArray()) {\n-        \/\/ An arrayOop is starting on the dirty card - since we do exact\n-        \/\/ store checks for objArrays we are done.\n-      } else {\n-        \/\/ Otherwise, it is possible that the object starting on the dirty\n-        \/\/ card spans the entire card, and that the store happened on a\n-        \/\/ later card.  Figure out where the object ends.\n-        assert(_sp->block_size(top_obj) == cast_to_oop(top_obj)->size(),\n-          \"Block size and object size mismatch\");\n-        top = top_obj + cast_to_oop(top_obj)->size();\n-      }\n+void DirtyCardToOopClosure::walk_mem_region_with_cl(MemRegion mr,\n+                                                    HeapWord* bottom,\n+                                                    HeapWord* top,\n+                                                    OopIterateClosure* cl) {\n+  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);\n+  if (bottom < top) {\n+    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();\n+    while (next_obj < top) {\n+      \/* Bottom lies entirely below top, so we can call the *\/\n+      \/* non-memRegion version of oop_iterate below. *\/\n+      cast_to_oop(bottom)->oop_iterate(cl);\n+      bottom = next_obj;\n+      next_obj = bottom + cast_to_oop(bottom)->size();\n@@ -181,2 +149,2 @@\n-  } else {\n-    top = (_sp->toContiguousSpace())->top();\n+    \/* Last object. *\/\n+    cast_to_oop(bottom)->oop_iterate(cl, mr);\n@@ -184,58 +152,0 @@\n-  return top;\n-}\n-\n-void ContiguousSpaceDCTOC::walk_mem_region(MemRegion mr,\n-                                           HeapWord* bottom,\n-                                           HeapWord* top) {\n-  \/\/ Note that this assumption won't hold if we have a concurrent\n-  \/\/ collector in this space, which may have freed up objects after\n-  \/\/ they were dirtied and before the stop-the-world GC that is\n-  \/\/ examining cards here.\n-  assert(bottom < top, \"ought to be at least one obj on a dirty card.\");\n-\n-  if (_boundary != NULL) {\n-    \/\/ We have a boundary outside of which we don't want to look\n-    \/\/ at objects, so create a filtering closure around the\n-    \/\/ oop closure before walking the region.\n-    FilteringClosure filter(_boundary, _cl);\n-    walk_mem_region_with_cl(mr, bottom, top, &filter);\n-  } else {\n-    \/\/ No boundary, simply walk the heap with the oop closure.\n-    walk_mem_region_with_cl(mr, bottom, top, _cl);\n-  }\n-\n-}\n-\n-\/\/ We must replicate this so that the static type of \"FilteringClosure\"\n-\/\/ (see above) is apparent at the oop_iterate calls.\n-#define ContiguousSpaceDCTOC__walk_mem_region_with_cl_DEFN(ClosureType) \\\n-void ContiguousSpaceDCTOC::walk_mem_region_with_cl(MemRegion mr,        \\\n-                                                   HeapWord* bottom,    \\\n-                                                   HeapWord* top,       \\\n-                                                   ClosureType* cl) {   \\\n-  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);              \\\n-  if (bottom < top) {                                                   \\\n-    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();          \\\n-    while (next_obj < top) {                                            \\\n-      \/* Bottom lies entirely below top, so we can call the *\/          \\\n-      \/* non-memRegion version of oop_iterate below. *\/                 \\\n-      cast_to_oop(bottom)->oop_iterate(cl);                             \\\n-      bottom = next_obj;                                                \\\n-      next_obj = bottom + cast_to_oop(bottom)->size();                  \\\n-    }                                                                   \\\n-    \/* Last object. *\/                                                  \\\n-    cast_to_oop(bottom)->oop_iterate(cl, mr);                           \\\n-  }                                                                     \\\n-}\n-\n-\/\/ (There are only two of these, rather than N, because the split is due\n-\/\/ only to the introduction of the FilteringClosure, a local part of the\n-\/\/ impl of this abstraction.)\n-ContiguousSpaceDCTOC__walk_mem_region_with_cl_DEFN(OopIterateClosure)\n-ContiguousSpaceDCTOC__walk_mem_region_with_cl_DEFN(FilteringClosure)\n-\n-DirtyCardToOopClosure*\n-ContiguousSpace::new_dcto_cl(OopIterateClosure* cl,\n-                             CardTable::PrecisionStyle precision,\n-                             HeapWord* boundary) {\n-  return new ContiguousSpaceDCTOC(this, cl, precision, boundary);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":36,"deletions":126,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -230,11 +230,14 @@\n-\/\/ A MemRegionClosure (ResourceObj) whose \"do_MemRegion\" function applies an\n-\/\/ OopClosure to (the addresses of) all the ref-containing fields that could\n-\/\/ be modified by virtue of the given MemRegion being dirty. (Note that\n-\/\/ because of the imprecise nature of the write barrier, this may iterate\n-\/\/ over oops beyond the region.)\n-\/\/ This base type for dirty card to oop closures handles memory regions\n-\/\/ in non-contiguous spaces with no boundaries, and should be sub-classed\n-\/\/ to support other space types. See ContiguousDCTOC for a sub-class\n-\/\/ that works with ContiguousSpaces.\n-\n-class DirtyCardToOopClosure: public MemRegionClosureRO {\n+\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n+\/\/ sub-classes). It knows how to filter out objects that are outside of the\n+\/\/ _boundary.\n+\/\/ (Note that because of the imprecise nature of the write barrier, this may\n+\/\/ iterate over oops beyond the region.)\n+\/\/\n+\/\/ Assumptions:\n+\/\/ 1. That the actual top of any area in a memory region\n+\/\/    contained by the space is bounded by the end of the contiguous\n+\/\/    region of the space.\n+\/\/ 2. That the space is really made up of objects and not just\n+\/\/    blocks.\n+\n+class DirtyCardToOopClosure: public MemRegionClosure {\n@@ -244,5 +247,2 @@\n-  CardTable::PrecisionStyle _precision;\n-  HeapWord* _boundary;          \/\/ If non-NULL, process only non-NULL oops\n-                                \/\/ pointing below boundary.\n-  HeapWord* _min_done;          \/\/ ObjHeadPreciseArray precision requires\n-                                \/\/ a downwards traversal; this is the\n+  HeapWord* _min_done;          \/\/ Need a downwards traversal to compensate\n+                                \/\/ imprecise write barrier; this is the\n@@ -260,1 +260,1 @@\n-  virtual HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n+  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj);\n@@ -268,1 +268,1 @@\n-  virtual void walk_mem_region(MemRegion mr, HeapWord* bottom, HeapWord* top);\n+  void walk_mem_region(MemRegion mr, HeapWord* bottom, HeapWord* top);\n@@ -270,0 +270,10 @@\n+  \/\/ Walk the given memory region, from bottom to top, applying\n+  \/\/ the given oop closure to (possibly) all objects found. The\n+  \/\/ given oop closure may or may not be the same as the oop\n+  \/\/ closure with which this closure was created, as it may\n+  \/\/ be a filtering closure which makes use of the _boundary.\n+  \/\/ We offer two signatures, so the FilteringClosure static type is\n+  \/\/ apparent.\n+  void walk_mem_region_with_cl(MemRegion mr,\n+                               HeapWord* bottom, HeapWord* top,\n+                               OopIterateClosure* cl);\n@@ -271,5 +281,2 @@\n-  DirtyCardToOopClosure(Space* sp, OopIterateClosure* cl,\n-                        CardTable::PrecisionStyle precision,\n-                        HeapWord* boundary) :\n-    _cl(cl), _sp(sp), _precision(precision), _boundary(boundary),\n-    _min_done(NULL) {\n+  DirtyCardToOopClosure(Space* sp, OopIterateClosure* cl) :\n+    _cl(cl), _sp(sp), _min_done(NULL) {\n@@ -422,1 +429,0 @@\n-  void reset_saved_mark()          { _saved_mark_word = bottom(); }\n@@ -470,4 +476,0 @@\n-  DirtyCardToOopClosure* new_dcto_cl(OopIterateClosure* cl,\n-                                     CardTable::PrecisionStyle precision,\n-                                     HeapWord* boundary);\n-\n@@ -515,40 +517,0 @@\n-\/\/ A dirty card to oop closure for contiguous spaces (ContiguousSpace and\n-\/\/ sub-classes). It knows how to filter out objects that are outside of the\n-\/\/ _boundary.\n-\/\/\n-\/\/ Assumptions:\n-\/\/ 1. That the actual top of any area in a memory region\n-\/\/    contained by the space is bounded by the end of the contiguous\n-\/\/    region of the space.\n-\/\/ 2. That the space is really made up of objects and not just\n-\/\/    blocks.\n-class ContiguousSpaceDCTOC : public DirtyCardToOopClosure {\n-  \/\/ Overrides.\n-  void walk_mem_region(MemRegion mr,\n-                       HeapWord* bottom, HeapWord* top) override;\n-\n-  HeapWord* get_actual_top(HeapWord* top, HeapWord* top_obj) override;\n-\n-  \/\/ Walk the given memory region, from bottom to top, applying\n-  \/\/ the given oop closure to (possibly) all objects found. The\n-  \/\/ given oop closure may or may not be the same as the oop\n-  \/\/ closure with which this closure was created, as it may\n-  \/\/ be a filtering closure which makes use of the _boundary.\n-  \/\/ We offer two signatures, so the FilteringClosure static type is\n-  \/\/ apparent.\n-  void walk_mem_region_with_cl(MemRegion mr,\n-                               HeapWord* bottom, HeapWord* top,\n-                               OopIterateClosure* cl);\n-  void walk_mem_region_with_cl(MemRegion mr,\n-                               HeapWord* bottom, HeapWord* top,\n-                               FilteringClosure* cl);\n-\n-public:\n-  ContiguousSpaceDCTOC(ContiguousSpace* sp, OopIterateClosure* cl,\n-                       CardTable::PrecisionStyle precision,\n-                       HeapWord* boundary) :\n-    DirtyCardToOopClosure(sp, cl, precision, boundary)\n-  {}\n-};\n-\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":30,"deletions":68,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1923,1 +1924,1 @@\n-oop ShenandoahHeap::pin_object(JavaThread* thr, oop o) {\n+void ShenandoahHeap::pin_object(JavaThread* thr, oop o) {\n@@ -1925,1 +1926,0 @@\n-  return o;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,2 +148,2 @@\n-  const char* name()          const { return \"Shenandoah\"; }\n-  ShenandoahHeap::Name kind() const { return CollectedHeap::Shenandoah; }\n+  const char* name()          const override { return \"Shenandoah\"; }\n+  ShenandoahHeap::Name kind() const override { return CollectedHeap::Shenandoah; }\n@@ -151,2 +152,2 @@\n-  jint initialize();\n-  void post_initialize();\n+  jint initialize() override;\n+  void post_initialize() override;\n@@ -156,1 +157,1 @@\n-  void initialize_serviceability();\n+  void initialize_serviceability() override;\n@@ -158,3 +159,3 @@\n-  void print_on(outputStream* st)              const;\n-  void print_extended_on(outputStream *st)     const;\n-  void print_tracing_info()                    const;\n+  void print_on(outputStream* st)              const override;\n+  void print_extended_on(outputStream *st)     const override;\n+  void print_tracing_info()                    const override;\n@@ -163,1 +164,1 @@\n-  void stop();\n+  void stop() override;\n@@ -165,2 +166,2 @@\n-  void prepare_for_verify();\n-  void verify(VerifyOption vo);\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption vo) override;\n@@ -169,1 +170,1 @@\n-  bool supports_concurrent_gc_breakpoints() const {\n+  bool supports_concurrent_gc_breakpoints() const override {\n@@ -198,1 +199,1 @@\n-  size_t max_capacity()      const;\n+  size_t max_capacity()      const override;\n@@ -201,2 +202,2 @@\n-  size_t capacity()          const;\n-  size_t used()              const;\n+  size_t capacity()          const override;\n+  size_t used()              const override;\n@@ -219,1 +220,1 @@\n-  WorkerThreads* safepoint_workers();\n+  WorkerThreads* safepoint_workers() override;\n@@ -221,1 +222,1 @@\n-  void gc_threads_do(ThreadClosure* tcl) const;\n+  void gc_threads_do(ThreadClosure* tcl) const override;\n@@ -424,8 +425,8 @@\n-  ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }\n-  GCMemoryManager* cycle_memory_manager()           { return &_cycle_memory_manager; }\n-  GCMemoryManager* stw_memory_manager()             { return &_stw_memory_manager;   }\n-  SoftRefPolicy* soft_ref_policy()                  { return &_soft_ref_policy;      }\n-\n-  GrowableArray<GCMemoryManager*> memory_managers();\n-  GrowableArray<MemoryPool*> memory_pools();\n-  MemoryUsage memory_usage();\n+  ShenandoahMonitoringSupport* monitoring_support()          { return _monitoring_support;    }\n+  GCMemoryManager* cycle_memory_manager()                    { return &_cycle_memory_manager; }\n+  GCMemoryManager* stw_memory_manager()                      { return &_stw_memory_manager;   }\n+  SoftRefPolicy* soft_ref_policy()                  override { return &_soft_ref_policy;      }\n+\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n+  MemoryUsage memory_usage() override;\n@@ -472,2 +473,1 @@\n-  AdaptiveSizePolicy* size_policy() shenandoah_not_implemented_return(NULL);\n-  bool is_maximal_no_gc() const shenandoah_not_implemented_return(false);\n+  bool is_maximal_no_gc() const override shenandoah_not_implemented_return(false);\n@@ -475,1 +475,1 @@\n-  bool is_in(const void* p) const;\n+  bool is_in(const void* p) const override;\n@@ -477,1 +477,1 @@\n-  bool requires_barriers(stackChunkOop obj) const;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -482,2 +482,2 @@\n-  void collect(GCCause::Cause cause);\n-  void do_full_collection(bool clear_all_soft_refs);\n+  void collect(GCCause::Cause cause) override;\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -488,1 +488,1 @@\n-  bool print_location(outputStream* st, void* addr) const;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -491,1 +491,1 @@\n-  void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -493,1 +493,1 @@\n-  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint workers);\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint workers) override;\n@@ -496,1 +496,1 @@\n-  void keep_alive(oop obj);\n+  void keep_alive(oop obj) override;\n@@ -501,2 +501,2 @@\n-  void safepoint_synchronize_begin();\n-  void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -507,3 +507,3 @@\n-  void register_nmethod(nmethod* nm);\n-  void unregister_nmethod(nmethod* nm);\n-  void verify_nmethod(nmethod* nm) {}\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override {}\n@@ -515,4 +515,2 @@\n-  bool supports_object_pinning() const { return true; }\n-\n-  oop pin_object(JavaThread* thread, oop obj);\n-  void unpin_object(JavaThread* thread, oop obj);\n+  void pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n@@ -526,1 +524,1 @@\n-  bool uses_stack_watermark_barrier() const { return true; }\n+  bool uses_stack_watermark_barrier() const override { return true; }\n@@ -538,1 +536,1 @@\n-  HeapWord* mem_allocate(size_t size, bool* what);\n+  HeapWord* mem_allocate(size_t size, bool* what) override;\n@@ -541,1 +539,1 @@\n-                                               Metaspace::MetadataType mdtype);\n+                                               Metaspace::MetadataType mdtype) override;\n@@ -545,5 +543,5 @@\n-  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);\n-  size_t tlab_capacity(Thread *thr) const;\n-  size_t unsafe_max_tlab_alloc(Thread *thread) const;\n-  size_t max_tlab_size() const;\n-  size_t tlab_used(Thread* ignored) const;\n+  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) override;\n+  size_t tlab_capacity(Thread *thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread *thread) const override;\n+  size_t max_tlab_size() const override;\n+  size_t tlab_used(Thread* ignored) const override;\n@@ -551,1 +549,1 @@\n-  void ensure_parsability(bool retire_labs);\n+  void ensure_parsability(bool retire_labs) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":51,"deletions":53,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-    \/\/ That is why we must check both ProfileInterpreter and mdo != NULL.\n+    \/\/ That is why we must check both ProfileInterpreter and mdo != nullptr.\n@@ -139,1 +139,1 @@\n-    if (mdo != NULL) {\n+    if (mdo != nullptr) {\n@@ -187,1 +187,1 @@\n-  assert(result != NULL || is_fast_aldc, \"null result only valid for fast_aldc\");\n+  assert(result != nullptr || is_fast_aldc, \"null result only valid for fast_aldc\");\n@@ -197,2 +197,2 @@\n-      oop coop = m->constants()->resolved_references()->obj_at(rindex);\n-      oop roop = (result == NULL ? Universe::the_null_sentinel() : result);\n+      oop coop = m->constants()->resolved_reference_at(rindex);\n+      oop roop = (result == nullptr ? Universe::the_null_sentinel() : result);\n@@ -318,1 +318,1 @@\n-    if (trap_mdo == NULL) {\n+    if (trap_mdo == nullptr) {\n@@ -331,1 +331,1 @@\n-    if (trap_mdo != NULL) {\n+    if (trap_mdo != nullptr) {\n@@ -507,1 +507,1 @@\n-    assert(h_exception.not_null(), \"NULL exceptions should be handled by athrow\");\n+    assert(h_exception.not_null(), \"null exceptions should be handled by athrow\");\n@@ -550,1 +550,1 @@\n-  if (EnableJVMCI && h_method->method_data() != NULL) {\n+  if (EnableJVMCI && h_method->method_data() != nullptr) {\n@@ -552,2 +552,2 @@\n-    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, NULL);\n-    if (pdata != NULL && pdata->is_BitData()) {\n+    ProfileData* pdata = h_method->method_data()->allocate_bci_to_data(current_bci, nullptr);\n+    if (pdata != nullptr && pdata->is_BitData()) {\n@@ -566,2 +566,2 @@\n-  address continuation = NULL;\n-  address handler_pc = NULL;\n+  address continuation = nullptr;\n+  address handler_pc = nullptr;\n@@ -591,1 +591,1 @@\n-    JvmtiExport::notice_unwind_due_to_exception(current, h_method(), handler_pc, h_exception(), (handler_pc != NULL));\n+    JvmtiExport::notice_unwind_due_to_exception(current, h_method(), handler_pc, h_exception(), (handler_pc != nullptr));\n@@ -618,1 +618,1 @@\n-  assert(missingMethod != NULL, \"sanity\");\n+  assert(missingMethod != nullptr, \"sanity\");\n@@ -644,2 +644,2 @@\n-               recvKlass ? recvKlass->external_name() : \"NULL\",\n-               interfaceKlass ? interfaceKlass->external_name() : \"NULL\");\n+               recvKlass ? recvKlass->external_name() : \"nullptr\",\n+               interfaceKlass ? interfaceKlass->external_name() : \"nullptr\");\n@@ -752,1 +752,1 @@\n-         \"must be NULL or an object\");\n+         \"must be null or an object\");\n@@ -755,1 +755,1 @@\n-         \"must be NULL or an object\");\n+         \"must be null or an object\");\n@@ -776,1 +776,1 @@\n-  elem->set_obj(NULL);\n+  elem->set_obj(nullptr);\n@@ -793,2 +793,2 @@\n-  assert(exception() != NULL, \"vm result should be set\");\n-  current->set_vm_result(NULL); \/\/ clear vm result before continuing (may cause memory leaks and assert failures)\n+  assert(exception() != nullptr, \"vm result should be set\");\n+  current->set_vm_result(nullptr); \/\/ clear vm result before continuing (may cause memory leaks and assert failures)\n@@ -818,1 +818,1 @@\n-  Handle receiver(current, NULL);\n+  Handle receiver(current, nullptr);\n@@ -1003,2 +1003,2 @@\n-  assert(branch_bcp != NULL || nm == NULL, \"always returns null for non OSR requests\");\n-  if (branch_bcp != NULL && nm != NULL) {\n+  assert(branch_bcp != nullptr || nm == nullptr, \"always returns null for non OSR requests\");\n+  if (branch_bcp != nullptr && nm != nullptr) {\n@@ -1015,1 +1015,1 @@\n-    if (nm != NULL && bs_nm != NULL) {\n+    if (nm != nullptr && bs_nm != nullptr) {\n@@ -1018,1 +1018,1 @@\n-        nm = NULL;\n+        nm = nullptr;\n@@ -1022,1 +1022,1 @@\n-  if (nm != NULL && current->is_interp_only_mode()) {\n+  if (nm != nullptr && current->is_interp_only_mode()) {\n@@ -1028,1 +1028,1 @@\n-    nm = NULL;\n+    nm = nullptr;\n@@ -1032,1 +1032,1 @@\n-    if (nm != NULL) {\n+    if (nm != nullptr) {\n@@ -1050,2 +1050,2 @@\n-  const int branch_bci = branch_bcp != NULL ? method->bci_from(branch_bcp) : InvocationEntryBci;\n-  const int bci = branch_bcp != NULL ? method->bci_from(last_frame.bcp()) : InvocationEntryBci;\n+  const int branch_bci = branch_bcp != nullptr ? method->bci_from(branch_bcp) : InvocationEntryBci;\n+  const int bci = branch_bcp != nullptr ? method->bci_from(last_frame.bcp()) : InvocationEntryBci;\n@@ -1053,1 +1053,1 @@\n-  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, NULL, CHECK_NULL);\n+  nmethod* osr_nm = CompilationPolicy::event(method, method, branch_bci, bci, CompLevel_none, nullptr, CHECK_NULL);\n@@ -1056,1 +1056,1 @@\n-  if (osr_nm != NULL && bs_nm != NULL) {\n+  if (osr_nm != nullptr && bs_nm != nullptr) {\n@@ -1058,1 +1058,1 @@\n-      osr_nm = NULL;\n+      osr_nm = nullptr;\n@@ -1068,1 +1068,1 @@\n-  if (mdo == NULL)  return 0;\n+  if (mdo == nullptr)  return 0;\n@@ -1077,1 +1077,1 @@\n-  assert(mdo != NULL, \"must not be null\");\n+  assert(mdo != nullptr, \"must not be null\");\n@@ -1115,1 +1115,1 @@\n-  guarantee(data != NULL, \"profile data must be valid\");\n+  guarantee(data != nullptr, \"profile data must be valid\");\n@@ -1173,1 +1173,1 @@\n-  bool is_static = (obj == NULL);\n+  bool is_static = (obj == nullptr);\n@@ -1212,1 +1212,1 @@\n-  bool is_static = (obj == NULL);\n+  bool is_static = (obj == nullptr);\n@@ -1277,2 +1277,2 @@\n-  if (handler_blob == NULL) {\n-    return NULL;\n+  if (handler_blob == nullptr) {\n+    return nullptr;\n@@ -1287,1 +1287,1 @@\n-  if (_fingerprints != NULL) {\n+  if (_fingerprints != nullptr) {\n@@ -1290,1 +1290,1 @@\n-  if (set_handler_blob() == NULL) {\n+  if (set_handler_blob() == nullptr) {\n@@ -1309,1 +1309,1 @@\n-  if (handler != NULL) {\n+  if (handler != nullptr) {\n@@ -1319,1 +1319,1 @@\n-  if (method->signature_handler() == NULL) {\n+  if (method->signature_handler() == nullptr) {\n@@ -1342,1 +1342,1 @@\n-        if (handler == NULL) {\n+        if (handler == nullptr) {\n@@ -1405,1 +1405,1 @@\n-    if (_handlers != NULL) {\n+    if (_handlers != nullptr) {\n@@ -1449,5 +1449,5 @@\n-BufferBlob*              SignatureHandlerLibrary::_handler_blob = NULL;\n-address                  SignatureHandlerLibrary::_handler      = NULL;\n-GrowableArray<uint64_t>* SignatureHandlerLibrary::_fingerprints = NULL;\n-GrowableArray<address>*  SignatureHandlerLibrary::_handlers     = NULL;\n-address                  SignatureHandlerLibrary::_buffer       = NULL;\n+BufferBlob*              SignatureHandlerLibrary::_handler_blob = nullptr;\n+address                  SignatureHandlerLibrary::_handler      = nullptr;\n+GrowableArray<uint64_t>* SignatureHandlerLibrary::_fingerprints = nullptr;\n+GrowableArray<address>*  SignatureHandlerLibrary::_handlers     = nullptr;\n+address                  SignatureHandlerLibrary::_buffer       = nullptr;\n@@ -1516,1 +1516,1 @@\n-    current->set_vm_result(NULL);\n+    current->set_vm_result(nullptr);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":55,"deletions":55,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -343,2 +343,2 @@\n-        if ((obj_) == NULL) {                                                                    \\\n-          VM_JAVA_ERROR(vmSymbols::java_lang_NullPointerException(), NULL);                      \\\n+        if ((obj_) == nullptr) {                                                                    \\\n+          VM_JAVA_ERROR(vmSymbols::java_lang_NullPointerException(), nullptr);                      \\\n@@ -403,1 +403,1 @@\n-        target = NULL;                                              \\\n+        target = nullptr;                                              \\\n@@ -423,1 +423,1 @@\n-        target = NULL;                                              \\\n+        target = nullptr;                                              \\\n@@ -509,1 +509,1 @@\n-  } while (l != NULL);\n+  } while (l != nullptr);\n@@ -607,1 +607,1 @@\n-      THREAD->set_do_not_unlock();\n+      THREAD->set_do_not_unlock_if_synchronized(true);\n@@ -632,1 +632,1 @@\n-            mon->lock()->set_displaced_header(markWord::from_pointer(NULL));\n+            mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n@@ -642,1 +642,1 @@\n-      THREAD->clr_do_not_unlock();\n+      THREAD->set_do_not_unlock_if_synchronized(false);\n@@ -720,1 +720,1 @@\n-      assert(entry->obj() == NULL, \"Frame manager didn't allocate the monitor\");\n+      assert(entry->obj() == nullptr, \"Frame manager didn't allocate the monitor\");\n@@ -731,1 +731,1 @@\n-          entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n+          entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n@@ -787,1 +787,1 @@\n-          SET_STACK_OBJECT(NULL, 0);\n+          SET_STACK_OBJECT(nullptr, 0);\n@@ -1370,1 +1370,1 @@\n-          int skip = (!(STACK_OBJECT(-1) == NULL))                           \\\n+          int skip = (!(STACK_OBJECT(-1) == nullptr))                           \\\n@@ -1380,1 +1380,1 @@\n-          int skip = ((STACK_OBJECT(-1) == NULL))                            \\\n+          int skip = ((STACK_OBJECT(-1) == nullptr))                            \\\n@@ -1588,1 +1588,1 @@\n-          if (rhsObject != NULL) {\n+          if (rhsObject != nullptr) {\n@@ -1644,1 +1644,1 @@\n-        BasicObjectLock* entry = NULL;\n+        BasicObjectLock* entry = nullptr;\n@@ -1646,1 +1646,1 @@\n-          if (most_recent->obj() == NULL) entry = most_recent;\n+          if (most_recent->obj() == nullptr) entry = most_recent;\n@@ -1650,1 +1650,1 @@\n-        if (entry != NULL) {\n+        if (entry != nullptr) {\n@@ -1661,1 +1661,1 @@\n-              entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n+              entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n@@ -1688,1 +1688,1 @@\n-            most_recent->set_obj(NULL);\n+            most_recent->set_obj(nullptr);\n@@ -1693,1 +1693,1 @@\n-            if (header.to_pointer() != NULL || call_vm) {\n+            if (header.to_pointer() != nullptr || call_vm) {\n@@ -1991,1 +1991,1 @@\n-            if (result != NULL) {\n+            if (result != nullptr) {\n@@ -2025,1 +2025,1 @@\n-        THREAD->set_vm_result(NULL);\n+        THREAD->set_vm_result(nullptr);\n@@ -2037,1 +2037,1 @@\n-        THREAD->set_vm_result(NULL);\n+        THREAD->set_vm_result(nullptr);\n@@ -2054,1 +2054,1 @@\n-        THREAD->set_vm_result(NULL);\n+        THREAD->set_vm_result(nullptr);\n@@ -2058,1 +2058,1 @@\n-          if (STACK_OBJECT(-1) != NULL) {\n+          if (STACK_OBJECT(-1) != nullptr) {\n@@ -2082,1 +2082,1 @@\n-          if (STACK_OBJECT(-1) == NULL) {\n+          if (STACK_OBJECT(-1) == nullptr) {\n@@ -2132,2 +2132,2 @@\n-              oop result = constants->resolved_references()->obj_at(index);\n-              if (result == NULL) {\n+              oop result = constants->resolved_reference_at(index);\n+              if (result == nullptr) {\n@@ -2136,1 +2136,1 @@\n-                THREAD->set_vm_result(NULL);\n+                THREAD->set_vm_result(nullptr);\n@@ -2153,1 +2153,1 @@\n-            THREAD->set_vm_result(NULL);\n+            THREAD->set_vm_result(nullptr);\n@@ -2237,2 +2237,2 @@\n-        oop result = constants->resolved_references()->obj_at(index);\n-        if (result == NULL) {\n+        oop result = constants->resolved_reference_at(index);\n+        if (result == nullptr) {\n@@ -2244,1 +2244,1 @@\n-          result = NULL;\n+          result = nullptr;\n@@ -2327,1 +2327,1 @@\n-        Method* callee = NULL;\n+        Method* callee = nullptr;\n@@ -2363,1 +2363,1 @@\n-        if (callee != NULL) {\n+        if (callee != nullptr) {\n@@ -2388,1 +2388,1 @@\n-               scan->interface_klass() != NULL;\n+               scan->interface_klass() != nullptr;\n@@ -2398,1 +2398,1 @@\n-          if (scan->interface_klass() == NULL) {\n+          if (scan->interface_klass() == nullptr) {\n@@ -2419,1 +2419,1 @@\n-        if (callee == NULL) {\n+        if (callee == nullptr) {\n@@ -2517,1 +2517,1 @@\n-        THREAD->set_vm_result(NULL);\n+        THREAD->set_vm_result(nullptr);\n@@ -2528,1 +2528,1 @@\n-          THREAD->set_pending_exception(except_oop, NULL, 0);\n+          THREAD->set_pending_exception(except_oop, nullptr, 0);\n@@ -2950,1 +2950,1 @@\n-    assert(except_oop() != NULL, \"No exception to process\");\n+    assert(except_oop() != nullptr, \"No exception to process\");\n@@ -2958,1 +2958,1 @@\n-    THREAD->set_vm_result(NULL);\n+    THREAD->set_vm_result(nullptr);\n@@ -2992,1 +2992,1 @@\n-    THREAD->set_pending_exception(except_oop(), NULL, 0);\n+    THREAD->set_pending_exception(except_oop(), nullptr, 0);\n@@ -3059,1 +3059,1 @@\n-    ts->set_earlyret_oop(NULL);\n+    ts->set_earlyret_oop(nullptr);\n@@ -3078,1 +3078,1 @@\n-    Handle illegal_state_oop(THREAD, NULL);\n+    Handle illegal_state_oop(THREAD, nullptr);\n@@ -3085,1 +3085,1 @@\n-    \/\/ a NULL oop in it and then overwrite the oop later as needed. This isn't\n+    \/\/ a null oop in it and then overwrite the oop later as needed. This isn't\n@@ -3103,1 +3103,1 @@\n-    if (THREAD->do_not_unlock()) {\n+    if (THREAD->do_not_unlock_if_synchronized()) {\n@@ -3108,1 +3108,1 @@\n-      THREAD->clr_do_not_unlock();\n+      THREAD->set_do_not_unlock_if_synchronized(false);\n@@ -3135,1 +3135,1 @@\n-        if (lockee != NULL) {\n+        if (lockee != nullptr) {\n@@ -3138,1 +3138,1 @@\n-          end->set_obj(NULL);\n+          end->set_obj(nullptr);\n@@ -3142,1 +3142,1 @@\n-          if (header.to_pointer() != NULL) {\n+          if (header.to_pointer() != nullptr) {\n@@ -3156,1 +3156,1 @@\n-          if (illegal_state_oop() == NULL && !suppress_error) {\n+          if (illegal_state_oop() == nullptr && !suppress_error) {\n@@ -3171,1 +3171,1 @@\n-        if (base->obj() == NULL) {\n+        if (base->obj() == nullptr) {\n@@ -3173,1 +3173,1 @@\n-          if (illegal_state_oop() == NULL && !suppress_error) {\n+          if (illegal_state_oop() == nullptr && !suppress_error) {\n@@ -3194,1 +3194,1 @@\n-          if (rcvr == NULL) {\n+          if (rcvr == nullptr) {\n@@ -3209,1 +3209,1 @@\n-            base->set_obj(NULL);\n+            base->set_obj(nullptr);\n@@ -3213,1 +3213,1 @@\n-            if (header.to_pointer() != NULL) {\n+            if (header.to_pointer() != nullptr) {\n@@ -3234,1 +3234,1 @@\n-    THREAD->clr_do_not_unlock();\n+    THREAD->set_do_not_unlock_if_synchronized(false);\n@@ -3254,1 +3254,1 @@\n-    suppress_exit_event = suppress_exit_event || illegal_state_oop() != NULL;\n+    suppress_exit_event = suppress_exit_event || illegal_state_oop() != nullptr;\n@@ -3270,2 +3270,2 @@\n-    assert(!suppress_error || (suppress_error && illegal_state_oop() == NULL), \"Error was not suppressed\");\n-    if (illegal_state_oop() != NULL || original_exception() != NULL) {\n+    assert(!suppress_error || (suppress_error && illegal_state_oop() == nullptr), \"Error was not suppressed\");\n+    if (illegal_state_oop() != nullptr || original_exception() != nullptr) {\n@@ -3274,2 +3274,2 @@\n-      if (illegal_state_oop() != NULL)\n-        THREAD->set_pending_exception(illegal_state_oop(), NULL, 0);\n+      if (illegal_state_oop() != nullptr)\n+        THREAD->set_pending_exception(illegal_state_oop(), nullptr, 0);\n@@ -3277,1 +3277,1 @@\n-        THREAD->set_pending_exception(original_exception(), NULL, 0);\n+        THREAD->set_pending_exception(original_exception(), nullptr, 0);\n@@ -3284,1 +3284,1 @@\n-      if (istate->prev() == NULL) {\n+      if (istate->prev() == nullptr) {\n@@ -3321,1 +3321,1 @@\n-  _prev_link = NULL;\n+  _prev_link = nullptr;\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":67,"deletions":67,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-  if (klass != NULL) {\n+  if (klass != nullptr) {\n@@ -80,1 +80,1 @@\n-  if (klass != NULL) {\n+  if (klass != nullptr) {\n@@ -128,1 +128,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n@@ -130,1 +130,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -140,1 +140,1 @@\n-  if (thread == NULL) {                                  \\\n+  if (thread == nullptr) {                                  \\\n@@ -151,1 +151,1 @@\n-  if (thread == NULL) {                                  \\\n+  if (thread == nullptr) {                                  \\\n@@ -159,1 +159,1 @@\n-#define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, NULL)\n+#define C2V_VMENTRY_NULL(result_type, name, signature) C2V_VMENTRY_(result_type, name, signature, nullptr)\n@@ -202,1 +202,1 @@\n-  if (flag == NULL) {\n+  if (flag == nullptr) {\n@@ -332,1 +332,1 @@\n-  oop mirror = NULL;\n+  oop mirror = nullptr;\n@@ -350,1 +350,1 @@\n-  Method* method = NULL;\n+  Method* method = nullptr;\n@@ -362,1 +362,1 @@\n-  if (method == NULL) {\n+  if (method == nullptr) {\n@@ -371,1 +371,1 @@\n-  ConstantPool* cp = NULL;\n+  ConstantPool* cp = nullptr;\n@@ -422,1 +422,1 @@\n-  assert (klass == NULL || klass->is_klass(), \"invalid read\");\n+  assert (klass == nullptr || klass->is_klass(), \"invalid read\");\n@@ -837,1 +837,1 @@\n-      \/\/ Signature polymorphic methods are already resolved, JVMCI just returns NULL in this case.\n+      \/\/ Signature polymorphic methods are already resolved, JVMCI just returns null in this case.\n@@ -866,1 +866,1 @@\n-    \/\/ Return NULL if there was a problem with lookup (uninitialized class, etc.)\n+    \/\/ Return null if there was a problem with lookup (uninitialized class, etc.)\n@@ -940,1 +940,1 @@\n-  CodeBlob* cb = NULL;\n+  CodeBlob* cb = nullptr;\n@@ -980,1 +980,1 @@\n-    assert(cb == NULL, \"should be\");\n+    assert(cb == nullptr, \"should be\");\n@@ -1009,1 +1009,1 @@\n-  if (installedCode == NULL) {\n+  if (installedCode == nullptr) {\n@@ -1015,2 +1015,2 @@\n-  if (cb == NULL) {\n-    return NULL;\n+  if (cb == nullptr) {\n+    return nullptr;\n@@ -1030,1 +1030,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1054,1 +1054,1 @@\n-  if (nm == NULL || !nm->is_in_use()) {\n+  if (nm == nullptr || !nm->is_in_use()) {\n@@ -1067,1 +1067,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1097,1 +1097,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1137,1 +1137,1 @@\n-  if (mcs != NULL) {\n+  if (mcs != nullptr) {\n@@ -1143,1 +1143,1 @@\n-  if (code != NULL) {\n+  if (code != nullptr) {\n@@ -1148,1 +1148,1 @@\n-  if (method_data == NULL) {\n+  if (method_data == nullptr) {\n@@ -1197,1 +1197,1 @@\n-  return mdo != NULL && mdo->is_mature();\n+  return mdo != nullptr && mdo->is_mature();\n@@ -1202,1 +1202,1 @@\n-  return method->lookup_osr_nmethod_for(entry_bci, comp_level, true) != NULL;\n+  return method->lookup_osr_nmethod_for(entry_bci, comp_level, true) != nullptr;\n@@ -1224,1 +1224,1 @@\n-    Method* resolved_method = NULL;\n+    Method* resolved_method = nullptr;\n@@ -1240,1 +1240,1 @@\n-  if (resolved_methods == NULL) {\n+  if (resolved_methods == nullptr) {\n@@ -1244,1 +1244,1 @@\n-  assert(method != NULL, \"method should not be NULL\");\n+  assert(method != nullptr, \"method should not be null\");\n@@ -1262,1 +1262,1 @@\n-  Klass* recvrKlass = receiver.is_null() ? (Klass*)NULL : receiver->klass();\n+  Klass* recvrKlass = receiver.is_null() ? (Klass*)nullptr : receiver->klass();\n@@ -1295,1 +1295,1 @@\n- * Used by c2v_iterateFrames. Returns an array of any unallocated scope objects or NULL if none.\n+ * Used by c2v_iterateFrames. Returns an array of any unallocated scope objects or null if none.\n@@ -1298,1 +1298,1 @@\n-  GrowableArray<ScopeValue*>* unallocated = NULL;\n+  GrowableArray<ScopeValue*>* unallocated = nullptr;\n@@ -1302,1 +1302,1 @@\n-      if (unallocated == NULL) {\n+      if (unallocated == nullptr) {\n@@ -1314,1 +1314,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1325,1 +1325,1 @@\n-  GrowableArray<Method*>* resolved_methods = NULL;\n+  GrowableArray<Method*>* resolved_methods = nullptr;\n@@ -1332,1 +1332,1 @@\n-    compiledVFrame* prev_cvf = NULL;\n+    compiledVFrame* prev_cvf = nullptr;\n@@ -1340,1 +1340,1 @@\n-      if (methods == NULL || matches(methods, method, &resolved_methods, &matched_jvmci_method, THREAD, JVMCIENV)) {\n+      if (methods == nullptr || matches(methods, method, &resolved_methods, &matched_jvmci_method, THREAD, JVMCIENV)) {\n@@ -1346,1 +1346,1 @@\n-        if (prev_cvf != NULL && prev_cvf->frame_pointer()->id() == frame_id) {\n+        if (prev_cvf != nullptr && prev_cvf->frame_pointer()->id() == frame_id) {\n@@ -1353,1 +1353,1 @@\n-        StackValueCollection* locals = NULL;\n+        StackValueCollection* locals = nullptr;\n@@ -1361,1 +1361,1 @@\n-          if (scope != NULL && scope->objects() != NULL) {\n+          if (scope != nullptr && scope->objects() != nullptr) {\n@@ -1364,1 +1364,1 @@\n-            GrowableArray<ScopeValue*>* objects = NULL;\n+            GrowableArray<ScopeValue*>* objects = nullptr;\n@@ -1372,1 +1372,1 @@\n-            if (objects != NULL) {\n+            if (objects != nullptr) {\n@@ -1437,1 +1437,1 @@\n-        if (result.get_oop() != NULL) {\n+        if (result.get_oop() != nullptr) {\n@@ -1442,2 +1442,2 @@\n-          if (resolved_methods != NULL && JNIHandles::resolve(match_methods) != JNIHandles::resolve(initial_methods)) {\n-            resolved_methods = NULL;\n+          if (resolved_methods != nullptr && JNIHandles::resolve(match_methods) != JNIHandles::resolve(initial_methods)) {\n+            resolved_methods = nullptr;\n@@ -1449,1 +1449,1 @@\n-          prev_cvf = NULL;\n+          prev_cvf = nullptr;\n@@ -1458,1 +1458,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1506,1 +1506,1 @@\n-      vmassert(cp_cache_entry->appendix_if_resolved(cp) == NULL, \"!\");\n+      vmassert(cp_cache_entry->appendix_if_resolved(cp) == nullptr, \"!\");\n@@ -1598,1 +1598,1 @@\n-  assert (virtualFrames->at(last_frame_number)->scope() != NULL,\"invalid scope\");\n+  assert (virtualFrames->at(last_frame_number)->scope() != nullptr,\"invalid scope\");\n@@ -1601,1 +1601,1 @@\n-  if (objects == NULL) {\n+  if (objects == nullptr) {\n@@ -1614,1 +1614,1 @@\n-    if (locals != NULL) {\n+    if (locals != nullptr) {\n@@ -1627,1 +1627,1 @@\n-    if (expressions != NULL) {\n+    if (expressions != nullptr) {\n@@ -1640,1 +1640,1 @@\n-    if (monitors != NULL) {\n+    if (monitors != nullptr) {\n@@ -1648,1 +1648,1 @@\n-  JVMCIENV->set_HotSpotStackFrameReference_localIsVirtual(hs_frame, NULL);\n+  JVMCIENV->set_HotSpotStackFrameReference_localIsVirtual(hs_frame, nullptr);\n@@ -1739,1 +1739,1 @@\n-  if (component_klass != NULL) {\n+  if (component_klass != nullptr) {\n@@ -1772,1 +1772,1 @@\n-  if (bytecode_frame_handle == NULL) {\n+  if (bytecode_frame_handle == nullptr) {\n@@ -1831,1 +1831,1 @@\n-  return (StringTable::lookup(name, len) != NULL);\n+  return (StringTable::lookup(name, len) != nullptr);\n@@ -1836,1 +1836,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -1843,1 +1843,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1850,1 +1850,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -1856,1 +1856,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -1861,2 +1861,2 @@\n-  Klass* box_klass = NULL;\n-  Symbol* box_signature = NULL;\n+  Klass* box_klass = nullptr;\n+  Symbol* box_signature = nullptr;\n@@ -2059,1 +2059,1 @@\n-  \/\/ asConstant will throw an NPE if a constant contains NULL\n+  \/\/ asConstant will throw an NPE if a constant contains null\n@@ -2076,1 +2076,1 @@\n-  if (object == NULL || klass == nullptr) {\n+  if (object == nullptr || klass == nullptr) {\n@@ -2105,1 +2105,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -2120,1 +2120,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2125,1 +2125,1 @@\n-  if (object == NULL) {\n+  if (object == nullptr) {\n@@ -2136,1 +2136,1 @@\n-  if (x == NULL || y == NULL) {\n+  if (x == nullptr || y == nullptr) {\n@@ -2154,1 +2154,1 @@\n-  if (x == NULL) {\n+  if (x == nullptr) {\n@@ -2166,1 +2166,1 @@\n-  if (x == NULL) {\n+  if (x == nullptr) {\n@@ -2174,1 +2174,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -2201,1 +2201,1 @@\n-  return NULL;;\n+  return nullptr;;\n@@ -2241,1 +2241,1 @@\n-    if (sl_handle == NULL) {\n+    if (sl_handle == nullptr) {\n@@ -2246,1 +2246,1 @@\n-  if (mirror == NULL) {\n+  if (mirror == nullptr) {\n@@ -2250,1 +2250,1 @@\n-  if (klass == NULL || !klass->is_instance_klass()) {\n+  if (klass == nullptr || !klass->is_instance_klass()) {\n@@ -2267,1 +2267,1 @@\n-      guarantee(pure_name != NULL, \"Illegal native method name encountered\");\n+      guarantee(pure_name != nullptr, \"Illegal native method name encountered\");\n@@ -2274,1 +2274,1 @@\n-      if (entry == NULL) {\n+      if (entry == nullptr) {\n@@ -2278,1 +2278,1 @@\n-        guarantee(long_name != NULL, \"Illegal native method name encountered\");\n+        guarantee(long_name != nullptr, \"Illegal native method name encountered\");\n@@ -2285,1 +2285,1 @@\n-        if (entry == NULL) {\n+        if (entry == nullptr) {\n@@ -2330,1 +2330,1 @@\n-  if (thread == NULL) {\n+  if (thread == nullptr) {\n@@ -2489,1 +2489,1 @@\n-  if (obj_handle == NULL) {\n+  if (obj_handle == nullptr) {\n@@ -2516,1 +2516,1 @@\n-      if (nm != NULL) {\n+      if (nm != nullptr) {\n@@ -2518,1 +2518,1 @@\n-        if (data != NULL) {\n+        if (data != nullptr) {\n@@ -2522,1 +2522,1 @@\n-          if (nmethod_mirror != NULL) {\n+          if (nmethod_mirror != nullptr) {\n@@ -2535,1 +2535,1 @@\n-      const char* cstring = name_string.is_null() ? NULL : thisEnv->as_utf8_string(name_string);\n+      const char* cstring = name_string.is_null() ? nullptr : thisEnv->as_utf8_string(name_string);\n@@ -2541,1 +2541,1 @@\n-      } else if (nm == NULL) {\n+      } else if (nm == nullptr) {\n@@ -2549,1 +2549,1 @@\n-          if (data == NULL) {\n+          if (data == nullptr) {\n@@ -2552,1 +2552,1 @@\n-          if (data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) != NULL) {\n+          if (data->get_nmethod_mirror(nm, \/* phantom_ref *\/ false) != nullptr) {\n@@ -2577,1 +2577,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -2596,2 +2596,2 @@\n-  if (cb == NULL) {\n-    return NULL;\n+  if (cb == nullptr) {\n+    return nullptr;\n@@ -2646,1 +2646,1 @@\n-  for (FailedSpeculation* fs = head; fs != NULL; fs = fs->next()) {\n+  for (FailedSpeculation* fs = head; fs != nullptr; fs = fs->next()) {\n@@ -2650,2 +2650,2 @@\n-  JVMCIObjectArray current_array = NULL;\n-  if (current != NULL) {\n+  JVMCIObjectArray current_array = nullptr;\n+  if (current != nullptr) {\n@@ -2662,1 +2662,1 @@\n-    assert(fs != NULL, \"npe\");\n+    assert(fs != nullptr, \"npe\");\n@@ -2678,1 +2678,1 @@\n-  if (method_data == NULL) {\n+  if (method_data == nullptr) {\n@@ -2695,1 +2695,1 @@\n-  return FailedSpeculation::add_failed_speculation(NULL, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);\n+  return FailedSpeculation::add_failed_speculation(nullptr, (FailedSpeculation**)(address) failed_speculations_address, (address) speculation, speculation_len);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":102,"deletions":102,"binary":false,"changes":204,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,1 +163,1 @@\n-  nonstatic_field(InstanceKlass,               _misc_status._flags,                           u2)                                    \\\n+  nonstatic_field(InstanceKlass,               _misc_flags._flags,                            u2)                                    \\\n@@ -271,2 +271,0 @@\n-  static_field(os,                             _polling_page,                                 address)                               \\\n-                                                                                                                                     \\\n@@ -655,2 +653,2 @@\n-  declare_constant(InstanceKlassMiscStatus::_misc_has_nonstatic_concrete_methods)   \\\n-  declare_constant(InstanceKlassMiscStatus::_misc_declares_nonstatic_concrete_methods) \\\n+  declare_constant(InstanceKlassFlags::_misc_has_nonstatic_concrete_methods)   \\\n+  declare_constant(InstanceKlassFlags::_misc_declares_nonstatic_concrete_methods) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,2 @@\n-  _non_class_space_arena(NULL),\n-  _class_space_arena(NULL)\n+  _non_class_space_arena(nullptr),\n+  _class_space_arena(nullptr)\n@@ -115,1 +115,1 @@\n-\/\/ and allocate. Returns NULL if failure. Used during Metaspace GC.\n+\/\/ and allocate. Returns null if failure. Used during Metaspace GC.\n@@ -132,1 +132,1 @@\n-  } while (!incremented && res == NULL && can_retry);\n+  } while (!incremented && res == nullptr && can_retry);\n@@ -158,1 +158,1 @@\n-  if (non_class_space_arena() != NULL) {\n+  if (non_class_space_arena() != nullptr) {\n@@ -161,1 +161,1 @@\n-  if (class_space_arena() != NULL) {\n+  if (class_space_arena() != nullptr) {\n@@ -168,1 +168,1 @@\n-  if (non_class_space_arena() != NULL) {\n+  if (non_class_space_arena() != nullptr) {\n@@ -171,1 +171,1 @@\n-  if (class_space_arena() != NULL) {\n+  if (class_space_arena() != nullptr) {\n@@ -184,2 +184,2 @@\n-  if (non_class_space_arena() != NULL) {\n-    non_class_space_arena()->usage_numbers(&used_nc, NULL, &cap_nc);\n+  if (non_class_space_arena() != nullptr) {\n+    non_class_space_arena()->usage_numbers(&used_nc, nullptr, &cap_nc);\n@@ -187,2 +187,2 @@\n-  if (class_space_arena() != NULL) {\n-    class_space_arena()->usage_numbers(&used_c, NULL, &cap_c);\n+  if (class_space_arena() != nullptr) {\n+    class_space_arena()->usage_numbers(&used_c, nullptr, &cap_c);\n@@ -190,1 +190,1 @@\n-  if (p_used_bytes != NULL) {\n+  if (p_used_bytes != nullptr) {\n@@ -193,1 +193,1 @@\n-  if (p_capacity_bytes != NULL) {\n+  if (p_capacity_bytes != nullptr) {\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -339,1 +339,1 @@\n-    if (can_retry != NULL) {\n+    if (can_retry != nullptr) {\n@@ -345,1 +345,1 @@\n-  if (can_retry != NULL) {\n+  if (can_retry != nullptr) {\n@@ -354,1 +354,1 @@\n-  if (new_cap_until_GC != NULL) {\n+  if (new_cap_until_GC != nullptr) {\n@@ -357,1 +357,1 @@\n-  if (old_cap_until_GC != NULL) {\n+  if (old_cap_until_GC != nullptr) {\n@@ -538,1 +538,1 @@\n-const MetaspaceTracer* Metaspace::_tracer = NULL;\n+const MetaspaceTracer* Metaspace::_tracer = nullptr;\n@@ -541,1 +541,1 @@\n-  return metaspace::MetaspaceContext::context_nonclass() != NULL\n+  return metaspace::MetaspaceContext::context_nonclass() != nullptr\n@@ -548,1 +548,1 @@\n-  if (VirtualSpaceList::vslist_class() != NULL) {\n+  if (VirtualSpaceList::vslist_class() != nullptr) {\n@@ -581,1 +581,1 @@\n-  return MetaspaceContext::context_class() != NULL;\n+  return MetaspaceContext::context_class() != nullptr;\n@@ -616,1 +616,1 @@\n-    {  NULL, NULL, 0 }\n+    {  nullptr, nullptr, 0 }\n@@ -619,1 +619,1 @@\n-  for (int i = 0; search_ranges[i].from != NULL; i ++) {\n+  for (int i = 0; search_ranges[i].from != nullptr; i ++) {\n@@ -640,1 +640,1 @@\n-  return ReservedSpace(size, Metaspace::reserve_alignment(), os::vm_page_size(), (char*)NULL);\n+  return ReservedSpace(size, Metaspace::reserve_alignment(), os::vm_page_size(), (char*)nullptr);\n@@ -764,1 +764,1 @@\n-    address base = NULL;\n+    address base = nullptr;\n@@ -799,1 +799,1 @@\n-      if (base != NULL) {\n+      if (base != nullptr) {\n@@ -835,3 +835,3 @@\n-  \/\/ VM does not distinguish between \"narrow 0 as in NULL\" and \"narrow 0 as in start\n-  \/\/  of ccs\". See CompressedKlassPointers::decode().\n-  \/\/ Before JEP 387 that did not happen due to the fact that every Metachunk\n+  \/\/ VM does not distinguish between \"narrow 0 as in null\" and \"narrow 0 as in start\n+  \/\/  of ccs\".\n+  \/\/ Before Elastic Metaspace that did not happen due to the fact that every Metachunk\n@@ -885,1 +885,1 @@\n-\/\/ This version of Metaspace::allocate does not throw OOM but simply returns NULL, and\n+\/\/ This version of Metaspace::allocate does not throw OOM but simply returns null, and\n@@ -893,1 +893,1 @@\n-  assert(loader_data != NULL, \"Should never pass around a NULL loader_data. \"\n+  assert(loader_data != nullptr, \"Should never pass around a nullptr loader_data. \"\n@@ -904,1 +904,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -919,1 +919,1 @@\n-    return NULL;  \/\/ caller does a CHECK_NULL too\n+    return nullptr;  \/\/ caller does a CHECK_NULL too\n@@ -924,1 +924,1 @@\n-  if (result == NULL) {\n+  if (result == nullptr) {\n@@ -936,1 +936,1 @@\n-    if (result == NULL) {\n+    if (result == nullptr) {\n@@ -939,1 +939,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -961,1 +961,1 @@\n-      if (loader_data->metaspace_or_null() != NULL) {\n+      if (loader_data->metaspace_or_null() != nullptr) {\n@@ -1009,1 +1009,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -1020,1 +1020,1 @@\n-    if (cm != NULL) {\n+    if (cm != nullptr) {\n@@ -1025,1 +1025,1 @@\n-      if (cm != NULL) {\n+      if (cm != nullptr) {\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":28,"deletions":28,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-  \/\/ NULL on failure.\n+  \/\/ null on failure.\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  MetaWord* p = NULL;\n+  MetaWord* p = nullptr;\n@@ -52,1 +52,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeBlocks.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-    assert(ptr != NULL, \"Should have worked\");\n+    assert(ptr != nullptr, \"Should have worked\");\n@@ -95,2 +95,2 @@\n-  if (c == NULL) {\n-    return NULL;\n+  if (c == nullptr) {\n+    return nullptr;\n@@ -105,1 +105,1 @@\n-  if (_fbl == NULL) {\n+  if (_fbl == nullptr) {\n@@ -119,1 +119,1 @@\n-  _fbl(NULL),\n+  _fbl(nullptr),\n@@ -123,1 +123,1 @@\n-  , _first_fence(NULL)\n+  , _first_fence(nullptr)\n@@ -145,1 +145,1 @@\n-  Metachunk* c2 = NULL;\n+  Metachunk* c2 = nullptr;\n@@ -150,2 +150,2 @@\n-    DEBUG_ONLY(c->set_prev(NULL);)\n-    DEBUG_ONLY(c->set_next(NULL);)\n+    DEBUG_ONLY(c->set_prev(nullptr);)\n+    DEBUG_ONLY(c->set_next(nullptr);)\n@@ -224,1 +224,1 @@\n-\/\/ At any point, if we hit a commit limit, we return NULL.\n+\/\/ At any point, if we hit a commit limit, we return null.\n@@ -229,1 +229,1 @@\n-  MetaWord* p = NULL;\n+  MetaWord* p = nullptr;\n@@ -233,1 +233,1 @@\n-  if (_fbl != NULL && !_fbl->is_empty()) {\n+  if (_fbl != nullptr && !_fbl->is_empty()) {\n@@ -235,1 +235,1 @@\n-    if (p != NULL) {\n+    if (p != nullptr) {\n@@ -251,1 +251,1 @@\n-  if (p != NULL && Settings::use_allocation_guard()) {\n+  if (p != nullptr && Settings::use_allocation_guard()) {\n@@ -254,1 +254,1 @@\n-    if (guard != NULL) {\n+    if (guard != nullptr) {\n@@ -275,1 +275,1 @@\n-  MetaWord* p = NULL;\n+  MetaWord* p = nullptr;\n@@ -279,1 +279,1 @@\n-  if (current_chunk() != NULL) {\n+  if (current_chunk() != nullptr) {\n@@ -307,1 +307,1 @@\n-      assert(p != NULL, \"Allocation from chunk failed.\");\n+      assert(p != nullptr, \"Allocation from chunk failed.\");\n@@ -311,1 +311,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -313,1 +313,1 @@\n-    assert(current_chunk() == NULL ||\n+    assert(current_chunk() == nullptr ||\n@@ -317,1 +317,1 @@\n-    if (new_chunk != NULL) {\n+    if (new_chunk != nullptr) {\n@@ -327,1 +327,1 @@\n-      if (current_chunk() != NULL) {\n+      if (current_chunk() != nullptr) {\n@@ -336,1 +336,1 @@\n-      assert(p != NULL, \"Allocation from chunk failed.\");\n+      assert(p != nullptr, \"Allocation from chunk failed.\");\n@@ -342,1 +342,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -351,2 +351,2 @@\n-  if (p == NULL) {\n-    UL(info, \"allocation failed, returned NULL.\");\n+  if (p == nullptr) {\n+    UL(info, \"allocation failed, returned nullptr.\");\n@@ -366,1 +366,1 @@\n-  assert(current_chunk() != NULL, \"stray deallocation?\");\n+  assert(current_chunk() != nullptr, \"stray deallocation?\");\n@@ -391,1 +391,1 @@\n-  for (const Metachunk* c = _chunks.first(); c != NULL; c = c->next()) {\n+  for (const Metachunk* c = _chunks.first(); c != nullptr; c = c->next()) {\n@@ -405,1 +405,1 @@\n-  if (_fbl != NULL) {\n+  if (_fbl != nullptr) {\n@@ -418,1 +418,1 @@\n-  for (const Metachunk* c = _chunks.first(); c != NULL; c = c->next()) {\n+  for (const Metachunk* c = _chunks.first(); c != nullptr; c = c->next()) {\n@@ -423,1 +423,1 @@\n-  if (p_used_words != NULL) {\n+  if (p_used_words != nullptr) {\n@@ -426,1 +426,1 @@\n-  if (p_committed_words != NULL) {\n+  if (p_committed_words != nullptr) {\n@@ -429,1 +429,1 @@\n-  if (p_capacity_words != NULL) {\n+  if (p_capacity_words != nullptr) {\n@@ -438,1 +438,1 @@\n-  assert(_growth_policy != NULL && _chunk_manager != NULL, \"Sanity\");\n+  assert(_growth_policy != nullptr && _chunk_manager != nullptr, \"Sanity\");\n@@ -440,1 +440,1 @@\n-  if (_fbl != NULL) {\n+  if (_fbl != nullptr) {\n@@ -452,1 +452,1 @@\n-  for (const Fence* f = _first_fence; f != NULL; f = f->next()) {\n+  for (const Fence* f = _first_fence; f != nullptr; f = f->next()) {\n@@ -465,1 +465,1 @@\n-  assert(p != NULL && word_size > 0, \"Sanity\");\n+  assert(p != nullptr && word_size > 0, \"Sanity\");\n@@ -467,1 +467,1 @@\n-  for (const Metachunk* c = _chunks.first(); c != NULL && !found; c = c->next()) {\n+  for (const Metachunk* c = _chunks.first(); c != nullptr && !found; c = c->next()) {\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":39,"deletions":39,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-  \/\/ At any point, if we hit a commit limit, we return NULL.\n+  \/\/ At any point, if we hit a commit limit, we return null.\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-  const char* s = NULL;\n+  const char* s = nullptr;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  const char* s = NULL;\n+  const char* s = nullptr;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceReporter.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-  _context(NULL),\n+  _context(nullptr),\n@@ -98,1 +98,1 @@\n-  MetaspaceArena* arena = NULL;\n+  MetaspaceArena* arena = nullptr;\n@@ -113,1 +113,1 @@\n-  if (_context != NULL) {\n+  if (_context != nullptr) {\n","filename":"src\/hotspot\/share\/memory\/metaspace\/testHelpers.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-ReservedSpace::ReservedSpace() : _base(NULL), _size(0), _noaccess_prefix(0),\n+ReservedSpace::ReservedSpace() : _base(nullptr), _size(0), _noaccess_prefix(0),\n@@ -53,1 +53,1 @@\n-  initialize(size, alignment, page_size, NULL, false);\n+  initialize(size, alignment, page_size, nullptr, false);\n@@ -65,1 +65,1 @@\n-  initialize(size, alignment, preferred_page_size, NULL, false);\n+  initialize(size, alignment, preferred_page_size, nullptr, false);\n@@ -119,1 +119,1 @@\n-  if (base == requested_address || requested_address == NULL) {\n+  if (base == requested_address || requested_address == nullptr) {\n@@ -123,1 +123,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -160,1 +160,1 @@\n-  \/\/ important.  If the reservation fails, return NULL.\n+  \/\/ important.  If the reservation fails, return null.\n@@ -193,1 +193,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -204,1 +204,1 @@\n-  initialize_members(NULL, 0, 0, 0, false, false);\n+  initialize_members(nullptr, 0, 0, 0, false, false);\n@@ -238,1 +238,1 @@\n-    if (base != NULL) {\n+    if (base != nullptr) {\n@@ -253,1 +253,1 @@\n-      if (base != NULL) {\n+      if (base != nullptr) {\n@@ -269,1 +269,1 @@\n-  if (base != NULL) {\n+  if (base != nullptr) {\n@@ -398,1 +398,1 @@\n-  if (_base != NULL) {\n+  if (_base != nullptr) {\n@@ -439,1 +439,1 @@\n-         ((_base == NULL) ||\n+         ((_base == nullptr) ||\n@@ -452,1 +452,1 @@\n-\/\/ NULL terminated.\n+\/\/ null terminated.\n@@ -525,1 +525,1 @@\n-  if (_base == NULL) {\n+  if (_base == nullptr) {\n@@ -566,1 +566,1 @@\n-        ((_base == NULL) ||                        \/\/ No previous try succeeded.\n+        ((_base == nullptr) ||                        \/\/ No previous try succeeded.\n@@ -591,1 +591,1 @@\n-           ((_base == NULL) ||                             \/\/ No previous try succeeded.\n+           ((_base == nullptr) ||                             \/\/ No previous try succeeded.\n@@ -601,3 +601,3 @@\n-    if (_base == NULL) {\n-      log_trace(gc, heap, coops)(\"Trying to allocate at address NULL heap of size \" SIZE_FORMAT_X, size + noaccess_prefix);\n-      initialize(size + noaccess_prefix, alignment, page_size, NULL, false);\n+    if (_base == nullptr) {\n+      log_trace(gc, heap, coops)(\"Trying to allocate at address nullptr heap of size \" SIZE_FORMAT_X, size + noaccess_prefix);\n+      initialize(size + noaccess_prefix, alignment, page_size, nullptr, false);\n@@ -614,1 +614,1 @@\n-  if (heap_allocation_directory != NULL) {\n+  if (heap_allocation_directory != nullptr) {\n@@ -640,1 +640,1 @@\n-    initialize(size, alignment, page_size, NULL, false);\n+    initialize(size, alignment, page_size, nullptr, false);\n@@ -648,1 +648,1 @@\n-  if (base() != NULL) {\n+  if (base() != nullptr) {\n@@ -666,1 +666,1 @@\n-  initialize(r_size, rs_align, rs_page_size, \/*requested address*\/ NULL, \/*executable*\/ true);\n+  initialize(r_size, rs_align, rs_page_size, \/*requested address*\/ nullptr, \/*executable*\/ true);\n@@ -673,10 +673,10 @@\n-  _low_boundary           = NULL;\n-  _high_boundary          = NULL;\n-  _low                    = NULL;\n-  _high                   = NULL;\n-  _lower_high             = NULL;\n-  _middle_high            = NULL;\n-  _upper_high             = NULL;\n-  _lower_high_boundary    = NULL;\n-  _middle_high_boundary   = NULL;\n-  _upper_high_boundary    = NULL;\n+  _low_boundary           = nullptr;\n+  _high_boundary          = nullptr;\n+  _low                    = nullptr;\n+  _high                   = nullptr;\n+  _lower_high             = nullptr;\n+  _middle_high            = nullptr;\n+  _upper_high             = nullptr;\n+  _lower_high_boundary    = nullptr;\n+  _middle_high_boundary   = nullptr;\n+  _upper_high_boundary    = nullptr;\n@@ -698,1 +698,1 @@\n-  assert(_low_boundary == NULL, \"VirtualSpace already initialized\");\n+  assert(_low_boundary == nullptr, \"VirtualSpace already initialized\");\n@@ -752,10 +752,10 @@\n-  _low_boundary           = NULL;\n-  _high_boundary          = NULL;\n-  _low                    = NULL;\n-  _high                   = NULL;\n-  _lower_high             = NULL;\n-  _middle_high            = NULL;\n-  _upper_high             = NULL;\n-  _lower_high_boundary    = NULL;\n-  _middle_high_boundary   = NULL;\n-  _upper_high_boundary    = NULL;\n+  _low_boundary           = nullptr;\n+  _high_boundary          = nullptr;\n+  _low                    = nullptr;\n+  _high                   = nullptr;\n+  _lower_high             = nullptr;\n+  _middle_high            = nullptr;\n+  _upper_high             = nullptr;\n+  _lower_high_boundary    = nullptr;\n+  _middle_high_boundary   = nullptr;\n+  _upper_high_boundary    = nullptr;\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -650,3 +650,3 @@\n-void Klass::set_archived_java_mirror(oop m) {\n-  assert(DumpSharedSpaces, \"called only during runtime\");\n-  _archived_mirror_index = HeapShared::append_root(m);\n+void Klass::set_archived_java_mirror(int mirror_index) {\n+  assert(DumpSharedSpaces, \"called only during dumptime\");\n+  _archived_mirror_index = mirror_index;\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,1 +271,1 @@\n-  void set_archived_java_mirror(oop m) NOT_CDS_JAVA_HEAP_RETURN;\n+  void set_archived_java_mirror(int mirror_index) NOT_CDS_JAVA_HEAP_RETURN;\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/integralConstant.hpp\"\n@@ -33,0 +32,2 @@\n+#include <type_traits>\n+\n@@ -291,1 +292,1 @@\n-struct PrimitiveConversions::Translate<markWord> : public TrueType {\n+struct PrimitiveConversions::Translate<markWord> : public std::true_type {\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-  oop atomic_compare_exchange_oop(int index, oop exchange_value, oop compare_value);\n+  oop replace_if_null(int index, oop exchange_value);\n","filename":"src\/hotspot\/share\/oops\/objArrayOop.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    st->print(\"BAD WORD\");\n+    st->print_cr(\"BAD WORD\");\n@@ -47,1 +47,1 @@\n-    st->print(\"BAD META WORD\");\n+    st->print_cr(\"BAD META WORD\");\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"memory\/iterator.inline.hpp\"\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"metaprogramming\/integralConstant.hpp\"\n@@ -32,0 +31,2 @@\n+#include <type_traits>\n+\n@@ -108,1 +109,1 @@\n-struct PrimitiveConversions::Translate<oop> : public TrueType {\n+struct PrimitiveConversions::Translate<oop> : public std::true_type {\n@@ -116,25 +117,25 @@\n-#define DEF_OOP(type)                                                      \\\n-   class type##OopDesc;                                                    \\\n-   class type##Oop : public oop {                                          \\\n-     public:                                                               \\\n-       type##Oop() : oop() {}                                              \\\n-       type##Oop(const type##Oop& o) : oop(o) {}                           \\\n-       type##Oop(const oop& o) : oop(o) {}                                 \\\n-       type##Oop(type##OopDesc* o) : oop((oopDesc*)o) {}                   \\\n-       operator type##OopDesc* () const { return (type##OopDesc*)obj(); }  \\\n-       type##OopDesc* operator->() const {                                 \\\n-            return (type##OopDesc*)obj();                                  \\\n-       }                                                                   \\\n-       type##Oop& operator=(const type##Oop& o) {                          \\\n-            oop::operator=(o);                                             \\\n-            return *this;                                                  \\\n-       }                                                                   \\\n-   };                                                                      \\\n-                                                                           \\\n-   template<>                                                              \\\n-   struct PrimitiveConversions::Translate<type##Oop> : public TrueType {   \\\n-     typedef type##Oop Value;                                              \\\n-     typedef type##OopDesc* Decayed;                                       \\\n-                                                                           \\\n-     static Decayed decay(Value x) { return (type##OopDesc*)x.obj(); }     \\\n-     static Value recover(Decayed x) { return type##Oop(x); }              \\\n+#define DEF_OOP(type)                                                          \\\n+   class type##OopDesc;                                                        \\\n+   class type##Oop : public oop {                                              \\\n+     public:                                                                   \\\n+       type##Oop() : oop() {}                                                  \\\n+       type##Oop(const type##Oop& o) : oop(o) {}                               \\\n+       type##Oop(const oop& o) : oop(o) {}                                     \\\n+       type##Oop(type##OopDesc* o) : oop((oopDesc*)o) {}                       \\\n+       operator type##OopDesc* () const { return (type##OopDesc*)obj(); }      \\\n+       type##OopDesc* operator->() const {                                     \\\n+            return (type##OopDesc*)obj();                                      \\\n+       }                                                                       \\\n+       type##Oop& operator=(const type##Oop& o) {                              \\\n+            oop::operator=(o);                                                 \\\n+            return *this;                                                      \\\n+       }                                                                       \\\n+   };                                                                          \\\n+                                                                               \\\n+   template<>                                                                  \\\n+   struct PrimitiveConversions::Translate<type##Oop> : public std::true_type { \\\n+     typedef type##Oop Value;                                                  \\\n+     typedef type##OopDesc* Decayed;                                           \\\n+                                                                               \\\n+     static Decayed decay(Value x) { return (type##OopDesc*)x.obj(); }         \\\n+     static Value recover(Decayed x) { return type##Oop(x); }                  \\\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":28,"deletions":27,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-    regalloc->dump_register(n,buf);\n+    regalloc->dump_register(n,buf,sizeof(buf));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -980,0 +980,6 @@\n+#ifdef ASSERT\n+  _type_verify_symmetry = true;\n+  _phase_optimize_finished = false;\n+  _exception_backedge = false;\n+#endif\n+\n@@ -1074,6 +1080,0 @@\n-\n-#ifdef ASSERT\n-  _type_verify_symmetry = true;\n-  _phase_optimize_finished = false;\n-  _exception_backedge = false;\n-#endif\n@@ -4364,2 +4364,2 @@\n-Compile::SubTypeCheckResult Compile::static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk) {\n-  if (StressReflectiveCode) {\n+Compile::SubTypeCheckResult Compile::static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk, bool skip) {\n+  if (skip) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,0 @@\n-class Int_Array;\n@@ -80,1 +79,0 @@\n-class Scope;\n@@ -85,1 +83,0 @@\n-class TypeData;\n@@ -167,1 +164,0 @@\n-  static const char* debug_option_name;\n@@ -1186,1 +1182,1 @@\n-  SubTypeCheckResult static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk);\n+  SubTypeCheckResult static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk, bool skip = StressReflectiveCode);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1201,1 +1201,1 @@\n-    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder);\n+    const Type* holder_type = TypeInstPtr::make(TypePtr::BotPTR, callee_holder, Type::trust_interfaces);\n@@ -1214,1 +1214,1 @@\n-      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder));\n+      Node* holder_klass = _gvn.makecon(TypeKlassPtr::make(callee_holder, Type::trust_interfaces));\n@@ -2134,1 +2134,1 @@\n-  Node* holder = makecon(TypeKlassPtr::make(method()->holder()));\n+  Node* holder = makecon(TypeKlassPtr::make(method()->holder(), Type::trust_interfaces));\n@@ -2213,21 +2213,0 @@\n-    const TypeInstPtr *tr = phi->bottom_type()->isa_instptr();\n-    if (tr && tr->is_loaded() &&\n-        tr->is_interface()) {\n-      const TypeInstPtr *tp = value->bottom_type()->isa_instptr();\n-      if (tp && tp->is_loaded() &&\n-          !tp->is_interface()) {\n-        \/\/ sharpen the type eagerly; this eases certain assert checking\n-        if (tp->higher_equal(TypeInstPtr::NOTNULL))\n-          tr = tr->join_speculative(TypeInstPtr::NOTNULL)->is_instptr();\n-        value = _gvn.transform(new CheckCastPPNode(0, value, tr));\n-      }\n-    } else {\n-      \/\/ Also handle returns of oop-arrays to an arrays-of-interface return\n-      const TypeInstPtr* phi_tip;\n-      const TypeInstPtr* val_tip;\n-      Type::get_arrays_base_elements(phi->bottom_type(), value->bottom_type(), &phi_tip, &val_tip);\n-      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->is_interface() &&\n-          val_tip != NULL && val_tip->is_loaded() && !val_tip->is_interface()) {\n-        value = _gvn.transform(new CheckCastPPNode(0, value, phi->bottom_type()));\n-      }\n-    }\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":3,"deletions":24,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,2 @@\n+const TypePtr::InterfaceSet* TypeAryPtr::_array_interfaces = NULL;\n+const TypePtr::InterfaceSet* TypeAryKlassPtr::_array_interfaces = NULL;\n@@ -137,1 +139,1 @@\n-const Type* Type::get_const_type(ciType* type) {\n+const Type* Type::get_const_type(ciType* type, InterfaceHandling interface_handling) {\n@@ -143,1 +145,1 @@\n-    return TypeOopPtr::make_from_klass(type->as_klass());\n+    return TypeOopPtr::make_from_klass(type->as_klass(), interface_handling);\n@@ -569,0 +571,6 @@\n+  GrowableArray<ciInstanceKlass*> array_interfaces;\n+  array_interfaces.push(current->env()->Cloneable_klass());\n+  array_interfaces.push(current->env()->Serializable_klass());\n+  TypeAryPtr::_array_interfaces = new TypePtr::InterfaceSet(&array_interfaces);\n+  TypeAryKlassPtr::_array_interfaces = TypeAryPtr::_array_interfaces;\n+\n@@ -781,45 +789,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool Type::interface_vs_oop_helper(const Type *t) const {\n-  bool result = false;\n-\n-  const TypePtr* this_ptr = this->make_ptr(); \/\/ In case it is narrow_oop\n-  const TypePtr*    t_ptr =    t->make_ptr();\n-  if( this_ptr == NULL || t_ptr == NULL )\n-    return result;\n-\n-  const TypeInstPtr* this_inst = this_ptr->isa_instptr();\n-  const TypeInstPtr*    t_inst =    t_ptr->isa_instptr();\n-  if( this_inst && this_inst->is_loaded() && t_inst && t_inst->is_loaded() ) {\n-    bool this_interface = this_inst->is_interface();\n-    bool    t_interface =    t_inst->is_interface();\n-    result = this_interface ^ t_interface;\n-  }\n-\n-  return result;\n-}\n-\n-bool Type::interface_vs_oop(const Type *t) const {\n-  if (interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  \/\/ Now check the speculative parts as well\n-  const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()->speculative() : NULL;\n-  const TypePtr* t_spec = t->isa_ptr() != NULL ? t->is_ptr()->speculative() : NULL;\n-  if (this_spec != NULL && t_spec != NULL) {\n-    if (this_spec->interface_vs_oop_helper(t_spec)) {\n-      return true;\n-    }\n-    return false;\n-  }\n-  if (this_spec != NULL && this_spec->interface_vs_oop_helper(t)) {\n-    return true;\n-  }\n-  if (t_spec != NULL && interface_vs_oop_helper(t_spec)) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-#endif\n-\n@@ -845,1 +808,1 @@\n-  if (!interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n+  if (t2t != t->_dual || t2this != this->_dual) {\n@@ -1677,1 +1640,1 @@\n-static const char* intname(char* buf, jint n) {\n+static const char* intname(char* buf, size_t buf_size, jint n) {\n@@ -1681,1 +1644,1 @@\n-    sprintf(buf, \"min+\" INT32_FORMAT, n - min_jint);\n+    os::snprintf_checked(buf, buf_size, \"min+\" INT32_FORMAT, n - min_jint);\n@@ -1685,1 +1648,1 @@\n-    sprintf(buf, \"max-\" INT32_FORMAT, max_jint - n);\n+    os::snprintf_checked(buf, buf_size, \"max-\" INT32_FORMAT, max_jint - n);\n@@ -1687,1 +1650,1 @@\n-    sprintf(buf, INT32_FORMAT, n);\n+    os::snprintf_checked(buf, buf_size, INT32_FORMAT, n);\n@@ -1696,1 +1659,1 @@\n-    st->print(\"int:%s\", intname(buf, get_con()));\n+    st->print(\"int:%s\", intname(buf, sizeof(buf), get_con()));\n@@ -1706,1 +1669,1 @@\n-    st->print(\"int:>=%s\", intname(buf, _lo));\n+    st->print(\"int:>=%s\", intname(buf, sizeof(buf), _lo));\n@@ -1708,1 +1671,1 @@\n-    st->print(\"int:<=%s\", intname(buf, _hi));\n+    st->print(\"int:<=%s\", intname(buf, sizeof(buf), _hi));\n@@ -1710,1 +1673,1 @@\n-    st->print(\"int:%s..%s\", intname(buf, _lo), intname(buf2, _hi));\n+    st->print(\"int:%s..%s\", intname(buf, sizeof(buf), _lo), intname(buf2, sizeof(buf2), _hi));\n@@ -1943,1 +1906,1 @@\n-static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {\n+static const char* longnamenear(jlong x, const char* xname, char* buf, size_t buf_size, jlong n) {\n@@ -1946,1 +1909,1 @@\n-    sprintf(buf, \"%s+\" JLONG_FORMAT, xname, n - x);\n+    os::snprintf_checked(buf, buf_size, \"%s+\" JLONG_FORMAT, xname, n - x);\n@@ -1949,1 +1912,1 @@\n-    sprintf(buf, \"%s-\" JLONG_FORMAT, xname, x - n);\n+    os::snprintf_checked(buf, buf_size, \"%s-\" JLONG_FORMAT, xname, x - n);\n@@ -1956,1 +1919,1 @@\n-static const char* longname(char* buf, jlong n) {\n+static const char* longname(char* buf, size_t buf_size, jlong n) {\n@@ -1961,1 +1924,1 @@\n-    sprintf(buf, \"min+\" JLONG_FORMAT, n - min_jlong);\n+    os::snprintf_checked(buf, buf_size, \"min+\" JLONG_FORMAT, n - min_jlong);\n@@ -1965,2 +1928,2 @@\n-    sprintf(buf, \"max-\" JLONG_FORMAT, max_jlong - n);\n-  else if ((str = longnamenear(max_juint, \"maxuint\", buf, n)) != NULL)\n+    os::snprintf_checked(buf, buf_size, \"max-\" JLONG_FORMAT, max_jlong - n);\n+  else if ((str = longnamenear(max_juint, \"maxuint\", buf, buf_size, n)) != NULL)\n@@ -1968,1 +1931,1 @@\n-  else if ((str = longnamenear(max_jint, \"maxint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(max_jint, \"maxint\", buf, buf_size, n)) != NULL)\n@@ -1970,1 +1933,1 @@\n-  else if ((str = longnamenear(min_jint, \"minint\", buf, n)) != NULL)\n+  else if ((str = longnamenear(min_jint, \"minint\", buf, buf_size, n)) != NULL)\n@@ -1973,1 +1936,1 @@\n-    sprintf(buf, JLONG_FORMAT, n);\n+    os::snprintf_checked(buf, buf_size, JLONG_FORMAT, n);\n@@ -1982,1 +1945,1 @@\n-    st->print(\"long:%s\", longname(buf, get_con()));\n+    st->print(\"long:%s\", longname(buf, sizeof(buf), get_con()));\n@@ -1984,1 +1947,1 @@\n-    st->print(\"long:>=%s\", longname(buf, _lo));\n+    st->print(\"long:>=%s\", longname(buf, sizeof(buf), _lo));\n@@ -1986,1 +1949,1 @@\n-    st->print(\"long:<=%s\", longname(buf, _hi));\n+    st->print(\"long:<=%s\", longname(buf, sizeof(buf), _hi));\n@@ -1988,1 +1951,1 @@\n-    st->print(\"long:%s..%s\", longname(buf, _lo), longname(buf2, _hi));\n+    st->print(\"long:%s..%s\", longname(buf, sizeof(buf), _lo), longname(buf2,sizeof(buf2),  _hi));\n@@ -2023,1 +1986,1 @@\n-const TypeTuple *TypeTuple::make_range(ciSignature* sig) {\n+const TypeTuple *TypeTuple::make_range(ciSignature* sig, InterfaceHandling interface_handling) {\n@@ -2044,1 +2007,1 @@\n-    field_array[TypeFunc::Parms] = get_const_type(return_type);\n+    field_array[TypeFunc::Parms] = get_const_type(return_type, interface_handling);\n@@ -2055,1 +2018,1 @@\n-const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {\n+const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig, InterfaceHandling interface_handling) {\n@@ -2064,1 +2027,1 @@\n-    field_array[pos++] = get_const_type(recv)->join_speculative(TypePtr::NOTNULL);\n+    field_array[pos++] = get_const_type(recv, interface_handling)->join_speculative(TypePtr::NOTNULL);\n@@ -2086,1 +2049,1 @@\n-      field_array[pos++] = get_const_type(type);\n+      field_array[pos++] = get_const_type(type, interface_handling);\n@@ -2317,15 +2280,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAry::interface_vs_oop(const Type *t) const {\n-  const TypeAry* t_ary = t->is_ary();\n-  if (t_ary) {\n-    const TypePtr* this_ptr = _elem->make_ptr(); \/\/ In case we have narrow_oops\n-    const TypePtr*    t_ptr = t_ary->_elem->make_ptr();\n-    if(this_ptr != NULL && t_ptr != NULL) {\n-      return this_ptr->interface_vs_oop(t_ptr);\n-    }\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -2369,3 +2317,1 @@\n-  ciKlass* tklass = toop->klass();\n-  if (tklass == NULL)       return false;  \/\/ unloaded class\n-  if (!tklass->is_loaded()) return false;  \/\/ unloaded class\n+  if (!toop->is_loaded())   return false;  \/\/ unloaded class\n@@ -2378,1 +2324,1 @@\n-    return tklass->as_instance_klass()->is_final();\n+    return tinst->instance_klass()->is_final();\n@@ -3170,0 +3116,229 @@\n+TypePtr::InterfaceSet::InterfaceSet()\n+        : _list(Compile::current()->type_arena(), 0, 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+}\n+\n+TypePtr::InterfaceSet::InterfaceSet(GrowableArray<ciInstanceKlass*>* interfaces)\n+        : _list(Compile::current()->type_arena(), interfaces->length(), 0, NULL),\n+          _hash_computed(0), _exact_klass_computed(0), _is_loaded_computed(0) {\n+  for (int i = 0; i < interfaces->length(); i++) {\n+    add(interfaces->at(i));\n+  }\n+}\n+\n+\n+int TypePtr::InterfaceSet::compare(ciKlass* const& k1, ciKlass* const& k2) {\n+  if ((intptr_t)k1 < (intptr_t)k2) {\n+    return -1;\n+  } else if ((intptr_t)k1 > (intptr_t)k2) {\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+void TypePtr::InterfaceSet::add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.insert_sorted<compare>(interface);\n+  verify();\n+}\n+\n+void TypePtr::InterfaceSet::raw_add(ciKlass* interface) {\n+  assert(interface->is_interface(), \"for interfaces only\");\n+  _list.push(interface);\n+}\n+\n+bool TypePtr::InterfaceSet::eq(const InterfaceSet& other) const {\n+  if (_list.length() != other._list.length()) {\n+    return false;\n+  }\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i);\n+    ciKlass* k2 = other._list.at(i);\n+    if (!k1->equals(k2)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+int TypePtr::InterfaceSet::hash() const {\n+  if (_hash_computed) {\n+    return _hash;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_hash();\n+  assert(_hash_computed, \"should be computed now\");\n+  return _hash;\n+}\n+\n+void TypePtr::InterfaceSet::compute_hash() {\n+  int hash = 0;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* k = _list.at(i);\n+    hash += (jint)k->hash();\n+  }\n+  _hash_computed = 1;\n+  _hash = hash;\n+}\n+\n+static int compare_interfaces(ciKlass** k1, ciKlass** k2) {\n+  return (int)((*k1)->ident() - (*k2)->ident());\n+}\n+\n+void TypePtr::InterfaceSet::dump(outputStream *st) const {\n+  if (_list.length() == 0) {\n+    return;\n+  }\n+  ResourceMark rm;\n+  st->print(\" (\");\n+  GrowableArray<ciKlass*> interfaces;\n+  interfaces.appendAll(&_list);\n+  \/\/ Sort the interfaces so they are listed in the same order from one run to the other of the same compilation\n+  interfaces.sort(compare_interfaces);\n+  for (int i = 0; i < interfaces.length(); i++) {\n+    if (i > 0) {\n+      st->print(\",\");\n+    }\n+    ciKlass* k = interfaces.at(i);\n+    k->print_name_on(st);\n+  }\n+  st->print(\")\");\n+}\n+\n+void TypePtr::InterfaceSet::verify() const {\n+#ifdef DEBUG\n+  for (int i = 1; i < _list.length(); i++) {\n+    ciKlass* k1 = _list.at(i-1);\n+    ciKlass* k2 = _list.at(i);\n+    assert(compare(k2, k1) > 0, \"should be ordered\");\n+    assert(k1 != k2, \"no duplicate\");\n+  }\n+#endif\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::union_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      result.raw_add(other._list.at(j));\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) || other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+TypePtr::InterfaceSet TypeOopPtr::InterfaceSet::intersection_with(const InterfaceSet& other) const {\n+  InterfaceSet result;\n+  int i = 0;\n+  int j = 0;\n+  while (i < _list.length() || j < other._list.length()) {\n+    while (i < _list.length() &&\n+           (j >= other._list.length() ||\n+            compare(_list.at(i), other._list.at(j)) < 0)) {\n+      i++;\n+    }\n+    while (j < other._list.length() &&\n+           (i >= _list.length() ||\n+            compare(other._list.at(j), _list.at(i)) < 0)) {\n+      j++;\n+    }\n+    if (i < _list.length() &&\n+        j < other._list.length() &&\n+        _list.at(i) == other._list.at(j)) {\n+      result.raw_add(_list.at(i));\n+      i++;\n+      j++;\n+    }\n+  }\n+  result.verify();\n+#ifdef DEBUG\n+  for (int i = 0; i < _list.length(); i++) {\n+    assert(!other._list.contains(_list.at(i)) || result.contains(_list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < other._list.length(); i++) {\n+    assert(!_list.contains(other._list.at(i)) || result.contains(other._list.at(i)), \"missing\");\n+  }\n+  for (int i = 0; i < result._list.length(); i++) {\n+    assert(_list.contains(result._list.at(i)) && other._list.contains(result._list.at(i)), \"missing\");\n+  }\n+#endif\n+  return result;\n+}\n+\n+\/\/ Is there a single ciKlass* that can represent the interface set?\n+ciKlass* TypePtr::InterfaceSet::exact_klass() const {\n+  if (_exact_klass_computed) {\n+    return _exact_klass;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_exact_klass();\n+  assert(_exact_klass_computed, \"should be computed now\");\n+  return _exact_klass;\n+}\n+\n+void TypePtr::InterfaceSet::compute_exact_klass() {\n+  if (_list.length() == 0) {\n+    _exact_klass_computed = 1;\n+    _exact_klass = NULL;\n+    return;\n+  }\n+  ciKlass* res = NULL;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (eq(interfaces(interface, false, true, false, trust_interfaces))) {\n+      assert(res == NULL, \"\");\n+      res = _list.at(i);\n+    }\n+  }\n+  _exact_klass_computed = 1;\n+  _exact_klass = res;\n+}\n+\n+bool TypePtr::InterfaceSet::is_loaded() const {\n+  if (_is_loaded_computed) {\n+    return _is_loaded;\n+  }\n+  const_cast<InterfaceSet*>(this)->compute_is_loaded();\n+  assert(_is_loaded_computed, \"should be computed now\");\n+  return _is_loaded;\n+}\n+\n+void TypePtr::InterfaceSet::compute_is_loaded() {\n+  _is_loaded_computed = 1;\n+  for (int i = 0; i < _list.length(); i++) {\n+    ciKlass* interface = _list.at(i);\n+    if (!interface->is_loaded()) {\n+      _is_loaded = false;\n+      return;\n+    }\n+  }\n+  _is_loaded = true;\n+}\n+\n@@ -3171,1 +3346,1 @@\n-TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,\n+TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int offset,\n@@ -3175,0 +3350,1 @@\n+    _interfaces(interfaces),\n@@ -3197,1 +3373,0 @@\n-      ciField* field = NULL;\n@@ -3222,1 +3397,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3229,1 +3404,1 @@\n-          field = ik->get_field_by_offset(_offset, false);\n+          ciField* field = ik->get_field_by_offset(_offset, false);\n@@ -3232,1 +3407,1 @@\n-            _is_ptr_to_narrowoop = UseCompressedOops && is_reference_type(basic_elem_type);\n+            _is_ptr_to_narrowoop = UseCompressedOops && ::is_reference_type(basic_elem_type);\n@@ -3255,1 +3430,1 @@\n-  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n+  return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, InterfaceSet(), xk, o, offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3368,1 +3543,1 @@\n-  return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeOopPtr(_base, dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -3373,1 +3548,1 @@\n-const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {\n+const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass* klass, bool klass_change, bool try_for_exact, InterfaceHandling interface_handling) {\n@@ -3400,1 +3575,2 @@\n-    return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstPtr::make(TypePtr::BotPTR, klass, interfaces, klass_is_exact, NULL, 0);\n@@ -3403,1 +3579,2 @@\n-    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass->as_obj_array_klass()->element_klass(), false, try_for_exact);\n+    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n+    const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(eklass, false, try_for_exact, interface_handling);\n@@ -3409,1 +3586,1 @@\n-    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);\n+    const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, NULL, xk, 0);\n@@ -3443,1 +3620,1 @@\n-      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass());\n+      TypeOopPtr::make_from_klass_raw(klass->as_obj_array_klass()->element_klass(), trust_interfaces);\n@@ -3501,21 +3678,0 @@\n-    \/\/ Check for evil case of 'this' being a class and 'kills' expecting an\n-    \/\/ interface.  This can happen because the bytecodes do not contain\n-    \/\/ enough type info to distinguish a Java-level interface variable\n-    \/\/ from a Java-level object variable.  If we meet 2 classes which\n-    \/\/ both implement interface I, but their meet is at 'j\/l\/O' which\n-    \/\/ doesn't implement I, we have no way to tell if the result should\n-    \/\/ be 'I' or 'j\/l\/O'.  Thus we'll pick 'j\/l\/O'.  If this then flows\n-    \/\/ into a Phi which \"knows\" it's an Interface type we'll have to\n-    \/\/ uplift the type.\n-    if (!empty()) {\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to interface\n-      }\n-      \/\/ Also check for evil cases of 'this' being a class array\n-      \/\/ and 'kills' expecting an array of interfaces.\n-      Type::get_arrays_base_elements(ft, kills, NULL, &ktip);\n-      if (ktip != NULL && ktip->is_loaded() && ktip->klass()->is_interface()) {\n-        return kills;           \/\/ Uplift to array of interface\n-      }\n-    }\n-\n@@ -3525,12 +3681,0 @@\n-  \/\/ If we have an interface-typed Phi or cast and we narrow to a class type,\n-  \/\/ the join should report back the class.  However, if we have a J\/L\/Object\n-  \/\/ class-typed Phi and an interface flows in, it's possible that the meet &\n-  \/\/ join report an interface back out.  This isn't possible but happens\n-  \/\/ because the type system doesn't interact well with interfaces.\n-  if (ftip != NULL && ktip != NULL &&\n-      ftip->is_loaded() &&  ftip->klass()->is_interface() &&\n-      ktip->is_loaded() && !ktip->klass()->is_interface()) {\n-    assert(!ftip->klass_is_exact(), \"interface could not be exact\");\n-    return ktip->cast_to_ptr_type(ftip->ptr());\n-  }\n-\n@@ -3595,1 +3739,1 @@\n-const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeOopPtr::add_offset(intptr_t offset) const {\n@@ -3662,0 +3806,12 @@\n+\n+TypePtr::InterfaceSet TypeOopPtr::meet_interfaces(const TypeOopPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -3686,0 +3842,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -3687,1 +3844,12 @@\n-  return _klass;\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    const TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    if (_interfaces.eq(interfaces)) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -3691,1 +3859,1 @@\n-TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,\n+TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, bool xk, ciObject* o, int off,\n@@ -3693,4 +3861,5 @@\n-  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth) {\n-   assert(k != NULL &&\n-          (k->is_loaded() || o == NULL),\n-          \"cannot have constants with non-loaded klass\");\n+  : TypeOopPtr(InstPtr, ptr, k, interfaces, xk, o, off, instance_id, speculative, inline_depth) {\n+  assert(k == NULL || !k->is_loaded() || !k->is_interface(), \"no interface here\");\n+  assert(k != NULL &&\n+         (k->is_loaded() || o == NULL),\n+         \"cannot have constants with non-loaded klass\");\n@@ -3702,0 +3871,1 @@\n+                                     const InterfaceSet& interfaces,\n@@ -3722,0 +3892,1 @@\n+    assert(!ik->is_interface(), \"no interface here\");\n@@ -3727,1 +3898,1 @@\n-    (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n+    (TypeInstPtr*)(new TypeInstPtr(ptr, k, interfaces, xk, o ,offset, instance_id, speculative, inline_depth))->hashcons();\n@@ -3732,0 +3903,33 @@\n+TypePtr::InterfaceSet TypePtr::interfaces(ciKlass*& k, bool klass, bool interface, bool array, InterfaceHandling interface_handling) {\n+  if (k->is_instance_klass()) {\n+    if (k->is_loaded()) {\n+      if (k->is_interface() && interface_handling == ignore_interfaces) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+        InterfaceSet interfaces;\n+        return interfaces;\n+      }\n+      GrowableArray<ciInstanceKlass *> *k_interfaces = k->as_instance_klass()->transitive_interfaces();\n+      InterfaceSet interfaces(k_interfaces);\n+      if (k->is_interface()) {\n+        assert(interface, \"no interface expected\");\n+        k = ciEnv::current()->Object_klass();\n+      } else {\n+        assert(klass, \"no instance klass expected\");\n+      }\n+      return interfaces;\n+    }\n+    InterfaceSet interfaces;\n+    return interfaces;\n+  }\n+  assert(array, \"no array expected\");\n+  assert(k->is_array_klass(), \"Not an array?\");\n+  ciType* e = k->as_array_klass()->base_element_type();\n+  if (e->is_loaded() && e->is_instance_klass() && e->as_instance_klass()->is_interface()) {\n+    if (interface_handling == ignore_interfaces) {\n+      k = ciObjArrayKlass::make(ciEnv::current()->Object_klass(), k->as_array_klass()->dimension());\n+    }\n+  }\n+  return *TypeAryPtr::_array_interfaces;\n+}\n+\n@@ -3760,1 +3964,1 @@\n-  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), _interfaces, klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n@@ -3770,2 +3974,2 @@\n-  if( ik->is_interface() )              return this;  \/\/ cannot set xk\n-  return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n+  assert(!ik->is_interface(), \"no interface here\");\n+  return make(ptr(), klass(), _interfaces, klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n@@ -3777,1 +3981,1 @@\n-  return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(),  _interfaces, _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -3783,35 +3987,31 @@\n-const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {\n-    int off = meet_offset(tinst->offset());\n-    PTR ptr = meet_ptr(tinst->ptr());\n-    int instance_id = meet_instance_id(tinst->instance_id());\n-    const TypePtr* speculative = xmeet_speculative(tinst);\n-    int depth = meet_inline_depth(tinst->inline_depth());\n-\n-    const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n-    const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n-    if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n-      \/\/\n-      \/\/ Meet unloaded class with java\/lang\/Object\n-      \/\/\n-      \/\/ Meet\n-      \/\/          |                     Unloaded Class\n-      \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n-      \/\/  ===================================================================\n-      \/\/   TOP    | ..........................Unloaded......................|\n-      \/\/  AnyNull |  U-AN    |................Unloaded......................|\n-      \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n-      \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n-      \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n-      \/\/\n-      assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n-      \/\/\n-      if(      loaded->ptr() == TypePtr::TopPTR ) { return unloaded; }\n-      else if (loaded->ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded->klass(), false, NULL, off, instance_id, speculative, depth); }\n-      else if (loaded->ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }\n-      else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n-        if (unloaded->ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }\n-        else                                      { return TypeInstPtr::NOTNULL; }\n-      }\n-      else if( unloaded->ptr() == TypePtr::TopPTR )  { return unloaded; }\n-\n-      return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst, const InterfaceSet& interfaces) const {\n+  int off = meet_offset(tinst->offset());\n+  PTR ptr = meet_ptr(tinst->ptr());\n+  int instance_id = meet_instance_id(tinst->instance_id());\n+  const TypePtr* speculative = xmeet_speculative(tinst);\n+  int depth = meet_inline_depth(tinst->inline_depth());\n+\n+  const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;\n+  const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;\n+  if( loaded->klass()->equals(ciEnv::current()->Object_klass()) ) {\n+    \/\/\n+    \/\/ Meet unloaded class with java\/lang\/Object\n+    \/\/\n+    \/\/ Meet\n+    \/\/          |                     Unloaded Class\n+    \/\/  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |\n+    \/\/  ===================================================================\n+    \/\/   TOP    | ..........................Unloaded......................|\n+    \/\/  AnyNull |  U-AN    |................Unloaded......................|\n+    \/\/ Constant | ... O-NN .................................. |   O-BOT   |\n+    \/\/  NotNull | ... O-NN .................................. |   O-BOT   |\n+    \/\/  BOTTOM  | ........................Object-BOTTOM ..................|\n+    \/\/\n+    assert(loaded->ptr() != TypePtr::Null, \"insanity check\");\n+    \/\/\n+    if (loaded->ptr() == TypePtr::TopPTR)        { return unloaded; }\n+    else if (loaded->ptr() == TypePtr::AnyNull)  { return make(ptr, unloaded->klass(), interfaces, false, NULL, off, instance_id, speculative, depth); }\n+    else if (loaded->ptr() == TypePtr::BotPTR)   { return TypeInstPtr::BOTTOM; }\n+    else if (loaded->ptr() == TypePtr::Constant || loaded->ptr() == TypePtr::NotNull) {\n+      if (unloaded->ptr() == TypePtr::BotPTR)    { return TypeInstPtr::BOTTOM;  }\n+      else                                       { return TypeInstPtr::NOTNULL; }\n@@ -3819,0 +4019,1 @@\n+    else if (unloaded->ptr() == TypePtr::TopPTR) { return unloaded; }\n@@ -3820,6 +4021,9 @@\n-    \/\/ Both are unloaded, not the same class, not Object\n-    \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n-    if( ptr != TypePtr::BotPTR ) {\n-      return TypeInstPtr::NOTNULL;\n-    }\n-    return TypeInstPtr::BOTTOM;\n+    return unloaded->cast_to_ptr_type(TypePtr::AnyNull)->is_instptr();\n+  }\n+\n+  \/\/ Both are unloaded, not the same class, not Object\n+  \/\/ Or meet unloaded with a different loaded class, not java\/lang\/Object\n+  if (ptr != TypePtr::BotPTR) {\n+    return TypeInstPtr::NOTNULL;\n+  }\n+  return TypeInstPtr::BOTTOM;\n@@ -3878,1 +4082,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -3906,1 +4110,1 @@\n-      return make(ptr, klass(), klass_is_exact(),\n+      return make(ptr, klass(), _interfaces, klass_is_exact(),\n@@ -3940,0 +4144,2 @@\n+    InterfaceSet interfaces = meet_interfaces(tinst);\n+\n@@ -3942,2 +4148,0 @@\n-    bool tinst_xk = tinst->klass_is_exact();\n-    bool this_xk  = klass_is_exact();\n@@ -3948,1 +4152,2 @@\n-    MeetResult kind = meet_instptr(ptr, this_klass, tinst_klass, this_xk, tinst_xk, this->_ptr, tinst->_ptr, res_klass, res_xk);\n+    MeetResult kind = meet_instptr(ptr, interfaces, this, tinst, res_klass, res_xk);\n+\n@@ -3951,1 +4156,1 @@\n-      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst);\n+      const TypeInstPtr* unloaded_meet = xmeet_unloaded(tinst, interfaces);\n@@ -3988,1 +4193,1 @@\n-      res = make(ptr, res_klass, res_xk, o, off, instance_id, speculative, depth);\n+      res = make(ptr, res_klass, interfaces, res_xk, o, off, instance_id, speculative, depth);\n@@ -3999,4 +4204,10 @@\n-TypePtr::MeetResult TypePtr::meet_instptr(PTR &ptr, ciKlass* this_klass, ciKlass* tinst_klass, bool this_xk, bool tinst_xk,\n-                                          PTR this_ptr,\n-                                          PTR tinst_ptr, ciKlass*&res_klass, bool &res_xk) {\n-\n+template<class T> TypePtr::MeetResult TypePtr::meet_instptr(PTR& ptr, InterfaceSet& interfaces, const T* this_type, const T* other_type,\n+                      ciKlass*& res_klass, bool& res_xk) {\n+  ciKlass* this_klass = this_type->klass();\n+  ciKlass* other_klass = other_type->klass();\n+  bool this_xk = this_type->klass_is_exact();\n+  bool other_xk = other_type->klass_is_exact();\n+  PTR this_ptr = this_type->ptr();\n+  PTR other_ptr = other_type->ptr();\n+  InterfaceSet this_interfaces = this_type->interfaces();\n+  InterfaceSet other_interfaces = other_type->interfaces();\n@@ -4007,1 +4218,1 @@\n-  if (ptr != Constant && this_klass->equals(tinst_klass) && this_xk == tinst_xk) {\n+  if (ptr != Constant && this_klass->equals(other_klass) && this_xk == other_xk) {\n@@ -4014,1 +4225,1 @@\n-  if (!tinst_klass->is_loaded() || !this_klass->is_loaded()) {\n+  if (!other_klass->is_loaded() || !this_klass->is_loaded()) {\n@@ -4018,41 +4229,0 @@\n-  \/\/ Handle mixing oops and interfaces first.\n-  if (this_klass->is_interface() && !(tinst_klass->is_interface() ||\n-                                      tinst_klass == ciEnv::current()->Object_klass())) {\n-    ciKlass *tmp = tinst_klass; \/\/ Swap interface around\n-    tinst_klass = this_klass;\n-    this_klass = tmp;\n-    bool tmp2 = tinst_xk;\n-    tinst_xk = this_xk;\n-    this_xk = tmp2;\n-  }\n-  if (tinst_klass->is_interface() &&\n-      !(this_klass->is_interface() ||\n-        \/\/ Treat java\/lang\/Object as an honorary interface,\n-        \/\/ because we need a bottom for the interface hierarchy.\n-        this_klass == ciEnv::current()->Object_klass())) {\n-    \/\/ Oop meets interface!\n-\n-    \/\/ See if the oop subtypes (implements) interface.\n-    if (this_klass->is_subtype_of(tinst_klass)) {\n-      \/\/ Oop indeed subtypes.  Now keep oop or interface depending\n-      \/\/ on whether we are both above the centerline or either is\n-      \/\/ below the centerline.  If we are on the centerline\n-      \/\/ (e.g., Constant vs. AnyNull interface), use the constant.\n-      res_klass  = below_centerline(ptr) ? tinst_klass : this_klass;\n-      \/\/ If we are keeping this_klass, keep its exactness too.\n-      res_xk = below_centerline(ptr) ? tinst_xk    : this_xk;\n-      return SUBTYPE;\n-    } else {                  \/\/ Does not implement, fall to Object\n-      \/\/ Oop does not implement interface, so mixing falls to Object\n-      \/\/ just like the verifier does (if both are above the\n-      \/\/ centerline fall to interface)\n-      res_klass = above_centerline(ptr) ? tinst_klass : ciEnv::current()->Object_klass();\n-      res_xk = above_centerline(ptr) ? tinst_xk : false;\n-      \/\/ Watch out for Constant vs. AnyNull interface.\n-      if (ptr == Constant)  ptr = NotNull;   \/\/ forget it was a constant\n-      return NOT_SUBTYPE;\n-    }\n-  }\n-\n-  \/\/ Either oop vs oop or interface vs interface or interface vs Object\n-\n@@ -4084,1 +4254,1 @@\n-  ciKlass *subtype = NULL;\n+  const T* subtype = NULL;\n@@ -4086,5 +4256,7 @@\n-  if (tinst_klass->equals(this_klass)) {\n-    subtype = this_klass;\n-    subtype_exact = below_centerline(ptr) ? (this_xk && tinst_xk) : (this_xk || tinst_xk);\n-  } else if (!tinst_xk && this_klass->is_subtype_of(tinst_klass)) {\n-    subtype = this_klass;     \/\/ Pick subtyping class\n+  InterfaceSet subtype_interfaces;\n+\n+  if (this_type->is_same_java_type_as(other_type)) {\n+    subtype = this_type;\n+    subtype_exact = below_centerline(ptr) ? (this_xk && other_xk) : (this_xk || other_xk);\n+  } else if (!other_xk && this_type->is_meet_subtype_of(other_type)) {\n+    subtype = this_type;     \/\/ Pick subtyping class\n@@ -4092,3 +4264,3 @@\n-  } else if (!this_xk && tinst_klass->is_subtype_of(this_klass)) {\n-    subtype = tinst_klass;    \/\/ Pick subtyping class\n-    subtype_exact = tinst_xk;\n+  } else if(!this_xk && other_type->is_meet_subtype_of(this_type)) {\n+    subtype = other_type;    \/\/ Pick subtyping class\n+    subtype_exact = other_xk;\n@@ -4099,8 +4271,8 @@\n-      this_klass = tinst_klass = subtype;\n-      this_xk = tinst_xk = subtype_exact;\n-    } else if (above_centerline(this_ptr) && !above_centerline(tinst_ptr)) {\n-      this_klass = tinst_klass; \/\/ tinst is down; keep down man\n-      this_xk = tinst_xk;\n-    } else if (above_centerline(tinst_ptr) && !above_centerline(this_ptr)) {\n-      tinst_klass = this_klass; \/\/ this is down; keep down man\n-      tinst_xk = this_xk;\n+      this_type = other_type = subtype;\n+      this_xk = other_xk = subtype_exact;\n+    } else if (above_centerline(this_ptr) && !above_centerline(other_ptr)) {\n+      this_type = other_type; \/\/ tinst is down; keep down man\n+      this_xk = other_xk;\n+    } else if (above_centerline(other_ptr) && !above_centerline(this_ptr)) {\n+      other_type = this_type; \/\/ this is down; keep down man\n+      other_xk = this_xk;\n@@ -4113,1 +4285,1 @@\n-  if (tinst_klass->equals(this_klass)) {\n+  if (this_type->is_same_java_type_as(other_type)) {\n@@ -4117,1 +4289,1 @@\n-    res_klass = this_klass;\n+    res_klass = this_type->klass();\n@@ -4128,0 +4300,2 @@\n+  interfaces = this_interfaces.intersection_with(other_interfaces);\n+\n@@ -4129,1 +4303,1 @@\n-  ciKlass* k = this_klass->least_common_ancestor(tinst_klass);\n+  ciKlass* k = this_klass->least_common_ancestor(other_klass);\n@@ -4137,1 +4311,0 @@\n-\n@@ -4154,1 +4327,1 @@\n-  return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n+  return new TypeInstPtr(dual_ptr(), klass(), _interfaces, klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());\n@@ -4163,0 +4336,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -4169,1 +4343,1 @@\n-  int hash = java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash());\n+  int hash = java_add(java_add((jint)klass()->hash(), (jint)TypeOopPtr::hash()), _interfaces.hash());\n@@ -4174,20 +4348,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-\n-  if (!other_exact) {\n-    return false;\n-  }\n-\n-  if (other->klass()->equals(ciEnv::current()->Object_klass())) {\n-    return true;\n-  }\n-\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n-\n-  return _klass->is_subtype_of(other->klass());\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4196,8 +4351,3 @@\n-bool TypeInstPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return false;\n-  }\n-  if (!other->isa_instptr()) {\n-    return false;\n-  }\n-  return _klass->equals(other->_klass);\n+\n+bool TypeInstPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n@@ -4207,27 +4357,1 @@\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n-\n-  if (other->isa_aryptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n-  }\n-\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n-  }\n-\n-  assert(other->isa_instptr(), \"unsupported\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n-    return false;\n-  }\n-\n-  if (this_exact) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-\n-  return true;\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -4243,0 +4367,1 @@\n+  _interfaces.dump(st);\n@@ -4292,1 +4417,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), xadd_offset(offset),\n@@ -4297,1 +4422,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), offset,\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), offset,\n@@ -4306,1 +4431,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset,\n@@ -4310,1 +4435,1 @@\n-const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeInstPtr::with_inline_depth(int depth) const {\n@@ -4314,1 +4439,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);\n@@ -4317,1 +4442,1 @@\n-const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeInstPtr::with_instance_id(int instance_id) const {\n@@ -4319,1 +4444,1 @@\n-  return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n+  return make(_ptr, klass(), _interfaces, klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);\n@@ -4325,5 +4450,59 @@\n-  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final() && !ik->is_interface()) {\n-    Compile* C = Compile::current();\n-    Dependencies* deps = C->dependencies();\n-    deps->assert_leaf_type(ik);\n-    xk = true;\n+  if (try_for_exact && !xk && !ik->has_subklass() && !ik->is_final()) {\n+    ciKlass* k = ik;\n+    TypePtr::InterfaceSet interfaces = TypePtr::interfaces(k, true, false, false, ignore_interfaces);\n+    assert(k == ik, \"\");\n+    if (interfaces.eq(_interfaces)) {\n+      Compile *C = Compile::current();\n+      Dependencies* deps = C->dependencies();\n+      deps->assert_leaf_type(ik);\n+      xk = true;\n+    }\n+  }\n+  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), _interfaces, 0);\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_meet_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (!this_one->is_instance_type(other)) {\n+    return false;\n+  }\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  return this_one->klass()->is_subtype_of(other->klass()) &&\n+         (!this_xk || this_one->_interfaces.contains(other->_interfaces));\n+}\n+\n+\n+bool TypeInstPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+template <class T1, class T2>  bool TypePtr::is_meet_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_xk, bool other_xk) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty()) {\n+    return true;\n+  }\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && this_one->_interfaces.contains(other->_interfaces);\n+  }\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (this_top_or_bottom) {\n+    return false;\n+  }\n+\n+  const T1* other_ary = this_one->is_array_type(other);\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_meet_subtype_of_helper(this_one->is_reference_type(other_elem), this_xk, other_xk);\n+  }\n+\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -4331,1 +4510,14 @@\n-  return TypeInstKlassPtr::make(xk ? TypePtr::Constant : TypePtr::NotNull, klass(), 0);\n+\n+  return false;\n+}\n+\n+bool TypeAryPtr::is_meet_subtype_of_helper(const TypeOopPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeInstKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_instance(this, other, this_xk, other_xk);\n+}\n+\n+bool TypeAryKlassPtr::is_meet_subtype_of_helper(const TypeKlassPtr *other, bool this_xk, bool other_xk) const {\n+  return TypePtr::is_meet_subtype_of_helper_for_array(this, other, this_xk, other_xk);\n@@ -4354,0 +4546,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4366,0 +4562,4 @@\n+  if (k != NULL && k->is_loaded() && k->is_obj_array_klass() &&\n+      k->as_obj_array_klass()->base_element_klass()->is_interface()) {\n+    k = NULL;\n+  }\n@@ -4393,1 +4593,1 @@\n-  if (!is_java_primitive(etype) && !is_reference_type(etype)) {\n+  if (!is_java_primitive(etype) && !::is_reference_type(etype)) {\n@@ -4501,22 +4701,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n-    return false;\n-  }\n-  if (other->isa_instptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n-  }\n-  if (klass() == NULL) {\n-    return false;\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact, other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -4525,13 +4704,2 @@\n-bool TypeAryPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n-  if (!other->isa_aryptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return false;\n-  }\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->is_same_java_type_as(other_ary->elem()->make_oopptr());\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->equals(other->_klass);\n-  }\n-  return false;\n+bool TypeAryPtr::is_same_java_type_as_helper(const TypeOopPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n@@ -4541,25 +4709,1 @@\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n-    return true;\n-  }\n-\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n-    return true;\n-  }\n-  if (other->isa_instptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n-  }\n-  assert(other->isa_aryptr(), \"\");\n-\n-  if (this_exact && other_exact) {\n-    return is_java_subtype_of(other);\n-  }\n-\n-  const TypeAryPtr* other_ary = other->isa_aryptr();\n-  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n-    return elem()->make_oopptr()->maybe_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact,\n-                                                               other_exact);\n-  }\n-  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n-  }\n-  return false;\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n@@ -4660,1 +4804,1 @@\n-    if (meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk) == NOT_SUBTYPE) {\n+    if (meet_aryptr(ptr, elem, this, tap, res_klass, res_xk) == NOT_SUBTYPE) {\n@@ -4690,0 +4834,4 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n+\n@@ -4696,2 +4844,2 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n-        return make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n+        return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);\n@@ -4702,1 +4850,2 @@\n-        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL,offset, instance_id, speculative, depth);\n+        interfaces = this_interfaces.intersection_with(tp_interfaces);\n+        return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL,offset, instance_id, speculative, depth);\n@@ -4714,1 +4863,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.contains(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -4728,1 +4877,2 @@\n-      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), false, NULL, offset, instance_id, speculative, depth);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, false, NULL, offset, instance_id, speculative, depth);\n@@ -4737,1 +4887,11 @@\n-TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, ciKlass* this_klass, ciKlass* tap_klass, bool this_xk, bool tap_xk, PTR this_ptr, PTR tap_ptr, ciKlass*& res_klass, bool& res_xk) {\n+template<class T> TypePtr::MeetResult TypePtr::meet_aryptr(PTR& ptr, const Type*& elem, const T* this_ary,\n+                                                           const T* other_ary, ciKlass*& res_klass, bool& res_xk) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_ary->base_element_type(dummy) == Type::TOP || this_ary->base_element_type(dummy) == Type::BOTTOM);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  ciKlass* this_klass = this_ary->klass();\n+  ciKlass* other_klass = other_ary->klass();\n+  bool this_xk = this_ary->klass_is_exact();\n+  bool other_xk = other_ary->klass_is_exact();\n+  PTR this_ptr = this_ary->ptr();\n+  PTR other_ptr = other_ary->ptr();\n@@ -4743,3 +4903,3 @@\n-    if (this_klass == NULL)\n-      res_klass = tap_klass;\n-    else if (tap_klass == NULL || tap_klass == this_klass) {\n+    if (this_top_or_bottom)\n+      res_klass = other_klass;\n+    else if (other_top_or_bottom || other_klass == this_klass) {\n@@ -4754,1 +4914,1 @@\n-  } else \/\/ Non integral arrays.\n+  } else {\/\/ Non integral arrays.\n@@ -4757,1 +4917,1 @@\n-    if ((above_centerline(ptr) || ptr == Constant) && this_klass != tap_klass &&\n+    if ((above_centerline(ptr) || ptr == Constant) && !this_ary->is_same_java_type_as(other_ary) &&\n@@ -4759,1 +4919,1 @@\n-        tap_klass != NULL  && this_klass != NULL   &&\n+        !this_top_or_bottom && !other_top_or_bottom &&\n@@ -4761,1 +4921,1 @@\n-        ((tap_xk && this_xk) ||\n+        ((other_xk && this_xk) ||\n@@ -4763,1 +4923,1 @@\n-         (tap_xk && !tap_klass->is_subtype_of(this_klass)) ||\n+         (other_xk && !other_ary->is_meet_subtype_of(this_ary)) ||\n@@ -4765,1 +4925,1 @@\n-         (this_xk && !this_klass->is_subtype_of(tap_klass)))) {\n+         (this_xk && !this_ary->is_meet_subtype_of(other_ary)))) {\n@@ -4773,0 +4933,1 @@\n+  }\n@@ -4775,1 +4936,1 @@\n-  switch (tap_ptr) {\n+  switch (other_ptr) {\n@@ -4782,1 +4943,1 @@\n-        res_xk = (tap_xk || this_xk);\n+        res_xk = (other_xk || this_xk);\n@@ -4792,1 +4953,1 @@\n-        res_xk = this_xk && (this_klass == tap_klass);\n+        res_xk = this_xk && (this_ary->is_same_java_type_as(other_ary) || (this_top_or_bottom && other_top_or_bottom));\n@@ -4800,1 +4961,1 @@\n-        res_xk = tap_xk;\n+        res_xk = other_xk;\n@@ -4802,2 +4963,2 @@\n-        res_xk = (tap_xk && this_xk) &&\n-          (this_klass == tap_klass); \/\/ Only precise for identical arrays\n+        res_xk = (other_xk && this_xk) &&\n+                 (this_ary->is_same_java_type_as(other_ary) || (this_top_or_bottom && other_top_or_bottom)); \/\/ Only precise for identical arrays\n@@ -4821,11 +4982,0 @@\n-\/\/----------------------interface_vs_oop---------------------------------------\n-#ifdef ASSERT\n-bool TypeAryPtr::interface_vs_oop(const Type *t) const {\n-  const TypeAryPtr* t_aryptr = t->isa_aryptr();\n-  if (t_aryptr) {\n-    return _ary->interface_vs_oop(t_aryptr->_ary);\n-  }\n-  return false;\n-}\n-#endif\n-\n@@ -4836,0 +4986,2 @@\n+  _interfaces.dump(st);\n+\n@@ -4889,1 +5041,1 @@\n-const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryPtr::add_offset(intptr_t offset) const {\n@@ -4909,1 +5061,1 @@\n-const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {\n+const TypePtr* TypeAryPtr::with_inline_depth(int depth) const {\n@@ -4916,1 +5068,1 @@\n-const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {\n+const TypePtr* TypeAryPtr::with_instance_id(int instance_id) const {\n@@ -5101,1 +5253,1 @@\n-const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {\n+const TypePtr* TypeMetadataPtr::add_offset( intptr_t offset ) const {\n@@ -5276,1 +5428,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass) {\n+const TypeKlassPtr* TypeKlassPtr::make(ciKlass *klass, InterfaceHandling interface_handling) {\n@@ -5278,1 +5430,1 @@\n-    return TypeInstKlassPtr::make(klass);\n+    return TypeInstKlassPtr::make(klass, interface_handling);\n@@ -5280,1 +5432,1 @@\n-  return TypeAryKlassPtr::make(klass);\n+  return TypeAryKlassPtr::make(klass, interface_handling);\n@@ -5283,1 +5435,1 @@\n-const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n+const TypeKlassPtr* TypeKlassPtr::make(PTR ptr, ciKlass* klass, int offset, InterfaceHandling interface_handling) {\n@@ -5285,1 +5437,2 @@\n-    return TypeInstKlassPtr::make(ptr, klass, offset);\n+    const InterfaceSet interfaces = TypePtr::interfaces(klass, true, true, false, interface_handling);\n+    return TypeInstKlassPtr::make(ptr, klass, interfaces, offset);\n@@ -5287,1 +5440,1 @@\n-  return TypeAryKlassPtr::make(ptr, klass, offset);\n+  return TypeAryKlassPtr::make(ptr, klass, offset, interface_handling);\n@@ -5292,2 +5445,4 @@\n-TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, int offset)\n-  : TypePtr(t, ptr, offset), _klass(klass) {\n+TypeKlassPtr::TypeKlassPtr(TYPES t, PTR ptr, ciKlass* klass, const InterfaceSet& interfaces, int offset)\n+  : TypePtr(t, ptr, offset), _klass(klass), _interfaces(interfaces) {\n+  assert(klass == NULL || !klass->is_loaded() || (klass->is_instance_klass() && !klass->is_interface()) ||\n+         klass->is_type_array_klass() || !klass->as_obj_array_klass()->base_element_klass()->is_interface(), \"no interface here\");\n@@ -5296,0 +5451,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5297,1 +5453,12 @@\n-  return _klass;\n+  assert(_klass->is_instance_klass() && !_klass->is_interface(), \"No interface\");\n+  if (_interfaces.empty()) {\n+    return _klass;\n+  }\n+  if (_klass != ciEnv::current()->Object_klass()) {\n+    ciKlass* k = _klass;\n+    if (_interfaces.eq(TypePtr::interfaces(k, true, false, true, ignore_interfaces))) {\n+      return _klass;\n+    }\n+    return NULL;\n+  }\n+  return _interfaces.exact_klass();\n@@ -5305,0 +5472,1 @@\n+    _interfaces.eq(p->_interfaces) &&\n@@ -5311,1 +5479,1 @@\n-  return TypePtr::hash();\n+  return java_add((jint)TypePtr::hash(), _interfaces.hash());\n@@ -5332,3 +5500,0 @@\n-    if (!empty() && ktkp != NULL && ktkp->klass()->is_loaded() && ktkp->klass()->is_interface())\n-      return kills;             \/\/ Uplift to interface\n-\n@@ -5338,9 +5503,0 @@\n-  \/\/ Interface klass type could be exact in opposite to interface type,\n-  \/\/ return it here instead of incorrect Constant ptr J\/L\/Object (6894807).\n-  if (ftkp != NULL && ktkp != NULL &&\n-      ftkp->is_loaded() &&  ftkp->klass()->is_interface() &&\n-      !ftkp->klass_is_exact() && \/\/ Keep exact interface klass\n-      ktkp->is_loaded() && !ktkp->klass()->is_interface()) {\n-    return ktkp->cast_to_ptr_type(ftkp->ptr());\n-  }\n-\n@@ -5350,0 +5506,11 @@\n+TypePtr::InterfaceSet TypeKlassPtr::meet_interfaces(const TypeKlassPtr* other) const {\n+  if (above_centerline(_ptr) && above_centerline(other->_ptr)) {\n+    return _interfaces.union_with(other->_interfaces);\n+  } else if (above_centerline(_ptr) && !above_centerline(other->_ptr)) {\n+    return other->_interfaces;\n+  } else if (above_centerline(other->_ptr) && !above_centerline(_ptr)) {\n+    return _interfaces;\n+  }\n+  return _interfaces.intersection_with(other->_interfaces);\n+}\n+\n@@ -5387,0 +5554,1 @@\n+      _interfaces.dump(st);\n@@ -5427,1 +5595,1 @@\n-const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, int offset) {\n+const TypeInstKlassPtr *TypeInstKlassPtr::make(PTR ptr, ciKlass* k, const InterfaceSet& interfaces, int offset) {\n@@ -5429,1 +5597,1 @@\n-    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, offset))->hashcons();\n+    (TypeInstKlassPtr*)(new TypeInstKlassPtr(ptr, k, interfaces, offset))->hashcons();\n@@ -5436,2 +5604,2 @@\n-const TypePtr *TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n-  return make( _ptr, klass(), xadd_offset(offset) );\n+const TypePtr* TypeInstKlassPtr::add_offset( intptr_t offset ) const {\n+  return make( _ptr, klass(), _interfaces, xadd_offset(offset) );\n@@ -5441,1 +5609,1 @@\n-  return make(_ptr, klass(), offset);\n+  return make(_ptr, klass(), _interfaces, offset);\n@@ -5448,1 +5616,1 @@\n-  return make(ptr, _klass, _offset);\n+  return make(ptr, _klass, _interfaces, _offset);\n@@ -5464,1 +5632,1 @@\n-  return make(klass_is_exact ? Constant : NotNull, k, _offset);\n+  return make(klass_is_exact ? Constant : NotNull, k, _interfaces, _offset);\n@@ -5479,0 +5647,1 @@\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n@@ -5487,3 +5656,8 @@\n-        deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n-        k = ik = sub;\n-        xk = sub->is_final();\n+        ciKlass* sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          xk = sub->is_final();\n+        }\n@@ -5493,1 +5667,1 @@\n-  return TypeInstPtr::make(TypePtr::BotPTR, k, xk, NULL, 0);\n+  return TypeInstPtr::make(TypePtr::BotPTR, k, interfaces, xk, NULL, 0);\n@@ -5534,1 +5708,1 @@\n-      return make( ptr, klass(), offset );\n+      return make( ptr, klass(), _interfaces, offset );\n@@ -5569,4 +5743,1 @@\n-    ciKlass* tkls_klass = tkls->klass();\n-    ciKlass* this_klass  = klass();\n-    bool tkls_xk = tkls->klass_is_exact();\n-    bool this_xk  = klass_is_exact();\n+    InterfaceSet interfaces = meet_interfaces(tkls);\n@@ -5576,1 +5747,1 @@\n-    switch(meet_instptr(ptr, this_klass, tkls_klass, this_xk, tkls_xk, this->_ptr, tkls->_ptr, res_klass, res_xk)) {\n+    switch(meet_instptr(ptr, interfaces, this, tkls, res_klass, res_xk)) {\n@@ -5584,2 +5755,2 @@\n-        const Type* res1 = make(ptr, res_klass, off);\n-        return res1;\n+        const Type* res = make(ptr, res_klass, interfaces, off);\n+        return res;\n@@ -5595,0 +5766,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -5602,1 +5776,1 @@\n-      if (klass()->equals(ciEnv::current()->Object_klass()) && !klass_is_exact()) {\n+      if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -5607,1 +5781,2 @@\n-        return make(ptr, ciEnv::current()->Object_klass(), offset);\n+        interfaces = _interfaces.intersection_with(tp->_interfaces);\n+        return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -5619,1 +5794,1 @@\n-        if (klass()->equals(ciEnv::current()->Object_klass())) {\n+        if (klass()->equals(ciEnv::current()->Object_klass()) && tp_interfaces.contains(this_interfaces) && !klass_is_exact()) {\n@@ -5629,1 +5804,2 @@\n-      return make(ptr, ciEnv::current()->Object_klass(), offset);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -5641,1 +5817,1 @@\n-  return new TypeInstKlassPtr(dual_ptr(), klass(), dual_offset());\n+  return new TypeInstKlassPtr(dual_ptr(), klass(), _interfaces, dual_offset());\n@@ -5644,2 +5820,3 @@\n-bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -5648,1 +5825,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -5656,1 +5833,1 @@\n-  if (other->_klass->equals(ciEnv::current()->Object_klass())) {\n+  if (other->klass()->equals(ciEnv::current()->Object_klass()) && other->_interfaces.empty()) {\n@@ -5660,3 +5837,2 @@\n-  if (!this_exact && klass()->is_interface()) {\n-    return false;\n-  }\n+  return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n+}\n@@ -5664,1 +5840,2 @@\n-  return _klass->is_subtype_of(other->_klass);\n+bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n@@ -5667,2 +5844,3 @@\n-bool TypeInstKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_instance(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n@@ -5671,1 +5849,1 @@\n-  if (!other->isa_instklassptr()) {\n+  if (!this_one->is_instance_type(other)) {\n@@ -5674,1 +5852,1 @@\n-  return _klass->equals(other->_klass);\n+  return this_one->_klass->equals(other->_klass) && this_one->_interfaces.eq(other->_interfaces);\n@@ -5677,4 +5855,3 @@\n-bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (!is_loaded() || !other->is_loaded()) {\n-    return true;\n-  }\n+bool TypeInstKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_instance(this, other);\n+}\n@@ -5682,2 +5859,4 @@\n-  if (other->isa_aryklassptr()) {\n-    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_instance(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (!this_one->is_loaded() || !other->is_loaded()) {\n+    return true;\n@@ -5686,2 +5865,2 @@\n-  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n-    return true;\n+  if (this_one->is_array_type(other)) {\n+    return !this_exact && this_one->_klass->equals(ciEnv::current()->Object_klass())  && other->_interfaces.contains(this_one->_interfaces);\n@@ -5690,1 +5869,1 @@\n-  assert(other->isa_instklassptr(), \"unsupported\");\n+  assert(this_one->is_instance_type(other), \"unsupported\");\n@@ -5693,1 +5872,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -5696,1 +5875,1 @@\n-  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n+  if (!this_one->_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(this_one->_klass)) {\n@@ -5701,1 +5880,1 @@\n-    return _klass->is_subtype_of(other->_klass);\n+    return this_one->_klass->is_subtype_of(other->_klass) && this_one->_interfaces.contains(other->_interfaces);\n@@ -5707,0 +5886,36 @@\n+bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_instance(this, other, this_exact, other_exact);\n+}\n+\n+const TypeKlassPtr* TypeInstKlassPtr::try_improve() const {\n+  if (!UseUniqueSubclasses) {\n+    return this;\n+  }\n+  ciKlass* k = klass();\n+  Compile* C = Compile::current();\n+  Dependencies* deps = C->dependencies();\n+  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+  TypePtr::InterfaceSet interfaces = _interfaces;\n+  if (k->is_loaded()) {\n+    ciInstanceKlass* ik = k->as_instance_klass();\n+    bool klass_is_exact = ik->is_final();\n+    if (!klass_is_exact &&\n+        deps != NULL) {\n+      ciInstanceKlass* sub = ik->unique_concrete_subklass();\n+      if (sub != NULL) {\n+        ciKlass *sub_k = sub;\n+        TypePtr::InterfaceSet sub_interfaces = TypePtr::interfaces(sub_k, true, false, false, ignore_interfaces);\n+        assert(sub_k == sub, \"\");\n+        if (sub_interfaces.eq(_interfaces)) {\n+          deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+          k = ik = sub;\n+          klass_is_exact = sub->is_final();\n+          return TypeKlassPtr::make(klass_is_exact ? Constant : _ptr, k, _offset);\n+        }\n+      }\n+    }\n+  }\n+  return this;\n+}\n+\n+\n@@ -5711,2 +5926,2 @@\n-const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* klass, int offset) {\n-  if (klass->is_obj_array_klass()) {\n+const TypeAryKlassPtr *TypeAryKlassPtr::make(PTR ptr, ciKlass* k, int offset, InterfaceHandling interface_handling) {\n+  if (k->is_obj_array_klass()) {\n@@ -5714,2 +5929,2 @@\n-    ciKlass* eklass = klass->as_obj_array_klass()->element_klass();\n-    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass)->cast_to_exactness(false);\n+    ciKlass* eklass = k->as_obj_array_klass()->element_klass();\n+    const TypeKlassPtr *etype = TypeKlassPtr::make(eklass, interface_handling)->cast_to_exactness(false);\n@@ -5717,1 +5932,1 @@\n-  } else if (klass->is_type_array_klass()) {\n+  } else if (k->is_type_array_klass()) {\n@@ -5719,2 +5934,2 @@\n-    const Type* etype = get_const_basic_type(klass->as_type_array_klass()->element_type());\n-    return TypeAryKlassPtr::make(ptr, etype, klass, offset);\n+    const Type* etype = get_const_basic_type(k->as_type_array_klass()->element_type());\n+    return TypeAryKlassPtr::make(ptr, etype, k, offset);\n@@ -5727,2 +5942,2 @@\n-const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass) {\n-  return TypeAryKlassPtr::make(Constant, klass, 0);\n+const TypeAryKlassPtr* TypeAryKlassPtr::make(ciKlass* klass, InterfaceHandling interface_handling) {\n+  return TypeAryKlassPtr::make(Constant, klass, 0, interface_handling);\n@@ -5760,2 +5975,1 @@\n-    \/\/ Compute array klass from element klass\n-    k_ary = ciObjArrayKlass::make(tinst->klass());\n+    \/\/ Leave k_ary at NULL.\n@@ -5763,5 +5977,1 @@\n-    \/\/ Compute array klass from element klass\n-    ciKlass* k_elem = tary->klass();\n-    \/\/ If element type is something like bottom[], k_elem will be null.\n-    if (k_elem != NULL)\n-      k_ary = ciObjArrayKlass::make(k_elem);\n+    \/\/ Leave k_ary at NULL.\n@@ -5825,5 +6035,0 @@\n-    if (UseCompressedOops && k_ary != NULL && k_ary->is_obj_array_klass() &&\n-        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n-        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n-      ((TypeAryPtr*)this)->_is_ptr_to_narrowoop = true;\n-    }\n@@ -5834,0 +6039,1 @@\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -5859,1 +6065,1 @@\n-const TypePtr *TypeAryKlassPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeAryKlassPtr::add_offset(intptr_t offset) const {\n@@ -5989,1 +6195,1 @@\n-    meet_aryptr(ptr, elem, this->klass(), tap->klass(), this->klass_is_exact(), tap->klass_is_exact(), this->ptr(), tap->ptr(), res_klass, res_xk);\n+    meet_aryptr(ptr, elem, this, tap, res_klass, res_xk);\n@@ -5997,0 +6203,3 @@\n+    InterfaceSet interfaces = meet_interfaces(tp);\n+    InterfaceSet tp_interfaces = tp->_interfaces;\n+    InterfaceSet this_interfaces = _interfaces;\n@@ -6004,1 +6213,1 @@\n-      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+      if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6009,1 +6218,2 @@\n-        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+        interfaces = this_interfaces.intersection_with(tp->_interfaces);\n+        return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -6021,1 +6231,1 @@\n-        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && !tp->klass_is_exact()) {\n+        if (tp->klass()->equals(ciEnv::current()->Object_klass()) && this_interfaces.intersection_with(tp_interfaces).eq(tp_interfaces) && !tp->klass_is_exact()) {\n@@ -6030,1 +6240,2 @@\n-      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), offset);\n+      interfaces = this_interfaces.intersection_with(tp_interfaces);\n+      return TypeInstKlassPtr::make(ptr, ciEnv::current()->Object_klass(), interfaces, offset);\n@@ -6039,2 +6250,4 @@\n-bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n+template <class T1, class T2> bool TypePtr::is_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6044,1 +6257,4 @@\n-  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6047,2 +6263,3 @@\n-  if (other->isa_instklassptr()) {\n-    return _klass->is_subtype_of(other->_klass) && other_exact;\n+\n+  if (this_one->is_instance_type(other)) {\n+    return other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces) && other_exact;\n@@ -6050,1 +6267,5 @@\n-  if (klass() == NULL) {\n+\n+  assert(this_one->is_array_type(other), \"\");\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n@@ -6053,4 +6274,5 @@\n-  assert(other->isa_aryklassptr(), \"\");\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->is_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (this_elem != NULL && other_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n@@ -6058,2 +6280,2 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (this_elem == NULL && other_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6064,3 +6286,18 @@\n-bool TypeAryKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n-  if (!other->isa_aryklassptr() ||\n-      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::is_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n+template <class T1, class T2> bool TypePtr::is_same_java_type_as_helper_for_array(const T1* this_one, const T2* other) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (!this_one->is_array_type(other) ||\n+      !this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n+    return false;\n+  }\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+\n+  if (other_top_or_bottom) {\n@@ -6069,3 +6306,5 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->is_same_java_type_as(other_ary->_elem->is_klassptr());\n+\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->is_same_java_type_as(this_one->is_reference_type(other_elem));\n@@ -6073,2 +6312,3 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->equals(other->_klass);\n+  if (other_elem == NULL && this_elem == NULL) {\n+    assert(this_one->_klass != NULL && other->_klass != NULL, \"\");\n+    return this_one->_klass->equals(other->_klass);\n@@ -6079,2 +6319,7 @@\n-bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n-  if (other->klass() == ciEnv::current()->Object_klass()) {\n+bool TypeAryKlassPtr::is_same_java_type_as_helper(const TypeKlassPtr* other) const {\n+  return TypePtr::is_same_java_type_as_helper_for_array(this, other);\n+}\n+\n+template <class T1, class T2> bool TypePtr::maybe_java_subtype_of_helper_for_array(const T1* this_one, const T2* other, bool this_exact, bool other_exact) {\n+  static_assert(std::is_base_of<T2, T1>::value, \"\");\n+  if (other->klass() == ciEnv::current()->Object_klass() && other->_interfaces.empty() && other_exact) {\n@@ -6083,1 +6328,3 @@\n-  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+  int dummy;\n+  bool this_top_or_bottom = (this_one->base_element_type(dummy) == Type::TOP || this_one->base_element_type(dummy) == Type::BOTTOM);\n+  if (!this_one->is_loaded() || !other->is_loaded() || this_top_or_bottom) {\n@@ -6086,2 +6333,2 @@\n-  if (other->isa_instklassptr()) {\n-    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n+  if (this_one->is_instance_type(other)) {\n+    return other->_klass->equals(ciEnv::current()->Object_klass()) && other->_interfaces.intersection_with(this_one->_interfaces).eq(other->_interfaces);\n@@ -6089,1 +6336,1 @@\n-  assert(other->isa_aryklassptr(), \"\");\n+  assert(this_one->is_array_type(other), \"\");\n@@ -6091,0 +6338,5 @@\n+  const T1* other_ary = this_one->is_array_type(other);\n+  bool other_top_or_bottom = (other_ary->base_element_type(dummy) == Type::TOP || other_ary->base_element_type(dummy) == Type::BOTTOM);\n+  if (other_top_or_bottom) {\n+    return true;\n+  }\n@@ -6092,1 +6344,1 @@\n-    return is_java_subtype_of(other);\n+    return this_one->is_java_subtype_of(other);\n@@ -6095,3 +6347,4 @@\n-  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n-  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n-    return _elem->is_klassptr()->maybe_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+  const TypePtr* this_elem = this_one->elem()->make_ptr();\n+  const TypePtr* other_elem = other_ary->elem()->make_ptr();\n+  if (other_elem != NULL && this_elem != NULL) {\n+    return this_one->is_reference_type(this_elem)->maybe_java_subtype_of_helper(this_one->is_reference_type(other_elem), this_exact, other_exact);\n@@ -6099,2 +6352,2 @@\n-  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n-    return _klass->is_subtype_of(other->_klass);\n+  if (other_elem == NULL && this_elem == NULL) {\n+    return this_one->_klass->is_subtype_of(other->_klass);\n@@ -6105,0 +6358,4 @@\n+bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  return TypePtr::maybe_java_subtype_of_helper_for_array(this, other, this_exact, other_exact);\n+}\n+\n@@ -6111,1 +6368,1 @@\n-\/\/------------------------------get_con----------------------------------------\n+\/\/ Is there a single ciKlass* that can represent that type?\n@@ -6131,5 +6388,1 @@\n-    k = elem()->is_klassptr()->klass();\n-    if (k != NULL) {\n-      k = ciObjArrayKlass::make(k);\n-      ((TypeAryKlassPtr*)this)->_klass = k;\n-    }\n+    \/\/ leave NULL\n@@ -6140,0 +6393,1 @@\n+    ((TypeAryKlassPtr*)this)->_klass = k;\n@@ -6155,0 +6409,1 @@\n+      _interfaces.dump(st);\n@@ -6203,1 +6458,1 @@\n-    domain = TypeTuple::make_domain(NULL, method->signature());\n+    domain = TypeTuple::make_domain(NULL, method->signature(), ignore_interfaces);\n@@ -6205,1 +6460,1 @@\n-    domain = TypeTuple::make_domain(method->holder(), method->signature());\n+    domain = TypeTuple::make_domain(method->holder(), method->signature(), ignore_interfaces);\n@@ -6207,1 +6462,1 @@\n-  const TypeTuple *range  = TypeTuple::make_range(method->signature());\n+  const TypeTuple *range  = TypeTuple::make_range(method->signature(), ignore_interfaces);\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":829,"deletions":574,"binary":false,"changes":1403,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,1 @@\n-  if (p != NULL) {\n+  if (p != nullptr) {\n@@ -384,1 +384,1 @@\n-    if (StubRoutines::unsafe_arraycopy() != NULL) {\n+    if (StubRoutines::unsafe_arraycopy() != nullptr) {\n@@ -401,1 +401,1 @@\n-  if (srcObj == NULL && dstObj == NULL) {\n+  if (srcObj == nullptr && dstObj == nullptr) {\n@@ -438,1 +438,1 @@\n-  assert(StubRoutines::data_cache_writeback() != NULL, \"sanity\");\n+  assert(StubRoutines::data_cache_writeback() != nullptr, \"sanity\");\n@@ -445,1 +445,1 @@\n-  assert(StubRoutines::data_cache_writeback_sync() != NULL, \"sanity\");\n+  assert(StubRoutines::data_cache_writeback_sync() != nullptr, \"sanity\");\n@@ -474,2 +474,2 @@\n-  assert(clazz != NULL, \"clazz must not be NULL\");\n-  assert(name != NULL, \"name must not be NULL\");\n+  assert(clazz != nullptr, \"clazz must not be null\");\n+  assert(name != nullptr, \"name must not be null\");\n@@ -497,1 +497,1 @@\n-  assert(field != NULL, \"field must not be NULL\");\n+  assert(field != nullptr, \"field must not be null\");\n@@ -529,1 +529,1 @@\n-  assert(field != NULL, \"field must not be NULL\");\n+  assert(field != nullptr, \"field must not be null\");\n@@ -536,1 +536,1 @@\n-  \/\/ large.  In that last case, this function would return NULL, since\n+  \/\/ large.  In that last case, this function would return null, since\n@@ -551,1 +551,1 @@\n-  assert(clazz != NULL, \"clazz must not be NULL\");\n+  assert(clazz != nullptr, \"clazz must not be null\");\n@@ -556,1 +556,1 @@\n-  if (klass != NULL && klass->should_be_initialized()) {\n+  if (klass != nullptr && klass->should_be_initialized()) {\n@@ -564,1 +564,1 @@\n-  assert(clazz != NULL, \"clazz must not be NULL\");\n+  assert(clazz != nullptr, \"clazz must not be null\");\n@@ -569,1 +569,1 @@\n-  if (klass != NULL && klass->should_be_initialized()) {\n+  if (klass != nullptr && klass->should_be_initialized()) {\n@@ -578,1 +578,1 @@\n-  assert(clazz != NULL, \"clazz must not be NULL\");\n+  assert(clazz != nullptr, \"clazz must not be null\");\n@@ -583,1 +583,1 @@\n-  if (k == NULL || !k->is_array_klass()) {\n+  if (k == nullptr || !k->is_array_klass()) {\n@@ -636,1 +636,1 @@\n-  env->ThrowNew(cls, NULL);\n+  env->ThrowNew(cls, nullptr);\n@@ -643,1 +643,1 @@\n-  char *utfName = NULL;\n+  char *utfName = nullptr;\n@@ -647,1 +647,1 @@\n-  assert(data != NULL, \"Class bytes must not be NULL\");\n+  assert(data != nullptr, \"Class bytes must not be null\");\n@@ -655,1 +655,1 @@\n-  if (body == NULL) {\n+  if (body == nullptr) {\n@@ -665,1 +665,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -671,1 +671,1 @@\n-      if (utfName == NULL) {\n+      if (utfName == nullptr) {\n@@ -755,2 +755,2 @@\n-  assert(event != NULL, \"invariant\");\n-  event->set_parkedClass((obj != NULL) ? obj->klass() : NULL);\n+  assert(event != nullptr, \"invariant\");\n+  event->set_parkedClass((obj != nullptr) ? obj->klass() : nullptr);\n@@ -759,1 +759,1 @@\n-  event->set_address((obj != NULL) ? (u8)cast_from_oop<uintptr_t>(obj) : 0);\n+  event->set_address((obj != nullptr) ? (u8)cast_from_oop<uintptr_t>(obj) : 0);\n@@ -785,1 +785,1 @@\n-  if (jthread != NULL) {\n+  if (jthread != nullptr) {\n@@ -787,2 +787,2 @@\n-    JavaThread* thr = NULL;\n-    oop java_thread = NULL;\n+    JavaThread* thr = nullptr;\n+    oop java_thread = nullptr;\n@@ -790,1 +790,1 @@\n-    if (java_thread != NULL) {\n+    if (java_thread != nullptr) {\n@@ -792,1 +792,1 @@\n-      if (thr != NULL) {\n+      if (thr != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,2 +75,2 @@\n-char*  Arguments::_jvm_flags_file               = NULL;\n-char** Arguments::_jvm_flags_array              = NULL;\n+char*  Arguments::_jvm_flags_file               = nullptr;\n+char** Arguments::_jvm_flags_array              = nullptr;\n@@ -78,1 +78,1 @@\n-char** Arguments::_jvm_args_array               = NULL;\n+char** Arguments::_jvm_args_array               = nullptr;\n@@ -80,2 +80,2 @@\n-char*  Arguments::_java_command                 = NULL;\n-SystemProperty* Arguments::_system_properties   = NULL;\n+char*  Arguments::_java_command                 = nullptr;\n+SystemProperty* Arguments::_system_properties   = nullptr;\n@@ -86,1 +86,1 @@\n-const char*  Arguments::_java_vendor_url_bug    = NULL;\n+const char*  Arguments::_java_vendor_url_bug    = nullptr;\n@@ -99,2 +99,2 @@\n-char*  Arguments::SharedArchivePath             = NULL;\n-char*  Arguments::SharedDynamicArchivePath      = NULL;\n+char*  Arguments::SharedArchivePath             = nullptr;\n+char*  Arguments::SharedDynamicArchivePath      = nullptr;\n@@ -110,3 +110,3 @@\n-abort_hook_t     Arguments::_abort_hook         = NULL;\n-exit_hook_t      Arguments::_exit_hook          = NULL;\n-vfprintf_hook_t  Arguments::_vfprintf_hook      = NULL;\n+abort_hook_t     Arguments::_abort_hook         = nullptr;\n+exit_hook_t      Arguments::_exit_hook          = nullptr;\n+vfprintf_hook_t  Arguments::_vfprintf_hook      = nullptr;\n@@ -115,6 +115,6 @@\n-SystemProperty *Arguments::_sun_boot_library_path = NULL;\n-SystemProperty *Arguments::_java_library_path = NULL;\n-SystemProperty *Arguments::_java_home = NULL;\n-SystemProperty *Arguments::_java_class_path = NULL;\n-SystemProperty *Arguments::_jdk_boot_class_path_append = NULL;\n-SystemProperty *Arguments::_vm_info = NULL;\n+SystemProperty *Arguments::_sun_boot_library_path = nullptr;\n+SystemProperty *Arguments::_java_library_path = nullptr;\n+SystemProperty *Arguments::_java_home = nullptr;\n+SystemProperty *Arguments::_java_class_path = nullptr;\n+SystemProperty *Arguments::_jdk_boot_class_path_append = nullptr;\n+SystemProperty *Arguments::_vm_info = nullptr;\n@@ -122,2 +122,2 @@\n-GrowableArray<ModulePatchPath*> *Arguments::_patch_mod_prefix = NULL;\n-PathString *Arguments::_boot_class_path = NULL;\n+GrowableArray<ModulePatchPath*> *Arguments::_patch_mod_prefix = nullptr;\n+PathString *Arguments::_boot_class_path = nullptr;\n@@ -126,1 +126,1 @@\n-char* Arguments::_ext_dirs = NULL;\n+char* Arguments::_ext_dirs = nullptr;\n@@ -133,1 +133,1 @@\n-  if (new_value == NULL) {\n+  if (new_value == nullptr) {\n@@ -137,1 +137,1 @@\n-  if (_value != NULL) {\n+  if (_value != nullptr) {\n@@ -148,1 +148,1 @@\n-  if (value != NULL) {\n+  if (value != nullptr) {\n@@ -150,1 +150,1 @@\n-    if (_value != NULL) {\n+    if (_value != nullptr) {\n@@ -154,3 +154,3 @@\n-    assert(sp != NULL, \"Unable to allocate space for new append path value\");\n-    if (sp != NULL) {\n-      if (_value != NULL) {\n+    assert(sp != nullptr, \"Unable to allocate space for new append path value\");\n+    if (sp != nullptr) {\n+      if (_value != nullptr) {\n@@ -170,2 +170,2 @@\n-  if (value == NULL) {\n-    _value = NULL;\n+  if (value == nullptr) {\n+    _value = nullptr;\n@@ -179,1 +179,1 @@\n-  if (_value != NULL) {\n+  if (_value != nullptr) {\n@@ -181,1 +181,1 @@\n-    _value = NULL;\n+    _value = nullptr;\n@@ -186,1 +186,1 @@\n-  assert(module_name != NULL && path != NULL, \"Invalid module name or path value\");\n+  assert(module_name != nullptr && path != nullptr, \"Invalid module name or path value\");\n@@ -194,1 +194,1 @@\n-  if (_module_name != NULL) {\n+  if (_module_name != nullptr) {\n@@ -196,1 +196,1 @@\n-    _module_name = NULL;\n+    _module_name = nullptr;\n@@ -198,1 +198,1 @@\n-  if (_path != NULL) {\n+  if (_path != nullptr) {\n@@ -200,1 +200,1 @@\n-    _path = NULL;\n+    _path = nullptr;\n@@ -205,2 +205,2 @@\n-  if (key == NULL) {\n-    _key = NULL;\n+  if (key == nullptr) {\n+    _key = nullptr;\n@@ -211,1 +211,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -221,2 +221,2 @@\n-  if (options == NULL) {\n-    _options = NULL;\n+  if (options == nullptr) {\n+    _options = nullptr;\n@@ -229,1 +229,1 @@\n-  _next = NULL;\n+  _next = nullptr;\n@@ -250,1 +250,1 @@\n-  const char* tail = NULL;\n+  const char* tail = nullptr;\n@@ -252,1 +252,1 @@\n-  if (tail != NULL && *tail == '\\0') {\n+  if (tail != nullptr && *tail == '\\0') {\n@@ -264,1 +264,1 @@\n-  for (\/* empty *\/; *names != NULL; ++names) {\n+  for (\/* empty *\/; *names != nullptr; ++names) {\n@@ -279,2 +279,2 @@\n-  assert((*option)->optionString != NULL, \"invariant\");\n-  char* tail = NULL;\n+  assert((*option)->optionString != nullptr, \"invariant\");\n+  char* tail = nullptr;\n@@ -326,1 +326,1 @@\n-  _libraryList.add(new AgentLibrary(name, options, false, NULL));\n+  _libraryList.add(new AgentLibrary(name, options, false, nullptr));\n@@ -330,1 +330,1 @@\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, NULL));\n+  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr));\n@@ -334,1 +334,1 @@\n-  _agentList.add(new AgentLibrary(name, options, absolute_path, NULL, true));\n+  _agentList.add(new AgentLibrary(name, options, absolute_path, nullptr, true));\n@@ -398,1 +398,1 @@\n-  _boot_class_path = new PathString(NULL);\n+  _boot_class_path = new PathString(nullptr);\n@@ -410,1 +410,1 @@\n-  \/\/ Properties values are set to NULL and they are\n+  \/\/ Properties values are set to nullptr and they are\n@@ -412,3 +412,3 @@\n-  _sun_boot_library_path = new SystemProperty(\"sun.boot.library.path\", NULL,  true);\n-  _java_library_path = new SystemProperty(\"java.library.path\", NULL,  true);\n-  _java_home =  new SystemProperty(\"java.home\", NULL,  true);\n+  _sun_boot_library_path = new SystemProperty(\"sun.boot.library.path\", nullptr,  true);\n+  _java_library_path = new SystemProperty(\"java.library.path\", nullptr,  true);\n+  _java_home =  new SystemProperty(\"java.home\", nullptr,  true);\n@@ -420,1 +420,1 @@\n-  _jdk_boot_class_path_append = new SystemProperty(\"jdk.boot.class.path.append\", NULL, false, true);\n+  _jdk_boot_class_path_append = new SystemProperty(\"jdk.boot.class.path.append\", nullptr, false, true);\n@@ -573,1 +573,1 @@\n-  { NULL, JDK_Version(0), JDK_Version(0) }\n+  { nullptr, JDK_Version(0), JDK_Version(0) }\n@@ -585,1 +585,1 @@\n-  { NULL, NULL}\n+  { nullptr, nullptr}\n@@ -599,1 +599,1 @@\n-  for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {\n+  for (size_t i = 0; special_jvm_flags[i].name != nullptr; i++) {\n@@ -609,1 +609,1 @@\n-  assert(version != NULL, \"Must provide a version buffer\");\n+  assert(version != nullptr, \"Must provide a version buffer\");\n@@ -620,1 +620,1 @@\n-        if (real_flag != NULL) {\n+        if (real_flag != nullptr) {\n@@ -635,1 +635,1 @@\n-  assert(version != NULL, \"Must provide a version buffer\");\n+  assert(version != nullptr, \"Must provide a version buffer\");\n@@ -652,1 +652,1 @@\n-  for (size_t i = 0; aliased_jvm_flags[i].alias_name != NULL; i++) {\n+  for (size_t i = 0; aliased_jvm_flags[i].alias_name != nullptr; i++) {\n@@ -663,1 +663,1 @@\n-  for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {\n+  for (size_t i = 0; special_jvm_flags[i].name != nullptr; i++) {\n@@ -692,1 +692,1 @@\n-  for (size_t i = 0; special_jvm_flags[i].name != NULL; i++) {\n+  for (size_t i = 0; special_jvm_flags[i].name != nullptr; i++) {\n@@ -725,1 +725,1 @@\n-        if (JVMFlag::find_declared_flag(flag.name) != NULL) {\n+        if (JVMFlag::find_declared_flag(flag.name) != nullptr) {\n@@ -740,1 +740,1 @@\n-        if (JVMFlag::find_declared_flag(flag.name) != NULL) {\n+        if (JVMFlag::find_declared_flag(flag.name) != nullptr) {\n@@ -849,1 +849,1 @@\n-    value = NULL;\n+    value = nullptr;\n@@ -860,1 +860,1 @@\n-  size_t old_len = old_value != NULL ? strlen(old_value) : 0;\n+  size_t old_len = old_value != nullptr ? strlen(old_value) : 0;\n@@ -863,1 +863,1 @@\n-  char* free_this_too = NULL;\n+  char* free_this_too = nullptr;\n@@ -897,1 +897,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -915,1 +915,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -924,1 +924,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -933,2 +933,2 @@\n-  if (real_name == NULL) {\n-    return NULL;\n+  if (real_name == nullptr) {\n+    return nullptr;\n@@ -966,1 +966,1 @@\n-  if (flag == NULL) {\n+  if (flag == nullptr) {\n@@ -1003,1 +1003,1 @@\n-  assert(bldarray != NULL, \"illegal argument\");\n+  assert(bldarray != nullptr, \"illegal argument\");\n@@ -1005,1 +1005,1 @@\n-  if (arg == NULL) {\n+  if (arg == nullptr) {\n@@ -1012,1 +1012,1 @@\n-  if (*bldarray == NULL) {\n+  if (*bldarray == nullptr) {\n@@ -1032,2 +1032,2 @@\n-  if (args == NULL || count == 0) {\n-    return NULL;\n+  if (args == nullptr || count == 0) {\n+    return nullptr;\n@@ -1037,1 +1037,1 @@\n-    length += strlen(args[i]) + 1; \/\/ add 1 for a space or NULL terminating character\n+    length += strlen(args[i]) + 1; \/\/ add 1 for a space or null terminating character\n@@ -1042,2 +1042,2 @@\n-    size_t offset = strlen(args[j]) + 1; \/\/ add 1 for a space or NULL terminating character\n-    jio_snprintf(dst, length, \"%s \", args[j]); \/\/ jio_snprintf will replace the last space character with NULL character\n+    size_t offset = strlen(args[j]) + 1; \/\/ add 1 for a space or null terminating character\n+    jio_snprintf(dst, length, \"%s \", args[j]); \/\/ jio_snprintf will replace the last space character with null character\n@@ -1061,1 +1061,1 @@\n-  if (_java_class_path != NULL) {\n+  if (_java_class_path != nullptr) {\n@@ -1090,1 +1090,1 @@\n-  if (java_command() != NULL) {\n+  if (java_command() != nullptr) {\n@@ -1127,1 +1127,1 @@\n-  if (equal_sign == NULL) {\n+  if (equal_sign == nullptr) {\n@@ -1149,1 +1149,1 @@\n-  if (found_flag != NULL) {\n+  if (found_flag != nullptr) {\n@@ -1180,1 +1180,1 @@\n-    if (fuzzy_matched != NULL) {\n+    if (fuzzy_matched != nullptr) {\n@@ -1195,1 +1195,1 @@\n-  if (stream == NULL) {\n+  if (stream == nullptr) {\n@@ -1269,1 +1269,1 @@\n-  if (eq == NULL) {\n+  if (eq == nullptr) {\n@@ -1313,1 +1313,1 @@\n-      if (old_java_command != NULL) {\n+      if (old_java_command != nullptr) {\n@@ -1326,1 +1326,1 @@\n-      if (old_java_vendor_url_bug != NULL) {\n+      if (old_java_vendor_url_bug != nullptr) {\n@@ -1358,1 +1358,1 @@\n-  while (sp != NULL) {\n+  while (sp != nullptr) {\n@@ -1377,1 +1377,1 @@\n-  if (ArchiveClassesAtExit != NULL) {\n+  if (ArchiveClassesAtExit != nullptr) {\n@@ -1385,1 +1385,1 @@\n-    if (get_property(unsupported_properties[i]) != NULL) {\n+    if (get_property(unsupported_properties[i]) != nullptr) {\n@@ -1478,1 +1478,1 @@\n-  \/\/ We need to fit both the NULL page and the heap into the memory budget, while\n+  \/\/ We need to fit both the null page and the heap into the memory budget, while\n@@ -1480,1 +1480,1 @@\n-  \/\/ NULL page is located before the heap, we pad the NULL page to the conservative\n+  \/\/ null page is located before the heap, we pad the null page to the conservative\n@@ -1893,1 +1893,1 @@\n-  assert(_sun_java_launcher != NULL, \"property must have value\");\n+  assert(_sun_java_launcher != nullptr, \"property must have value\");\n@@ -1984,1 +1984,1 @@\n-  if (option_type == NULL) {\n+  if (option_type == nullptr) {\n@@ -2142,1 +2142,1 @@\n-    if ((_name = strrchr(name, (int) *os::file_separator())) == NULL) {\n+    if ((_name = strrchr(name, (int) *os::file_separator())) == nullptr) {\n@@ -2179,1 +2179,1 @@\n-  assert(patch_mod_tail != NULL, \"Unexpected NULL patch-module value\");\n+  assert(patch_mod_tail != nullptr, \"Unexpected null patch-module value\");\n@@ -2182,1 +2182,1 @@\n-  if (module_equal == NULL) {\n+  if (module_equal == nullptr) {\n@@ -2189,1 +2189,1 @@\n-    if (module_name != NULL) {\n+    if (module_name != nullptr) {\n@@ -2228,1 +2228,1 @@\n-    bool silent = (option == NULL); \/\/ Allow testing to silence error messages\n+    bool silent = (option == nullptr); \/\/ Allow testing to silence error messages\n@@ -2330,1 +2330,1 @@\n-      if (tail != NULL) {\n+      if (tail != nullptr) {\n@@ -2332,1 +2332,1 @@\n-        size_t len = (pos == NULL) ? strlen(tail) : pos - tail;\n+        size_t len = (pos == nullptr) ? strlen(tail) : pos - tail;\n@@ -2336,2 +2336,2 @@\n-        char *options = NULL;\n-        if(pos != NULL) {\n+        char *options = nullptr;\n+        if(pos != nullptr) {\n@@ -2395,1 +2395,1 @@\n-      if(tail != NULL) {\n+      if(tail != nullptr) {\n@@ -2398,1 +2398,1 @@\n-        if (pos == NULL) {\n+        if (pos == nullptr) {\n@@ -2407,2 +2407,2 @@\n-        char *options = NULL;\n-        if(pos != NULL) {\n+        char *options = nullptr;\n+        if(pos != nullptr) {\n@@ -2427,1 +2427,1 @@\n-      if (tail != NULL) {\n+      if (tail != nullptr) {\n@@ -2862,1 +2862,1 @@\n-      if (jvmciFlag != NULL && jvmciFlag->is_unlocked()) {\n+      if (jvmciFlag != nullptr && jvmciFlag->is_unlocked()) {\n@@ -2921,1 +2921,1 @@\n-  if (_patch_mod_prefix == NULL) {\n+  if (_patch_mod_prefix == nullptr) {\n@@ -2975,1 +2975,1 @@\n-  if (dir != NULL) {\n+  if (dir != nullptr) {\n@@ -2985,1 +2985,1 @@\n-  if (dir != NULL) {\n+  if (dir != nullptr) {\n@@ -3064,1 +3064,1 @@\n-  if (ArchiveClassesAtExit != NULL && RecordDynamicDumpInfo) {\n+  if (ArchiveClassesAtExit != nullptr && RecordDynamicDumpInfo) {\n@@ -3070,1 +3070,1 @@\n-  if (ArchiveClassesAtExit == NULL && !RecordDynamicDumpInfo) {\n+  if (ArchiveClassesAtExit == nullptr && !RecordDynamicDumpInfo) {\n@@ -3077,1 +3077,1 @@\n-    if (SharedArchiveFile == NULL) {\n+    if (SharedArchiveFile == nullptr) {\n@@ -3081,1 +3081,1 @@\n-    if (ArchiveClassesAtExit != NULL) {\n+    if (ArchiveClassesAtExit != nullptr) {\n@@ -3127,1 +3127,1 @@\n-    _args.options = NULL;\n+    _args.options = nullptr;\n@@ -3131,1 +3131,1 @@\n-    _vm_options_file_arg = NULL;\n+    _vm_options_file_arg = nullptr;\n@@ -3143,1 +3143,1 @@\n-    if (options_arr == NULL) {\n+    if (options_arr == nullptr) {\n@@ -3151,1 +3151,1 @@\n-      if (options_arr[i].optionString == NULL) {\n+      if (options_arr[i].optionString == nullptr) {\n@@ -3166,1 +3166,1 @@\n-  bool  found_vm_options_file_arg() { return _vm_options_file_arg != NULL; }\n+  bool  found_vm_options_file_arg() { return _vm_options_file_arg != nullptr; }\n@@ -3170,1 +3170,1 @@\n-    if (_vm_options_file_arg != NULL) {\n+    if (_vm_options_file_arg != nullptr) {\n@@ -3177,1 +3177,1 @@\n-    if (_vm_options_file_arg != NULL) {\n+    if (_vm_options_file_arg != nullptr) {\n@@ -3180,1 +3180,1 @@\n-    if (_args.options == NULL) return;\n+    if (_args.options == nullptr) return;\n@@ -3192,1 +3192,1 @@\n-    assert(_args.options == NULL, \"shouldn't be set yet\");\n+    assert(_args.options == nullptr, \"shouldn't be set yet\");\n@@ -3229,1 +3229,1 @@\n-  if (buffer == NULL || os::have_special_privileges()) {\n+  if (buffer == nullptr || os::have_special_privileges()) {\n@@ -3233,1 +3233,1 @@\n-  if ((buffer = os::strdup(buffer)) == NULL) {\n+  if ((buffer = os::strdup(buffer)) == nullptr) {\n@@ -3272,1 +3272,1 @@\n-  \/\/ '+ 1' for NULL termination even with max bytes\n+  \/\/ '+ 1' for null termination even with max bytes\n@@ -3276,1 +3276,1 @@\n-  if (NULL == buf) {\n+  if (nullptr == buf) {\n@@ -3356,1 +3356,1 @@\n-    \/\/ steal a white space character and set it to NULL\n+    \/\/ steal a white space character and set it to null\n@@ -3362,1 +3362,1 @@\n-    option.extraInfo = NULL;\n+    option.extraInfo = nullptr;\n@@ -3399,1 +3399,1 @@\n-  if (end != NULL) *end = '\\0';\n+  if (end != nullptr) *end = '\\0';\n@@ -3411,1 +3411,1 @@\n-  if (archive_path == NULL) {\n+  if (archive_path == nullptr) {\n@@ -3430,1 +3430,1 @@\n-  if (end_ptr == NULL || end_ptr == begin_ptr) {\n+  if (end_ptr == nullptr || end_ptr == begin_ptr) {\n@@ -3444,1 +3444,1 @@\n-  assert(end_ptr != NULL, \"sanity\");\n+  assert(end_ptr != nullptr, \"sanity\");\n@@ -3496,1 +3496,1 @@\n-        char* base_archive_path = NULL;\n+        char* base_archive_path = nullptr;\n@@ -3514,1 +3514,1 @@\n-        } else if (base_archive_path == NULL) {\n+        } else if (base_archive_path == nullptr) {\n@@ -3525,2 +3525,2 @@\n-        if (SharedArchivePath == NULL) {\n-          assert(SharedDynamicArchivePath == NULL, \"must be\");\n+        if (SharedArchivePath == nullptr) {\n+          assert(SharedDynamicArchivePath == nullptr, \"must be\");\n@@ -3739,1 +3739,1 @@\n-    return LogConfiguration::parse_log_arguments(_legacyGCLogging.file, gc_conf, NULL, NULL, &errstream);\n+    return LogConfiguration::parse_log_arguments(_legacyGCLogging.file, gc_conf, nullptr, nullptr, &errstream);\n@@ -3811,1 +3811,1 @@\n-  if (vmoptions != NULL) {\n+  if (vmoptions != nullptr) {\n@@ -3848,1 +3848,1 @@\n-  settings_file_specified = (flags_file != NULL);\n+  settings_file_specified = (flags_file != nullptr);\n@@ -3946,1 +3946,1 @@\n-  if (DumpLoadedClassList != NULL) {\n+  if (DumpLoadedClassList != nullptr) {\n@@ -3964,1 +3964,1 @@\n-                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", NULL);\n+                \"Syntax error, expecting -XX:NativeMemoryTracking=[off|summary|detail]\", nullptr);\n@@ -4098,1 +4098,1 @@\n-  while(pl != NULL) {\n+  while(pl != nullptr) {\n@@ -4108,1 +4108,1 @@\n-  while(pl != NULL) {\n+  while(pl != nullptr) {\n@@ -4118,1 +4118,1 @@\n-  assert(key != NULL, \"just checking\");\n+  assert(key != nullptr, \"just checking\");\n@@ -4120,1 +4120,1 @@\n-  for (prop = pl; prop != NULL; prop = prop->next()) {\n+  for (prop = pl; prop != nullptr; prop = prop->next()) {\n@@ -4123,1 +4123,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4128,1 +4128,1 @@\n-  assert(key != NULL, \"just checking\");\n+  assert(key != nullptr, \"just checking\");\n@@ -4132,1 +4132,1 @@\n-  for (prop = pl; prop != NULL; prop = prop->next()) {\n+  for (prop = pl; prop != nullptr; prop = prop->next()) {\n@@ -4139,2 +4139,2 @@\n-        \/\/ Property is internal and not jdk.boot.class.path.append so return NULL.\n-        return NULL;\n+        \/\/ Property is internal and not jdk.boot.class.path.append so return null.\n+        return nullptr;\n@@ -4144,1 +4144,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -4149,1 +4149,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -4152,1 +4152,1 @@\n-    while (p->next() != NULL) {\n+    while (p->next() != nullptr) {\n@@ -4161,1 +4161,1 @@\n-  if (plist == NULL)\n+  if (plist == nullptr)\n@@ -4176,1 +4176,1 @@\n-  if (plist == NULL)\n+  if (plist == nullptr)\n@@ -4182,1 +4182,1 @@\n-  for (prop = *plist; prop != NULL; prop = prop->next()) {\n+  for (prop = *plist; prop != nullptr; prop = prop->next()) {\n@@ -4201,1 +4201,1 @@\n-\/\/ NULL terminator character is not long enough for holding the expanded\n+\/\/ null terminator character is not long enough for holding the expanded\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":167,"deletions":167,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,0 +360,3 @@\n+  product(bool, UseVectorizedHashCodeIntrinsic, false, DIAGNOSTIC,           \\\n+          \"Enables intrinsification of ArraysSupport.vectorizedHashCode()\") \\\n+                                                                            \\\n@@ -544,1 +547,1 @@\n-  product(ccstr, HeapDumpPath, NULL, MANAGEABLE,                            \\\n+  product(ccstr, HeapDumpPath, nullptr, MANAGEABLE,                            \\\n@@ -598,1 +601,1 @@\n-  product(ccstr, PrintAssemblyOptions, NULL, DIAGNOSTIC,                    \\\n+  product(ccstr, PrintAssemblyOptions, nullptr, DIAGNOSTIC,                    \\\n@@ -626,1 +629,1 @@\n-          \"Start debugger when an implicit OS (e.g. NULL) \"                 \\\n+          \"Start debugger when an implicit OS (e.g. nullptr) \"                 \\\n@@ -832,1 +835,1 @@\n-  product(ccstr, TraceJVMTI, NULL,                                          \\\n+  product(ccstr, TraceJVMTI, nullptr,                                          \\\n@@ -944,3 +947,0 @@\n-  develop(bool, GenerateRangeChecks, true,                                  \\\n-          \"Generate range checks for array accesses\")                       \\\n-                                                                            \\\n@@ -1035,1 +1035,1 @@\n-  product(ccstr, LogFile, NULL, DIAGNOSTIC,                                 \\\n+  product(ccstr, LogFile, nullptr, DIAGNOSTIC,                                 \\\n@@ -1039,1 +1039,1 @@\n-  product(ccstr, ErrorFile, NULL,                                           \\\n+  product(ccstr, ErrorFile, nullptr,                                           \\\n@@ -1076,1 +1076,1 @@\n-  product(ccstr, AbortVMOnException, NULL, DIAGNOSTIC,                      \\\n+  product(ccstr, AbortVMOnException, nullptr, DIAGNOSTIC,                      \\\n@@ -1080,1 +1080,1 @@\n-  product(ccstr, AbortVMOnExceptionMessage, NULL, DIAGNOSTIC,               \\\n+  product(ccstr, AbortVMOnExceptionMessage, nullptr, DIAGNOSTIC,               \\\n@@ -1744,1 +1744,1 @@\n-  product(ccstr, PerfDataSaveFile, NULL,                                    \\\n+  product(ccstr, PerfDataSaveFile, nullptr,                                    \\\n@@ -1824,1 +1824,1 @@\n-  product(ccstr, PauseAtStartupFile, NULL, DIAGNOSTIC,                      \\\n+  product(ccstr, PauseAtStartupFile, nullptr, DIAGNOSTIC,                      \\\n@@ -1931,1 +1931,1 @@\n-  product(ccstr, AllocateHeapAt, NULL,                                      \\\n+  product(ccstr, AllocateHeapAt, nullptr,                                      \\\n@@ -1966,1 +1966,1 @@\n-  JFR_ONLY(product(ccstr, FlightRecorderOptions, NULL,                      \\\n+  JFR_ONLY(product(ccstr, FlightRecorderOptions, nullptr,                      \\\n@@ -1969,1 +1969,1 @@\n-  JFR_ONLY(product(ccstr, StartFlightRecording, NULL,                       \\\n+  JFR_ONLY(product(ccstr, StartFlightRecording, nullptr,                       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,1 +150,1 @@\n-OopStorage* JavaThread::_thread_oop_storage = NULL;\n+OopStorage* JavaThread::_thread_oop_storage = nullptr;\n@@ -153,1 +153,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -158,1 +158,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -161,2 +161,2 @@\n-  _jvmti_vthread = OopHandle(_thread_oop_storage, NULL);\n-  _scopedValueCache = OopHandle(_thread_oop_storage, NULL);\n+  _jvmti_vthread = OopHandle(_thread_oop_storage, nullptr);\n+  _scopedValueCache = OopHandle(_thread_oop_storage, nullptr);\n@@ -178,1 +178,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -187,1 +187,1 @@\n-  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  assert(_thread_oop_storage != nullptr, \"not yet initialized\");\n@@ -196,1 +196,1 @@\n-  if (_scopedValueCache.ptr_raw() != NULL) { \/\/ i.e. if the OopHandle has been allocated\n+  if (_scopedValueCache.ptr_raw() != nullptr) { \/\/ i.e. if the OopHandle has been allocated\n@@ -199,1 +199,1 @@\n-    assert(p == NULL, \"not yet initialized\");\n+    assert(p == nullptr, \"not yet initialized\");\n@@ -204,1 +204,1 @@\n-  set_scopedValueCache(NULL);\n+  set_scopedValueCache(nullptr);\n@@ -208,1 +208,1 @@\n-  if (vthread_oop != NULL) {\n+  if (vthread_oop != nullptr) {\n@@ -216,1 +216,1 @@\n-  assert(threadObj() == NULL, \"should only create Java thread object once\");\n+  assert(threadObj() == nullptr, \"should only create Java thread object once\");\n@@ -229,1 +229,1 @@\n-  if (thread_name != NULL) {\n+  if (thread_name != nullptr) {\n@@ -286,2 +286,2 @@\n-  if (new_counters == NULL) {\n-    return NULL;\n+  if (new_counters == nullptr) {\n+    return nullptr;\n@@ -289,1 +289,1 @@\n-  if (old_counters == NULL) {\n+  if (old_counters == nullptr) {\n@@ -307,1 +307,1 @@\n-  if (new_counters == NULL) {\n+  if (new_counters == nullptr) {\n@@ -327,1 +327,1 @@\n-    if (new_counters == NULL) {\n+    if (new_counters == nullptr) {\n@@ -413,1 +413,1 @@\n-  _current_pending_monitor(NULL),\n+  _current_pending_monitor(nullptr),\n@@ -415,3 +415,3 @@\n-  _current_waiting_monitor(NULL),\n-  _active_handles(NULL),\n-  _free_handle_block(NULL),\n+  _current_waiting_monitor(nullptr),\n+  _active_handles(nullptr),\n+  _free_handle_block(nullptr),\n@@ -546,1 +546,1 @@\n-  if (_threadObj.peek() == NULL) {\n+  if (_threadObj.peek() == nullptr) {\n@@ -548,1 +548,1 @@\n-    \/\/ been interrupted. We can find NULL during VM initialization\n+    \/\/ been interrupted. We can find null during VM initialization\n@@ -603,1 +603,1 @@\n-  \/\/ The _osthread may be NULL here because we ran out of memory (too many threads active).\n+  \/\/ The _osthread may be null here because we ran out of memory (too many threads active).\n@@ -622,1 +622,1 @@\n-  _SleepEvent = NULL;\n+  _SleepEvent = nullptr;\n@@ -627,1 +627,1 @@\n-  if (old_array != NULL) {\n+  if (old_array != nullptr) {\n@@ -629,1 +629,1 @@\n-    old_array->set_unroll_block(NULL);\n+    old_array->set_unroll_block(nullptr);\n@@ -635,1 +635,1 @@\n-  if (updates != NULL) {\n+  if (updates != nullptr) {\n@@ -640,1 +640,1 @@\n-    set_deferred_updates(NULL);\n+    set_deferred_updates(nullptr);\n@@ -645,1 +645,1 @@\n-  if (_thread_stat != NULL) delete _thread_stat;\n+  if (_thread_stat != nullptr) delete _thread_stat;\n@@ -702,1 +702,1 @@\n-  assert(_threadObj.peek() != NULL, \"just checking\");\n+  assert(_threadObj.peek() != nullptr, \"just checking\");\n@@ -738,1 +738,1 @@\n-  java_lang_Thread::set_thread(threadObj(), NULL);\n+  java_lang_Thread::set_thread(threadObj(), nullptr);\n@@ -745,1 +745,1 @@\n-  return (threadObj != NULL && java_lang_Thread::is_daemon(threadObj));\n+  return (threadObj != nullptr && java_lang_Thread::is_daemon(threadObj));\n@@ -883,1 +883,1 @@\n-  if (active_handles() != NULL) {\n+  if (active_handles() != nullptr) {\n@@ -885,1 +885,1 @@\n-    set_active_handles(NULL);\n+    set_active_handles(nullptr);\n@@ -889,1 +889,1 @@\n-  if (free_handle_block() != NULL) {\n+  if (free_handle_block() != nullptr) {\n@@ -891,1 +891,1 @@\n-    set_free_handle_block(NULL);\n+    set_free_handle_block(nullptr);\n@@ -908,1 +908,1 @@\n-  char* thread_name = NULL;\n+  char* thread_name = nullptr;\n@@ -954,1 +954,1 @@\n-  if (active_handles() != NULL) {\n+  if (active_handles() != nullptr) {\n@@ -956,1 +956,1 @@\n-    set_active_handles(NULL);\n+    set_active_handles(nullptr);\n@@ -960,1 +960,1 @@\n-  if (free_handle_block() != NULL) {\n+  if (free_handle_block() != nullptr) {\n@@ -962,1 +962,1 @@\n-    set_free_handle_block(NULL);\n+    set_free_handle_block(nullptr);\n@@ -984,1 +984,1 @@\n-    JavaThread *ret = op == NULL ? NULL : JavaThread::cast(op->calling_thread());\n+    JavaThread *ret = op == nullptr ? nullptr : JavaThread::cast(op->calling_thread());\n@@ -993,1 +993,1 @@\n-  for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+  for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n@@ -1014,1 +1014,1 @@\n-  guarantee(monitor_chunks() != NULL, \"must be non empty\");\n+  guarantee(monitor_chunks() != nullptr, \"must be non empty\");\n@@ -1036,1 +1036,1 @@\n-  assert(java_throwable != NULL, \"should have an _async_exception to throw\");\n+  assert(java_throwable != nullptr, \"should have an _async_exception to throw\");\n@@ -1248,1 +1248,1 @@\n-        while (found != NULL) {\n+        while (found != nullptr) {\n@@ -1316,1 +1316,1 @@\n-  assert(old_handles != NULL && new_handles != NULL, \"should not be NULL\");\n+  assert(old_handles != nullptr && new_handles != nullptr, \"should not be null\");\n@@ -1328,1 +1328,1 @@\n-  old_handles->set_pop_frame_link(NULL);\n+  old_handles->set_pop_frame_link(nullptr);\n@@ -1339,1 +1339,1 @@\n-  if (active_handles() != NULL) {\n+  if (active_handles() != nullptr) {\n@@ -1347,1 +1347,1 @@\n-    for (MonitorChunk* chunk = monitor_chunks(); chunk != NULL; chunk = chunk->next()) {\n+    for (MonitorChunk* chunk = monitor_chunks(); chunk != nullptr; chunk = chunk->next()) {\n@@ -1352,1 +1352,1 @@\n-  assert(vframe_array_head() == NULL, \"deopt in progress at a safepoint!\");\n+  assert(vframe_array_head() == nullptr, \"deopt in progress at a safepoint!\");\n@@ -1356,1 +1356,1 @@\n-  if (list != NULL) {\n+  if (list != nullptr) {\n@@ -1370,1 +1370,1 @@\n-  if (jvmti_thread_state() != NULL) {\n+  if (jvmti_thread_state() != nullptr) {\n@@ -1395,1 +1395,1 @@\n-  StackWatermarkSet::finish_processing(this, NULL \/* context *\/, StackWatermarkKind::gc);\n+  StackWatermarkSet::finish_processing(this, nullptr \/* context *\/, StackWatermarkKind::gc);\n@@ -1420,1 +1420,1 @@\n-  if (jvmti_thread_state() != NULL) {\n+  if (jvmti_thread_state() != nullptr) {\n@@ -1434,1 +1434,1 @@\n-    if (ct->env() != NULL) {\n+    if (ct->env() != nullptr) {\n@@ -1438,1 +1438,1 @@\n-    if (task != NULL) {\n+    if (task != nullptr) {\n@@ -1472,1 +1472,1 @@\n-  if (thread_oop != NULL) {\n+  if (thread_oop != nullptr) {\n@@ -1480,1 +1480,1 @@\n-  if (thread_oop != NULL) {\n+  if (thread_oop != nullptr) {\n@@ -1483,1 +1483,1 @@\n-      assert(vt != NULL, \"\");\n+      assert(vt != nullptr, \"\");\n@@ -1494,1 +1494,1 @@\n-    if (task != NULL) {\n+    if (task != nullptr) {\n@@ -1496,1 +1496,1 @@\n-      task->print(st, NULL, true, false);\n+      task->print(st, nullptr, true, false);\n@@ -1554,1 +1554,1 @@\n-  oops_do(&VerifyOopClosure::verify_oop, NULL);\n+  oops_do(&VerifyOopClosure::verify_oop, nullptr);\n@@ -1561,1 +1561,1 @@\n-\/\/ Most callers of this method assume that it can't return NULL but a\n+\/\/ Most callers of this method assume that it can't return null but a\n@@ -1566,1 +1566,1 @@\n-\/\/ for such that this method never returns NULL.\n+\/\/ for such that this method never returns null.\n@@ -1577,1 +1577,1 @@\n-\/\/ Returns a non-NULL representation of this thread's name, or a suitable\n+\/\/ Returns a non-null representation of this thread's name, or a suitable\n@@ -1589,1 +1589,1 @@\n-    if (thread_obj != NULL) {\n+    if (thread_obj != nullptr) {\n@@ -1591,2 +1591,2 @@\n-      if (name != NULL) {\n-        if (buf == NULL) {\n+      if (name != nullptr) {\n+        if (buf == nullptr) {\n@@ -1618,1 +1618,1 @@\n-  assert(name_str != NULL, \"unexpected NULL thread name\");\n+  assert(name_str != nullptr, \"unexpected null thread name\");\n@@ -1624,1 +1624,1 @@\n-  assert(thread_obj != NULL, \"precondition\");\n+  assert(thread_obj != nullptr, \"precondition\");\n@@ -1627,1 +1627,1 @@\n-  if (name != NULL) {\n+  if (name != nullptr) {\n@@ -1678,1 +1678,1 @@\n-  if (thread_oop != NULL) {\n+  if (thread_oop != nullptr) {\n@@ -1681,1 +1681,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1717,1 +1717,1 @@\n-  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+  for (vframe* f = start_vf; f != nullptr; f = f->sender()) {\n@@ -1751,1 +1751,1 @@\n-  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+  for (vframe* f = start_vf; f != nullptr; f = f->sender()) {\n@@ -1803,1 +1803,1 @@\n-  assert(_popframe_preserved_args == NULL, \"should not wipe out old PopFrame preserved arguments\");\n+  assert(_popframe_preserved_args == nullptr, \"should not wipe out old PopFrame preserved arguments\");\n@@ -1826,1 +1826,1 @@\n-  assert(_popframe_preserved_args != NULL, \"should not free PopFrame preserved arguments twice\");\n+  assert(_popframe_preserved_args != nullptr, \"should not free PopFrame preserved arguments twice\");\n@@ -1828,1 +1828,1 @@\n-  _popframe_preserved_args = NULL;\n+  _popframe_preserved_args = nullptr;\n@@ -1848,1 +1848,1 @@\n-    if (obj == NULL) return;\n+    if (obj == nullptr) return;\n@@ -1948,1 +1948,1 @@\n-  guarantee (entry != NULL, \"Not a carrier thread\");\n+  guarantee (entry != nullptr, \"Not a carrier thread\");\n@@ -1962,1 +1962,1 @@\n-  assert(reg_map != NULL, \"a map must be given\");\n+  assert(reg_map != nullptr, \"a map must be given\");\n@@ -1966,1 +1966,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1978,1 +1978,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -2053,1 +2053,1 @@\n-  if (shutdown_klass != NULL) {\n+  if (shutdown_klass != nullptr) {\n@@ -2102,1 +2102,1 @@\n-  assert(target->osthread() != NULL, \"target thread is not properly initialized\");\n+  assert(target->osthread() != nullptr, \"target thread is not properly initialized\");\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":89,"deletions":89,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-  \/\/ be NULLed. This is because we rarely ever see the race and end up\n+  \/\/ be nulled. This is because we rarely ever see the race and end up\n@@ -167,1 +167,1 @@\n-    \/\/ Especially, reloading pointer from thread after NULL check must be prevented.\n+    \/\/ Especially, reloading pointer from thread after null check must be prevented.\n@@ -228,1 +228,1 @@\n-  void install_async_exception(AsyncExceptionHandshake* aec = NULL);\n+  void install_async_exception(AsyncExceptionHandshake* aec = nullptr);\n@@ -518,1 +518,1 @@\n-  \/\/ Thread oop. threadObj() can be NULL for initial JavaThread\n+  \/\/ Thread oop. threadObj() can be null for initial JavaThread\n@@ -540,1 +540,1 @@\n-  \/\/ Allocates a new Java level thread object for this thread. thread_name may be NULL.\n+  \/\/ Allocates a new Java level thread object for this thread. thread_name may be null.\n@@ -599,1 +599,1 @@\n-  bool cont_fastpath() const                   { return _cont_fastpath == NULL && _cont_fastpath_thread_state != 0; }\n+  bool cont_fastpath() const                   { return _cont_fastpath == nullptr && _cont_fastpath_thread_state != 0; }\n@@ -710,2 +710,2 @@\n-  void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, \"must be\"); _jvmci._alternate_call_target = a; }\n-  void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, \"must be\"); _jvmci._implicit_exception_pc = a; }\n+  void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == nullptr, \"must be\"); _jvmci._alternate_call_target = a; }\n+  void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == nullptr, \"must be\"); _jvmci._implicit_exception_pc = a; }\n@@ -733,2 +733,2 @@\n-    set_exception_oop(NULL);\n-    set_exception_pc(NULL);\n+    set_exception_oop(nullptr);\n+    set_exception_pc(nullptr);\n@@ -745,4 +745,0 @@\n-  void set_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = true; }\n-  void clr_do_not_unlock(void)                   { _do_not_unlock_if_synchronized = false; }\n-  bool do_not_unlock(void)                       { return _do_not_unlock_if_synchronized; }\n-\n@@ -855,2 +851,2 @@\n-  bool is_pending_jni_exception_check() const { return _pending_jni_exception_check_fn != NULL; }\n-  void clear_pending_jni_exception_check() { _pending_jni_exception_check_fn = NULL; }\n+  bool is_pending_jni_exception_check() const { return _pending_jni_exception_check_fn != nullptr; }\n+  void clear_pending_jni_exception_check() { _pending_jni_exception_check_fn = nullptr; }\n@@ -884,1 +880,1 @@\n-  const char* get_thread_name_string(char* buf = NULL, int buflen = 0) const;\n+  const char* get_thread_name_string(char* buf = nullptr, int buflen = 0) const;\n@@ -977,1 +973,1 @@\n-  \/\/ Returns the current thread as a JavaThread, or NULL if not attached\n+  \/\/ Returns the current thread as a JavaThread, or nullptr if not attached\n@@ -1008,1 +1004,1 @@\n-  \/\/ one which means NULL can be returned. JvmtiThreadState::state_for()\n+  \/\/ one which means null can be returned. JvmtiThreadState::state_for()\n@@ -1011,1 +1007,1 @@\n-  \/\/ returns it. JvmtiThreadState::state_for() will return NULL only if\n+  \/\/ returns it. JvmtiThreadState::state_for() will return null only if\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":17,"deletions":21,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n-  char* bytes = NULL;                                                      \\\n+  char* bytes = nullptr;                                                   \\\n@@ -73,1 +73,1 @@\n-  if (klassname != NULL) {                                                 \\\n+  if (klassname != nullptr) {                                              \\\n@@ -124,1 +124,1 @@\n-OopStorage* ObjectMonitor::_oop_storage = NULL;\n+OopStorage* ObjectMonitor::_oop_storage = nullptr;\n@@ -262,1 +262,1 @@\n-  _owner(NULL),\n+  _owner(nullptr),\n@@ -264,1 +264,1 @@\n-  _next_om(NULL),\n+  _next_om(nullptr),\n@@ -266,4 +266,4 @@\n-  _EntryList(NULL),\n-  _cxq(NULL),\n-  _succ(NULL),\n-  _Responsible(NULL),\n+  _EntryList(nullptr),\n+  _cxq(nullptr),\n+  _succ(nullptr),\n+  _Responsible(nullptr),\n@@ -273,1 +273,1 @@\n-  _WaitSet(NULL),\n+  _WaitSet(nullptr),\n@@ -285,1 +285,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -292,1 +292,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -300,1 +300,1 @@\n-    _om->_succ = NULL;\n+    _om->_succ = nullptr;\n@@ -312,1 +312,1 @@\n-      _om->_succ = NULL;\n+      _om->_succ = nullptr;\n@@ -325,2 +325,2 @@\n-  void* cur = try_set_owner_from(NULL, current);\n-  if (cur == NULL) {\n+  void* cur = try_set_owner_from(nullptr, current);\n+  if (cur == nullptr) {\n@@ -376,1 +376,1 @@\n-    if (l_object != NULL) {\n+    if (l_object != nullptr) {\n@@ -399,1 +399,1 @@\n-    assert(current->current_pending_monitor() == NULL, \"invariant\");\n+    assert(current->current_pending_monitor() == nullptr, \"invariant\");\n@@ -422,1 +422,1 @@\n-        current->set_current_pending_monitor(NULL);\n+        current->set_current_pending_monitor(nullptr);\n@@ -487,2 +487,2 @@\n-  if (own != NULL) return 0;\n-  if (try_set_owner_from(NULL, current) == NULL) {\n+  if (own != nullptr) return 0;\n+  if (try_set_owner_from(nullptr, current) == nullptr) {\n@@ -530,1 +530,1 @@\n-  if (obj == NULL) {\n+  if (obj == nullptr) {\n@@ -533,1 +533,1 @@\n-    set_owner_from(NULL, DEFLATER_MARKER);\n+    set_owner_from(nullptr, DEFLATER_MARKER);\n@@ -539,1 +539,1 @@\n-    \/\/ Set a NULL owner to DEFLATER_MARKER to force any contending thread\n+    \/\/ Set a nullptr owner to DEFLATER_MARKER to force any contending thread\n@@ -542,2 +542,2 @@\n-    if (try_set_owner_from(NULL, DEFLATER_MARKER) != NULL) {\n-      \/\/ The owner field is no longer NULL so we lost the race since the\n+    if (try_set_owner_from(nullptr, DEFLATER_MARKER) != nullptr) {\n+      \/\/ The owner field is no longer null so we lost the race since the\n@@ -552,2 +552,2 @@\n-      \/\/ NULL if it is still DEFLATER_MARKER.\n-      if (try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+      \/\/ null if it is still DEFLATER_MARKER.\n+      if (try_set_owner_from(DEFLATER_MARKER, nullptr) != DEFLATER_MARKER) {\n@@ -564,1 +564,1 @@\n-      \/\/ ObjectMonitor is now busy. Restore owner to NULL if it is\n+      \/\/ ObjectMonitor is now busy. Restore owner to nullptr if it is\n@@ -566,1 +566,1 @@\n-      if (try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+      if (try_set_owner_from(DEFLATER_MARKER, nullptr) != DEFLATER_MARKER) {\n@@ -579,1 +579,1 @@\n-  guarantee(_cxq == NULL, \"must be no contending threads: cxq=\"\n+  guarantee(_cxq == nullptr, \"must be no contending threads: cxq=\"\n@@ -581,1 +581,1 @@\n-  guarantee(_EntryList == NULL,\n+  guarantee(_EntryList == nullptr,\n@@ -585,1 +585,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -630,1 +630,1 @@\n-  guarantee(obj != NULL, \"must be non-NULL\");\n+  guarantee(obj != nullptr, \"must be non-null\");\n@@ -640,1 +640,1 @@\n-  if (l_object == NULL) {\n+  if (l_object == nullptr) {\n@@ -649,1 +649,1 @@\n-  \/\/ The dmw has to be neutral (not NULL, not locked and not marked).\n+  \/\/ The dmw has to be neutral (not null, not locked and not marked).\n@@ -685,1 +685,1 @@\n-    \/\/ We report NULL instead of DEFLATER_MARKER here because is_busy()\n+    \/\/ We report nullptr instead of DEFLATER_MARKER here because is_busy()\n@@ -802,1 +802,1 @@\n-  if (nxt == NULL && _EntryList == NULL) {\n+  if (nxt == nullptr && _EntryList == nullptr) {\n@@ -880,1 +880,1 @@\n-    if (_succ == current) _succ = NULL;\n+    if (_succ == current) _succ = nullptr;\n@@ -897,1 +897,1 @@\n-  if (_succ == current) _succ = NULL;\n+  if (_succ == current) _succ = nullptr;\n@@ -901,1 +901,1 @@\n-    _Responsible = NULL;\n+    _Responsible = nullptr;\n@@ -957,2 +957,2 @@\n-  assert(current != NULL, \"invariant\");\n-  assert(currentNode != NULL, \"invariant\");\n+  assert(current != nullptr, \"invariant\");\n+  assert(currentNode != nullptr, \"invariant\");\n@@ -1000,1 +1000,1 @@\n-    if (_succ == current) _succ = NULL;\n+    if (_succ == current) _succ = nullptr;\n@@ -1022,1 +1022,1 @@\n-  if (_succ == current) _succ = NULL;\n+  if (_succ == current) _succ = nullptr;\n@@ -1041,2 +1041,2 @@\n-    if (nxt != NULL) nxt->_prev = prv;\n-    if (prv != NULL) prv->_next = nxt;\n+    if (nxt != nullptr) nxt->_prev = prv;\n+    if (prv != nullptr) prv->_next = nxt;\n@@ -1044,2 +1044,2 @@\n-    assert(nxt == NULL || nxt->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n-    assert(prv == NULL || prv->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+    assert(nxt == nullptr || nxt->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n+    assert(prv == nullptr || prv->TState == ObjectWaiter::TS_ENTER, \"invariant\");\n@@ -1062,1 +1062,1 @@\n-    assert(v != NULL, \"invariant\");\n+    assert(v != nullptr, \"invariant\");\n@@ -1072,2 +1072,2 @@\n-      ObjectWaiter* q = NULL;\n-      for (p = v; p != NULL && p != currentNode; p = p->_next) {\n+      ObjectWaiter* q = nullptr;\n+      for (p = v; p != nullptr && p != currentNode; p = p->_next) {\n@@ -1080,1 +1080,1 @@\n-      assert(q != NULL, \"invariant\");\n+      assert(q != nullptr, \"invariant\");\n@@ -1187,1 +1187,1 @@\n-  _Responsible = NULL;\n+  _Responsible = nullptr;\n@@ -1209,1 +1209,1 @@\n-    if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != NULL) {\n+    if ((intptr_t(_EntryList)|intptr_t(_cxq)) == 0 || _succ != nullptr) {\n@@ -1216,1 +1216,1 @@\n-    \/\/ then this thread can simply store NULL into _owner and exit without\n+    \/\/ then this thread can simply store null into _owner and exit without\n@@ -1250,1 +1250,1 @@\n-    if (try_set_owner_from(NULL, current) != NULL) {\n+    if (try_set_owner_from(nullptr, current) != nullptr) {\n@@ -1256,1 +1256,1 @@\n-    ObjectWaiter* w = NULL;\n+    ObjectWaiter* w = nullptr;\n@@ -1259,1 +1259,1 @@\n-    if (w != NULL) {\n+    if (w != nullptr) {\n@@ -1263,1 +1263,1 @@\n-      \/\/ then calls exit().  Exit release the lock by setting O._owner to NULL.\n+      \/\/ then calls exit().  Exit release the lock by setting O._owner to null.\n@@ -1279,1 +1279,1 @@\n-    if (w == NULL) continue;\n+    if (w == nullptr) continue;\n@@ -1283,1 +1283,1 @@\n-    \/\/ The following loop is tantamount to: w = swap(&cxq, NULL)\n+    \/\/ The following loop is tantamount to: w = swap(&cxq, nullptr)\n@@ -1285,2 +1285,2 @@\n-      assert(w != NULL, \"Invariant\");\n-      ObjectWaiter* u = Atomic::cmpxchg(&_cxq, w, (ObjectWaiter*)NULL);\n+      assert(w != nullptr, \"Invariant\");\n+      ObjectWaiter* u = Atomic::cmpxchg(&_cxq, w, (ObjectWaiter*)nullptr);\n@@ -1291,2 +1291,2 @@\n-    assert(w != NULL, \"invariant\");\n-    assert(_EntryList == NULL, \"invariant\");\n+    assert(w != nullptr, \"invariant\");\n+    assert(_EntryList == nullptr, \"invariant\");\n@@ -1304,1 +1304,1 @@\n-    ObjectWaiter* q = NULL;\n+    ObjectWaiter* q = nullptr;\n@@ -1306,1 +1306,1 @@\n-    for (p = w; p != NULL; p = p->_next) {\n+    for (p = w; p != nullptr; p = p->_next) {\n@@ -1313,1 +1313,1 @@\n-    \/\/ In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = NULL\n+    \/\/ In 1-0 mode we need: ST EntryList; MEMBAR #storestore; ST _owner = nullptr\n@@ -1319,1 +1319,1 @@\n-    if (_succ != NULL) continue;\n+    if (_succ != nullptr) continue;\n@@ -1322,1 +1322,1 @@\n-    if (w != NULL) {\n+    if (w != nullptr) {\n@@ -1336,1 +1336,1 @@\n-  \/\/ 2. ST _owner = NULL\n+  \/\/ 2. ST _owner = nullptr\n@@ -1342,1 +1342,1 @@\n-  \/\/ Hygiene -- once we've set _owner = NULL we can't safely dereference Wakee again.\n+  \/\/ Hygiene -- once we've set _owner = nullptr we can't safely dereference Wakee again.\n@@ -1345,1 +1345,1 @@\n-  Wakee  = NULL;\n+  Wakee  = nullptr;\n@@ -1447,2 +1447,2 @@\n-  assert(event != NULL, \"invariant\");\n-  assert(monitor != NULL, \"invariant\");\n+  assert(event != nullptr, \"invariant\");\n+  assert(monitor != nullptr, \"invariant\");\n@@ -1524,1 +1524,1 @@\n-  _Responsible = NULL;\n+  _Responsible = nullptr;\n@@ -1596,1 +1596,1 @@\n-    if (_succ == current) _succ = NULL;\n+    if (_succ == current) _succ = nullptr;\n@@ -1658,1 +1658,1 @@\n-  current->set_current_waiting_monitor(NULL);\n+  current->set_current_waiting_monitor(nullptr);\n@@ -1694,1 +1694,1 @@\n-  if (iterator != NULL) {\n+  if (iterator != nullptr) {\n@@ -1709,2 +1709,2 @@\n-    if (list != NULL) {\n-      assert(list->_prev == NULL, \"invariant\");\n+    if (list != nullptr) {\n+      assert(list->_prev == nullptr, \"invariant\");\n@@ -1716,2 +1716,2 @@\n-    if (list == NULL) {\n-      iterator->_next = iterator->_prev = NULL;\n+    if (list == nullptr) {\n+      iterator->_next = iterator->_prev = nullptr;\n@@ -1756,1 +1756,1 @@\n-  if (_WaitSet == NULL) {\n+  if (_WaitSet == nullptr) {\n@@ -1775,1 +1775,1 @@\n-  if (_WaitSet == NULL) {\n+  if (_WaitSet == nullptr) {\n@@ -1781,1 +1781,1 @@\n-  while (_WaitSet != NULL) {\n+  while (_WaitSet != nullptr) {\n@@ -1907,1 +1907,1 @@\n-  if (_succ == NULL) {\n+  if (_succ == nullptr) {\n@@ -1910,1 +1910,1 @@\n-  Thread* prv = NULL;\n+  Thread* prv = nullptr;\n@@ -1949,3 +1949,3 @@\n-    if (ox == NULL) {\n-      ox = static_cast<JavaThread*>(try_set_owner_from(NULL, current));\n-      if (ox == NULL) {\n+    if (ox == nullptr) {\n+      ox = static_cast<JavaThread*>(try_set_owner_from(nullptr, current));\n+      if (ox == nullptr) {\n@@ -1955,1 +1955,1 @@\n-          _succ = NULL;\n+          _succ = nullptr;\n@@ -1983,1 +1983,1 @@\n-    if (ox != prv && prv != NULL) {\n+    if (ox != prv && prv != nullptr) {\n@@ -1995,1 +1995,1 @@\n-    if (_succ == NULL) {\n+    if (_succ == nullptr) {\n@@ -2016,1 +2016,1 @@\n-    _succ = NULL;\n+    _succ = nullptr;\n@@ -2061,1 +2061,1 @@\n-  if (ox == NULL) return 0;\n+  if (ox == nullptr) return 0;\n@@ -2088,2 +2088,2 @@\n-  _next     = NULL;\n-  _prev     = NULL;\n+  _next     = nullptr;\n+  _prev     = nullptr;\n@@ -2096,1 +2096,1 @@\n-  assert(_event != NULL, \"invariant\");\n+  assert(_event != nullptr, \"invariant\");\n@@ -2108,3 +2108,3 @@\n-  assert(node != NULL, \"should not add NULL node\");\n-  assert(node->_prev == NULL, \"node already in list\");\n-  assert(node->_next == NULL, \"node already in list\");\n+  assert(node != nullptr, \"should not add null node\");\n+  assert(node->_prev == nullptr, \"node already in list\");\n+  assert(node->_next == nullptr, \"node already in list\");\n@@ -2112,1 +2112,1 @@\n-  if (_WaitSet == NULL) {\n+  if (_WaitSet == nullptr) {\n@@ -2137,3 +2137,3 @@\n-  assert(node != NULL, \"should not dequeue NULL node\");\n-  assert(node->_prev != NULL, \"node already removed from list\");\n-  assert(node->_next != NULL, \"node already removed from list\");\n+  assert(node != nullptr, \"should not dequeue nullptr node\");\n+  assert(node->_prev != nullptr, \"node already removed from list\");\n+  assert(node->_next != nullptr, \"node already removed from list\");\n@@ -2146,1 +2146,1 @@\n-    _WaitSet = NULL;\n+    _WaitSet = nullptr;\n@@ -2157,2 +2157,2 @@\n-  node->_next = NULL;\n-  node->_prev = NULL;\n+  node->_next = nullptr;\n+  node->_prev = nullptr;\n@@ -2163,7 +2163,7 @@\n-PerfCounter * ObjectMonitor::_sync_ContendedLockAttempts       = NULL;\n-PerfCounter * ObjectMonitor::_sync_FutileWakeups               = NULL;\n-PerfCounter * ObjectMonitor::_sync_Parks                       = NULL;\n-PerfCounter * ObjectMonitor::_sync_Notifications               = NULL;\n-PerfCounter * ObjectMonitor::_sync_Inflations                  = NULL;\n-PerfCounter * ObjectMonitor::_sync_Deflations                  = NULL;\n-PerfLongVariable * ObjectMonitor::_sync_MonExtant              = NULL;\n+PerfCounter * ObjectMonitor::_sync_ContendedLockAttempts       = nullptr;\n+PerfCounter * ObjectMonitor::_sync_FutileWakeups               = nullptr;\n+PerfCounter * ObjectMonitor::_sync_Parks                       = nullptr;\n+PerfCounter * ObjectMonitor::_sync_Notifications               = nullptr;\n+PerfCounter * ObjectMonitor::_sync_Inflations                  = nullptr;\n+PerfCounter * ObjectMonitor::_sync_Deflations                  = nullptr;\n+PerfLongVariable * ObjectMonitor::_sync_MonExtant              = nullptr;\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":118,"deletions":118,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -195,6 +195,6 @@\n-  #define OM_PERFDATA_OP(f, op_str)              \\\n-    do {                                         \\\n-      if (ObjectMonitor::_sync_ ## f != NULL &&  \\\n-          PerfDataManager::has_PerfData()) {     \\\n-        ObjectMonitor::_sync_ ## f->op_str;      \\\n-      }                                          \\\n+  #define OM_PERFDATA_OP(f, op_str)                 \\\n+    do {                                            \\\n+      if (ObjectMonitor::_sync_ ## f != nullptr &&  \\\n+          PerfDataManager::has_PerfData()) {        \\\n+        ObjectMonitor::_sync_ ## f->op_str;         \\\n+      }                                             \\\n@@ -258,1 +258,1 @@\n-  void*     owner() const;  \/\/ Returns NULL if DEFLATER_MARKER is observed.\n+  void*     owner() const;  \/\/ Returns null if DEFLATER_MARKER is observed.\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-  return owner != NULL && owner != DEFLATER_MARKER;\n+  return owner != nullptr && owner != DEFLATER_MARKER;\n@@ -73,1 +73,1 @@\n-\/\/ Returns NULL if DEFLATER_MARKER is observed.\n+\/\/ Returns null if DEFLATER_MARKER is observed.\n@@ -76,1 +76,1 @@\n-  return owner != DEFLATER_MARKER ? owner : NULL;\n+  return owner != DEFLATER_MARKER ? owner : nullptr;\n@@ -85,1 +85,1 @@\n-\/\/ field == DEFLATER_MARKER and any non-NULL value won't do the trick.\n+\/\/ field == DEFLATER_MARKER and any non-null value won't do the trick.\n@@ -112,1 +112,1 @@\n-  Atomic::release_store(&_owner, (void*)NULL);\n+  Atomic::release_store(&_owner, (void*)nullptr);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,2 +84,1 @@\n-OSThread*         os::_starting_thread    = NULL;\n-address           os::_polling_page       = NULL;\n+OSThread*         os::_starting_thread    = nullptr;\n@@ -115,1 +114,1 @@\n-\/\/ Returns buffer, or NULL if it failed.\n+\/\/ Returns buffer, or null if it failed.\n@@ -123,1 +122,1 @@\n-\/\/ Returns buffer, or NULL if it failed.\n+\/\/ Returns buffer, or null if it failed.\n@@ -133,3 +132,3 @@\n-  if (buffer == NULL) {\n-    assert(false, \"NULL buffer\");\n-    return NULL;\n+  if (buffer == nullptr) {\n+    assert(false, \"null buffer\");\n+    return nullptr;\n@@ -139,1 +138,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -149,1 +148,1 @@\n-    if (gmtime_pd(&seconds_since_19700101, &time_struct) == NULL) {\n+    if (gmtime_pd(&seconds_since_19700101, &time_struct) == nullptr) {\n@@ -151,1 +150,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -154,1 +153,1 @@\n-    if (localtime_pd(&seconds_since_19700101, &time_struct) == NULL) {\n+    if (localtime_pd(&seconds_since_19700101, &time_struct) == nullptr) {\n@@ -156,1 +155,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -222,1 +221,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -297,1 +296,1 @@\n-          if (a[n] != NULL) {\n+          if (a[n] != nullptr) {\n@@ -316,1 +315,1 @@\n-      if (p != NULL) {\n+      if (p != nullptr) {\n@@ -322,1 +321,1 @@\n-    } else if (strchr(pname, *os::path_separator()) != NULL) {\n+    } else if (strchr(pname, *os::path_separator()) != nullptr) {\n@@ -326,1 +325,1 @@\n-      if (pelements != NULL) {\n+      if (pelements != nullptr) {\n@@ -329,2 +328,2 @@\n-          \/\/ Really shouldn't be NULL, but check can't hurt.\n-          size_t plen = (path == NULL) ? 0 : strlen(path);\n+          \/\/ Really shouldn't be null, but check can't hurt.\n+          size_t plen = (path == nullptr) ? 0 : strlen(path);\n@@ -429,1 +428,1 @@\n-        if (klass != NULL) {\n+        if (klass != nullptr) {\n@@ -446,1 +445,1 @@\n-          if (tty != NULL) {\n+          if (tty != nullptr) {\n@@ -452,1 +451,1 @@\n-            if (os::exception_name(sig, tmp_sig_name, 16) != NULL)\n+            if (os::exception_name(sig, tmp_sig_name, 16) != nullptr)\n@@ -503,1 +502,1 @@\n-static void* _native_java_library = NULL;\n+static void* _native_java_library = nullptr;\n@@ -506,1 +505,1 @@\n-  if (_native_java_library == NULL) {\n+  if (_native_java_library == nullptr) {\n@@ -515,1 +514,1 @@\n-    if (_native_java_library == NULL) {\n+    if (_native_java_library == nullptr) {\n@@ -542,1 +541,1 @@\n-  assert(agent_lib != NULL, \"sanity check\");\n+  assert(agent_lib != nullptr, \"sanity check\");\n@@ -545,1 +544,1 @@\n-  void *entryName = NULL;\n+  void *entryName = nullptr;\n@@ -551,1 +550,1 @@\n-  lib_name = ((check_lib || agent_lib->is_static_lib()) ? agent_lib->name() : NULL);\n+  lib_name = ((check_lib || agent_lib->is_static_lib()) ? agent_lib->name() : nullptr);\n@@ -554,1 +553,1 @@\n-    if (agent_function_name == NULL) {\n+    if (agent_function_name == nullptr) {\n@@ -559,1 +558,1 @@\n-    if (entryName != NULL) {\n+    if (entryName != nullptr) {\n@@ -573,2 +572,2 @@\n-  assert(agent_lib != NULL, \"sanity check\");\n-  if (agent_lib->name() == NULL) {\n+  assert(agent_lib != nullptr, \"sanity check\");\n+  if (agent_lib->name() == nullptr) {\n@@ -583,1 +582,1 @@\n-  if (ret != NULL) {\n+  if (ret != nullptr) {\n@@ -598,1 +597,1 @@\n-  if (dup_str == NULL) return NULL;\n+  if (dup_str == nullptr) return nullptr;\n@@ -605,1 +604,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -648,1 +647,1 @@\n-  void* rc = NULL;\n+  void* rc = nullptr;\n@@ -658,1 +657,1 @@\n-  \/\/ NULL or a unique non-NULL pointer. To unify libc behavior across our platforms\n+  \/\/ null or a unique non-null pointer. To unify libc behavior across our platforms\n@@ -664,1 +663,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -671,1 +670,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -675,2 +674,2 @@\n-  if (outer_ptr == NULL) {\n-    return NULL;\n+  if (outer_ptr == nullptr) {\n+    return nullptr;\n@@ -698,1 +697,1 @@\n-  void* rc = NULL;\n+  void* rc = nullptr;\n@@ -703,1 +702,1 @@\n-  if (memblock == NULL) {\n+  if (memblock == nullptr) {\n@@ -710,1 +709,1 @@\n-  \/\/ NULL or a unique non-NULL pointer. To unify libc behavior across our platforms\n+  \/\/ null or a unique non-null pointer. To unify libc behavior across our platforms\n@@ -716,1 +715,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -726,1 +725,1 @@\n-      return NULL;\n+      return nullptr;\n@@ -739,1 +738,1 @@\n-    if (new_outer_ptr == NULL) {\n+    if (new_outer_ptr == nullptr) {\n@@ -766,2 +765,2 @@\n-    if (rc == NULL) {\n-      return NULL;\n+    if (rc == nullptr) {\n+      return nullptr;\n@@ -784,1 +783,1 @@\n-  if (memblock == NULL) {\n+  if (memblock == nullptr) {\n@@ -864,1 +863,1 @@\n-  abort(dump_core && CreateCoredumpOnCrash, NULL, NULL);\n+  abort(dump_core && CreateCoredumpOnCrash, nullptr, nullptr);\n@@ -880,1 +879,1 @@\n-  if (p == NULL) {\n+  if (p == nullptr) {\n@@ -907,1 +906,1 @@\n-      if (args_start != NULL) {\n+      if (args_start != nullptr) {\n@@ -928,1 +927,1 @@\n-      if (p2 != NULL) {\n+      if (p2 != nullptr) {\n@@ -991,1 +990,1 @@\n-  if (startStr == NULL) startStr = \"\";\n+  if (startStr == nullptr) startStr = \"\";\n@@ -1009,1 +1008,1 @@\n-    for (int i = 0; env_list[i] != NULL; i++) {\n+    for (int i = 0; env_list[i] != nullptr; i++) {\n@@ -1011,1 +1010,1 @@\n-      if (envvar != NULL) {\n+      if (envvar != nullptr) {\n@@ -1074,1 +1073,1 @@\n-  if (nl != NULL) {\n+  if (nl != nullptr) {\n@@ -1079,1 +1078,1 @@\n-  if (localtime_pd(&tloc, &tz) != NULL) {\n+  if (localtime_pd(&tloc, &tz) != nullptr) {\n@@ -1110,1 +1109,1 @@\n-\/\/ Helps to prove validity of a not-NULL pointer.\n+\/\/ Helps to prove validity of a non-null pointer.\n@@ -1134,3 +1133,3 @@\n-  \/\/ Handle NULL first, so later checks don't need to protect against it.\n-  if (addr == NULL) {\n-    st->print_cr(\"0x0 is NULL\");\n+  \/\/ Handle null first, so later checks don't need to protect against it.\n+  if (addr == nullptr) {\n+    st->print_cr(\"0x0 is nullptr\");\n@@ -1142,1 +1141,1 @@\n-  if (b != NULL) {\n+  if (b != nullptr) {\n@@ -1334,1 +1333,1 @@\n-  if (file != NULL) {\n+  if (file != nullptr) {\n@@ -1356,1 +1355,1 @@\n-  if (jimage == NULL) return false;\n+  if (jimage == nullptr) return false;\n@@ -1367,1 +1366,1 @@\n-  if (base_classes == NULL) return false;\n+  if (base_classes == nullptr) return false;\n@@ -1380,1 +1379,1 @@\n-  if (filename == NULL || strlen(filename) == 0) {\n+  if (filename == nullptr || strlen(filename) == 0) {\n@@ -1401,2 +1400,2 @@\n-  if (path == NULL || strlen(path) == 0 || file_name_length == (size_t)NULL) {\n-    return NULL;\n+  if (path == nullptr || strlen(path) == 0 || file_name_length == (size_t)nullptr) {\n+    return nullptr;\n@@ -1410,1 +1409,1 @@\n-  while (p != NULL) {\n+  while (p != nullptr) {\n@@ -1503,1 +1502,1 @@\n-      (void)::poll(NULL, 0, 100);\n+      (void)::poll(nullptr, 0, 100);\n@@ -1741,1 +1740,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1749,1 +1748,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1866,3 +1865,3 @@\n-  \/\/ On all current implementations NULL is interpreted as any available address.\n-  char* result = os::map_memory_to_file(NULL \/* addr *\/, bytes, file_desc);\n-  if (result != NULL) {\n+  \/\/ On all current implementations null is interpreted as any available address.\n+  char* result = os::map_memory_to_file(nullptr \/* addr *\/, bytes, file_desc);\n+  if (result != nullptr) {\n@@ -1876,1 +1875,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1886,1 +1885,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n@@ -1927,1 +1926,1 @@\n-  if (result != NULL) {\n+  if (result != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":80,"deletions":81,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,1 +131,1 @@\n-  ObjectMonitor* prev = NULL;\n+  ObjectMonitor* prev = nullptr;\n@@ -134,2 +134,2 @@\n-  \/\/ The in-use list head can be NULL during the final audit.\n-  while (m != NULL) {\n+  \/\/ The in-use list head can be null during the final audit.\n+  while (m != nullptr) {\n@@ -148,2 +148,2 @@\n-      } while (next != NULL && next->is_being_async_deflated());\n-      if (prev == NULL) {\n+      } while (next != nullptr && next->is_being_async_deflated());\n+      if (prev == nullptr) {\n@@ -206,1 +206,1 @@\n-  char* bytes = NULL;                                                      \\\n+  char* bytes = nullptr;                                                      \\\n@@ -210,1 +210,1 @@\n-  if (klassname != NULL) {                                                 \\\n+  if (klassname != nullptr) {                                                 \\\n@@ -313,1 +313,1 @@\n-  if (obj == NULL) return false;  \/\/ slow-path for invalid obj\n+  if (obj == nullptr) return false;  \/\/ slow-path for invalid obj\n@@ -328,1 +328,1 @@\n-    if (mon->first_waiter() != NULL) {\n+    if (mon->first_waiter() != nullptr) {\n@@ -341,1 +341,1 @@\n-      } while (mon->first_waiter() != NULL && all);\n+      } while (mon->first_waiter() != nullptr && all);\n@@ -362,1 +362,1 @@\n-  if (obj == NULL) return false;       \/\/ Need to throw NPE\n+  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n@@ -375,1 +375,1 @@\n-    if (m->object_peek() == NULL) {\n+    if (m->object_peek() == nullptr) {\n@@ -393,1 +393,1 @@\n-    \/\/ non-NULL so this BasicLock is not seen as recursive nor as\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n@@ -404,1 +404,1 @@\n-    if (owner == NULL && m->try_set_owner_from(NULL, current) == NULL) {\n+    if (owner == nullptr && m->try_set_owner_from(nullptr, current) == nullptr) {\n@@ -440,1 +440,1 @@\n-    if (newline != NULL) {\n+    if (newline != nullptr) {\n@@ -524,1 +524,1 @@\n-                 current->is_lock_owned((address) mark.locker())) {\n+                 current->is_lock_owned((address)mark.locker())) {\n@@ -526,2 +526,2 @@\n-        assert(lock != (BasicLock*) obj->mark().value(), \"don't relock with same BasicLock\");\n-        lock->set_displaced_header(markWord::from_pointer(NULL));\n+        assert(lock != (BasicLock*)obj->mark().value(), \"don't relock with same BasicLock\");\n+        lock->set_displaced_header(markWord::from_pointer(nullptr));\n@@ -577,1 +577,1 @@\n-        \/\/ If the displaced header is NULL, then this exit matches up with\n+        \/\/ If the displaced header is null, then this exit matches up with\n@@ -715,1 +715,1 @@\n-  if (_obj() != NULL) {\n+  if (_obj() != nullptr) {\n@@ -721,1 +721,1 @@\n-  if (_obj() != NULL) {\n+  if (_obj() != nullptr) {\n@@ -923,1 +923,1 @@\n-    ObjectMonitor* monitor = NULL;\n+    ObjectMonitor* monitor = nullptr;\n@@ -1086,1 +1086,1 @@\n-    assert(monitor != NULL, \"monitor should be non-null\");\n+    assert(monitor != nullptr, \"monitor should be non-null\");\n@@ -1090,1 +1090,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1109,1 +1109,1 @@\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != NULL) {\n+    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n@@ -1134,1 +1134,1 @@\n-    if (!mid->is_being_async_deflated() && mid->object_peek() != NULL) {\n+    if (!mid->is_being_async_deflated() && mid->object_peek() != nullptr) {\n@@ -1250,1 +1250,1 @@\n-  assert(event != NULL, \"invariant\");\n+  assert(event != nullptr, \"invariant\");\n@@ -1327,1 +1327,1 @@\n-        monitor->set_owner_from(NULL, current);\n+        monitor->set_owner_from(nullptr, current);\n@@ -1418,2 +1418,2 @@\n-      \/\/ with CAS.  That is, we can avoid the xchg-NULL .... ST idiom.\n-      m->set_owner_from(NULL, mark.locker());\n+      \/\/ with CAS.  That is, we can avoid the xchg-nullptr .... ST idiom.\n+      m->set_owner_from(nullptr, mark.locker());\n@@ -1453,1 +1453,1 @@\n-    \/\/ to inflate and then CAS() again to try to swing _owner from NULL to current.\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n@@ -1465,1 +1465,1 @@\n-      m = NULL;\n+      m = nullptr;\n@@ -1500,1 +1500,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1513,1 +1513,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1601,1 +1601,1 @@\n-  LogStream* ls = NULL;\n+  LogStream* ls = nullptr;\n@@ -1609,1 +1609,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1630,1 +1630,1 @@\n-      if (ls != NULL) {\n+      if (ls != nullptr) {\n@@ -1649,1 +1649,1 @@\n-      if (ls != NULL) {\n+      if (ls != nullptr) {\n@@ -1672,1 +1672,1 @@\n-  if (ls != NULL) {\n+  if (ls != nullptr) {\n@@ -1816,1 +1816,1 @@\n-  LogStream* ls = NULL;\n+  LogStream* ls = nullptr;\n@@ -1824,1 +1824,1 @@\n-  assert(ls != NULL, \"sanity check\");\n+  assert(ls != nullptr, \"sanity check\");\n@@ -1895,1 +1895,1 @@\n-                  \"have non-NULL _header field.\", p2i(n));\n+                  \"have non-null _header field.\", p2i(n));\n@@ -1899,1 +1899,1 @@\n-  if (obj != NULL) {\n+  if (obj != nullptr) {\n@@ -1937,2 +1937,2 @@\n-                 mid->is_busy(), mark.hash() != 0, mid->owner() != NULL,\n-                 p2i(obj), obj == NULL ? \"\" : obj->klass()->external_name());\n+                 mid->is_busy(), mark.hash() != 0, mid->owner() != nullptr,\n+                 p2i(obj), obj == nullptr ? \"\" : obj->klass()->external_name());\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":46,"deletions":46,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-THREAD_LOCAL Thread* Thread::_thr_current = NULL;\n+THREAD_LOCAL Thread* Thread::_thr_current = nullptr;\n@@ -73,1 +73,1 @@\n-DEBUG_ONLY(Thread* Thread::_starting_thread = NULL;)\n+DEBUG_ONLY(Thread* Thread::_starting_thread = nullptr;)\n@@ -80,1 +80,1 @@\n-  set_stack_base(NULL);\n+  set_stack_base(nullptr);\n@@ -86,1 +86,1 @@\n-  set_osthread(NULL);\n+  set_osthread(nullptr);\n@@ -88,2 +88,2 @@\n-  DEBUG_ONLY(_current_resource_mark = NULL;)\n-  set_handle_area(new (mtThread) HandleArea(NULL));\n+  DEBUG_ONLY(_current_resource_mark = nullptr;)\n+  set_handle_area(new (mtThread) HandleArea(nullptr));\n@@ -91,2 +91,2 @@\n-  set_last_handle_mark(NULL);\n-  DEBUG_ONLY(_missed_ic_stub_refill_verifier = NULL);\n+  set_last_handle_mark(nullptr);\n+  DEBUG_ONLY(_missed_ic_stub_refill_verifier = nullptr);\n@@ -96,2 +96,2 @@\n-  _threads_hazard_ptr = NULL;\n-  _threads_list_ptr = NULL;\n+  _threads_hazard_ptr = nullptr;\n+  _threads_list_ptr = nullptr;\n@@ -105,1 +105,1 @@\n-  debug_only(_owned_locks = NULL;)\n+  debug_only(_owned_locks = nullptr;)\n@@ -109,1 +109,1 @@\n-  _current_pending_raw_monitor = NULL;\n+  _current_pending_raw_monitor = nullptr;\n@@ -137,1 +137,1 @@\n-  if (barrier_set != NULL) {\n+  if (barrier_set != nullptr) {\n@@ -144,1 +144,1 @@\n-    assert(Thread::current_or_null() == NULL, \"creating thread before barrier set\");\n+    assert(Thread::current_or_null() == nullptr, \"creating thread before barrier set\");\n@@ -158,1 +158,1 @@\n-  assert(_thr_current == NULL, \"Thread::current already initialized\");\n+  assert(_thr_current == nullptr, \"Thread::current already initialized\");\n@@ -161,1 +161,1 @@\n-  assert(ThreadLocalStorage::thread() == NULL, \"ThreadLocalStorage::thread already initialized\");\n+  assert(ThreadLocalStorage::thread() == nullptr, \"ThreadLocalStorage::thread already initialized\");\n@@ -169,1 +169,1 @@\n-  _thr_current = NULL;\n+  _thr_current = nullptr;\n@@ -171,1 +171,1 @@\n-  ThreadLocalStorage::set_thread(NULL);\n+  ThreadLocalStorage::set_thread(nullptr);\n@@ -202,1 +202,1 @@\n-  assert(Thread::current_or_null() != NULL, \"current thread is unset\");\n+  assert(Thread::current_or_null() != nullptr, \"current thread is unset\");\n@@ -229,1 +229,1 @@\n-  assert(Thread::current_or_null() != NULL, \"current thread is unset\");\n+  assert(Thread::current_or_null() != nullptr, \"current thread is unset\");\n@@ -242,1 +242,1 @@\n-  assert(Thread::current_or_null() == NULL, \"current thread still present\");\n+  assert(Thread::current_or_null() == nullptr, \"current thread still present\");\n@@ -257,1 +257,1 @@\n-  if (barrier_set != NULL) {\n+  if (barrier_set != nullptr) {\n@@ -265,1 +265,1 @@\n-  assert(last_handle_mark() != NULL, \"check we have an element\");\n+  assert(last_handle_mark() != nullptr, \"check we have an element\");\n@@ -267,1 +267,1 @@\n-  assert(last_handle_mark() == NULL, \"check we have reached the end\");\n+  assert(last_handle_mark() == nullptr, \"check we have reached the end\");\n@@ -270,2 +270,2 @@\n-  \/\/ Set to NULL as a termination indicator for has_terminated().\n-  Atomic::store(&_ParkEvent, (ParkEvent*)NULL);\n+  \/\/ Set to null as a termination indicator for has_terminated().\n+  Atomic::store(&_ParkEvent, (ParkEvent*)nullptr);\n@@ -276,2 +276,2 @@\n-  \/\/ osthread() can be NULL, if creation of thread failed.\n-  if (osthread() != NULL) os::free_thread(osthread());\n+  \/\/ osthread() can be nullptr, if creation of thread failed.\n+  if (osthread() != nullptr) os::free_thread(osthread());\n@@ -318,1 +318,1 @@\n-  if (target->osthread() == NULL || target->osthread()->get_state() <= INITIALIZED) {\n+  if (target->osthread() == nullptr || target->osthread()->get_state() <= INITIALIZED) {\n@@ -360,1 +360,1 @@\n-       stlp != NULL; stlp = stlp->previous()) {\n+       stlp != nullptr; stlp = stlp->previous()) {\n@@ -420,1 +420,1 @@\n-      assert(_cur_thr->processed_thread() == NULL, \"nesting not supported\");\n+      assert(_cur_thr->processed_thread() == nullptr, \"nesting not supported\");\n@@ -423,1 +423,1 @@\n-      _cur_thr = NULL;\n+      _cur_thr = nullptr;\n@@ -429,2 +429,2 @@\n-      assert(_cur_thr->processed_thread() != NULL, \"nesting not supported\");\n-      _cur_thr->set_processed_thread(NULL);\n+      assert(_cur_thr->processed_thread() != nullptr, \"nesting not supported\");\n+      _cur_thr->set_processed_thread(nullptr);\n@@ -444,1 +444,1 @@\n-  if (metadata_handles() != NULL) {\n+  if (metadata_handles() != nullptr) {\n@@ -453,1 +453,1 @@\n-  if (osthread() != NULL) {\n+  if (osthread() != nullptr) {\n@@ -494,1 +494,1 @@\n-  if (os_thr != NULL) {\n+  if (os_thr != nullptr) {\n@@ -518,1 +518,1 @@\n-  if (cur == NULL) {\n+  if (cur == nullptr) {\n@@ -541,1 +541,1 @@\n-  assert(_starting_thread == NULL, \"already initialized: \"\n+  assert(_starting_thread == nullptr, \"already initialized: \"\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,1 +180,1 @@\n-  bool found = ik != NULL &&\n+  bool found = ik != nullptr &&\n@@ -185,2 +185,2 @@\n-    if (name_oop == NULL) {\n-      return NULL;\n+    if (name_oop == nullptr) {\n+      return nullptr;\n@@ -191,1 +191,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -221,1 +221,1 @@\n-  if (klass != NULL) {\n+  if (klass != nullptr) {\n@@ -258,0 +258,2 @@\n+  assert_at_safepoint();\n+\n@@ -264,3 +266,5 @@\n-  VMThread* vmt = VMThread::vm_thread();\n-  if (vmt->claim_threads_do(is_par, claim_token)) {\n-    tc->do_thread(vmt);\n+  for (NonJavaThread::Iterator njti; !njti.end(); njti.step()) {\n+    Thread* current = njti.current();\n+    if (current->claim_threads_do(is_par, claim_token)) {\n+      tc->do_thread(current);\n+    }\n@@ -523,1 +527,1 @@\n-    JavaThread::_jvmci_old_thread_counters = NULL;\n+    JavaThread::_jvmci_old_thread_counters = nullptr;\n@@ -821,2 +825,2 @@\n-  OnLoadEntry_t on_load_entry = NULL;\n-  void *library = NULL;\n+  OnLoadEntry_t on_load_entry = nullptr;\n+  void *library = nullptr;\n@@ -835,1 +839,1 @@\n-      if (library == NULL) {\n+      if (library == nullptr) {\n@@ -841,1 +845,1 @@\n-        vm_exit_during_initialization(buf, NULL);\n+        vm_exit_during_initialization(buf, nullptr);\n@@ -850,1 +854,1 @@\n-      if (library == NULL) { \/\/ Try the library path directory.\n+      if (library == nullptr) { \/\/ Try the library path directory.\n@@ -854,1 +858,1 @@\n-        if (library == NULL) {\n+        if (library == nullptr) {\n@@ -867,1 +871,1 @@\n-          vm_exit_during_initialization(buf, NULL);\n+          vm_exit_during_initialization(buf, nullptr);\n@@ -905,1 +909,1 @@\n-  for (agent = Arguments::libraries(); agent != NULL; agent = next) {\n+  for (agent = Arguments::libraries(); agent != nullptr; agent = next) {\n@@ -911,1 +915,1 @@\n-    if (on_load_entry == NULL) {\n+    if (on_load_entry == nullptr) {\n@@ -913,1 +917,1 @@\n-      if (on_load_entry != NULL) {\n+      if (on_load_entry != nullptr) {\n@@ -933,1 +937,1 @@\n-  for (agent = Arguments::agents(); agent != NULL; agent = agent->next()) {\n+  for (agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n@@ -947,1 +951,1 @@\n-    if (on_load_entry != NULL) {\n+    if (on_load_entry != nullptr) {\n@@ -949,1 +953,1 @@\n-      jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);\n+      jint err = (*on_load_entry)(&main_vm, agent->options(), nullptr);\n@@ -970,1 +974,1 @@\n-  for (AgentLibrary* agent = Arguments::agents(); agent != NULL; agent = agent->next()) {\n+  for (AgentLibrary* agent = Arguments::agents(); agent != nullptr; agent = agent->next()) {\n@@ -980,1 +984,1 @@\n-    if (unload_entry != NULL) {\n+    if (unload_entry != nullptr) {\n@@ -995,1 +999,1 @@\n-  for (agent = Arguments::libraries(); agent != NULL; agent = agent->next()) {\n+  for (agent = Arguments::libraries(); agent != nullptr; agent = agent->next()) {\n@@ -998,1 +1002,1 @@\n-    if (on_load_entry != NULL) {\n+    if (on_load_entry != nullptr) {\n@@ -1003,1 +1007,1 @@\n-      jint err = (*on_load_entry)(&main_vm, agent->options(), NULL);\n+      jint err = (*on_load_entry)(&main_vm, agent->options(), nullptr);\n@@ -1309,1 +1313,1 @@\n-    assert_thread_claimed(\"Thread\", p, _thread_claim_token);\n+    assert_thread_claimed(\"JavaThread\", p, _thread_claim_token);\n@@ -1311,1 +1315,12 @@\n-  assert_thread_claimed(\"VMThread\", VMThread::vm_thread(), _thread_claim_token);\n+\n+  struct NJTClaimedVerifierClosure : public ThreadClosure {\n+    uintx _thread_claim_token;\n+\n+    NJTClaimedVerifierClosure(uintx thread_claim_token) : ThreadClosure(), _thread_claim_token(thread_claim_token) { }\n+\n+    virtual void do_thread(Thread* thread) override {\n+      assert_thread_claimed(\"Non-JavaThread\", VMThread::vm_thread(), _thread_claim_token);\n+    }\n+  } tc(_thread_claim_token);\n+\n+  non_java_threads_do(&tc);\n@@ -1378,2 +1393,2 @@\n-  \/\/ NULL owner means not locked so we can skip the search\n-  if (owner == NULL) return NULL;\n+  \/\/ null owner means not locked so we can skip the search\n+  if (owner == nullptr) return nullptr;\n@@ -1389,1 +1404,1 @@\n-  if (UseHeavyMonitors) return NULL;\n+  if (UseHeavyMonitors) return nullptr;\n@@ -1395,1 +1410,1 @@\n-  JavaThread* the_owner = NULL;\n+  JavaThread* the_owner = nullptr;\n@@ -1414,1 +1429,1 @@\n-  return NULL;\n+  return nullptr;\n@@ -1423,1 +1438,1 @@\n-      assert(owner == NULL || owner->is_Java_thread(), \"only JavaThreads own monitors\");\n+      assert(owner == nullptr || owner->is_Java_thread(), \"only JavaThreads own monitors\");\n@@ -1441,1 +1456,1 @@\n-    if (thread != NULL) {\n+    if (thread != nullptr) {\n@@ -1504,1 +1519,1 @@\n-  if (this_thread != NULL) {\n+  if (this_thread != nullptr) {\n@@ -1553,1 +1568,1 @@\n-  if (Universe::heap() != NULL) {\n+  if (Universe::heap() != nullptr) {\n@@ -1580,2 +1595,2 @@\n-      \/\/ Keep task in local variable for NULL check.\n-      \/\/ ct->_task might be set to NULL by concurring compiler thread\n+      \/\/ Keep task in local variable for null check.\n+      \/\/ ct->_task might be set to null by concurring compiler thread\n@@ -1585,1 +1600,1 @@\n-      if (task != NULL) {\n+      if (task != nullptr) {\n@@ -1588,1 +1603,1 @@\n-        task->print(st, NULL, short_form, true);\n+        task->print(st, nullptr, short_form, true);\n@@ -1599,1 +1614,1 @@\n-  if (thread != NULL) thread->verify();\n+  if (thread != nullptr) thread->verify();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":59,"deletions":44,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+private:\n@@ -101,0 +102,2 @@\n+\n+public:\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-  VM_Operation() : _calling_thread(NULL) {}\n+  VM_Operation() : _calling_thread(nullptr) {}\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -382,6 +382,0 @@\n-  \/******\/                                                                                                                           \\\n-  \/* os *\/                                                                                                                           \\\n-  \/******\/                                                                                                                           \\\n-                                                                                                                                     \\\n-     static_field(os,                          _polling_page,                                 address)                               \\\n-                                                                                                                                     \\\n@@ -819,1 +813,1 @@\n-  nonstatic_field(ciMethod,                    _instructions_size,                            int)                                   \\\n+  nonstatic_field(ciMethod,                    _inline_instructions_size,                     int)                                   \\\n@@ -3083,1 +3077,1 @@\n-    while (types->typeName != NULL) {\n+    while (types->typeName != nullptr) {\n@@ -3104,1 +3098,1 @@\n-  const char* start = NULL;\n+  const char* start = nullptr;\n@@ -3110,1 +3104,1 @@\n-  if (start != NULL) {\n+  if (start != nullptr) {\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include <cstdint>\n@@ -124,0 +125,1 @@\n+#define INT64_PLUS_FORMAT        \"%+\"         PRId64\n@@ -191,0 +193,1 @@\n+FORBID_C_FUNCTION(int sprintf(char*, const char*, ...), \"use os::snprintf\");\n@@ -527,0 +530,7 @@\n+\/\/ Additional Java basic types\n+\n+typedef uint8_t  jubyte;\n+typedef uint16_t jushort;\n+typedef uint32_t juint;\n+typedef uint64_t julong;\n+\n@@ -1046,1 +1056,0 @@\n-#define       badOop            (cast_to_oop(::badOopVal))\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-\/\/  while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr) != NULL)\n+\/\/  while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr) != nullptr)\n@@ -131,1 +131,1 @@\n-  if (ptr == NULL || *ptr == NULL) return NULL;\n+  if (ptr == nullptr || *ptr == nullptr) return nullptr;\n@@ -138,1 +138,1 @@\n-  if (*cmd == '\\0') return NULL;\n+  if (*cmd == '\\0') return nullptr;\n@@ -150,1 +150,1 @@\n-  if (out == NULL) return;\n+  if (out == nullptr) return;\n@@ -152,1 +152,1 @@\n-  if (url == NULL || *url == '\\0')\n+  if (url == nullptr || *url == '\\0')\n@@ -154,1 +154,1 @@\n-  if (url != NULL && *url != '\\0') {\n+  if (url != nullptr && *url != '\\0') {\n@@ -186,1 +186,1 @@\n-  } else if (_filename != NULL && _lineno > 0) {\n+  } else if (_filename != nullptr && _lineno > 0) {\n@@ -275,1 +275,1 @@\n- * @param printed array of code units that have already been printed (delimited by NULL entry)\n+ * @param printed array of code units that have already been printed (delimited by nullptr entry)\n@@ -430,1 +430,1 @@\n-   const char* runtime_name = JDK_Version::runtime_name() != NULL ?\n+   const char* runtime_name = JDK_Version::runtime_name() != nullptr ?\n@@ -432,1 +432,1 @@\n-   const char* runtime_version = JDK_Version::runtime_version() != NULL ?\n+   const char* runtime_version = JDK_Version::runtime_version() != nullptr ?\n@@ -434,1 +434,1 @@\n-   const char* vendor_version = JDK_Version::runtime_vendor_version() != NULL ?\n+   const char* vendor_version = JDK_Version::runtime_vendor_version() != nullptr ?\n@@ -436,1 +436,1 @@\n-   const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != NULL ?\n+   const char* jdk_debug_level = VM_Version::printable_jdk_debug_level() != nullptr ?\n@@ -675,1 +675,1 @@\n-      if (_siginfo != NULL && os::signal_sent_by_kill(_siginfo)) {\n+      if (_siginfo != nullptr && os::signal_sent_by_kill(_siginfo)) {\n@@ -684,1 +684,1 @@\n-      if (_filename != NULL && _lineno > 0) {\n+      if (_filename != nullptr && _lineno > 0) {\n@@ -842,1 +842,1 @@\n-    if (thread != NULL && thread->is_Java_thread()) {\n+    if (thread != nullptr && thread->is_Java_thread()) {\n@@ -1010,1 +1010,1 @@\n-    if (Universe::heap() != NULL) {\n+    if (Universe::heap() != nullptr) {\n@@ -1303,1 +1303,1 @@\n-  if (pattern != NULL) {\n+  if (pattern != nullptr) {\n@@ -1311,1 +1311,1 @@\n-    if (cwd != NULL) {\n+    if (cwd != nullptr) {\n@@ -1324,1 +1324,1 @@\n-     if (tmpdir != NULL && strlen(tmpdir) > 0) {\n+     if (tmpdir != nullptr && strlen(tmpdir) > 0) {\n@@ -1340,1 +1340,1 @@\n-  report_and_die(sig, NULL, detail_fmt, detail_args, thread, pc, siginfo, context, NULL, 0, 0);\n+  report_and_die(sig, nullptr, detail_fmt, detail_args, thread, pc, siginfo, context, nullptr, 0, 0);\n@@ -1352,1 +1352,1 @@\n-  report_and_die(INTERNAL_ERROR, message, detail_fmt, detail_args, thread, NULL, NULL, context, filename, lineno, 0);\n+  report_and_die(INTERNAL_ERROR, message, detail_fmt, detail_args, thread, nullptr, nullptr, context, filename, lineno, 0);\n@@ -1357,1 +1357,1 @@\n-  report_and_die(vm_err_type, NULL, detail_fmt, detail_args, thread, NULL, NULL, NULL, filename, lineno, size);\n+  report_and_die(vm_err_type, nullptr, detail_fmt, detail_args, thread, nullptr, nullptr, nullptr, filename, lineno, size);\n@@ -1518,1 +1518,1 @@\n-              filename == NULL ? \"??\" : filename, lineno);\n+              filename == nullptr ? \"??\" : filename, lineno);\n@@ -1521,1 +1521,1 @@\n-              filename == NULL ? \"??\" : filename, lineno);\n+              filename == nullptr ? \"??\" : filename, lineno);\n@@ -1613,1 +1613,1 @@\n-    if (env != NULL) {\n+    if (env != nullptr) {\n@@ -1618,1 +1618,1 @@\n-        if (replay_data_file != NULL) {\n+        if (replay_data_file != nullptr) {\n@@ -1633,1 +1633,1 @@\n-  if (JVMCI::fatal_log_filename() != NULL) {\n+  if (JVMCI::fatal_log_filename() != nullptr) {\n@@ -1661,1 +1661,1 @@\n-    while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != NULL){\n+    while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != nullptr){\n@@ -1679,1 +1679,1 @@\n-    OnError = NULL;\n+    OnError = nullptr;\n@@ -1722,1 +1722,1 @@\n-  while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != NULL){\n+  while ((cmd = next_OnError_command(buffer, sizeof(buffer), &ptr)) != nullptr){\n@@ -1764,2 +1764,2 @@\n-      || (OnError != NULL && OnError[0] != '\\0')\n-      || Arguments::abort_hook() != NULL) {\n+      || (OnError != nullptr && OnError[0] != '\\0')\n+      || Arguments::abort_hook() != nullptr) {\n@@ -1807,1 +1807,1 @@\n-static void crash_with_sigfpe() {\n+static void ALWAYSINLINE crash_with_sigfpe() {\n@@ -1823,1 +1823,1 @@\n-static void crash_with_segfault() {\n+static void ALWAYSINLINE crash_with_segfault() {\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":35,"deletions":35,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_status._flags\", Integer.class, \"u2\");\n+    final int instanceKlassMiscFlagsOffset = getFieldOffset(\"InstanceKlass::_misc_flags._flags\", Integer.class, \"u2\");\n@@ -144,2 +144,2 @@\n-    final int jvmMiscFlagsHasDefaultMethods = getConstant(\"InstanceKlassMiscStatus::_misc_has_nonstatic_concrete_methods\", Integer.class);\n-    final int jvmMiscFlagsDeclaresDefaultMethods = getConstant(\"InstanceKlassMiscStatus::_misc_declares_nonstatic_concrete_methods\", Integer.class);\n+    final int jvmMiscFlagsHasDefaultMethods = getConstant(\"InstanceKlassFlags::_misc_has_nonstatic_concrete_methods\", Integer.class);\n+    final int jvmMiscFlagsDeclaresDefaultMethods = getConstant(\"InstanceKlassFlags::_misc_declares_nonstatic_concrete_methods\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -172,0 +172,4 @@\n+\n+\n+Lilliput temporary:\n+compiler\/c2\/irTests\/TestVectorizationNotRun.java 8301785 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+            \/*\n@@ -155,0 +156,1 @@\n+            *\/\n@@ -173,0 +175,1 @@\n+            \/*\n@@ -178,0 +181,1 @@\n+            *\/\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointerEncoding.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static final long min_class_space_size = 4194304;\n+    static final long min_class_space_size = 16777216;\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassSpaceSize.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}