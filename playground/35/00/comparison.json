{"files":[{"patch":"@@ -0,0 +1,668 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.util.Arrays;\n+import java.security.*;\n+import java.security.spec.*;\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+\n+\/**\n+ * This class acts as the base class for AES KeyWrap algorithms as defined\n+ * in <a href=https:\/\/nvlpubs.nist.gov\/nistpubs\/SpecialPublications\/NIST.SP.800-38F.pdf>\n+ * \"Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping\"\n+ *\/\n+abstract class KeyWrapBaseCipher extends CipherSpi {\n+\n+    \/\/ In NIST SP 800-38F, KWP input size is limited to be no longer\n+    \/\/ than 2^32 bytes. Otherwise, the length cannot be encoded in 32 bits\n+    \/\/ However, given the current spec requirement that recovered text\n+    \/\/ can only be returned after successful tag verification, we are\n+    \/\/ bound by limiting the data size to the size limit of\n+    \/\/ java byte array, e.g. Integer.MAX_VALUE, since all data\n+    \/\/ can only be returned by the doFinal(...) call.\n+    private static final int MAX_BUF_SIZE = Integer.MAX_VALUE;\n+    protected static final int BLKSIZE = 16;\n+    protected static final int SEMI_BLKSIZE = BLKSIZE >> 1;\n+\n+    private static void checkDataLength(ByteArrayOutputStream buf, int len) {\n+        if (buf == null) return;\n+        int buffered = buf.size();\n+        if (len > MAX_BUF_SIZE - buffered) {\n+            throw new ProviderException(\"SunJCE provider only supports \" +\n+                \"input size up to \" + MAX_BUF_SIZE + \" bytes\");\n+        }\n+    }\n+\n+    \/*\n+     * Enhanced version of the wrapping function W as defined in section 6.1\n+     * of NIST SP 800-38F as well as sec 2.2.1 of RFC 3394.\n+     * Enhanced w\/ additional handling as below:\n+     * - separated out the initial value from the plain text and expanded the\n+     *   loop for j = 0 separately to minimize data copying\n+     * - relaxed ptLen requirement and added padding bytes as needed (see the\n+     *   zeroize code)\n+     * @param iv the initial value (length: SEMI_BLKSIZE). For KW, iv=ICV1.\n+     *         For KWP, iv = ICV2 || 32-bit encoding of input length (in bytes).\n+     * @param pt input bytes\n+     * @param ptOfs starting offset into the input bytes\n+     * @param ptLen length of the to-be-wrapped bytes\n+     * @param out output buffer for the wrapped bytes\n+     * @param outOfs starting offset for the output buffer\n+     * @param cipher the initialized cipher object used for the wrapping\n+     *\/\n+    protected static final void W(byte[] iv, byte[] pt, int ptOfs, int ptLen,\n+            byte[] out, int outOfs, SymmetricCipher cipher) {\n+\n+        int n = (ptLen + SEMI_BLKSIZE - 1) \/ SEMI_BLKSIZE;\n+        \/\/System.out.println(\"W: inLen = \" +  ptLen + \", n = \" + n);\n+\n+        byte[] buffer = new byte[BLKSIZE];\n+\n+        System.arraycopy(iv, 0, buffer, 0, SEMI_BLKSIZE);\n+        System.arraycopy(pt, ptOfs, buffer, SEMI_BLKSIZE, SEMI_BLKSIZE);\n+        \/\/System.out.println(\"W: copy pt from \" + ptOfs + \" to \" + SEMI_BLKSIZE);\n+\n+        \/\/ for j = 0, use the value from 'iv' and 'pt'\n+        for (int i = 1; i <= n; i++) {\n+            int T = i;\n+            int idx = i<<3;\n+            cipher.encryptBlock(buffer, 0, buffer, 0);\n+            \/\/ MSB(64, B) xor T\n+            for (int k = 1; T != 0 && k < 5; k++) {\n+                byte v = (byte) T;\n+                buffer[SEMI_BLKSIZE - k] ^= v;\n+                T >>>= SEMI_BLKSIZE;\n+            }\n+            System.arraycopy(buffer, 0, out, outOfs, SEMI_BLKSIZE);\n+            System.arraycopy(buffer, SEMI_BLKSIZE, out, outOfs + idx,\n+                    SEMI_BLKSIZE);\n+            if (i < n) {\n+                int len = ((i == n-1)? (ptLen - idx): SEMI_BLKSIZE);\n+                \/\/System.out.println(\"W: copy pt from \" +  (ptOfs + idx) +\n+                \/\/        \" to \" + (ptOfs + idx + len));\n+                System.arraycopy(pt, ptOfs + idx, buffer, SEMI_BLKSIZE, len);\n+                if (len != SEMI_BLKSIZE) { \/\/ need to zeroize the rest\n+                    Arrays.fill(buffer, SEMI_BLKSIZE + len, BLKSIZE, (byte) 0);\n+                }\n+            }\n+        }\n+\n+        \/\/ for j = 1...5, use the processed value stored into 'out' when\n+        \/\/ j = 0\n+        for (int j = 1; j < 6; j++) {\n+            for (int i = 1; i <= n; i++) {\n+                int T = n*j + i;\n+                int idx = Math.addExact(outOfs, i<<3);\n+\n+                System.arraycopy(out, outOfs, buffer, 0, SEMI_BLKSIZE);\n+                System.arraycopy(out, idx, buffer, SEMI_BLKSIZE, SEMI_BLKSIZE);\n+                cipher.encryptBlock(buffer, 0, buffer, 0);\n+                for (int k = 1; T != 0; k++) {\n+                    byte v = (byte) T;\n+                    buffer[SEMI_BLKSIZE - k] ^= v;\n+                    T >>>= SEMI_BLKSIZE;\n+                }\n+                System.arraycopy(buffer, 0, out, outOfs, SEMI_BLKSIZE);\n+                System.arraycopy(buffer, SEMI_BLKSIZE, out, idx, SEMI_BLKSIZE);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Enhanced version of the unwrapping function W^-1 as defined in section\n+     * 6.1 of NIST SP 800-38F as well as sec 2.2.2 of RFC 3394.\n+     * Enhanced w\/ additional handling as below:\n+     * - separated out the initial value from the remaining recovered data\n+     * - since we cannot write out the recovered data until the initial\n+     *   value and padding bytes are verified. Allocate buffer for the\n+     *   recovered data and return to the caller instead of accepting output\n+     *   buffer argument.\n+     * @param ct input bytes, i.e. the to-be-unwrapped data\n+     * @param ctOfs starting offset into the input bytes\n+     * @param ctLen length of the to-be-unwrapped bytes\n+     * @param ivOut buffer for holding the initial value after unwrapping\n+     * @param cipher the initialized cipher object used for the wrapping\n+     *\/\n+    protected static final byte[] W_INV(byte[] ct, int ctOfs, int ctLen,\n+            byte[] ivOut, SymmetricCipher cipher) {\n+\n+        byte[] buffer = new byte[BLKSIZE];\n+        System.arraycopy(ct, ctOfs, buffer, 0, SEMI_BLKSIZE);\n+        byte[] out = Arrays.copyOfRange(ct, ctOfs + SEMI_BLKSIZE,\n+            ctOfs + ctLen);\n+        int n = out.length \/ SEMI_BLKSIZE;\n+\n+        for (int j = 5; j >= 0; j--) {\n+            for (int i = n; i > 0; i--) {\n+                int T = n*j + i;\n+                int idx = (i-1) << 3;\n+                System.arraycopy(out, idx, buffer, SEMI_BLKSIZE, SEMI_BLKSIZE);\n+                for (int k = 1; T != 0; k++) {\n+                    byte v = (byte) T;\n+                    buffer[SEMI_BLKSIZE - k] ^= v;\n+                    T >>>= SEMI_BLKSIZE;\n+                }\n+                cipher.decryptBlock(buffer, 0, buffer, 0);\n+                System.arraycopy(buffer, SEMI_BLKSIZE, out, idx, SEMI_BLKSIZE);\n+            }\n+        }\n+        System.arraycopy(buffer, 0, ivOut, 0, SEMI_BLKSIZE);\n+        return out;\n+    }\n+\n+    abstract protected int implGetOutputSize(int inLen);\n+\n+    abstract protected int implEncrypt(byte[] in, int inOfs, int inLen,\n+            byte[] out, int outOfs) throws IllegalBlockSizeException;\n+\n+    abstract protected int implDecrypt(byte[] in, int inOfs, int inLen,\n+            byte[] out, int outOfs) throws IllegalBlockSizeException;\n+\n+    \/*\n+     * internal cipher object which does the real work.\n+     *\/\n+    protected SymmetricCipher cipher;\n+\n+    \/*\n+     * are we encrypting or decrypting?\n+     *\/\n+    protected boolean decrypting = false;\n+\n+    \/*\n+     * needed to support oids which associates a fixed key size\n+     * to the cipher object.\n+     *\/\n+    private final int fixedKeySize; \/\/ in bytes, -1 if no restriction\n+    private final String mode; \/\/ null if no restriction\n+    private final String padding; \/\/ null if no restriction\n+    private final boolean wrapOnly;\n+    \/\/ When wrapOnly == false; input buffering is needed for supporting\n+    \/\/ multi-part encryption\/decryption\n+    private final ByteArrayOutputStream dataBuf;\n+\n+    \/**\n+     * Creates an instance of KeyWrap cipher using the specified\n+     * symmetric cipher whose block size must be 128-bit, and\n+     * the supported mode and padding scheme.\n+     *\/\n+    public KeyWrapBaseCipher(SymmetricCipher cipher, int keySize,\n+            String mode, String padding) {\n+        System.out.println(\"KeyWrapBaseCipher: \" + keySize + \", \" +\n+                mode + \", \" + padding);\n+        if (cipher.getBlockSize() != BLKSIZE) {\n+            throw new ProviderException(\"Invalid block size for KeyWrap\");\n+        }\n+        this.cipher = cipher;\n+        this.fixedKeySize = keySize;\n+        this.mode = mode;\n+        this.padding = padding;\n+        this.wrapOnly = mode.equalsIgnoreCase(\"ECB\");\n+        this.dataBuf = (wrapOnly? null : new ByteArrayOutputStream());\n+    }\n+\n+    \/**\n+     * Sets the mode of this cipher. Must match the mode specified in\n+     * the constructor.\n+     *\n+     * @param mode the cipher mode\n+     *\n+     * @exception NoSuchAlgorithmException if the requested cipher mode\n+     * does not match the supported mode\n+     *\/\n+    @Override\n+    protected void engineSetMode(String mode)\n+        throws NoSuchAlgorithmException {\n+        if (mode != null && !this.mode.equalsIgnoreCase(mode)) {\n+            throw new NoSuchAlgorithmException(mode + \" cannot be used\");\n+        }\n+    }\n+\n+    \/**\n+     * Sets the padding mechanism of this cipher. Currently, only\n+     * \"NoPadding\" scheme is accepted for this cipher.\n+     *\n+     * @param padding the padding mechanism\n+     *\n+     * @exception NoSuchPaddingException if the requested padding mechanism\n+     * does not match the supported padding scheme\n+     *\/\n+    @Override\n+    protected void engineSetPadding(String padding)\n+        throws NoSuchPaddingException {\n+        if (padding != null && !this.padding.equalsIgnoreCase(padding)) {\n+            throw new NoSuchPaddingException(padding + \" cannot be used\");\n+        }\n+    }\n+\n+    \/**\n+     * Returns the block size (in bytes). i.e. 16 bytes.\n+     *\n+     * @return the block size (in bytes), i.e. 16 bytes.\n+     *\/\n+    @Override\n+    protected int engineGetBlockSize() {\n+        return BLKSIZE;\n+    }\n+\n+    \/**\n+     * Returns the length in bytes that an output buffer would need to be\n+     * given the input length <code>inputLen<\/code> (in bytes).\n+     *\n+     * <p>The actual output length of the next <code>update<\/code> or\n+     * <code>doFinal<\/code> call may be smaller than the length returned\n+     * by this method.\n+     *\n+     * @param inputLen the input length (in bytes)\n+     *\n+     * @return the required output buffer size (in bytes)\n+     *\/\n+    protected int engineGetOutputSize(int inputLen) {\n+        int bufferedLen = (dataBuf == null? 0 : dataBuf.size());\n+        return implGetOutputSize(bufferedLen + inputLen);\n+    }\n+\n+    \/**\n+     * Returns the initialization vector (IV) which is null for this cipher.\n+     *\n+     * @return null for this cipher.\n+     *\/\n+    @Override\n+    protected byte[] engineGetIV() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Initializes this cipher with a key and a source of randomness.\n+     *\n+     * <p>The cipher only supports the following two operation modes:<b>\n+     * Cipher.WRAP_MODE, and <b>\n+     * Cipher.UNWRAP_MODE.\n+     * <p>For modes other than the above two, UnsupportedOperationException\n+     * will be thrown.\n+     *\n+     * @param opmode the operation mode of this cipher. Only\n+     * <code>WRAP_MODE<\/code> or <code>UNWRAP_MODE<\/code>) are accepted.\n+     * @param key the secret key.\n+     * @param random the source of randomness.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher.\n+     *\/\n+    @Override\n+    protected void engineInit(int opmode, Key key, SecureRandom random)\n+        throws InvalidKeyException {\n+        if (wrapOnly &&\n+            (opmode == Cipher.ENCRYPT_MODE || opmode == Cipher.ENCRYPT_MODE)) {\n+            throw new UnsupportedOperationException(\"This cipher can \" +\n+                    \"only be used for key wrapping and unwrapping\");\n+        }\n+        decrypting = (opmode == Cipher.DECRYPT_MODE ||\n+                opmode == Cipher.UNWRAP_MODE);\n+        \/\/AESCipher.checkKeySize(key, fixedKeySize);\n+        \/\/XXX need to add this to SymmetricCipher\n+        cipher.init(decrypting, key.getAlgorithm(), key.getEncoded());\n+    }\n+\n+    \/**\n+     * Initializes this cipher with a key, a set of algorithm parameters,\n+     * and a source of randomness.\n+     *\n+     * <p>The cipher only supports the following two operation modes:<b>\n+     * Cipher.WRAP_MODE, and <b>\n+     * Cipher.UNWRAP_MODE.\n+     * <p>For modes other than the above two, UnsupportedOperationException\n+     * will be thrown.\n+     *\n+     * @param opmode the operation mode of this cipher. Only\n+     * <code>WRAP_MODE<\/code> or <code>UNWRAP_MODE<\/code>) are accepted.\n+     * @param key the secret key.\n+     * @param params the algorithm parameters; must be null for this cipher.\n+     * @param random the source of randomness.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this cipher\n+     * @exception InvalidAlgorithmParameterException if the given algorithm\n+     * parameters is not null.\n+     *\/\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+                              AlgorithmParameterSpec params,\n+                              SecureRandom random)\n+        throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidAlgorithmParameterException(\"This cipher \" +\n+                \"does not accept any parameters\");\n+        }\n+        engineInit(opmode, key, random);\n+    }\n+\n+    \/**\n+     * Initializes this cipher with a key, a set of algorithm parameters,\n+     * and a source of randomness.\n+     *\n+     * <p>The cipher only supports the following two operation modes:<b>\n+     * Cipher.WRAP_MODE, and <b>\n+     * Cipher.UNWRAP_MODE.\n+     * <p>For modes other than the above two, UnsupportedOperationException\n+     * will be thrown.\n+     *\n+     * @param opmode the operation mode of this cipher. Only\n+     * <code>WRAP_MODE<\/code> or <code>UNWRAP_MODE<\/code>) are accepted.\n+     * @param key the secret key.\n+     * @param params the algorithm parameters; must be null for this cipher.\n+     * @param random the source of randomness.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate.\n+     * @exception InvalidAlgorithmParameterException if the given algorithm\n+     * parameters is not null.\n+     *\/\n+    @Override\n+    protected void engineInit(int opmode, Key key,\n+                              AlgorithmParameters params,\n+                              SecureRandom random)\n+        throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        if (params != null) {\n+            throw new InvalidAlgorithmParameterException(\"This cipher \" +\n+                \"does not accept any parameters\");\n+        }\n+        engineInit(opmode, key, random);\n+    }\n+\n+    \/**\n+     * This operation is not supported by this cipher.\n+     * Since it's impossible to initialize this cipher given the\n+     * current Cipher.engineInit(...) implementation,\n+     * IllegalStateException will always be thrown upon invocation.\n+     *\n+     * @param in the input buffer.\n+     * @param inOffset the offset in <code>in<\/code> where the input\n+     * starts.\n+     * @param inLen the input length.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    @Override\n+    protected byte[] engineUpdate(byte[] in, int inOffset, int inLen) {\n+        if (wrapOnly) {\n+            throw new IllegalStateException(\"Cipher has not been initialized\");\n+        }\n+        checkDataLength(dataBuf, inLen);\n+        dataBuf.write(in, inOffset, inLen);\n+        return null;\n+    }\n+\n+    \/**\n+     * This operation is not supported by this cipher.\n+     * Since it's impossible to initialize this cipher given the\n+     * current Cipher.engineInit(...) implementation,\n+     * IllegalStateException will always be thrown upon invocation.\n+     *\n+     * @param in the input buffer.\n+     * @param inOffset the offset in <code>in<\/code> where the input\n+     * starts.\n+     * @param inLen the input length.\n+     * @param out the buffer for the result.\n+     * @param outOffset the offset in <code>out<\/code> where the result\n+     * is stored.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    @Override\n+    protected int engineUpdate(byte[] in, int inOffset, int inLen,\n+                               byte[] out, int outOffset)\n+        throws ShortBufferException {\n+        if (wrapOnly) {\n+            throw new IllegalStateException(\"Cipher has not been initialized\");\n+        }\n+        checkDataLength(dataBuf, inLen);\n+        dataBuf.write(in, inOffset, inLen);\n+        return 0;\n+    }\n+\n+    \/**\n+     * This operation is not supported by this cipher.\n+     * Since it's impossible to initialize this cipher given the\n+     * current Cipher.engineInit(...) implementation,\n+     * IllegalStateException will always be thrown upon invocation.\n+     *\n+     * @param input the input buffer\n+     * @param inputOffset the offset in <code>in<\/code> where the input\n+     * starts\n+     * @param inputLen the input length.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    @Override\n+    protected byte[] engineDoFinal(byte[] in, int inOfs, int inLen)\n+        throws IllegalBlockSizeException, BadPaddingException {\n+        if (wrapOnly) {\n+            throw new IllegalStateException(\"Cipher has not been initialized\");\n+        }\n+        if (dataBuf.size() > 0) {\n+            if (inLen != 0) {\n+                checkDataLength(dataBuf, inLen);\n+                dataBuf.write(in, inOfs, inLen);\n+            }\n+            byte[] data = dataBuf.toByteArray();\n+            in = data;\n+            inOfs = 0;\n+            inLen = data.length;\n+        }\n+        try {\n+            byte[] out = new byte[implGetOutputSize(inLen)];\n+            int outLen = 0;\n+            if (decrypting) {\n+                outLen = implDecrypt(in, inOfs, inLen, out, 0);\n+            } else {\n+                outLen = implEncrypt(in, inOfs, inLen, out, 0);\n+            }\n+            if (outLen < out.length) {\n+                out = Arrays.copyOf(out, outLen);\n+            }\n+            return out;\n+        } finally {\n+            dataBuf.reset();\n+        }\n+    }\n+\n+    \/**\n+     * This operation is not supported by this cipher.\n+     * Since it's impossible to initialize this cipher given the\n+     * current Cipher.engineInit(...) implementation,\n+     * IllegalStateException will always be thrown upon invocation.\n+     *\n+     * @param in the input buffer.\n+     * @param inOffset the offset in <code>in<\/code> where the input\n+     * starts.\n+     * @param inLen the input length.\n+     * @param out the buffer for the result.\n+     * @param outOffset the ofset in <code>out<\/code> where the result\n+     * is stored.\n+     *\n+     * @return n\/a.\n+     *\n+     * @exception IllegalStateException upon invocation of this method.\n+     *\/\n+    protected int engineDoFinal(byte[] in, int inOfs, int inLen,\n+                                byte[] out, int outOfs)\n+        throws IllegalBlockSizeException, ShortBufferException,\n+               BadPaddingException {\n+        if (wrapOnly) {\n+            throw new IllegalStateException(\"Cipher has not been initialized\");\n+        }\n+        if (dataBuf.size() > 0) {\n+            if (inLen != 0) {\n+                checkDataLength(dataBuf, inLen);\n+                dataBuf.write(in, inOfs, inLen);\n+            }\n+            byte[] data = dataBuf.toByteArray();\n+            in = data;\n+            inOfs = 0;\n+            inLen = data.length;\n+        }\n+        int estOutLen = implGetOutputSize(inLen);\n+        if (out.length - outOfs < estOutLen) {\n+            throw new ShortBufferException(\"Need at least \" + estOutLen);\n+        }\n+        try {\n+            int outLen = 0;\n+            byte[] out2 = new byte[estOutLen];\n+            if (decrypting) {\n+                outLen = implDecrypt(in, inOfs, inLen, out2, 0);\n+            } else {\n+                outLen = implEncrypt(in, inOfs, inLen, out2, 0);\n+            }\n+            \/\/ can only write out the result after verification succeeds\n+            System.arraycopy(out2, 0, out, outOfs, outLen);\n+            return outLen;\n+        } finally {\n+            dataBuf.reset();\n+        }\n+\n+    }\n+\n+    \/**\n+     * Returns the parameters used with this cipher which is always null\n+     * for this cipher.\n+     *\n+     * @return null since this cipher does not use any parameters.\n+     *\/\n+    @Override\n+    protected AlgorithmParameters engineGetParameters() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the key size of the given key object in number of bits.\n+     *\n+     * @param key the key object.\n+     *\n+     * @return the \"effective\" key size of the given key object.\n+     *\n+     * @exception InvalidKeyException if <code>key<\/code> is invalid.\n+     *\/\n+    protected int engineGetKeySize(Key key) throws InvalidKeyException {\n+        byte[] encoded = key.getEncoded();\n+        if ((cipher instanceof AESCrypt) &&\n+            !AESCrypt.isKeySizeValid(encoded.length)) {\n+            throw new InvalidKeyException(\"Invalid key length: \" +\n+                                          encoded.length + \" bytes\");\n+        }\n+        return Math.multiplyExact(encoded.length, 8);\n+    }\n+\n+    \/**\n+     * Wrap a key.\n+     *\n+     * @param key the key to be wrapped.\n+     *\n+     * @return the wrapped key.\n+     *\n+     * @exception IllegalBlockSizeException if this cipher is a block\n+     * cipher, no padding has been requested, and the length of the\n+     * encoding of the key to be wrapped is not a\n+     * multiple of the block size.\n+     *\n+     * @exception InvalidKeyException if it is impossible or unsafe to\n+     * wrap the key with this cipher (e.g., a hardware protected key is\n+     * being passed to a software only cipher).\n+     *\/\n+    @Override\n+    protected byte[] engineWrap(Key key)\n+            throws IllegalBlockSizeException, InvalidKeyException {\n+\n+        byte[] keyVal = key.getEncoded();\n+        if ((keyVal == null) || (keyVal.length == 0)) {\n+            throw new InvalidKeyException(\"Cannot get an encoding of \" +\n+                                          \"the key to be wrapped\");\n+        }\n+\n+        int keyValLen = keyVal.length;\n+        int outLen = implGetOutputSize(keyValLen);\n+        byte[] out = new byte[outLen];\n+        outLen = implEncrypt(keyVal, 0, keyValLen, out, 0);\n+        if (outLen < out.length) {\n+            out = Arrays.copyOf(out, outLen);\n+        }\n+        return out;\n+\n+    }\n+\n+    \/**\n+     * Unwrap a previously wrapped key.\n+     *\n+     * @param wrappedKey the key to be unwrapped.\n+     *\n+     * @param wrappedKeyAlgorithm the algorithm the wrapped key is for.\n+     *\n+     * @param wrappedKeyType the type of the wrapped key.\n+     * This is one of <code>Cipher.SECRET_KEY<\/code>,\n+     * <code>Cipher.PRIVATE_KEY<\/code>, or <code>Cipher.PUBLIC_KEY<\/code>.\n+     *\n+     * @return the unwrapped key.\n+     *\n+     * @exception NoSuchAlgorithmException if no installed providers\n+     * can create keys of type <code>wrappedKeyType<\/code> for the\n+     * <code>wrappedKeyAlgorithm<\/code>.\n+     *\n+     * @exception InvalidKeyException if <code>wrappedKey<\/code> does not\n+     * represent a wrapped key of type <code>wrappedKeyType<\/code> for\n+     * the <code>wrappedKeyAlgorithm<\/code>.\n+     *\/\n+    @Override\n+    protected Key engineUnwrap(byte[] wrappedKey,\n+            String wrappedKeyAlgorithm, int wrappedKeyType)\n+            throws InvalidKeyException, NoSuchAlgorithmException {\n+        int wrappedKeyLen = wrappedKey.length;\n+        \/\/ ensure the wrappedKey length is multiples of SEMI_BLKSIZE and\n+        \/\/ non-zero\n+        if (wrappedKeyLen == 0) {\n+            throw new InvalidKeyException(\"The wrapped key is empty\");\n+        }\n+\n+        int outLen = implGetOutputSize(wrappedKeyLen);\n+        byte[] out = new byte[outLen];\n+        try {\n+            outLen = implDecrypt(wrappedKey, 0, wrappedKeyLen, out, 0);\n+        } catch (IllegalBlockSizeException e) {\n+            throw new InvalidKeyException(e);\n+        }\n+        if (outLen < out.length) {\n+            out = Arrays.copyOf(out, outLen);\n+        }\n+        return ConstructKeys.constructKey(out, wrappedKeyAlgorithm,\n+                wrappedKeyType);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyWrapBaseCipher.java","additions":668,"deletions":0,"binary":false,"changes":668,"status":"added"},{"patch":"@@ -119,1 +119,2 @@\n-    AESWRAP_128(\"2.16.840.1.101.3.4.1.5\"),\n+    AESWRAP_128(\"2.16.840.1.101.3.4.1.5\", \"AESWrap_128\",\n+            \"AES_128\/KW\/NoPadding\"),\n@@ -121,0 +122,2 @@\n+    AES_128$KWP$NoPadding(\"2.16.840.1.101.3.4.1.8\", \"AES_128\/KWP\/NoPadding\"),\n+\n@@ -125,1 +128,2 @@\n-    AESWRAP_192(\"2.16.840.1.101.3.4.1.25\"),\n+    AESWRAP_192(\"2.16.840.1.101.3.4.1.25\", \"AESWrap_192\",\n+            \"AES_192\/KW\/NoPadding\"),\n@@ -127,0 +131,2 @@\n+    AES_192$KWP$NoPadding(\"2.16.840.1.101.3.4.1.28\", \"AES_192\/KWP\/NoPadding\"),\n+\n@@ -131,1 +137,2 @@\n-    AESWRAP_256(\"2.16.840.1.101.3.4.1.45\"),\n+    AESWRAP_256(\"2.16.840.1.101.3.4.1.45\", \"AESWrap_256\",\n+            \"AES_256\/KW\/NoPadding\"),\n@@ -133,0 +140,1 @@\n+    AES_256$KWP$NoPadding(\"2.16.840.1.101.3.4.1.48\", \"AES_256\/KWP\/NoPadding\"),\n@@ -432,1 +440,1 @@\n-        List.of(KnownOIDs.values()).forEach(o -> {\n+        for (KnownOIDs o : KnownOIDs.values()) {\n@@ -434,1 +442,1 @@\n-        });\n+        };\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/KnownOIDs.java","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"}]}