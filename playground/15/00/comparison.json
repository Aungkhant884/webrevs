{"files":[{"patch":"@@ -66,1 +66,1 @@\n-#include \"gc\/g1\/g1YoungRemSetSamplingThread.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n@@ -1616,1 +1616,1 @@\n-  _young_gen_sampling_thread = new G1YoungRemSetSamplingThread();\n+  _young_gen_sampling_thread = new G1ServiceThread();\n@@ -1618,1 +1618,1 @@\n-    vm_shutdown_during_initialization(\"Could not create G1YoungRemSetSamplingThread\");\n+    vm_shutdown_during_initialization(\"Could not create G1ServiceThread\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-class G1YoungRemSetSamplingThread;\n+class G1ServiceThread;\n@@ -157,1 +157,1 @@\n-  G1YoungRemSetSamplingThread* _young_gen_sampling_thread;\n+  G1ServiceThread* _young_gen_sampling_thread;\n@@ -548,1 +548,1 @@\n-  G1YoungRemSetSamplingThread* sampling_thread() const { return _young_gen_sampling_thread; }\n+  G1ServiceThread* sampling_thread() const { return _young_gen_sampling_thread; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/g1YoungRemSetSamplingThread.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n+#include \"gc\/g1\/g1CollectionSet.hpp\"\n+#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n+#include \"gc\/g1\/g1ConcurrentMarkThread.inline.hpp\"\n+#include \"gc\/g1\/g1Policy.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/heapRegion.inline.hpp\"\n+#include \"gc\/g1\/heapRegionRemSet.hpp\"\n+#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+\n+G1ServiceThread::G1ServiceThread() :\n+    ConcurrentGCThread(),\n+    _monitor(Mutex::nonleaf,\n+             \"G1ServiceThread monitor\",\n+             true,\n+             Monitor::_safepoint_check_never),\n+    _last_periodic_gc_attempt_s(os::elapsedTime()),\n+    _vtime_accum(0) {\n+  set_name(\"G1 Young RemSet Sampling\");\n+  create_and_start();\n+}\n+\n+void G1ServiceThread::sleep_before_next_cycle() {\n+  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n+  if (!should_terminate()) {\n+    uintx waitms = G1ConcRefinementServiceIntervalMillis;\n+    ml.wait(waitms);\n+  }\n+}\n+\n+bool G1ServiceThread::should_start_periodic_gc() {\n+  \/\/ If we are currently in a concurrent mark we are going to uncommit memory soon.\n+  if (G1CollectedHeap::heap()->concurrent_mark()->cm_thread()->during_cycle()) {\n+    log_debug(gc, periodic)(\"Concurrent cycle in progress. Skipping.\");\n+    return false;\n+  }\n+\n+  \/\/ Check if enough time has passed since the last GC.\n+  uintx time_since_last_gc = (uintx)Universe::heap()->millis_since_last_gc();\n+  if ((time_since_last_gc < G1PeriodicGCInterval)) {\n+    log_debug(gc, periodic)(\"Last GC occurred \" UINTX_FORMAT \"ms before which is below threshold \" UINTX_FORMAT \"ms. Skipping.\",\n+                            time_since_last_gc, G1PeriodicGCInterval);\n+    return false;\n+  }\n+\n+  \/\/ Check if load is lower than max.\n+  double recent_load;\n+  if ((G1PeriodicGCSystemLoadThreshold > 0.0f) &&\n+      (os::loadavg(&recent_load, 1) == -1 || recent_load > G1PeriodicGCSystemLoadThreshold)) {\n+    log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n+                            recent_load, G1PeriodicGCSystemLoadThreshold);\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+void G1ServiceThread::check_for_periodic_gc(){\n+  \/\/ If disabled, just return.\n+  if (G1PeriodicGCInterval == 0) {\n+    return;\n+  }\n+  if ((os::elapsedTime() - _last_periodic_gc_attempt_s) > (G1PeriodicGCInterval \/ 1000.0)) {\n+    log_debug(gc, periodic)(\"Checking for periodic GC.\");\n+    if (should_start_periodic_gc()) {\n+      if (!G1CollectedHeap::heap()->try_collect(GCCause::_g1_periodic_collection)) {\n+        log_debug(gc, periodic)(\"GC request denied. Skipping.\");\n+      }\n+    }\n+    _last_periodic_gc_attempt_s = os::elapsedTime();\n+  }\n+}\n+\n+void G1ServiceThread::run_service() {\n+  double vtime_start = os::elapsedVTime();\n+\n+  while (!should_terminate()) {\n+    sample_young_list_rs_length();\n+\n+    if (os::supports_vtime()) {\n+      _vtime_accum = (os::elapsedVTime() - vtime_start);\n+    } else {\n+      _vtime_accum = 0.0;\n+    }\n+\n+    check_for_periodic_gc();\n+\n+    sleep_before_next_cycle();\n+  }\n+}\n+\n+void G1ServiceThread::stop_service() {\n+  MutexLocker x(&_monitor, Mutex::_no_safepoint_check_flag);\n+  _monitor.notify();\n+}\n+\n+class G1ServiceClosure : public HeapRegionClosure {\n+  SuspendibleThreadSetJoiner* _sts;\n+  size_t _regions_visited;\n+  size_t _sampled_rs_length;\n+public:\n+  G1ServiceClosure(SuspendibleThreadSetJoiner* sts) :\n+    HeapRegionClosure(), _sts(sts), _regions_visited(0), _sampled_rs_length(0) { }\n+\n+  virtual bool do_heap_region(HeapRegion* r) {\n+    size_t rs_length = r->rem_set()->occupied();\n+    _sampled_rs_length += rs_length;\n+\n+    \/\/ Update the collection set policy information for this region\n+    G1CollectedHeap::heap()->collection_set()->update_young_region_prediction(r, rs_length);\n+\n+    _regions_visited++;\n+\n+    if (_regions_visited == 10) {\n+      if (_sts->should_yield()) {\n+        _sts->yield();\n+        \/\/ A gc may have occurred and our sampling data is stale and further\n+        \/\/ traversal of the collection set is unsafe\n+        return true;\n+      }\n+      _regions_visited = 0;\n+    }\n+    return false;\n+  }\n+\n+  size_t sampled_rs_length() const { return _sampled_rs_length; }\n+};\n+\n+void G1ServiceThread::sample_young_list_rs_length() {\n+  SuspendibleThreadSetJoiner sts;\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  G1Policy* policy = g1h->policy();\n+\n+  if (policy->use_adaptive_young_list_length()) {\n+    G1ServiceClosure cl(&sts);\n+\n+    G1CollectionSet* g1cs = g1h->collection_set();\n+    g1cs->iterate(&cl);\n+\n+    if (cl.is_complete()) {\n+      policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1SERVICETHREAD_HPP\n+#define SHARE_GC_G1_G1SERVICETHREAD_HPP\n+\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+\n+\/\/ The G1ServiceThread is used to do a number of different task:\n+\/\/   - re-assess the validity of the prediction for the\n+\/\/     remembered set lengths of the young generation.\n+\/\/   - check if a periodic GC should be scheduled.\n+class G1ServiceThread: public ConcurrentGCThread {\n+private:\n+  Monitor _monitor;\n+\n+  double _last_periodic_gc_attempt_s;\n+\n+  double _vtime_accum;  \/\/ Accumulated virtual time.\n+\n+  \/\/ Sample the current length of remembered sets for young.\n+  \/\/\n+  \/\/ At the end of the GC G1 determines the length of the young gen based on\n+  \/\/ how much time the next GC can take, and when the next GC may occur\n+  \/\/ according to the MMU.\n+  \/\/\n+  \/\/ The assumption is that a significant part of the GC is spent on scanning\n+  \/\/ the remembered sets (and many other components), so this thread constantly\n+  \/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n+  \/\/ G1Policy resizes the young gen. This may do a premature GC or even\n+  \/\/ increase the young gen size to keep pause time length goal.\n+  void sample_young_list_rs_length();\n+\n+  void run_service();\n+  void check_for_periodic_gc();\n+\n+  void stop_service();\n+\n+  void sleep_before_next_cycle();\n+\n+  bool should_start_periodic_gc();\n+\n+public:\n+  G1ServiceThread();\n+  double vtime_accum() { return _vtime_accum; }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1SERVICETHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n-#include \"gc\/g1\/g1CollectionSet.hpp\"\n-#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n-#include \"gc\/g1\/g1ConcurrentMarkThread.inline.hpp\"\n-#include \"gc\/g1\/g1Policy.hpp\"\n-#include \"gc\/g1\/g1YoungRemSetSamplingThread.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.hpp\"\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n-#include \"memory\/universe.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-\n-G1YoungRemSetSamplingThread::G1YoungRemSetSamplingThread() :\n-    ConcurrentGCThread(),\n-    _monitor(Mutex::nonleaf,\n-             \"G1YoungRemSetSamplingThread monitor\",\n-             true,\n-             Monitor::_safepoint_check_never),\n-    _last_periodic_gc_attempt_s(os::elapsedTime()),\n-    _vtime_accum(0) {\n-  set_name(\"G1 Young RemSet Sampling\");\n-  create_and_start();\n-}\n-\n-void G1YoungRemSetSamplingThread::sleep_before_next_cycle() {\n-  MonitorLocker ml(&_monitor, Mutex::_no_safepoint_check_flag);\n-  if (!should_terminate()) {\n-    uintx waitms = G1ConcRefinementServiceIntervalMillis;\n-    ml.wait(waitms);\n-  }\n-}\n-\n-bool G1YoungRemSetSamplingThread::should_start_periodic_gc() {\n-  \/\/ If we are currently in a concurrent mark we are going to uncommit memory soon.\n-  if (G1CollectedHeap::heap()->concurrent_mark()->cm_thread()->during_cycle()) {\n-    log_debug(gc, periodic)(\"Concurrent cycle in progress. Skipping.\");\n-    return false;\n-  }\n-\n-  \/\/ Check if enough time has passed since the last GC.\n-  uintx time_since_last_gc = (uintx)Universe::heap()->millis_since_last_gc();\n-  if ((time_since_last_gc < G1PeriodicGCInterval)) {\n-    log_debug(gc, periodic)(\"Last GC occurred \" UINTX_FORMAT \"ms before which is below threshold \" UINTX_FORMAT \"ms. Skipping.\",\n-                            time_since_last_gc, G1PeriodicGCInterval);\n-    return false;\n-  }\n-\n-  \/\/ Check if load is lower than max.\n-  double recent_load;\n-  if ((G1PeriodicGCSystemLoadThreshold > 0.0f) &&\n-      (os::loadavg(&recent_load, 1) == -1 || recent_load > G1PeriodicGCSystemLoadThreshold)) {\n-    log_debug(gc, periodic)(\"Load %1.2f is higher than threshold %1.2f. Skipping.\",\n-                            recent_load, G1PeriodicGCSystemLoadThreshold);\n-    return false;\n-  }\n-\n-  return true;\n-}\n-\n-void G1YoungRemSetSamplingThread::check_for_periodic_gc(){\n-  \/\/ If disabled, just return.\n-  if (G1PeriodicGCInterval == 0) {\n-    return;\n-  }\n-  if ((os::elapsedTime() - _last_periodic_gc_attempt_s) > (G1PeriodicGCInterval \/ 1000.0)) {\n-    log_debug(gc, periodic)(\"Checking for periodic GC.\");\n-    if (should_start_periodic_gc()) {\n-      if (!G1CollectedHeap::heap()->try_collect(GCCause::_g1_periodic_collection)) {\n-        log_debug(gc, periodic)(\"GC request denied. Skipping.\");\n-      }\n-    }\n-    _last_periodic_gc_attempt_s = os::elapsedTime();\n-  }\n-}\n-\n-void G1YoungRemSetSamplingThread::run_service() {\n-  double vtime_start = os::elapsedVTime();\n-\n-  while (!should_terminate()) {\n-    sample_young_list_rs_length();\n-\n-    if (os::supports_vtime()) {\n-      _vtime_accum = (os::elapsedVTime() - vtime_start);\n-    } else {\n-      _vtime_accum = 0.0;\n-    }\n-\n-    check_for_periodic_gc();\n-\n-    sleep_before_next_cycle();\n-  }\n-}\n-\n-void G1YoungRemSetSamplingThread::stop_service() {\n-  MutexLocker x(&_monitor, Mutex::_no_safepoint_check_flag);\n-  _monitor.notify();\n-}\n-\n-class G1YoungRemSetSamplingClosure : public HeapRegionClosure {\n-  SuspendibleThreadSetJoiner* _sts;\n-  size_t _regions_visited;\n-  size_t _sampled_rs_length;\n-public:\n-  G1YoungRemSetSamplingClosure(SuspendibleThreadSetJoiner* sts) :\n-    HeapRegionClosure(), _sts(sts), _regions_visited(0), _sampled_rs_length(0) { }\n-\n-  virtual bool do_heap_region(HeapRegion* r) {\n-    size_t rs_length = r->rem_set()->occupied();\n-    _sampled_rs_length += rs_length;\n-\n-    \/\/ Update the collection set policy information for this region\n-    G1CollectedHeap::heap()->collection_set()->update_young_region_prediction(r, rs_length);\n-\n-    _regions_visited++;\n-\n-    if (_regions_visited == 10) {\n-      if (_sts->should_yield()) {\n-        _sts->yield();\n-        \/\/ A gc may have occurred and our sampling data is stale and further\n-        \/\/ traversal of the collection set is unsafe\n-        return true;\n-      }\n-      _regions_visited = 0;\n-    }\n-    return false;\n-  }\n-\n-  size_t sampled_rs_length() const { return _sampled_rs_length; }\n-};\n-\n-void G1YoungRemSetSamplingThread::sample_young_list_rs_length() {\n-  SuspendibleThreadSetJoiner sts;\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  G1Policy* policy = g1h->policy();\n-\n-  if (policy->use_adaptive_young_list_length()) {\n-    G1YoungRemSetSamplingClosure cl(&sts);\n-\n-    G1CollectionSet* g1cs = g1h->collection_set();\n-    g1cs->iterate(&cl);\n-\n-    if (cl.is_complete()) {\n-      policy->revise_young_list_target_length_if_necessary(cl.sampled_rs_length());\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungRemSetSamplingThread.cpp","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1YOUNGREMSETSAMPLINGTHREAD_HPP\n-#define SHARE_GC_G1_G1YOUNGREMSETSAMPLINGTHREAD_HPP\n-\n-#include \"gc\/shared\/concurrentGCThread.hpp\"\n-\n-\/\/ The G1YoungRemSetSamplingThread is used to re-assess the validity of\n-\/\/ the prediction for the remembered set lengths of the young generation.\n-\/\/\n-\/\/ At the end of the GC G1 determines the length of the young gen based on\n-\/\/ how much time the next GC can take, and when the next GC may occur\n-\/\/ according to the MMU.\n-\/\/\n-\/\/ The assumption is that a significant part of the GC is spent on scanning\n-\/\/ the remembered sets (and many other components), so this thread constantly\n-\/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n-\/\/ G1Policy resizes the young gen. This may do a premature GC or even\n-\/\/ increase the young gen size to keep pause time length goal.\n-class G1YoungRemSetSamplingThread: public ConcurrentGCThread {\n-private:\n-  Monitor _monitor;\n-\n-  double _last_periodic_gc_attempt_s;\n-\n-  double _vtime_accum;  \/\/ Accumulated virtual time.\n-\n-  void sample_young_list_rs_length();\n-\n-  void run_service();\n-  void check_for_periodic_gc();\n-\n-  void stop_service();\n-\n-  void sleep_before_next_cycle();\n-\n-  bool should_start_periodic_gc();\n-\n-public:\n-  G1YoungRemSetSamplingThread();\n-  double vtime_accum() { return _vtime_accum; }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1YOUNGREMSETSAMPLINGTHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungRemSetSamplingThread.hpp","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"}]}