{"files":[{"patch":"@@ -66,1 +66,1 @@\n-#include \"gc\/g1\/g1YoungRemSetSamplingThread.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n@@ -1479,1 +1479,1 @@\n-  _young_gen_sampling_thread(NULL),\n+  _service_thread(NULL),\n@@ -1615,4 +1615,4 @@\n-jint G1CollectedHeap::initialize_young_gen_sampling_thread() {\n-  _young_gen_sampling_thread = new G1YoungRemSetSamplingThread();\n-  if (_young_gen_sampling_thread->osthread() == NULL) {\n-    vm_shutdown_during_initialization(\"Could not create G1YoungRemSetSamplingThread\");\n+jint G1CollectedHeap::initialize_service_thread() {\n+  _service_thread = new G1ServiceThread();\n+  if (_service_thread->osthread() == NULL) {\n+    vm_shutdown_during_initialization(\"Could not create G1ServiceThread\");\n@@ -1793,1 +1793,1 @@\n-  ecode = initialize_young_gen_sampling_thread();\n+  ecode = initialize_service_thread();\n@@ -1839,1 +1839,1 @@\n-  _young_gen_sampling_thread->stop();\n+  _service_thread->stop();\n@@ -2578,1 +2578,1 @@\n-  tc->do_thread(_young_gen_sampling_thread);\n+  tc->do_thread(_service_thread);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-class G1YoungRemSetSamplingThread;\n+class G1ServiceThread;\n@@ -157,1 +157,1 @@\n-  G1YoungRemSetSamplingThread* _young_gen_sampling_thread;\n+  G1ServiceThread* _service_thread;\n@@ -548,1 +548,1 @@\n-  G1YoungRemSetSamplingThread* sampling_thread() const { return _young_gen_sampling_thread; }\n+  G1ServiceThread* service_thread() const { return _service_thread; }\n@@ -966,1 +966,1 @@\n-  jint initialize_young_gen_sampling_thread();\n+  jint initialize_service_thread();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/g1YoungRemSetSamplingThread.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n@@ -56,1 +56,1 @@\n-  set_sampling_thread_vtime(g1h->sampling_thread()->vtime_accum());\n+  set_service_thread_vtime(g1h->service_thread()->vtime_accum());\n@@ -75,1 +75,1 @@\n-  _sampling_thread_vtime(0.0f) {\n+  _service_thread_vtime(0.0f) {\n@@ -96,1 +96,1 @@\n-  set_sampling_thread_vtime(other->sampling_thread_vtime());\n+  set_service_thread_vtime(other->service_thread_vtime());\n@@ -109,1 +109,1 @@\n-  _sampling_thread_vtime = other->sampling_thread_vtime() - _sampling_thread_vtime;\n+  _service_thread_vtime = other->service_thread_vtime() - _service_thread_vtime;\n@@ -331,1 +331,1 @@\n-  out->print_cr(\"         %5.2f\", sampling_thread_vtime());\n+  out->print_cr(\"         %5.2f\", service_thread_vtime());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  double _sampling_thread_vtime;\n+  double _service_thread_vtime;\n@@ -44,2 +44,2 @@\n-  void set_sampling_thread_vtime(double value) {\n-    _sampling_thread_vtime = value;\n+  void set_service_thread_vtime(double value) {\n+    _service_thread_vtime = value;\n@@ -65,2 +65,2 @@\n-  double sampling_thread_vtime() const {\n-    return _sampling_thread_vtime;\n+  double service_thread_vtime() const {\n+    return _service_thread_vtime;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"gc\/g1\/g1YoungRemSetSamplingThread.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n@@ -38,1 +38,1 @@\n-G1YoungRemSetSamplingThread::G1YoungRemSetSamplingThread() :\n+G1ServiceThread::G1ServiceThread() :\n@@ -41,1 +41,1 @@\n-             \"G1YoungRemSetSamplingThread monitor\",\n+             \"G1ServiceThread monitor\",\n@@ -50,1 +50,1 @@\n-void G1YoungRemSetSamplingThread::sleep_before_next_cycle() {\n+void G1ServiceThread::sleep_before_next_cycle() {\n@@ -58,1 +58,1 @@\n-bool G1YoungRemSetSamplingThread::should_start_periodic_gc() {\n+bool G1ServiceThread::should_start_periodic_gc() {\n@@ -85,1 +85,1 @@\n-void G1YoungRemSetSamplingThread::check_for_periodic_gc(){\n+void G1ServiceThread::check_for_periodic_gc(){\n@@ -101,1 +101,1 @@\n-void G1YoungRemSetSamplingThread::run_service() {\n+void G1ServiceThread::run_service() {\n@@ -119,1 +119,1 @@\n-void G1YoungRemSetSamplingThread::stop_service() {\n+void G1ServiceThread::stop_service() {\n@@ -156,1 +156,1 @@\n-void G1YoungRemSetSamplingThread::sample_young_list_rs_length() {\n+void G1ServiceThread::sample_young_list_rs_length() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"previous_filename":"src\/hotspot\/share\/gc\/g1\/g1YoungRemSetSamplingThread.cpp","status":"renamed"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1SERVICETHREAD_HPP\n+#define SHARE_GC_G1_G1SERVICETHREAD_HPP\n+\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+\n+\/\/ The G1ServiceThread is used to do a number of different task:\n+\/\/   - re-assess the validity of the prediction for the\n+\/\/     remembered set lengths of the young generation.\n+\/\/   - check if a periodic GC should be scheduled.\n+class G1ServiceThread: public ConcurrentGCThread {\n+private:\n+  Monitor _monitor;\n+\n+  double _last_periodic_gc_attempt_s;\n+\n+  double _vtime_accum;  \/\/ Accumulated virtual time.\n+\n+  \/\/ Sample the current length of remembered sets for young.\n+  \/\/\n+  \/\/ At the end of the GC G1 determines the length of the young gen based on\n+  \/\/ how much time the next GC can take, and when the next GC may occur\n+  \/\/ according to the MMU.\n+  \/\/\n+  \/\/ The assumption is that a significant part of the GC is spent on scanning\n+  \/\/ the remembered sets (and many other components), so this thread constantly\n+  \/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n+  \/\/ G1Policy resizes the young gen. This may do a premature GC or even\n+  \/\/ increase the young gen size to keep pause time length goal.\n+  void sample_young_list_rs_length();\n+\n+  void run_service();\n+  void check_for_periodic_gc();\n+\n+  void stop_service();\n+\n+  void sleep_before_next_cycle();\n+\n+  bool should_start_periodic_gc();\n+\n+public:\n+  G1ServiceThread();\n+  double vtime_accum() { return _vtime_accum; }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1SERVICETHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1YOUNGREMSETSAMPLINGTHREAD_HPP\n-#define SHARE_GC_G1_G1YOUNGREMSETSAMPLINGTHREAD_HPP\n-\n-#include \"gc\/shared\/concurrentGCThread.hpp\"\n-\n-\/\/ The G1YoungRemSetSamplingThread is used to re-assess the validity of\n-\/\/ the prediction for the remembered set lengths of the young generation.\n-\/\/\n-\/\/ At the end of the GC G1 determines the length of the young gen based on\n-\/\/ how much time the next GC can take, and when the next GC may occur\n-\/\/ according to the MMU.\n-\/\/\n-\/\/ The assumption is that a significant part of the GC is spent on scanning\n-\/\/ the remembered sets (and many other components), so this thread constantly\n-\/\/ reevaluates the prediction for the remembered set scanning costs, and potentially\n-\/\/ G1Policy resizes the young gen. This may do a premature GC or even\n-\/\/ increase the young gen size to keep pause time length goal.\n-class G1YoungRemSetSamplingThread: public ConcurrentGCThread {\n-private:\n-  Monitor _monitor;\n-\n-  double _last_periodic_gc_attempt_s;\n-\n-  double _vtime_accum;  \/\/ Accumulated virtual time.\n-\n-  void sample_young_list_rs_length();\n-\n-  void run_service();\n-  void check_for_periodic_gc();\n-\n-  void stop_service();\n-\n-  void sleep_before_next_cycle();\n-\n-  bool should_start_periodic_gc();\n-\n-public:\n-  G1YoungRemSetSamplingThread();\n-  double vtime_accum() { return _vtime_accum; }\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1YOUNGREMSETSAMPLINGTHREAD_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungRemSetSamplingThread.hpp","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"}]}