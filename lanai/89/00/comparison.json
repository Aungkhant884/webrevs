{"files":[{"patch":"@@ -105,5 +105,0 @@\n-        MTLTextureDescriptor *lcdTextureDescriptor = \n-            [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:MTLPixelFormatBGRA8Unorm width:width height:height mipmapped:NO];\n-\n-        bmtlsdo->textureLCD = [ctx.device newTextureWithDescriptor:lcdTextureDescriptor];\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceData.m","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -180,1 +180,0 @@\n-    void*                        textureLCD;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceDataBase.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -84,12 +84,0 @@\n-\/**\n- * The handle to the LCD text fragment program object.\n- *\/\n-static GLhandleARB lcdTextProgram = 0;\n-\n-\/**\n- * This value tracks the previous LCD contrast setting, so if the contrast\n- * value hasn't changed since the last time the gamma uniforms were\n- * updated (not very common), then we can skip updating the unforms.\n- *\/\n-static jint lastLCDContrast = -1;\n-\n@@ -113,55 +101,0 @@\n-\/**\n- * These constants define the size of the \"cached destination\" texture.\n- * This texture is only used when rendering LCD-optimized text, as that\n- * codepath needs direct access to the destination.  There is no way to\n- * access the framebuffer directly from an OpenGL shader, so we need to first\n- * copy the destination region corresponding to a particular glyph into\n- * this cached texture, and then that texture will be accessed inside the\n- * shader.  Copying the destination into this cached texture can be a very\n- * expensive operation (accounting for about half the rendering time for\n- * LCD text), so to mitigate this cost we try to bulk read a horizontal\n- * region of the destination at a time.  (These values are empirically\n- * derived for the common case where text runs horizontally.)\n- *\n- * Note: It is assumed in various calculations below that:\n- *     (MTLTR_CACHED_DEST_WIDTH  >= MTLTR_CACHE_CELL_WIDTH)  &&\n- *     (MTLTR_CACHED_DEST_WIDTH  >= MTLTR_NOCACHE_TILE_SIZE) &&\n- *     (MTLTR_CACHED_DEST_HEIGHT >= MTLTR_CACHE_CELL_HEIGHT) &&\n- *     (MTLTR_CACHED_DEST_HEIGHT >= MTLTR_NOCACHE_TILE_SIZE)\n- *\/\n-#define MTLTR_CACHED_DEST_WIDTH  512\n-#define MTLTR_CACHED_DEST_HEIGHT (MTLTR_CACHE_CELL_HEIGHT * 2)\n-\n-\/**\n- * The handle to the \"cached destination\" texture object.\n- *\/\n-static GLuint cachedDestTextureID = 0;\n-\n-\/**\n- * The current bounds of the \"cached destination\" texture, in destination\n- * coordinate space.  The width\/height of these bounds will not exceed the\n- * MTLTR_CACHED_DEST_WIDTH\/HEIGHT values defined above.  These bounds are\n- * only considered valid when the isCachedDestValid flag is JNI_TRUE.\n- *\/\n-static SurfaceDataBounds cachedDestBounds;\n-\n-\/**\n- * This flag indicates whether the \"cached destination\" texture contains\n- * valid data.  This flag is reset to JNI_FALSE at the beginning of every\n- * call to MTLTR_DrawGlyphList().  Once we copy valid destination data\n- * into the cached texture, this flag is set to JNI_TRUE.  This way, we can\n- * limit the number of times we need to copy destination data, which is a\n- * very costly operation.\n- *\/\n-static jboolean isCachedDestValid = JNI_FALSE;\n-\n-\/**\n- * The bounds of the previously rendered LCD glyph, in destination\n- * coordinate space.  We use these bounds to determine whether the glyph\n- * currently being rendered overlaps the previously rendered glyph (i.e.\n- * its bounding box intersects that of the previously rendered glyph).  If\n- * so, we need to re-read the destination area associated with that previous\n- * glyph so that we can correctly blend with the actual destination data.\n- *\/\n-static SurfaceDataBounds previousGlyphBounds;\n-\n@@ -505,27 +438,0 @@\n-\/**\n- * Disables any pending state associated with the current \"glyph mode\".\n- *\/\n-void\n-MTLTR_DisableGlyphModeState()\n-{\n-    \/\/ TODO : This is similar to OpenGL implementation\n-    \/\/ When LCD implementation is done weshould make\n-    \/\/ more changes.\n-    J2dTraceLn1(J2D_TRACE_VERBOSE,\n-                \"MTLTR_DisableGlyphModeState: mode=%d\", glyphMode);\n-    switch (glyphMode) {\n-    case MODE_NO_CACHE_LCD:\n-        \/\/ TODO : Along with LCD implementation\n-        \/\/ changes needs to be made\n-    case MODE_USE_CACHE_LCD:\n-        \/\/ TODO : Along with LCD implementation\n-        \/\/ changes needs to be made\n-        break;\n-    case MODE_NO_CACHE_GRAY:\n-    case MODE_USE_CACHE_GRAY:\n-    case MODE_NOT_INITED:\n-    default:\n-        break;\n-    }\n-}\n-\n@@ -576,31 +482,0 @@\n-\/**\n- * Evaluates to true if the rectangle defined by gx1\/gy1\/gx2\/gy2 is\n- * inside outerBounds.\n- *\/\n-#define INSIDE(gx1, gy1, gx2, gy2, outerBounds) \\\n-    (((gx1) >= outerBounds.x1) && ((gy1) >= outerBounds.y1) && \\\n-     ((gx2) <= outerBounds.x2) && ((gy2) <= outerBounds.y2))\n-\n-\/**\n- * Evaluates to true if the rectangle defined by gx1\/gy1\/gx2\/gy2 intersects\n- * the rectangle defined by bounds.\n- *\/\n-#define INTERSECTS(gx1, gy1, gx2, gy2, bounds) \\\n-    ((bounds.x2 > (gx1)) && (bounds.y2 > (gy1)) && \\\n-     (bounds.x1 < (gx2)) && (bounds.y1 < (gy2)))\n-\n-\/**\n- * This method checks to see if the given LCD glyph bounds fall within the\n- * cached destination texture bounds.  If so, this method can return\n- * immediately.  If not, this method will copy a chunk of framebuffer data\n- * into the cached destination texture and then update the current cached\n- * destination bounds before returning.\n- *\/\n-static void\n-MTLTR_UpdateCachedDestination(MTLSDOps *dstOps, GlyphInfo *ginfo,\n-                              jint gx1, jint gy1, jint gx2, jint gy2,\n-                              jint glyphIndex, jint totalGlyphs)\n-{\n-    \/\/TODO\n-}\n-\n@@ -610,2 +485,1 @@\n-                           jboolean rgbOrder, jint contrast,\n-                           id<MTLTexture> dstTexture)\n+                           jboolean rgbOrder, jint contrast)\n@@ -728,2 +602,1 @@\n-                          jboolean rgbOrder, jint contrast,\n-                          id<MTLTexture> dstTexture)\n+                          jboolean rgbOrder, jint contrast)\n@@ -732,1 +605,0 @@\n-    jfloat dtx1=0, dty1=0, dtx2=0, dty2=0;\n@@ -734,2 +606,0 @@\n-    jint sx=0, sy=0, sw=0, sh=0, dxadj=0, dyadj=0;\n-    jint x0;\n@@ -778,8 +648,0 @@\n-    x0 = x;\n-    tx1 = 0.0f;\n-    ty1 = 0.0f;\n-    dtx1 = 0.0f;\n-    dty2 = 0.0f;\n-    tw = MTLTR_NOCACHE_TILE_SIZE;\n-    th = MTLTR_NOCACHE_TILE_SIZE;\n-\n@@ -808,4 +670,2 @@\n-    J2dTraceLn7(J2D_TRACE_INFO, \"sx = %d sy = %d x = %d y = %d sw = %d sh = %d w = %d\", sx, sy, x, y, sw, sh, w);\n-\n-\n-    \/\/ update the lower-right glyph texture coordinates\n+    tx1 = 0.0f;\n+    ty1 = 0.0f;\n@@ -815,8 +675,1 @@\n-    J2dTraceLn5(J2D_TRACE_INFO, \"xOffset %d yOffset %d, dxadj %d, dyadj %d dstOps->height %d\", dstOps->xOffset, dstOps->yOffset, dxadj, dyadj, dstOps->height);\n-\n-    dtx1 = ((jfloat)dxadj) \/ dstOps->textureWidth;\n-    dtx2 = ((float)dxadj + sw) \/ dstOps->textureWidth;\n-  \n-    dty1 = ((jfloat)dyadj + sh) \/ dstOps->textureHeight;\n-    dty2 = ((jfloat)dyadj) \/ dstOps->textureHeight;\n-\n+    J2dTraceLn3(J2D_TRACE_INFO, \"xOffset %d yOffset %d, dstOps->height %d\", dstOps->xOffset, dstOps->yOffset, dstOps->height);\n@@ -825,1 +678,0 @@\n-    J2dTraceLn4(J2D_TRACE_INFO, \"dtx1 %f, dty1 %f, dtx2 %f, dty2 %f\", dtx1, dty1, dtx2, dty2);\n@@ -875,1 +727,0 @@\n-    isCachedDestValid = JNI_FALSE;\n@@ -942,1 +793,0 @@\n-            void* dstTexture = dstOps->textureLCD;\n@@ -962,2 +812,1 @@\n-                                                rgbOrder, lcdContrast,\n-                                                dstTexture);\n+                                                rgbOrder, lcdContrast);\n@@ -969,2 +818,1 @@\n-                                               rgbOrder, lcdContrast,\n-                                               dstTexture);\n+                                               rgbOrder, lcdContrast);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":7,"deletions":159,"binary":false,"changes":166,"status":"modified"}]}