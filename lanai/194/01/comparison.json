{"files":[{"patch":"@@ -71,0 +71,4 @@\n+- (id<MTLRenderCommandEncoder> _Nonnull) getLCDEncoder:(id<MTLTexture> _Nonnull)dest\n+                                               isSrcOpaque:(bool)isSrcOpaque\n+                                               isDstOpaque:(bool)isDstOpaque;\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,2 @@\n-                  isText:(jboolean)isText;\n+                  isText:(jboolean)isText\n+                  isLCD:(jboolean)isLCD;\n@@ -55,0 +56,1 @@\n+@property (assign) jboolean lcd;\n@@ -68,0 +70,1 @@\n+    jboolean _isLCD;\n@@ -92,0 +95,1 @@\n+@synthesize lcd = _isLCD;\n@@ -122,1 +126,2 @@\n-                  isText:(jboolean)isText {\n+                  isText:(jboolean)isText\n+                  isLCD:(jboolean)isLCD {\n@@ -128,0 +133,1 @@\n+    _isLCD = isLCD;\n@@ -176,0 +182,1 @@\n+        && _isLCD == renderOptions->isLCD\n@@ -185,0 +192,1 @@\n+    _isLCD = renderOptions->isLCD;\n@@ -278,1 +286,1 @@\n-  RenderOptions roptions = {JNI_FALSE, JNI_TRUE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps->isOpaque, JNI_TRUE}, JNI_FALSE};\n+  RenderOptions roptions = {JNI_FALSE, JNI_TRUE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {dstOps->isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n@@ -285,1 +293,1 @@\n-    RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {isOpaque, JNI_TRUE}, JNI_FALSE};\n+    RenderOptions roptions = {JNI_FALSE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, defaultRasterFlags, {isOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n@@ -309,0 +317,8 @@\n+- (id<MTLRenderCommandEncoder> _Nonnull) getLCDEncoder:(id<MTLTexture> _Nonnull)dest\n+                                               isSrcOpaque:(bool)isSrcOpaque\n+                                               isDstOpaque:(bool)isDstOpaque\n+{\n+    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, {isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_TRUE};\n+    return [self getEncoder:dest renderOptions:&roptions];\n+}\n+\n@@ -315,1 +331,1 @@\n-    RenderOptions roptions = {JNI_TRUE, isAA, interpolation, { isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE};\n+    RenderOptions roptions = {JNI_TRUE, isAA, interpolation, { isSrcOpaque, JNI_TRUE }, {isDstOpaque, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n@@ -330,1 +346,1 @@\n-    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, { isSrcOpaque, JNI_TRUE }, {dstOps->isOpaque, JNI_TRUE}, JNI_TRUE};\n+    RenderOptions roptions = {JNI_TRUE, JNI_FALSE, INTERPOLATION_NEAREST_NEIGHBOR, { isSrcOpaque, JNI_TRUE }, {dstOps->isOpaque, JNI_TRUE}, JNI_TRUE, JNI_FALSE};\n@@ -410,1 +426,2 @@\n-                      isText:renderOptions->isText];\n+                      isText:renderOptions->isText\n+                      isLCD:renderOptions->isLCD];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.m","additions":24,"deletions":7,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;\n@@ -96,0 +97,11 @@\n+    templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];\n+    templateLCDPipelineDesc.sampleCount = 1;\n+    templateLCDPipelineDesc.vertexDescriptor = vertDesc;\n+    templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n+    templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n+    templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n+    templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n+    templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);\n+    templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;\n+    templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n+    templateLCDPipelineDesc.label = @\"template_lcd\";\n@@ -163,0 +175,5 @@\n+        if (renderOptions->isLCD) {\n+            vertShader = @\"vert_txt_lcd\";\n+            fragShader = @\"lcd_color\";\n+            rpDesc = [[templateLCDPipelineDesc copy] autorelease];\n+        }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.m","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE};\n+    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n@@ -101,1 +101,1 @@\n-    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE};\n+    RenderOptions defaultOptions = {JNI_FALSE, JNI_FALSE, 0\/*unused*\/, {JNI_FALSE, JNI_TRUE}, {JNI_FALSE, JNI_TRUE}, JNI_FALSE, JNI_FALSE};\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPipelineStatesStorage.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -250,114 +250,0 @@\n-static MTLRenderPipelineDescriptor * templateLCDPipelineDesc = nil;\n-\n-\/**\n- * Enables the LCD text shader and updates any related state, such as the\n- * gamma lookup table textures.\n- *\/\n-static jboolean\n-MTLTR_EnableLCDGlyphModeState(id<MTLRenderCommandEncoder> encoder,\n-                              MTLContext *mtlc,\n-                              MTLSDOps *dstOps,\n-                              jint contrast)\n-{\n-    if (![mtlc.paint isKindOfClass:[MTLColorPaint class]]) {\n-        return JNI_FALSE;\n-    }\n-    MTLColorPaint* cPaint = (MTLColorPaint *) mtlc.paint;\n-    \/\/ create the LCD text shader, if necessary\n-    if (templateLCDPipelineDesc == nil) {\n-\n-        MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];\n-        vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n-        vertDesc.attributes[VertexAttributePosition].offset = 0;\n-        vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n-        vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);\n-        vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n-        vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n-\n-        templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];\n-        templateLCDPipelineDesc.sampleCount = 1;\n-        templateLCDPipelineDesc.vertexDescriptor = vertDesc;\n-        templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n-        templateLCDPipelineDesc.label = @\"template_lcd\";\n-    }\n-\n-    id<MTLRenderPipelineState> pipelineState =\n-                [mtlc.pipelineStateStorage\n-                    getPipelineState:templateLCDPipelineDesc\n-                    vertexShaderId:@\"vert_txt_lcd\"\n-                    fragmentShaderId:@\"lcd_color\"\n-                   ];\n-\n-    [encoder setRenderPipelineState:pipelineState];\n-\n-    \/\/ update the current color settings\n-    double gamma = ((double)contrast) \/ 100.0;\n-    double invgamma = 1.0\/gamma;\n-    jfloat radj, gadj, badj;\n-    jfloat clr[4];\n-    jint col = cPaint.color;\n-\n-    J2dTraceLn2(J2D_TRACE_INFO, \"primary color %x, contrast %d\", col, contrast);\n-    J2dTraceLn2(J2D_TRACE_INFO, \"gamma %f, invgamma %f\", gamma, invgamma);\n-\n-    clr[0] = ((col >> 16) & 0xFF)\/255.0f;\n-    clr[1] = ((col >> 8) & 0xFF)\/255.0f;\n-    clr[2] = ((col) & 0xFF)\/255.0f;\n-\n-    \/\/ gamma adjust the primary color\n-    radj = (float)pow(clr[0], gamma);\n-    gadj = (float)pow(clr[1], gamma);\n-    badj = (float)pow(clr[2], gamma);\n-\n-    struct LCDFrameUniforms uf = {\n-            {radj, gadj, badj},\n-            {gamma, gamma, gamma},\n-            {invgamma, invgamma, invgamma}};\n-    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n-\n-    return JNI_TRUE;\n-}\n-\n-static jboolean\n-MTLTR_SetLCDCachePipelineState(MTLContext *mtlc)\n-{\n-    if (templateLCDPipelineDesc == nil) {\n-\n-        MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];\n-        vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n-        vertDesc.attributes[VertexAttributePosition].offset = 0;\n-        vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n-        vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct Vertex);\n-        vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n-        vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n-\n-        templateLCDPipelineDesc = [MTLRenderPipelineDescriptor new];\n-        templateLCDPipelineDesc.sampleCount = 1;\n-        templateLCDPipelineDesc.vertexDescriptor = vertDesc;\n-        templateLCDPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n-        templateLCDPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stride = sizeof(struct TxtVertex);\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepRate = 1;\n-        templateLCDPipelineDesc.vertexDescriptor.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n-        templateLCDPipelineDesc.label = @\"template_lcd\";\n-    }\n-\n-    id<MTLRenderPipelineState> pipelineState =\n-                [mtlc.pipelineStateStorage\n-                    getPipelineState:templateLCDPipelineDesc\n-                    vertexShaderId:@\"vert_txt_lcd\"\n-                    fragmentShaderId:@\"lcd_color\"\n-                   ];\n-\n-    [lcdCacheEncoder setRenderPipelineState:pipelineState];\n-    return JNI_TRUE;\n-}\n-\n@@ -366,1 +252,2 @@\n-                     jint contrast)\n+                     jint contrast,\n+                     id<MTLRenderCommandEncoder> encoder)\n@@ -395,1 +282,1 @@\n-    [lcdCacheEncoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n@@ -507,2 +394,1 @@\n-            lcdCacheEncoder = [mtlc.encoderManager getTextureEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n-            MTLTR_SetLCDCachePipelineState(mtlc);\n+            lcdCacheEncoder = [mtlc.encoderManager getLCDEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n@@ -533,1 +419,1 @@\n-    MTLTR_SetLCDContrast(mtlc, contrast);\n+    MTLTR_SetLCDContrast(mtlc, contrast, lcdCacheEncoder);\n@@ -644,5 +530,2 @@\n-    encoder = [mtlc.encoderManager getTextureEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n-    if (!MTLTR_EnableLCDGlyphModeState(encoder, mtlc, dstOps,contrast))\n-    {\n-        return JNI_FALSE;\n-    }\n+    encoder = [mtlc.encoderManager getLCDEncoder:dstOps->pTexture isSrcOpaque:YES isDstOpaque:YES];\n+    MTLTR_SetLCDContrast(mtlc, contrast, encoder);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":7,"deletions":124,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    jboolean isLCD;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/RenderOptions.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}