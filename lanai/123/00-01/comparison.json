{"files":[{"patch":"@@ -254,0 +254,2 @@\n+            \"--disable-jvm-feature-aot\",\n+            \"--disable-jvm-feature-graal\",\n@@ -407,1 +409,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\", \"graalunit_lib\"],\n+            dependencies: [\"devkit\", \"gtest\", \"graphviz\", \"pandoc\"],\n@@ -426,1 +428,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"pandoc\", \"graalunit_lib\"],\n+            dependencies: [\"devkit\", \"gtest\", \"pandoc\"],\n@@ -437,1 +439,1 @@\n-            dependencies: [\"devkit\", \"gtest\", \"pandoc\", \"graalunit_lib\"],\n+            dependencies: [\"devkit\", \"gtest\", \"pandoc\"],\n@@ -457,2 +459,0 @@\n-\t\t\"--disable-jvm-feature-graal\",\n-\t\t\"--disable-jvm-feature-aot\",\n@@ -690,1 +690,1 @@\n-            configure_args: [\n+            configure_args: concat(\n@@ -692,0 +692,1 @@\n+                versionArgs(input, common),\n@@ -694,1 +695,1 @@\n-            ],\n+            ),\n@@ -1154,9 +1155,0 @@\n-        graalunit_lib: {\n-            organization: common.organization,\n-            ext: \"zip\",\n-            revision: \"619_Apr_12_2018\",\n-            module: \"graalunit-lib\",\n-            configure_args: \"--with-graalunit-lib=\" + input.get(\"graalunit_lib\", \"install_path\"),\n-            environment_name: \"GRAALUNIT_LIB\"\n-        },\n-\n","filename":"make\/conf\/jib-profiles.js","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-DISABLED_WARNINGS_microsoft := 4100 4127 4201 4244 4291 4351 \\\n+DISABLED_WARNINGS_microsoft := 4100 4127 4146 4201 4244 4291 4351 \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-    guarantee(val < (1U << nbits), \"Field too big for insn\");\n+    guarantee(val < (1ULL << nbits), \"Field too big for insn\");\n@@ -448,2 +448,2 @@\n-    guarantee((_mode == base_plus_offset | _mode == base_plus_offset_reg\n-               | _mode == post | _mode == post_reg),\n+    guarantee((_mode == base_plus_offset || _mode == base_plus_offset_reg\n+               || _mode == post || _mode == post_reg),\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -665,5 +665,6 @@\n-#define DESCRIBE_FP_OFFSET(name)                                        \\\n-  {                                                                     \\\n-    uintptr_t *p = (uintptr_t *)fp;                                     \\\n-    printf(\"0x%016lx 0x%016lx %s\\n\", (uintptr_t)(p + frame::name##_offset), \\\n-           p[frame::name##_offset], #name);                             \\\n+#define DESCRIBE_FP_OFFSET(name)                     \\\n+  {                                                  \\\n+    uintptr_t *p = (uintptr_t *)fp;                  \\\n+    printf(INTPTR_FORMAT \" \" INTPTR_FORMAT \" %s\\n\",  \\\n+           (uintptr_t)(p + frame::name##_offset),    \\\n+           p[frame::name##_offset], #name);          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address load_addr) {\n+void ShenandoahBarrierSetAssembler::load_reference_barrier_weak(MacroAssembler* masm, Register dst, Address load_addr) {\n@@ -275,1 +275,1 @@\n-  __ block_comment(\"load_reference_barrier_native { \");\n+  __ block_comment(\"load_reference_barrier_weak { \");\n@@ -289,1 +289,1 @@\n-  __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));\n+  __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak));\n@@ -300,1 +300,1 @@\n-  __ block_comment(\"} load_reference_barrier_native\");\n+  __ block_comment(\"} load_reference_barrier_weak\");\n@@ -355,2 +355,2 @@\n-    if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {\n-      load_reference_barrier_native(masm, dst, src);\n+    if (ShenandoahBarrierSet::use_load_reference_barrier_weak(decorators, type)) {\n+      load_reference_barrier_weak(masm, dst, src);\n@@ -480,1 +480,2 @@\n-  assert_different_registers(addr, expected, new_val, tmp1, tmp2);\n+  assert_different_registers(addr, expected, tmp1, tmp2);\n+  assert_different_registers(addr, new_val,  tmp1, tmp2);\n@@ -672,2 +673,2 @@\n-  if (stub->is_native()) {\n-    __ far_call(RuntimeAddress(bs->load_reference_barrier_native_rt_code_blob()->code_begin()));\n+  if (stub->is_weak()) {\n+    __ far_call(RuntimeAddress(bs->load_reference_barrier_weak_rt_code_blob()->code_begin()));\n@@ -731,1 +732,1 @@\n-void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {\n+void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_weak) {\n@@ -738,2 +739,2 @@\n-  if (is_native) {\n-    __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));\n+  if (is_weak) {\n+    __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak));\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  void load_reference_barrier_native(MacroAssembler* masm, Register dst, Address load_addr);\n+  void load_reference_barrier_weak(MacroAssembler* masm, Register dst, Address load_addr);\n@@ -75,1 +75,1 @@\n-  void generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native);\n+  void generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_weak);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1833,1 +1833,1 @@\n-    const unsigned mask = size_in_bytes - 1;\n+    const uint64_t mask = size_in_bytes - 1;\n@@ -2897,1 +2897,1 @@\n-  const int sz = prev_ldst->size_in_bytes();\n+  const size_t sz = prev_ldst->size_in_bytes();\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -658,1 +658,1 @@\n-  size_t size_in_bytes() { return 1 << size(); }\n+  size_t size_in_bytes() { return 1ULL << size(); }\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1501,1 +1501,1 @@\n-    __ bang_stack_with_offset(StackOverflow::stack_shadow_zone_size());\n+    __ bang_stack_with_offset(checked_cast<int>(StackOverflow::stack_shadow_zone_size()));\n@@ -2448,1 +2448,1 @@\n-  __ mov(rscratch1, (address)0xDEADDEAD);        \/\/ Make a recognizable pattern\n+  __ mov(rscratch1, (uint64_t)0xDEADDEAD);        \/\/ Make a recognizable pattern\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1308,1 +1308,1 @@\n-  void verify_oop_array (size_t size, Register a, Register count, Register temp) {\n+  void verify_oop_array (int size, Register a, Register count, Register temp) {\n@@ -1315,1 +1315,1 @@\n-    if (size == (size_t)wordSize) {\n+    if (size == wordSize) {\n@@ -1346,1 +1346,1 @@\n-  address generate_disjoint_copy(size_t size, bool aligned, bool is_oop, address *entry,\n+  address generate_disjoint_copy(int size, bool aligned, bool is_oop, address *entry,\n@@ -1412,1 +1412,1 @@\n-  address generate_conjoint_copy(size_t size, bool aligned, bool is_oop, address nooverlap_target,\n+  address generate_conjoint_copy(int size, bool aligned, bool is_oop, address nooverlap_target,\n@@ -1663,1 +1663,1 @@\n-    const size_t size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+    const int size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n@@ -1681,1 +1681,1 @@\n-    const size_t size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n+    const int size = UseCompressedOops ? sizeof (jint) : sizeof (jlong);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1123,1 +1123,1 @@\n-    const int n_shadow_pages = StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size();\n+    const int n_shadow_pages = (int)(StackOverflow::stack_shadow_zone_size() \/ os::vm_page_size());\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src) {\n+void ShenandoahBarrierSetAssembler::load_reference_barrier_weak(MacroAssembler* masm, Register dst, Address src) {\n@@ -347,1 +347,1 @@\n-  __ block_comment(\"load_reference_barrier_native { \");\n+  __ block_comment(\"load_reference_barrier_weak { \");\n@@ -399,1 +399,1 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), dst, rsi);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), dst, rsi);\n@@ -423,1 +423,1 @@\n-  __ block_comment(\"load_reference_barrier_native { \");\n+  __ block_comment(\"} load_reference_barrier_weak\");\n@@ -520,2 +520,2 @@\n-    if (ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type)) {\n-      load_reference_barrier_native(masm, dst, src);\n+    if (ShenandoahBarrierSet::use_load_reference_barrier_weak(decorators, type)) {\n+      load_reference_barrier_weak(masm, dst, src);\n@@ -641,1 +641,2 @@\n-  assert_different_registers(oldval, newval, tmp1, tmp2);\n+  assert_different_registers(oldval, tmp1, tmp2);\n+  assert_different_registers(newval, tmp1, tmp2);\n@@ -873,2 +874,2 @@\n-  if (stub->is_native()) {\n-    __ call(RuntimeAddress(bs->load_reference_barrier_native_rt_code_blob()->code_begin()));\n+  if (stub->is_weak()) {\n+    __ call(RuntimeAddress(bs->load_reference_barrier_weak_rt_code_blob()->code_begin()));\n@@ -941,1 +942,1 @@\n-void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native) {\n+void ShenandoahBarrierSetAssembler::generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_weak) {\n@@ -950,2 +951,2 @@\n-  if (is_native) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), c_rarg0, c_rarg1);\n+  if (is_weak) {\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), c_rarg0, c_rarg1);\n@@ -960,2 +961,2 @@\n-  if (is_native) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native), rax, rbx);\n+  if (is_weak) {\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), rax, rbx);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-  void generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_native);\n+  void generate_c1_load_reference_barrier_runtime_stub(StubAssembler* sasm, bool is_weak);\n@@ -77,1 +77,1 @@\n-  void load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src);\n+  void load_reference_barrier_weak(MacroAssembler* masm, Register dst, Address src);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -325,0 +325,2 @@\n+  static int component_mirror_offset() { return _component_mirror_offset; }\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,2 +214,2 @@\n-    bool is_native = ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type);\n-    tmp = load_reference_barrier(gen, tmp, access.resolved_addr(), is_native);\n+    bool is_weak = ShenandoahBarrierSet::use_load_reference_barrier_weak(decorators, type);\n+    tmp = load_reference_barrier(gen, tmp, access.resolved_addr(), is_weak);\n@@ -254,1 +254,1 @@\n-  const bool _is_native;\n+  const bool _is_weak;\n@@ -257,1 +257,1 @@\n-  C1ShenandoahLoadReferenceBarrierCodeGenClosure(bool is_native) : _is_native(is_native) {}\n+  C1ShenandoahLoadReferenceBarrierCodeGenClosure(bool is_weak) : _is_weak(is_weak) {}\n@@ -261,1 +261,1 @@\n-    bs->generate_c1_load_reference_barrier_runtime_stub(sasm, _is_native);\n+    bs->generate_c1_load_reference_barrier_runtime_stub(sasm, _is_weak);\n@@ -277,4 +277,4 @@\n-    C1ShenandoahLoadReferenceBarrierCodeGenClosure lrb_native_code_gen_cl(true);\n-    _load_reference_barrier_native_rt_code_blob = Runtime1::generate_blob(buffer_blob, -1,\n-                                                                   \"shenandoah_load_reference_barrier_native_slow\",\n-                                                                   false, &lrb_native_code_gen_cl);\n+    C1ShenandoahLoadReferenceBarrierCodeGenClosure lrb_weak_code_gen_cl(true);\n+    _load_reference_barrier_weak_rt_code_blob = Runtime1::generate_blob(buffer_blob, -1,\n+                                                                   \"shenandoah_load_reference_barrier_weak_slow\",\n+                                                                   false, &lrb_weak_code_gen_cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-  bool _is_native;\n+  bool _is_weak;\n@@ -99,2 +99,2 @@\n-  ShenandoahLoadReferenceBarrierStub(LIR_Opr obj, LIR_Opr addr, LIR_Opr result, LIR_Opr tmp1, LIR_Opr tmp2, bool is_native) :\n-          _obj(obj), _addr(addr), _result(result), _tmp1(tmp1), _tmp2(tmp2), _is_native(is_native)\n+  ShenandoahLoadReferenceBarrierStub(LIR_Opr obj, LIR_Opr addr, LIR_Opr result, LIR_Opr tmp1, LIR_Opr tmp2, bool is_weak) :\n+          _obj(obj), _addr(addr), _result(result), _tmp1(tmp1), _tmp2(tmp2), _is_weak(is_weak)\n@@ -114,1 +114,1 @@\n-  bool is_native() const { return _is_native; }\n+  bool is_weak() const { return _is_weak; }\n@@ -194,1 +194,1 @@\n-  CodeBlob* _load_reference_barrier_native_rt_code_blob;\n+  CodeBlob* _load_reference_barrier_weak_rt_code_blob;\n@@ -218,3 +218,3 @@\n-  CodeBlob* load_reference_barrier_native_rt_code_blob() {\n-    assert(_load_reference_barrier_native_rt_code_blob != NULL, \"\");\n-    return _load_reference_barrier_native_rt_code_blob;\n+  CodeBlob* load_reference_barrier_weak_rt_code_blob() {\n+    assert(_load_reference_barrier_weak_rt_code_blob != NULL, \"\");\n+    return _load_reference_barrier_weak_rt_code_blob;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-         (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native));\n+         (entry_point == CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak));\n@@ -550,1 +550,1 @@\n-                                                  ShenandoahBarrierSet::use_load_reference_barrier_native(decorators, type));\n+                                                  ShenandoahBarrierSet::use_load_reference_barrier_weak(decorators, type));\n@@ -1066,1 +1066,1 @@\n-          ((ShenandoahLoadReferenceBarrierNode*)in2)->is_native())) {\n+          ((ShenandoahLoadReferenceBarrierNode*)in2)->is_weak())) {\n@@ -1071,1 +1071,1 @@\n-          ((ShenandoahLoadReferenceBarrierNode*)in1)->is_native())) {\n+          ((ShenandoahLoadReferenceBarrierNode*)in1)->is_weak())) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -959,1 +959,1 @@\n-void ShenandoahBarrierC2Support::call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr, Node*& result_mem, Node* raw_mem, bool is_native, PhaseIdealLoop* phase) {\n+void ShenandoahBarrierC2Support::call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr, Node*& result_mem, Node* raw_mem, bool is_weak, PhaseIdealLoop* phase) {\n@@ -974,3 +974,3 @@\n-  address calladdr = is_native ? CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_native)\n-                               : target;\n-  const char* name = is_native ? \"load_reference_barrier_native\" : \"load_reference_barrier\";\n+  address calladdr = is_weak ? CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak)\n+                             : target;\n+  const char* name = is_weak ? \"load_reference_barrier_native\" : \"load_reference_barrier\";\n@@ -1341,1 +1341,1 @@\n-    if (!lrb->is_native()) {\n+    if (!lrb->is_weak()) {\n@@ -1392,1 +1392,1 @@\n-    call_lrb_stub(ctrl, val, addr, result_mem, raw_mem, lrb->is_native(), phase);\n+    call_lrb_stub(ctrl, val, addr, result_mem, raw_mem, lrb->is_weak(), phase);\n@@ -2317,1 +2317,1 @@\n-                    phi = NULL;\n+                    phi = NodeSentinel;\n@@ -2322,1 +2322,1 @@\n-            if (phi == NULL) {\n+            if (phi == NodeSentinel) {\n@@ -2331,2 +2331,5 @@\n-          assert(phi != NULL, \"\");\n-          regions.map(c->_idx, phi);\n+          if (phi != NULL) {\n+            regions.map(c->_idx, phi);\n+          } else {\n+            assert(c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n+          }\n@@ -2343,1 +2346,1 @@\n-        assert(m != NULL, \"expect memory state\");\n+        assert(m != NULL || c->Opcode() == Op_Halt, \"expect memory state\");\n@@ -2367,1 +2370,2 @@\n-      if (n->is_Phi() && n->_idx >= last && n->in(0) == c) {\n+      assert(n != NULL || c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n+      if (n != NULL && n->is_Phi() && n->_idx >= last && n->in(0) == c) {\n@@ -2376,0 +2380,1 @@\n+      assert(n != NULL || c->unique_ctrl_out()->Opcode() == Op_Halt, \"expected memory state\");\n@@ -2380,0 +2385,1 @@\n+          assert(c->unique_ctrl_out()->Opcode() != Op_Halt, \"expected memory state\");\n@@ -2882,2 +2888,2 @@\n-ShenandoahLoadReferenceBarrierNode::ShenandoahLoadReferenceBarrierNode(Node* ctrl, Node* obj, bool native)\n-: Node(ctrl, obj), _native(native) {\n+ShenandoahLoadReferenceBarrierNode::ShenandoahLoadReferenceBarrierNode(Node* ctrl, Node* obj, bool weak)\n+: Node(ctrl, obj), _weak(weak) {\n@@ -2887,2 +2893,2 @@\n-bool ShenandoahLoadReferenceBarrierNode::is_native() const {\n-  return _native;\n+bool ShenandoahLoadReferenceBarrierNode::is_weak() const {\n+  return _weak;\n@@ -2896,1 +2902,1 @@\n-  return Node::hash() + (_native ? 1 : 0);\n+  return Node::hash() + (_weak ? 1 : 0);\n@@ -2901,1 +2907,1 @@\n-         _native == ((const ShenandoahLoadReferenceBarrierNode&)n)._native;\n+         _weak == ((const ShenandoahLoadReferenceBarrierNode&)n)._weak;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  static void call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr, Node*& result_mem, Node* raw_mem, bool is_native, PhaseIdealLoop* phase);\n+  static void call_lrb_stub(Node*& ctrl, Node*& val, Node* load_addr, Node*& result_mem, Node* raw_mem, bool is_weak, PhaseIdealLoop* phase);\n@@ -232,1 +232,1 @@\n-  bool _native;\n+  bool _weak;\n@@ -237,1 +237,1 @@\n-  bool is_native() const;\n+  bool is_weak() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-bool ShenandoahBarrierSet::use_load_reference_barrier_native(DecoratorSet decorators, BasicType type) {\n+bool ShenandoahBarrierSet::use_load_reference_barrier_weak(DecoratorSet decorators, BasicType type) {\n@@ -98,1 +98,1 @@\n-  return (decorators & IN_NATIVE) != 0;\n+  return ((decorators & IN_NATIVE) != 0) && ((decorators & ON_STRONG_OOP_REF) == 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-  static bool use_load_reference_barrier_native(DecoratorSet decorators, BasicType type);\n+  static bool use_load_reference_barrier_weak(DecoratorSet decorators, BasicType type);\n@@ -95,2 +95,2 @@\n-  template <class T>\n-  inline oop load_reference_barrier_native(oop obj, T* load_addr);\n+  template <DecoratorSet decorators, class T>\n+  inline oop load_reference_barrier(oop obj, T* load_addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -102,5 +102,2 @@\n-template <class T>\n-inline oop ShenandoahBarrierSet::load_reference_barrier_native(oop obj, T* load_addr) {\n-  if (CompressedOops::is_null(obj)) {\n-    return NULL;\n-  }\n+template <DecoratorSet decorators, class T>\n+inline oop ShenandoahBarrierSet::load_reference_barrier(oop obj, T* load_addr) {\n@@ -108,2 +105,4 @@\n-  ShenandoahMarkingContext* const marking_context = _heap->marking_context();\n-  if (_heap->is_concurrent_weak_root_in_progress() && !marking_context->is_marked(obj)) {\n+  \/\/ Prevent resurrection of unreachable non-strorg references.\n+  if (!HasDecorator<decorators, ON_STRONG_OOP_REF>::value && obj != NULL &&\n+      _heap->is_concurrent_weak_root_in_progress() &&\n+      !_heap->marking_context()->is_marked(obj)) {\n@@ -114,0 +113,2 @@\n+      \/\/ This path is sometimes (rarely) taken by GC threads.\n+      \/\/ See e.g.: https:\/\/bugs.openjdk.java.net\/browse\/JDK-8237874\n@@ -189,1 +190,1 @@\n-    value = bs->load_reference_barrier_native(value, addr);\n+    value = bs->load_reference_barrier<decorators, T>(value, addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -69,2 +69,2 @@\n-JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_native(oopDesc * src, oop* load_addr))\n-  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier_native(oop(src), load_addr);\n+JRT_LEAF(oopDesc*, ShenandoahRuntime::load_reference_barrier_weak(oopDesc * src, oop* load_addr))\n+  return (oopDesc*) ShenandoahBarrierSet::barrier_set()->load_reference_barrier<ON_UNKNOWN_OOP_REF, oop>(oop(src), load_addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  static oopDesc* load_reference_barrier_native(oopDesc* src, oop* load_addr);\n+  static oopDesc* load_reference_barrier_weak(oopDesc* src, oop* load_addr);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -228,4 +228,5 @@\n-  enum {\n-    chunk_bits  = 10,\n-    pow_bits    = 5,\n-  };\n+  static const uint8_t chunk_bits  = 10;\n+  static const uint8_t pow_bits    = 5;\n+\n+  static const int chunk_max       = nth_bit(chunk_bits) - 1;\n+  static const int pow_max         = nth_bit(pow_bits) - 1;\n@@ -240,2 +241,2 @@\n-    assert(0 <= chunk && chunk < nth_bit(chunk_bits), \"chunk is sane: %d\", chunk);\n-    assert(0 <= pow && pow < nth_bit(pow_bits), \"pow is sane: %d\", pow);\n+    assert(0 <= chunk && chunk <= chunk_max, \"chunk is in range: %d\", chunk);\n+    assert(0 <= pow && pow <= pow_max, \"pow is in range: %d\", pow);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-  ZNMethod::nmethod_oops_do(nm, &cl);\n+  ZNMethod::nmethod_oops_do_inner(nm, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -39,3 +40,2 @@\n-  char* const addr = _top;\n-  _top += size;\n-  assert(_top <= _end, \"Allocation should never fail\");\n+  char* const addr = Atomic::fetch_and_add(&_top, size);\n+  assert(addr + size <= _end, \"Allocation should never fail\");\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingAllocator.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/z\/zForwarding.inline.hpp\"\n-#include \"gc\/z\/zForwardingTable.inline.hpp\"\n-#include \"gc\/z\/zGlobals.hpp\"\n-#include \"gc\/z\/zGranuleMap.inline.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-ZForwardingTable::ZForwardingTable() :\n-    _map(ZAddressOffsetMax) {}\n-\n-void ZForwardingTable::insert(ZForwarding* forwarding) {\n-  const uintptr_t offset = forwarding->start();\n-  const size_t size = forwarding->size();\n-\n-  assert(_map.get(offset) == NULL, \"Invalid entry\");\n-  _map.put(offset, size, forwarding);\n-}\n-\n-void ZForwardingTable::remove(ZForwarding* forwarding) {\n-  const uintptr_t offset = forwarding->start();\n-  const size_t size = forwarding->size();\n-\n-  assert(_map.get(offset) == forwarding, \"Invalid entry\");\n-  _map.put(offset, size, NULL);\n-}\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingTable.cpp","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zForwarding.inline.hpp\"\n@@ -29,0 +30,1 @@\n+#include \"gc\/z\/zGlobals.hpp\"\n@@ -30,0 +32,4 @@\n+#include \"utilities\/debug.hpp\"\n+\n+inline ZForwardingTable::ZForwardingTable() :\n+    _map(ZAddressOffsetMax) {}\n@@ -36,0 +42,16 @@\n+inline void ZForwardingTable::insert(ZForwarding* forwarding) {\n+  const uintptr_t offset = forwarding->start();\n+  const size_t size = forwarding->size();\n+\n+  assert(_map.get(offset) == NULL, \"Invalid entry\");\n+  _map.put(offset, size, forwarding);\n+}\n+\n+inline void ZForwardingTable::remove(ZForwarding* forwarding) {\n+  const uintptr_t offset = forwarding->start();\n+  const size_t size = forwarding->size();\n+\n+  assert(_map.get(offset) == forwarding, \"Invalid entry\");\n+  _map.put(offset, size, NULL);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingTable.inline.hpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n@@ -68,1 +69,1 @@\n-    _relocation_set(),\n+    _relocation_set(&_workers),\n@@ -223,0 +224,11 @@\n+void ZHeap::free_pages(const ZArray<ZPage*>* pages, bool reclaimed) {\n+  \/\/ Remove page table entries\n+  ZArrayIterator<ZPage*> iter(pages);\n+  for (ZPage* page; iter.next(&page);) {\n+    _page_table.remove(page);\n+  }\n+\n+  \/\/ Free pages\n+  _page_allocator.free_pages(pages, reclaimed);\n+}\n+\n@@ -352,0 +364,10 @@\n+void ZHeap::free_garbage_pages(ZRelocationSetSelector* selector, int bulk) {\n+  \/\/ Freeing garbage pages in bulk is an optimization to avoid grabbing\n+  \/\/ the page allocator lock, and trying to satisfy stalled allocations\n+  \/\/ too frequently.\n+  if (selector->should_free_garbage_pages(bulk)) {\n+    free_pages(selector->garbage_pages(), true \/* reclaimed *\/);\n+    selector->clear_garbage_pages();\n+  }\n+}\n+\n@@ -372,2 +394,2 @@\n-      \/\/ Reclaim page immediately\n-      free_page(page, true \/* reclaimed *\/);\n+      \/\/ Reclaim garbage pages in bulk\n+      free_garbage_pages(&selector, 64 \/* bulk *\/);\n@@ -377,0 +399,3 @@\n+  \/\/ Reclaim remaining garbage pages\n+  free_garbage_pages(&selector, 0 \/* bulk *\/);\n+\n@@ -380,2 +405,5 @@\n-  \/\/ Select pages to relocate\n-  selector.select(&_relocation_set);\n+  \/\/ Select relocation set\n+  selector.select();\n+\n+  \/\/ Install relocation set\n+  _relocation_set.install(&selector);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zArray.hpp\"\n@@ -43,0 +44,1 @@\n+class ZRelocationSetSelector;\n@@ -66,0 +68,2 @@\n+  void free_garbage_pages(ZRelocationSetSelector* selector, int bulk);\n+\n@@ -113,0 +117,1 @@\n+  void free_pages(const ZArray<ZPage*>* pages, bool reclaimed);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"gc\/z\/zNMethod.hpp\"\n@@ -95,2 +97,2 @@\n-template <bool Concurrent, bool Weak>\n-class ZHeapIteratorRootOopClosure : public ZRootsIteratorClosure {\n+template <bool Weak>\n+class ZHeapIteratorRootOopClosure : public OopClosure {\n@@ -105,5 +107,1 @@\n-    if (Concurrent) {\n-      return NativeAccess<AS_NO_KEEPALIVE>::oop_load(p);\n-    }\n-\n-    return RawAccess<>::oop_load(p);\n+    return NativeAccess<AS_NO_KEEPALIVE>::oop_load(p);\n@@ -124,16 +122,0 @@\n-\n-  virtual void do_thread(Thread* thread) {\n-    CodeBlobToOopClosure code_cl(this, false \/* fix_oop_relocations *\/);\n-    thread->oops_do(this, &code_cl);\n-  }\n-\n-  virtual ZNMethodEntry nmethod_entry() const {\n-    if (ClassUnloading) {\n-      \/\/ All encountered nmethods should have been \"entered\" during stack walking\n-      return ZNMethodEntry::VerifyDisarmed;\n-    } else {\n-      \/\/ All nmethods are considered roots and will be visited.\n-      \/\/ Make sure that the unvisited gets fixed and disarmed before proceeding.\n-      return ZNMethodEntry::PreBarrier;\n-    }\n-  }\n@@ -183,1 +165,1 @@\n-    _concurrent_roots(),\n+    _concurrent_roots(ClassLoaderData::_claim_other),\n@@ -258,4 +240,77 @@\n-template <bool Concurrent, bool Weak, typename RootsIterator>\n-void ZHeapIterator::push_roots(const ZHeapIteratorContext& context, RootsIterator& iter) {\n-  ZHeapIteratorRootOopClosure<Concurrent, Weak> cl(context);\n-  iter.oops_do(&cl);\n+typedef ClaimingCLDToOopClosure<ClassLoaderData::_claim_other> ZHeapIteratorCLDCLosure;\n+\n+class ZHeapIteratorNMethodClosure : public NMethodClosure {\n+private:\n+  OopClosure* const        _cl;\n+  BarrierSetNMethod* const _bs_nm;\n+\n+public:\n+  ZHeapIteratorNMethodClosure(OopClosure* cl) :\n+      _cl(cl),\n+      _bs_nm(BarrierSet::barrier_set()->barrier_set_nmethod()) {}\n+\n+  virtual void do_nmethod(nmethod* nm) {\n+    assert(!ClassUnloading, \"Only used if class unloading is turned off\");\n+\n+    \/\/ ClassUnloading is turned off, all nmethods are considered strong,\n+    \/\/ not only those on the call stacks. The heap iteration might happen\n+    \/\/ before the concurrent processign of the code cache, make sure that\n+    \/\/ all nmethods have been processed before visiting the oops.\n+    _bs_nm->nmethod_entry_barrier(nm);\n+\n+    ZNMethod::nmethod_oops_do(nm, _cl);\n+  }\n+};\n+\n+class ZHeapIteratorThreadClosure : public ThreadClosure {\n+private:\n+  OopClosure* const _cl;\n+\n+  class NMethodVisitor : public CodeBlobToOopClosure {\n+  public:\n+    NMethodVisitor(OopClosure* cl) :\n+        CodeBlobToOopClosure(cl, false \/* fix_oop_relocations *\/) {}\n+\n+    void do_code_blob(CodeBlob* cb) {\n+      assert(!cb->is_nmethod() || !ZNMethod::is_armed(cb->as_nmethod()),\n+          \"NMethods on stack should have been fixed and disarmed\");\n+\n+      CodeBlobToOopClosure::do_code_blob(cb);\n+    }\n+  };\n+\n+public:\n+  ZHeapIteratorThreadClosure(OopClosure* cl) : _cl(cl) {}\n+\n+  void do_thread(Thread* thread) {\n+    NMethodVisitor code_cl(_cl);\n+    thread->oops_do(_cl, &code_cl);\n+  }\n+};\n+\n+void ZHeapIterator::push_strong_roots(const ZHeapIteratorContext& context) {\n+  ZHeapIteratorRootOopClosure<false \/* Weak *\/> cl(context);\n+  ZHeapIteratorCLDCLosure cld_cl(&cl);\n+  ZHeapIteratorNMethodClosure nm_cl(&cl);\n+  ZHeapIteratorThreadClosure thread_cl(&cl);\n+\n+  _concurrent_roots.apply(&cl,\n+                          &cld_cl,\n+                          &thread_cl,\n+                          &nm_cl);\n+}\n+\n+void ZHeapIterator::push_weak_roots(const ZHeapIteratorContext& context) {\n+  ZHeapIteratorRootOopClosure<true  \/* Weak *\/> cl(context);\n+  _concurrent_weak_roots.apply(&cl);\n+\n+  AlwaysTrueClosure is_alive;\n+  _weak_roots.apply(&is_alive, &cl);\n+}\n+\n+template <bool VisitWeaks>\n+void ZHeapIterator::push_roots(const ZHeapIteratorContext& context) {\n+  push_strong_roots(context);\n+  if (VisitWeaks) {\n+    push_weak_roots(context);\n+  }\n@@ -346,8 +401,3 @@\n-void ZHeapIterator::object_iterate_inner(const ZHeapIteratorContext& context, ObjectClosure* cl) {\n-  push_roots<true  \/* Concurrent *\/, false \/* Weak *\/>(context, _concurrent_roots);\n-  if (VisitWeaks) {\n-    push_roots<false \/* Concurrent *\/, true  \/* Weak *\/>(context, _weak_roots);\n-    push_roots<true  \/* Concurrent *\/, true  \/* Weak *\/>(context, _concurrent_weak_roots);\n-  }\n-\n-  drain_and_steal<VisitWeaks>(context, cl);\n+void ZHeapIterator::object_iterate_inner(const ZHeapIteratorContext& context, ObjectClosure* object_cl) {\n+  push_roots<VisitWeaks>(context);\n+  drain_and_steal<VisitWeaks>(context, object_cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":86,"deletions":36,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -49,10 +49,10 @@\n-  const bool                         _visit_weaks;\n-  ZStatTimerDisable                  _timer_disable;\n-  ZHeapIteratorBitMaps               _bitmaps;\n-  ZLock                              _bitmaps_lock;\n-  ZHeapIteratorQueues                _queues;\n-  ZHeapIteratorArrayQueues           _array_queues;\n-  ZConcurrentRootsIteratorClaimOther _concurrent_roots;\n-  ZWeakRootsIterator                 _weak_roots;\n-  ZConcurrentWeakRootsIterator       _concurrent_weak_roots;\n-  TaskTerminator                     _terminator;\n+  const bool                   _visit_weaks;\n+  ZStatTimerDisable            _timer_disable;\n+  ZHeapIteratorBitMaps         _bitmaps;\n+  ZLock                        _bitmaps_lock;\n+  ZHeapIteratorQueues          _queues;\n+  ZHeapIteratorArrayQueues     _array_queues;\n+  ZConcurrentRootsIterator     _concurrent_roots;\n+  ZWeakRootsIterator           _weak_roots;\n+  ZConcurrentWeakRootsIterator _concurrent_weak_roots;\n+  TaskTerminator               _terminator;\n@@ -64,2 +64,5 @@\n-  template <bool Concurrent, bool Weak, typename RootsIterator>\n-  void push_roots(const ZHeapIteratorContext& context, RootsIterator& iter);\n+  void push_strong_roots(const ZHeapIteratorContext& context);\n+  void push_weak_roots(const ZHeapIteratorContext& context);\n+\n+  template <bool VisitWeaks>\n+  void push_roots(const ZHeapIteratorContext& context);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.hpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/nmethod.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"gc\/z\/zLock.inline.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"gc\/z\/zNMethod.hpp\"\n@@ -575,4 +578,3 @@\n-class ZMarkConcurrentRootsIteratorClosure : public ZRootsIteratorClosure {\n-public:\n-  ZMarkConcurrentRootsIteratorClosure() {\n-    ZThreadLocalAllocBuffer::reset_statistics();\n+class ZMarkOopClosure : public OopClosure {\n+  virtual void do_oop(oop* p) {\n+    ZBarrier::mark_barrier_on_oop_field(p, false \/* finalizable *\/);\n@@ -581,2 +583,2 @@\n-  ~ZMarkConcurrentRootsIteratorClosure() {\n-    ZThreadLocalAllocBuffer::publish_statistics();\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n@@ -584,0 +586,1 @@\n+};\n@@ -585,4 +588,3 @@\n-  virtual ZNMethodEntry nmethod_entry() const {\n-    \/\/ Only apply closure to armed nmethods, and then disarm them.\n-    return ZNMethodEntry::Disarm;\n-  }\n+class ZMarkThreadClosure : public ThreadClosure {\n+private:\n+  OopClosure* const _cl;\n@@ -590,0 +592,8 @@\n+public:\n+  ZMarkThreadClosure(OopClosure* cl) :\n+      _cl(cl) {\n+    ZThreadLocalAllocBuffer::reset_statistics();\n+  }\n+  ~ZMarkThreadClosure() {\n+    ZThreadLocalAllocBuffer::publish_statistics();\n+  }\n@@ -592,1 +602,1 @@\n-    StackWatermarkSet::finish_processing(jt, this, StackWatermarkKind::gc);\n+    StackWatermarkSet::finish_processing(jt, _cl, StackWatermarkKind::gc);\n@@ -595,0 +605,1 @@\n+};\n@@ -596,3 +607,3 @@\n-  virtual void do_oop(oop* p) {\n-    ZBarrier::mark_barrier_on_oop_field(p, false \/* finalizable *\/);\n-  }\n+class ZMarkNMethodClosure : public NMethodClosure {\n+private:\n+  OopClosure* const _cl;\n@@ -600,2 +611,14 @@\n-  virtual void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n+public:\n+  ZMarkNMethodClosure(OopClosure* cl) :\n+      _cl(cl) {}\n+\n+  virtual void do_nmethod(nmethod* nm) {\n+    ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));\n+    if (!nm->is_alive()) {\n+      return;\n+    }\n+\n+    if (ZNMethod::is_armed(nm)) {\n+      ZNMethod::nmethod_oops_do_inner(nm, _cl);\n+      ZNMethod::disarm(nm);\n+    }\n@@ -605,0 +628,2 @@\n+typedef ClaimingCLDToOopClosure<ClassLoaderData::_claim_strong> ZMarkCLDClosure;\n+\n@@ -607,4 +632,8 @@\n-  ZMark* const                        _mark;\n-  SuspendibleThreadSetJoiner          _sts_joiner;\n-  ZConcurrentRootsIteratorClaimStrong _roots;\n-  ZMarkConcurrentRootsIteratorClosure _cl;\n+  ZMark* const               _mark;\n+  SuspendibleThreadSetJoiner _sts_joiner;\n+  ZConcurrentRootsIterator   _roots;\n+\n+  ZMarkOopClosure            _cl;\n+  ZMarkCLDClosure            _cld_cl;\n+  ZMarkThreadClosure         _thread_cl;\n+  ZMarkNMethodClosure        _nm_cl;\n@@ -617,2 +646,5 @@\n-      _roots(),\n-      _cl() {\n+      _roots(ClassLoaderData::_claim_strong),\n+      _cl(),\n+      _cld_cl(&_cl),\n+      _thread_cl(&_cl),\n+      _nm_cl(&_cl) {\n@@ -627,1 +659,4 @@\n-    _roots.oops_do(&_cl);\n+    _roots.apply(&_cl,\n+                 &_cld_cl,\n+                 &_thread_cl,\n+                 &_nm_cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":58,"deletions":23,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -207,0 +207,9 @@\n+  ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));\n+  if (!nm->is_alive()) {\n+    return;\n+  }\n+\n+  ZNMethod::nmethod_oops_do_inner(nm, cl);\n+}\n+\n+void ZNMethod::nmethod_oops_do_inner(nmethod* nm, OopClosure* cl) {\n@@ -237,42 +246,1 @@\n-class ZNMethodToOopsDoClosure : public NMethodClosure {\n-private:\n-  OopClosure* const        _cl;\n-  const ZNMethodEntry      _entry;\n-  BarrierSetNMethod* const _bs_nm;\n-\n-public:\n-  ZNMethodToOopsDoClosure(OopClosure* cl, ZNMethodEntry entry) :\n-      _cl(cl),\n-      _entry(entry),\n-      _bs_nm(BarrierSet::barrier_set()->barrier_set_nmethod()) {}\n-\n-  virtual void do_nmethod(nmethod* nm) {\n-    if (_entry == ZNMethodEntry::PreBarrier) {\n-      \/\/ Apply entry barrier before proceeding with closure\n-      _bs_nm->nmethod_entry_barrier(nm);\n-    }\n-\n-    ZLocker<ZReentrantLock> locker(ZNMethod::lock_for_nmethod(nm));\n-    if (!nm->is_alive()) {\n-      return;\n-    }\n-\n-    if (_entry == ZNMethodEntry::Disarm) {\n-      \/\/ Apply closure and disarm only armed nmethods\n-      if (ZNMethod::is_armed(nm)) {\n-        ZNMethod::nmethod_oops_do(nm, _cl);\n-        ZNMethod::disarm(nm);\n-      }\n-      return;\n-    }\n-\n-    if (_entry == ZNMethodEntry::VerifyDisarmed) {\n-      \/\/ Only verify\n-      assert(!ZNMethod::is_armed(nm), \"Must be disarmed\");\n-    }\n-\n-    ZNMethod::nmethod_oops_do(nm, _cl);\n-  }\n-};\n-\n-void ZNMethod::oops_do_begin() {\n+void ZNMethod::nmethods_do_begin() {\n@@ -282,1 +250,1 @@\n-void ZNMethod::oops_do_end() {\n+void ZNMethod::nmethods_do_end() {\n@@ -286,3 +254,2 @@\n-void ZNMethod::oops_do(OopClosure* cl, ZNMethodEntry entry) {\n-  ZNMethodToOopsDoClosure nmethod_cl(cl, entry);\n-  ZNMethodTable::nmethods_do(&nmethod_cl);\n+void ZNMethod::nmethods_do(NMethodClosure* cl) {\n+  ZNMethodTable::nmethods_do(cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":13,"deletions":46,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-class OopClosure;\n+class NMethodClosure;\n@@ -34,7 +34,0 @@\n-enum class ZNMethodEntry {\n-  PreBarrier,\n-  Disarm,\n-  VerifyDisarmed,\n-  None\n-};\n-\n@@ -59,0 +52,1 @@\n+  static void nmethod_oops_do_inner(nmethod* nm, OopClosure* cl);\n@@ -60,3 +54,3 @@\n-  static void oops_do_begin();\n-  static void oops_do_end();\n-  static void oops_do(OopClosure* cl, ZNMethodEntry entry);\n+  static void nmethods_do_begin();\n+  static void nmethods_do_end();\n+  static void nmethods_do(NMethodClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-class ZPhantomKeepAliveOopClosure : public ZRootsIteratorClosure {\n+class ZPhantomKeepAliveOopClosure : public OopClosure {\n@@ -60,2 +60,0 @@\n-\n-  virtual ZNMethodEntry nmethod_entry() const;\n@@ -63,2 +61,1 @@\n-\n-class ZPhantomCleanOopClosure : public ZRootsIteratorClosure {\n+class ZPhantomCleanOopClosure : public OopClosure {\n@@ -68,2 +65,0 @@\n-\n-  virtual ZNMethodEntry nmethod_entry() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -83,5 +83,0 @@\n-inline ZNMethodEntry ZPhantomKeepAliveOopClosure::nmethod_entry() const {\n-  ShouldNotReachHere();\n-  return ZNMethodEntry::None;\n-}\n-\n@@ -112,5 +107,0 @@\n-inline ZNMethodEntry ZPhantomCleanOopClosure::nmethod_entry() const {\n-  ShouldNotReachHere();\n-  return ZNMethodEntry::None;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n@@ -751,0 +752,13 @@\n+void ZPageAllocator::free_pages(const ZArray<ZPage*>* pages, bool reclaimed) {\n+  ZLocker<ZLock> locker(&_lock);\n+\n+  \/\/ Free pages\n+  ZArrayIterator<ZPage*> iter(pages);\n+  for (ZPage* page; iter.next(&page);) {\n+    free_page_inner(page, reclaimed);\n+  }\n+\n+  \/\/ Try satisfy stalled allocations\n+  satisfy_stalled();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zArray.hpp\"\n@@ -127,0 +128,1 @@\n+  void free_pages(const ZArray<ZPage*>* pages, bool reclaimed);\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"prims\/jvmtiTagMap.hpp\"\n@@ -41,0 +42,1 @@\n+static const ZStatSubPhase ZSubPhasePauseRootsJVMTITagMap(\"Pause Roots JVMTITagMap\");\n@@ -70,2 +72,4 @@\n-    \/\/ export weak roots to rehash the JVMTI tag map\n-    ZRelocateRoots::oops_do(&_cl);\n+    \/\/ tag map to rehash the entries with the new oop addresses.\n+    ZStatTimer timer(ZSubPhasePauseRootsJVMTITagMap);\n+    AlwaysTrueClosure always_alive;\n+    JvmtiTagMap::weak_oops_do(&always_alive, &_cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"gc\/z\/zRelocationSetSelector.inline.hpp\"\n@@ -29,1 +31,3 @@\n-#include \"memory\/allocation.hpp\"\n+#include \"gc\/z\/zTask.hpp\"\n+#include \"gc\/z\/zWorkers.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -32,4 +36,15 @@\n-ZRelocationSet::ZRelocationSet() :\n-    _allocator(),\n-    _forwardings(NULL),\n-    _nforwardings(0) {}\n+class ZRelocationSetInstallTask : public ZTask {\n+private:\n+  ZForwardingAllocator* const    _allocator;\n+  ZForwarding**                  _forwardings;\n+  const size_t                   _nforwardings;\n+  ZArrayParallelIterator<ZPage*> _small_iter;\n+  ZArrayParallelIterator<ZPage*> _medium_iter;\n+  volatile size_t                _small_next;\n+  volatile size_t                _medium_next;\n+\n+  void install(ZForwarding* forwarding, volatile size_t* next) {\n+    const size_t index = Atomic::fetch_and_add(next, 1u);\n+    assert(index < _nforwardings, \"Invalid index\");\n+    _forwardings[index] = forwarding;\n+  }\n@@ -37,5 +52,3 @@\n-void ZRelocationSet::populate(ZPage* const* small, size_t nsmall,\n-                              ZPage* const* medium, size_t nmedium,\n-                              size_t forwarding_entries) {\n-  \/\/ Set relocation set length\n-  _nforwardings = nsmall + nmedium;\n+  void install_small(ZForwarding* forwarding) {\n+    install(forwarding, &_small_next);\n+  }\n@@ -43,6 +56,3 @@\n-  \/\/ Initialize forwarding allocator to have room for the\n-  \/\/ relocation set, all forwardings, and all forwarding entries.\n-  const size_t relocation_set_size = _nforwardings * sizeof(ZForwarding*);\n-  const size_t forwardings_size = _nforwardings * sizeof(ZForwarding);\n-  const size_t forwarding_entries_size = forwarding_entries * sizeof(ZForwardingEntry);\n-  _allocator.reset(relocation_set_size + forwardings_size + forwarding_entries_size);\n+  void install_medium(ZForwarding* forwarding) {\n+    install(forwarding, &_medium_next);\n+  }\n@@ -50,2 +60,10 @@\n-  \/\/ Allocate relocation set\n-  _forwardings = new (_allocator.alloc(relocation_set_size)) ZForwarding*[_nforwardings];\n+public:\n+  ZRelocationSetInstallTask(ZForwardingAllocator* allocator, const ZRelocationSetSelector* selector) :\n+      ZTask(\"ZRelocationSetInstallTask\"),\n+      _allocator(allocator),\n+      _forwardings(NULL),\n+      _nforwardings(selector->small()->length() + selector->medium()->length()),\n+      _small_iter(selector->small()),\n+      _medium_iter(selector->medium()),\n+      _small_next(selector->medium()->length()),\n+      _medium_next(0) {\n@@ -53,2 +71,6 @@\n-  \/\/ Populate relocation set array\n-  size_t j = 0;\n+    \/\/ Reset the allocator to have room for the relocation\n+    \/\/ set, all forwardings, and all forwarding entries.\n+    const size_t relocation_set_size = _nforwardings * sizeof(ZForwarding*);\n+    const size_t forwardings_size = _nforwardings * sizeof(ZForwarding);\n+    const size_t forwarding_entries_size = selector->forwarding_entries() * sizeof(ZForwardingEntry);\n+    _allocator->reset(relocation_set_size + forwardings_size + forwarding_entries_size);\n@@ -56,3 +78,2 @@\n-  \/\/ Populate medium pages\n-  for (size_t i = 0; i < nmedium; i++) {\n-    _forwardings[j++] = ZForwarding::alloc(&_allocator, medium[i]);\n+    \/\/ Allocate relocation set\n+    _forwardings = new (_allocator->alloc(relocation_set_size)) ZForwarding*[_nforwardings];\n@@ -61,3 +82,16 @@\n-  \/\/ Populate small pages\n-  for (size_t i = 0; i < nsmall; i++) {\n-    _forwardings[j++] = ZForwarding::alloc(&_allocator, small[i]);\n+  ~ZRelocationSetInstallTask() {\n+    assert(_allocator->is_full(), \"Should be full\");\n+  }\n+\n+  virtual void work() {\n+    \/\/ Allocate and install forwardings for small pages\n+    for (ZPage* page; _small_iter.next(&page);) {\n+      ZForwarding* const forwarding = ZForwarding::alloc(_allocator, page);\n+      install_small(forwarding);\n+    }\n+\n+    \/\/ Allocate and install forwardings for medium pages\n+    for (ZPage* page; _medium_iter.next(&page);) {\n+      ZForwarding* const forwarding = ZForwarding::alloc(_allocator, page);\n+      install_medium(forwarding);\n+    }\n@@ -66,1 +100,22 @@\n-  assert(_allocator.is_full(), \"Should be full\");\n+  ZForwarding** forwardings() const {\n+    return _forwardings;\n+  }\n+\n+  size_t nforwardings() const {\n+    return _nforwardings;\n+  }\n+};\n+\n+ZRelocationSet::ZRelocationSet(ZWorkers* workers) :\n+    _workers(workers),\n+    _allocator(),\n+    _forwardings(NULL),\n+    _nforwardings(0) {}\n+\n+void ZRelocationSet::install(const ZRelocationSetSelector* selector) {\n+  \/\/ Install relocation set\n+  ZRelocationSetInstallTask task(&_allocator, selector);\n+  _workers->run_concurrent(&task);\n+\n+  _forwardings = task.forwardings();\n+  _nforwardings = task.nforwardings();\n@@ -69,1 +124,1 @@\n-  ZStatRelocation::set_at_populate_relocation_set(_allocator.size());\n+  ZStatRelocation::set_at_install_relocation_set(_allocator.size());\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":83,"deletions":28,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"memory\/allocation.hpp\"\n@@ -32,1 +31,2 @@\n-class ZPage;\n+class ZRelocationSetSelector;\n+class ZWorkers;\n@@ -38,0 +38,1 @@\n+  ZWorkers*            _workers;\n@@ -43,1 +44,1 @@\n-  ZRelocationSet();\n+  ZRelocationSet(ZWorkers* workers);\n@@ -45,3 +46,1 @@\n-  void populate(ZPage* const* small, size_t nsmall,\n-                ZPage* const* medium, size_t nmedium,\n-                size_t forwarding_entries);\n+  void install(const ZRelocationSetSelector* selector);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/z\/zRelocationSet.hpp\"\n@@ -55,2 +54,0 @@\n-    _sorted_pages(NULL),\n-    _nselected(0),\n@@ -60,29 +57,0 @@\n-ZRelocationSetSelectorGroup::~ZRelocationSetSelectorGroup() {\n-  FREE_C_HEAP_ARRAY(ZPage*, _sorted_pages);\n-}\n-\n-void ZRelocationSetSelectorGroup::register_live_page(ZPage* page) {\n-  const uint8_t type = page->type();\n-  const size_t size = page->size();\n-  const size_t live = page->live_bytes();\n-  const size_t garbage = size - live;\n-\n-  if (garbage > _fragmentation_limit) {\n-    _registered_pages.append(page);\n-  }\n-\n-  _stats._npages++;\n-  _stats._total += size;\n-  _stats._live += live;\n-  _stats._garbage += garbage;\n-}\n-\n-void ZRelocationSetSelectorGroup::register_garbage_page(ZPage* page) {\n-  const size_t size = page->size();\n-\n-  _stats._npages++;\n-  _stats._total += size;\n-  _stats._garbage += size;\n-  _stats._empty += size;\n-}\n-\n@@ -105,1 +73,0 @@\n-  const size_t npages = _registered_pages.length();\n@@ -108,6 +75,1 @@\n-  size_t partitions[npartitions];\n-\n-  \/\/ Allocate destination array\n-  assert(_sorted_pages == NULL, \"Already initialized\");\n-  _sorted_pages = NEW_C_HEAP_ARRAY(ZPage*, npages, mtGC);\n-  debug_only(memset(_sorted_pages, 0, npages * sizeof(ZPage*)));\n+  int partitions[npartitions] = { \/* zero initialize *\/ };\n@@ -116,1 +78,0 @@\n-  memset(partitions, 0, sizeof(partitions));\n@@ -124,1 +85,1 @@\n-  size_t finger = 0;\n+  int finger = 0;\n@@ -126,1 +87,1 @@\n-    const size_t slots = partitions[i];\n+    const int slots = partitions[i];\n@@ -131,0 +92,4 @@\n+  \/\/ Allocate destination array\n+  const int npages = _registered_pages.length();\n+  ZArray<ZPage*> sorted_pages(npages, npages, NULL);\n+\n@@ -135,3 +100,3 @@\n-    const size_t finger = partitions[index]++;\n-    assert(_sorted_pages[finger] == NULL, \"Invalid finger\");\n-    _sorted_pages[finger] = page;\n+    const int finger = partitions[index]++;\n+    assert(sorted_pages.at(finger) == NULL, \"Invalid finger\");\n+    sorted_pages.at_put(finger, page);\n@@ -139,0 +104,2 @@\n+\n+  _registered_pages.swap(&sorted_pages);\n@@ -145,3 +112,3 @@\n-  const size_t npages = _registered_pages.length();\n-  size_t selected_from = 0;\n-  size_t selected_to = 0;\n+  const int npages = _registered_pages.length();\n+  int selected_from = 0;\n+  int selected_to = 0;\n@@ -154,1 +121,1 @@\n-  for (size_t from = 1; from <= npages; from++) {\n+  for (int from = 1; from <= npages; from++) {\n@@ -156,1 +123,1 @@\n-    ZPage* const page = _sorted_pages[from - 1];\n+    ZPage* const page = _registered_pages.at(from - 1);\n@@ -164,1 +131,1 @@\n-    const size_t to = ceil((double)(from_live_bytes) \/ (double)(_page_size - _object_size_limit));\n+    const int to = ceil((double)(from_live_bytes) \/ (double)(_page_size - _object_size_limit));\n@@ -170,2 +137,2 @@\n-    const size_t diff_from = from - selected_from;\n-    const size_t diff_to = to - selected_to;\n+    const int diff_from = from - selected_from;\n+    const int diff_to = to - selected_to;\n@@ -179,1 +146,1 @@\n-    log_trace(gc, reloc)(\"Candidate Relocation Set (%s Pages): \" SIZE_FORMAT \"->\" SIZE_FORMAT \", \"\n+    log_trace(gc, reloc)(\"Candidate Relocation Set (%s Pages): %d->%d, \"\n@@ -186,1 +153,1 @@\n-  _nselected = selected_from;\n+  _registered_pages.trunc_to(selected_from);\n@@ -193,4 +160,2 @@\n-  log_trace(gc, reloc)(\"Relocation Set (%s Pages): \" SIZE_FORMAT \"->\" SIZE_FORMAT \", \"\n-                       SIZE_FORMAT \" skipped, \" SIZE_FORMAT \" forwarding entries\",\n-                       _name, selected_from, selected_to, npages - selected_from,\n-                       selected_forwarding_entries);\n+  log_trace(gc, reloc)(\"Relocation Set (%s Pages): %d->%d, %d skipped, \" SIZE_FORMAT \" forwarding entries\",\n+                       _name, selected_from, selected_to, npages - selected_from, selected_forwarding_entries);\n@@ -218,25 +183,2 @@\n-    _large(\"Large\", ZPageTypeLarge, 0 \/* page_size *\/, 0 \/* object_size_limit *\/) {}\n-\n-void ZRelocationSetSelector::register_live_page(ZPage* page) {\n-  const uint8_t type = page->type();\n-\n-  if (type == ZPageTypeSmall) {\n-    _small.register_live_page(page);\n-  } else if (type == ZPageTypeMedium) {\n-    _medium.register_live_page(page);\n-  } else {\n-    _large.register_live_page(page);\n-  }\n-}\n-\n-void ZRelocationSetSelector::register_garbage_page(ZPage* page) {\n-  const uint8_t type = page->type();\n-\n-  if (type == ZPageTypeSmall) {\n-    _small.register_garbage_page(page);\n-  } else if (type == ZPageTypeMedium) {\n-    _medium.register_garbage_page(page);\n-  } else {\n-    _large.register_garbage_page(page);\n-  }\n-}\n+    _large(\"Large\", ZPageTypeLarge, 0 \/* page_size *\/, 0 \/* object_size_limit *\/),\n+    _garbage_pages() {}\n@@ -244,1 +186,1 @@\n-void ZRelocationSetSelector::select(ZRelocationSet* relocation_set) {\n+void ZRelocationSetSelector::select() {\n@@ -258,5 +200,0 @@\n-  \/\/ Populate relocation set\n-  relocation_set->populate(_small.selected(), _small.nselected(),\n-                           _medium.selected(), _medium.nselected(),\n-                           forwarding_entries());\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.cpp","additions":27,"deletions":90,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-class ZRelocationSet;\n@@ -79,2 +78,0 @@\n-  ZPage**                          _sorted_pages;\n-  size_t                           _nselected;\n@@ -94,1 +91,0 @@\n-  ~ZRelocationSetSelectorGroup();\n@@ -100,2 +96,1 @@\n-  ZPage* const* selected() const;\n-  size_t nselected() const;\n+  const ZArray<ZPage*>* selected() const;\n@@ -112,0 +107,1 @@\n+  ZArray<ZPage*>              _garbage_pages;\n@@ -113,1 +109,0 @@\n-  size_t forwarding_entries() const;\n@@ -124,1 +119,10 @@\n-  void select(ZRelocationSet* relocation_set);\n+\n+  bool should_free_garbage_pages(int bulk) const;\n+  const ZArray<ZPage*>* garbage_pages() const;\n+  void clear_garbage_pages();\n+\n+  void select();\n+\n+  const ZArray<ZPage*>* small() const;\n+  const ZArray<ZPage*>* medium() const;\n+  size_t forwarding_entries() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.hpp","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"gc\/z\/zArray.inline.hpp\"\n+#include \"gc\/z\/zPage.inline.hpp\"\n@@ -69,2 +71,14 @@\n-inline ZPage* const* ZRelocationSetSelectorGroup::selected() const {\n-  return _sorted_pages;\n+inline void ZRelocationSetSelectorGroup::register_live_page(ZPage* page) {\n+  const uint8_t type = page->type();\n+  const size_t size = page->size();\n+  const size_t live = page->live_bytes();\n+  const size_t garbage = size - live;\n+\n+  if (garbage > _fragmentation_limit) {\n+    _registered_pages.append(page);\n+  }\n+\n+  _stats._npages++;\n+  _stats._total += size;\n+  _stats._live += live;\n+  _stats._garbage += garbage;\n@@ -73,2 +87,11 @@\n-inline size_t ZRelocationSetSelectorGroup::nselected() const {\n-  return _nselected;\n+inline void ZRelocationSetSelectorGroup::register_garbage_page(ZPage* page) {\n+  const size_t size = page->size();\n+\n+  _stats._npages++;\n+  _stats._total += size;\n+  _stats._garbage += size;\n+  _stats._empty += size;\n+}\n+\n+inline const ZArray<ZPage*>* ZRelocationSetSelectorGroup::selected() const {\n+  return &_registered_pages;\n@@ -85,2 +108,36 @@\n-inline size_t ZRelocationSetSelector::forwarding_entries() const {\n-  return _small.forwarding_entries() + _medium.forwarding_entries();\n+inline void ZRelocationSetSelector::register_live_page(ZPage* page) {\n+  const uint8_t type = page->type();\n+\n+  if (type == ZPageTypeSmall) {\n+    _small.register_live_page(page);\n+  } else if (type == ZPageTypeMedium) {\n+    _medium.register_live_page(page);\n+  } else {\n+    _large.register_live_page(page);\n+  }\n+}\n+\n+inline void ZRelocationSetSelector::register_garbage_page(ZPage* page) {\n+  const uint8_t type = page->type();\n+\n+  if (type == ZPageTypeSmall) {\n+    _small.register_garbage_page(page);\n+  } else if (type == ZPageTypeMedium) {\n+    _medium.register_garbage_page(page);\n+  } else {\n+    _large.register_garbage_page(page);\n+  }\n+\n+  _garbage_pages.append(page);\n+}\n+\n+inline bool ZRelocationSetSelector::should_free_garbage_pages(int bulk) const {\n+  return _garbage_pages.length() >= bulk && _garbage_pages.is_nonempty();\n+}\n+\n+inline const ZArray<ZPage*>* ZRelocationSetSelector::garbage_pages() const {\n+  return &_garbage_pages;\n+}\n+\n+inline void ZRelocationSetSelector::clear_garbage_pages() {\n+  return _garbage_pages.clear();\n@@ -105,0 +162,12 @@\n+inline const ZArray<ZPage*>* ZRelocationSetSelector::small() const {\n+  return _small.selected();\n+}\n+\n+inline const ZArray<ZPage*>* ZRelocationSetSelector::medium() const {\n+  return _medium.selected();\n+}\n+\n+inline size_t ZRelocationSetSelector::forwarding_entries() const {\n+  return _small.forwarding_entries() + _medium.forwarding_entries();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.inline.hpp","additions":75,"deletions":6,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -31,1 +32,1 @@\n-#include \"prims\/jvmtiExport.hpp\"\n+#include \"prims\/jvmtiTagMap.hpp\"\n@@ -37,1 +38,0 @@\n-static const ZStatSubPhase ZSubPhasePauseRootsJVMTIWeakExport(\"Pause Roots JVMTIWeakExport\");\n@@ -42,1 +42,1 @@\n-static const ZStatSubPhase ZSubPhasePauseWeakRootsJVMTIWeakExport(\"Pause Weak Roots JVMTIWeakExport\");\n+static const ZStatSubPhase ZSubPhasePauseWeakRootsJVMTITagMap(\"Pause Weak Roots JVMTITagMap\");\n@@ -45,7 +45,3 @@\n-template <typename T, void (T::*F)(ZRootsIteratorClosure*)>\n-ZParallelOopsDo<T, F>::ZParallelOopsDo(T* iter) :\n-    _iter(iter),\n-    _completed(false) {}\n-\n-template <typename T, void (T::*F)(ZRootsIteratorClosure*)>\n-void ZParallelOopsDo<T, F>::oops_do(ZRootsIteratorClosure* cl) {\n+template <typename Iterator>\n+template <typename ClosureType>\n+void ZParallelApply<Iterator>::apply(ClosureType* cl) {\n@@ -53,1 +49,1 @@\n-    (_iter->*F)(cl);\n+    _iter.apply(cl);\n@@ -60,7 +56,2 @@\n-template <typename T, void (T::*F)(BoolObjectClosure*, ZRootsIteratorClosure*)>\n-ZSerialWeakOopsDo<T, F>::ZSerialWeakOopsDo(T* iter) :\n-    _iter(iter),\n-    _claimed(false) {}\n-\n-template <typename T, void (T::*F)(BoolObjectClosure*, ZRootsIteratorClosure*)>\n-void ZSerialWeakOopsDo<T, F>::weak_oops_do(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl) {\n+template <typename Iterator>\n+void ZSerialWeakApply<Iterator>::apply(BoolObjectClosure* is_alive, OopClosure* cl) {\n@@ -68,1 +59,1 @@\n-    (_iter->*F)(is_alive, cl);\n+    _iter.apply(is_alive, cl);\n@@ -72,0 +63,13 @@\n+ZStrongOopStorageSetIterator::ZStrongOopStorageSetIterator() :\n+    _iter() {}\n+\n+void ZStrongOopStorageSetIterator::apply(OopClosure* cl) {\n+  ZStatTimer timer(ZSubPhaseConcurrentRootsOopStorageSet);\n+  _iter.oops_do(cl);\n+}\n+\n+void ZStrongCLDsIterator::apply(CLDClosure* cl) {\n+  ZStatTimer timer(ZSubPhaseConcurrentRootsClassLoaderDataGraph);\n+  ClassLoaderDataGraph::always_strong_cld_do(cl);\n+}\n+\n@@ -80,1 +84,8 @@\n-void ZJavaThreadsIterator::threads_do(ThreadClosure* cl) {\n+void ZJavaThreadsIterator::apply(ThreadClosure* cl) {\n+  ZStatTimer timer(ZSubPhaseConcurrentRootsJavaThreads);\n+\n+  \/\/ The resource mark is needed because interpreter oop maps are\n+  \/\/ not reused in concurrent mode. Instead, they are temporary and\n+  \/\/ resource allocated.\n+  ResourceMark                 _rm;\n+\n@@ -86,15 +97,1 @@\n-void ZRelocateRoots::oops_do(OopClosure* cl) {\n-  ZStatTimer timer(ZSubPhasePauseRootsJVMTIWeakExport);\n-  AlwaysTrueClosure always_alive;\n-  JvmtiExport::weak_oops_do(&always_alive, cl);\n-}\n-\n-ZConcurrentRootsIterator::ZConcurrentRootsIterator(int cld_claim) :\n-    _oop_storage_set_iter(),\n-    _java_threads_iter(),\n-    _cld_claim(cld_claim),\n-    _oop_storage_set(this),\n-    _class_loader_data_graph(this),\n-    _java_threads(this),\n-    _code_cache(this) {\n-  ClassLoaderDataGraph::clear_claimed_marks(cld_claim);\n+ZNMethodsIterator::ZNMethodsIterator() {\n@@ -102,1 +99,1 @@\n-    ZNMethodTable::nmethods_do_begin();\n+    ZNMethod::nmethods_do_begin();\n@@ -106,1 +103,1 @@\n-ZConcurrentRootsIterator::~ZConcurrentRootsIterator() {\n+ZNMethodsIterator::~ZNMethodsIterator() {\n@@ -108,1 +105,1 @@\n-    ZNMethodTable::nmethods_do_end();\n+    ZNMethod::nmethods_do_end();\n@@ -112,12 +109,1 @@\n-void ZConcurrentRootsIterator::do_oop_storage_set(ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhaseConcurrentRootsOopStorageSet);\n-  _oop_storage_set_iter.oops_do(cl);\n-}\n-\n-void ZConcurrentRootsIterator::do_class_loader_data_graph(ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhaseConcurrentRootsClassLoaderDataGraph);\n-  CLDToOopClosure cld_cl(cl, _cld_claim);\n-  ClassLoaderDataGraph::always_strong_cld_do(&cld_cl);\n-}\n-\n-void ZConcurrentRootsIterator::do_code_cache(ZRootsIteratorClosure* cl) {\n+void ZNMethodsIterator::apply(NMethodClosure* cl) {\n@@ -125,1 +111,1 @@\n-  ZNMethod::oops_do(cl, cl->nmethod_entry());\n+  ZNMethod::nmethods_do(cl);\n@@ -128,14 +114,3 @@\n-class ZConcurrentRootsIteratorThreadClosure : public ThreadClosure {\n-private:\n-  \/\/ The resource mark is needed because interpreter oop maps are\n-  \/\/ not reused in concurrent mode. Instead, they are temporary and\n-  \/\/ resource allocated.\n-  ResourceMark                 _rm;\n-  ZRootsIteratorClosure* const _cl;\n-\n-public:\n-  ZConcurrentRootsIteratorThreadClosure(ZRootsIteratorClosure* cl) :\n-      _cl(cl) {}\n-\n-  virtual void do_thread(Thread* thread) {\n-    _cl->do_thread(thread);\n+ZConcurrentRootsIterator::ZConcurrentRootsIterator(int cld_claim) {\n+  if (cld_claim != ClassLoaderData::_claim_none) {\n+    ClassLoaderDataGraph::clear_claimed_marks(cld_claim);\n@@ -143,6 +118,0 @@\n-};\n-\n-void ZConcurrentRootsIterator::do_java_threads(ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhaseConcurrentRootsJavaThreads);\n-  ZConcurrentRootsIteratorThreadClosure thread_cl(cl);\n-  _java_threads_iter.threads_do(&thread_cl);\n@@ -151,4 +120,7 @@\n-void ZConcurrentRootsIterator::oops_do(ZRootsIteratorClosure* cl) {\n-  _oop_storage_set.oops_do(cl);\n-  _class_loader_data_graph.oops_do(cl);\n-  _java_threads.oops_do(cl);\n+void ZConcurrentRootsIterator::apply(OopClosure* cl,\n+                                     CLDClosure* cld_cl,\n+                                     ThreadClosure* thread_cl,\n+                                     NMethodClosure* nm_cl) {\n+  _oop_storage_set.apply(cl);\n+  _class_loader_data_graph.apply(cld_cl);\n+  _java_threads.apply(thread_cl);\n@@ -156,1 +128,1 @@\n-    _code_cache.oops_do(cl);\n+    _nmethods.apply(nm_cl);\n@@ -161,1 +133,1 @@\n-    _jvmti_weak_export(this) {\n+    _jvmti_tag_map() {\n@@ -165,3 +137,2 @@\n-void ZWeakRootsIterator::do_jvmti_weak_export(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhasePauseWeakRootsJVMTIWeakExport);\n-  JvmtiExport::weak_oops_do(is_alive, cl);\n+void ZWeakRootsIterator::apply(BoolObjectClosure* is_alive, OopClosure* cl) {\n+  _jvmti_tag_map.apply(is_alive, cl);\n@@ -170,2 +141,3 @@\n-void ZWeakRootsIterator::weak_oops_do(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl) {\n-  _jvmti_weak_export.weak_oops_do(is_alive, cl);\n+void ZJVMTITagMapIterator::apply(BoolObjectClosure* is_alive, OopClosure* cl) {\n+  ZStatTimer timer(ZSubPhasePauseWeakRootsJVMTITagMap);\n+  JvmtiTagMap::weak_oops_do(is_alive, cl);\n@@ -174,4 +146,2 @@\n-void ZWeakRootsIterator::oops_do(ZRootsIteratorClosure* cl) {\n-  AlwaysTrueClosure always_alive;\n-  weak_oops_do(&always_alive, cl);\n-}\n+ZWeakOopStorageSetIterator::ZWeakOopStorageSetIterator() :\n+    _iter() {}\n@@ -179,3 +149,3 @@\n-ZConcurrentWeakRootsIterator::ZConcurrentWeakRootsIterator() :\n-    _oop_storage_set_iter(),\n-    _oop_storage_set(this) {\n+void ZWeakOopStorageSetIterator::apply(OopClosure* cl) {\n+  ZStatTimer timer(ZSubPhaseConcurrentWeakRootsOopStorageSet);\n+  _iter.oops_do(cl);\n@@ -184,2 +154,2 @@\n-void ZConcurrentWeakRootsIterator::report_num_dead() {\n-  _oop_storage_set_iter.report_num_dead();\n+void ZWeakOopStorageSetIterator::report_num_dead() {\n+  _iter.report_num_dead();\n@@ -188,3 +158,2 @@\n-void ZConcurrentWeakRootsIterator::do_oop_storage_set(ZRootsIteratorClosure* cl) {\n-  ZStatTimer timer(ZSubPhaseConcurrentWeakRootsOopStorageSet);\n-  _oop_storage_set_iter.oops_do(cl);\n+void ZConcurrentWeakRootsIterator::report_num_dead() {\n+  _oop_storage_set.iter().report_num_dead();\n@@ -193,2 +162,2 @@\n-void ZConcurrentWeakRootsIterator::oops_do(ZRootsIteratorClosure* cl) {\n-  _oop_storage_set.oops_do(cl);\n+void ZConcurrentWeakRootsIterator::apply(OopClosure* cl) {\n+  _oop_storage_set.apply(cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.cpp","additions":65,"deletions":96,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"classfile\/classLoaderDataGraph.hpp\"\n@@ -29,2 +28,1 @@\n-#include \"gc\/z\/zNMethod.hpp\"\n-#include \"memory\/allocation.hpp\"\n+#include \"logging\/log.hpp\"\n@@ -34,7 +32,2 @@\n-class ZRootsIteratorClosure;\n-\n-typedef OopStorageSetStrongParState<true \/* concurrent *\/, false \/* is_const *\/> ZOopStorageSetStrongIterator;\n-typedef OopStorageSetWeakParState<true \/* concurrent *\/, false \/* is_const *\/> ZOopStorageSetWeakIterator;\n-\n-template <typename T, void (T::*F)(ZRootsIteratorClosure*)>\n-class ZParallelOopsDo {\n+template <typename Iterator>\n+class ZParallelApply {\n@@ -42,1 +35,1 @@\n-  T* const      _iter;\n+  Iterator      _iter;\n@@ -46,2 +39,10 @@\n-  ZParallelOopsDo(T* iter);\n-  void oops_do(ZRootsIteratorClosure* cl);\n+  ZParallelApply() :\n+      _iter(),\n+      _completed(false) {}\n+\n+  template <typename ClosureType>\n+  void apply(ClosureType* cl);\n+\n+  Iterator& iter() {\n+    return _iter;\n+  }\n@@ -50,2 +51,2 @@\n-template <typename T, void (T::*F)(BoolObjectClosure*, ZRootsIteratorClosure*)>\n-class ZSerialWeakOopsDo {\n+template <typename Iterator>\n+class ZSerialWeakApply {\n@@ -53,1 +54,1 @@\n-  T* const      _iter;\n+  Iterator      _iter;\n@@ -57,2 +58,5 @@\n-  ZSerialWeakOopsDo(T* iter);\n-  void weak_oops_do(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl);\n+  ZSerialWeakApply() :\n+      _iter(),\n+      _claimed(false) {}\n+\n+  void apply(BoolObjectClosure* is_alive, OopClosure* cl);\n@@ -61,1 +65,3 @@\n-class ZRootsIteratorClosure : public OopClosure {\n+class ZStrongOopStorageSetIterator {\n+  OopStorageSetStrongParState<true \/* concurrent *\/, false \/* is_const *\/> _iter;\n+\n@@ -63,1 +69,1 @@\n-  virtual void do_thread(Thread* thread) {}\n+  ZStrongOopStorageSetIterator();\n@@ -65,1 +71,6 @@\n-  virtual ZNMethodEntry nmethod_entry() const = 0;\n+  void apply(OopClosure* cl);\n+};\n+\n+class ZStrongCLDsIterator {\n+public:\n+  void apply(CLDClosure* cl);\n@@ -78,1 +89,1 @@\n-  void threads_do(ThreadClosure* cl);\n+  void apply(ThreadClosure* cl);\n@@ -81,1 +92,1 @@\n-class ZRelocateRoots : public AllStatic {\n+class ZNMethodsIterator {\n@@ -83,1 +94,4 @@\n-  static void oops_do(OopClosure* cl);\n+  ZNMethodsIterator();\n+  ~ZNMethodsIterator();\n+\n+  void apply(NMethodClosure* cl);\n@@ -88,13 +102,4 @@\n-  ZOopStorageSetStrongIterator _oop_storage_set_iter;\n-  ZJavaThreadsIterator         _java_threads_iter;\n-  const int                    _cld_claim;\n-\n-  void do_oop_storage_set(ZRootsIteratorClosure* cl);\n-  void do_java_threads(ZRootsIteratorClosure* cl);\n-  void do_class_loader_data_graph(ZRootsIteratorClosure* cl);\n-  void do_code_cache(ZRootsIteratorClosure* cl);\n-\n-  ZParallelOopsDo<ZConcurrentRootsIterator, &ZConcurrentRootsIterator::do_oop_storage_set>         _oop_storage_set;\n-  ZParallelOopsDo<ZConcurrentRootsIterator, &ZConcurrentRootsIterator::do_class_loader_data_graph> _class_loader_data_graph;\n-  ZParallelOopsDo<ZConcurrentRootsIterator, &ZConcurrentRootsIterator::do_java_threads>            _java_threads;\n-  ZParallelOopsDo<ZConcurrentRootsIterator, &ZConcurrentRootsIterator::do_code_cache>              _code_cache;\n+  ZParallelApply<ZStrongOopStorageSetIterator> _oop_storage_set;\n+  ZParallelApply<ZStrongCLDsIterator>          _class_loader_data_graph;\n+  ZParallelApply<ZJavaThreadsIterator>         _java_threads;\n+  ZParallelApply<ZNMethodsIterator>            _nmethods;\n@@ -104,1 +109,0 @@\n-  ~ZConcurrentRootsIterator();\n@@ -106,1 +110,4 @@\n-  void oops_do(ZRootsIteratorClosure* cl);\n+  void apply(OopClosure* cl,\n+             CLDClosure* cld_cl,\n+             ThreadClosure* thread_cl,\n+             NMethodClosure* nm_cl);\n@@ -109,5 +116,3 @@\n-class ZConcurrentRootsIteratorClaimStrong : public ZConcurrentRootsIterator {\n-public:\n-  ZConcurrentRootsIteratorClaimStrong() :\n-      ZConcurrentRootsIterator(ClassLoaderData::_claim_strong) {}\n-};\n+class ZWeakOopStorageSetIterator {\n+private:\n+  OopStorageSetWeakParState<true \/* concurrent *\/, false \/* is_const *\/> _iter;\n@@ -115,1 +120,0 @@\n-class ZConcurrentRootsIteratorClaimOther : public ZConcurrentRootsIterator {\n@@ -117,2 +121,5 @@\n-  ZConcurrentRootsIteratorClaimOther() :\n-      ZConcurrentRootsIterator(ClassLoaderData::_claim_other) {}\n+  ZWeakOopStorageSetIterator();\n+\n+  void apply(OopClosure* cl);\n+\n+  void report_num_dead();\n@@ -121,1 +128,1 @@\n-class ZConcurrentRootsIteratorClaimNone : public ZConcurrentRootsIterator {\n+class ZJVMTITagMapIterator {\n@@ -123,2 +130,1 @@\n-  ZConcurrentRootsIteratorClaimNone() :\n-      ZConcurrentRootsIterator(ClassLoaderData::_claim_none) {}\n+  void apply(BoolObjectClosure* is_alive, OopClosure* cl);\n@@ -129,3 +135,1 @@\n-  void do_jvmti_weak_export(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl);\n-\n-  ZSerialWeakOopsDo<ZWeakRootsIterator, &ZWeakRootsIterator::do_jvmti_weak_export> _jvmti_weak_export;\n+  ZSerialWeakApply<ZJVMTITagMapIterator> _jvmti_tag_map;\n@@ -136,2 +140,1 @@\n-  void weak_oops_do(BoolObjectClosure* is_alive, ZRootsIteratorClosure* cl);\n-  void oops_do(ZRootsIteratorClosure* cl);\n+  void apply(BoolObjectClosure* is_alive, OopClosure* cl);\n@@ -142,5 +145,1 @@\n-  ZOopStorageSetWeakIterator _oop_storage_set_iter;\n-\n-  void do_oop_storage_set(ZRootsIteratorClosure* cl);\n-\n-  ZParallelOopsDo<ZConcurrentWeakRootsIterator, &ZConcurrentWeakRootsIterator::do_oop_storage_set> _oop_storage_set;\n+  ZParallelApply<ZWeakOopStorageSetIterator> _oop_storage_set;\n@@ -149,3 +148,1 @@\n-  ZConcurrentWeakRootsIterator();\n-\n-  void oops_do(ZRootsIteratorClosure* cl);\n+  void apply(OopClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zRootsIterator.hpp","additions":60,"deletions":63,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -1150,1 +1150,1 @@\n-void ZStatRelocation::set_at_populate_relocation_set(size_t forwarding_usage) {\n+void ZStatRelocation::set_at_install_relocation_set(size_t forwarding_usage) {\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -433,1 +433,1 @@\n-  static void set_at_populate_relocation_set(size_t forwarding_usage);\n+  static void set_at_install_relocation_set(size_t forwarding_usage);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    ZNMethod::nmethod_oops_do(nm, &cl);\n+    ZNMethod::nmethod_oops_do_inner(nm, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zNMethod.hpp\"\n@@ -69,1 +70,1 @@\n-class ZVerifyRootClosure : public ZRootsIteratorClosure {\n+class ZVerifyRootClosure : public OopClosure {\n@@ -92,2 +93,0 @@\n-  virtual void do_thread(Thread* thread);\n-\n@@ -97,5 +96,0 @@\n-\n-  virtual ZNMethodEntry nmethod_entry() const {\n-    \/\/ Verification performs its own verification\n-    return ZNMethodEntry::None;\n-  }\n@@ -184,12 +178,0 @@\n-void ZVerifyRootClosure::do_thread(Thread* thread) {\n-  thread->oops_do_no_frames(this, NULL);\n-\n-  JavaThread* const jt = thread->as_Java_thread();\n-  if (!jt->has_last_Java_frame()) {\n-    return;\n-  }\n-\n-  ZVerifyStack verify_stack(this, jt);\n-  verify_stack.verify_frames();\n-}\n-\n@@ -224,4 +206,1 @@\n-template <typename RootsIterator>\n-void ZVerify::roots(bool verify_fixed) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at a safepoint\");\n-  assert(!ZResurrection::is_blocked(), \"Invalid phase\");\n+typedef ClaimingCLDToOopClosure<ClassLoaderData::_claim_none> ZVerifyCLDClosure;\n@@ -229,4 +208,18 @@\n-  if (ZVerifyRoots) {\n-    ZVerifyRootClosure cl(verify_fixed);\n-    RootsIterator iter;\n-    iter.oops_do(&cl);\n+class ZVerifyThreadClosure : public ThreadClosure {\n+private:\n+  ZVerifyRootClosure* const _cl;\n+\n+public:\n+  ZVerifyThreadClosure(ZVerifyRootClosure* cl) :\n+      _cl(cl) {}\n+\n+  virtual void do_thread(Thread* thread) {\n+    thread->oops_do_no_frames(_cl, NULL);\n+\n+    JavaThread* const jt = thread->as_Java_thread();\n+    if (!jt->has_last_Java_frame()) {\n+      return;\n+    }\n+\n+    ZVerifyStack verify_stack(_cl, jt);\n+    verify_stack.verify_frames();\n@@ -234,1 +227,1 @@\n-}\n+};\n@@ -236,3 +229,24 @@\n-void ZVerify::roots_weak() {\n-  roots<ZWeakRootsIterator>(true \/* verify_fixed *\/);\n-}\n+class ZVerifyNMethodClosure : public NMethodClosure {\n+private:\n+  OopClosure* const        _cl;\n+  BarrierSetNMethod* const _bs_nm;\n+  const bool               _verify_fixed;\n+\n+  bool trust_nmethod_state() const {\n+    \/\/ The root iterator will visit non-processed\n+    \/\/ nmethods class unloading is turned off.\n+    return ClassUnloading || _verify_fixed;\n+  }\n+\n+public:\n+  ZVerifyNMethodClosure(OopClosure* cl, bool verify_fixed) :\n+      _cl(cl),\n+      _bs_nm(BarrierSet::barrier_set()->barrier_set_nmethod()),\n+      _verify_fixed(verify_fixed) {}\n+\n+  virtual void do_nmethod(nmethod* nm) {\n+    assert(!trust_nmethod_state() || !_bs_nm->is_armed(nm), \"Should not encounter any armed nmethods\");\n+\n+    ZNMethod::nmethod_oops_do(nm, _cl);\n+  }\n+};\n@@ -241,1 +255,17 @@\n-  roots<ZConcurrentRootsIteratorClaimNone>(verify_fixed);\n+  ZVerifyRootClosure cl(verify_fixed);\n+  ZVerifyCLDClosure cld_cl(&cl);\n+  ZVerifyThreadClosure thread_cl(&cl);\n+  ZVerifyNMethodClosure nm_cl(&cl, verify_fixed);\n+\n+  ZConcurrentRootsIterator iter(ClassLoaderData::_claim_none);\n+  iter.apply(&cl,\n+             &cld_cl,\n+             &thread_cl,\n+             &nm_cl);\n+}\n+\n+void ZVerify::roots_weak() {\n+  AlwaysTrueClosure is_alive;\n+  ZVerifyRootClosure cl(true \/* verify_fixed *\/);\n+  ZWeakRootsIterator iter;\n+  iter.apply(&is_alive, &cl);\n@@ -245,1 +275,3 @@\n-  roots<ZConcurrentWeakRootsIterator>(true \/* verify_fixed *\/);\n+  ZVerifyRootClosure cl(true \/* verify_fixed *\/);\n+  ZConcurrentWeakRootsIterator iter;\n+  iter.apply(&cl);\n@@ -249,4 +281,9 @@\n-  roots_concurrent_strong(verify_concurrent_strong);\n-  if (verify_weaks) {\n-    roots_weak();\n-    roots_concurrent_weak();\n+  assert(SafepointSynchronize::is_at_safepoint(), \"Must be at a safepoint\");\n+  assert(!ZResurrection::is_blocked(), \"Invalid phase\");\n+\n+  if (ZVerifyRoots) {\n+    roots_concurrent_strong(verify_concurrent_strong);\n+    if (verify_weaks) {\n+      roots_weak();\n+      roots_concurrent_weak();\n+    }\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":75,"deletions":38,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -34,3 +34,0 @@\n-  template <typename RootsIterator> static void roots(bool verify_fixed);\n-\n-  static void roots_weak();\n@@ -38,0 +35,1 @@\n+  static void roots_weak();\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    _weak_roots.weak_oops_do(&is_alive, &keep_alive);\n+    _weak_roots.apply(&is_alive, &keep_alive);\n@@ -50,1 +50,1 @@\n-  _workers->run_parallel(&task);\n+  _workers->run_serial(&task);\n@@ -68,1 +68,1 @@\n-    _concurrent_weak_roots.oops_do(&cl);\n+    _concurrent_weak_roots.apply(&cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zWeakRootsProcessor.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1998,0 +1998,8 @@\n+\n+  if (displacement == java_lang_Class::component_mirror_offset() && java_lang_Class::is_instance(obj()) &&\n+      !java_lang_Class::as_Klass(obj())->is_array_klass()) {\n+    \/\/ Class.componentType for non-array classes can transiently contain an int[] that's\n+    \/\/ used for locking so always return null to mimic Class.getComponentType()\n+    return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_NULL_POINTER());\n+  }\n+\n@@ -2223,0 +2231,7 @@\n+  if (displacement == java_lang_Class::component_mirror_offset() && java_lang_Class::is_instance(xobj()) &&\n+      !java_lang_Class::as_Klass(xobj())->is_array_klass()) {\n+    \/\/ Class.componentType for non-array classes can transiently contain an int[] that's\n+    \/\/ used for locking so always return null to mimic Class.getComponentType()\n+    return JVMCIENV->get_jobject(JVMCIENV->get_JavaConstant_NULL_POINTER());\n+  }\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n","filename":"src\/hotspot\/share\/memory\/iterator.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -146,0 +146,6 @@\n+template <int claim>\n+class ClaimingCLDToOopClosure : public CLDToOopClosure {\n+public:\n+  ClaimingCLDToOopClosure(OopClosure* cl) : CLDToOopClosure(cl, claim) {}\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1338,12 +1338,0 @@\n-        private static final int hashN(byte[] a, int off, int len) {\n-            int h = 1;\n-            while (len-- > 0) {\n-                h = 31 * h + a[off++];\n-            }\n-            return h;\n-        }\n-\n-        private static final int hash_append(int hash, byte b) {\n-            return hash * 31 + b;\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -4593,1 +4593,1 @@\n-                      levelStart + \" is out of range 0 to \" +\n+                      objectStart + \" is out of range 0 to \" +\n@@ -4598,2 +4598,2 @@\n-                      levelStart + \" is out of range 0 to \" +\n-                      (objects.length - objectStart));\n+                      count + \" is less than zero, or objectStart + count\" +\n+                      \" is beyond objects length \" + objects.length);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/icu\/text\/BidiBase.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -210,1 +210,1 @@\n- * <a href=\"..\/..\/java\/awt\/doc-files\/FocusSpec.html\">Focus Specification<\/a>\n+ * <a href=\"doc-files\/FocusSpec.html\">Focus Specification<\/a>\n@@ -7654,1 +7654,1 @@\n-     *<a href=\"..\/..\/java\/awt\/doc-files\/FocusSpec.html\">Focus Specification<\/a>\n+     *<a href=\"doc-files\/FocusSpec.html\">Focus Specification<\/a>\n@@ -7722,1 +7722,1 @@\n-     *<a href=\"..\/..\/java\/awt\/doc-files\/FocusSpec.html\">Focus Specification<\/a>\n+     *<a href=\"doc-files\/FocusSpec.html\">Focus Specification<\/a>\n@@ -7889,1 +7889,1 @@\n-     *<a href=\"..\/..\/java\/awt\/doc-files\/FocusSpec.html\">Focus Specification<\/a>\n+     *<a href=\"doc-files\/FocusSpec.html\">Focus Specification<\/a>\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Component.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n- * <a href=\"..\/..\/java\/awt\/doc-files\/FocusSpec.html\">Focus Specification<\/a>\n+ * <a href=\"doc-files\/FocusSpec.html\">Focus Specification<\/a>\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Container.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n- * <a href=\"..\/..\/java\/awt\/doc-files\/FocusSpec.html\">Focus Specification<\/a>\n+ * <a href=\"doc-files\/FocusSpec.html\">Focus Specification<\/a>\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/DefaultFocusTraversalPolicy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * <a href=\"..\/..\/java\/awt\/doc-files\/FocusSpec.html\">Focus Specification<\/a>\n+ * <a href=\"doc-files\/FocusSpec.html\">Focus Specification<\/a>\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/DefaultKeyboardFocusManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n- * <a href=\"..\/..\/java\/awt\/doc-files\/FocusSpec.html\">Focus Specification<\/a>\n+ * <a href=\"doc-files\/FocusSpec.html\">Focus Specification<\/a>\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/FocusTraversalPolicy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n- * <a href=\"..\/..\/java\/awt\/doc-files\/FocusSpec.html\">Focus Specification<\/a>\n+ * <a href=\"doc-files\/FocusSpec.html\">Focus Specification<\/a>\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/KeyboardFocusManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-<a href=\"..\/Toolkit.html#getDesktopProperty(java.lang.String)\">\n-<code>Toolkit.getDesktopProperty<\/code><\/a> method.\n+{@link java.awt.Toolkit#getDesktopProperty(java.lang.String)\n+Toolkit.getDesktopProperty} method.\n@@ -89,1 +89,1 @@\n-<a href=\"..\/Graphics2D.html\"> <code>Graphics2D<\/code><\/a> methods.\n+{@link java.awt.Graphics2D Graphics2D} methods.\n@@ -91,1 +91,1 @@\n-<a href=\"..\/..\/..\/javax\/swing\/JComponent.html\"> Swing components<\/a> which\n+{@link javax.swing.JComponent Swing components} which\n@@ -100,3 +100,2 @@\n-The return value is a\n-<a href=\"..\/..\/util\/Map.html\"> Map<\/a> of\n-<a href=\"..\/RenderingHints.html\"> <code>RenderingHints<\/code><\/a> which\n+The return value is a {@link java.util.Map Map} of\n+{@link java.awt.RenderingHints RenderingHints} which\n@@ -119,2 +118,1 @@\n-using a <a href=\"..\/..\/beans\/PropertyChangeListener.html\">\n-<code>PropertyChangeListener<\/code><\/a> :\n+using a {@link java.beans.PropertyChangeListener PropertyChangeListener}:\n@@ -137,1 +135,1 @@\n-<a href=\"..\/font\/FontRenderContext.html\"> <code>FontRenderContext<\/code><\/a>\n+{@link java.awt.font.FontRenderContext FontRenderContext}\n@@ -140,1 +138,1 @@\n-A <a href=\"..\/FontMetrics.html\"> <code>FontMetrics<\/code><\/a>\n+A {@link java.awt.FontMetrics FontMetrics}\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/doc-files\/DesktopProperties.html","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -75,1 +75,1 @@\n-TIFF images are read by an <a href=\"..\/..\/ImageReader.html\">ImageReader<\/a>\n+TIFF images are read by an {@link javax.imageio.ImageReader ImageReader}\n@@ -77,1 +77,1 @@\n-<a href=\"..\/..\/plugins\/tiff\/TIFFImageReadParam.html\">TIFFImageReadParam<\/a>.\n+{@link javax.imageio.plugins.tiff.TIFFImageReadParam TIFFImageReadParam}.\n@@ -93,1 +93,1 @@\n-user-supplied <a href=\"..\/..\/ImageTypeSpecifier.html\">ImageTypeSpecifier<\/a>,\n+user-supplied {@link javax.imageio.ImageTypeSpecifier ImageTypeSpecifier},\n@@ -161,2 +161,2 @@\n-(<a href=\"..\/..\/plugins\/tiff\/BaselineTIFFTagSet.html\">\n-BaselineTIFFTagSet<\/a>.TAG_ICC_PROFILE, tag number 34675),\n+({@link javax.imageio.plugins.tiff.BaselineTIFFTagSet BaselineTIFFTagSet}.\n+TAG_ICC_PROFILE, tag number 34675),\n@@ -177,4 +177,2 @@\n-<li>Create an <a href=\"..\/..\/..\/..\/java\/awt\/color\/ICC_ColorSpace.html\">\n-ICC_ColorSpace<\/a> from an\n-<a href=\"..\/..\/..\/..\/java\/awt\/color\/ICC_Profile.html\">\n-ICC_Profile<\/a> created from the ICC profile field data\n+<li>Create an {@link java.awt.color.ICC_ColorSpace ICC_ColorSpace} from an\n+{@link java.awt.color.ICC_Profile ICC_Profile} created from the ICC profile field data\n@@ -185,1 +183,1 @@\n-<li>Create a compatible <a href=\"..\/..\/ImageReadParam.html\">ImageReadParam<\/a>\n+<li>Create a compatible {@link javax.imageio.ImageReadParam ImageReadParam}\n@@ -209,1 +207,1 @@\n-informed of which <a href=\"..\/..\/plugins\/tiff\/TIFFTag.html\">TIFFTag<\/a>s to\n+informed of which {@link javax.imageio.plugins.tiff.TIFFTag TIFFTag}s to\n@@ -224,1 +222,1 @@\n-<p>Use of a <a href=\"..\/..\/plugins\/tiff\/TIFFDirectory.html\">TIFFDirectory<\/a>\n+<p>Use of a {@link javax.imageio.plugins.tiff.TIFFDirectory TIFFDirectory}\n@@ -484,1 +482,1 @@\n-TIFF images are written by a <a href=\"..\/..\/ImageWriter.html\">ImageWriter<\/a> which may be\n+TIFF images are written by a {@link javax.imageio.ImageWriter ImageWriter} which may be\n@@ -486,1 +484,1 @@\n-<a href=\"..\/..\/ImageWriteParam.html\">ImageWriteParam<\/a>.  For an <code>ImageWriteParam<\/code> returned\n+{@link javax.imageio.ImageWriteParam ImageWriteParam}.  For an <code>ImageWriteParam<\/code> returned\n@@ -634,1 +632,1 @@\n-<a href=\"..\/IIOMetadata.html\">IIOMetadata<\/a> instance supplied to the writer,\n+{@link javax.imageio.metadata.IIOMetadata IIOMetadata} instance supplied to the writer,\n@@ -636,1 +634,1 @@\n-<li>the <a href=\"..\/..\/..\/..\/java\/awt\/color\/ColorSpace.html\">ColorSpace<\/a>\n+<li>the {@link java.awt.color.ColorSpace ColorSpace}\n@@ -751,1 +749,1 @@\n-instance of <a href=\"..\/..\/plugins\/tiff\/TIFFField.html\">TIFFField<\/a>. For each\n+instance of {@link javax.imageio.plugins.tiff.TIFFField TIFFField}. For each\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/metadata\/doc-files\/tiff_metadata.html","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -159,3 +159,3 @@\n- * See <a href=\"..\/..\/java\/lang\/package-summary.html#charenc\">character\n- * encodings<\/a> for more information on the character encodings supported on\n- * the Java platform.\n+ * See <a href=\"..\/..\/..\/java.base\/java\/lang\/package-summary.html#charenc\">\n+ * character encodings<\/a> for more information on the character encodings\n+ * supported on the Java platform.\n","filename":"src\/java.desktop\/share\/classes\/javax\/print\/DocFlavor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -407,0 +407,8 @@\n+        if (obj instanceof Class && field.getName().equals(\"componentType\")) {\n+            Class<?> clazz = (Class<?>) obj;\n+            if (!clazz.isArray()) {\n+                \/\/ Class.componentType for non-array classes can transiently contain an int[] that's\n+                \/\/ used for locking so always return null to mimic Class.getComponentType()\n+                return JavaConstant.NULL_POINTER;\n+            }\n+        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotJDKReflection.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -839,0 +839,1 @@\n+            jvmtiDeallocate(threads);\n@@ -1518,16 +1519,3 @@\n-        if (canSuspendResumeThreadLists()) {\n-            error = commonSuspendList(env, count, threads);\n-            if (error != JVMTI_ERROR_NONE) {\n-                goto err;\n-            }\n-        } else {\n-\n-            int i;\n-\n-            for (i = 0; i < count; i++) {\n-                error = commonSuspend(env, threads[i], JNI_FALSE);\n-\n-                if (error != JVMTI_ERROR_NONE) {\n-                    goto err;\n-                }\n-            }\n+        error = commonSuspendList(env, count, threads);\n+        if (error != JVMTI_ERROR_NONE) {\n+            goto err;\n@@ -1552,1 +1540,2 @@\n-    err: ;\n+    err:\n+        jvmtiDeallocate(threads);\n@@ -1591,6 +1580,1 @@\n-    if (canSuspendResumeThreadLists()) {\n-        error = commonResumeList(env);\n-    } else {\n-        error = enumerateOverThreadList(env, &runningThreads,\n-                                        resumeHelper, NULL);\n-    }\n+    error = commonResumeList(env);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":8,"deletions":24,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -702,1 +702,1 @@\n-    error = FUNC_PTR(gdata->jvmti,GetMethodDeclaringClass)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodDeclaringClass)\n@@ -707,1 +707,1 @@\n-\/* Returns a local ref to the declaring class for a method, or NULL. *\/\n+\/* Returns the start and end locations of the specified method. *\/\n@@ -730,1 +730,1 @@\n-    error = FUNC_PTR(gdata->jvmti,GetMethodName)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,GetMethodName)\n@@ -965,10 +965,0 @@\n-jboolean\n-canSuspendResumeThreadLists(void)\n-{\n-    jvmtiError error;\n-    jvmtiCapabilities cap;\n-\n-    error = jvmtiGetCapabilities(&cap);\n-    return (error == JVMTI_ERROR_NONE && cap.can_suspend);\n-}\n-\n@@ -1022,1 +1012,1 @@\n-        error = FUNC_PTR(gdata->jvmti,RawMonitorEnter)\n+        error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorEnter)\n@@ -1041,1 +1031,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorExit)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorExit)\n@@ -1053,1 +1043,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorWait)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorWait)\n@@ -1098,1 +1088,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorWait)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorWait)\n@@ -1116,1 +1106,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorNotify)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorNotify)\n@@ -1129,1 +1119,1 @@\n-    error = FUNC_PTR(gdata->jvmti,RawMonitorNotifyAll)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,RawMonitorNotifyAll)\n@@ -1143,1 +1133,1 @@\n-    error = FUNC_PTR(gdata->jvmti,CreateRawMonitor)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,CreateRawMonitor)\n@@ -1156,1 +1146,1 @@\n-    error = FUNC_PTR(gdata->jvmti,DestroyRawMonitor)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,DestroyRawMonitor)\n@@ -1215,1 +1205,1 @@\n-    error = FUNC_PTR(gdata->jvmti,GetClassSignature)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,GetClassSignature)\n@@ -1787,1 +1777,1 @@\n-    error = FUNC_PTR(gdata->jvmti,Allocate)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,Allocate)\n@@ -1802,1 +1792,1 @@\n-    error = FUNC_PTR(gdata->jvmti,Deallocate)\n+    error = JVMTI_FUNC_PTR(gdata->jvmti,Deallocate)\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":14,"deletions":24,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -340,1 +340,0 @@\n-jboolean canSuspendResumeThreadLists(void);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @modules jdk.internal.vm.compiler\n@@ -44,0 +45,17 @@\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires vm.jvmci & vm.compMode == \"Xmixed\"\n+ * @library \/test\/lib \/\n+ * @library ..\/common\/patches\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.org.objectweb.asm.tree\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ *\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/IsCompilableTest.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255400\n+ * @summary C2 failures after JDK-8255000\n+ * @requires vm.gc.Shenandoah\n+ * @modules java.base\/jdk.internal.misc:+open\n+ *\n+ * @run main\/othervm -XX:-UseOnStackReplacement -XX:-BackgroundCompilation -XX:-TieredCompilation -XX:+UseShenandoahGC TestBarrierExpansionDeadMemPhi\n+ *\n+ *\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import java.util.Arrays;\n+import java.lang.reflect.Field;\n+\n+public class TestBarrierExpansionDeadMemPhi {\n+\n+    static final jdk.internal.misc.Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    static final long F_OFFSET;\n+\n+    static class A {\n+        int f;\n+    }\n+\n+    static {\n+        try {\n+            Field fField = A.class.getDeclaredField(\"f\");\n+            F_OFFSET = UNSAFE.objectFieldOffset(fField);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static int test(Object[] array) {\n+        int f = 0;\n+        for (int i = 0; i < 100; i++) {\n+            f += UNSAFE.getInt(array[i], F_OFFSET);\n+        }\n+        return f;\n+    }\n+\n+    static public void main(String[] args) {\n+        Object[] array = new Object[100];\n+        Arrays.fill(array, new A());\n+\n+        for (int i = 0; i < 20000; i++) {\n+            test(array);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestBarrierExpansionDeadMemPhi.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+ * @modules jdk.internal.vm.compiler\n","filename":"test\/hotspot\/jtreg\/runtime\/InvocationTests\/invocationGraalTests.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n- * @requires ((vm.compMode == \"Xmixed\") & vm.jvmci)\n+ * @requires ((vm.compMode == \"Xmixed\") & vm.graal.enabled)\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1249,0 +1249,5 @@\n+            if (!e.getMessage().equals(\n+                            \"Value levelStart -1 is out of range 0 to \" + (llen - 1))) {\n+                errorHandling(\"reorderVisually() should throw an IAE\" +\n+                        \" mentioning levelStart is beyond the levels range. Message: \" + e.getMessage());\n+            }\n@@ -1261,0 +1266,5 @@\n+            if (!e.getMessage().equals(\n+                    \"Value levelStart \" + llen + \" is out of range 0 to \" + (llen - 1))) {\n+                errorHandling(\"reorderVisually() should throw an IAE\" +\n+                        \" mentioning levelStart is beyond the levels range. Message: \" + e.getMessage());\n+            }\n@@ -1281,0 +1291,5 @@\n+            if (!e.getMessage().equals(\n+                    \"Value objectStart -1 is out of range 0 to \" + (olen - 1))) {\n+                errorHandling(\"reorderVisually() should throw an IAE\" +\n+                        \" mentioning objectStart is beyond the objects range. Message: \" + e.getMessage());\n+            }\n@@ -1293,0 +1308,5 @@\n+            if (!e.getMessage().equals(\n+                    \"Value objectStart 6 is out of range 0 to \" + (olen - 1))) {\n+                errorHandling(\"reorderVisually() should throw an IAE\" +\n+                        \" mentioning objectStart is beyond the objects range. Message: \" + e.getMessage());\n+            }\n@@ -1301,0 +1321,6 @@\n+            if (!e.getMessage().equals(\n+                    \"Value count -1 is less than zero, or objectStart + count \" +\n+                    \"is beyond objects length \" + olen)) {\n+                errorHandling(\"reorderVisually() should throw an IAE\" +\n+                        \" mentioning objectStart\/count is beyond the objects range. Message: \" + e.getMessage());\n+            }\n@@ -1313,0 +1339,6 @@\n+            if (!e.getMessage().equals(\n+                    \"Value count \" + (count + 1) + \" is less than zero, or objectStart + count \" +\n+                    \"is beyond objects length \" + olen)) {\n+                errorHandling(\"reorderVisually() should throw an IAE\" +\n+                        \" mentioning objectStart\/count is beyond the objects range. Message: \" + e.getMessage());\n+            }\n","filename":"test\/jdk\/java\/text\/Bidi\/BidiConformance.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"}]}