{"files":[{"patch":"@@ -84,1 +84,1 @@\n-      $$(call FindFiles, $$($1_SOURCE_DIRS), $$($1_PREFIX)*.c $$($1_PREFIX)*.cpp)\n+      $$(call FindFiles, $$($1_SOURCE_DIRS), $$($1_PREFIX)*.c $$($1_PREFIX)*.cpp $$($1_PREFIX)*.m)\n","filename":"make\/common\/TestFilesCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,0 @@\n-JVM_GetInterfaceVersion\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,0 @@\n-            -framework JavaNativeFoundation \\\n@@ -116,0 +115,1 @@\n+            -framework Foundation \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,0 @@\n-          -framework JavaNativeFoundation \\\n@@ -131,1 +130,0 @@\n-          -framework JavaNativeFoundation \\\n","filename":"make\/modules\/java.desktop\/Lib.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,0 @@\n-        -framework JavaNativeFoundation \\\n@@ -772,2 +771,1 @@\n-        -framework Metal \\\n-        -framework JavaNativeFoundation\n+        -framework Metal\n@@ -873,1 +871,0 @@\n-          -framework JavaNativeFoundation \\\n@@ -934,1 +931,0 @@\n-          -framework JavaNativeFoundation \\\n","filename":"make\/modules\/java.desktop\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,2 +83,2 @@\n-        LIBS := -framework JavaNativeFoundation -framework Cocoa \\\n-            -framework SystemConfiguration -framework Kerberos, \\\n+        LIBS := -framework Cocoa -framework SystemConfiguration \\\n+            -framework Kerberos, \\\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    LIBS_macosx := -framework Foundation -framework JavaNativeFoundation \\\n+    LIBS_macosx := -framework Foundation \\\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,0 @@\n-  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libTestMainKeyWindow := -ObjC\n@@ -82,1 +81,1 @@\n-      -framework Cocoa -framework JavaNativeFoundation\n+      -framework Cocoa\n@@ -84,0 +83,2 @@\n+  BUILD_JDK_JTREG_LIBRARIES_LIBS_libTestDynamicStore := \\\n+      -framework Cocoa -framework SystemConfiguration\n@@ -85,1 +86,1 @@\n-  BUILD_JDK_JTREG_EXCLUDE += libTestMainKeyWindow.c\n+  BUILD_JDK_JTREG_EXCLUDE += libTestMainKeyWindow.m\n@@ -87,0 +88,1 @@\n+  BUILD_JDK_JTREG_EXCLUDE += libTestDynamicStore.m\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4702,0 +4702,17 @@\n+static bool should_warn_invalid_processor_id() {\n+  if (os::processor_count() == 1) {\n+    \/\/ Don't warn if we only have one processor\n+    return false;\n+  }\n+\n+  static volatile int warn_once = 1;\n+\n+  if (Atomic::load(&warn_once) == 0 ||\n+      Atomic::xchg(&warn_once, 0) == 0) {\n+    \/\/ Don't warn more than once\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -4705,5 +4722,17 @@\n-#ifndef PRODUCT\n-  if (UseDebuggerErgo1 && id >= _processor_count) {\n-    \/\/ Some debuggers limit the processor count without limiting\n-    \/\/ the returned processor ids. Fake the processor id.\n-    return 0;\n+  if (id < processor_count()) {\n+    return (uint)id;\n+  }\n+\n+  \/\/ Some environments (e.g. openvz containers and the rr debugger) incorrectly\n+  \/\/ report a processor id that is higher than the number of processors available.\n+  \/\/ This is problematic, for example, when implementing CPU-local data structures,\n+  \/\/ where the processor id is used to index into an array of length processor_count().\n+  \/\/ If this happens we return 0 here. This is is safe since we always have at least\n+  \/\/ one processor, but it's not optimal for performance if we're actually executing\n+  \/\/ in an environment with more than one processor.\n+  if (should_warn_invalid_processor_id()) {\n+    log_warning(os)(\"Invalid processor id reported by the operating system \"\n+                    \"(got processor id %d, valid processor id range is 0-%d)\",\n+                    id, processor_count() - 1);\n+    log_warning(os)(\"Falling back to assuming processor id is 0. \"\n+                    \"This could have a negative impact on performance.\");\n@@ -4711,1 +4740,0 @@\n-#endif\n@@ -4713,2 +4741,1 @@\n-  assert(id >= 0 && id < _processor_count, \"Invalid processor id [%d]\", id);\n-  return (uint)id;\n+  return 0;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -136,1 +136,5 @@\n-  set_end(mr.end());\n+  \/\/ When expanding concurrently with callers of cas_allocate, setting end\n+  \/\/ makes the new space available for allocation by other threads.  So this\n+  \/\/ assignment must follow all other configuration and initialization that\n+  \/\/ might be done for expansion.\n+  Atomic::release_store(end_addr(), mr.end());\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#include \"runtime\/orderAccess.hpp\"\n@@ -357,3 +356,3 @@\n-  \/\/ Ensure the space bounds are updated and made visible to other\n-  \/\/ threads after the other data structures have been resized.\n-  OrderAccess::storestore();\n+  \/\/ The update of the space's end is done by this call.  As that\n+  \/\/ makes the new space available for concurrent allocation, this\n+  \/\/ must be the last step when expanding.\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -347,0 +347,1 @@\n+          range(1, max_uintx)                                               \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2288,1 +2288,1 @@\n-  uint8_t max_depth = 0;\n+  uint16_t max_depth = 0;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -203,1 +203,2 @@\n-  _iterate_discovered_list_id(0U) {\n+  _iterate_discovered_list_id(0U),\n+  _stats() {\n@@ -598,0 +599,6 @@\n+\n+  _stats = ReferenceProcessorStats(discovered[REF_SOFT],\n+                                   discovered[REF_WEAK],\n+                                   discovered[REF_FINAL],\n+                                   discovered[REF_PHANTOM]);\n+\n@@ -605,0 +612,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"gc\/shared\/referencePolicy.hpp\"\n+#include \"gc\/shared\/referenceProcessorStats.hpp\"\n@@ -139,0 +141,2 @@\n+  ReferenceProcessorStats _stats;\n+\n@@ -182,0 +186,2 @@\n+  const ReferenceProcessorStats& reference_process_stats() { return _stats; }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"gc\/shared\/referenceProcessorStats.hpp\"\n+#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n@@ -33,0 +35,1 @@\n+#include \"gc\/shenandoah\/shenandoahReferenceProcessor.hpp\"\n@@ -34,1 +37,0 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n@@ -68,0 +70,1 @@\n+  _tracer->report_gc_reference_stats(_heap->ref_processor()->reference_process_stats());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,14 +59,0 @@\n-\/*\n- * Bump the version number when either of the following happens:\n- *\n- * 1. There is a change in JVM_* functions.\n- *\n- * 2. There is a change in the contract between VM and Java classes.\n- *    For example, if the VM relies on a new private field in Thread\n- *    class.\n- *\/\n-\n-#define JVM_INTERFACE_VERSION 6\n-\n-JNIEXPORT jint JNICALL\n-JVM_GetInterfaceVersion(void);\n@@ -764,74 +750,0 @@\n-\/*\n- * com.sun.dtrace.jsdt support\n- *\/\n-\n-#define JVM_TRACING_DTRACE_VERSION 1\n-\n-\/*\n- * Structure to pass one probe description to JVM\n- *\/\n-typedef struct {\n-    jmethodID method;\n-    jstring   function;\n-    jstring   name;\n-    void*            reserved[4];     \/\/ for future use\n-} JVM_DTraceProbe;\n-\n-\/**\n- * Encapsulates the stability ratings for a DTrace provider field\n- *\/\n-typedef struct {\n-    jint nameStability;\n-    jint dataStability;\n-    jint dependencyClass;\n-} JVM_DTraceInterfaceAttributes;\n-\n-\/*\n- * Structure to pass one provider description to JVM\n- *\/\n-typedef struct {\n-    jstring                       name;\n-    JVM_DTraceProbe*              probes;\n-    jint                          probe_count;\n-    JVM_DTraceInterfaceAttributes providerAttributes;\n-    JVM_DTraceInterfaceAttributes moduleAttributes;\n-    JVM_DTraceInterfaceAttributes functionAttributes;\n-    JVM_DTraceInterfaceAttributes nameAttributes;\n-    JVM_DTraceInterfaceAttributes argsAttributes;\n-    void*                         reserved[4]; \/\/ for future use\n-} JVM_DTraceProvider;\n-\n-\/*\n- * Get the version number the JVM was built with\n- *\/\n-JNIEXPORT jint JNICALL\n-JVM_DTraceGetVersion(JNIEnv* env);\n-\n-\/*\n- * Register new probe with given signature, return global handle\n- *\n- * The version passed in is the version that the library code was\n- * built with.\n- *\/\n-JNIEXPORT jlong JNICALL\n-JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,\n-  jint providers_count, JVM_DTraceProvider* providers);\n-\n-\/*\n- * Check JSDT probe\n- *\/\n-JNIEXPORT jboolean JNICALL\n-JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);\n-\n-\/*\n- * Destroy custom DOF\n- *\/\n-JNIEXPORT void JNICALL\n-JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);\n-\n-\/*\n- * Check to see if DTrace is supported by OS\n- *\/\n-JNIEXPORT jboolean JNICALL\n-JVM_DTraceIsSupported(JNIEnv* env);\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":0,"deletions":88,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -294,0 +294,1 @@\n+  assert(loop->_nest <= SHRT_MAX, \"sanity\");\n@@ -2617,0 +2618,1 @@\n+  assert(depth <= SHRT_MAX, \"sanity\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -614,1 +614,1 @@\n-  uint8_t _nest;                \/\/ Nesting depth\n+  uint16_t _nest;               \/\/ Nesting depth\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n@@ -416,9 +417,11 @@\n-    Node* vec_field_ld = LoadNode::make(gvn,\n-                                        ctrl,\n-                                        mem,\n-                                        vec_adr,\n-                                        vec_adr->bottom_type()->is_ptr(),\n-                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n-                                        T_OBJECT,\n-                                        MemNode::unordered);\n-    vec_field_ld = gvn.transform(vec_field_ld);\n+    Node* vec_field_ld;\n+    {\n+      DecoratorSet decorators = MO_UNORDERED | IN_HEAP;\n+      C2AccessValuePtr addr(vec_adr, vec_adr->bottom_type()->is_ptr());\n+      MergeMemNode* local_mem = MergeMemNode::make(mem);\n+      gvn.record_for_igvn(local_mem);\n+      BarrierSetC2* bs = BarrierSet::barrier_set()->barrier_set_c2();\n+      C2OptAccess access(gvn, ctrl, local_mem, decorators, T_OBJECT, obj, addr);\n+      const Type* type = TypeOopPtr::make_from_klass(field->type()->as_klass());\n+      vec_field_ld = bs->load_at(access, type);\n+    }\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-#include \"utilities\/dtrace.hpp\"\n@@ -231,9 +230,0 @@\n-\n-\/\/ Interface version \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\n-JVM_LEAF(jint, JVM_GetInterfaceVersion())\n-  return JVM_INTERFACE_VERSION;\n-JVM_END\n-\n-\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -995,0 +995,9 @@\n+  \/\/ Check code again because compilation may be finished before Compile_lock is acquired.\n+  if (bci == InvocationEntryBci) {\n+    CompiledMethod* code = mh->code();\n+    if (code != NULL && code->as_nmethod_or_null() != NULL) {\n+      return true;\n+    }\n+  } else if (mh->lookup_osr_nmethod_for(bci, comp_level, false) != NULL) {\n+    return true;\n+  }\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -305,0 +305,3 @@\n+    JVMFlag::printError(verbose,\n+                        \"InitArrayShortSize (\" INTX_FORMAT \") must be \"\n+                        \"a multiple of %d\\n\", value, BytesPerLong);\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -486,0 +486,1 @@\n+  case T_VOID:\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -818,2 +818,2 @@\n-    private void createKeyEntry(String alias, long creationDate, long secKeyRef, long[] secCertificateRefs, byte[][] rawCertData)\n-        throws IOException, NoSuchAlgorithmException, UnrecoverableKeyException {\n+    private void createKeyEntry(String alias, long creationDate, long secKeyRef,\n+                                long[] secCertificateRefs, byte[][] rawCertData) {\n","filename":"src\/java.base\/macosx\/classes\/apple\/security\/KeychainStore.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-\n@@ -32,6 +31,1 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n-\n-static JNF_CLASS_CACHE(jc_KeychainStore, \"apple\/security\/KeychainStore\");\n-static JNF_MEMBER_CACHE(jm_createTrustedCertEntry, jc_KeychainStore, \"createTrustedCertEntry\", \"(Ljava\/lang\/String;JJ[B)V\");\n-static JNF_MEMBER_CACHE(jm_createKeyEntry, jc_KeychainStore, \"createKeyEntry\", \"(Ljava\/lang\/String;JJ[J[[B)V\");\n+#import <Cocoa\/Cocoa.h>\n@@ -293,0 +287,4 @@\n+    jclass jc_KeychainStore = (*env)->FindClass(env, \"apple\/security\/KeychainStore\");\n+    CHECK_NULL(jc_KeychainStore);\n+    jmethodID jm_createKeyEntry = (*env)->GetMethodID(env, jc_KeychainStore, \"createKeyEntry\", \"(Ljava\/lang\/String;JJ[J[[B)V\");\n+    CHECK_NULL(jm_createKeyEntry);\n@@ -362,1 +360,2 @@\n-            JNFCallVoidMethod(env, keyStore, jm_createKeyEntry, alias, creationDate, nativeKeyRef, certRefArray, javaCertArray);\n+            (*env)->CallVoidMethod(env, keyStore, jm_createKeyEntry, alias, creationDate, nativeKeyRef, certRefArray, javaCertArray);\n+            JNU_CHECK_EXCEPTION(env);\n@@ -380,0 +379,5 @@\n+    jclass jc_KeychainStore = (*env)->FindClass(env, \"apple\/security\/KeychainStore\");\n+    CHECK_NULL(jc_KeychainStore);\n+    jmethodID jm_createTrustedCertEntry = (*env)->GetMethodID(\n+            env, jc_KeychainStore, \"createTrustedCertEntry\", \"(Ljava\/lang\/String;JJ[B)V\");\n+    CHECK_NULL(jm_createTrustedCertEntry);\n@@ -405,1 +409,2 @@\n-            JNFCallVoidMethod(env, keyStore, jm_createTrustedCertEntry, alias, nativeRef, creationDate, certData);\n+            (*env)->CallVoidMethod(env, keyStore, jm_createTrustedCertEntry, alias, nativeRef, creationDate, certData);\n+            JNU_CHECK_EXCEPTION(env);\n@@ -503,0 +508,14 @@\n+NSString* JavaStringToNSString(JNIEnv *env, jstring jstr) {\n+     if (jstr == NULL) {\n+         return NULL;\n+     }\n+     jsize len = (*env)->GetStringLength(env, jstr);\n+     const jchar *chars = (*env)->GetStringChars(env, jstr, NULL);\n+     if (chars == NULL) {\n+         return NULL;\n+     }\n+     NSString *result = [NSString stringWithCharacters:(UniChar *)chars length:len];\n+     (*env)->ReleaseStringChars(env, jstr, chars);\n+     return result;\n+}\n+\n@@ -514,1 +533,7 @@\n-JNF_COCOA_ENTER(env);\n+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; \\\n+    @try {\n+        jsize dataSize = (*env)->GetArrayLength(env, rawDataObj);\n+        jbyte *rawData = (*env)->GetByteArrayElements(env, rawDataObj, NULL);\n+        if (rawData == NULL) {\n+            goto errOut;\n+        }\n@@ -516,5 +541,2 @@\n-    jsize dataSize = (*env)->GetArrayLength(env, rawDataObj);\n-    jbyte *rawData = (*env)->GetByteArrayElements(env, rawDataObj, NULL);\n-    if (rawData == NULL) {\n-        goto errOut;\n-    }\n+        CFDataRef cfDataToImport = CFDataCreate(kCFAllocatorDefault, (UInt8 *)rawData, dataSize);\n+        CFArrayRef createdItems = NULL;\n@@ -522,2 +544,2 @@\n-    CFDataRef cfDataToImport = CFDataCreate(kCFAllocatorDefault, (UInt8 *)rawData, dataSize);\n-    CFArrayRef createdItems = NULL;\n+        SecKeychainRef defaultKeychain = NULL;\n+        SecKeychainCopyDefault(&defaultKeychain);\n@@ -525,2 +547,1 @@\n-    SecKeychainRef defaultKeychain = NULL;\n-    SecKeychainCopyDefault(&defaultKeychain);\n+        SecExternalFormat dataFormat = (isCertificate == JNI_TRUE ? kSecFormatX509Cert : kSecFormatWrappedPKCS8);\n@@ -528,1 +549,3 @@\n-    SecExternalFormat dataFormat = (isCertificate == JNI_TRUE ? kSecFormatX509Cert : kSecFormatWrappedPKCS8);\n+        \/\/ Convert the password obj into a CFStringRef that the keychain importer can use for encryption.\n+        SecKeyImportExportParameters paramBlock;\n+        CFStringRef passwordStrRef = NULL;\n@@ -530,3 +553,2 @@\n-    \/\/ Convert the password obj into a CFStringRef that the keychain importer can use for encryption.\n-    SecKeyImportExportParameters paramBlock;\n-    CFStringRef passwordStrRef = NULL;\n+        jsize passwordLen = 0;\n+        jchar *passwordChars = NULL;\n@@ -534,2 +556,2 @@\n-    jsize passwordLen = 0;\n-    jchar *passwordChars = NULL;\n+        if (passwordObj) {\n+            passwordLen = (*env)->GetArrayLength(env, passwordObj);\n@@ -537,8 +559,5 @@\n-    if (passwordObj) {\n-        passwordLen = (*env)->GetArrayLength(env, passwordObj);\n-\n-        if (passwordLen > 0) {\n-            passwordChars = (*env)->GetCharArrayElements(env, passwordObj, NULL);\n-            if (passwordChars == NULL) {\n-                goto errOut;\n-            }\n+            if (passwordLen > 0) {\n+                passwordChars = (*env)->GetCharArrayElements(env, passwordObj, NULL);\n+                if (passwordChars == NULL) {\n+                    goto errOut;\n+                }\n@@ -546,3 +565,4 @@\n-            passwordStrRef = CFStringCreateWithCharactersNoCopy(NULL, passwordChars, passwordLen, kCFAllocatorNull);\n-            if (passwordStrRef == NULL) {\n-                goto errOut;\n+                passwordStrRef = CFStringCreateWithCharactersNoCopy(NULL, passwordChars, passwordLen, kCFAllocatorNull);\n+                if (passwordStrRef == NULL) {\n+                    goto errOut;\n+                }\n@@ -551,1 +571,0 @@\n-    }\n@@ -553,9 +572,15 @@\n-    paramBlock.version = SEC_KEY_IMPORT_EXPORT_PARAMS_VERSION;\n-    \/\/ Note that setting the flags field **requires** you to pass in a password of some kind.  The keychain will not prompt you.\n-    paramBlock.flags = 0;\n-    paramBlock.passphrase = passwordStrRef;\n-    paramBlock.alertTitle = NULL;\n-    paramBlock.alertPrompt = NULL;\n-    paramBlock.accessRef = NULL;\n-    paramBlock.keyUsage = CSSM_KEYUSE_ANY;\n-    paramBlock.keyAttributes = CSSM_KEYATTR_RETURN_DEFAULT;\n+        paramBlock.version = SEC_KEY_IMPORT_EXPORT_PARAMS_VERSION;\n+        \/\/ Note that setting the flags field **requires** you to pass in a password of some kind.  The keychain will not prompt you.\n+        paramBlock.flags = 0;\n+        paramBlock.passphrase = passwordStrRef;\n+        paramBlock.alertTitle = NULL;\n+        paramBlock.alertPrompt = NULL;\n+        paramBlock.accessRef = NULL;\n+        paramBlock.keyUsage = CSSM_KEYUSE_ANY;\n+        paramBlock.keyAttributes = CSSM_KEYATTR_RETURN_DEFAULT;\n+\n+        err = SecKeychainItemImport(cfDataToImport, NULL, &dataFormat, NULL,\n+                                    0, &paramBlock, defaultKeychain, &createdItems);\n+        if (cfDataToImport != NULL) {\n+            CFRelease(cfDataToImport);\n+        }\n@@ -563,5 +588,2 @@\n-    err = SecKeychainItemImport(cfDataToImport, NULL, &dataFormat, NULL,\n-                                0, &paramBlock, defaultKeychain, &createdItems);\n-    if (cfDataToImport != NULL) {\n-        CFRelease(cfDataToImport);\n-    }\n+        if (err == noErr) {\n+            SecKeychainItemRef anItem = (SecKeychainItemRef)CFArrayGetValueAtIndex(createdItems, 0);\n@@ -569,2 +591,4 @@\n-    if (err == noErr) {\n-        SecKeychainItemRef anItem = (SecKeychainItemRef)CFArrayGetValueAtIndex(createdItems, 0);\n+            \/\/ Don't bother labeling keys. They become part of an identity, and are not an accessible part of the keychain.\n+            if (CFGetTypeID(anItem) == SecCertificateGetTypeID()) {\n+                setLabelForItem(JavaStringToNSString(env, alias), anItem);\n+            }\n@@ -572,3 +596,5 @@\n-        \/\/ Don't bother labeling keys. They become part of an identity, and are not an accessible part of the keychain.\n-        if (CFGetTypeID(anItem) == SecCertificateGetTypeID()) {\n-            setLabelForItem(JNFJavaToNSString(env, alias), anItem);\n+            \/\/ Retain the item, since it will be released once when the array holding it gets released.\n+            CFRetain(anItem);\n+            returnValue = ptr_to_jlong(anItem);\n+        } else {\n+            cssmPerror(\"_addItemToKeychain: SecKeychainItemImport\", err);\n@@ -577,10 +603,3 @@\n-        \/\/ Retain the item, since it will be released once when the array holding it gets released.\n-        CFRetain(anItem);\n-        returnValue = ptr_to_jlong(anItem);\n-    } else {\n-        cssmPerror(\"_addItemToKeychain: SecKeychainItemImport\", err);\n-    }\n-\n-    if (createdItems != NULL) {\n-        CFRelease(createdItems);\n-    }\n+        if (createdItems != NULL) {\n+            CFRelease(createdItems);\n+        }\n@@ -588,4 +607,4 @@\n-errOut:\n-    if (rawData) {\n-        (*env)->ReleaseByteArrayElements(env, rawDataObj, rawData, JNI_ABORT);\n-    }\n+    errOut:\n+        if (rawData) {\n+            (*env)->ReleaseByteArrayElements(env, rawDataObj, rawData, JNI_ABORT);\n+        }\n@@ -593,6 +612,11 @@\n-    if (passwordStrRef) CFRelease(passwordStrRef);\n-    if (passwordChars) {\n-        \/\/ clear the password and release\n-        memset(passwordChars, 0, passwordLen);\n-        (*env)->ReleaseCharArrayElements(env, passwordObj, passwordChars,\n-            JNI_ABORT);\n+        if (passwordStrRef) CFRelease(passwordStrRef);\n+        if (passwordChars) {\n+            \/\/ clear the password and release\n+            memset(passwordChars, 0, passwordLen);\n+            (*env)->ReleaseCharArrayElements(env, passwordObj, passwordChars,\n+                JNI_ABORT);\n+        }\n+    } @catch (NSException *e) {\n+        NSLog(@\"%@\", [e callStackSymbols]);\n+    } @finally {\n+        [pool drain];\n@@ -600,3 +624,0 @@\n-\n-JNF_COCOA_EXIT(env);\n-\n","filename":"src\/java.base\/macosx\/native\/libosxsecurity\/KeystoreImpl.m","additions":101,"deletions":80,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -4400,1 +4400,1 @@\n-            System.arraycopy(value, srcPos, dst, dstBegin << coder, length << coder());\n+            System.arraycopy(value, srcPos << coder, dst, dstBegin << coder, length << coder);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -376,3 +376,5 @@\n-     * This String is constructed by calling toString() on the InetAddress\n-     * and concatenating the port number (with a colon). If the address\n-     * is an IPv6 address, the IPv6 literal is enclosed in square brackets.\n+     * This string is constructed by calling {@link InetAddress#toString()}\n+     * on the InetAddress and concatenating the port number (with a colon).\n+     * <p>\n+     * If the address is an IPv6 address, the IPv6 literal is enclosed in\n+     * square brackets, for example: {@code \"localhost\/[0:0:0:0:0:0:0:1]:80\"}.\n@@ -380,1 +382,6 @@\n-     * {@code <unresolved>} is displayed in place of the address literal.\n+     * {@code <unresolved>} is displayed in place of the address literal, for\n+     * example {@code \"foo\/<unresolved>:80\"}.\n+     * <p>\n+     * To retrieve a string representation of the hostname or the address, use\n+     * {@link #getHostString()}, rather than parsing the string returned by this\n+     * {@link #toString()} method.\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetSocketAddress.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -57,8 +57,0 @@\n-    void checkEncoding(byte[] a, int pos, int nlen) throws ZipException {\n-        try {\n-            toString(a, pos, nlen);\n-        } catch(Exception e) {\n-            throw new ZipException(\"invalid CEN header (bad entry name)\");\n-        }\n-    }\n-\n@@ -101,4 +93,0 @@\n-    static String toStringUTF8(byte[] ba, int off, int len) {\n-        return UTF8.toString(ba, off, len);\n-    }\n-\n@@ -113,1 +101,6 @@\n-    int normalizedHash(byte[] a, int off, int len) {\n+    \/\/\n+    \/\/ Does encoding error checking and hashing in a single pass for efficiency.\n+    \/\/ On an error, this function will throw CharacterCodingException while the\n+    \/\/ UTF8ZipCoder override will throw IllegalArgumentException, so we declare\n+    \/\/ throws Exception to keep things simple.\n+    int checkedHash(byte[] a, int off, int len) throws Exception {\n@@ -117,1 +110,14 @@\n-        return normalizedHashDecode(0, a, off, off + len);\n+\n+        int h = 0;\n+        \/\/ cb will be a newly allocated CharBuffer with pos == 0,\n+        \/\/ arrayOffset == 0, backed by an array.\n+        CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, len));\n+        int limit = cb.limit();\n+        char[] decoded = cb.array();\n+        for (int i = 0; i < limit; i++) {\n+            h = 31 * h + decoded[i];\n+        }\n+        if (limit > 0 && decoded[limit - 1] != '\/') {\n+            h = 31 * h + '\/';\n+        }\n+        return h;\n@@ -120,2 +126,2 @@\n-    \/\/ Matching normalized hash code function for Strings\n-    static int normalizedHash(String name) {\n+    \/\/ Hash function equivalent of checkedHash for String inputs\n+    static int hash(String name) {\n@@ -136,23 +142,0 @@\n-    \/\/ Implements normalizedHash by decoding byte[] to char[] and then computing\n-    \/\/ the hash. This is a slow-path used for non-UTF8 charsets and also when\n-    \/\/ aborting the ASCII fast-path in the UTF8 implementation, so {@code h}\n-    \/\/ might be a partially calculated hash code\n-    int normalizedHashDecode(int h, byte[] a, int off, int end) {\n-        try {\n-            \/\/ cb will be a newly allocated CharBuffer with pos == 0,\n-            \/\/ arrayOffset == 0, backed by an array.\n-            CharBuffer cb = decoder().decode(ByteBuffer.wrap(a, off, end - off));\n-            int limit = cb.limit();\n-            char[] decoded = cb.array();\n-            for (int i = 0; i < limit; i++) {\n-                h = 31 * h + decoded[i];\n-            }\n-            if (limit > 0 && decoded[limit - 1] != '\/') {\n-                h = 31 * h + '\/';\n-            }\n-        } catch (CharacterCodingException cce) {\n-            \/\/ Ignore - return the hash code generated so far.\n-        }\n-        return h;\n-    }\n-\n@@ -214,19 +197,0 @@\n-        @Override\n-        void checkEncoding(byte[] a, int pos, int len) throws ZipException {\n-            try {\n-                int end = pos + len;\n-                while (pos < end) {\n-                    \/\/ ASCII fast-path: When checking that a range of bytes is\n-                    \/\/ valid UTF-8, we can avoid some allocation by skipping\n-                    \/\/ past bytes in the 0-127 range\n-                    if (a[pos] < 0) {\n-                        ZipCoder.toStringUTF8(a, pos, end - pos);\n-                        break;\n-                    }\n-                    pos++;\n-                }\n-            } catch(Exception e) {\n-                throw new ZipException(\"invalid CEN header (bad entry name)\");\n-            }\n-        }\n-\n@@ -244,1 +208,1 @@\n-        int normalizedHash(byte[] a, int off, int len) {\n+        int checkedHash(byte[] a, int off, int len) throws Exception {\n@@ -253,1 +217,5 @@\n-                if (b < 0) {\n+                if (b >= 0) {\n+                    \/\/ ASCII, keep going\n+                    h = 31 * h + b;\n+                    off++;\n+                } else {\n@@ -257,8 +225,3 @@\n-                    \/\/ We also avoid the JLA.newStringUTF8NoRepl variant at\n-                    \/\/ this point to avoid throwing exceptions eagerly when\n-                    \/\/ opening ZipFiles (exceptions are expected when accessing\n-                    \/\/ malformed entries.)\n-                    return normalizedHash(new String(a, end - len, len, UTF_8.INSTANCE));\n-                } else {\n-                    h = 31 * h + b;\n-                    off++;\n+                    \/\/ We use the JLA.newStringUTF8NoRepl variant to throw\n+                    \/\/ exceptions eagerly when opening ZipFiles\n+                    return hash(JLA.newStringUTF8NoRepl(a, end - len, len));\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipCoder.java","additions":31,"deletions":68,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -1118,1 +1119,1 @@\n-        private static final int META_INF_LENGTH = 9;\n+        private static final int META_INF_LEN = 9;\n@@ -1151,1 +1152,1 @@\n-        \/\/ {@code hash}, {@code next and {@code \"pos for each entry. The entry can then be\n+        \/\/ {@code hash}, {@code next} and {@code pos} for each entry. The entry can then be\n@@ -1155,5 +1156,37 @@\n-        private int addEntry(int index, int hash, int next, int pos) {\n-            entries[index++] = hash;\n-            entries[index++] = next;\n-            entries[index++] = pos;\n-            return index;\n+\n+        \/\/ Checks the entry at offset pos in the CEN, calculates the Entry values as per above,\n+        \/\/ then returns the length of the entry name.\n+        private int checkAndAddEntry(int pos, int index)\n+            throws ZipException\n+        {\n+            byte[] cen = this.cen;\n+            if (CENSIG(cen, pos) != CENSIG) {\n+                zerror(\"invalid CEN header (bad signature)\");\n+            }\n+            int method = CENHOW(cen, pos);\n+            int flag   = CENFLG(cen, pos);\n+            if ((flag & 1) != 0) {\n+                zerror(\"invalid CEN header (encrypted entry)\");\n+            }\n+            if (method != STORED && method != DEFLATED) {\n+                zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n+            }\n+            int entryPos = pos + CENHDR;\n+            int nlen = CENNAM(cen, pos);\n+            if (entryPos + nlen > cen.length - ENDHDR) {\n+                zerror(\"invalid CEN header (bad header size)\");\n+            }\n+            try {\n+                ZipCoder zcp = zipCoderForPos(pos);\n+                int hash = zcp.checkedHash(cen, entryPos, nlen);\n+                int hsh = (hash & 0x7fffffff) % tablelen;\n+                int next = table[hsh];\n+                table[hsh] = index;\n+                \/\/ Record the CEN offset and the name hash in our hash cell.\n+                entries[index++] = hash;\n+                entries[index++] = next;\n+                entries[index  ] = pos;\n+            } catch (Exception e) {\n+                zerror(\"invalid CEN header (bad entry name)\");\n+            }\n+            return nlen;\n@@ -1161,0 +1194,1 @@\n+\n@@ -1416,2 +1450,1 @@\n-            zerror(\"zip END header not found\");\n-            return null; \/\/make compiler happy\n+            throw new ZipException(\"zip END header not found\");\n@@ -1447,1 +1480,1 @@\n-                total = end.centot;\n+                this.total = end.centot;\n@@ -1450,1 +1483,1 @@\n-                total = knownTotal;\n+                this.total = knownTotal;\n@@ -1453,1 +1486,2 @@\n-            entries  = new int[total * 3];\n+            int entriesLength = this.total * 3;\n+            entries = new int[entriesLength];\n@@ -1455,2 +1489,2 @@\n-            this.tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n-            int tablelen = this.tablelen;\n+            int tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n+            this.tablelen = tablelen;\n@@ -1458,2 +1492,2 @@\n-            this.table = new int[tablelen];\n-            int[] table = this.table;\n+            int[] table = new int[tablelen];\n+            this.table = table;\n@@ -1462,3 +1496,0 @@\n-            int idx = 0;\n-            int hash;\n-            int next;\n@@ -1472,2 +1503,1 @@\n-            int i = 0;\n-            int hsh;\n+            int idx = 0; \/\/ Index into the entries array\n@@ -1478,1 +1508,1 @@\n-                if (i >= total) {\n+                if (idx >= entriesLength) {\n@@ -1485,21 +1515,5 @@\n-                if (CENSIG(cen, pos) != CENSIG)\n-                    zerror(\"invalid CEN header (bad signature)\");\n-                int method = CENHOW(cen, pos);\n-                int nlen   = CENNAM(cen, pos);\n-                int elen   = CENEXT(cen, pos);\n-                int clen   = CENCOM(cen, pos);\n-                int flag   = CENFLG(cen, pos);\n-                if ((flag & 1) != 0)\n-                    zerror(\"invalid CEN header (encrypted entry)\");\n-                if (method != STORED && method != DEFLATED)\n-                    zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n-                if (entryPos + nlen > limit)\n-                    zerror(\"invalid CEN header (bad header size)\");\n-                ZipCoder zcp = zipCoderForPos(pos);\n-                zcp.checkEncoding(cen, pos + CENHDR, nlen);\n-                \/\/ Record the CEN offset and the name hash in our hash cell.\n-                hash = zcp.normalizedHash(cen, entryPos, nlen);\n-                hsh = (hash & 0x7fffffff) % tablelen;\n-                next = table[hsh];\n-                table[hsh] = idx;\n-                idx = addEntry(idx, hash, next, pos);\n+\n+                \/\/ Checks the entry and adds values to entries[idx ... idx+2]\n+                int nlen = checkAndAddEntry(pos, idx);\n+                idx += 3;\n+\n@@ -1509,2 +1523,1 @@\n-                    if (isManifestName(cen, entryPos + META_INF_LENGTH,\n-                            nlen - META_INF_LENGTH)) {\n+                    if (isManifestName(entryPos + META_INF_LEN, nlen - META_INF_LEN)) {\n@@ -1513,1 +1526,1 @@\n-                        if (isSignatureRelated(cen, entryPos, nlen)) {\n+                        if (isSignatureRelated(entryPos, nlen)) {\n@@ -1522,2 +1535,1 @@\n-                        int version = getMetaVersion(cen,\n-                            entryPos + META_INF_LENGTH, nlen - META_INF_LENGTH);\n+                        int version = getMetaVersion(entryPos + META_INF_LEN, nlen - META_INF_LEN);\n@@ -1531,2 +1543,2 @@\n-                \/\/ skip ext and comment\n-                pos = entryPos + nlen + elen + clen;\n+                \/\/ skip to the start of the next entry\n+                pos = nextEntryPos(pos, entryPos, nlen);\n@@ -1534,1 +1546,0 @@\n-                i++;\n@@ -1536,1 +1547,4 @@\n-            total = i;\n+\n+            \/\/ Adjust the total entries\n+            this.total = idx \/ 3;\n+\n@@ -1558,0 +1572,4 @@\n+        private int nextEntryPos(int pos, int entryPos, int nlen) {\n+            return entryPos + nlen + CENCOM(cen, pos) + CENEXT(cen, pos);\n+        }\n+\n@@ -1571,1 +1589,1 @@\n-            int hsh = ZipCoder.normalizedHash(name);\n+            int hsh = ZipCoder.hash(name);\n@@ -1623,1 +1641,1 @@\n-            return len > META_INF_LENGTH       \/\/ \"META-INF\/\".length()\n+            return len > META_INF_LEN       \/\/ \"META-INF\/\".length()\n@@ -1639,1 +1657,2 @@\n-        private static boolean isManifestName(byte[] name, int off, int len) {\n+        private boolean isManifestName(int off, int len) {\n+            byte[] name = cen;\n@@ -1654,1 +1673,1 @@\n-        private static boolean isSignatureRelated(byte[] name, int off, int len) {\n+        private boolean isSignatureRelated(int off, int len) {\n@@ -1659,0 +1678,1 @@\n+            byte[] name = cen;\n@@ -1688,1 +1708,2 @@\n-        private static int getMetaVersion(byte[] name, int off, int len) {\n+        private int getMetaVersion(int off, int len) {\n+            byte[] name = cen;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":78,"deletions":57,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JAVA\" \"1\" \"2020\" \"JDK 17\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2021\" \"JDK 17\" \"JDK Commands\"\n@@ -4098,0 +4098,16 @@\n+.SH REMOVED JAVA OPTIONS\n+.PP\n+These \\f[CB]java\\f[R] options have been removed in JDK 16 and using them\n+results in an error of:\n+.RS\n+.PP\n+\\f[CB]Unrecognized\\ VM\\ option\\f[R] \\f[I]option\\-name\\f[R]\n+.RE\n+.TP\n+.B \\f[CB]\\-XX:+UseParallelOldGC\\f[R]\n+Enables the use of the parallel garbage collector for full GCs.\n+By default, this option is disabled.\n+Enabling it automatically enables the \\f[CB]\\-XX:+UseParallelGC\\f[R]\n+option.\n+.RS\n+.RE\n","filename":"src\/java.base\/share\/man\/java.1","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"KEYTOOL\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"KEYTOOL\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/java.base\/share\/man\/keytool.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,11 +33,0 @@\n-    jint vm_version = JVM_GetInterfaceVersion();\n-    if (vm_version != JVM_INTERFACE_VERSION) {\n-        JNIEnv *env;\n-        char buf[128];\n-        sprintf(buf, \"JVM interface version mismatch: expecting %d, got %d.\",\n-                JVM_INTERFACE_VERSION, (int)vm_version);\n-        (*vm)->GetEnv(vm, (void **)&env, JNI_VERSION_1_2);\n-        if (env) {\n-            (*env)->FatalError(env, buf);\n-        }\n-    }\n","filename":"src\/java.base\/share\/native\/libjava\/check_version.c","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTEvent.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTSurfaceLayers.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -138,1 +137,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^() {\n+    [ThreadUtilities performOnMainThreadWaiting:NO block:^() {\n@@ -464,2 +463,2 @@\n-        characters = JNFNSToJavaString(env, [event characters]);\n-        charactersIgnoringModifiers = JNFNSToJavaString(env, [event charactersIgnoringModifiers]);\n+        characters = NSStringToJavaString(env, [event characters]);\n+        charactersIgnoringModifiers = NSStringToJavaString(env, [event charactersIgnoringModifiers]);\n@@ -578,4 +577,1 @@\n-        if (env != NULL)\n-        {\n-            JNFDumpJavaStack(env);\n-        }\n+        NSLog(@\"%@\",[NSThread callStackSymbols]);\n@@ -595,1 +591,1 @@\n-        JNFDumpJavaStack(env);\n+        NSLog(@\"%@\",[NSThread callStackSymbols]);\n@@ -992,2 +988,2 @@\n-        jstring insertedText =  JNFNSToJavaString(env, useString);\n-        (*env)->CallVoidMethod(env, fInputMethodLOCKABLE, jm_insertText, insertedText); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+        jstring insertedText =  NSStringToJavaString(env, useString);\n+        (*env)->CallVoidMethod(env, fInputMethodLOCKABLE, jm_insertText, insertedText);\n@@ -1058,2 +1054,2 @@\n-    jstring inProcessText = JNFNSToJavaString(env, incomingString);\n-    (*env)->CallVoidMethod(env, fInputMethodLOCKABLE, jm_startIMUpdate, inProcessText); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    jstring inProcessText = NSStringToJavaString(env, incomingString);\n+    (*env)->CallVoidMethod(env, fInputMethodLOCKABLE, jm_startIMUpdate, inProcessText);\n@@ -1084,1 +1080,1 @@\n-                       isGray, effectiveRange.location, effectiveRange.length); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                       isGray, effectiveRange.location, effectiveRange.length);\n@@ -1099,1 +1095,1 @@\n-            selectionRange.location, selectionRange.length, JNI_FALSE); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+            selectionRange.location, selectionRange.length, JNI_FALSE);\n@@ -1121,1 +1117,1 @@\n-    (*env)->CallVoidMethod(env, fInputMethodLOCKABLE, jm_unmarkText); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    (*env)->CallVoidMethod(env, fInputMethodLOCKABLE, jm_unmarkText);\n@@ -1174,1 +1170,1 @@\n-    jobject theString = (*env)->CallObjectMethod(env, fInputMethodLOCKABLE, jm_substringFromRange, theRange.location, theRange.length); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    jobject theString = (*env)->CallObjectMethod(env, fInputMethodLOCKABLE, jm_substringFromRange, theRange.location, theRange.length);\n@@ -1177,1 +1173,1 @@\n-    id result = [[[NSAttributedString alloc] initWithString:JNFJavaToNSString(env, theString)] autorelease];\n+    id result = [[[NSAttributedString alloc] initWithString:JavaStringToNSString(env, theString)] autorelease];\n@@ -1208,1 +1204,1 @@\n-    array = (*env)->CallObjectMethod(env, fInputMethodLOCKABLE, jm_markedRange); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    array = (*env)->CallObjectMethod(env, fInputMethodLOCKABLE, jm_markedRange);\n@@ -1249,1 +1245,1 @@\n-    array = (*env)->CallObjectMethod(env, fInputMethodLOCKABLE, jm_selectedRange); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    array = (*env)->CallObjectMethod(env, fInputMethodLOCKABLE, jm_selectedRange);\n@@ -1288,1 +1284,1 @@\n-                                theRange.location); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                                theRange.location);\n@@ -1329,1 +1325,1 @@\n-                      (jint)flippedLocation.x, (jint)flippedLocation.y); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                      (jint)flippedLocation.x, (jint)flippedLocation.y);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTView.m","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -1447,1 +1446,1 @@\n-                              withObject:JNFJavaToNSString(env, jtitle)\n+                              withObject:JavaStringToNSString(env, jtitle)\n@@ -1523,1 +1522,1 @@\n-    NSURL *url = (filename == NULL) ? nil : [NSURL fileURLWithPath:JNFNormalizedNSStringForPath(env, filename)];\n+    NSURL *url = (filename == NULL) ? nil : [NSURL fileURLWithPath:NormalizedPathNSStringFromJavaString(env, filename)];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTWindow.m","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n@@ -293,1 +291,1 @@\n-    jstring jURL = JNFNSToJavaString(env, url);\n+    jstring jURL = NSStringToJavaString(env, url);\n@@ -296,1 +294,1 @@\n-    (*env)->CallStaticVoidMethod(env, sjc_AppEventHandler, jm_handleOpenURI, jURL); \/\/ AWT_THREADING Safe (event)\n+    (*env)->CallStaticVoidMethod(env, sjc_AppEventHandler, jm_handleOpenURI, jURL);\n@@ -315,1 +313,1 @@\n-    jobject jFileNamesArray = (*env)->NewObject(env, sjc_ArrayList, jm_ArrayList_ctor, (jint)[filenames count]); \/\/ AWT_THREADING Safe (known object)\n+    jobject jFileNamesArray = (*env)->NewObject(env, sjc_ArrayList, jm_ArrayList_ctor, (jint)[filenames count]);\n@@ -319,1 +317,1 @@\n-        jstring jFileName = JNFNormalizedJavaStringForPath(env, filename);\n+        jstring jFileName = NormalizedPathJavaStringFromNSString(env, filename);\n@@ -341,1 +339,1 @@\n-    jstring jSearchString = JNFNSToJavaString(env, searchString);\n+    jstring jSearchString = NSStringToJavaString(env, searchString);\n@@ -368,1 +366,1 @@\n-    (*env)->CallStaticVoidMethod(env, sjc_AppEventHandler, jm_handlePrintFile, jFileNamesArray); \/\/ AWT_THREADING Safe (event)\n+    (*env)->CallStaticVoidMethod(env, sjc_AppEventHandler, jm_handlePrintFile, jFileNamesArray);\n@@ -383,1 +381,1 @@\n-    (*env)->CallStaticVoidMethod(env, sjc_AppEventHandler, jm_handleNativeNotification, notificationType); \/\/ AWT_THREADING Safe (event)\n+    (*env)->CallStaticVoidMethod(env, sjc_AppEventHandler, jm_handleNativeNotification, notificationType);\n@@ -627,1 +625,1 @@\n-                           waitUntilDone:NO]; \/\/ AWT_THREADING Safe (non-blocking)\n+                           waitUntilDone:NO];\n@@ -717,1 +715,1 @@\n-    NSString *badgeString = JNFJavaToNSString(env, badge);\n+    NSString *badgeString = JavaStringToNSString(env, badge);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/ApplicationDelegate.m","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -102,1 +101,1 @@\n-                (*env)->CallVoidMethod(env, self.clipboardOwner, jm_lostOwnership); \/\/ AWT_THREADING Safe (event)\n+                (*env)->CallVoidMethod(env, self.clipboardOwner, jm_lostOwnership);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CClipboard.m","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -78,1 +77,1 @@\n-    NSString *cursorName = JNFJavaToNSString(env, name);\n+    NSString *cursorName = JavaStringToNSString(env, name);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CCursorManager.m","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,3 +31,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n-\n@@ -113,1 +110,1 @@\n-    returnValue = registerFormatWithPasteboard(JNFJavaToNSString(env, newformat));\n+    returnValue = registerFormatWithPasteboard(JavaStringToNSString(env, newformat));\n@@ -128,1 +125,1 @@\n-    returnValue = JNFNSToJavaString(env, formatForIndex(index));\n+    returnValue = NSStringToJavaString(env, formatForIndex(index));\n@@ -141,1 +138,1 @@\n-    jobject jfilenameArray = (*env)->NewObjectArray(env, filenameCount, stringClazz, NULL); \/\/ AWT_THREADING Safe (known object)\n+    jobject jfilenameArray = (*env)->NewObjectArray(env, filenameCount, stringClazz, NULL);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDataTransferer.m","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -46,1 +45,1 @@\n-    NSURL *url = [NSURL URLWithString:JNFJavaToNSString(env, uri)];\n+    NSURL *url = [NSURL URLWithString:JavaStringToNSString(env, uri)];\n@@ -71,1 +70,1 @@\n-    NSString *path  = JNFNormalizedNSStringForPath(env, jpath);\n+    NSString *path  = NormalizedPathNSStringFromJavaString(env, jpath);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDesktopPeer.m","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -575,1 +574,1 @@\n-        (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragDropFinishedMethod, success, dragOp, (jint) point.x, (jint) point.y); \/\/ AWT_THREADING Safe (event)\n+        (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragDropFinishedMethod, success, dragOp, (jint) point.x, (jint) point.y);\n@@ -597,1 +596,1 @@\n-    [self performSelectorOnMainThread:@selector(doDrag) withObject:nil waitUntilDone:YES]; \/\/ AWT_THREADING Safe (called from unique asynchronous thread)\n+    [self performSelectorOnMainThread:@selector(doDrag) withObject:nil waitUntilDone:YES];\n@@ -616,1 +615,1 @@\n-    (*env)->CallVoidMethod(env, fDragSourceContextPeer, operationChangedMethod, targetActions, modifiedModifiers, (jint) point.x, (jint) point.y); \/\/ AWT_THREADING Safe (event)\n+    (*env)->CallVoidMethod(env, fDragSourceContextPeer, operationChangedMethod, targetActions, modifiedModifiers, (jint) point.x, (jint) point.y);\n@@ -691,1 +690,1 @@\n-        (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragMotionMethod, targetActions, (jint) fModifiers, (jint) point.x, (jint) point.y); \/\/ AWT_THREADING Safe (event)\n+        (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragMotionMethod, targetActions, (jint) fModifiers, (jint) point.x, (jint) point.y);\n@@ -695,1 +694,1 @@\n-        (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragMouseMovedMethod, targetActions, (jint) fModifiers, (jint) point.x, (jint) point.y); \/\/ AWT_THREADING Safe (event)\n+        (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragMouseMovedMethod, targetActions, (jint) fModifiers, (jint) point.x, (jint) point.y);\n@@ -722,1 +721,1 @@\n-    (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragEnterMethod, targetActions, (jint) fModifiers, (jint) point.x, (jint) point.y); \/\/ AWT_THREADING Safe (event)\n+    (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragEnterMethod, targetActions, (jint) fModifiers, (jint) point.x, (jint) point.y);\n@@ -734,1 +733,1 @@\n-    (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragExitMethod, (jint) point.x, (jint) point.y); \/\/ AWT_THREADING Safe (event)\n+    (*env)->CallVoidMethod(env, fDragSourceContextPeer, dragExitMethod, (jint) point.x, (jint) point.y);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDragSource.m","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDragSourceContextPeer.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDropTarget.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CDropTargetContextPeer.m","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#import \"ThreadUtilities.h\"\n@@ -29,1 +30,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -52,1 +52,1 @@\n-            [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^() {\n+            [ThreadUtilities performOnMainThreadWaiting:NO block:^() {\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CFRetainedResource.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CFileDialog.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -30,1 +29,0 @@\n-#import \"CFileDialog.h\"\n@@ -33,0 +31,1 @@\n+#import \"CFileDialog.h\"\n@@ -146,1 +145,1 @@\n-    jstring jString = JNFNormalizedJavaStringForPath(env, filename);\n+    jstring jString = NormalizedPathJavaStringFromNSString(env, filename);\n@@ -150,1 +149,1 @@\n-    BOOL returnValue = (*env)->CallBooleanMethod(env, fFileDialog, jm_queryFF, jString); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    BOOL returnValue = (*env)->CallBooleanMethod(env, fFileDialog, jm_queryFF, jString);\n@@ -202,1 +201,1 @@\n-    NSString *dialogTitle = JNFJavaToNSString(env, title);\n+    NSString *dialogTitle = JavaStringToNSString(env, title);\n@@ -210,2 +209,2 @@\n-                                                            directory:JNFJavaToNSString(env, directory)\n-                                                                 file:JNFJavaToNSString(env, file)\n+                                                            directory:JavaStringToNSString(env, directory)\n+                                                                 file:JavaStringToNSString(env, file)\n@@ -218,1 +217,1 @@\n-    [JNFRunLoop performOnMainThread:@selector(safeSaveOrLoad)\n+    [ThreadUtilities performOnMainThread:@selector(safeSaveOrLoad)\n@@ -231,1 +230,1 @@\n-            jstring filename = JNFNormalizedJavaStringForPath(env, [url path]);\n+            jstring filename = NormalizedPathJavaStringFromNSString(env, [url path]);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CFileDialog.m","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CGraphicsDevice.m","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n@@ -117,13 +115,12 @@\n-        JNFPerformEnvBlock(JNFThreadDetachImmediately, ^(JNIEnv *env) {\n-            jobject cgeRef = (jobject)userInfo;\n-\n-            jobject graphicsEnv = (*env)->NewLocalRef(env, cgeRef);\n-            if (graphicsEnv == NULL) return; \/\/ ref already GC'd\n-            DECLARE_CLASS(jc_CGraphicsEnvironment, \"sun\/awt\/CGraphicsEnvironment\");\n-            DECLARE_METHOD(jm_displayReconfiguration,\n-                    jc_CGraphicsEnvironment, \"_displayReconfiguration\",\"(IZ)V\");\n-            (*env)->CallVoidMethod(env, graphicsEnv, jm_displayReconfiguration,\n-                    (jint) display, (jboolean) flags & kCGDisplayRemoveFlag);\n-            (*env)->DeleteLocalRef(env, graphicsEnv);\n-            CHECK_EXCEPTION();\n-        });\n+        JNIEnv *env = [ThreadUtilities getJNIEnvUncached];\n+        jobject cgeRef = (jobject)userInfo;\n+\n+        jobject graphicsEnv = (*env)->NewLocalRef(env, cgeRef);\n+        if (graphicsEnv == NULL) return; \/\/ ref already GC'd\n+        DECLARE_CLASS(jc_CGraphicsEnvironment, \"sun\/awt\/CGraphicsEnvironment\");\n+        DECLARE_METHOD(jm_displayReconfiguration,\n+                jc_CGraphicsEnvironment, \"_displayReconfiguration\",\"(IZ)V\");\n+        (*env)->CallVoidMethod(env, graphicsEnv, jm_displayReconfiguration,\n+                (jint) display, (jboolean) flags & kCGDisplayRemoveFlag);\n+        (*env)->DeleteLocalRef(env, graphicsEnv);\n+        CHECK_EXCEPTION();\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CGraphicsEnv.m","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -207,1 +206,1 @@\n-    NSString *path = JNFNormalizedNSStringForPath(env, file);\n+    NSString *path = NormalizedPathNSStringFromJavaString(env, file);\n@@ -227,1 +226,1 @@\n-    NSString *path = JNFNormalizedNSStringForPath(env, file);\n+    NSString *path = NormalizedPathNSStringFromJavaString(env, file);\n@@ -250,1 +249,1 @@\n-    image = [[NSImage imageNamed:JNFJavaToNSString(env, name)] retain];\n+    image = [[NSImage imageNamed:JavaStringToNSString(env, name)] retain];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CImage.m","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -163,1 +162,1 @@\n-    returnValue = JNFNSToJavaString(env, keyboardInfo);\n+    returnValue = NSStringToJavaString(env, keyboardInfo);\n@@ -262,1 +261,1 @@\n-    NSString *localeStr = JNFJavaToNSString(env, locale);\n+    NSString *localeStr = JavaStringToNSString(env, locale);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CInputMethod.m","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -219,1 +218,1 @@\n-    [((CMenu *)jlong_to_ptr(menuObject)) setJavaMenuTitle:JNFJavaToNSString(env, label)];\n+    [((CMenu *)jlong_to_ptr(menuObject)) setJavaMenuTitle:JavaStringToNSString(env, label)];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CMenu.m","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CMenuBar.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CMenuComponent.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -316,1 +315,1 @@\n-    NSString *theLabel = JNFJavaToNSString(env, label);\n+    NSString *theLabel = JavaStringToNSString(env, label);\n@@ -345,1 +344,1 @@\n-    NSString *theTooltip = JNFJavaToNSString(env, tooltip);\n+    NSString *theTooltip = JavaStringToNSString(env, tooltip);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CMenuItem.m","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CPopupMenu.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -90,1 +89,1 @@\n-        NSPrinter* nsPrinter = [NSPrinter printerWithName:JNFJavaToNSString(env, printer)];\n+        NSPrinter* nsPrinter = [NSPrinter printerWithName:JavaStringToNSString(env, printer)];\n@@ -348,1 +347,1 @@\n-    NSString *printerName = JNFJavaToNSString(env, printerNameObj);\n+    NSString *printerName = JavaStringToNSString(env, printerNameObj);\n@@ -367,1 +366,1 @@\n-    jstring printerName = JNFNSToJavaString(env, name);\n+    jstring printerName = NSStringToJavaString(env, name);\n@@ -378,1 +377,1 @@\n-        jstring str = JNFNSToJavaString(env, nsStr);\n+        jstring str = NSStringToJavaString(env, nsStr);\n@@ -494,1 +493,1 @@\n-       NSString *nsDestStr = JNFJavaToNSString(env, dest);\n+       NSString *nsDestStr = JavaStringToNSString(env, dest);\n@@ -631,1 +630,1 @@\n-            NSString *printerTray = JNFJavaToNSString(env, printerTrayObj);\n+            NSString *printerTray = JavaStringToNSString(env, printerTrayObj);\n@@ -645,1 +644,1 @@\n-            NSString *printerName = JNFJavaToNSString(env, printerNameObj);\n+            NSString *printerName = JavaStringToNSString(env, printerNameObj);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CPrinterJob.m","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CRobot.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CSystemColors.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,2 +33,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n@@ -589,0 +587,3 @@\n+    if (str == NULL) {\n+        return;\n+    }\n@@ -600,1 +601,1 @@\n-        JNF_CHECK_AND_RETHROW_EXCEPTION(env);\n+        CHECK_EXCEPTION();\n@@ -608,1 +609,5 @@\n-        const jchar *unichars = JNFGetStringUTF16UniChars(env, str);\n+        const jchar *unichars = (*env)->GetStringChars(env, str, NULL);\n+        if (unichars == NULL) {\n+            JNU_ThrowOutOfMemoryError(env, \"Could not get string chars\");\n+            return;\n+        }\n@@ -613,1 +618,1 @@\n-        JNFReleaseStringUTF16UniChars(env, str, unichars);\n+        (*env)->ReleaseStringChars(env, str, unichars);\n@@ -638,1 +643,1 @@\n-        JNF_CHECK_AND_RETHROW_EXCEPTION(env);\n+        CHECK_EXCEPTION();\n@@ -651,1 +656,1 @@\n-            JNF_CHECK_AND_RETHROW_EXCEPTION(env);\n+            CHECK_EXCEPTION();\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CTextPipe.m","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -345,1 +344,1 @@\n-    NSString *tooltip = JNFJavaToNSString(env, jtooltip);\n+    NSString *tooltip = JavaStringToNSString(env, jtooltip);\n@@ -398,2 +397,2 @@\n-    NSString *caption = JNFJavaToNSString(env, jcaption);\n-    NSString *text = JNFJavaToNSString(env, jtext);\n+    NSString *caption = JavaStringToNSString(env, jcaption);\n+    NSString *text = JavaStringToNSString(env, jtext);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CTrayIcon.m","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -595,1 +594,1 @@\n-    NSString* s = JNFJavaToNSString(env, msg);\n+    NSString* s = JavaStringToNSString(env, msg);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CWrapper.m","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -103,1 +102,4 @@\n-    if (env != NULL) [JNFException raise:env as:kRuntimeException reason:\"Failed to convert, no screen.\"];\n+    if ((env != NULL) && ([NSThread isMainThread] == NO)) {\n+        JNU_ThrowByName(env, \"java\/lang\/RuntimeException\", \"Failed to convert, no screen.\");\n+    }\n+    [NSException raise:NSGenericException format:@\"Failed to convert, no screen.\"];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/GeomUtilities.m","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/ImageSurfaceData.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-        str = JNFJavaToNSString(env, jstr); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+        str = JavaStringToNSString(env, jstr);\n@@ -103,1 +103,1 @@\n-             fAccessibleAction, fIndex, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+             fAccessibleAction, fIndex, fComponent);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/JavaAccessibilityAction.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n+#import \"JNIUtilities.h\"\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/JavaAccessibilityUtilities.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n@@ -61,1 +59,1 @@\n-    jobject dimension = (*env)->CallStaticObjectMethod(env, jc_Dimension, jm_getSize, axComponent, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    jobject dimension = (*env)->CallStaticObjectMethod(env, jc_Dimension, jm_getSize, axComponent, component);\n@@ -74,1 +72,1 @@\n-                      axComponent, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                      axComponent, component);\n@@ -78,1 +76,1 @@\n-    NSString* str = JNFJavaToNSString(env, axRole);\n+    NSString* str = JavaStringToNSString(env, axRole);\n@@ -89,1 +87,1 @@\n-                      axContext, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                      axContext, component);\n@@ -100,1 +98,1 @@\n-                    axContext, index, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                    axContext, index, component);\n@@ -110,1 +108,1 @@\n-                    axContext, index, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                    axContext, index, component);\n@@ -120,1 +118,1 @@\n-                    accessible, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                    accessible, component);\n@@ -131,1 +129,1 @@\n-                    accessible, index, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                    accessible, index, component);\n@@ -142,1 +140,1 @@\n-                    axContext, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                    axContext, component);\n@@ -152,1 +150,1 @@\n-    jboolean b = (*env)->CallStaticBooleanMethod(env, sjc_CAccessibility, jm_contains, axContext, axState, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    jboolean b = (*env)->CallStaticBooleanMethod(env, sjc_CAccessibility, jm_contains, axContext, axState, component);\n@@ -213,1 +211,1 @@\n-                      axComponent, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                      axComponent, component);\n@@ -224,1 +222,1 @@\n-    int i = (*env)->CallStaticIntMethod(env, sjc_CAccessibility, jm_getCharCount, axText, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    int i = (*env)->CallStaticIntMethod(env, sjc_CAccessibility, jm_getCharCount, axText, component);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/JavaAccessibilityUtilities.m","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -315,1 +314,1 @@\n-            jstring jString = JNFNSToJavaString(env, [ignoredKeys objectAtIndex:i]);\n+            jstring jString = NSStringToJavaString(env, [ignoredKeys objectAtIndex:i]);\n@@ -351,1 +350,1 @@\n-                  parent->fAccessible, parent->fComponent, whichChildren, allowIgnored); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                  parent->fAccessible, parent->fComponent, whichChildren, allowIgnored);\n@@ -371,1 +370,1 @@\n-            childJavaRole = JNFJavaToNSString(env, jkey);\n+            childJavaRole = JavaStringToNSString(env, jkey);\n@@ -493,1 +492,1 @@\n-                     jm_getInitialAttributeStates, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                     jm_getInitialAttributeStates, fAccessible, fComponent);\n@@ -592,1 +591,1 @@\n-    jobject axAction = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, jm_getAccessibleAction, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    jobject axAction = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, jm_getAccessibleAction, fAccessible, fComponent);\n@@ -869,1 +868,1 @@\n-    NSNumber *value = [NSNumber numberWithBool:(*env)->CallStaticBooleanMethod(env, sjc_CAccessibility, jm_isEnabled, fAccessible, fComponent)]; \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    NSNumber *value = [NSNumber numberWithBool:(*env)->CallStaticBooleanMethod(env, sjc_CAccessibility, jm_isEnabled, fAccessible, fComponent)];\n@@ -901,1 +900,1 @@\n-    if ((*env)->CallStaticBooleanMethod(env, sjc_CAccessibility, sjm_isFocusTraversable, fAccessible, fComponent)) { \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    if ((*env)->CallStaticBooleanMethod(env, sjc_CAccessibility, sjm_isFocusTraversable, fAccessible, fComponent)) {\n@@ -918,1 +917,1 @@\n-        (*env)->CallStaticVoidMethod(env, sjc_CAccessibility, jm_requestFocus, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+        (*env)->CallStaticVoidMethod(env, sjc_CAccessibility, jm_requestFocus, fAccessible, fComponent);\n@@ -932,1 +931,1 @@\n-                                   sjm_getAccessibleDescription, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                                   sjm_getAccessibleDescription, fAccessible, fComponent);\n@@ -937,1 +936,1 @@\n-    NSString* str = JNFJavaToNSString(env, val);\n+    NSString* str = JavaStringToNSString(env, val);\n@@ -959,0 +958,26 @@\n+\/*\n+ * The java\/lang\/Number concrete class could be for any of the Java primitive\n+ * numerical types or some other subclass.\n+ * All existing A11Y code uses Integer so that is what we look for first\n+ * But all must be able to return a double and NSNumber accepts a double,\n+ * so that's the fall back.\n+ *\/\n+static NSNumber* JavaNumberToNSNumber(JNIEnv *env, jobject jnumber) {\n+    if (jnumber == NULL) {\n+        return nil;\n+    }\n+    DECLARE_CLASS_RETURN(jnumber_Class, \"java\/lang\/Number\", nil);\n+    DECLARE_CLASS_RETURN(jinteger_Class, \"java\/lang\/Integer\", nil);\n+    DECLARE_METHOD_RETURN(jm_intValue, jnumber_Class, \"intValue\", \"()D\", nil);\n+    DECLARE_METHOD_RETURN(jm_doubleValue, jnumber_Class, \"doubleValue\", \"()D\", nil);\n+    if ((*env)->IsInstanceOf(env, jnumber, jinteger_Class)) {\n+        jint i = (*env)->CallIntMethod(env, jnumber_Class, jm_intValue);\n+        CHECK_EXCEPTION();\n+        return [NSNumber numberWithInteger:i];\n+    } else {\n+        jdouble d = (*env)->CallDoubleMethod(env, jnumber_Class, jm_doubleValue);\n+        CHECK_EXCEPTION();\n+        return [NSNumber numberWithDouble:d];\n+    }\n+}\n+\n@@ -967,1 +992,1 @@\n-    jobject axValue = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, jm_getMaximumAccessibleValue, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    jobject axValue = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, jm_getMaximumAccessibleValue, fAccessible, fComponent);\n@@ -972,1 +997,1 @@\n-    NSNumber* num = JNFJavaToNSNumber(env, axValue);\n+    NSNumber* num = JavaNumberToNSNumber(env, axValue);\n@@ -990,1 +1015,1 @@\n-    jobject axValue = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, jm_getMinimumAccessibleValue, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    jobject axValue = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, jm_getMinimumAccessibleValue, fAccessible, fComponent);\n@@ -995,1 +1020,1 @@\n-    NSNumber* num = JNFJavaToNSNumber(env, axValue);\n+    NSNumber* num = JavaNumberToNSNumber(env, axValue);\n@@ -1047,1 +1072,1 @@\n-                           fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                           fAccessible, fComponent);\n@@ -1118,1 +1143,1 @@\n-            value = JNFJavaToNSString(env, axRole);\n+            value = JavaStringToNSString(env, axRole);\n@@ -1174,1 +1199,1 @@\n-        (*env)->CallStaticVoidMethod(env, sjc_CAccessibility, jm_requestSelection, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+        (*env)->CallStaticVoidMethod(env, sjc_CAccessibility, jm_requestSelection, fAccessible, fComponent);\n@@ -1184,1 +1209,1 @@\n-                           sjm_getAccessibleComponent, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                           sjm_getAccessibleComponent, fAccessible, fComponent);\n@@ -1246,1 +1271,1 @@\n-    jobject val = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, sjm_getAccessibleName, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    jobject val = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, sjm_getAccessibleName, fAccessible, fComponent);\n@@ -1251,1 +1276,1 @@\n-    NSString* str = JNFJavaToNSString(env, val);\n+    NSString* str = JavaStringToNSString(env, val);\n@@ -1307,1 +1332,1 @@\n-                                                   selectedMenuItem->fComponent ); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                                                   selectedMenuItem->fComponent );\n@@ -1312,1 +1337,1 @@\n-                NSString* itemString = JNFJavaToNSString(env, itemValue);\n+                NSString* itemString = JavaStringToNSString(env, itemValue);\n@@ -1329,1 +1354,1 @@\n-    jobject axValue = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, sjm_getAccessibleValue, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    jobject axValue = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, sjm_getAccessibleValue, fAccessible, fComponent);\n@@ -1337,1 +1362,1 @@\n-            num = JNFJavaToNSNumber(env, str); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+            num = JavaNumberToNSNumber(env, str);\n@@ -1445,1 +1470,1 @@\n-                               jparent, (jfloat)point.x, (jfloat)point.y); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                               jparent, (jfloat)point.x, (jfloat)point.y);\n@@ -1475,1 +1500,1 @@\n-    jobject focused = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, jm_getFocusOwner, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    jobject focused = (*env)->CallStaticObjectMethod(env, sjc_CAccessibility, jm_getFocusOwner, fComponent);\n@@ -1677,1 +1702,1 @@\n-                                  fAccessible, fComponent, whichTabs, allowIgnored); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                                  fAccessible, fComponent, whichTabs, allowIgnored);\n@@ -1698,1 +1723,1 @@\n-    NSString *tabJavaRole = JNFJavaToNSString(env, jkey);\n+    NSString *tabJavaRole = JavaStringToNSString(env, jkey);\n@@ -2053,1 +2078,1 @@\n-        return (*env)->CallStaticBooleanMethod(env, sjc_LWCToolkit, jm_doEquals, a, b, component); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+        return (*env)->CallStaticBooleanMethod(env, sjc_LWCToolkit, jm_doEquals, a, b, component);\n@@ -2057,1 +2082,1 @@\n-    jboolean jb = (*env)->CallBooleanMethod(env, a, jm_equals, b); \/\/ AWT_THREADING Safe (!appKit)\n+    jboolean jb = (*env)->CallBooleanMethod(env, a, jm_equals, b);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/JavaComponentAccessibility.m","additions":56,"deletions":31,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-                           sjm_getAccessibleName, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                           sjm_getAccessibleName, fAccessible, fComponent);\n@@ -140,1 +140,1 @@\n-            NSString* str = JNFJavaToNSString(env, axName);\n+            NSString* str = JavaStringToNSString(env, axName);\n@@ -150,1 +150,1 @@\n-                      sjm_getAccessibleText, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                      sjm_getAccessibleText, fAccessible, fComponent);\n@@ -157,1 +157,1 @@\n-                       sjm_getAccessibleEditableText, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                       sjm_getAccessibleEditableText, fAccessible, fComponent);\n@@ -166,1 +166,1 @@\n-    NSString *string = JNFJavaToNSString(env, jrange); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    NSString *string = JavaStringToNSString(env, jrange);\n@@ -184,1 +184,1 @@\n-                     sjm_getAccessibleEditableText, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                     sjm_getAccessibleEditableText, fAccessible, fComponent);\n@@ -207,1 +207,1 @@\n-                        fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                        fAccessible, fComponent);\n@@ -210,1 +210,1 @@\n-    NSString* str = JNFJavaToNSString(env, axText);\n+    NSString* str = JavaStringToNSString(env, axText);\n@@ -230,1 +230,1 @@\n-    jstring jstringValue = JNFNSToJavaString(env, (NSString *)value);\n+    jstring jstringValue = NSStringToJavaString(env, (NSString *)value);\n@@ -235,1 +235,1 @@\n-              fAccessible, fComponent, jstringValue); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+              fAccessible, fComponent, jstringValue);\n@@ -247,1 +247,1 @@\n-                jm_getSelectedTextRange, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                jm_getSelectedTextRange, fAccessible, fComponent);\n@@ -277,1 +277,1 @@\n-                  fAccessible, fComponent, startIndex, endIndex); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                  fAccessible, fComponent, startIndex, endIndex);\n@@ -288,1 +288,1 @@\n-                     sjm_getAccessibleText, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                     sjm_getAccessibleText, fAccessible, fComponent);\n@@ -307,1 +307,1 @@\n-                 jm_getVisibleCharacterRange, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                 jm_getVisibleCharacterRange, fAccessible, fComponent);\n@@ -329,1 +329,1 @@\n-                  jm_getLineNumberForInsertionPoint, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                  jm_getLineNumberForInsertionPoint, fAccessible, fComponent);\n@@ -368,1 +368,1 @@\n-                              fAccessible, fComponent, range.location, range.length); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                              fAccessible, fComponent, range.location, range.length);\n@@ -400,1 +400,1 @@\n-                       fAccessible, fComponent, [line intValue]); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                       fAccessible, fComponent, [line intValue]);\n@@ -416,1 +416,1 @@\n-                jm_getRangeForLine, fAccessible, fComponent, [line intValue]); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                jm_getRangeForLine, fAccessible, fComponent, [line intValue]);\n@@ -446,1 +446,1 @@\n-                            fAccessible, fComponent, range.location, range.length); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                            fAccessible, fComponent, range.location, range.length);\n@@ -449,1 +449,1 @@\n-    NSString* str = JNFJavaToNSString(env, jstringForRange);\n+    NSString* str = JavaStringToNSString(env, jstringForRange);\n@@ -478,1 +478,1 @@\n-                            fAccessible, fComponent, point.x, point.y); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                            fAccessible, fComponent, point.x, point.y);\n@@ -511,1 +511,1 @@\n-                              fAccessible, fComponent, index); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                              fAccessible, fComponent, index);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/JavaTextAccessibility.m","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -459,1 +459,1 @@\n-        [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){}];\n+        [ThreadUtilities performOnMainThreadWaiting:YES block:^(){}];\n@@ -520,1 +520,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n@@ -590,1 +590,1 @@\n-        isRunning = [[NSRunLoop currentRunLoop] runMode:(inAWT ? [JNFRunLoop javaRunLoopMode] : NSDefaultRunLoopMode)\n+        isRunning = [[NSRunLoop currentRunLoop] runMode:(inAWT ? [ThreadUtilities javaRunLoopMode] : NSDefaultRunLoopMode)\n@@ -657,1 +657,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n@@ -730,1 +730,1 @@\n-    return JNFNSToJavaString(env, @\"\/Library\/Fonts\");\n+    return NSStringToJavaString(env, @\"\/Library\/Fonts\");\n@@ -872,1 +872,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/LWCToolkit.m","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n@@ -56,1 +54,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n@@ -67,1 +65,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/PrintModel.m","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/PrinterSurfaceData.m","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n@@ -109,1 +107,1 @@\n-                           fCurPainter, fCurPageFormat, jPageIndex, context); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                           fCurPainter, fCurPageFormat, jPageIndex, context);\n@@ -125,1 +123,1 @@\n-    jobject o = (*env)->CallObjectMethod(env, fPrinterJob, jm_getJobName); \/\/ AWT_THREADING Safe (known object)\n+    jobject o = (*env)->CallObjectMethod(env, fPrinterJob, jm_getJobName);\n@@ -127,1 +125,1 @@\n-    id result = JNFJavaToNSString(env, o);\n+    id result = JavaStringToNSString(env, o);\n@@ -198,1 +196,1 @@\n-                                jm_getPageformatPrintablePeekgraphics, jPageNumber); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                                jm_getPageformatPrintablePeekgraphics, jPageNumber);\n@@ -217,1 +215,1 @@\n-                                    fCurPeekGraphics, fCurPageFormat, jPageNumber); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                                    fCurPeekGraphics, fCurPageFormat, jPageNumber);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/PrinterView.m","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/QuartzRenderer.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/QuartzSurfaceData.m","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-            NSString* str = JNFJavaToNSString(env, axName);\n+            NSString* str = JavaStringToNSString(env, axName);\n@@ -103,1 +103,1 @@\n-    NSString *string = JNFJavaToNSString(env, jrange); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+    NSString *string = JavaStringToNSString(env, jrange);\n@@ -119,1 +119,1 @@\n-                 jm_getVisibleCharacterRange, fAccessible, fComponent); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                 jm_getVisibleCharacterRange, fAccessible, fComponent);\n@@ -133,1 +133,1 @@\n-                            fAccessible, fComponent, range.location, range.length); \/\/ AWT_THREADING Safe (AWTRunLoop)\n+                            fAccessible, fComponent, range.location, range.length);\n@@ -136,1 +136,1 @@\n-    NSString* str = JNFJavaToNSString(env, jstringForRange);\n+    NSString* str = JavaStringToNSString(env, jstringForRange);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/a11y\/CommonTextAccessibility.m","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n@@ -313,1 +311,1 @@\n-        jobject jFontName = JNFNSToJavaString(env, fontname);\n+        jobject jFontName = NSStringToJavaString(env, fontname);\n@@ -315,1 +313,1 @@\n-            JNFNSToJavaString(env, GetFamilyNameForFontName(fontname));\n+            NSStringToJavaString(env, GetFamilyNameForFontName(fontname));\n@@ -337,1 +335,1 @@\n-    NSString *path = JNFJavaToNSString(env, filename);\n+    NSString *path = JavaStringToNSString(env, filename);\n@@ -437,1 +435,1 @@\n-        [AWTFont awtFontForName:JNFJavaToNSString(env, nativeFontName)\n+        [AWTFont awtFontForName:JavaStringToNSString(env, nativeFontName)\n@@ -573,1 +571,1 @@\n-        jstring jFontName = (jstring)JNFNSToJavaString(env, fontname);\n+        jstring jFontName = (jstring)NSStringToJavaString(env, fontname);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTFont.m","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTStrike.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CCharToGlyphMapper.m","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -29,0 +28,1 @@\n+#import \"JNIUtilities.h\"\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CGGlyphImages.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -126,0 +125,1 @@\n+\n@@ -291,0 +291,1 @@\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/opengl\/CGLGraphicsConfig.m","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/opengl\/CGLLayer.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -318,1 +318,1 @@\n-            [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){\n+            [ThreadUtilities performOnMainThreadWaiting:NO block:^(){\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/opengl\/CGLSurfaceData.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,4 +29,0 @@\n-\n-#import <Cocoa\/Cocoa.h>\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n@@ -35,0 +31,1 @@\n+#import <Cocoa\/Cocoa.h>\n@@ -45,1 +42,1 @@\n-        NSString *filename = JNFNormalizedNSStringForPath(env, javaFilename);\n+        NSString *filename = NormalizedPathNSStringFromJavaString(env, javaFilename);\n@@ -62,1 +59,1 @@\n-        NSString *filename = JNFNormalizedNSStringForPath(env, javaFilename);\n+        NSString *filename = NormalizedPathNSStringFromJavaString(env, javaFilename);\n@@ -77,1 +74,1 @@\n-        NSString *filename = JNFNormalizedNSStringForPath(env, javaFilename);\n+        NSString *filename = NormalizedPathNSStringFromJavaString(env, javaFilename);\n@@ -93,1 +90,1 @@\n-        NSString *filename = JNFNormalizedNSStringForPath(env, javaFilename);\n+        NSString *filename = NormalizedPathNSStringFromJavaString(env, javaFilename);\n@@ -111,1 +108,1 @@\n-        NSString *filename = JNFNormalizedNSStringForPath(env, javaFilename);\n+        NSString *filename = NormalizedPathNSStringFromJavaString(env, javaFilename);\n@@ -136,1 +133,1 @@\n-            filename = JNFNormalizedJavaStringForPath(env, filenameString);\n+            filename = NormalizedPathJavaStringFromNSString(env, filenameString);\n@@ -155,1 +152,1 @@\n-    NSURL *url = [NSURL URLWithString:JNFNormalizedNSStringForPath(env, urlString)];\n+    NSURL *url = [NSURL URLWithString:NormalizedPathNSStringFromJavaString(env, urlString)];\n@@ -158,1 +155,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:NO block:^(){\n@@ -177,3 +174,3 @@\n-    NSString *resourceName = JNFNormalizedNSStringForPath(env, javaResourceName);\n-        NSString *subDirectory = JNFNormalizedNSStringForPath(env, javaSubDirName);\n-        NSString *typeName = JNFNormalizedNSStringForPath(env, javaTypeName);\n+    NSString *resourceName = NormalizedPathNSStringFromJavaString(env, javaResourceName);\n+        NSString *subDirectory = NormalizedPathNSStringFromJavaString(env, javaSubDirName);\n+        NSString *typeName = NormalizedPathNSStringFromJavaString(env, javaTypeName);\n@@ -185,1 +182,1 @@\n-    filename = JNFNormalizedJavaStringForPath(env, path);\n+    filename = NormalizedPathJavaStringFromNSString(env, path);\n@@ -204,1 +201,1 @@\n-        filename = JNFNormalizedJavaStringForPath(env, [mainBundle bundlePath]);\n+        filename = NormalizedPathJavaStringFromNSString(env, [mainBundle bundlePath]);\n@@ -223,1 +220,1 @@\n-    NSString * path = JNFNormalizedNSStringForPath(env, fileName);\n+    NSString * path = NormalizedPathNSStringFromJavaString(env, fileName);\n@@ -225,1 +222,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n@@ -249,2 +246,2 @@\n-    NSString *path = JNFNormalizedNSStringForPath(env, url);\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    NSString *path = NormalizedPathNSStringFromJavaString(env, url);\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n","filename":"src\/java.desktop\/macosx\/native\/libosx\/CFileManager.m","additions":18,"deletions":21,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -240,0 +240,10 @@\n+\/********        STRING CONVERSION SUPPORT    *********\/\n+\n+JNIEXPORT NSString* JavaStringToNSString(JNIEnv *env, jstring jstr);\n+\n+JNIEXPORT jstring NSStringToJavaString(JNIEnv* env, NSString *str);\n+\n+JNIEXPORT NSString* NormalizedPathNSStringFromJavaString(JNIEnv *env, jstring pathStr);\n+\n+JNIEXPORT jstring NormalizedPathJavaStringFromNSString(JNIEnv* env, NSString *str);\n+\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/JNIUtilities.h","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"JNIUtilities.h\"\n+\n+NSString* JavaStringToNSString(JNIEnv *env, jstring jstr) {\n+    if (jstr == NULL) {\n+        return NULL;\n+    }\n+    jsize len = (*env)->GetStringLength(env, jstr);\n+    const jchar *chars = (*env)->GetStringChars(env, jstr, NULL);\n+    if (chars == NULL) {\n+        return NULL;\n+    }\n+    NSString *result = [NSString stringWithCharacters:(UniChar *)chars length:len];\n+    (*env)->ReleaseStringChars(env, jstr, chars);\n+    return result;\n+}\n+\n+jstring NSStringToJavaString(JNIEnv* env, NSString *str) {\n+\n+    if (str == NULL) {\n+       return NULL;\n+    }\n+    jstring jStr = (*env)->NewStringUTF(env, [str UTF8String]);\n+    CHECK_EXCEPTION();\n+    return jStr;\n+}\n+\n+\/*\n+ * These next conversion functions are for file system paths.\n+ * The NSString needs to be in de-composed UTF-16 format for the Apple file system\n+ * The Java String needs to be in pre-composed UTF-16 format for display by Java.\n+ * https:\/\/developer.apple.com\/library\/archive\/qa\/qa1235\/_index.html\n+ * has some information on this.\n+ *\/\n+\n+\/*\n+ * Returns an NSString in decomposed UTF16 format that is compatible with HFS's\n+ * expectation of the UTF16 format for file system paths.\n+ *\n+ * Example string: \"\/Users\/Amélie\/\"\n+ *\n+ * Java's UTF16 string is \"\/ U s e r s \/ A m \\351 l i e \/\"\n+ * macOS UTF16 string suitable for HFS is \"\/ U s e r s \/ A m e \\314 \\201 l i e \/\"\n+ *\n+ * There is no direct API that takes in NSString UTF16 encoded by Java\n+ * and produces NSString UTF16 for HFS, so we first need to decompose it\n+ * into chars (suitable for low level C file APIs), and only then\n+ * create NSString representation of this decomposition back into UTF16 string.\n+ *\n+ * https:\/\/developer.apple.com\/documentation\/foundation\/nsstring\/1414559-filesystemrepresentation?language=objc\n+ * describes how to get a file system representation as a char* from an NSString\n+ * and then using FileManager (!) convert it to an NSString.\n+ * But we want an NSString.\n+ * So the steps are\n+ * 1) Convert to NSString\n+ * 2) call [NSString fileSystemRepresentation] which gives us a char*\n+ * 3) Convert the returned char* to an NSString using FileManager (is there a better way?)\n+ *\/\n+NSString* NormalizedPathNSStringFromJavaString(JNIEnv *env, jstring pathStr) {\n+    if (pathStr == NULL) {\n+        return nil;\n+    }\n+    NSString *nsStr = JavaStringToNSString(env, pathStr);\n+    if (nsStr == NULL) {\n+        return nil;\n+    }\n+    const char* chs = [nsStr fileSystemRepresentation];\n+    int len = strlen(chs);\n+    NSString* result = [[NSFileManager defaultManager]\n+                  stringWithFileSystemRepresentation:chs length:len];\n+    return result;\n+}\n+\n+\/*\n+ * Given what is (potentially) a de-composed NSString, convert it to pre-composed\n+ * Then convert it into a Java String.\n+ *\/\n+jstring NormalizedPathJavaStringFromNSString(JNIEnv* env, NSString *str) {\n+    if (str == nil) {\n+        return NULL;\n+    }\n+    NSString *normStr = [str precomposedStringWithCanonicalMapping];\n+    return NSStringToJavaString(env, normStr);\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/JNIUtilities.m","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -26,6 +26,1 @@\n-\/*\n- * Must include this before JavaNativeFoundation.h to get jni.h from build\n- *\/\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-\n+#import \"JNIUtilities.h\"\n@@ -33,1 +28,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/NSApplicationAWT.h","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -163,3 +163,0 @@\n-\n-    \/\/ inform any interested parties that the AWT has arrived and is pumping\n-    [[NSNotificationCenter defaultCenter] postNotificationName:JNFRunLoopDidStartNotification object:self];\n@@ -274,1 +271,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:NO block:^(){\n@@ -329,2 +326,2 @@\n-    \/\/ Make sure that when we run in AWTRunLoopMode we don't exit randomly\n-    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:[JNFRunLoop javaRunLoopMode]];\n+    \/\/ Make sure that when we run in javaRunLoopMode we don't exit randomly\n+    [[NSRunLoop currentRunLoop] addPort:[NSPort port] forMode:[ThreadUtilities javaRunLoopMode]];\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/NSApplicationAWT.m","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-\/*\n- * Must include this before JavaNativeFoundation.h to get jni.h from build\n- *\/\n@@ -33,1 +30,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/PropertiesUtilities.h","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    jstring jKey = JNFNSToJavaString(env, key);\n+    jstring jKey = NSStringToJavaString(env, key);\n@@ -41,1 +41,1 @@\n-    NSString *value = JNFJavaToNSString(env, jValue);\n+    NSString *value = JavaStringToNSString(env, jValue);\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/PropertiesUtilities.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-@interface ThreadUtilities { }\n+@interface ThreadUtilities : NSObject { } \/* Extend NSObject so can call performSelectorOnMainThread *\/\n@@ -135,1 +135,0 @@\n-\/\/Wrappers for the corresponding JNFRunLoop methods with a check for main thread\n@@ -138,0 +137,1 @@\n++ (NSString*)javaRunLoopMode;\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/ThreadUtilities.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -37,0 +36,2 @@\n+static NSString* JavaRunLoopMode = @\"javaRunLoopMode\";\n+static NSArray<NSString*> *javaModes = nil;\n@@ -52,0 +53,9 @@\n++ (void)initialize {\n+    \/* All the standard modes plus ours *\/\n+    javaModes = [[NSArray alloc] initWithObjects:NSDefaultRunLoopMode,\n+                                           NSModalPanelRunLoopMode,\n+                                           NSEventTrackingRunLoopMode,\n+                                           JavaRunLoopMode,\n+                                           nil];\n+}\n+\n@@ -74,0 +84,18 @@\n+\/* This is needed because we can't directly pass a block to\n+ * performSelectorOnMainThreadWaiting .. since it expects a selector\n+ *\/\n++ (void)invokeBlock:(void (^)())block {\n+  block();\n+}\n+\n+\/*\n+ * When running a block where either we don't wait, or it needs to run on another thread\n+ * we need to copy it from stack to heap, use the copy in the call and release after use.\n+ * Do this only when we must because it could be expensive.\n+ * Note : if waiting cross-thread, possibly the stack allocated copy is accessible ?\n+ *\/\n++ (void)invokeBlockCopy:(void (^)(void))blockCopy {\n+  blockCopy();\n+  Block_release(blockCopy);\n+}\n+\n@@ -78,1 +106,6 @@\n-        [JNFRunLoop performOnMainThreadWaiting:wait withBlock:block];\n+        if (wait == YES) {\n+            [self performOnMainThread:@selector(invokeBlock:) on:self withObject:block waitUntilDone:YES];\n+        } else {\n+            void (^blockCopy)(void) = Block_copy(block);\n+            [self performOnMainThread:@selector(invokeBlockCopy:) on:self withObject:blockCopy waitUntilDone:NO];\n+        }\n@@ -86,1 +119,1 @@\n-        [JNFRunLoop performOnMainThread:aSelector on:target withObject:arg waitUntilDone:wait];\n+        [target performSelectorOnMainThread:aSelector withObject:arg waitUntilDone:wait modes:javaModes];\n@@ -90,0 +123,4 @@\n++ (NSString*)javaRunLoopMode {\n+    return JavaRunLoopMode;\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/ThreadUtilities.m","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -47,1 +46,1 @@\n-    returnValue = JNFNSToJavaString(env, getRunningJavaBundle());\n+    returnValue = NSStringToJavaString(env, getRunningJavaBundle());\n@@ -64,1 +63,1 @@\n-    returnValue = JNFNSToJavaString(env, [[NSBundle bundleWithIdentifier:@\"com.apple.JavaVM\"] bundlePath]);\n+    returnValue = NSStringToJavaString(env, [[NSBundle bundleWithIdentifier:@\"com.apple.JavaVM\"] bundlePath]);\n@@ -82,1 +81,1 @@\n-    returnValue = JNFNSToJavaString(env, (NSString*)machineName);\n+    returnValue = NSStringToJavaString(env, (NSString*)machineName);\n@@ -172,1 +171,1 @@\n-            returnValue = JNFNSToJavaString(env, (NSString *)mutableDisplayName);\n+            returnValue = NSStringToJavaString(env, (NSString *)mutableDisplayName);\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/AquaFileView.m","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-\/\/ Must include this before JavaNativeFoundation.h to get jni.h from build\n@@ -30,2 +29,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/AquaLookAndFeel.m","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/AquaNativeResources.m","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n+#import \"JNIUtilities.h\"\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/JRSUIConstantSync.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n+#import \"JNIUtilities.h\"\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/JRSUIController.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n+#import \"JNIUtilities.h\"\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/JRSUIFocus.m","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/ScreenMenu.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -112,1 +111,1 @@\n-    (*env)->CallVoidMethod(env, self.javaObject, jm_ScreenMenu_invokeOpenLater); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    (*env)->CallVoidMethod(env, self.javaObject, jm_ScreenMenu_invokeOpenLater);\n@@ -132,1 +131,1 @@\n-    (*env)->CallVoidMethod(env, self.javaObject, jm_ScreenMenu_invokeMenuClosing); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+    (*env)->CallVoidMethod(env, self.javaObject, jm_ScreenMenu_invokeMenuClosing);\n@@ -153,1 +152,1 @@\n-                    NSMinY(rect), NSMinX(rect), NSMaxY(rect), NSMaxX(rect)); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+                    NSMinY(rect), NSMinX(rect), NSMaxY(rect), NSMaxX(rect));\n@@ -159,0 +158,10 @@\n+\/*\n+ * The input is an NSTimeInterval (a double representing seconds and fractions of seconds)\n+ * 0.0 means midnight Jan 1, 2001.\n+ * The output is a Java long representing time in milliseconds since midnight Jan 1st 1970.\n+ * There is a Cocoa constant representing that difference : NSTimeIntervalSince1970\n+ *\/\n+static jlong NSTimeIntervalToJavaMilliseconds(NSTimeInterval interval) {\n+    NSTimeInterval interval1970 = interval + NSTimeIntervalSince1970;\n+    return (jlong)(interval1970 * 1000);\n+}\n@@ -190,1 +199,1 @@\n-    jlong javaWhen = JNFNSTimeIntervalToJavaMillis([event timestamp]);\n+    jlong javaWhen = NSTimeIntervalToJavaMilliseconds([event timestamp]);\n@@ -198,1 +207,1 @@\n-             javaKind, javaX, javaY, javaModifiers, javaWhen); \/\/ AWT_THREADING Safe (AWTRunLoopMode)\n+             javaKind, javaX, javaY, javaModifiers, javaWhen);\n@@ -224,1 +233,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^{\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^{\n@@ -251,1 +260,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^{\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^{\n","filename":"src\/java.desktop\/macosx\/native\/libosxui\/ScreenMenu.m","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -229,1 +228,1 @@\n-        [JNFRunLoop performOnMainThreadWaiting:NO withBlock:^() {\n+        [ThreadUtilities performOnMainThreadWaiting:NO block:^() {\n@@ -246,1 +245,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n@@ -285,1 +284,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n@@ -344,1 +343,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n@@ -433,1 +432,1 @@\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+    [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n@@ -448,1 +447,1 @@\n-        [JNFRunLoop performOnMainThreadWaiting:YES withBlock:^(){\n+        [ThreadUtilities performOnMainThreadWaiting:YES block:^(){\n","filename":"src\/java.desktop\/macosx\/native\/libsplashscreen\/splashscreen_sys.m","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,2 +354,1 @@\n-                             getLocalGraphicsEnvironment()).\n-                                displayChanged();\n+                             getLocalGraphicsEnvironment()).rebuildDevices();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XToolkit.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -332,9 +332,2 @@\n-    public Rectangle getBounds() {\n-        Rectangle rect = pGetBounds(device.getScreen());\n-        if (getScale() != 1) {\n-            rect.x = scaleDown(rect.x);\n-            rect.y = scaleDown(rect.y);\n-            rect.width = scaleDown(rect.width);\n-            rect.height = scaleDown(rect.height);\n-        }\n-        return rect;\n+    public final Rectangle getBounds() {\n+        return device.getBounds();\n@@ -343,2 +336,0 @@\n-    private native Rectangle pGetBounds(int screenNum);\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsConfig.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import sun.java2d.pipe.Region;\n@@ -56,1 +57,5 @@\n-    int screen;\n+    \/**\n+     * X11 screen number. This identifier can become non-valid at any time\n+     * therefore methods, which is using this id should be ready to it.\n+     *\/\n+    private volatile int screen;\n@@ -108,0 +113,19 @@\n+    public int scaleUp(int x) {\n+        return Region.clipRound(x * (double)getScaleFactor());\n+    }\n+\n+    public int scaleDown(int x) {\n+        return Region.clipRound(x \/ (double)getScaleFactor());\n+    }\n+\n+    public Rectangle getBounds() {\n+        Rectangle rect = pGetBounds(getScreen());\n+        if (getScaleFactor() != 1) {\n+            rect.x = scaleDown(rect.x);\n+            rect.y = scaleDown(rect.y);\n+            rect.width = scaleDown(rect.width);\n+            rect.height = scaleDown(rect.height);\n+        }\n+        return rect;\n+    }\n+\n@@ -168,2 +192,2 @@\n-                        ret[i] = XRGraphicsConfig.getConfig(this, visNum, depth,                                getConfigColormap(i, screen),\n-                                doubleBuffer);\n+                        ret[i] = XRGraphicsConfig.getConfig(this, visNum, depth,\n+                                getConfigColormap(i, screen), doubleBuffer);\n@@ -274,1 +298,0 @@\n-    private static native void resetNativeData(int screen);\n@@ -276,0 +299,1 @@\n+    private native Rectangle pGetBounds(int screenNum);\n@@ -517,1 +541,0 @@\n-        isXrandrExtensionSupported();\n@@ -547,0 +570,4 @@\n+\n+    public void invalidate(X11GraphicsDevice device) {\n+        screen = device.screen;\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsDevice.java","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.ref.WeakReference;\n@@ -34,0 +35,1 @@\n+import java.util.ArrayList;\n@@ -35,0 +37,4 @@\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.Map;\n@@ -36,0 +42,1 @@\n+import sun.awt.X11.XToolkit;\n@@ -40,1 +47,0 @@\n-import sun.util.logging.PlatformLogger;\n@@ -52,5 +58,0 @@\n-    private static final PlatformLogger log = PlatformLogger.getLogger(\"sun.awt.X11GraphicsEnvironment\");\n-    private static final PlatformLogger screenLog = PlatformLogger.getLogger(\"sun.awt.screen.X11GraphicsEnvironment\");\n-\n-    private static Boolean xinerState;\n-\n@@ -172,0 +173,11 @@\n+    \/** Available X11 screens. *\/\n+    private final Map<Integer, X11GraphicsDevice> devices = new HashMap<>(5);\n+\n+    \/**\n+     * The key in the {@link #devices} for the main screen.\n+     *\/\n+    private int mainScreen;\n+\n+    \/\/ list of invalidated graphics devices (those which were removed)\n+    private List<WeakReference<X11GraphicsDevice>> oldDevices = new ArrayList<>();\n+\n@@ -178,0 +190,4 @@\n+    protected native int getNumScreens();\n+\n+    private native int getDefaultScreenNum();\n+\n@@ -179,0 +195,6 @@\n+        if (isHeadless()) {\n+            return;\n+        }\n+\n+        \/* Populate the device table *\/\n+        rebuildDevices();\n@@ -181,1 +203,4 @@\n-    protected native int getNumScreens();\n+    \/**\n+     * Initialize the native list of devices.\n+     *\/\n+    private static native void initNativeData();\n@@ -183,2 +208,12 @@\n-    protected GraphicsDevice makeScreenDevice(int screennum) {\n-        return new X11GraphicsDevice(screennum);\n+    \/**\n+     * Updates the list of devices and notify listeners.\n+     *\/\n+    public void rebuildDevices() {\n+        XToolkit.awtLock();\n+        try {\n+            initNativeData();\n+            initDevices();\n+        } finally {\n+            XToolkit.awtUnlock();\n+        }\n+        displayChanged();\n@@ -187,1 +222,0 @@\n-    private native int getDefaultScreenNum();\n@@ -189,1 +223,1 @@\n-     * Returns the default screen graphics device.\n+     * (Re)create all X11GraphicsDevices, reuses a devices if it is possible.\n@@ -191,3 +225,6 @@\n-    public GraphicsDevice getDefaultScreenDevice() {\n-        GraphicsDevice[] screens = getScreenDevices();\n-        if (screens.length == 0) {\n+    private synchronized void initDevices() {\n+        Map<Integer, X11GraphicsDevice> old = new HashMap<>(devices);\n+        devices.clear();\n+\n+        int numScreens = getNumScreens();\n+        if (numScreens == 0) {\n@@ -197,1 +234,42 @@\n-        return screens[0 < index && index < screens.length ? index : 0];\n+        mainScreen = 0 < index && index < screens.length ? index : 0;\n+\n+        for (int id = 0; id < numScreens; ++id) {\n+            devices.put(id, old.containsKey(id) ? old.remove(id) :\n+                                                  new X11GraphicsDevice(id));\n+        }\n+        \/\/ if a device was not reused it should be invalidated\n+        for (X11GraphicsDevice gd : old.values()) {\n+            oldDevices.add(new WeakReference<>(gd));\n+        }\n+        \/\/ Need to notify old devices, in case the user hold the reference to it\n+        for (ListIterator<WeakReference<X11GraphicsDevice>> it =\n+             oldDevices.listIterator(); it.hasNext(); ) {\n+            X11GraphicsDevice gd = it.next().get();\n+            if (gd != null) {\n+                gd.invalidate(devices.get(mainScreen));\n+                gd.displayChanged();\n+            } else {\n+                \/\/ no more references to this device, remove it\n+                it.remove();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public synchronized GraphicsDevice getDefaultScreenDevice() {\n+        return devices.get(mainScreen);\n+    }\n+\n+    @Override\n+    public synchronized GraphicsDevice[] getScreenDevices() {\n+        return devices.values().toArray(new X11GraphicsDevice[0]);\n+    }\n+\n+    public synchronized GraphicsDevice getScreenDevice(int screen) {\n+        return devices.get(screen);\n+    }\n+\n+    @Override\n+    protected GraphicsDevice makeScreenDevice(int screennum) {\n+        throw new UnsupportedOperationException(\"This method is unused and\" +\n+                \"should not be called in this implementation\");\n@@ -292,9 +370,1 @@\n-        if (xinerState == null) {\n-            \/\/ pRunningXinerama() simply returns a global boolean variable,\n-            \/\/ so there is no need to synchronize here\n-            xinerState = Boolean.valueOf(pRunningXinerama());\n-            if (screenLog.isLoggable(PlatformLogger.Level.FINER)) {\n-                screenLog.finer(\"Running Xinerama: \" + xinerState);\n-            }\n-        }\n-        return xinerState.booleanValue();\n+        return pRunningXinerama();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":95,"deletions":25,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,5 +26,0 @@\n-\/*\n- * To change this template, choose Tools | Templates\n- * and open the template in the editor.\n- *\/\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRGraphicsConfig.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-AwtScreenDataPtr x11Screens;\n+AwtScreenDataPtr x11Screens; \/\/ should be guarded by AWT_LOCK()\/AWT_UNLOCK()\n@@ -594,2 +594,0 @@\n-    int32_t locNumScr = 0;\n-    XineramaScreenInfo *xinInfo;\n@@ -625,17 +623,0 @@\n-        } else {\n-            DTRACE_PRINTLN(\"calling XineramaQueryScreens func\");\n-            xinInfo = (*XineramaQueryScreens)(awt_display, &locNumScr);\n-            if (xinInfo != NULL) {\n-                if (locNumScr > XScreenCount(awt_display)) {\n-                    DTRACE_PRINTLN(\"Enabling Xinerama support\");\n-                    usingXinerama = True;\n-                    \/* set global number of screens *\/\n-                    DTRACE_PRINTLN1(\" num screens = %i\\n\", locNumScr);\n-                    awt_numScreens = locNumScr;\n-                } else {\n-                    DTRACE_PRINTLN(\"XineramaQueryScreens <= XScreenCount\");\n-                }\n-                XFree(xinInfo);\n-            } else {\n-                DTRACE_PRINTLN(\"calling XineramaQueryScreens didn't work\");\n-            }\n@@ -648,0 +629,80 @@\n+static void resetNativeData(int screen) {\n+    \/*\n+     * Reset references to the various configs; the actual native config data\n+     * will be free'd later by the Disposer mechanism when the Java-level\n+     * X11GraphicsConfig objects go away.  By setting these values to NULL,\n+     * we ensure that they will be reinitialized as necessary (for example,\n+     * see the getNumConfigs() method).\n+     *\/\n+    if (x11Screens[screen].configs) {\n+        free(x11Screens[screen].configs);\n+        x11Screens[screen].configs = NULL;\n+    }\n+    x11Screens[screen].defaultConfig = NULL;\n+    x11Screens[screen].numConfigs = 0;\n+}\n+\n+\/*\n+ * Class:     sun_awt_X11GraphicsEnvironment\n+ * Method:    initDevices\n+ * Signature: (Z)V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_awt_X11GraphicsEnvironment_initNativeData(JNIEnv *env, jobject this) {\n+    usingXinerama = False;\n+    if (x11Screens) {\n+        for (int i = 0; i < awt_numScreens; ++i) {\n+            resetNativeData(i);\n+        }\n+        free((void *)x11Screens);\n+        x11Screens = NULL;\n+        awt_numScreens = 0;\n+    }\n+\n+    \/\/ will try xinerama first\n+    if (XineramaQueryScreens) {\n+        int32_t locNumScr = 0;\n+        XineramaScreenInfo *xinInfo;\n+        DTRACE_PRINTLN(\"calling XineramaQueryScreens func\");\n+        xinInfo = (*XineramaQueryScreens)(awt_display, &locNumScr);\n+        if (xinInfo != NULL) {\n+            if (locNumScr > XScreenCount(awt_display)) {\n+                DTRACE_PRINTLN(\"Enabling Xinerama support\");\n+                usingXinerama = True;\n+                \/* set global number of screens *\/\n+                DTRACE_PRINTLN1(\" num screens = %i\\n\", locNumScr);\n+                awt_numScreens = locNumScr;\n+            } else {\n+                DTRACE_PRINTLN(\"XineramaQueryScreens <= XScreenCount\");\n+            }\n+            XFree(xinInfo);\n+        } else {\n+            DTRACE_PRINTLN(\"calling XineramaQueryScreens didn't work\");\n+        }\n+    }\n+    \/\/ if xinerama is not enabled or does not work will use X11\n+    if (!usingXinerama) {\n+        awt_numScreens =  XScreenCount(awt_display);\n+    }\n+    DTRACE_PRINTLN1(\"allocating %i screens\\n\", awt_numScreens);\n+    \/* Allocate screen data structure array *\/\n+    x11Screens = calloc(awt_numScreens, sizeof(AwtScreenData));\n+    if (x11Screens == NULL) {\n+        JNU_ThrowOutOfMemoryError((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2),\n+                                  NULL);\n+        return;\n+    }\n+\n+    for (int i = 0; i < awt_numScreens; i++) {\n+        if (usingXinerama) {\n+            \/* All Xinerama screens use the same X11 root for now *\/\n+            x11Screens[i].root = RootWindow(awt_display, 0);\n+        }\n+        else {\n+            x11Screens[i].root = RootWindow(awt_display, i);\n+        }\n+        x11Screens[i].defaultConfig = makeDefaultConfig(env, i);\n+        JNU_CHECK_EXCEPTION(env);\n+    }\n+}\n+\n@@ -695,26 +756,0 @@\n-\n-    if (!usingXinerama) {\n-        awt_numScreens =  XScreenCount(awt_display);\n-    }\n-\n-    DTRACE_PRINTLN1(\"allocating %i screens\\n\", awt_numScreens);\n-    \/* Allocate screen data structure array *\/\n-    x11Screens = calloc(awt_numScreens, sizeof(AwtScreenData));\n-    if (x11Screens == NULL) {\n-        JNU_ThrowOutOfMemoryError((JNIEnv *)JNU_GetEnv(jvm, JNI_VERSION_1_2),\n-                                  NULL);\n-        return NULL;\n-    }\n-\n-    for (i = 0; i < awt_numScreens; i++) {\n-        if (usingXinerama) {\n-            \/* All Xinerama screens use the same X11 root for now *\/\n-            x11Screens[i].root = RootWindow(awt_display, 0);\n-        }\n-        else {\n-            x11Screens[i].root = RootWindow(awt_display, i);\n-        }\n-        x11Screens[i].defaultConfig = makeDefaultConfig(env, i);\n-        JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-    }\n-\n@@ -940,0 +975,1 @@\n+    AWT_LOCK();\n@@ -941,1 +977,3 @@\n-    return x11Screens[screen].numConfigs;\n+    int configs = x11Screens[screen].numConfigs;\n+    AWT_UNLOCK();\n+    return configs;\n@@ -954,1 +992,1 @@\n-\n+    AWT_LOCK();\n@@ -956,5 +994,4 @@\n-    if (index == 0) {\n-        return ((jint)x11Screens[screen].defaultConfig->awt_visInfo.visualid);\n-    } else {\n-        return ((jint)x11Screens[screen].configs[index]->awt_visInfo.visualid);\n-    }\n+    jint id = (jint) (index == 0 ? x11Screens[screen].defaultConfig\n+                                 : x11Screens[screen].configs[index])->awt_visInfo.visualid;\n+    AWT_UNLOCK();\n+    return id;\n@@ -973,1 +1010,1 @@\n-\n+    AWT_LOCK();\n@@ -975,5 +1012,4 @@\n-    if (index == 0) {\n-        return ((jint)x11Screens[screen].defaultConfig->awt_visInfo.depth);\n-    } else {\n-        return ((jint)x11Screens[screen].configs[index]->awt_visInfo.depth);\n-    }\n+    jint depth = (jint) (index == 0 ? x11Screens[screen].defaultConfig\n+                                    : x11Screens[screen].configs[index])->awt_visInfo.depth;\n+    AWT_UNLOCK();\n+    return depth;\n@@ -992,1 +1028,1 @@\n-\n+    AWT_LOCK();\n@@ -994,5 +1030,4 @@\n-    if (index == 0) {\n-        return ((jint)x11Screens[screen].defaultConfig->awt_cmap);\n-    } else {\n-        return ((jint)x11Screens[screen].configs[index]->awt_cmap);\n-    }\n+    jint colormap = (jint) (index == 0 ? x11Screens[screen].defaultConfig\n+                                       : x11Screens[screen].configs[index])->awt_cmap;\n+    AWT_UNLOCK();\n+    return colormap;\n@@ -1001,23 +1036,0 @@\n-\/*\n- * Class:     sun_awt_X11GraphicsDevice\n- * Method:    resetNativeData\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_sun_awt_X11GraphicsDevice_resetNativeData\n-    (JNIEnv *env, jclass x11gd, jint screen)\n-{\n-    \/*\n-     * Reset references to the various configs; the actual native config data\n-     * will be free'd later by the Disposer mechanism when the Java-level\n-     * X11GraphicsConfig objects go away.  By setting these values to NULL,\n-     * we ensure that they will be reinitialized as necessary (for example,\n-     * see the getNumConfigs() method).\n-     *\/\n-    if (x11Screens[screen].configs) {\n-        free(x11Screens[screen].configs);\n-        x11Screens[screen].configs = NULL;\n-    }\n-    x11Screens[screen].defaultConfig = NULL;\n-    x11Screens[screen].numConfigs = 0;\n-}\n@@ -1131,0 +1143,1 @@\n+    AWT_LOCK();\n@@ -1152,0 +1165,1 @@\n+        AWT_UNLOCK();\n@@ -1170,0 +1184,1 @@\n+    AWT_UNLOCK();\n@@ -1213,1 +1228,1 @@\n- * Class:     sun_awt_X11GraphicsConfig\n+ * Class:     sun_awt_X11GraphicsDevice\n@@ -1218,1 +1233,1 @@\n-Java_sun_awt_X11GraphicsConfig_pGetBounds(JNIEnv *env, jobject this, jint screen)\n+Java_sun_awt_X11GraphicsDevice_pGetBounds(JNIEnv *env, jobject this, jint screen)\n@@ -1223,1 +1238,0 @@\n-    AwtGraphicsConfigDataPtr adata;\n@@ -1227,3 +1241,0 @@\n-    adata = (AwtGraphicsConfigDataPtr)\n-        JNU_GetLongFieldAsPtr(env, this, x11GraphicsConfigIDs.aData);\n-\n@@ -1264,2 +1275,1 @@\n-            XGetWindowAttributes(awt_display,\n-                    RootWindow(awt_display, adata->awt_visInfo.screen),\n+            XGetWindowAttributes(awt_display, RootWindow(awt_display, screen),\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_GraphicsEnv.c","additions":106,"deletions":96,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -123,0 +123,1 @@\n+    AWT_LOCK();\n@@ -125,1 +126,1 @@\n-\n+    AWT_UNLOCK();\n@@ -148,0 +149,1 @@\n+    AWT_LOCK();\n@@ -151,0 +153,1 @@\n+    AWT_UNLOCK();\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/xawt\/XToolkit.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"RMID\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"RMID\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/java.rmi\/share\/man\/rmid.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"RMIREGISTRY\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"RMIREGISTRY\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/java.rmi\/share\/man\/rmiregistry.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JRUNSCRIPT\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JRUNSCRIPT\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/java.scripting\/share\/man\/jrunscript.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n@@ -29,88 +28,1 @@\n-\n-\n-@interface JNFVectorCoercion : NSObject <JNFTypeCoercion> { }\n-@end\n-\n-@implementation JNFVectorCoercion\n-\n-- (jobject) coerceNSObject:(id)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {\n-    static JNF_CLASS_CACHE(jc_Vector, \"java\/util\/Vector\");\n-    static JNF_CTOR_CACHE(jm_Vector_ctor, jc_Vector, \"(I)V\");\n-    static JNF_MEMBER_CACHE(jm_Vector_add, jc_Vector, \"add\", \"(Ljava\/lang\/Object;)Z\");\n-\n-    NSArray *nsArray = (NSArray *)obj;\n-    jobject javaArray = JNFNewObject(env, jm_Vector_ctor, (jint)[nsArray count]);\n-\n-    for (id obj in nsArray) {\n-        jobject jobj = [coercer coerceNSObject:obj withEnv:env usingCoercer:coercer];\n-        JNFCallBooleanMethod(env, javaArray, jm_Vector_add, jobj);\n-        if (jobj != NULL) (*env)->DeleteLocalRef(env, jobj);\n-    }\n-\n-    return javaArray;\n-}\n-\n-- (id) coerceJavaObject:(jobject)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {\n-    return nil;\n-}\n-\n-@end\n-\n-\n-@interface JNFHashtableCoercion : NSObject <JNFTypeCoercion> { }\n-@end\n-\n-@implementation JNFHashtableCoercion\n-\n-- (jobject) coerceNSObject:(id)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {\n-    static JNF_CLASS_CACHE(jc_Hashtable, \"java\/util\/Hashtable\");\n-    static JNF_CTOR_CACHE(jm_Hashtable_ctor, jc_Hashtable, \"()V\");\n-    static JNF_MEMBER_CACHE(jm_Hashtable_put, jc_Hashtable, \"put\", \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\");\n-\n-    NSDictionary *nsDict = (NSDictionary *)obj;\n-    NSEnumerator *keyEnum = [nsDict keyEnumerator];\n-\n-    jobject jHashTable = JNFNewObject(env, jm_Hashtable_ctor);\n-\n-    id key = nil;\n-    while ((key = [keyEnum nextObject]) != nil) {\n-        jobject jkey = [coercer coerceNSObject:key withEnv:env usingCoercer:coercer];\n-\n-        id value = [nsDict objectForKey:key];\n-        jobject jvalue = [coercer coerceNSObject:value withEnv:env usingCoercer:coercer];\n-\n-        JNFCallObjectMethod(env, jHashTable, jm_Hashtable_put, jkey, jvalue);\n-\n-        if (jkey != NULL) (*env)->DeleteLocalRef(env, jkey);\n-        if (jvalue != NULL) (*env)->DeleteLocalRef(env, jvalue);\n-    }\n-\n-    return jHashTable;\n-}\n-\n-- (id) coerceJavaObject:(jobject)obj withEnv:(JNIEnv *)env usingCoercer:(JNFTypeCoercion *)coercer {\n-    return nil;\n-}\n-\n-@end\n-\n-\n-\n-NSDictionary *realmConfigsForRealms(SCDynamicStoreRef store, NSArray *realms) {\n-    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n-\n-    for (NSString *realm in realms) {\n-        CFTypeRef realmInfo = SCDynamicStoreCopyValue(store, (CFStringRef) [NSString stringWithFormat:@\"Kerberos:%@\", realm]);\n-\n-        if (realmInfo == NULL || CFGetTypeID(realmInfo) != CFDictionaryGetTypeID()) {\n-            if (realmInfo) CFRelease(realmInfo);\n-            return nil;\n-        }\n-\n-        [dict setObject:(NSArray *)realmInfo forKey:realm];\n-        CFRelease(realmInfo);\n-    }\n-\n-    return dict;\n-}\n-\n+#import \"jni_util.h\"\n@@ -120,0 +32,3 @@\n+#define KERBEROS_REALM_INFO @\"Kerberos:%@\"\n+\n+JavaVM *localVM;\n@@ -122,1 +37,1 @@\n-   NSArray *keys = (NSArray *)changedKeys;\n+    NSArray *keys = (NSArray *)changedKeys;\n@@ -126,5 +41,20 @@\n-    JNFPerformEnvBlock(JNFThreadDetachOnThreadDeath | JNFThreadSetSystemClassLoaderOnAttach | JNFThreadAttachAsDaemon, ^(JNIEnv *env) {\n-        static JNF_CLASS_CACHE(jc_Config, \"sun\/security\/krb5\/Config\");\n-        static JNF_STATIC_MEMBER_CACHE(jm_Config_refresh, jc_Config, \"refresh\", \"()V\");\n-        JNFCallStaticVoidMethod(env, jm_Config_refresh);\n-    });\n+    JNIEnv *env;\n+    bool createdFromAttach = FALSE;\n+    jint status = (*localVM)->GetEnv(localVM, (void**)&env, JNI_VERSION_1_2);\n+    if (status == JNI_EDETACHED) {\n+        status = (*localVM)->AttachCurrentThreadAsDaemon(localVM, (void**)&env, NULL);\n+        createdFromAttach = TRUE;\n+    }\n+    if (status == 0) {\n+        jclass jc_Config = (*env)->FindClass(env, \"sun\/security\/krb5\/Config\");\n+        CHECK_NULL(jc_Config);\n+        jmethodID jm_Config_refresh = (*env)->GetStaticMethodID(env, jc_Config, \"refresh\", \"()V\");\n+        CHECK_NULL(jm_Config_refresh);\n+        (*env)->CallStaticVoidMethod(env, jc_Config, jm_Config_refresh);\n+        if ((*env)->ExceptionOccurred(env) != NULL) {\n+            (*env)->ExceptionClear(env);\n+        }\n+        if (createdFromAttach) {\n+            (*localVM)->DetachCurrentThread(localVM);\n+        }\n+    }\n@@ -138,0 +68,7 @@\n+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; \\\n+    @try {\n+        (*env)->GetJavaVM(env, &localVM);\n+        SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java\"), _SCDynamicStoreCallBack, NULL);\n+        if (store == NULL) {\n+            return;\n+        }\n@@ -139,6 +76,2 @@\n-JNF_COCOA_ENTER(env);\n-\n-    SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java\"), _SCDynamicStoreCallBack, NULL);\n-    if (store == NULL) {\n-        return;\n-    }\n+        NSArray *keys = [NSArray arrayWithObjects:KERBEROS_DEFAULT_REALMS, KERBEROS_DEFAULT_REALM_MAPPINGS, nil];\n+        SCDynamicStoreSetNotificationKeys(store, (CFArrayRef) keys, NULL);\n@@ -146,2 +79,5 @@\n-    NSArray *keys = [NSArray arrayWithObjects:KERBEROS_DEFAULT_REALMS, KERBEROS_DEFAULT_REALM_MAPPINGS, nil];\n-    SCDynamicStoreSetNotificationKeys(store, (CFArrayRef) keys, NULL);\n+        CFRunLoopSourceRef rls = SCDynamicStoreCreateRunLoopSource(NULL, store, 0);\n+        if (rls != NULL) {\n+            CFRunLoopAddSource(CFRunLoopGetMain(), rls, kCFRunLoopDefaultMode);\n+            CFRelease(rls);\n+        }\n@@ -149,4 +85,5 @@\n-    CFRunLoopSourceRef rls = SCDynamicStoreCreateRunLoopSource(NULL, store, 0);\n-    if (rls != NULL) {\n-        CFRunLoopAddSource(CFRunLoopGetMain(), rls, kCFRunLoopDefaultMode);\n-        CFRelease(rls);\n+        CFRelease(store);\n+    } @catch (NSException *e) {\n+        NSLog(@\"%@\", [e callStackSymbols]);\n+    } @finally {\n+        [pool drain];\n@@ -154,0 +91,1 @@\n+}\n@@ -155,4 +93,4 @@\n-    CFRelease(store);\n-\n-JNF_COCOA_EXIT(env);\n-\n+#define ADD(list, str) { \\\n+    jobject localeObj = (*env)->NewStringUTF(env, [str UTF8String]); \\\n+    (*env)->CallBooleanMethod(env, list, jm_listAdd, localeObj); \\\n+    (*env)->DeleteLocalRef(env, localeObj); \\\n@@ -161,0 +99,2 @@\n+#define ADDNULL(list) (*env)->CallBooleanMethod(env, list, jm_listAdd, NULL)\n+\n@@ -164,1 +104,1 @@\n- * Signature: ()Ljava\/util\/Hashtable;\n+ * Signature: ()Ljava\/util\/List;\n@@ -167,1 +107,0 @@\n-    jobject jHashTable = NULL;\n@@ -169,1 +108,1 @@\n-JNF_COCOA_ENTER(env);\n+    jobject newList = 0;\n@@ -171,4 +110,4 @@\n-    SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java-kerberos\"), NULL, NULL);\n-    if (store == NULL) {\n-        return NULL;\n-    }\n+    SCDynamicStoreRef store = NULL;\n+    CFTypeRef realms = NULL;\n+    CFTypeRef realmMappings = NULL;\n+    CFTypeRef realmInfo = NULL;\n@@ -176,6 +115,6 @@\n-    CFTypeRef realms = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS);\n-    if (realms == NULL || CFGetTypeID(realms) != CFArrayGetTypeID()) {\n-        if (realms) CFRelease(realms);\n-        CFRelease(store);\n-        return NULL;\n-    }\n+    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; \\\n+    @try {\n+        SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java-kerberos\"), NULL, NULL);\n+        if (store == NULL) {\n+            return NULL;\n+        }\n@@ -183,1 +122,4 @@\n-    CFTypeRef realmMappings = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS);\n+        CFTypeRef realms = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS);\n+        if (realms == NULL || CFGetTypeID(realms) != CFArrayGetTypeID()) {\n+            return NULL;\n+        }\n@@ -185,1 +127,41 @@\n-    if (realmMappings == NULL || CFGetTypeID(realmMappings) != CFArrayGetTypeID()) {\n+        \/\/ This methods returns a ArrayList<String>:\n+        \/\/ (realm kdc* null) null (mapping-domain mapping-realm)*\n+        jclass jc_arrayListClass = (*env)->FindClass(env, \"java\/util\/ArrayList\");\n+        CHECK_NULL_RETURN(jc_arrayListClass, NULL);\n+        jmethodID jm_arrayListCons = (*env)->GetMethodID(env, jc_arrayListClass, \"<init>\", \"()V\");\n+        CHECK_NULL_RETURN(jm_arrayListCons, NULL);\n+        jmethodID jm_listAdd = (*env)->GetMethodID(env, jc_arrayListClass, \"add\", \"(Ljava\/lang\/Object;)Z\");\n+        CHECK_NULL_RETURN(jm_listAdd, NULL);\n+        newList = (*env)->NewObject(env, jc_arrayListClass, jm_arrayListCons);\n+        CHECK_NULL_RETURN(newList, NULL);\n+\n+        for (NSString *realm in (NSArray*)realms) {\n+            if (realmInfo) CFRelease(realmInfo); \/\/ for the previous realm\n+            realmInfo = SCDynamicStoreCopyValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, realm]);\n+            if (realmInfo == NULL || CFGetTypeID(realmInfo) != CFDictionaryGetTypeID()) {\n+                continue;\n+            }\n+\n+            ADD(newList, realm);\n+            NSDictionary* ri = (NSDictionary*)realmInfo;\n+            for (NSDictionary* k in (NSArray*)ri[@\"kdc\"]) {\n+                ADD(newList, k[@\"host\"]);\n+            }\n+            ADDNULL(newList);\n+        }\n+        ADDNULL(newList);\n+\n+        CFTypeRef realmMappings = SCDynamicStoreCopyValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS);\n+        if (realmMappings != NULL && CFGetTypeID(realmMappings) == CFArrayGetTypeID()) {\n+            for (NSDictionary* d in (NSArray *)realmMappings) {\n+                for (NSString* s in d) {\n+                    ADD(newList, s);\n+                    ADD(newList, d[s]);\n+                }\n+            }\n+        }\n+    } @catch (NSException *e) {\n+        NSLog(@\"%@\", [e callStackSymbols]);\n+    } @finally {\n+        [pool drain];\n+        if (realmInfo) CFRelease(realmInfo);\n@@ -187,19 +169,2 @@\n-        CFRelease(realms);\n-        CFRelease(store);\n-        return NULL;\n-    }\n-\n-    NSMutableDictionary *dict = [NSMutableDictionary dictionary];\n-\n-    if (CFArrayGetCount(realms) > 0) {\n-        NSDictionary *defaultRealmsDict = [NSDictionary dictionaryWithObject:[(NSArray *)realms objectAtIndex:0] forKey:@\"default_realm\"];\n-        [dict setObject:defaultRealmsDict forKey:@\"libdefaults\"];\n-\n-        NSDictionary *realmConfigs = realmConfigsForRealms(store, (NSArray *)realms);\n-        [dict setObject:realmConfigs forKey:@\"realms\"];\n-    }\n-    CFRelease(realms);\n-    CFRelease(store);\n-\n-    if (CFArrayGetCount(realmMappings) > 0) {\n-        [dict setObject:[(NSArray *)realmMappings objectAtIndex:0] forKey:@\"domain_realm\"];\n+        if (realms) CFRelease(realms);\n+        if (store) CFRelease(store);\n@@ -207,16 +172,1 @@\n-    CFRelease(realmMappings);\n-\n-\n-    \/\/ create and load a coercer with all of the different coercions to convert each type of object\n-    JNFTypeCoercer *coercer = [[[JNFTypeCoercer alloc] init] autorelease];\n-    [JNFDefaultCoercions addStringCoercionTo:coercer];\n-    [JNFDefaultCoercions addNumberCoercionTo:coercer];\n-    [coercer addCoercion:[[[JNFHashtableCoercion alloc] init] autorelease] forNSClass:[NSDictionary class] javaClass:@\"java\/util\/Map\"];\n-    [coercer addCoercion:[[[JNFVectorCoercion alloc] init] autorelease] forNSClass:[NSArray class] javaClass:@\"java\/util\/List\"];\n-\n-    \/\/ convert Cocoa graph to Java graph\n-    jHashTable = [coercer coerceNSObject:dict withEnv:env];\n-\n-JNF_COCOA_EXIT(env);\n-\n-    return jHashTable;\n+    return newList;\n","filename":"src\/java.security.jgss\/macosx\/native\/libosxkrb5\/SCDynamicStoreConfig.m","additions":112,"deletions":162,"binary":false,"changes":274,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.Collection;\n@@ -31,0 +30,2 @@\n+import java.util.Iterator;\n+import java.util.List;\n@@ -36,1 +37,6 @@\n-    private static native Hashtable<String, Object> getKerberosConfig();\n+\n+    \/**\n+     * Returns the dynamic store setting for kerberos in a string array.\n+     * (realm kdc* null) null (mapping-domain mapping-realm)*\n+     *\/\n+    private static native List<String> getKerberosConfig();\n@@ -54,43 +60,0 @@\n-    private static Vector<String> unwrapHost(\n-            Collection<Hashtable<String, String>> c) {\n-        Vector<String> vector = new Vector<String>();\n-        for (Hashtable<String, String> m : c) {\n-            vector.add(m.get(\"host\"));\n-        }\n-        return vector;\n-    }\n-\n-    \/**\n-     * convertRealmConfigs: Maps the Object graph that we get from JNI to the\n-     * object graph that Config expects. Also the items inside the kdc array\n-     * are wrapped inside Hashtables\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    private static Hashtable<String, Object>\n-            convertRealmConfigs(Hashtable<String, ?> configs) {\n-        Hashtable<String, Object> realmsTable = new Hashtable<String, Object>();\n-\n-        for (String realm : configs.keySet()) {\n-            \/\/ get the kdc\n-            Hashtable<String, Collection<?>> map =\n-                    (Hashtable<String, Collection<?>>) configs.get(realm);\n-            Hashtable<String, Vector<String>> realmMap =\n-                    new Hashtable<String, Vector<String>>();\n-\n-            \/\/ put the kdc into the realmMap\n-            Collection<Hashtable<String, String>> kdc =\n-                    (Collection<Hashtable<String, String>>) map.get(\"kdc\");\n-            if (kdc != null) realmMap.put(\"kdc\", unwrapHost(kdc));\n-\n-            \/\/ put the admin server into the realmMap\n-            Collection<Hashtable<String, String>> kadmin =\n-                    (Collection<Hashtable<String, String>>) map.get(\"kadmin\");\n-            if (kadmin != null) realmMap.put(\"admin_server\", unwrapHost(kadmin));\n-\n-            \/\/ add the full entry to the realmTable\n-            realmsTable.put(realm, realmMap);\n-        }\n-\n-        return realmsTable;\n-    }\n-\n@@ -105,2 +68,2 @@\n-        Hashtable<String, Object> stanzaTable = getKerberosConfig();\n-        if (stanzaTable == null) {\n+        List<String> list = getKerberosConfig();\n+        if (list == null) {\n@@ -110,3 +73,1 @@\n-        if (DEBUG) System.out.println(\"Raw map from JNI: \" + stanzaTable);\n-        return convertNativeConfig(stanzaTable);\n-    }\n+        if (DEBUG) System.out.println(\"Raw map from JNI: \" + list);\n@@ -114,17 +75,4 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private static Hashtable<String, Object> convertNativeConfig(\n-            Hashtable<String, Object> stanzaTable) throws IOException {\n-        \/\/ convert SCDynamicStore realm structure to Java realm structure\n-        Hashtable<String, ?> realms =\n-                (Hashtable<String, ?>) stanzaTable.get(\"realms\");\n-        if (realms == null || realms.isEmpty()) {\n-            throw new IOException(\n-                    \"SCDynamicStore contains an empty Kerberos setting\");\n-        }\n-        stanzaTable.remove(\"realms\");\n-        Hashtable<String, Object> realmsTable = convertRealmConfigs(realms);\n-        stanzaTable.put(\"realms\", realmsTable);\n-        WrapAllStringInVector(stanzaTable);\n-        if (DEBUG) System.out.println(\"stanzaTable : \" + stanzaTable);\n-        return stanzaTable;\n-    }\n+        Hashtable<String,Object> v = new Hashtable<>();\n+        Hashtable<String,Object> realms = new Hashtable<>();\n+        Iterator<String> iterator = list.iterator();\n+        String defaultRealm = null;\n@@ -132,11 +80,18 @@\n-    @SuppressWarnings(\"unchecked\")\n-    private static void WrapAllStringInVector(\n-            Hashtable<String, Object> stanzaTable) {\n-        for (String s: stanzaTable.keySet()) {\n-            Object v = stanzaTable.get(s);\n-            if (v instanceof Hashtable) {\n-                WrapAllStringInVector((Hashtable<String,Object>)v);\n-            } else if (v instanceof String) {\n-                Vector<String> vec = new Vector<>();\n-                vec.add((String)v);\n-                stanzaTable.put(s, vec);\n+        while (true) {\n+            String nextRealm = iterator.next();\n+            if (nextRealm == null) {\n+                break;\n+            }\n+            if (defaultRealm == null) {\n+                defaultRealm = nextRealm;\n+                Hashtable<String,Object> dr = new Hashtable<>();\n+                dr.put(\"default_realm\", v1(defaultRealm));\n+                v.put(\"libdefaults\", dr);\n+            }\n+            Vector<String> kdcs = new Vector<>();\n+            while (true) {\n+                String nextKdc = iterator.next();\n+                if (nextKdc == null) {\n+                    break;\n+                }\n+                kdcs.add(nextKdc);\n@@ -144,0 +99,15 @@\n+            if (!kdcs.isEmpty()) {\n+                Hashtable<String,Object> ri = new Hashtable<>();\n+                ri.put(\"kdc\", kdcs);\n+                realms.put(nextRealm, ri);\n+            }\n+        }\n+        if (!realms.isEmpty()) {\n+            v.put(\"realms\", realms);\n+        }\n+        Hashtable<String,Object> mapping = new Hashtable<>();\n+        while (true) {\n+            if (!iterator.hasNext()) {\n+                break;\n+            }\n+            mapping.put(iterator.next(), v1(iterator.next()));\n@@ -145,0 +115,12 @@\n+        if (!mapping.isEmpty()) {\n+            v.put(\"domain_realm\", mapping);\n+        }\n+        return v;\n+    }\n+\n+    \/\/ Make a single value Vector. Config's stanzaTable always\n+    \/\/ use Vector as end values.\n+    private static Vector<String> v1(String s) {\n+        Vector<String> out = new Vector<>();\n+        out.add(s);\n+        return out;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/SCDynamicStoreConfig.java","additions":61,"deletions":79,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -1653,0 +1653,1 @@\n+            boolean errorEnumSwitch = TreeInfo.isErrorEnumSwitch(selector, cases);\n@@ -1683,0 +1684,11 @@\n+                        } else if (errorEnumSwitch) {\n+                            \/\/error recovery: the selector is erroneous, and all the case labels\n+                            \/\/are identifiers. This could be an enum switch - don't report resolve\n+                            \/\/error for the case label:\n+                            var prevResolveHelper = rs.basicLogResolveHelper;\n+                            try {\n+                                rs.basicLogResolveHelper = rs.silentLogResolveHelper;\n+                                attribExpr(pat, switchEnv, seltype);\n+                            } finally {\n+                                rs.basicLogResolveHelper = prevResolveHelper;\n+                            }\n@@ -3799,1 +3811,1 @@\n-        if (sym != null && sym.kind.matches(KindSelector.TYP_PCK))\n+        if (sym != null && sym.kind.matches(KindSelector.TYP_PCK) && sym.kind != Kind.ERR)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -739,1 +739,2 @@\n-            if ((constants == null || !constants.isEmpty()) && !hasDefault) {\n+            if ((constants == null || !constants.isEmpty()) && !hasDefault &&\n+                !TreeInfo.isErrorEnumSwitch(tree.selector, tree.cases)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2632,0 +2632,9 @@\n+    LogResolveHelper silentLogResolveHelper = new LogResolveHelper() {\n+        public boolean resolveDiagnosticNeeded(Type site, List<Type> argtypes, List<Type> typeargtypes) {\n+            return false;\n+        }\n+        public List<Type> getArgumentTypes(ResolveError errSym, Symbol accessedSym, Name name, List<Type> argtypes) {\n+            return argtypes;\n+        }\n+    };\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1327,0 +1327,5 @@\n+    public static boolean isErrorEnumSwitch(JCExpression selector, List<JCCase> cases) {\n+        return selector.type.tsym.kind == Kinds.Kind.ERR &&\n+               cases.stream().flatMap(c -> c.pats.stream())\n+                             .allMatch(p -> p.hasTag(IDENT));\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JAVAC\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JAVAC\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.compiler\/share\/man\/javac.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"SERIALVER\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"SERIALVER\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.compiler\/share\/man\/serialver.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-#import <JavaRuntimeSupport\/JavaRuntimeSupport.h>\n@@ -263,0 +261,33 @@\n+\/* Create a pool and initiate a try block to catch any exception *\/\n+#define JNI_COCOA_ENTER(env) \\\n+ NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; \\\n+ @try {\n+\n+\/* Don't allow NSExceptions to escape to Java.\n+ * If there is a Java exception that has been thrown that should escape.\n+ * And ensure we drain the auto-release pool.\n+ *\/\n+#define JNI_COCOA_EXIT(env) \\\n+ } \\\n+ @catch (NSException *e) { \\\n+     NSLog(@\"%@\", [e callStackSymbols]); \\\n+ } \\\n+ @finally { \\\n+    [pool drain]; \\\n+ };\n+\n+static NSString* JavaStringToNSString(JNIEnv *env, jstring jstr) {\n+\n+    if (jstr == NULL) {\n+        return NULL;\n+    }\n+    jsize len = (*env)->GetStringLength(env, jstr);\n+    const jchar *chars = (*env)->GetStringChars(env, jstr, NULL);\n+    if (chars == NULL) {\n+        return NULL;\n+    }\n+    NSString *result = [NSString stringWithCharacters:(UniChar *)chars length:len];\n+    (*env)->ReleaseStringChars(env, jstr, chars);\n+    return result;\n+}\n+\n@@ -280,2 +311,3 @@\n-JNF_COCOA_ENTER(env);\n-  NSString *symbolNameString = JNFJavaToNSString(env, symbolName);\n+  JNI_COCOA_ENTER(env);\n+\n+  NSString *symbolNameString = JavaStringToNSString(env, symbolName);\n@@ -292,1 +324,1 @@\n-JNF_COCOA_EXIT(env);\n+  JNI_COCOA_EXIT(env);\n@@ -815,1 +847,1 @@\n-JNF_COCOA_ENTER(env);\n+  JNI_COCOA_ENTER(env);\n@@ -929,1 +961,1 @@\n-JNF_COCOA_EXIT(env);\n+  JNI_COCOA_EXIT(env);\n@@ -1023,1 +1055,2 @@\n-JNF_COCOA_ENTER(env);\n+\n+  JNI_COCOA_ENTER(env);\n@@ -1074,1 +1107,1 @@\n-JNF_COCOA_EXIT(env);\n+  JNI_COCOA_EXIT(env);\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/MacosxDebuggerLocal.m","additions":42,"deletions":9,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JHSDB\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JHSDB\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.hotspot.agent\/share\/man\/jhsdb.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JAR\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JAR\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jartool\/share\/man\/jar.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JARSIGNER\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JARSIGNER\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n@@ -963,9 +963,0 @@\n-.B \\f[CB]\\-directsign\\f[R]\n-By default, jarsigner stores the hash of the \\f[CB]\\&.SF\\f[R] file and\n-possibly other information in a SignerInfo signedAttributes field, and\n-then calculates the signature on this field.\n-If this option is set, no SignerInfo signedAttributes field is generated\n-and the signature is calculated on the \\f[CB]\\&.SF\\f[R] file directly.\n-.RS\n-.RE\n-.TP\n","filename":"src\/jdk.jartool\/share\/man\/jarsigner.1","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JAVADOC\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JAVADOC\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n@@ -599,1 +599,1 @@\n-\\f[CB]javadoc\\ \\-header\\ \"<b>My\\ Library<\/b><br>v1.0\"\\ com.mypackage.\\f[R]\n+\\f[CB]javadoc\\ \\-doctitle\\ \"<b>My\\ Library<\/b><br>v1.0\"\\ com.mypackage.\\f[R]\n","filename":"src\/jdk.javadoc\/share\/man\/javadoc.1","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JCMD\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JCMD\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JINFO\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JINFO\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jinfo.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JMAP\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JMAP\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jmap.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JPS\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JPS\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jps.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JSTACK\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JSTACK\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jstack.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JSTAT\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JSTAT\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jstat.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JCONSOLE\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JCONSOLE\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jconsole\/share\/man\/jconsole.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JAVAP\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JAVAP\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jdeps\/share\/man\/javap.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JDEPRSCAN\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JDEPRSCAN\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jdeps\/share\/man\/jdeprscan.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JDEPS\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JDEPS\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jdeps\/share\/man\/jdeps.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JDB\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JDB\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jdi\/share\/man\/jdb.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import java.util.Iterator;\n@@ -854,0 +855,14 @@\n+\n+    public void removePath(SafePath path) {\n+        synchronized (recorder) {\n+            Iterator<RepositoryChunk> it = chunks.iterator();\n+            while (it.hasNext()) {\n+                RepositoryChunk c = it.next();\n+                if (c.getFile().equals(path)) {\n+                    it.remove();\n+                    removed(c);\n+                    return;\n+                }\n+            }\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.jfr.internal.management.ChunkFilename;\n@@ -48,0 +49,1 @@\n+    private ChunkFilename chunkFilename;\n@@ -64,0 +66,1 @@\n+        this.chunkFilename = null;\n@@ -87,0 +90,1 @@\n+                chunkFilename = null;\n@@ -88,1 +92,5 @@\n-            return new RepositoryChunk(repository, timestamp);\n+            if (chunkFilename == null) {\n+                chunkFilename = ChunkFilename.newPriviliged(repository.toPath());\n+            }\n+            String filename = chunkFilename.next(timestamp.toLocalDateTime());\n+            return new RepositoryChunk(new SafePath(filename), timestamp.toInstant());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Repository.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-    private final SafePath repositoryPath;\n@@ -59,4 +58,3 @@\n-    RepositoryChunk(SafePath path, ZonedDateTime timestamp) throws Exception {\n-        this.startTime = timestamp.toInstant();\n-        this.repositoryPath = path;\n-        this.chunkFile = findFileName(repositoryPath, timestamp.toLocalDateTime());\n+    RepositoryChunk(SafePath path, Instant startTime) throws Exception {\n+        this.startTime = startTime;\n+        this.chunkFile = path;\n@@ -66,15 +64,0 @@\n-    private static SafePath findFileName(SafePath directory, LocalDateTime time) throws Exception {\n-        String filename = Utils.formatDateTime(time);\n-        Path p = directory.toPath().resolve(filename + FILE_EXTENSION);\n-        for (int i = 1; i < MAX_CHUNK_NAMES; i++) {\n-            SafePath s = new SafePath(p);\n-            if (!SecuritySupport.exists(s)) {\n-                return s;\n-            }\n-            String extendedName = String.format(\"%s_%02d%s\", filename, i, FILE_EXTENSION);\n-            p = directory.toPath().resolve(extendedName);\n-        }\n-        p = directory.toPath().resolve(filename + \"_\" + System.currentTimeMillis() + FILE_EXTENSION);\n-        return new SafePath(p);\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/RepositoryChunk.java","additions":4,"deletions":21,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -503,0 +503,5 @@\n+\n+        @Override\n+        public boolean exists(Path p) throws IOException {\n+            return doPrivilegedIOWithReturn( () -> Files.exists(p));\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SecuritySupport.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,1 +187,1 @@\n-    static String formatDateTime(LocalDateTime time) {\n+    public static String formatDateTime(LocalDateTime time) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,2 @@\n+    public abstract boolean exists(Path s) throws IOException;\n+\n@@ -74,0 +76,5 @@\n+\n+        @Override\n+        public boolean exists(Path p) {\n+            return Files.exists(p);\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FileAccess.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,2 +122,1 @@\n-                Instant timestamp = Utils.epochNanosToInstant(startTimeNanos);\n-                ManagementSupport.removeBefore(recording, timestamp);\n+                ManagementSupport.removePath(recording, path);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/OngoingStream.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.internal.management;\n+\n+import java.nio.file.Paths;\n+import java.nio.file.Path;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import jdk.jfr.internal.SecuritySupport;\n+import jdk.jfr.internal.SecuritySupport.SafePath;\n+import jdk.jfr.internal.Utils;\n+import jdk.jfr.internal.consumer.FileAccess;\n+\n+\/\/ Allows a remote streaming client to create chunk files\n+\/\/ with same naming scheme as the JVM.\n+public final class ChunkFilename {\n+   private static final int MAX_CHUNK_NAMES = 100_000;\n+   private static final String FILE_EXTENSION = \".jfr\";\n+\n+   private final Path directory;\n+   private final FileAccess fileAcess;\n+\n+   private Path lastPath;\n+   private int counter;\n+\n+   public static ChunkFilename newUnpriviliged(Path directory) {\n+       return new ChunkFilename(directory, FileAccess.UNPRIVILEGED);\n+   }\n+\n+   public static ChunkFilename newPriviliged(Path directory) {\n+       return new ChunkFilename(directory, SecuritySupport.PRIVILEGED);\n+   }\n+\n+   private ChunkFilename(Path directory, FileAccess fileAccess) {\n+       \/\/ Avoid malicious implementations of Path interface\n+       this.directory = Paths.get(directory.toString());\n+       this.fileAcess = fileAccess;\n+   }\n+\n+   public String next(LocalDateTime time) throws IOException {\n+       String filename = Utils.formatDateTime(time);\n+       Path p = directory.resolve(filename + FILE_EXTENSION);\n+\n+       \/\/ If less than one file per second (typically case)\n+       if (lastPath == null || !p.equals(lastPath)) {\n+           if (!fileAcess.exists(p)) {\n+               counter = 1; \/\/ reset counter\n+               lastPath = p;\n+               return p.toString();\n+           }\n+       }\n+\n+       \/\/ If more than one file per second\n+       while (counter < MAX_CHUNK_NAMES) {\n+           String extendedName = String.format(\"%s_%02d%s\", filename, counter, FILE_EXTENSION);\n+           p = directory.resolve(extendedName);\n+           counter++;\n+           if (!fileAcess.exists(p)) {\n+               return p.toString();\n+           }\n+       }\n+       throw new IOException(\"Unable to find unused filename after \" + counter + \" attempts\");\n+   }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ChunkFilename.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,1 @@\n+import jdk.jfr.internal.SecuritySupport.SafePath;\n@@ -144,0 +145,1 @@\n+    }\n@@ -145,0 +147,4 @@\n+    \/\/ Needed callback to detect when a chunk has been parsed.\n+    public static void removePath(Recording recording, Path path) {\n+        PlatformRecording pr = PrivateAccess.getInstance().getPlatformRecording(recording);\n+        pr.removePath(new SafePath(path));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JFR\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JFR\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jfr\/share\/man\/jfr.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JLINK\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JLINK\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jlink\/share\/man\/jlink.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JMOD\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JMOD\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jlink\/share\/man\/jmod.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JSHELL\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JSHELL\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jshell\/share\/man\/jshell.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JSTATD\" \"1\" \"2020\" \"JDK 16\" \"JDK Commands\"\n+.TH \"JSTATD\" \"1\" \"2021\" \"JDK 16\" \"JDK Commands\"\n","filename":"src\/jdk.jstatd\/share\/man\/jstatd.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.nio.file.Paths;\n@@ -43,0 +44,1 @@\n+import jdk.jfr.internal.management.ChunkFilename;\n@@ -49,1 +51,1 @@\n-        final Instant startTime;\n+        final long startTimeNanos;\n@@ -55,1 +57,1 @@\n-            this.startTime = ManagementSupport.epochNanosToInstant(startNanos);\n+            this.startTimeNanos = startNanos;\n@@ -83,0 +85,1 @@\n+    private final ChunkFilename chunkFilename;\n@@ -106,0 +109,1 @@\n+        this.chunkFilename = ChunkFilename.newUnpriviliged(path);\n@@ -298,2 +302,2 @@\n-            Duration d = Duration.ofNanos(durationNanos);\n-            currentChunk.endTime = currentChunk.startTime.plus(d);\n+            long endTimeNanos = currentChunk.startTimeNanos + durationNanos;\n+            currentChunk.endTime = ManagementSupport.epochNanosToInstant(endTimeNanos);\n@@ -328,38 +332,2 @@\n-        String filename = formatDateTime(d);\n-        Path p1 = directory.resolve(filename + \".jfr\");\n-        if (!Files.exists(p1)) {\n-            return new DiskChunk(p1, nanos);\n-        }\n-        for (int i = 1; i < 100; i++) {\n-            String s = Integer.toString(i);\n-            if (i < 10) {\n-                s = \"0\" + s;\n-            }\n-            Path p2 = directory.resolve(filename + \"_\" + s + \".jfr\");\n-            if (!Files.exists(p2)) {\n-                return new DiskChunk(p2, nanos);\n-            }\n-        }\n-        throw new IOException(\"Could not create chunk for path \" + p1);\n-    }\n-\n-    static String formatDateTime(LocalDateTime time) {\n-        StringBuilder sb = new StringBuilder(19);\n-        sb.append(time.getYear() \/ 100);\n-        appendPadded(sb, time.getYear() % 100, true);\n-        appendPadded(sb, time.getMonth().getValue(), true);\n-        appendPadded(sb, time.getDayOfMonth(), true);\n-        appendPadded(sb, time.getHour(), true);\n-        appendPadded(sb, time.getMinute(), true);\n-        appendPadded(sb, time.getSecond(), false);\n-        return sb.toString();\n-    }\n-\n-    private static void appendPadded(StringBuilder text, int number, boolean separator) {\n-        if (number < 10) {\n-            text.append('0');\n-        }\n-        text.append(number);\n-        if (separator) {\n-            text.append('_');\n-        }\n+        String filename = chunkFilename.next(d);\n+        return new DiskChunk(Paths.get(filename), nanos);\n@@ -426,1 +394,1 @@\n-    public synchronized void onChunkComplete(Instant timestamp) {\n+    public synchronized void onChunkComplete(long endTimeNanos) {\n@@ -430,1 +398,1 @@\n-            if (oldestChunk.startTime.isBefore(timestamp)) {\n+            if (oldestChunk.startTimeNanos < endTimeNanos) {\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DiskRepository.java","additions":13,"deletions":45,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.jfr.internal.management.ManagementSupport;\n+\n@@ -38,1 +40,2 @@\n-    DownLoadThread(RemoteRecordingStream stream) {\n+    DownLoadThread(RemoteRecordingStream stream, String name) {\n+        super(name);\n@@ -68,1 +71,1 @@\n-           \/\/ ignore\n+            ManagementSupport.logDebug(ioe.getMessage());\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/DownLoadThread.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -136,2 +136,1 @@\n-            Instant t = ManagementSupport.epochNanosToInstant(endNanos);\n-            repository.onChunkComplete(t);\n+            repository.onChunkComplete(endNanos);\n@@ -555,2 +554,2 @@\n-        Thread downLoadThread = new DownLoadThread(this);\n-        downLoadThread.setName(\"JFR: Download Thread \" + creationTime);\n+        String name = \"JFR: Download Thread \" + creationTime;\n+        Thread downLoadThread = new DownLoadThread(this, name);\n","filename":"src\/jdk.management.jfr\/share\/classes\/jdk\/management\/jfr\/RemoteRecordingStream.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,0 +277,7 @@\n+            \/\/ Set the \"label\" property of each input node, so that by default\n+            \/\/ search is done on the node label (without line breaks). See also\n+            \/\/ class NodeQuickSearch in the View module.\n+            for (InputNode n : getSource().getSourceNodes()) {\n+                String label = resolveString(diagram.getNodeText(), n.getProperties());\n+                n.getProperties().setProperty(\"label\", label);\n+            }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-javac.source=1.7\r\n+javac.source=1.8\r\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/nbproject\/project.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Collections;\n@@ -49,1 +50,1 @@\n-    private static final String DEFAULT_PROPERTY = \"name\";\n+    private static final String DEFAULT_PROPERTY = \"label\";\n@@ -69,0 +70,1 @@\n+        String rawValue;\n@@ -73,1 +75,2 @@\n-            value = \".*\" + Pattern.quote(parts[0]) + \".*\";\n+            rawValue = parts[0];\n+            value = \".*\" + Pattern.quote(rawValue) + \".*\";\n@@ -76,5 +79,2 @@\n-            value = parts[1];\n-        }\n-\n-        if (value.isEmpty()) {\n-            value = \".*\";\n+            rawValue = parts[1];\n+            value = (rawValue.isEmpty() ? \"\" : Pattern.quote(rawValue)) + \".*\";\n@@ -112,7 +112,15 @@\n-                response.addResult(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        final EditorTopComponent comp = EditorTopComponent.getActive();\n-                        if (comp != null) {\n-                            if (theGraph != null) {\n-                                comp.getDiagramModel().selectGraph(theGraph);\n+                \/\/ Show \"All N matching nodes\" entry only if 1) there are\n+                \/\/ multiple matches and 2) the query does not only contain\n+                \/\/ digits (it is rare to select all nodes whose id contains a\n+                \/\/ certain subsequence of digits).\n+                if (matches.size() > 1 && !rawValue.matches(\"\\\\d+\")) {\n+                    if (!response.addResult(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            final EditorTopComponent comp = EditorTopComponent.getActive();\n+                            if (comp != null) {\n+                                if (theGraph != null) {\n+                                    comp.getDiagramModel().selectGraph(theGraph);\n+                                }\n+                                comp.setSelectedNodes(set);\n+                                comp.requestActive();\n@@ -120,2 +128,0 @@\n-                            comp.setSelectedNodes(set);\n-                            comp.requestActive();\n@@ -123,0 +129,4 @@\n+                    },\n+                            \"All \" + matches.size() + \" matching nodes (\" + name + \"=\" + value + \")\" + (theGraph != null ? \" in \" + theGraph.getName() : \"\")\n+                    )) {\n+                        return;\n@@ -124,3 +134,8 @@\n-                },\n-                        \"All \" + matches.size() + \" matching nodes (\" + name + \"=\" + value + \")\" + (theGraph != null ? \" in \" + theGraph.getName() : \"\")\n-                );\n+                }\n+\n+                \/\/ Rank the matches.\n+                Collections.sort(matches,\n+                                 (InputNode a, InputNode b) ->\n+                                 compareByRankThenNumVal(rawValue,\n+                                                         a.getProperties().get(name),\n+                                                         b.getProperties().get(name)));\n@@ -130,1 +145,1 @@\n-                    response.addResult(new Runnable() {\n+                    if (!response.addResult(new Runnable() {\n@@ -146,1 +161,3 @@\n-                    );\n+                    )) {\n+                        return;\n+                    }\n@@ -176,0 +193,47 @@\n+\n+    \/**\n+     * Compare two matches for a given query, first by rank (see rankMatch()\n+     * below) and then by numeric value, if applicable.\n+     *\/\n+    private int compareByRankThenNumVal(String qry, String prop1, String prop2) {\n+        int key1 = rankMatch(qry, prop1);\n+        int key2 = rankMatch(qry, prop2);\n+        if (key1 == key2) {\n+            \/\/ If the matches have the same rank, compare the numeric values of\n+            \/\/ their first words, if applicable.\n+            try {\n+                key1 = Integer.parseInt(prop1.split(\"\\\\W+\")[0]);\n+                key2 = Integer.parseInt(prop2.split(\"\\\\W+\")[0]);\n+            } catch (Exception e) {\n+                \/\/ Not applicable, return equality value.\n+                return 0;\n+            }\n+        }\n+        return Integer.compare(key1, key2);\n+    }\n+\n+    \/**\n+     * Rank a match by splitting the property into words. Full matches of a word\n+     * rank highest, followed by partial matches at the word start, followed by\n+     * the rest of matches in increasing size of the partially matched word, for\n+     * example:\n+     *\n+     *   rank(\"5\", \"5 AddI\")   = 1 (full match of first word)\n+     *   rank(\"5\", \"554 MulI\") = 2 (start match of first word)\n+     *   rank(\"5\", \"25 AddL\")  = 3 (middle match of first word with excess 1)\n+     *   rank(\"5\", \"253 AddL\") = 4 (middle match of first word with excess 2)\n+     *\/\n+    private int rankMatch(String qry, String prop) {\n+        String query = qry.toLowerCase();\n+        String property = prop.toLowerCase();\n+        for (String component : property.split(\"\\\\W+\")) {\n+            if (component.equals(query)) {\n+                return 1;\n+            } else if (component.startsWith(query)) {\n+                return 2;\n+            } else if (component.contains(query)) {\n+                return component.length() - query.length() + 2;\n+            }\n+        }\n+        return Integer.MAX_VALUE;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/com\/sun\/hotspot\/igv\/view\/NodeQuickSearch.java","additions":86,"deletions":22,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private boolean isFileValid = true;\n+    public boolean isFileValid = true;\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/JcmdStateBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+    private final boolean isJcmdValid;\n@@ -58,0 +59,1 @@\n+                     boolean isJcmdValid,\n@@ -64,0 +66,1 @@\n+        this.isJcmdValid = isJcmdValid;\n@@ -124,1 +127,12 @@\n-                mainOutput.shouldContain(\"CompileCommand: An error occurred during parsing\");\n+                if (!isJcmdValid) {\n+                    boolean parse_error_found = false;\n+                    for(OutputAnalyzer out : outputList) {\n+                        if (out.getOutput().contains(\"Parsing of compiler directives failed\")) {\n+                            parse_error_found = true;\n+                            break;\n+                        }\n+                    }\n+                    Asserts.assertTrue(parse_error_found, \"'Parsing of compiler directives failed' missing from output\");\n+                } else {\n+                    mainOutput.shouldContain(\"CompileCommand: An error occurred during parsing\");\n+                }\n@@ -256,0 +270,1 @@\n+            boolean isJcmdValid = true;\n@@ -318,0 +333,1 @@\n+            isJcmdValid = jcmdStateBuilder.isFileValid;\n@@ -331,1 +347,1 @@\n-            return new Scenario(isValid, options, finalStates, ccList,\n+            return new Scenario(isValid, isJcmdValid, options, finalStates, ccList,\n","filename":"test\/hotspot\/jtreg\/compiler\/compilercontrol\/share\/scenario\/Scenario.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8260370\n+ * @summary C2: LoopLimit node is not eliminated\n+ *\n+ * @run main\/othervm\n+ *      -Xcomp\n+ *      -XX:CompileOnly=compiler\/loopopts\/TestLoopLimitNodeElimination\n+ *      compiler.loopopts.TestLoopLimitNodeElimination\n+ *\/\n+\n+package compiler.loopopts;\n+\n+\/\/ the test code is derived from a randomly generated test\n+public class TestLoopLimitNodeElimination {\n+    private static class MyException extends RuntimeException { }\n+    private static final int ITERATIONS = 100000;\n+    private static final int SIZE = 400;\n+\n+    private static int counter = 0;\n+\n+    int[] array1 = new int[SIZE];\n+\n+    void test() {\n+        int[] array2 = new int[SIZE];\n+        array1[2] = 0;\n+        array1 = array1;\n+        for (long i = 301; i > 2; i -= 2) {\n+            int j = 1;\n+            do {\n+               for (int k = (int) i; k < 1; k++) { }\n+            } while (++j < 4);\n+        }\n+\n+        counter++;\n+        if (counter == ITERATIONS) {\n+            throw new MyException();\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        try {\n+            var test = new TestLoopLimitNodeElimination();\n+            while (true) {\n+                test.test();\n+            }\n+        } catch (MyException e) {\n+            \/\/ expected\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestLoopLimitNodeElimination.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,1939 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class TestNestedIrreducibleLoops\n+\tversion 45:3\n+{\n+  Field loopCounter:I;\n+  Field start:I;\n+\n+  public Method \"<init>\":\"()V\"\n+\tstack 1 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\treturn;\n+  }\n+  static Method addi:\"(I)I\"\n+\tstack 2 locals 1\n+  {\n+\t\tiload_0;\n+\t\ticonst_1;\n+\t\tiadd;\n+\t\tireturn;\n+  }\n+  Method test:\"()I\"\n+\tstack 2 locals 8\n+  {\n+\t\ticonst_0;\n+\t\tistore_1;\n+\t\ticonst_0;\n+\t\tistore_2;\n+\t\ticonst_0;\n+\t\tistore_3;\n+\t\ticonst_m1;\n+\t\tistore\t5;\n+\t\ticonst_2;\n+\t\tistore\t6;\n+\t\taload_0;\n+\t\tgetfield\tField start:\"I\";\n+\t\tifne\tL3135;\n+\t\tgoto\tL31;\n+\tL22:\tiinc\t2, 1;\n+\t\tiload_2;\n+\t\tiload\t6;\n+\t\tif_icmpgt\tL3135;\n+\tL31:\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpeq\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmplt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiload_1;\n+\t\ticonst_3;\n+\t\tif_icmpgt\tL3135;\n+\t\ticonst_0;\n+\t\tistore\t7;\n+\tL3084:\tiload\t7;\n+\t\tiload\t6;\n+\t\tif_icmpge\tL3104;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tifeq\tL3104;\n+\t\tiinc\t7, 1;\n+\t\tgoto\tL3084;\n+\tL3104:\tiload_1;\n+\t\tiload\t6;\n+\t\tif_icmpge\tL3135;\n+\t\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tbipush\t84;\n+\t\tif_icmpne\tL3135;\n+\t\tiload_1;\n+\t\tbipush\t88;\n+\t\tiadd;\n+\t\tiload\t6;\n+\t\tif_icmpge\tL3135;\n+\t\ticonst_1;\n+\t\tireturn;\n+\tL3130:\tiload\t5;\n+\t\tiflt\tL3153;\n+\tL3135:\tiload_1;\n+\t\tinvokestatic\tMethod addi:\"(I)I\";\n+\t\tistore_1;\n+\t\tiinc\t3, 1;\n+\t\tiload_3;\n+\t\taload_0;\n+\t\tgetfield\tField loopCounter:\"I\";\n+\t\tif_icmplt\tL3130;\n+\t\ticonst_0;\n+\t\tireturn;\n+\tL3153:\tiload\t5;\n+\t\tiflt\tL22;\n+\t\ticonst_0;\n+\t\tireturn;\n+  }\n+\n+} \/\/ end Class TestNestedIrreducibleLoops\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestNestedIrreducibleLoops.jasm","additions":1939,"deletions":0,"binary":false,"changes":1939,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8253353\n+ * @summary Tests custom bytecode with deep nested irreducible loops.\n+ *\n+ * @compile TestNestedIrreducibleLoops.jasm\n+ * @run main\/othervm -Xbatch -XX:CompileCommand=dontinline,TestNestedIrreducibleLoops::*\n+ *                   -XX:CompileCommand=exclude,TestNestedIrreducibleLoopsMain::main\n+ *                   TestNestedIrreducibleLoopsMain\n+ *\/\n+\n+public class TestNestedIrreducibleLoopsMain {\n+    public static void main(String[] args) {\n+        TestNestedIrreducibleLoops t = new TestNestedIrreducibleLoops();\n+        t.loopCounter = 3;\n+        int j;\n+        for (int i = 0; i < 11000; i++) {\n+            t.start = i & 0x3ff;\n+            j = t.test(); \/\/ Produces deep nested irreducible loops\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestNestedIrreducibleLoopsMain.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Huawei Technologies Co. Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+\/*\n+ * @test\n+ * @bug 8260339\n+ * @summary StoreVectorNode is not considered with -XX:+OptimizeFill\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+OptimizeFill compiler.vectorapi.TestLoopStoreVector\n+ *\/\n+\n+public class TestLoopStoreVector {\n+    static final VectorSpecies<Integer> SPECIESi = IntVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Long> SPECIESl = LongVector.SPECIES_PREFERRED;\n+\n+    static final int INVOC_COUNT = 5000;\n+    static final int size = 64;\n+\n+    static int[] ai = {20, 21, 02, 14, 83, 119, 101, 101, 116, 121, 44, 32,\n+                       73, 32, 76, 79, 86, 69, 32, 89, 79, 85, 32, 102, 111,\n+                       114, 101, 118, 101, 114, 33, 32, 32, 32, 45, 45, 32,\n+                       32, 32, 66, 121, 32, 87, 97, 110, 103, 72, 117, 97,\n+                       110, 103,46, 76, 105, 102, 101, 32, 105, 115, 32, 116,\n+                       104, 101, 32};\n+    static long[] al = {102, 108, 111, 119, 101, 114, 32, 102, 111, 114, 32,\n+                        119, 104, 105, 99, 104, 32, 108, 111, 118, 101, 32,\n+                        105, 115, 32, 116, 104, 101, 32, 104, 111, 110, 101,\n+                        121, 46, 32, 87, 101, 32, 119, 105, 108, 108, 32, 115,\n+                        116, 105, 99, 107, 32, 116, 111, 103, 101, 116, 104,\n+                        101, 114, 32, 33, 33, 33, 33, 32};\n+\n+    public static void testVectorCastL2I(long[] input, int[] output, VectorSpecies<Long> speciesl, VectorSpecies<Integer> speciesi) {\n+        LongVector av = LongVector.fromArray(speciesl, input, 0);\n+        IntVector bv = (IntVector) av.castShape(speciesi, 0);\n+        bv.intoArray(output, 0);\n+    }\n+\n+    public static int test0() {\n+        for (int i = 0; i < 1000; i++) {\n+            testVectorCastL2I(al, ai, SPECIESl, SPECIESi);\n+        }\n+        return 0;\n+    }\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < INVOC_COUNT; i++) {\n+            test0();\n+        }\n+        for (int i = 0; i < 64; i++) {\n+            System.out.print(ai[i] + \" \");\n+        }\n+        System.out.println(\"\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestLoopStoreVector.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import jdk.incubator.vector.*;\n+import jdk.internal.vm.annotation.ForceInline;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+import java.util.function.IntUnaryOperator;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/*\n+ * @test\n+ * @bug 8260473\n+ * @requires vm.gc.Z\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @run testng\/othervm -XX:CompileCommand=compileonly,jdk\/incubator\/vector\/ByteVector.fromByteBuffer\n+ *      -XX:-TieredCompilation -XX:CICompilerCount=1 -XX:+UseZGC -Xbatch -Xmx256m VectorRebracket128Test\n+ *\/\n+\n+@Test\n+public class VectorRebracket128Test {\n+    static final int INVOC_COUNT = Integer.getInteger(\"jtreg.compiler.vectorapi.vectorrebracket128test.loop-iterations\", 1000);\n+    static final int NUM_ITER = 200 * INVOC_COUNT;\n+\n+    static final VectorSpecies<Integer> ispec128 = IntVector.SPECIES_128;\n+    static final VectorSpecies<Float> fspec128 = FloatVector.SPECIES_128;\n+    static final VectorSpecies<Long> lspec128 = LongVector.SPECIES_128;\n+    static final VectorSpecies<Double> dspec128 = DoubleVector.SPECIES_128;\n+    static final VectorSpecies<Byte> bspec128 = ByteVector.SPECIES_128;\n+    static final VectorSpecies<Short> sspec128 = ShortVector.SPECIES_128;\n+\n+    static <T> IntFunction<T> withToString(String s, IntFunction<T> f) {\n+        return new IntFunction<T>() {\n+            @Override\n+            public T apply(int v) {\n+                return f.apply(v);\n+            }\n+\n+            @Override\n+            public String toString() {\n+                return s;\n+            }\n+        };\n+    }\n+\n+    interface ToByteF {\n+        byte apply(int i);\n+    }\n+\n+    static byte[] fill_byte(int s , ToByteF f) {\n+        return fill_byte(new byte[s], f);\n+    }\n+\n+    static byte[] fill_byte(byte[] a, ToByteF f) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = f.apply(i);\n+        }\n+        return a;\n+    }\n+\n+    static final List<IntFunction<byte[]>> BYTE_GENERATORS = List.of(\n+            withToString(\"byte(i)\", (int s) -> {\n+                return fill_byte(s, i -> (byte)(i+1));\n+            })\n+    );\n+\n+    @DataProvider\n+    public Object[][] byteUnaryOpProvider() {\n+        return BYTE_GENERATORS.stream().\n+                map(f -> new Object[]{f}).\n+                toArray(Object[][]::new);\n+    }\n+\n+    static\n+    void checkPartialResult(VectorSpecies<?> a, VectorSpecies<?> b,\n+                            byte[] input, byte[] output, byte[] expected,\n+                            int part, int origin) {\n+        if (Arrays.equals(expected, output)) {\n+            return;\n+        }\n+        int block;\n+        block = Math.min(a.vectorByteSize(), b.vectorByteSize());\n+\n+        System.out.println(\"input:  \"+Arrays.toString(input));\n+        System.out.println(\"Failing with \"+a+\"->\"+b+\n+                           \" (reinterpret)\"+\n+                           \", block=\" + block +\n+                           \", part=\" + part +\n+                           \", origin=\" + origin);\n+        System.out.println(\"expect: \"+Arrays.toString(expected));\n+        System.out.println(\"output: \"+Arrays.toString(output));\n+        Assert.assertEquals(expected, output);\n+    }\n+\n+    @ForceInline\n+    static <E,F>\n+    void testVectorRebracket(VectorSpecies<E> a, VectorSpecies<F> b, byte[] input, byte[] output) {\n+        Vector<E> av = a.fromByteArray(input, 0, ByteOrder.nativeOrder());\n+        int block;\n+        assert(input.length == output.length);\n+\n+        block = Math.min(a.vectorByteSize(), b.vectorByteSize());\n+        if (false)\n+            System.out.println(\"testing \"+a+\"->\"+b+\n+                    (false?\" (lanewise)\":\" (reinterpret)\")+\n+                    \", block=\" + block);\n+        byte[] expected;\n+        int origin;\n+\n+        int part = 0;\n+        Vector<F> bv = av.reinterpretShape(b, part);\n+        bv.intoByteArray(output, 0, ByteOrder.nativeOrder());\n+        \/\/ in-place copy, no resize\n+        expected = input;\n+        origin = 0;\n+        checkPartialResult(a, b, input, output, expected,\n+                part, origin);\n+\n+    }\n+\n+    @Test(dataProvider = \"byteUnaryOpProvider\")\n+    static void testRebracket128(IntFunction<byte[]> fa) {\n+        byte[] barr = fa.apply(128\/Byte.SIZE);\n+        byte[] bout = new byte[barr.length];\n+        for (int i = 0; i < NUM_ITER; i++) {\n+            testVectorRebracket(bspec128, bspec128, barr, bout);\n+            testVectorRebracket(bspec128, sspec128, barr, bout);\n+            testVectorRebracket(bspec128, ispec128, barr, bout);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorRebracket128Test.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -257,1 +257,0 @@\n-java\/awt\/print\/PrinterJob\/TestPgfmtSetMPA.java 8198343 generic-all\n@@ -737,1 +736,0 @@\n-javax\/swing\/JColorChooser\/Test6827032.java 8197825 windows-all\n@@ -833,1 +831,0 @@\n-jdk\/jfr\/jmx\/streaming\/TestRotate.java                           8257215 generic-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#import <Cocoa\/Cocoa.h>\n-#import <JavaNativeFoundation\/JavaNativeFoundation.h>\n-\n-static NSWindow *testWindow;\n-static NSColorPanel *colorPanel;\n-\n-\/*\n- * Class:     TestMainKeyWindow\n- * Method:    setup\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL Java_TestMainKeyWindow_setup(JNIEnv *env, jclass cl)\n-{\n-    JNF_COCOA_ENTER(env);\n-\n-    void (^block)() = ^(){\n-        NSScreen *mainScreen = [[NSScreen screens] objectAtIndex:0];\n-        NSRect screenFrame = [mainScreen frame];\n-        NSRect frame = NSMakeRect(130, screenFrame.size.height - 280, 200, 100);\n-\n-#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 101200\n-        NSWindowStyleMask style = NSWindowStyleMaskTitled;\n-#else\n-        NSInteger style = NSTitledWindowMask;\n-#endif\n-\n-        NSRect rect = [NSWindow contentRectForFrameRect:frame styleMask:style];\n-        NSBackingStoreType bt = NSBackingStoreBuffered;\n-        testWindow = [[[NSWindow alloc] initWithContentRect:rect styleMask:style backing:bt defer:NO] retain];\n-        testWindow.title = @\"NSWindow\";\n-        [testWindow setBackgroundColor:[NSColor blueColor]];\n-        [testWindow makeKeyAndOrderFront:nil];\n-        \/\/ Java coordinates are 100, 200\n-\n-        colorPanel = [[NSColorPanel sharedColorPanel] retain];\n-        [colorPanel setReleasedWhenClosed: YES];\n-        colorPanel.restorable = NO;\n-        [colorPanel setFrame:NSMakeRect(130, screenFrame.size.height - 500, 200, 200) display:NO];\n-        \/\/ Java coordinates are 100, 400\n-        [colorPanel makeKeyAndOrderFront: nil];\n-    };\n-\n-    if ([NSThread isMainThread]) {\n-        block();\n-    } else {\n-        [JNFRunLoop performOnMainThreadWaiting:YES withBlock:block];\n-    }\n-\n-    JNF_COCOA_EXIT(env);\n-}\n-\n-\/*\n- * Class:     TestMainKeyWindow\n- * Method:    takedown\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL Java_TestMainKeyWindow_takedown(JNIEnv *env, jclass cl)\n-{\n-    JNF_COCOA_ENTER(env);\n-\n-    void (^block)() = ^(){\n-        if (testWindow != nil) {\n-            [testWindow close];\n-            testWindow = nil;\n-        }\n-        if (colorPanel != nil) {\n-            [colorPanel orderOut:nil];\n-            colorPanel = nil;\n-        }\n-    };\n-\n-    if ([NSThread isMainThread]) {\n-        block();\n-    } else {\n-        [JNFRunLoop performOnMainThreadWaiting:YES withBlock:block];\n-    }\n-\n-    JNF_COCOA_EXIT(env);\n-}\n-\n-\/*\n- * Class:     TestMainKeyWindow\n- * Method:    activateApplication\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL Java_TestMainKeyWindow_activateApplication\n-  (JNIEnv *env, jclass cl)\n-{\n-    JNF_COCOA_ENTER(env);\n-\n-    void (^block)() = ^(){\n-        [NSApp activateIgnoringOtherApps:YES];\n-    };\n-\n-    [JNFRunLoop performOnMainThreadWaiting:YES withBlock:block];\n-\n-  JNF_COCOA_EXIT(env);\n-}\n","filename":"test\/jdk\/java\/awt\/Window\/MainKeyWindowTest\/libTestMainKeyWindow.c","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <Cocoa\/Cocoa.h>\n+#import <jni_util.h>\n+\n+static NSWindow *testWindow;\n+static NSColorPanel *colorPanel;\n+\n+#define JNI_COCOA_ENTER(env) \\\n+ NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; \\\n+ @try {\n+\n+#define JNI_COCOA_EXIT(env) \\\n+ } \\\n+ @catch (NSException *e) { \\\n+     NSLog(@\"%@\", [e callStackSymbols]); \\\n+ } \\\n+ @finally { \\\n+    [pool drain]; \\\n+  };\n+\n+\/*\n+ * Pass the block to a selector of a class that extends NSObject\n+ * There is no need to copy the block since this class always waits.\n+ *\/\n+@interface BlockRunner : NSObject { }\n+\n++ (void)invokeBlock:(void (^)())block;\n+@end\n+\n+@implementation BlockRunner\n+\n++ (void)invokeBlock:(void (^)())block{\n+  block();\n+}\n+\n++ (void)performBlock:(void (^)())block {\n+  [self performSelectorOnMainThread:@selector(invokeBlock:) withObject:block waitUntilDone:YES];\n+}\n+\n+@end\n+\n+\/*\n+ * Class:     TestMainKeyWindow\n+ * Method:    setup\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_TestMainKeyWindow_setup(JNIEnv *env, jclass cl)\n+{\n+    JNI_COCOA_ENTER(env);\n+\n+    void (^block)() = ^(){\n+        NSScreen *mainScreen = [[NSScreen screens] objectAtIndex:0];\n+        NSRect screenFrame = [mainScreen frame];\n+        NSRect frame = NSMakeRect(130, screenFrame.size.height - 280, 200, 100);\n+\n+#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 101200\n+        NSWindowStyleMask style = NSWindowStyleMaskTitled;\n+#else\n+        NSInteger style = NSTitledWindowMask;\n+#endif\n+\n+        NSRect rect = [NSWindow contentRectForFrameRect:frame styleMask:style];\n+        NSBackingStoreType bt = NSBackingStoreBuffered;\n+        testWindow = [[[NSWindow alloc] initWithContentRect:rect styleMask:style backing:bt defer:NO] retain];\n+        testWindow.title = @\"NSWindow\";\n+        [testWindow setBackgroundColor:[NSColor blueColor]];\n+        [testWindow makeKeyAndOrderFront:nil];\n+        \/\/ Java coordinates are 100, 200\n+\n+        colorPanel = [[NSColorPanel sharedColorPanel] retain];\n+        [colorPanel setReleasedWhenClosed: YES];\n+        colorPanel.restorable = NO;\n+        [colorPanel setFrame:NSMakeRect(130, screenFrame.size.height - 500, 200, 200) display:NO];\n+        \/\/ Java coordinates are 100, 400\n+        [colorPanel makeKeyAndOrderFront: nil];\n+    };\n+\n+    if ([NSThread isMainThread]) {\n+        block();\n+    } else {\n+        [BlockRunner performBlock:block];\n+    }\n+\n+    JNI_COCOA_EXIT(env);\n+}\n+\n+\/*\n+ * Class:     TestMainKeyWindow\n+ * Method:    takedown\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_TestMainKeyWindow_takedown(JNIEnv *env, jclass cl)\n+{\n+    JNI_COCOA_ENTER(env);\n+\n+    void (^block)() = ^(){\n+        if (testWindow != nil) {\n+            [testWindow close];\n+            testWindow = nil;\n+        }\n+        if (colorPanel != nil) {\n+            [colorPanel orderOut:nil];\n+            colorPanel = nil;\n+        }\n+    };\n+\n+    if ([NSThread isMainThread]) {\n+        block();\n+    } else {\n+        [BlockRunner performBlock:block];\n+    }\n+\n+    JNI_COCOA_EXIT(env);\n+}\n+\n+\/*\n+ * Class:     TestMainKeyWindow\n+ * Method:    activateApplication\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_TestMainKeyWindow_activateApplication\n+  (JNIEnv *env, jclass cl)\n+{\n+    JNI_COCOA_ENTER(env);\n+\n+    void (^block)() = ^(){\n+        [NSApp activateIgnoringOtherApps:YES];\n+    };\n+\n+    [BlockRunner performBlock:block];\n+\n+  JNI_COCOA_EXIT(env);\n+}\n","filename":"test\/jdk\/java\/awt\/Window\/MainKeyWindowTest\/libTestMainKeyWindow.m","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+ * @key printer\n@@ -41,0 +42,4 @@\n+        if (job.getPrintService() == null) {\n+            System.out.println(\"No printers. Test cannot continue\");\n+            return;\n+        }\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/TestPgfmtSetMPA.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @run testng Insert\n@@ -33,0 +32,2 @@\n+ * @run testng\/othervm -XX:-CompactStrings Insert\n+ * @run testng\/othervm -XX:+CompactStrings Insert\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/Insert.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,205 +0,0 @@\n-#!\/bin\/sh\n-\n-#\n-# Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#\n-# @test\n-# @bug 4833089 4992454\n-# @summary Check for proper handling of uncaught exceptions\n-# @author Martin Buchholz\n-#\n-# @run shell UncaughtExceptions.sh\n-\n-# To run this test manually, simply do .\/UncaughtExceptions.sh\n-\n- java=\"${TESTJAVA+${TESTJAVA}\/bin\/}java\"\n-javac=\"${COMPILEJAVA+${COMPILEJAVA}\/bin\/}javac\"\n-\n-failed=\"\"\n-Fail() { echo \"FAIL: $1\"; failed=\"${failed}.\"; }\n-\n-Die() { printf \"%s\\n\" \"$*\"; exit 1; }\n-\n-Sys() {\n-    \"$@\"; rc=\"$?\";\n-    test \"$rc\" -eq 0 || Die \"Command \\\"$*\\\" failed with exitValue $rc\";\n-}\n-\n-HorizontalRule() {\n-    echo \"-----------------------------------------------------------------\"\n-}\n-\n-Bottom() {\n-    test \"$#\" = 1 -a \"$1\" = \"Line\" || Die \"Usage: Bottom Line\"\n-\n-    HorizontalRule\n-    if test -n \"$failed\"; then\n-\tcount=`printf \"%s\" \"$failed\" | wc -c | tr -d ' '`\n-\techo \"FAIL: $count tests failed\"\n-\texit 1\n-    else\n-\techo \"PASS: all tests gave expected results\"\n-\texit 0\n-    fi\n-}\n-\n-Cleanup() { Sys rm -f Seppuku* OK.class; }\n-\n-set -u\n-\n-checkOutput() {\n-    name=\"$1\" expected=\"$2\" got=\"$3\"\n-    printf \"$name:\\n\"; cat \"$got\"\n-    if test -z \"$expected\"; then\n-\ttest \"`cat $got`\" != \"\" && \\\n-\t    Fail \"Unexpected $name: `cat $got`\"\n-    else\n-\tgrep \"$expected\" \"$got\" >\/dev\/null || \\\n-\t    Fail \"Expected \\\"$expected\\\", got `cat $got`\"\n-    fi\n-}\n-\n-CheckCommandResults() {\n-    expectedRC=\"$1\" expectedOut=\"$2\" expectedErr=\"$3\"; shift 3\n-    saveFailed=\"${failed}\"\n-    \"$@\" >TmpTest.Out 2>TmpTest.Err; rc=\"$?\";\n-    printf \"==> %s (rc=%d)\\n\" \"$*\" \"$rc\"\n-    checkOutput \"stdout\" \"$expectedOut\" \"TmpTest.Out\"\n-    checkOutput \"stderr\" \"$expectedErr\" \"TmpTest.Err\"\n-    test \"${saveFailed}\" = \"${failed}\" && \\\n-\techo \"PASS: command completed as expected\"\n-    Sys rm -f TmpTest.Out TmpTest.Err\n-}\n-\n-Run() {\n-    expectedRC=\"$1\" expectedOut=\"$2\" expectedErr=\"$3\" mainBody=\"$4\"\n-    cat > Seppuku.java <<EOJAVA\n-import static java.lang.Thread.*;\n-import static java.lang.System.*;\n-\n-class OK implements UncaughtExceptionHandler {\n-    public void uncaughtException(Thread t, Throwable e) {\n-\tout.println(\"OK\");\n-    }\n-}\n-\n-class NeverInvoked implements UncaughtExceptionHandler {\n-    public void uncaughtException(Thread t, Throwable e) {\n-\terr.println(\"Test failure: This handler should never be invoked!\");\n-    }\n-}\n-\n-public class Seppuku extends Thread implements Runnable {\n-    public static void seppuku() { throw new RuntimeException(\"Seppuku!\"); }\n-\n-    public void run() {\tseppuku(); }\n-\n-    public static void main(String[] args) throws Exception {\n-\t$mainBody\n-    }\n-}\n-EOJAVA\n-\n-    Sys \"$javac\" ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} \"Seppuku.java\"\n-    CheckCommandResults \"$expectedRC\" \"$expectedOut\" \"$expectedErr\" \\\n-\t\"$java\" \"Seppuku\"\n-    Cleanup\n-}\n-\n-#----------------------------------------------------------------\n-# A thread is never alive after you've join()ed it.\n-#----------------------------------------------------------------\n-Run 0 \"OK\" \"Exception in thread \\\"Thread-0\\\".*Seppuku\" \"\n-    Thread t = new Seppuku();\n-    t.start(); t.join();\n-    if (! t.isAlive())\n-\tout.println(\\\"OK\\\");\"\n-\n-#----------------------------------------------------------------\n-# Even the main thread is mortal - here it terminates \"abruptly\"\n-#----------------------------------------------------------------\n-Run 1 \"OK\" \"Exception in thread \\\"main\\\".*Seppuku\" \"\n-    final Thread mainThread = currentThread();\n-    new Thread() { public void run() {\n-\ttry { mainThread.join(); }\n-\tcatch (InterruptedException e) {}\n-\tif (! mainThread.isAlive())\n-\t    out.println(\\\"OK\\\");\n-    }}.start();\n-    seppuku();\"\n-\n-#----------------------------------------------------------------\n-# Even the main thread is mortal - here it terminates normally.\n-#----------------------------------------------------------------\n-Run 0 \"OK\" \"\" \"\n-    final Thread mainThread = currentThread();\n-    new Thread() { public void run() {\n-\ttry { mainThread.join(); }\n-\tcatch (InterruptedException e) {}\n-\tif (! mainThread.isAlive())\n-\t    out.println(\\\"OK\\\");\n-    }}.start();\"\n-\n-#----------------------------------------------------------------\n-# Check uncaught exception handler mechanism on the main thread.\n-# Check that thread-level handler overrides global default handler.\n-#----------------------------------------------------------------\n-Run 1 \"OK\" \"\" \"\n-    currentThread().setUncaughtExceptionHandler(new OK());\n-    setDefaultUncaughtExceptionHandler(new NeverInvoked());\n-    seppuku();\"\n-\n-Run 1 \"OK\" \"\" \"\n-    setDefaultUncaughtExceptionHandler(new OK());\n-    seppuku();\"\n-\n-#----------------------------------------------------------------\n-# Check uncaught exception handler mechanism on non-main threads.\n-#----------------------------------------------------------------\n-Run 0 \"OK\" \"\" \"\n-    Thread t = new Seppuku();\n-    t.setUncaughtExceptionHandler(new OK());\n-    t.start();\"\n-\n-Run 0 \"OK\" \"\" \"\n-    setDefaultUncaughtExceptionHandler(new OK());\n-    new Seppuku().start();\"\n-\n-#----------------------------------------------------------------\n-# Test ThreadGroup based uncaught exception handler mechanism.\n-# Since the handler for the main thread group cannot be changed,\n-# there are no tests for the main thread here.\n-#----------------------------------------------------------------\n-Run 0 \"OK\" \"\" \"\n-    setDefaultUncaughtExceptionHandler(new NeverInvoked());\n-    new Thread(\n-\tnew ThreadGroup(\\\"OK\\\") {\n-\t    public void uncaughtException(Thread t, Throwable e) {\n-\t\tout.println(\\\"OK\\\");}},\n-\tnew Seppuku()\n-    ).start();\"\n-\n-Cleanup\n-\n-Bottom Line\n","filename":"test\/jdk\/java\/lang\/Thread\/UncaughtExceptions.sh","additions":0,"deletions":205,"binary":false,"changes":205,"status":"deleted"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import static java.lang.System.err;\n+import static java.lang.System.out;\n+\n+\/*\n+ * @test\n+ * @bug 4833089 4992454\n+ * @summary Check for proper handling of uncaught exceptions\n+ * @author Martin Buchholz\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.process.*\n+ * @run testng UncaughtExceptionsTest\n+ *\/\n+public class UncaughtExceptionsTest {\n+\n+    @DataProvider\n+    public Object[][] testCases() {\n+        return new Object[][]{\n+            new Object[] { \"ThreadIsDeadAfterJoin\",\n+                           0,\n+                           UncaughtExitSimulator.EXPECTED_RESULT,\n+                           \"Exception in thread \\\"Thread-0\\\".*simulateUncaughtExitEvent\"\n+            },\n+            new Object[] {\n+                            \"MainThreadAbruptTermination\",\n+                            1,\n+                            UncaughtExitSimulator.EXPECTED_RESULT,\n+                            \"Exception in thread \\\"main\\\".*simulateUncaughtExitEvent\"\n+            },\n+            new Object[] { \"MainThreadNormalTermination\", 0, UncaughtExitSimulator.EXPECTED_RESULT, \"\"},\n+            new Object[] { \"DefaultUncaughtExceptionHandlerOnMainThread\", 1, UncaughtExitSimulator.EXPECTED_RESULT, \"\" },\n+            new Object[] { \"DefaultUncaughtExceptionHandlerOnMainThreadOverride\", 1, UncaughtExitSimulator.EXPECTED_RESULT, \"\" },\n+            new Object[] { \"DefaultUncaughtExceptionHandlerOnNonMainThreadOverride\", 0, UncaughtExitSimulator.EXPECTED_RESULT, \"\" },\n+            new Object[] { \"DefaultUncaughtExceptionHandlerOnNonMainThread\", 0, UncaughtExitSimulator.EXPECTED_RESULT, \"\" },\n+            new Object[] { \"ThreadGroupUncaughtExceptionHandlerOnNonMainThread\", 0, UncaughtExitSimulator.EXPECTED_RESULT, \"\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testCases\")\n+    public void test(String className, int exitValue, String stdOutMatch, String stdErrMatch) throws Throwable {\n+        ProcessBuilder processBuilder = ProcessTools.createJavaProcessBuilder(String.format(\"UncaughtExitSimulator$%s\",className));\n+        OutputAnalyzer outputAnalyzer = ProcessTools.executeCommand(processBuilder);\n+        outputAnalyzer.shouldHaveExitValue(exitValue);\n+        outputAnalyzer.stderrShouldMatch(stdErrMatch);\n+        outputAnalyzer.stdoutShouldMatch(stdOutMatch);\n+    }\n+\n+}\n+\n+\n+class OK implements Thread.UncaughtExceptionHandler {\n+    public void uncaughtException(Thread t, Throwable e) {\n+        out.println(UncaughtExitSimulator.EXPECTED_RESULT);\n+    }\n+}\n+\n+class NeverInvoked implements Thread.UncaughtExceptionHandler {\n+    public void uncaughtException(Thread t, Throwable e) {\n+        err.println(\"Test failure: This handler should never be invoked!\");\n+    }\n+}\n+\n+class UncaughtExitSimulator extends Thread implements Runnable {\n+\n+    final static String EXPECTED_RESULT = \"OK\";\n+\n+    public static void throwRuntimeException() { throw new RuntimeException(\"simulateUncaughtExitEvent\"); }\n+\n+    public void run() { throwRuntimeException(); }\n+\n+    \/**\n+     * A thread is never alive after you've join()ed it.\n+     *\/\n+    public static class ThreadIsDeadAfterJoin extends UncaughtExitSimulator {\n+        public static void main(String[] args) throws Exception {\n+            Thread t = new UncaughtExitSimulator();\n+            t.start(); t.join();\n+            if (! t.isAlive()) {\n+                out.println(EXPECTED_RESULT);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Even the main thread is mortal - here it terminates \"abruptly\"\n+     *\/\n+    public static class MainThreadAbruptTermination extends UncaughtExitSimulator {\n+        public static void main(String[] args) {\n+            final Thread mainThread = currentThread();\n+            new Thread() { public void run() {\n+                try { mainThread.join(); }\n+                catch (InterruptedException e) {}\n+                if (! mainThread.isAlive())\n+                    out.println(EXPECTED_RESULT);\n+            }}.start();\n+            throwRuntimeException();\n+        }\n+    }\n+\n+    \/**\n+     * Even the main thread is mortal - here it terminates normally.\n+     *\/\n+    public static class MainThreadNormalTermination extends UncaughtExitSimulator {\n+        public static void main(String[] args) {\n+            final Thread mainThread = currentThread();\n+            new Thread() {\n+                public void run() {\n+                    try {\n+                        mainThread.join();\n+                    } catch (InterruptedException e) {\n+                    }\n+                    if (!mainThread.isAlive())\n+                        out.println(EXPECTED_RESULT);\n+                }\n+            }.start();\n+        }\n+    }\n+\n+    \/**\n+     * Check uncaught exception handler mechanism on the main thread.\n+     *\/\n+    public static class DefaultUncaughtExceptionHandlerOnMainThread extends UncaughtExitSimulator {\n+        public static void main(String[] args) {\n+            currentThread().setUncaughtExceptionHandler(new OK());\n+            setDefaultUncaughtExceptionHandler(new NeverInvoked());\n+            throwRuntimeException();\n+        }\n+    }\n+\n+    \/**\n+     * Check that thread-level handler overrides global default handler.\n+     *\/\n+    public static class DefaultUncaughtExceptionHandlerOnMainThreadOverride extends UncaughtExitSimulator {\n+        public static void main(String[] args) {\n+            setDefaultUncaughtExceptionHandler(new OK());\n+            throwRuntimeException();\n+        }\n+    }\n+\n+    \/**\n+     * Check uncaught exception handler mechanism on non-main threads.\n+     *\/\n+    public static class DefaultUncaughtExceptionHandlerOnNonMainThreadOverride extends UncaughtExitSimulator {\n+        public static void main(String[] args) {\n+            Thread t = new UncaughtExitSimulator();\n+            t.setUncaughtExceptionHandler(new OK());\n+            t.start();\n+        }\n+    }\n+\n+    \/**\n+     * Check uncaught exception handler mechanism on non-main threads.\n+     *\/\n+    public static class DefaultUncaughtExceptionHandlerOnNonMainThread extends UncaughtExitSimulator {\n+        public static void main(String[] args) {\n+            setDefaultUncaughtExceptionHandler(new OK());\n+            new UncaughtExitSimulator().start();\n+        }\n+    }\n+\n+    \/**\n+     * Test ThreadGroup based uncaught exception handler mechanism.\n+     * Since the handler for the main thread group cannot be changed,\n+     * there are no tests for the main thread here.\n+     *\/\n+    public static class ThreadGroupUncaughtExceptionHandlerOnNonMainThread extends UncaughtExitSimulator {\n+        public static void main(String[] args) {\n+            setDefaultUncaughtExceptionHandler(new NeverInvoked());\n+            new Thread(\n+                    new ThreadGroup(EXPECTED_RESULT) {\n+                        public void uncaughtException(Thread t, Throwable e) {\n+                            out.println(EXPECTED_RESULT);\n+                        }\n+                    },\n+                    new UncaughtExitSimulator()\n+            ).start();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/UncaughtExceptionsTest.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 6827032\n+ * @bug 6827032 8197825\n@@ -41,1 +41,0 @@\n-\n@@ -43,0 +42,1 @@\n+    private static JFrame frame;\n@@ -46,9 +46,33 @@\n-        UIManager.setLookAndFeel(new NimbusLookAndFeel());\n-\n-        Robot robot = new Robot();\n-        robot.setAutoDelay(50);\n-\n-\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-            public void run() {\n-                createAndShowGUI();\n+        try {\n+            UIManager.setLookAndFeel(new NimbusLookAndFeel());\n+\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                public void run() {\n+                    createAndShowGUI();\n+                }\n+            });\n+\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(new Runnable() {\n+                public void run() {\n+                    Component previewPanel = Util.findSubComponent(cc, \"javax.swing.colorchooser.DefaultPreviewPanel\");\n+                    point = previewPanel.getLocationOnScreen();\n+                }\n+            });\n+\n+            point.translate(5, 5);\n+\n+            robot.mouseMove(point.x, point.y);\n+            robot.waitForIdle();\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+        } finally {\n+            if (frame != null) {\n+                SwingUtilities.invokeAndWait(() -> frame.dispose());\n@@ -56,16 +80,1 @@\n-        });\n-\n-        robot.waitForIdle();\n-\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-            public void run() {\n-                Component previewPanel = Util.findSubComponent(cc, \"javax.swing.colorchooser.DefaultPreviewPanel\");\n-                point = previewPanel.getLocationOnScreen();\n-            }\n-        });\n-\n-        point.translate(5, 5);\n-\n-        robot.mouseMove(point.x, point.y);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        }\n@@ -76,1 +85,1 @@\n-        JFrame frame = new JFrame(Test6827032.class.getName());\n+        frame = new JFrame(Test6827032.class.getName());\n@@ -82,0 +91,1 @@\n+        frame.setLocationRelativeTo(null);\n","filename":"test\/jdk\/javax\/swing\/JColorChooser\/Test6827032.java","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n- * @run main\/othervm jdk.jfr.jmx.streaming.TestRotate\n+ * @run main\/othervm -Xlog:jfr=debug jdk.jfr.jmx.streaming.TestRotate\n","filename":"test\/jdk\/jdk\/jfr\/jmx\/streaming\/TestRotate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 7184246\n- * @summary Simplify Config.get() of krb5\n- * @modules java.security.jgss\/sun.security.krb5:+open\n- *\/\n-import java.lang.reflect.Field;\n-import java.lang.reflect.Method;\n-import java.util.Hashtable;\n-import java.util.Vector;\n-import sun.security.krb5.Config;\n-import sun.security.krb5.SCDynamicStoreConfig;\n-\n-public class SCDynamicConfigTest {\n-\n-    static Vector<Hashtable<String,String>>hosts() {\n-        Vector <Hashtable<String,String>> result = new Vector<>();\n-        Hashtable<String,String> pair = new Hashtable<>();\n-        pair.put(\"host\", \"127.0.0.1\");\n-        result.add(pair);\n-        pair = new Hashtable<>();\n-        pair.put(\"host\", \"127.0.0.2\");\n-        result.add(pair);\n-        return result;\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ Reconstruct a typical SCDynamicConfig.getKerberosConfig() output\n-        Hashtable<String, Object> conf = new Hashtable<>();\n-\n-        Hashtable<String, Object> libdefaults = new Hashtable<>();\n-        libdefaults.put(\"default_realm\", \"REALM.COM\");\n-        conf.put(\"libdefaults\", libdefaults);\n-\n-        Hashtable<String, Object> realms = new Hashtable<>();\n-        Hashtable<String, Object> thisRealm = new Hashtable<>();\n-        realms.put(\"REALM.COM\", thisRealm);\n-        thisRealm.put(\"kpasswd\", hosts());\n-        thisRealm.put(\"kadmin\", hosts());\n-        thisRealm.put(\"kdc\", hosts());\n-        conf.put(\"realms\", realms);\n-\n-        Hashtable<String, Object> domain_realm = new Hashtable<>();\n-        domain_realm.put(\".realm.com\", \"REALM.COM\");\n-        domain_realm.put(\"realm.com\", \"REALM.COM\");\n-        conf.put(\"domain_realm\", domain_realm);\n-\n-        System.out.println(\"SCDynamicConfig:\\n\");\n-        System.out.println(conf);\n-\n-        \/\/ Simulate SCDynamicConfig.getConfig() output\n-        Method m = SCDynamicStoreConfig.class.getDeclaredMethod(\n-                \"convertNativeConfig\", Hashtable.class);\n-        m.setAccessible(true);\n-        conf = (Hashtable)m.invoke(null, conf);\n-\n-        System.out.println(\"\\nkrb5.conf:\\n\");\n-        System.out.println(conf);\n-\n-        \/\/ Feed it into a Config object\n-        System.setProperty(\"java.security.krb5.conf\", \"not-a-file\");\n-        Config cf = Config.getInstance();\n-        Field f = Config.class.getDeclaredField(\"stanzaTable\");\n-        f.setAccessible(true);\n-        f.set(cf, conf);\n-\n-        System.out.println(\"\\nConfig:\\n\");\n-        System.out.println(cf);\n-\n-        if (!cf.getDefaultRealm().equals(\"REALM.COM\")) {\n-            throw new Exception();\n-        }\n-        if (!cf.getKDCList(\"REALM.COM\").equals(\"127.0.0.1 127.0.0.2\")) {\n-            throw new Exception();\n-        }\n-        if (!cf.get(\"domain_realm\", \".realm.com\").equals(\"REALM.COM\")) {\n-            throw new Exception();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/SCDynamicConfigTest.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8257860\n+ * @summary SCDynamicStoreConfig works\n+ * @modules java.security.jgss\/sun.security.krb5\n+ * @library \/test\/lib\n+ * @run main\/manual\/native TestDynamicStore\n+ * @requires (os.family == \"mac\")\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.krb5.Config;\n+\n+public class TestDynamicStore {\n+\n+    native static int actionInternal(char what, char whom);\n+\n+    \/\/ what: 'a' for add, 'r' for remove\n+    \/\/ whom: 'a' for all, 'r' for realm, 'm' for mapping\n+    static int action(char what, char whom) throws Exception {\n+        int out = actionInternal(what, whom);\n+        System.out.println(\"Run \" + what + whom + \" \" + out);\n+        Thread.sleep(1000);   \/\/ wait for callback called\n+        return out;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        System.loadLibrary(\"TestDynamicStore\");\n+\n+        Config cfg = Config.getInstance();\n+        if (cfg.exists(\"libdefaults\") || cfg.exists(\"realms\")) {\n+            System.out.println(\"Already have krb5 config. Will not touch\");\n+            return;\n+        }\n+\n+        try {\n+            System.out.println(\"Fill in dynamic store\");\n+            action('a', 'a');\n+            Asserts.assertTrue(Config.getInstance().get(\"libdefaults\", \"default_realm\").equals(\"A.COM\"));\n+            Asserts.assertTrue(Config.getInstance().exists(\"domain_realm\"));\n+\n+            System.out.println(\"Remove mapping\");\n+            action('r', 'm');\n+            Asserts.assertTrue(!Config.getInstance().exists(\"domain_realm\"));\n+\n+            System.out.println(\"Re-add mapping\");\n+            action('a', 'm');\n+            Asserts.assertTrue(Config.getInstance().exists(\"domain_realm\"));\n+\n+            System.out.println(\"Remove realm info\");\n+            action('r', 'r');\n+            \/\/ Realm info is not watched, so no change detected\n+            Asserts.assertTrue(Config.getInstance().get(\"libdefaults\", \"default_realm\").equals(\"A.COM\"));\n+\n+            System.out.println(\"Remove mapping\");\n+            action('r', 'm');\n+            \/\/ But mapping is watched, so realm info is not re-read\n+            Asserts.assertTrue(Config.getInstance().get(\"libdefaults\", \"default_realm\").equals(\"B.COM\"));\n+        } finally {\n+            System.out.println(\"Remove everything\");\n+            action('r', 'a');\n+            Asserts.assertTrue(!Config.getInstance().exists(\"libdefault\"));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/native\/TestDynamicStore.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,111 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#import <Cocoa\/Cocoa.h>\n+#import <SystemConfiguration\/SystemConfiguration.h>\n+#import <jni.h>\n+\n+#define KERBEROS_DEFAULT_REALMS @\"Kerberos-Default-Realms\"\n+#define KERBEROS_DEFAULT_REALM_MAPPINGS @\"Kerberos-Domain-Realm-Mappings\"\n+#define KERBEROS_REALM_INFO @\"Kerberos:%@\"\n+\n+int removeAll(SCDynamicStoreRef store) {\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS));\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"A.COM\"]));\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"B.COM\"]));\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS));\n+    return 1;\n+}\n+\n+int removeRealm(SCDynamicStoreRef store) {\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"A.COM\"]));\n+    return 1;\n+}\n+\n+int removeMapping(SCDynamicStoreRef store) {\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreRemoveValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS));\n+    return 1;\n+}\n+\n+int addMapping(SCDynamicStoreRef store) {\n+    NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:\n+        @\"a\", @\"A\",\n+        @\"b\", @\"B\",\n+        @\"c\", @\"C\",\n+        @\"d\", @\"D\",\n+        nil];\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreSetValue(store, (CFStringRef) KERBEROS_DEFAULT_REALM_MAPPINGS, [NSArray arrayWithObjects: dict, nil]));\n+    return 1;\n+}\n+\n+int addAll(SCDynamicStoreRef store) {\n+    NSArray *keys = [NSArray arrayWithObjects:@\"A.COM\", @\"B.COM\", nil];\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreSetValue(store, (CFStringRef) KERBEROS_DEFAULT_REALMS, keys));\n+\n+    NSDictionary *k1 = [NSDictionary dictionaryWithObjectsAndKeys:\n+        @\"kdc1.a.com\", @\"host\", nil];\n+    NSDictionary *k2 = [NSDictionary dictionaryWithObjectsAndKeys:\n+        @\"kdc2.a.com\", @\"host\", nil];\n+    NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:\n+        [NSArray arrayWithObjects: k1, k2, nil], @\"kdc\",\n+        nil];\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreSetValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"A.COM\"], dict));\n+\n+    k1 = [NSDictionary dictionaryWithObjectsAndKeys:\n+        @\"kdc1.b.com\", @\"host\", nil];\n+    k2 = [NSDictionary dictionaryWithObjectsAndKeys:\n+        @\"kdc2.b.com\", @\"host\", nil];\n+    dict = [NSDictionary dictionaryWithObjectsAndKeys:\n+        [NSArray arrayWithObjects: k1, k2, nil], @\"kdc\",\n+        nil];\n+    fprintf(stderr, \"%d\\n\", SCDynamicStoreSetValue(store, (CFStringRef) [NSString stringWithFormat:KERBEROS_REALM_INFO, @\"B.COM\"], dict));\n+    addMapping(store);\n+    return 1;\n+}\n+\n+JNIEXPORT jint JNICALL Java_TestDynamicStore_actionInternal(JNIEnv *env, jclass clazz, jchar what, jchar whom) {\n+    SCDynamicStoreRef store = SCDynamicStoreCreate(NULL, CFSTR(\"java-kerberos\"), NULL, NULL);\n+    fprintf(stderr, \">>> action: %c %c\\n\", what, whom);\n+    @try {\n+        switch (what) {\n+            case 'a':\n+                switch (whom) {\n+                    case 'a': return addAll(store);\n+                    case 'm': return addMapping(store);\n+                }\n+                break;\n+            case 'r':\n+                switch (whom) {\n+                    case 'a': return removeAll(store);\n+                    case 'r': return removeRealm(store);\n+                    case 'm': return removeMapping(store);\n+                }\n+                break;\n+        }\n+        return 0;\n+    } @finally {\n+        CFRelease(store);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/native\/libTestDynamicStore.m","additions":111,"deletions":0,"binary":false,"changes":111,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8222850\n+ * @summary Check error recovery for switch over undefined variables.\n+ * @compile\/fail\/ref=SwitchUndefinedSelector.out -XDrawDiagnostics --should-stop=at=FLOW SwitchUndefinedSelector.java\n+ *\/\n+\n+public class SwitchUndefinedSelector {\n+    private static final Object D = null;\n+    public void switchTest() {\n+        switch (undefined) {\n+            case A -> {}\n+            case B, C -> {}\n+            case D -> {}\n+        }\n+        var v = switch (undefined) {\n+            case A -> 0;\n+            case B, C -> 0;\n+            case D -> 0;\n+        };\n+        switch (undefined) {\n+            case SwitchUndefinedSelector.D -> {}\n+            case SwitchUndefinedSelector.UNDEF -> {}\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/recovery\/SwitchUndefinedSelector.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,6 @@\n+SwitchUndefinedSelector.java:11:17: compiler.err.cant.resolve.location: kindname.variable, undefined, , , (compiler.misc.location: kindname.class, SwitchUndefinedSelector, null)\n+SwitchUndefinedSelector.java:16:25: compiler.err.cant.resolve.location: kindname.variable, undefined, , , (compiler.misc.location: kindname.class, SwitchUndefinedSelector, null)\n+SwitchUndefinedSelector.java:21:17: compiler.err.cant.resolve.location: kindname.variable, undefined, , , (compiler.misc.location: kindname.class, SwitchUndefinedSelector, null)\n+SwitchUndefinedSelector.java:22:41: compiler.err.string.const.req\n+SwitchUndefinedSelector.java:23:41: compiler.err.cant.resolve.location: kindname.variable, UNDEF, , , (compiler.misc.location: kindname.class, SwitchUndefinedSelector, null)\n+5 errors\n","filename":"test\/langtools\/tools\/javac\/recovery\/SwitchUndefinedSelector.out","additions":6,"deletions":0,"binary":false,"changes":6,"status":"added"},{"patch":"@@ -23,4 +23,0 @@\n-\/*\n- * To change this template, choose Tools | Templates\n- * and open the template in the editor.\n- *\/\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegers.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -23,5 +23,0 @@\n-\/*\n- * To change this template, choose Tools | Templates\n- * and open the template in the editor.\n- *\/\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/WriteBarrier.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}