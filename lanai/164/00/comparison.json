{"files":[{"patch":"@@ -74,1 +74,1 @@\n-            this.config = MTLGraphicsConfig.getConfig(this, displayID, 0);\n+            this.config = MTLGraphicsConfig.getConfig(this, displayID);\n@@ -102,1 +102,1 @@\n-                this.config = MTLGraphicsConfig.getConfig(this, displayID, 0);\n+                this.config = MTLGraphicsConfig.getConfig(this, displayID);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/CGraphicsDevice.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,8 +108,0 @@\n-    \/**\n-     * Returns a string representing adapter id (vendor, renderer, version).\n-     * Must be called on the rendering thread.\n-     *\n-     * @return an id string for the adapter\n-     *\/\n-    public static final native String getMTLIdString();\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLContext.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -75,3 +75,0 @@\n-    \/\/private static final int kOpenGLSwapInterval =\n-    \/\/ RuntimeOptions.getCurrentOptions().OpenGLSwapInterval;\n-    private static final int kMetalSwapInterval = 0; \/\/ TODO\n@@ -87,1 +84,0 @@\n-    private int pixfmt;\n@@ -109,1 +105,1 @@\n-    private MTLGraphicsConfig(CGraphicsDevice device, int pixfmt,\n+    private MTLGraphicsConfig(CGraphicsDevice device,\n@@ -114,1 +110,0 @@\n-        this.pixfmt = pixfmt;\n@@ -138,1 +133,1 @@\n-                                              int displayID, int pixfmt)\n+                                              int displayID)\n@@ -150,1 +145,0 @@\n-        final String[] ids = new String[1];\n@@ -166,3 +160,0 @@\n-                rq.flushAndInvokeNow(() -> {\n-                    ids[0] = MTLContext.getMTLIdString();\n-                });\n@@ -182,2 +173,2 @@\n-                ids[0]);\n-        return new MTLGraphicsConfig(device, pixfmt, cfginfo, textureSize, caps);\n+                null);\n+        return new MTLGraphicsConfig(device, cfginfo, textureSize, caps);\n@@ -276,2 +267,1 @@\n-        return (\"MTLGraphicsConfig[\" + getDevice().getIDstring() +\n-                \",pixfmt=\"+pixfmt+\"]\");\n+        return (\"MTLGraphicsConfig[\" + getDevice().getIDstring() + \"]\");\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLGraphicsConfig.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,280 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.java2d.metal;\n-\n-import sun.java2d.SunGraphics2D;\n-import sun.java2d.SurfaceData;\n-import sun.java2d.pipe.Region;\n-\n-import java.awt.Graphics;\n-import java.awt.GraphicsConfiguration;\n-import java.awt.Rectangle;\n-\n-\/**\n- * This class contains a number of static utility methods that may be\n- * called (via reflection) by a third-party library in order\n- * to interoperate with the metal-based Java 2D pipeline.\n- *\n- *\/\n-class MTLUtilities {\n-\n-    \/**\n-     * These MTL-specific surface type constants are the same as those\n-     * defined in the MTLSurfaceData class and are duplicated here so that\n-     * clients of this API can access them more easily via reflection.\n-     *\/\n-    public static final int UNDEFINED       = MTLSurfaceData.UNDEFINED;\n-    public static final int WINDOW          = MTLSurfaceData.WINDOW;\n-    public static final int TEXTURE         = MTLSurfaceData.TEXTURE;\n-    public static final int FLIP_BACKBUFFER = MTLSurfaceData.FLIP_BACKBUFFER;\n-    public static final int RT_TEXTURE      = MTLSurfaceData.RT_TEXTURE;\n-\n-    private MTLUtilities() {\n-    }\n-\n-    \/**\n-     * Returns true if the current thread is the MTL QueueFlusher thread.\n-     *\/\n-    public static boolean isQueueFlusherThread() {\n-        return MTLRenderQueue.isQueueFlusherThread();\n-    }\n-\n-    \/**\n-     * Invokes the given Runnable on the MTL QueueFlusher thread with the\n-     * MTL context corresponding to the given Graphics object made\n-     * current.  It is legal for MTL code executed in the given\n-     * Runnable to change the current MTL context; it will be reset\n-     * once the Runnable completes.  No guarantees are made as to the\n-     * state of the MTL context of the Graphics object; for\n-     *\n-     * In order to avoid deadlock, it is important that the given Runnable\n-     * does not attempt to acquire the AWT lock, as that will be handled\n-     * automatically as part of the {@code rq.flushAndInvokeNow()} step.\n-     *\n-     * @param g the Graphics object for the corresponding destination surface;\n-     * if null, the step making a context current to the destination surface\n-     * will be skipped\n-     * @param r the action to be performed on the QFT; cannot be null\n-     * @return true if the operation completed successfully, or false if\n-     * there was any problem making a context current to the surface\n-     * associated with the given Graphics object\n-     *\/\n-    public static boolean invokeWithMTLContextCurrent(Graphics g, Runnable r) {\n-        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n-        rq.lock();\n-        try {\n-            if (g != null) {\n-                if (!(g instanceof SunGraphics2D)) {\n-                    return false;\n-                }\n-                SurfaceData sData = ((SunGraphics2D)g).surfaceData;\n-                if (!(sData instanceof MTLSurfaceData)) {\n-                    return false;\n-                }\n-\n-                \/\/ make a context current to the destination surface\n-                MTLContext.validateContext((MTLSurfaceData)sData);\n-            }\n-\n-            \/\/ invoke the given runnable on the QFT\n-            rq.flushAndInvokeNow(r);\n-\n-            \/\/ invalidate the current context so that the next time we render\n-            \/\/ with Java 2D, the context state will be completely revalidated\n-            MTLContext.invalidateCurrentContext();\n-        } finally {\n-            rq.unlock();\n-        }\n-\n-        return true;\n-    }\n-\n-    \/**\n-     * Invokes the given Runnable on the MTL QueueFlusher thread with the\n-     * \"shared\" MTL context (corresponding to the given\n-     * GraphicsConfiguration object) made current.  This method is typically\n-     * used when the Runnable needs a current context to complete its\n-     * operation, but does not require that the context be made current to\n-     * a particular surface.  For example, an application may call this\n-     * method so that the given Runnable can query the Metal capabilities\n-     * of the given GraphicsConfiguration, without making a context current\n-     * to a dummy surface (or similar hacky techniques).\n-     *\n-     * In order to avoid deadlock, it is important that the given Runnable\n-     * does not attempt to acquire the AWT lock, as that will be handled\n-     * automatically as part of the {@code rq.flushAndInvokeNow()} step.\n-     *\n-     * @param config the GraphicsConfiguration object whose \"shared\"\n-     * context will be made current during this operation; if this value is\n-     * null or if MTL is not enabled for the GraphicsConfiguration, this\n-     * method will return false\n-     * @param r the action to be performed on the QFT; cannot be null\n-     * @return true if the operation completed successfully, or false if\n-     * there was any problem making the shared context current\n-     *\/\n-    public static boolean\n-    invokeWithMTLSharedContextCurrent(GraphicsConfiguration config,\n-                                      Runnable r)\n-    {\n-        if (!(config instanceof MTLGraphicsConfig)) {\n-            return false;\n-        }\n-\n-        MTLRenderQueue rq = MTLRenderQueue.getInstance();\n-        rq.lock();\n-        try {\n-            \/\/ make the \"shared\" context current for the given GraphicsConfig\n-            MTLContext.setScratchSurface((MTLGraphicsConfig)config);\n-\n-            \/\/ invoke the given runnable on the QFT\n-            rq.flushAndInvokeNow(r);\n-\n-            \/\/ invalidate the current context so that the next time we render\n-            \/\/ with Java 2D, the context state will be completely revalidated\n-            MTLContext.invalidateCurrentContext();\n-        } finally {\n-            rq.unlock();\n-        }\n-\n-        return true;\n-    }\n-\n-    \/**\n-     * Returns the Rectangle describing the MTL viewport on the\n-     * Java 2D surface associated with the given Graphics object and\n-     * component width and height. When a third-party library is\n-     * performing MTL rendering directly into the visible region of\n-     * the associated surface, this viewport helps the application\n-     * position the MTL output correctly on that surface.\n-     *\n-     * Note that the x\/y values in the returned Rectangle object represent\n-     * the lower-left corner of the viewport region, relative to the\n-     * lower-left corner of the given surface.\n-     *\n-     * @param g the Graphics object for the corresponding destination surface;\n-     * cannot be null\n-     * @param componentWidth width of the component to be painted\n-     * @param componentHeight height of the component to be painted\n-     * @return a Rectangle describing the MTL viewport for the given\n-     * destination surface and component dimensions, or null if the given\n-     * Graphics object is invalid\n-     *\/\n-    public static Rectangle getMTLViewport(Graphics g,\n-                                           int componentWidth,\n-                                           int componentHeight)\n-    {\n-        if (!(g instanceof SunGraphics2D)) {\n-            return null;\n-        }\n-\n-        SunGraphics2D sg2d = (SunGraphics2D)g;\n-        SurfaceData sData = sg2d.surfaceData;\n-\n-        \/\/ this is the upper-left origin of the region to be painted,\n-        \/\/ relative to the upper-left origin of the surface\n-        \/\/ (in Java2D coordinates)\n-        int x0 = sg2d.transX;\n-        int y0 = sg2d.transY;\n-\n-        \/\/ this is the lower-left origin of the region to be painted,\n-        \/\/ relative to the lower-left origin of the surface\n-        \/\/ (in Metal coordinates)\n-        Rectangle surfaceBounds = sData.getBounds();\n-        int x1 = x0;\n-        int y1 = surfaceBounds.height - (y0 + componentHeight);\n-\n-        return new Rectangle(x1, y1, componentWidth, componentHeight);\n-    }\n-\n-    \/**\n-     * Returns the Rectangle describing the MTL scissor box on the\n-     * Java 2D surface associated with the given Graphics object.  When a\n-     * third-party library is performing MTL rendering directly\n-     * into the visible region of the associated surface, this scissor box\n-     * must be set to avoid drawing over existing rendering results.\n-     *\n-     * Note that the x\/y values in the returned Rectangle object represent\n-     * the lower-left corner of the scissor region, relative to the\n-     * lower-left corner of the given surface.\n-     *\n-     * @param g the Graphics object for the corresponding destination surface;\n-     * cannot be null\n-     * @return a Rectangle describing the MTL scissor box for the given\n-     * Graphics object and corresponding destination surface, or null if the\n-     * given Graphics object is invalid or the clip region is non-rectangular\n-     *\/\n-    public static Rectangle getOGLScissorBox(Graphics g) {\n-        if (!(g instanceof SunGraphics2D)) {\n-            return null;\n-        }\n-\n-        SunGraphics2D sg2d = (SunGraphics2D)g;\n-        SurfaceData sData = sg2d.surfaceData;\n-        Region r = sg2d.getCompClip();\n-        if (!r.isRectangular()) {\n-            \/\/ caller probably doesn't know how to handle shape clip\n-            \/\/ appropriately, so just return null (Swing currently never\n-            \/\/ sets a shape clip, but that could change in the future)\n-            return null;\n-        }\n-\n-        \/\/ this is the upper-left origin of the scissor box relative to the\n-        \/\/ upper-left origin of the surface (in Java 2D coordinates)\n-        int x0 = r.getLoX();\n-        int y0 = r.getLoY();\n-\n-        \/\/ this is the width and height of the scissor region\n-        int w = r.getWidth();\n-        int h = r.getHeight();\n-\n-        \/\/ this is the lower-left origin of the scissor box relative to the\n-        \/\/ lower-left origin of the surface (in Metal coordinates)\n-        Rectangle surfaceBounds = sData.getBounds();\n-        int x1 = x0;\n-        int y1 = surfaceBounds.height - (y0 + h);\n-\n-        return new Rectangle(x1, y1, w, h);\n-    }\n-\n-    \/**\n-     * Returns an Object identifier for the Java 2D surface associated with\n-     * the given Graphics object.  This identifier may be used to determine\n-     * whether the surface has changed since the last invocation of this\n-     * operation, and thereby whether the MTL state corresponding to the\n-     * old surface must be destroyed and recreated.\n-     *\n-     * @param g the Graphics object for the corresponding destination surface;\n-     * cannot be null\n-     * @return an identifier for the surface associated with the given\n-     * Graphics object, or null if the given Graphics object is invalid\n-     *\/\n-    public static Object getMTLSurfaceIdentifier(Graphics g) {\n-        if (!(g instanceof SunGraphics2D)) {\n-            return null;\n-        }\n-        return ((SunGraphics2D)g).surfaceData;\n-    }\n-}\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLUtilities.java","additions":0,"deletions":280,"binary":false,"changes":280,"status":"deleted"},{"patch":"@@ -140,3 +140,3 @@\n-                \/\/ 7160609: GL still fails to create a square texture of this\n-                \/\/ size. Half should be safe enough.\n-                \/\/ Explicitly not support a texture more than 2^14, see 8010999.\n+                \/\/ TODO : This clamping code is same as in OpenGL.\n+                \/\/ Whether we need such clamping or not in case of Metal\n+                \/\/ will be pursued under 8260644\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/opengl\/CGLGraphicsConfig.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        if ( CGraphicsDevice.usingMetalPipeline()) {\n+        if (CGraphicsDevice.usingMetalPipeline()) {\n@@ -83,1 +83,1 @@\n-        if ( CGraphicsDevice.usingMetalPipeline()) {\n+        if (CGraphicsDevice.usingMetalPipeline()) {\n@@ -127,1 +127,1 @@\n-        if ( CGraphicsDevice.usingMetalPipeline()) {\n+        if (CGraphicsDevice.usingMetalPipeline()) {\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformEmbeddedFrame.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -1221,2 +1221,0 @@\n-extern jboolean metalEnabled;\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTWindow.m","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -454,16 +454,0 @@\n-\/*\n- * Class:     sun_java2d_metal_MTLContext\n- * Method:    getMTLIdString\n- * Signature: ()Ljava\/lang\/String;\n- *\/\n-JNIEXPORT jstring JNICALL Java_sun_java2d_metal_MTLContext_getMTLIdString\n-  (JNIEnv *env, jclass mtlcc)\n-{\n-    char *vendor, *renderer, *version;\n-    char *pAdapterId;\n-    jobject ret = NULL;\n-    int len;\n-\n-    return NULL;\n-}\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.m","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -152,18 +152,0 @@\n-\/**\n- * Initializes a surface in the backbuffer of a given double-buffered\n- * onscreen window for use in a BufferStrategy.Flip situation.  The bounds of\n- * the backbuffer surface should always be kept in sync with the bounds of\n- * the underlying native window.\n- *\/\n-JNIEXPORT jboolean JNICALL\n-Java_sun_java2d_metal_MTLSurfaceData_initFlipBackbuffer\n-    (JNIEnv *env, jobject mtlsd,\n-     jlong pData)\n-{\n-    \/\/TODO\n-    MTLSDOps *mtlsdo = (MTLSDOps *)jlong_to_ptr(pData);\n-\n-    J2dTraceLn(J2D_TRACE_INFO, \"MTLSurfaceData_initFlipBackbuffer -- :TODO\");\n-    return JNI_TRUE;\n-}\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceData.m","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -101,1 +101,0 @@\n-    jint                       activeBuffer;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceDataBase.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n-#include \"Trace.h\"\n@@ -84,2 +83,0 @@\n-    J2dTraceLn(J2D_TRACE_INFO, \"Java_sun_java2d_SurfaceData_initIDs --- invoked \");\n-\n@@ -242,2 +239,0 @@\n-    J2dTraceLn(J2D_TRACE_INFO, \"SurfaceData_InitOps --- invoked \");\n-\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/SurfaceData.c","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"}]}