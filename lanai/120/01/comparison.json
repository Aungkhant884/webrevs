{"files":[{"patch":"@@ -182,1 +182,1 @@\n-                 pixelColor.b, srcA*uniforms.extraAlpha);\n+                 pixelColor.b, srcA)*uniforms.extraAlpha;\n@@ -330,1 +330,1 @@\n-                 srcColor.b*uniforms.normScaleFactors.b + uniforms.normOffsets.b, srcA*uniforms.extraAlpha);\n+                 srcColor.b*uniforms.normScaleFactors.b + uniforms.normOffsets.b, srcA)*uniforms.extraAlpha;\n@@ -371,1 +371,1 @@\n-    return half4(sum.r, sum.g, sum.b, srcA*uniforms.extraAlpha);\n+    return half4(sum.r, sum.g, sum.b, srcA)*uniforms.extraAlpha;\n@@ -414,1 +414,1 @@\n-    return half4(lookupR.a, lookupG.a, lookupB.a, a*uniforms.extraAlpha);\n+    return half4(lookupR.a, lookupG.a, lookupB.a, a)*uniforms.extraAlpha;\n@@ -669,1 +669,1 @@\n-                 pixelColor.b, srcA*uniforms.extraAlpha);\n+                 pixelColor.b, srcA)*uniforms.extraAlpha;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/shaders.metal","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -218,0 +218,39 @@\n+\/**\n+ * The MTLBlendRule structure encapsulates the two enumerated values that\n+ * comprise a given Porter-Duff blending (compositing) rule.  For example,\n+ * the \"SrcOver\" rule can be represented by:\n+ *     rule.src = GL_ONE;\n+ *     rule.dst = GL_ONE_MINUS_SRC_ALPHA;\n+ *\n+ *     GLenum src;\n+ * The constant representing the source factor in this Porter-Duff rule.\n+ *\n+ *     GLenum dst;\n+ * The constant representing the destination factor in this Porter-Duff rule.\n+ *\/\n+struct MTLBlendRule {\n+    MTLBlendFactor src;\n+    MTLBlendFactor dst;\n+};\n+\n+\/**\n+ * This table contains the standard blending rules (or Porter-Duff compositing\n+ * factors) used in setBlendingFactors(), indexed by the rule constants from the\n+ * AlphaComposite class.\n+ *\/\n+static struct MTLBlendRule StdBlendRules[] = {\n+        { MTLBlendFactorZero,                     MTLBlendFactorZero                }, \/* 0 - Nothing      *\/\n+        { MTLBlendFactorZero,                     MTLBlendFactorZero                }, \/* 1 - RULE_Clear   *\/\n+        { MTLBlendFactorOne,                      MTLBlendFactorZero                }, \/* 2 - RULE_Src     *\/\n+        { MTLBlendFactorOne,                      MTLBlendFactorOneMinusSourceAlpha }, \/* 3 - RULE_SrcOver *\/\n+        { MTLBlendFactorOneMinusDestinationAlpha, MTLBlendFactorOne                 }, \/* 4 - RULE_DstOver *\/\n+        { MTLBlendFactorDestinationAlpha,         MTLBlendFactorZero                }, \/* 5 - RULE_SrcIn   *\/\n+        { MTLBlendFactorZero,                     MTLBlendFactorSourceAlpha         }, \/* 6 - RULE_DstIn   *\/\n+        { MTLBlendFactorOneMinusDestinationAlpha, MTLBlendFactorZero                }, \/* 7 - RULE_SrcOut  *\/\n+        { MTLBlendFactorZero,                     MTLBlendFactorOneMinusSourceAlpha }, \/* 8 - RULE_DstOut  *\/\n+        { MTLBlendFactorZero,                     MTLBlendFactorOne                 }, \/* 9 - RULE_Dst     *\/\n+        { MTLBlendFactorDestinationAlpha,         MTLBlendFactorOneMinusSourceAlpha }, \/*10 - RULE_SrcAtop *\/\n+        { MTLBlendFactorOneMinusDestinationAlpha, MTLBlendFactorSourceAlpha         }, \/*11 - RULE_DstAtop *\/\n+        { MTLBlendFactorOneMinusDestinationAlpha, MTLBlendFactorOneMinusSourceAlpha }, \/*12 - RULE_AlphaXor*\/\n+};\n+\n@@ -223,4 +262,7 @@\n-    const jint compositeRule = composite != nil ? [composite getRule] : RULE_Src;\n-    if (compositeRule == RULE_Src &&\n-        (composite == nil || FLT_GE([composite getExtraAlpha], 1.0f))) {\n-        J2dTraceLn(J2D_TRACE_VERBOSE, \"set RULE_Src but blending is disabled because src is opaque\");\n+    const long compositeRule = composite != nil ? [composite getRule] : RULE_Src;\n+\n+    if ((compositeRule == RULE_Src || compositeRule == RULE_SrcOver) &&\n+        (composite == nil || FLT_GE([composite getExtraAlpha], 1.0f)) &&\n+        (renderOptions->srcFlags.isOpaque))\n+    {\n+        cad.blendingEnabled = NO;\n@@ -231,0 +273,2 @@\n+    cad.rgbBlendOperation = MTLBlendOperationAdd;\n+    cad.alphaBlendOperation = MTLBlendOperationAdd;\n@@ -232,152 +276,4 @@\n-    \/\/ RGB = Source.rgb * SBFc + Dest.rgb * DBFc\n-    \/\/ A = Source.a * SBFa + Dest.a * DBFa\n-    \/\/\n-    \/\/ default mode == RULE_Src with constants:\n-    \/\/ DBFa=0\n-    \/\/ DBFc=0\n-    \/\/ SBFa=1\n-    \/\/ SBFc=1\n-    \/\/\n-    \/\/ NOTE: constants MTLBlendFactorBlendAlpha, MTLBlendFactorOneMinusBlendAlpha refers to [encoder setBlendColorRed:green:blue:alpha:] (default value is zero)\n-    \/\/\n-    \/\/ TODO: implement alpha-composite via shaders (will be much more simpler and can support all rules and modes)\n-\n-    switch (compositeRule) {\n-        case RULE_SrcOver: {\n-            \/\/ Ar = As + Ad*(1-As)\n-            \/\/ Cr = Cs + Cd*(1-As)\n-            if (renderOptions->srcFlags.isOpaque &&\n-                (composite == nil ||\n-                 FLT_GE([composite getExtraAlpha], 1.0f)))\n-            {\n-                J2dTraceLn(J2D_TRACE_VERBOSE, \"rule=RULE_SrcOver, but blending is disabled because src is opaque\");\n-                cad.blendingEnabled = NO;\n-                return;\n-            }\n-            if (renderOptions->dstFlags.isOpaque) {\n-                \/\/ Ar = 1, can be ignored, so\n-                \/\/ Cr = Cs + Cd*(1-As)\n-                \/\/ TODO: select any multiplier with best performance\n-                \/\/ for example: cad.destinationAlphaBlendFactor = MTLBlendFactorZero;\n-            } else {\n-                cad.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n-            }\n-            if (!renderOptions->srcFlags.isPremultiplied) {\n-                cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;\n-            }\n-            if (composite != nil && FLT_LT([composite getExtraAlpha], 1.0f)) {\n-                cad.sourceRGBBlendFactor = MTLBlendFactorSourceAlpha;\n-            }\n-            cad.destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n-\n-            J2dTraceLn(J2D_TRACE_VERBOSE, \"set RULE_SrcOver\");\n-            break;\n-        }\n-        case RULE_DstOver: {\n-            \/\/ Ar = As*(1-Ad) + Ad\n-            \/\/ Cr = Cs*(1-Ad) + Cd\n-            if (renderOptions->srcFlags.isOpaque) {\n-                J2dTraceLn(J2D_TRACE_ERROR, \"Composite rule RULE_DstOver with opaque src isn't implemented (src alpha won't be ignored)\");\n-            }\n-            if (renderOptions->dstFlags.isOpaque) {\n-                J2dTraceLn(J2D_TRACE_ERROR, \"Composite rule RULE_DstOver with opaque dest hasn't any sense\");\n-            }\n-            if (!renderOptions->srcFlags.isPremultiplied) {\n-                J2dTrace(J2D_TRACE_ERROR, \"Composite rule RULE_DstOver with non-premultiplied source isn't implemented (scr alpha will be ignored for rgb-component)\");\n-            }\n-            cad.sourceAlphaBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;\n-            cad.sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;\n-            cad.destinationAlphaBlendFactor = MTLBlendFactorOne;\n-            cad.destinationRGBBlendFactor = MTLBlendFactorOne;\n-            J2dTraceLn(J2D_TRACE_VERBOSE, \"set RULE_DstOver\");\n-            break;\n-        }\n-        case RULE_SrcIn: {\n-            \/\/ Ar = As*Ad\n-            \/\/ Cr = Cs*Ad\n-            if (renderOptions->srcFlags.isOpaque) {\n-                J2dTraceLn(J2D_TRACE_ERROR, \"Composite rule RULE_SrcIn with opaque src isn't implemented (src alpha won't be ignored)\");\n-            }\n-            if (renderOptions->dstFlags.isOpaque) {\n-                J2dTraceLn(J2D_TRACE_VERBOSE, \"rule=RULE_SrcIn, but blending is disabled because dest is opaque\");\n-                cad.blendingEnabled = NO;\n-                return;\n-            }\n-            if (!renderOptions->srcFlags.isPremultiplied) {\n-                J2dTrace(J2D_TRACE_ERROR, \"Composite rule RULE_SrcIn with non-premultiplied source isn't implemented (scr alpha will be ignored for rgb-component)\");\n-            }\n-            cad.sourceAlphaBlendFactor = MTLBlendFactorDestinationAlpha;\n-            cad.sourceRGBBlendFactor = MTLBlendFactorDestinationAlpha;\n-            cad.destinationAlphaBlendFactor = MTLBlendFactorZero;\n-            cad.destinationRGBBlendFactor = MTLBlendFactorZero;\n-            J2dTraceLn(J2D_TRACE_VERBOSE, \"set RULE_SrcIn\");\n-            break;\n-        }\n-        case RULE_DstIn: {\n-            \/\/ Ar = Ad*As\n-            \/\/ Cr = Cd*As\n-            if (renderOptions->srcFlags.isOpaque) {\n-                J2dTraceLn(J2D_TRACE_ERROR, \"Composite rule RULE_DstIn with opaque src isn't implemented (src alpha won't be ignored)\");\n-            }\n-            if (renderOptions->dstFlags.isOpaque) {\n-                J2dTraceLn(J2D_TRACE_ERROR, \"Composite rule RULE_DstIn with opaque dest isn't implemented (dest alpha won't be ignored)\");\n-            }\n-            cad.sourceAlphaBlendFactor = MTLBlendFactorZero;\n-            cad.sourceRGBBlendFactor = MTLBlendFactorZero;\n-            cad.destinationAlphaBlendFactor = MTLBlendFactorSourceAlpha;\n-            cad.destinationRGBBlendFactor = MTLBlendFactorSourceAlpha;\n-            J2dTraceLn(J2D_TRACE_VERBOSE, \"set RULE_DstIn\");\n-            break;\n-        }\n-        case RULE_SrcOut: {\n-            \/\/ Ar = As*(1-Ad)\n-            \/\/ Cr = Cs*(1-Ad)\n-            if (!renderOptions->srcFlags.isPremultiplied) {\n-                J2dTrace(J2D_TRACE_ERROR, \"Composite rule SrcOut with non-premultiplied source isn't implemented (scr alpha will be ignored for rgb-component)\");\n-            }\n-            cad.sourceAlphaBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;\n-            cad.sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;\n-            cad.destinationAlphaBlendFactor = MTLBlendFactorZero;\n-            cad.destinationRGBBlendFactor = MTLBlendFactorZero;\n-            J2dTraceLn(J2D_TRACE_VERBOSE, \"set RULE_SrcOut\");\n-            break;\n-        }\n-        case RULE_DstOut: {\n-            \/\/ Ar = Ad*(1-As)\n-            \/\/ Cr = Cd*(1-As)\n-            cad.sourceAlphaBlendFactor = MTLBlendFactorZero;\n-            cad.sourceRGBBlendFactor = MTLBlendFactorZero;\n-            cad.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n-            cad.destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n-            J2dTraceLn(J2D_TRACE_VERBOSE, \"set RULE_DstOut\");\n-            break;\n-        }\n-        case RULE_Xor: {\n-            \/\/ Ar = As*(1-Ad) + Ad*(1-As)\n-            \/\/ Cr = Cs*(1-Ad) + Cd*(1-As)\n-            if (!renderOptions->srcFlags.isPremultiplied) {\n-                J2dTrace(J2D_TRACE_ERROR, \"Composite rule Xor with non-premultiplied source isn't implemented (scr alpha will be ignored for rgb-component)\");\n-            }\n-            cad.sourceAlphaBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;\n-            cad.sourceRGBBlendFactor = MTLBlendFactorOneMinusDestinationAlpha;\n-            cad.destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n-            cad.destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n-            J2dTraceLn(J2D_TRACE_VERBOSE, \"set RULE_Xor\");\n-            break;\n-        }\n-        case RULE_Clear: {\n-            \/\/ Ar = 0\n-            \/\/ Cr = 0\n-            cad.sourceAlphaBlendFactor = MTLBlendFactorZero;\n-            cad.sourceRGBBlendFactor = MTLBlendFactorZero;\n-            cad.destinationAlphaBlendFactor = MTLBlendFactorZero;\n-            cad.destinationRGBBlendFactor = MTLBlendFactorZero;\n-            J2dTraceLn(J2D_TRACE_VERBOSE, \"set RULE_Clear\");\n-            break;\n-        }\n-\n-        default: {\n-            J2dTrace1(J2D_TRACE_ERROR, \"Unimplemented composite rule %d (will be used Src)\", compositeRule);\n-            cad.blendingEnabled = NO;\n-        }\n-    }\n+    cad.sourceAlphaBlendFactor = StdBlendRules[compositeRule].src;\n+    cad.sourceRGBBlendFactor = StdBlendRules[compositeRule].src;\n+    cad.destinationAlphaBlendFactor = StdBlendRules[compositeRule].dst;\n+    cad.destinationRGBBlendFactor = StdBlendRules[compositeRule].dst;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPipelineStatesStorage.m","additions":52,"deletions":156,"binary":false,"changes":208,"status":"modified"}]}