{"files":[{"patch":"@@ -42,1 +42,2 @@\n-    VertexAttributeTexPos = 1\n+    VertexAttributeTexPos = 1,\n+    VertexAttributeITexPos = 2\n@@ -93,0 +94,6 @@\n+struct AAVertex {\n+    float position[2];\n+    float otxtpos[2];\n+    float itxtpos[2];\n+};\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/common.h","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -41,0 +41,6 @@\n+struct AAVertexInput {\n+    float2 position [[attribute(VertexAttributePosition)]];\n+    float2 oTexCoords [[attribute(VertexAttributeTexPos)]];\n+    float2 iTexCoords [[attribute(VertexAttributeITexPos)]];\n+};\n+\n@@ -46,0 +52,7 @@\n+struct AAShaderInOut {\n+    float4 position [[position]];\n+    float2 outerTexCoords;\n+    float2 innerTexCoords;\n+    half4  color;\n+};\n+\n@@ -92,0 +105,12 @@\n+vertex AAShaderInOut vert_col_aa(AAVertexInput in [[stage_in]],\n+       constant FrameUniforms& uniforms [[buffer(FrameUniformBuffer)]],\n+       constant TransformMatrix& transform [[buffer(MatrixBuffer)]]) {\n+    AAShaderInOut out;\n+    float4 pos4 = float4(in.position, 0.0, 1.0);\n+    out.position = transform.transformMatrix*pos4;\n+    out.color = half4(uniforms.color.r, uniforms.color.g, uniforms.color.b, uniforms.color.a);\n+    out.outerTexCoords = in.oTexCoords;\n+    out.innerTexCoords = in.iTexCoords;\n+    return out;\n+}\n+\n@@ -157,0 +182,42 @@\n+fragment half4 frag_col_aa(AAShaderInOut in [[stage_in]]) {\n+    float2 oleg1 = dfdx(in.outerTexCoords);\n+    float2 oleg2 = dfdy(in.outerTexCoords);\n+    \/\/ Calculate the bounds of the distorted pixel parallelogram.\n+    float2 corner = in.outerTexCoords - (oleg1+oleg2)\/2.0;\n+    float2 omin = min(corner, corner+oleg1);\n+    omin = min(omin, corner+oleg2);\n+    omin = min(omin, corner+oleg1+oleg2);\n+    float2 omax = max(corner, corner+oleg1);\n+    omax = max(omax, corner+oleg2);\n+    omax = max(omax, corner+oleg1+oleg2);\n+    \/\/ Calculate the vectors for the \"legs\" of the pixel parallelogram\n+    \/\/ for the inner parallelogram.\n+    float2 ileg1 = dfdx(in.innerTexCoords);\n+    float2 ileg2 = dfdy(in.innerTexCoords);\n+    \/\/ Calculate the bounds of the distorted pixel parallelogram.\n+    corner = in.innerTexCoords - (ileg1+ileg2)\/2.0;\n+    float2 imin = min(corner, corner+ileg1);\n+    imin = min(imin, corner+ileg2);\n+    imin = min(imin, corner+ileg1+ileg2);\n+    float2 imax = max(corner, corner+ileg1);\n+    imax = max(imax, corner+ileg2);\n+    imax = max(imax, corner+ileg1+ileg2);\n+    \/\/ Clamp the bounds of the parallelograms to the unit square to\n+    \/\/ estimate the intersection of the pixel parallelogram with\n+    \/\/ the unit square.  The ratio of the 2 rectangle areas is a\n+    \/\/ reasonable estimate of the proportion of coverage.\n+    float2 o1 = clamp(omin, 0.0, 1.0);\n+    float2 o2 = clamp(omax, 0.0, 1.0);\n+    float oint = (o2.y-o1.y)*(o2.x-o1.x);\n+    float oarea = (omax.y-omin.y)*(omax.x-omin.x);\n+    float2 i1 = clamp(imin, 0.0, 1.0);\n+    float2 i2 = clamp(imax, 0.0, 1.0);\n+    float iint = (i2.y-i1.y)*(i2.x-i1.x);\n+    float iarea = (imax.y-imin.y)*(imax.x-imin.x);\n+    \/\/ Proportion of pixel in outer shape minus the proportion\n+    \/\/ of pixel in the inner shape == the coverage of the pixel\n+    \/\/ in the area between the two.\n+    float coverage = oint\/oarea - iint \/ iarea;\n+    return (in.color * coverage);\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/shaders.metal","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -342,22 +342,3 @@\n-    if (renderOptions->isAA && !renderOptions->isTexture) {\n-      MTLTexturePoolItem *tiBuf = [_mtlc.texturePool getTexture:dest.width\n-                                                      height:dest.height\n-                                                      format:MTLPixelFormatBGRA8Unorm];\n-      [cbw registerPooledTexture:tiBuf];\n-      _aaDestination = tiBuf.texture;\n-\n-      MTLTexturePoolItem *ti = [_mtlc.texturePool getTexture:dest.width\n-                                                      height:dest.height\n-                                                      format:_aaDestination.pixelFormat\n-                                               isMultiSample:YES];\n-      [cbw registerPooledTexture:ti];\n-      ca.texture = ti.texture;\n-      ca.resolveTexture = _aaDestination;\n-      ca.clearColor = MTLClearColorMake(0.0f, 0.0f, 0.0f, 0.0f);\n-      ca.loadAction = MTLLoadActionClear;\n-      ca.storeAction = MTLStoreActionMultisampleResolve;\n-    } else {\n-      ca.texture = dest;\n-      ca.loadAction = MTLLoadActionLoad;\n-      ca.storeAction = MTLStoreActionStore;\n-    }\n+    ca.texture = dest;\n+    ca.loadAction = MTLLoadActionLoad;\n+    ca.storeAction = MTLStoreActionStore;\n@@ -403,29 +384,1 @@\n-        if (_aaDestination != nil) {\n-          id<MTLTexture> aaDest = _aaDestination;\n-          _aaDestination = nil;\n-          NSUInteger _w = _destination.width;\n-          NSUInteger _h = _destination.height;\n-          _encoder = [self getTextureEncoder:_destination\n-                                 isSrcOpaque:JNI_FALSE\n-                                 isDstOpaque:JNI_TRUE\n-                               interpolation:INTERPOLATION_NEAREST_NEIGHBOR\n-                                        isAA:JNI_TRUE];\n-          [_encoder setFragmentTexture:_mtlc.clip.stencilAADataRef atIndex: 1];\n-\n-          struct TxtVertex quadTxVerticesBuffer[] = {\n-              {{0, 0}, {0, 0}},\n-              {{0,_h}, {0, 1}},\n-              {{_w, 0},{1, 0}},\n-              {{0, _h},{0, 1}},\n-              {{_w, _h}, {1, 1}},\n-              {{_w, 0}, {1, 0}}\n-          };\n-\n-          [_encoder setVertexBytes:quadTxVerticesBuffer length:sizeof(quadTxVerticesBuffer) atIndex:MeshVertexBuffer];\n-          [_encoder setFragmentTexture:aaDest atIndex: 0];\n-          [_encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];\n-          [_encoder endEncoding];\n-        }\n-\n-        _encoder = nil;\n-        _destination = nil;\n+      _destination = nil;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.m","additions":4,"deletions":51,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-                    MTLRenderer_DrawParallelogram(mtlc, dstOps, JNI_FALSE,\n+                    MTLRenderer_DrawParallelogram(mtlc, dstOps,\n@@ -533,1 +533,1 @@\n-                    MTLRenderer_DrawParallelogram(mtlc, dstOps, JNI_TRUE,\n+                    MTLRenderer_DrawAAParallelogram(mtlc, dstOps,\n@@ -591,1 +591,1 @@\n-                    MTLRenderer_FillParallelogram(mtlc, dstOps, JNI_FALSE,\n+                    MTLRenderer_FillParallelogram(mtlc, dstOps,\n@@ -599,1 +599,1 @@\n-                    CHECK_PREVIOUS_OP(MTL_OP_AA);\n+                    CHECK_PREVIOUS_OP(MTL_OP_OTHER);\n@@ -606,1 +606,1 @@\n-                    MTLRenderer_FillParallelogram(mtlc, dstOps, JNI_TRUE,\n+                    MTLRenderer_FillAAParallelogram(mtlc, dstOps,\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.m","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -53,1 +53,6 @@\n-void MTLRenderer_DrawParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps, jboolean isAA,\n+void MTLRenderer_DrawParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                                   jfloat fx11, jfloat fy11,\n+                                   jfloat dx21, jfloat dy21,\n+                                   jfloat dx12, jfloat dy12,\n+                                   jfloat lw21, jfloat lw12);\n+void MTLRenderer_DrawAAParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n@@ -58,1 +63,0 @@\n-\n@@ -63,1 +67,5 @@\n-void MTLRenderer_FillParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps, jboolean isAA,\n+void MTLRenderer_FillParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                                   jfloat fx11, jfloat fy11,\n+                                   jfloat dx21, jfloat dy21,\n+                                   jfloat dx12, jfloat dy12);\n+void MTLRenderer_FillAAParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.h","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-MTLRenderer_FillParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps, jboolean isAA,\n+MTLRenderer_FillParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n@@ -470,2 +470,2 @@\n-    J2dTraceLn8(J2D_TRACE_INFO,\n-                \"MTLRenderer_FillParallelogram (isAA = %d)\"\n+    J2dTraceLn7(J2D_TRACE_INFO,\n+                \"MTLRenderer_FillParallelogram\"\n@@ -475,1 +475,0 @@\n-                isAA,\n@@ -488,6 +487,1 @@\n-    id<MTLRenderCommandEncoder> mtlEncoder = nil;\n-    if (isAA == JNI_TRUE) {\n-        mtlEncoder = [mtlc.encoderManager getAARenderEncoder:dstOps];\n-    } else {\n-        mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n-    }\n+    id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];;\n@@ -505,1 +499,1 @@\n-MTLRenderer_DrawParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps, jboolean isAA,\n+MTLRenderer_DrawParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n@@ -521,1 +515,0 @@\n-    J2dTraceLn1(J2D_TRACE_INFO, \"MTLRenderer_DrawParallelogram (isAA = %d)\", isAA);\n@@ -523,0 +516,1 @@\n+                \"MTLRenderer_DrawParallelogram\"\n@@ -617,6 +611,1 @@\n-        id<MTLRenderCommandEncoder> mtlEncoder = nil;\n-        if (isAA == JNI_TRUE) {\n-            mtlEncoder = [mtlc.encoderManager getAARenderEncoder:dstOps];\n-        } else {\n-            mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n-        }\n+        id<MTLRenderCommandEncoder> mtlEncoder = [mtlc.encoderManager getRenderEncoder:dstOps];\n@@ -640,1 +629,1 @@\n-        MTLRenderer_FillParallelogram(mtlc, dstOps, isAA, ox11, oy11, dx21, dy21, dx12, dy12);\n+        MTLRenderer_FillParallelogram(mtlc, dstOps, ox11, oy11, dx21, dy21, dx12, dy12);\n@@ -644,0 +633,302 @@\n+static struct AAVertex aaVertices[6];\n+static jint vertexCacheIndex = 0;\n+\n+#define AA_ADD_VERTEX(OU, OV, IU, IV, DX, DY) \\\n+    do { \\\n+        struct AAVertex *v = &aaVertices[vertexCacheIndex++]; \\\n+        v->otxtpos[0] = OU; \\\n+        v->otxtpos[1] = OV; \\\n+        v->itxtpos[0] = IU; \\\n+        v->itxtpos[1] = IV; \\\n+        v->position[0]= DX; \\\n+        v->position[1] = DY; \\\n+    } while (0)\n+\n+#define AA_ADD_TRIANGLES(ou11, ov11, iu11, iv11, ou21, ov21, iu21, iv21, ou22, ov22, iu22, iv22, ou12, ov12, iu12, iv12, DX1, DY1, DX2, DY2) \\\n+    do { \\\n+        AA_ADD_VERTEX(ou11, ov11, iu11, iv11, DX1, DY1); \\\n+        AA_ADD_VERTEX(ou21, ov21, iu21, iv21, DX2, DY1); \\\n+        AA_ADD_VERTEX(ou22, ov22, iu22, iv22, DX2, DY2); \\\n+        AA_ADD_VERTEX(ou22, ov22, iu22, iv22, DX2, DY2); \\\n+        AA_ADD_VERTEX(ou12, ov12, iu12, iv12, DX1, DY2); \\\n+        AA_ADD_VERTEX(ou11, ov11, iu11, iv11, DX1, DY1); \\\n+    } while (0)\n+\n+static MTLRenderPipelineDescriptor * templateAAPipelineDesc = nil;\n+\n+static jboolean\n+setupAAShaderState(id<MTLRenderCommandEncoder> encoder,\n+                    MTLContext *mtlc,\n+                    MTLSDOps *dstOps)\n+{\n+    if (templateAAPipelineDesc == nil) {\n+\n+        MTLVertexDescriptor *vertDesc = [[MTLVertexDescriptor new] autorelease];\n+        vertDesc.attributes[VertexAttributePosition].format = MTLVertexFormatFloat2;\n+        vertDesc.attributes[VertexAttributePosition].offset = 0;\n+        vertDesc.attributes[VertexAttributePosition].bufferIndex = MeshVertexBuffer;\n+        vertDesc.layouts[MeshVertexBuffer].stride = sizeof(struct AAVertex);\n+        vertDesc.layouts[MeshVertexBuffer].stepRate = 1;\n+        vertDesc.layouts[MeshVertexBuffer].stepFunction = MTLVertexStepFunctionPerVertex;\n+\n+        templateAAPipelineDesc = [MTLRenderPipelineDescriptor new];\n+        templateAAPipelineDesc.sampleCount = 1;\n+        templateAAPipelineDesc.vertexDescriptor = vertDesc;\n+        templateAAPipelineDesc.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;\n+        templateAAPipelineDesc.colorAttachments[0].rgbBlendOperation =   MTLBlendOperationAdd;\n+        templateAAPipelineDesc.colorAttachments[0].alphaBlendOperation = MTLBlendOperationAdd;\n+        templateAAPipelineDesc.colorAttachments[0].sourceRGBBlendFactor = MTLBlendFactorOne;\n+        templateAAPipelineDesc.colorAttachments[0].sourceAlphaBlendFactor = MTLBlendFactorOne;\n+        templateAAPipelineDesc.colorAttachments[0].destinationRGBBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+        templateAAPipelineDesc.colorAttachments[0].destinationAlphaBlendFactor = MTLBlendFactorOneMinusSourceAlpha;\n+        templateAAPipelineDesc.colorAttachments[0].blendingEnabled = YES;\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].format = MTLVertexFormatFloat2;\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].offset = 2*sizeof(float);\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeTexPos].bufferIndex = MeshVertexBuffer;\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].format = MTLVertexFormatFloat2;\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].offset = 4*sizeof(float);\n+        templateAAPipelineDesc.vertexDescriptor.attributes[VertexAttributeITexPos].bufferIndex = MeshVertexBuffer;\n+        templateAAPipelineDesc.label = @\"template_aa\";\n+    }\n+\n+    id<MTLRenderPipelineState> pipelineState =\n+                [mtlc.pipelineStateStorage\n+                    getPipelineState:templateAAPipelineDesc\n+                    vertexShaderId:@\"vert_col_aa\"\n+                    fragmentShaderId:@\"frag_col_aa\"\n+                   ];\n+\n+    [encoder setRenderPipelineState:pipelineState];\n+    return JNI_TRUE;\n+}\n+\n+#define ADJUST_PGRAM(V1, DV, V2) \\\n+    do { \\\n+        if ((DV) >= 0) { \\\n+            (V2) += (DV); \\\n+        } else { \\\n+            (V1) += (DV); \\\n+        } \\\n+    } while (0)\n+\n+\/\/ Invert the following transform:\n+\/\/ DeltaT(0, 0) == (0,       0)\n+\/\/ DeltaT(1, 0) == (DX1,     DY1)\n+\/\/ DeltaT(0, 1) == (DX2,     DY2)\n+\/\/ DeltaT(1, 1) == (DX1+DX2, DY1+DY2)\n+\/\/ TM00 = DX1,   TM01 = DX2,   (TM02 = X11)\n+\/\/ TM10 = DY1,   TM11 = DY2,   (TM12 = Y11)\n+\/\/ Determinant = TM00*TM11 - TM01*TM10\n+\/\/             =  DX1*DY2  -  DX2*DY1\n+\/\/ Inverse is:\n+\/\/ IM00 =  TM11\/det,   IM01 = -TM01\/det\n+\/\/ IM10 = -TM10\/det,   IM11 =  TM00\/det\n+\/\/ IM02 = (TM01 * TM12 - TM11 * TM02) \/ det,\n+\/\/ IM12 = (TM10 * TM02 - TM00 * TM12) \/ det,\n+\n+#define DECLARE_MATRIX(MAT) \\\n+    jfloat MAT ## 00, MAT ## 01, MAT ## 02, MAT ## 10, MAT ## 11, MAT ## 12\n+\n+#define GET_INVERTED_MATRIX(MAT, X11, Y11, DX1, DY1, DX2, DY2, RET_CODE) \\\n+    do { \\\n+        jfloat det = DX1*DY2 - DX2*DY1; \\\n+        if (det == 0) { \\\n+            RET_CODE; \\\n+        } \\\n+        MAT ## 00 = DY2\/det; \\\n+        MAT ## 01 = -DX2\/det; \\\n+        MAT ## 10 = -DY1\/det; \\\n+        MAT ## 11 = DX1\/det; \\\n+        MAT ## 02 = (DX2 * Y11 - DY2 * X11) \/ det; \\\n+        MAT ## 12 = (DY1 * X11 - DX1 * Y11) \/ det; \\\n+    } while (0)\n+\n+#define TRANSFORM(MAT, TX, TY, X, Y) \\\n+    do { \\\n+        TX = (X) * MAT ## 00 + (Y) * MAT ## 01 + MAT ## 02; \\\n+        TY = (X) * MAT ## 10 + (Y) * MAT ## 11 + MAT ## 12; \\\n+    } while (0)\n+\n+void\n+MTLRenderer_FillAAParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                              jfloat fx11, jfloat fy11,\n+                              jfloat dx21, jfloat dy21,\n+                              jfloat dx12, jfloat dy12)\n+{\n+    DECLARE_MATRIX(om);\n+    \/\/ parameters for parallelogram bounding box\n+    jfloat bx11, by11, bx22, by22;\n+    \/\/ parameters for uv texture coordinates of parallelogram corners\n+    jfloat ou11, ov11, ou12, ov12, ou21, ov21, ou22, ov22;\n+\n+    J2dTraceLn6(J2D_TRACE_INFO,\n+                \"MTLRenderer_FillAAParallelogram \"\n+                \"(x=%6.2f y=%6.2f \"\n+                \"dx1=%6.2f dy1=%6.2f \"\n+                \"dx2=%6.2f dy2=%6.2f)\",\n+                fx11, fy11,\n+                dx21, dy21,\n+                dx12, dy12);\n+\n+    RETURN_IF_NULL(mtlc);\n+    RETURN_IF_NULL(dstOps);\n+\n+    GET_INVERTED_MATRIX(om, fx11, fy11, dx21, dy21, dx12, dy12,\n+                        return);\n+\n+    bx11 = bx22 = fx11;\n+    by11 = by22 = fy11;\n+    ADJUST_PGRAM(bx11, dx21, bx22);\n+    ADJUST_PGRAM(by11, dy21, by22);\n+    ADJUST_PGRAM(bx11, dx12, bx22);\n+    ADJUST_PGRAM(by11, dy12, by22);\n+    bx11 = (jfloat) floor(bx11);\n+    by11 = (jfloat) floor(by11);\n+    bx22 = (jfloat) ceil(bx22);\n+    by22 = (jfloat) ceil(by22);\n+\n+    TRANSFORM(om, ou11, ov11, bx11, by11);\n+    TRANSFORM(om, ou21, ov21, bx22, by11);\n+    TRANSFORM(om, ou12, ov12, bx11, by22);\n+    TRANSFORM(om, ou22, ov22, bx22, by22);\n+\n+    id<MTLRenderCommandEncoder> encoder =\n+        [mtlc.encoderManager getRenderEncoder:dstOps];\n+    setupAAShaderState(encoder, mtlc, dstOps);\n+\n+    AA_ADD_TRIANGLES(ou11, ov11, 5.f, 5.f, ou21, ov21, 6.f, 5.f, ou22, ov22, 6.f, 6.f, ou12, ov12, 5.f, 5.f, bx11, by11, bx22, by22);\n+    [encoder setVertexBytes:aaVertices length:sizeof(aaVertices) atIndex:MeshVertexBuffer];\n+    [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];\n+    vertexCacheIndex = 0;\n+}\n+\n+void\n+MTLRenderer_FillAAParallelogramInnerOuter(MTLContext *mtlc, MTLSDOps *dstOps,\n+                                          jfloat ox11, jfloat oy11,\n+                                          jfloat ox21, jfloat oy21,\n+                                          jfloat ox12, jfloat oy12,\n+                                          jfloat ix11, jfloat iy11,\n+                                          jfloat ix21, jfloat iy21,\n+                                          jfloat ix12, jfloat iy12)\n+{\n+    DECLARE_MATRIX(om);\n+    DECLARE_MATRIX(im);\n+    \/\/ parameters for parallelogram bounding box\n+    jfloat bx11, by11, bx22, by22;\n+    \/\/ parameters for uv texture coordinates of outer parallelogram corners\n+    jfloat ou11, ov11, ou12, ov12, ou21, ov21, ou22, ov22;\n+    \/\/ parameters for uv texture coordinates of inner parallelogram corners\n+    jfloat iu11, iv11, iu12, iv12, iu21, iv21, iu22, iv22;\n+\n+    RETURN_IF_NULL(mtlc);\n+    RETURN_IF_NULL(dstOps);\n+\n+    GET_INVERTED_MATRIX(im, ix11, iy11, ix21, iy21, ix12, iy12,\n+                        \/\/ inner parallelogram is degenerate\n+                        \/\/ therefore it encloses no area\n+                        \/\/ fill outer\n+                        MTLRenderer_FillAAParallelogram(mtlc, dstOps,\n+                                                        ox11, oy11,\n+                                                        ox21, oy21,\n+                                                        ox12, oy12);\n+                        return);\n+    GET_INVERTED_MATRIX(om, ox11, oy11, ox21, oy21, ox12, oy12,\n+                        return);\n+\n+    bx11 = bx22 = ox11;\n+    by11 = by22 = oy11;\n+    ADJUST_PGRAM(bx11, ox21, bx22);\n+    ADJUST_PGRAM(by11, oy21, by22);\n+    ADJUST_PGRAM(bx11, ox12, bx22);\n+    ADJUST_PGRAM(by11, oy12, by22);\n+    bx11 = (jfloat) floor(bx11);\n+    by11 = (jfloat) floor(by11);\n+    bx22 = (jfloat) ceil(bx22);\n+    by22 = (jfloat) ceil(by22);\n+\n+    TRANSFORM(om, ou11, ov11, bx11, by11);\n+    TRANSFORM(om, ou21, ov21, bx22, by11);\n+    TRANSFORM(om, ou12, ov12, bx11, by22);\n+    TRANSFORM(om, ou22, ov22, bx22, by22);\n+\n+    TRANSFORM(im, iu11, iv11, bx11, by11);\n+    TRANSFORM(im, iu21, iv21, bx22, by11);\n+    TRANSFORM(im, iu12, iv12, bx11, by22);\n+    TRANSFORM(im, iu22, iv22, bx22, by22);\n+\n+    id<MTLRenderCommandEncoder> encoder =\n+        [mtlc.encoderManager getRenderEncoder:dstOps];\n+    setupAAShaderState(encoder, mtlc, dstOps);\n+\n+    AA_ADD_TRIANGLES(ou11, ov11, iu11, iv11, ou21, ov21, iu21, iv21, ou22, ov22, iu22, iv22, ou12, ov12, iu12, iv12, bx11, by11, bx22, by22);\n+    [encoder setVertexBytes:aaVertices length:sizeof(aaVertices) atIndex:MeshVertexBuffer];\n+    [encoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];\n+    vertexCacheIndex = 0;\n+}\n+\n+void\n+MTLRenderer_DrawAAParallelogram(MTLContext *mtlc, BMTLSDOps * dstOps,\n+                              jfloat fx11, jfloat fy11,\n+                              jfloat dx21, jfloat dy21,\n+                              jfloat dx12, jfloat dy12,\n+                              jfloat lwr21, jfloat lwr12)\n+{\n+    \/\/ dx,dy for line width in the \"21\" and \"12\" directions.\n+    jfloat ldx21, ldy21, ldx12, ldy12;\n+    \/\/ parameters for \"outer\" parallelogram\n+    jfloat ofx11, ofy11, odx21, ody21, odx12, ody12;\n+    \/\/ parameters for \"inner\" parallelogram\n+    jfloat ifx11, ify11, idx21, idy21, idx12, idy12;\n+\n+    J2dTraceLn8(J2D_TRACE_INFO,\n+                \"MTLRenderer_DrawAAParallelogram \"\n+                \"(x=%6.2f y=%6.2f \"\n+                \"dx1=%6.2f dy1=%6.2f lwr1=%6.2f \"\n+                \"dx2=%6.2f dy2=%6.2f lwr2=%6.2f)\",\n+                fx11, fy11,\n+                dx21, dy21, lwr21,\n+                dx12, dy12, lwr12);\n+\n+    RETURN_IF_NULL(mtlc);\n+    RETURN_IF_NULL(dstOps);\n+\n+    \/\/ calculate true dx,dy for line widths from the \"line width ratios\"\n+    ldx21 = dx21 * lwr21;\n+    ldy21 = dy21 * lwr21;\n+    ldx12 = dx12 * lwr12;\n+    ldy12 = dy12 * lwr12;\n+\n+    \/\/ calculate coordinates of the outer parallelogram\n+    ofx11 = fx11 - (ldx21 + ldx12) \/ 2.0f;\n+    ofy11 = fy11 - (ldy21 + ldy12) \/ 2.0f;\n+    odx21 = dx21 + ldx21;\n+    ody21 = dy21 + ldy21;\n+    odx12 = dx12 + ldx12;\n+    ody12 = dy12 + ldy12;\n+\n+    \/\/ Only process the inner parallelogram if the line width ratio\n+    \/\/ did not consume the entire interior of the parallelogram\n+    \/\/ (i.e. if the width ratio was less than 1.0)\n+    if (lwr21 < 1.0f && lwr12 < 1.0f) {\n+        \/\/ calculate coordinates of the inner parallelogram\n+        ifx11 = fx11 + (ldx21 + ldx12) \/ 2.0f;\n+        ify11 = fy11 + (ldy21 + ldy12) \/ 2.0f;\n+        idx21 = dx21 - ldx21;\n+        idy21 = dy21 - ldy21;\n+        idx12 = dx12 - ldx12;\n+        idy12 = dy12 - ldy12;\n+\n+        MTLRenderer_FillAAParallelogramInnerOuter(mtlc, dstOps,\n+                                                  ofx11, ofy11,\n+                                                  odx21, ody21,\n+                                                  odx12, ody12,\n+                                                  ifx11, ify11,\n+                                                  idx21, idy21,\n+                                                  idx12, idy12);\n+    } else {\n+        MTLRenderer_FillAAParallelogram(mtlc, dstOps,\n+                                        ofx11, ofy11,\n+                                        odx21, ody21,\n+                                        odx12, ody12);\n+    }\n+}\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.m","additions":310,"deletions":19,"binary":false,"changes":329,"status":"modified"}]}