{"files":[{"patch":"@@ -670,0 +670,33 @@\n+\/\/ work item deals with 4 byte pixel\n+\/\/ assuming that data is aligned\n+kernel void bgr_to_rgba(const device uchar *imageBuffer [[buffer(0)]],\n+                        device uchar *outputBuffer [[buffer(1)]],\n+                        uint gid [[thread_position_in_grid]])\n+{\n+    outputBuffer[4 * gid]     = imageBuffer[4 * gid + 2]; \/\/ r\n+    outputBuffer[4 * gid + 1] = imageBuffer[4 * gid + 1]; \/\/ g\n+    outputBuffer[4 * gid + 2] = imageBuffer[4 * gid];     \/\/ b\n+    outputBuffer[4 * gid + 3] = 255;                      \/\/ a\n+}\n+\n+kernel void xrgb_to_rgba(const device uchar *imageBuffer [[buffer(0)]],\n+                         device uchar *outputBuffer [[buffer(1)]],\n+                         uint gid [[thread_position_in_grid]])\n+{\n+    outputBuffer[4 * gid]     = imageBuffer[4 * gid + 1]; \/\/ r\n+    outputBuffer[4 * gid + 1] = imageBuffer[4 * gid + 2]; \/\/ g\n+    outputBuffer[4 * gid + 2] = imageBuffer[4 * gid + 3]; \/\/ b\n+    outputBuffer[4 * gid + 3] = imageBuffer[4 * gid];     \/\/ a\n+}\n+\n+\n+kernel void xbgr_to_rgba(const device uchar *imageBuffer [[buffer(0)]],\n+                         device uchar *outputBuffer [[buffer(1)]],\n+                         uint gid [[thread_position_in_grid]])\n+{\n+    outputBuffer[4 * gid]     = imageBuffer[4 * gid + 3]; \/\/ r\n+    outputBuffer[4 * gid + 1] = imageBuffer[4 * gid + 2]; \/\/ g\n+    outputBuffer[4 * gid + 2] = imageBuffer[4 * gid + 1]; \/\/ b\n+    outputBuffer[4 * gid + 3] = imageBuffer[4 * gid];     \/\/ a\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/shaders.metal","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    MTLPixelFormat   format;\n+    MTLPixelFormat format; \/\/ Consider deleting this field, since it's always MTLPixelFormatBGRA8Unorm\n@@ -55,1 +55,1 @@\n-    const uint8_t * permuteMap;\n+    NSString* swizzleKernel;\n@@ -58,14 +58,0 @@\n-\/\/ 0 denotes the alpha channel, 1 the red channel, 2 the green channel, and 3 the blue channel.\n-const uint8_t permuteMap_rgbx[4] = { 1, 2, 3, 0 };\n-const uint8_t permuteMap_bgrx[4] = { 3, 2, 1, 0 };\n-\n-static uint8_t revertPerm(const uint8_t * perm, uint8_t pos) {\n-    for (int c = 0; c < 4; ++c) {\n-        if (perm[c] == pos)\n-            return c;\n-    }\n-    return -1;\n-}\n-\n-#define uint2swizzle(channel) (channel == 0 ? MTLTextureSwizzleAlpha : (channel == 1 ? MTLTextureSwizzleRed : (channel == 2 ? MTLTextureSwizzleGreen : (channel == 3 ? MTLTextureSwizzleBlue : MTLTextureSwizzleZero))))\n-\n@@ -80,6 +66,6 @@\n-        { MTLPixelFormatBGRA8Unorm, 1, 0, NULL }, \/* 0 - IntArgb      *\/ \/\/ Argb (in java notation)\n-        { MTLPixelFormatBGRA8Unorm, 1, 1, NULL }, \/* 1 - IntArgbPre   *\/\n-        { MTLPixelFormatBGRA8Unorm, 0, 1, NULL }, \/* 2 - IntRgb       *\/ \/\/ xrgb\n-        { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_rgbx }, \/* 3 - IntRgbx      *\/\n-        { MTLPixelFormatRGBA8Unorm, 0, 1, NULL }, \/* 4 - IntBgr       *\/ \/\/ xbgr\n-        { MTLPixelFormatBGRA8Unorm, 0, 1, permuteMap_bgrx }, \/* 5 - IntBgrx      *\/\n+        { MTLPixelFormatBGRA8Unorm, 1, 0, nil }, \/* 0 - IntArgb      *\/ \/\/ Argb (in java notation)\n+        { MTLPixelFormatBGRA8Unorm, 1, 1, nil }, \/* 1 - IntArgbPre   *\/\n+        { MTLPixelFormatBGRA8Unorm, 0, 1, nil }, \/* 2 - IntRgb       *\/\n+        { MTLPixelFormatBGRA8Unorm, 0, 1, @\"xrgb_to_rgba\" }, \/* 3 - IntRgbx      *\/\n+        { MTLPixelFormatBGRA8Unorm, 0, 1, @\"bgr_to_rgba\"  }, \/* 4 - IntBgr       *\/\n+        { MTLPixelFormatBGRA8Unorm, 0, 1, @\"xbgr_to_rgba\" }, \/* 5 - IntBgrx      *\/\n@@ -172,2 +158,4 @@\n-static\n-id<MTLTexture> replaceTextureRegion(MTLContext *mtlc, id<MTLTexture> dest, const SurfaceDataRasInfo * srcInfo, const MTLRasterFormatInfo * rfi, int dx1, int dy1, int dx2, int dy2) {\n+static void\n+replaceTextureRegion(MTLContext *mtlc, id<MTLTexture> dest, const SurfaceDataRasInfo *srcInfo,\n+                     const MTLRasterFormatInfo *rfi,\n+                     int dx1, int dy1, int dx2, int dy2) {\n@@ -177,1 +165,1 @@\n-    const void * raster = srcInfo->rasBase;\n+    const void *raster = srcInfo->rasBase;\n@@ -180,66 +168,0 @@\n-    id<MTLTexture> result = nil;\n-    if (rfi->permuteMap != NULL) {\n-#if defined(__MAC_10_15) && __MAC_OS_X_VERSION_MAX_ALLOWED >= __MAC_10_15\n-        if (@available(macOS 10.15, *)) {\n-            @autoreleasepool {\n-                const uint8_t swzRed = revertPerm(rfi->permuteMap, 1);\n-                const uint8_t swzGreen = revertPerm(rfi->permuteMap, 2);\n-                const uint8_t swzBlue = revertPerm(rfi->permuteMap, 3);\n-                const uint8_t swzAlpha = revertPerm(rfi->permuteMap, 0);\n-                MTLTextureSwizzleChannels swizzle = MTLTextureSwizzleChannelsMake(\n-                        uint2swizzle(swzRed),\n-                        uint2swizzle(swzGreen),\n-                        uint2swizzle(swzBlue),\n-                        rfi->hasAlpha ? uint2swizzle(swzAlpha) : MTLTextureSwizzleOne\n-                );\n-                result = [dest\n-                        newTextureViewWithPixelFormat:MTLPixelFormatBGRA8Unorm\n-                        textureType:MTLTextureType2D\n-                        levels:NSMakeRange(0, 1) slices:NSMakeRange(0, 1)\n-                        swizzle:swizzle];\n-                J2dTraceLn5(J2D_TRACE_VERBOSE, \"replaceTextureRegion [use swizzle for pooled]: %d, %d, %d, %d, hasA=%d\",\n-                            swizzle.red, swizzle.green, swizzle.blue, swizzle.alpha, rfi->hasAlpha);\n-            }\n-        } else\n-#endif \/\/ __MAC_10_15 && __MAC_OS_X_VERSION_MAX_ALLOWED >= __MAC_10_15\n-        {\n-            \/\/ perform raster conversion\n-            \/\/ invoked only from rq-thread, so use static buffers\n-            \/\/ but it's better to use thread-local buffers (or special buffer manager)\n-            const int destRasterSize = dw*dh*4;\n-\n-            static int bufferSize = 0;\n-            static void * buffer = NULL;\n-            if (buffer == NULL || bufferSize < destRasterSize) {\n-                bufferSize = destRasterSize;\n-                buffer = realloc(buffer, bufferSize);\n-            }\n-            if (buffer == NULL) {\n-                J2dTraceLn1(J2D_TRACE_ERROR, \"replaceTextureRegion: can't alloc buffer for raster conversion, size=%d\", bufferSize);\n-                bufferSize = 0;\n-                return nil;\n-            }\n-            vImage_Buffer srcBuf;\n-            srcBuf.height = dh;\n-            srcBuf.width = dw;\n-            srcBuf.rowBytes = srcInfo->scanStride;\n-            srcBuf.data = raster;\n-\n-            vImage_Buffer destBuf;\n-            destBuf.height = dh;\n-            destBuf.width = dw;\n-            destBuf.rowBytes = dw*4;\n-            destBuf.data = buffer;\n-\n-            vImagePermuteChannels_ARGB8888(&srcBuf, &destBuf, rfi->permuteMap, kvImageNoFlags);\n-            raster = buffer;\n-\n-            J2dTraceLn5(J2D_TRACE_VERBOSE, \"replaceTextureRegion [use conversion]: %d, %d, %d, %d, hasA=%d\",\n-                        rfi->permuteMap[0], rfi->permuteMap[1], rfi->permuteMap[2], rfi->permuteMap[3], rfi->hasAlpha);\n-        }\n-    }\n-\n-    MTLRegion region = MTLRegionMake2D(dx1, dy1, dw, dh);\n-    if (result != nil)\n-        dest = result;\n-\n@@ -247,2 +169,0 @@\n-        id <MTLBlitCommandEncoder> blitEncoder = [mtlc.encoderManager createBlitEncoder];\n-\n@@ -251,0 +171,4 @@\n+        \/\/ NOTE: we might want to fill alpha channel when !rfi->hasAlpha\n+        id<MTLBuffer> buff = [mtlc.device newBufferWithBytes:raster length:srcInfo->scanStride * dh options:MTLResourceStorageModeManaged];\n+        if (rfi->swizzleKernel != nil) {\n+            id <MTLBuffer> swizzled = [mtlc.device newBufferWithLength:srcInfo->scanStride * dh options:MTLResourceStorageModeManaged];\n@@ -252,1 +176,24 @@\n-        id <MTLBuffer> buff = [[mtlc.device newBufferWithBytes:raster length:srcInfo->scanStride * dh options:MTLResourceStorageModeManaged] autorelease];\n+            \/\/ this should be cheap, since data is already on GPU\n+            id<MTLCommandBuffer> cb = [mtlc createCommandBuffer];\n+            id<MTLComputeCommandEncoder> computeEncoder = [cb computeCommandEncoder];\n+            id<MTLComputePipelineState> computePipelineState = [mtlc.pipelineStateStorage\n+                                                                getComputePipelineState:rfi->swizzleKernel];\n+            [computeEncoder setComputePipelineState:computePipelineState];\n+\n+            [computeEncoder setBuffer:buff offset:0 atIndex:0];\n+            [computeEncoder setBuffer:swizzled offset:0 atIndex:1];\n+\n+            NSUInteger threadGroupSize = computePipelineState.maxTotalThreadsPerThreadgroup;\n+            NSUInteger pixelCount = buff.length \/ srcInfo->pixelStride;\n+            MTLSize threadsPerGroup = MTLSizeMake(threadGroupSize, 1, 1);\n+            MTLSize threadGroups = MTLSizeMake((pixelCount + threadGroupSize - 1) \/ threadGroupSize,\n+                                               1, 1);\n+            [computeEncoder dispatchThreadgroups:threadGroups\n+                           threadsPerThreadgroup:threadsPerGroup];\n+            [computeEncoder endEncoding];\n+            [cb commit];\n+\n+            buff = swizzled;\n+        }\n+\n+        id<MTLBlitCommandEncoder> blitEncoder = [mtlc.encoderManager createBlitEncoder];\n@@ -254,2 +201,4 @@\n-                sourceOffset:0 sourceBytesPerRow:srcInfo->scanStride sourceBytesPerImage:srcInfo->scanStride * dh sourceSize:MTLSizeMake(dw, dh, 1)\n-                toTexture:dest destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dx1, dy1, 0)];\n+                       sourceOffset:0 sourceBytesPerRow:srcInfo->scanStride\n+                sourceBytesPerImage:srcInfo->scanStride * dh sourceSize:MTLSizeMake(dw, dh, 1)\n+                          toTexture:dest\n+                   destinationSlice:0 destinationLevel:0 destinationOrigin:MTLOriginMake(dx1, dy1, 0)];\n@@ -258,2 +207,0 @@\n-\n-    return result;\n@@ -286,1 +233,2 @@\n-    id<MTLTexture> swizzledTexture = replaceTextureRegion(mtlc, texBuff, srcInfo, rfi, 0, 0, sw, sh);\n+    replaceTextureRegion(mtlc, texBuff, srcInfo, rfi, 0, 0, sw, sh);\n+    \/\/ TODO: useBlitEncoder is always false, remove dead code\n@@ -289,1 +237,1 @@\n-        [blitEncoder copyFromTexture:swizzledTexture != nil ? swizzledTexture : texBuff\n+        [blitEncoder copyFromTexture:texBuff\n@@ -300,1 +248,1 @@\n-        drawTex2Tex(mtlc, swizzledTexture != nil ? swizzledTexture : texBuff, dest, !rfi->hasAlpha, bmtlsdOps->isOpaque, hint,\n+        drawTex2Tex(mtlc, texBuff, dest, !rfi->hasAlpha, bmtlsdOps->isOpaque, hint,\n@@ -303,4 +251,0 @@\n-\n-    if (swizzledTexture != nil) {\n-        [swizzledTexture release];\n-    }\n@@ -740,3 +684,0 @@\n-            MTLRasterFormatInfo rfi = RasterFormatInfos[dsttype];\n-            const jboolean directCopy = rfi.permuteMap == NULL;\n-\n@@ -745,14 +686,12 @@\n-            if (directCopy) {\n-                \/\/ NOTE: theoretically we can use newBufferWithBytesNoCopy, but pDst must be allocated with special API\n-                \/\/ mtlbuf = [mtlc.device\n-                \/\/          newBufferWithBytesNoCopy:pDst\n-                \/\/                            length:(NSUInteger) srcLength\n-                \/\/                           options:MTLResourceCPUCacheModeDefaultCache\n-                \/\/                       deallocator:nil];\n-                \/\/\n-                \/\/ see https:\/\/developer.apple.com\/documentation\/metal\/mtldevice\/1433382-newbufferwithbytesnocopy?language=objc\n-                \/\/\n-                \/\/ The storage allocation of the returned new MTLBuffer object is the same as the pointer input value.\n-                \/\/ The existing memory allocation must be covered by a single VM region, typically allocated with vm_allocate or mmap.\n-                \/\/ Memory allocated by malloc is specifically disallowed.\n-            }\n+            \/\/ NOTE: theoretically we can use newBufferWithBytesNoCopy, but pDst must be allocated with special API\n+            \/\/ mtlbuf = [mtlc.device\n+            \/\/          newBufferWithBytesNoCopy:pDst\n+            \/\/                            length:(NSUInteger) srcLength\n+            \/\/                           options:MTLResourceCPUCacheModeDefaultCache\n+            \/\/                       deallocator:nil];\n+            \/\/\n+            \/\/ see https:\/\/developer.apple.com\/documentation\/metal\/mtldevice\/1433382-newbufferwithbytesnocopy?language=objc\n+            \/\/\n+            \/\/ The storage allocation of the returned new MTLBuffer object is the same as the pointer input value.\n+            \/\/ The existing memory allocation must be covered by a single VM region, typically allocated with vm_allocate or mmap.\n+            \/\/ Memory allocated by malloc is specifically disallowed.\n@@ -798,16 +737,5 @@\n-            if (directCopy) {\n-                if ((dstInfo.scanStride == width * dstInfo.pixelStride) &&\n-                    (height == (dstInfo.bounds.y2 - dstInfo.bounds.y1))) {\n-                    \/\/ mtlbuf.contents have same dimensions as of pDst\n-                    copyFromMTLBuffer(pDst, mtlbuf, 0, byteLength, convertFromPre);\n-                } else {\n-                    \/\/ mtlbuf.contents have smaller dimensions than pDst\n-                    \/\/ copy each row from mtlbuf.contents at appropriate position in pDst\n-                    \/\/ Note : pDst is already addjusted for offsets using PtrAddBytes above\n-\n-                    int rowSize = width * dstInfo.pixelStride;\n-                    for (int y = 0; y < height; y++) {\n-                        copyFromMTLBuffer(pDst, mtlbuf, y * rowSize, rowSize, convertFromPre);\n-                        pDst = PtrAddBytes(pDst, dstInfo.scanStride);\n-                    }\n-                }\n+\n+            if ((dstInfo.scanStride == width * dstInfo.pixelStride) &&\n+                (height == (dstInfo.bounds.y2 - dstInfo.bounds.y1))) {\n+                \/\/ mtlbuf.contents have same dimensions as of pDst\n+                copyFromMTLBuffer(pDst, mtlbuf, 0, byteLength, convertFromPre);\n@@ -815,19 +743,9 @@\n-                J2dTraceLn6(J2D_TRACE_VERBOSE,\"MTLBlitLoops_SurfaceToSwBlit: dsttype=%d, raster conversion will be performed, dest rfi: %d, %d, %d, %d, hasA=%d\",\n-                            dsttype, rfi.permuteMap[0], rfi.permuteMap[1], rfi.permuteMap[2], rfi.permuteMap[3], rfi.hasAlpha);\n-\n-                \/\/ perform raster conversion: mtlIntermediateBuffer(8888) -> pDst(rfi)\n-                \/\/ invoked only from rq-thread, so use static buffers\n-                \/\/ but it's better to use thread-local buffers (or special buffer manager)\n-                vImage_Buffer srcBuf;\n-                srcBuf.height = height;\n-                srcBuf.width = width;\n-                srcBuf.rowBytes = 4*width;\n-                srcBuf.data = mtlbuf.contents;\n-\n-                vImage_Buffer destBuf;\n-                destBuf.height = height;\n-                destBuf.width = width;\n-                destBuf.rowBytes = dstInfo.scanStride;\n-                destBuf.data = pDst;\n-\n-                vImagePermuteChannels_ARGB8888(&srcBuf, &destBuf, rfi.permuteMap, kvImageNoFlags);\n+                \/\/ mtlbuf.contents have smaller dimensions than pDst\n+                \/\/ copy each row from mtlbuf.contents at appropriate position in pDst\n+                \/\/ Note : pDst is already addjusted for offsets using PtrAddBytes above\n+\n+                int rowSize = width * dstInfo.pixelStride;\n+                for (int y = 0; y < height; y++) {\n+                    copyFromMTLBuffer(pDst, mtlbuf, y * rowSize, rowSize, convertFromPre);\n+                    pDst = PtrAddBytes(pDst, dstInfo.scanStride);\n+                }\n@@ -835,0 +753,1 @@\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBlitLoops.m","additions":76,"deletions":157,"binary":false,"changes":233,"status":"modified"}]}