{"files":[{"patch":"@@ -53,0 +53,1 @@\n+    NSLock* _lock;\n@@ -60,0 +61,1 @@\n+        _lock = [[NSLock alloc] init];\n@@ -69,3 +71,9 @@\n-    for (int c = 0; c < [_pooledTextures count]; ++c)\n-        [[_pooledTextures objectAtIndex:c] releaseTexture];\n-    [_pooledTextures removeAllObjects];\n+    [_lock lock];\n+    @try {\n+        for (int c = 0; c < [_pooledTextures count]; ++c)\n+            [[_pooledTextures objectAtIndex:c] releaseTexture];\n+        [_pooledTextures removeAllObjects];\n+    } @finally {\n+        [_lock unlock];\n+    }\n+\n@@ -75,1 +83,6 @@\n-    [_pooledTextures addObject:handle];\n+    [_lock lock];\n+    @try {\n+        [_pooledTextures addObject:handle];\n+    } @finally {\n+        [_lock unlock];\n+    }\n@@ -81,2 +94,3 @@\n-    [self->_pooledTextures release];\n-    [self->_commandBuffer release];\n+    [_pooledTextures release];\n+    [_commandBuffer release];\n+    [_lock release];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.m","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+#include <time.h>\n@@ -5,0 +6,2 @@\n+@class MTLPoolCell;\n+\n@@ -8,1 +11,1 @@\n-@property (readwrite, retain) NSDate * lastUsed;\n+@property (readwrite) NSTimeInterval lastUsed;\n@@ -10,0 +13,3 @@\n+@property (readwrite, assign) MTLTexturePoolItem* prev;\n+@property (readwrite, retain) MTLTexturePoolItem* next;\n+@property (readwrite, assign) MTLPoolCell* cell;\n@@ -11,1 +17,2 @@\n-- (id) initWithTexture:(id<MTLTexture>)tex;\n+- (id) initWithTexture:(id<MTLTexture>)tex cell:(MTLPoolCell*)cell;\n+- (void) releaseTexture;\n@@ -30,0 +37,8 @@\n+@interface MTLPoolCell : NSObject\n+@property (readwrite, retain) MTLTexturePoolItem* available;\n+@property (readwrite, retain) MTLTexturePoolItem* occupied;\n+- (MTLTexturePoolItem*) createItem:(id<MTLTexture>) texture;\n+- (NSUInteger)cleanIfBefore:(time_t)lastUsedTimeToRemove;\n+- (void)releaseItem:(MTLTexturePoolItem *)item;\n+@end\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTexturePool.h","additions":17,"deletions":2,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -13,1 +13,1 @@\n-@synthesize texture, isBusy, lastUsed, isMultiSample;\n+@synthesize texture, isBusy, lastUsed, isMultiSample, next, cell;\n@@ -15,1 +15,1 @@\n-- (id) initWithTexture:(id<MTLTexture>)tex {\n+- (id) initWithTexture:(id<MTLTexture>)tex cell:(MTLPoolCell*)c{\n@@ -20,0 +20,3 @@\n+    self.next = nil;\n+    self.prev = nil;\n+    self.cell = c;\n@@ -24,1 +27,0 @@\n-    [lastUsed release];\n@@ -43,3 +45,3 @@\n-    self->_rect = rectangle;\n-    self->_texture = texture;\n-    self->_poolItem = poolItem;\n+    _rect = rectangle;\n+    _texture = texture;\n+    _poolItem = poolItem;\n@@ -50,1 +52,1 @@\n-    self->_poolItem.isBusy = NO;\n+    [_poolItem.cell releaseItem:_poolItem];\n@@ -52,0 +54,199 @@\n+\n+@end\n+\n+@implementation MTLPoolCell {\n+    NSLock* _lock;\n+}\n+@synthesize available, occupied;\n+\n+- (instancetype)init {\n+    self = [super init];\n+    if (self) {\n+        self.available = nil;\n+        self.occupied = nil;\n+        _lock = [[NSLock alloc] init];\n+    }\n+    return self;\n+}\n+\n+- (void)occupyItem:(MTLTexturePoolItem *)item {\n+    if (item.isBusy) return;\n+    [item retain];\n+    if (item.prev == nil) {\n+        self.available = item.next;\n+        if (item.next) item.next.prev = nil;\n+    } else {\n+        item.prev.next = item.next;\n+        if (item.next) item.next.prev = item.prev;\n+        item.prev = nil;\n+    }\n+    if (occupied) occupied.prev = item;\n+    item.next = occupied;\n+    self.occupied = item;\n+    [item release];\n+    item.isBusy = YES;\n+}\n+\n+- (void)releaseItem:(MTLTexturePoolItem *)item {\n+    [_lock lock];\n+    @try {\n+        if (!item.isBusy) return;\n+        [item retain];\n+        if (item.prev == nil) {\n+            self.occupied = item.next;\n+            if (item.next) item.next.prev = nil;\n+        } else {\n+            item.prev.next = item.next;\n+            if (item.next) item.next.prev = item.prev;\n+            item.prev = nil;\n+        }\n+        if (self.available) self.available.prev = item;\n+        item.next = self.available;\n+        self.available = item;\n+        item.isBusy = NO;\n+        [item release];\n+    } @finally {\n+        [_lock unlock];\n+    }\n+}\n+\n+- (void)addOccupiedItem:(MTLTexturePoolItem *)item {\n+    if (self.occupied) self.occupied.prev = item;\n+    item.next = self.occupied;\n+    item.isBusy = YES;\n+    self.occupied = item;\n+}\n+\n+- (void)removeAvailableItem:(MTLTexturePoolItem*)item {\n+    [item retain];\n+    if (item.prev == nil) {\n+        self.available = item.next;\n+        if (item.next) {\n+            item.next.prev = nil;\n+            item.next = nil;\n+        }\n+    } else {\n+        item.prev.next = item.next;\n+        if (item.next) {\n+            item.next.prev = item.prev;\n+            item.next = nil;\n+        }\n+    }\n+    [item release];\n+}\n+\n+- (void)removeAllItems {\n+    MTLTexturePoolItem *cur = self.available;\n+    while (cur != nil) {\n+        cur = cur.next;\n+        self.available = cur;\n+    }\n+    cur = self.occupied;\n+    while (cur != nil) {\n+        cur = cur.next;\n+        self.occupied = cur;\n+    }\n+}\n+\n+- (MTLTexturePoolItem *)createItem:(id<MTLDevice>)dev\n+                             width:(int)width\n+                            height:(int)height\n+                            format:(MTLPixelFormat)format\n+                     isMultiSample:(bool)isMultiSample\n+{\n+    MTLTextureDescriptor *textureDescriptor =\n+            [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:format\n+                                                               width:(NSUInteger) width\n+                                                              height:(NSUInteger) height\n+                                                           mipmapped:NO];\n+    if (isMultiSample) {\n+        textureDescriptor.textureType = MTLTextureType2DMultisample;\n+        textureDescriptor.sampleCount = MTLAASampleCount;\n+        textureDescriptor.storageMode = MTLStorageModePrivate;\n+    }\n+\n+    id <MTLTexture> tex = (id <MTLTexture>) [[dev newTextureWithDescriptor:textureDescriptor] autorelease];\n+    MTLTexturePoolItem* item = [[[MTLTexturePoolItem alloc] initWithTexture:tex cell:self] autorelease];\n+    item.isMultiSample = isMultiSample;\n+    [_lock lock];\n+    @try {\n+        [self addOccupiedItem:item];\n+    } @finally {\n+        [_lock unlock];\n+    }\n+    return item;\n+}\n+\n+\n+- (NSUInteger)cleanIfBefore:(time_t)lastUsedTimeToRemove {\n+    NSUInteger deallocMem = 0;\n+    [_lock lock];\n+    MTLTexturePoolItem *cur = available;\n+    @try {\n+        while (cur != nil) {\n+            MTLTexturePoolItem *next = cur.next;\n+            if (lastUsedTimeToRemove <= 0 ||\n+                cur.lastUsed < lastUsedTimeToRemove) {\n+#ifdef DEBUG\n+                J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE,\n+                             \"MTLTexturePool: remove pool item: tex=%p, w=%d h=%d, elapsed=%d\",\n+                             cur.texture, cur.texture.width, cur.texture.height,\n+                             time(NULL) - cur.lastUsed);\n+#endif \/\/DEBUG\n+                deallocMem += cur.texture.width * cur.texture.height * 4;\n+                [self removeAvailableItem:cur];\n+            }\n+            cur = next;\n+        }\n+    } @finally {\n+        [_lock unlock];\n+    }\n+    return deallocMem;\n+}\n+\n+- (MTLTexturePoolItem *)occupyItem:(int)width height:(int)height format:(MTLPixelFormat)format\n+                     isMultiSample:(bool)isMultiSample {\n+    int minDeltaArea = -1;\n+    const int requestedPixels = width*height;\n+    MTLTexturePoolItem *minDeltaTpi = nil;\n+    [_lock lock];\n+    @try {\n+        for (MTLTexturePoolItem *cur = available; cur != nil; cur = cur.next) {\n+            if (cur.texture.pixelFormat != format\n+                || cur.isMultiSample != isMultiSample) { \/\/ TODO: use swizzle when formats are not equal\n+                continue;\n+            }\n+            if (cur.texture.width < width || cur.texture.height < height) {\n+                continue;\n+            }\n+            const int deltaArea = cur.texture.width * cur.texture.height - requestedPixels;\n+            if (minDeltaArea < 0 || deltaArea < minDeltaArea) {\n+                minDeltaArea = deltaArea;\n+                minDeltaTpi = cur;\n+                if (deltaArea == 0) {\n+                    \/\/ found exact match in current cell\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (minDeltaTpi) {\n+            [self occupyItem:minDeltaTpi];\n+        }\n+    } @finally {\n+        [_lock unlock];\n+    }\n+    return minDeltaTpi;\n+}\n+\n+- (void) dealloc {\n+    [_lock lock];\n+    @try {\n+        [self removeAllItems];\n+    } @finally {\n+        [_lock unlock];\n+    }\n+    [_lock release];\n+    [super dealloc];\n+}\n+\n@@ -80,1 +281,1 @@\n-        NSMutableArray * cell = _cells[c];\n+        MTLPoolCell * cell = _cells[c];\n@@ -136,0 +337,1 @@\n+        int minDeltaArea = -1;\n@@ -138,16 +340,5 @@\n-                NSMutableArray * cell = _cells[cy * _poolCellWidth + cx];\n-                if (cell == NULL)\n-                    continue;\n-\n-                const int count = [cell count];\n-                int minDeltaArea = -1;\n-                int minDeltaAreaIndex = -1;\n-                for (int c = 0; c < count; ++c) {\n-                    MTLTexturePoolItem *tpi = [cell objectAtIndex:c];\n-                    if (tpi == nil || tpi.isBusy || tpi.texture.pixelFormat != format\n-                        || tpi.isMultiSample != isMultiSample) { \/\/ TODO: use swizzle when formats are not equal\n-                        continue;\n-                    }\n-                    if (tpi.texture.width < width || tpi.texture.height < height) {\n-                        continue;\n-                    }\n+                MTLPoolCell * cell = _cells[cy * _poolCellWidth + cx];\n+                if (cell != NULL) {\n+                    MTLTexturePoolItem* tpi = [cell occupyItem:width height:height\n+                                                        format:format isMultiSample:isMultiSample];\n+                    if (!tpi) continue;\n@@ -156,1 +347,0 @@\n-                        minDeltaAreaIndex = c;\n@@ -165,3 +355,0 @@\n-                if (minDeltaTpi != nil) {\n-                    break;\n-                }\n@@ -175,15 +362,1 @@\n-            MTLTextureDescriptor *textureDescriptor =\n-                    [MTLTextureDescriptor texture2DDescriptorWithPixelFormat:format\n-                                                                       width:(NSUInteger) width\n-                                                                      height:(NSUInteger) height\n-                                                                   mipmapped:NO];\n-            if (isMultiSample) {\n-                textureDescriptor.textureType = MTLTextureType2DMultisample;\n-                textureDescriptor.sampleCount = MTLAASampleCount;\n-                textureDescriptor.storageMode = MTLStorageModePrivate;\n-            }\n-\n-            id <MTLTexture> tex = [[self.device newTextureWithDescriptor:textureDescriptor] autorelease];\n-            minDeltaTpi = [[[MTLTexturePoolItem alloc] initWithTexture:tex] autorelease];\n-            minDeltaTpi.isMultiSample = isMultiSample;\n-            NSMutableArray * cell = _cells[cellY0 * _poolCellWidth + cellX0];\n+            MTLPoolCell* cell = _cells[cellY0 * _poolCellWidth + cellX0];\n@@ -191,1 +364,1 @@\n-                cell = [[NSMutableArray arrayWithCapacity:10] retain];\n+                cell = [[MTLPoolCell alloc] init];\n@@ -194,1 +367,1 @@\n-            [cell addObject:minDeltaTpi];\n+            minDeltaTpi = [cell createItem:device width:width height:height format:format isMultiSample:isMultiSample];\n@@ -196,1 +369,1 @@\n-            J2dTraceLn5(J2D_TRACE_VERBOSE, \"MTLTexturePool: created pool item: tex=%p, w=%d h=%d, pf=%d | total memory = %d Kb\", tex, width, height, format, _memoryTotalAllocated\/1024);\n+            J2dTraceLn5(J2D_TRACE_VERBOSE, \"MTLTexturePool: created pool item: tex=%p, w=%d h=%d, pf=%d | total memory = %d Kb\", minDeltaTpi.texture, width, height, format, _memoryTotalAllocated\/1024);\n@@ -200,1 +373,1 @@\n-        minDeltaTpi.lastUsed = [NSDate date];\n+        minDeltaTpi.lastUsed = time(NULL);\n@@ -209,0 +382,4 @@\n+    NSTimeInterval lastUsedTimeToRemove =\n+            lastUsedTimeThreshold > 0 ?\n+                time(NULL) - lastUsedTimeThreshold :\n+                lastUsedTimeThreshold;\n@@ -211,20 +388,3 @@\n-            NSMutableArray * cell = _cells[cy * _poolCellWidth + cx];\n-            if (cell == NULL)\n-                continue;\n-\n-            for (int c = 0; c < [cell count];) {\n-                MTLTexturePoolItem *tpi = [cell objectAtIndex:c];\n-                if (!tpi.isBusy) {\n-                    if (\n-                        lastUsedTimeThreshold <= 0\n-                        || (int)(-[tpi.lastUsed timeIntervalSinceNow]) > lastUsedTimeThreshold\n-                    ) {\n-#ifdef DEBUG\n-                        J2dTraceImpl(J2D_TRACE_VERBOSE, JNI_TRUE, \"MTLTexturePool: remove pool item: tex=%p, w=%d h=%d, elapsed=%d\", tpi.texture, tpi.texture.width, tpi.texture.height, (int)(-[tpi.lastUsed timeIntervalSinceNow]));\n-#endif \/\/DEBUG\n-                        _memoryTotalAllocated -= tpi.texture.width * tpi.texture.height * 4;\n-                        [cell removeObjectAtIndex:c];\n-                        continue;\n-                    }\n-                }\n-                ++c;\n+            MTLPoolCell * cell = _cells[cy * _poolCellWidth + cx];\n+            if (cell != NULL) {\n+                _memoryTotalAllocated -= [cell cleanIfBefore:lastUsedTimeToRemove];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTexurePool.m","additions":227,"deletions":67,"binary":false,"changes":294,"status":"modified"}]}