{"files":[{"patch":"@@ -241,0 +241,1 @@\n+  printf \"* Name:           $CONF_NAME\\n\"\n","filename":"make\/autoconf\/help.m4","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) {\n+static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) {\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1786,1 +1786,1 @@\n-      subs(zr, rscratch1, vmIntrinsics::_compiledLambdaForm);\n+      subs(zr, rscratch1, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -427,1 +427,1 @@\n-      fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+      fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1201,1 +1201,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -438,1 +438,1 @@\n-      fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+      fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -704,1 +704,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1922,1 +1922,1 @@\n-      cmpwi(CCR1, tmp2, vmIntrinsics::_compiledLambdaForm);\n+      cmpwi(CCR1, tmp2, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -461,1 +461,1 @@\n-      fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+      fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1624,1 +1624,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1809,1 +1809,1 @@\n-        z_cli(Method::intrinsic_id_offset_in_bytes(), tmp, vmIntrinsics::_compiledLambdaForm);\n+        z_cli(Method::intrinsic_id_offset_in_bytes(), tmp, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n@@ -1813,1 +1813,1 @@\n-        z_chi(tmp, vmIntrinsics::_compiledLambdaForm);\n+        z_chi(tmp, static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-      fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+      fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -923,1 +923,1 @@\n-              \"special_dispatch=%d\", special_dispatch);\n+              \"special_dispatch=%d\", vmIntrinsics::as_int(special_dispatch));\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) {\n+static void z_load_barrier(MacroAssembler& _masm, const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) {\n","filename":"src\/hotspot\/cpu\/x86\/gc\/z\/z_x86_64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -193,1 +193,1 @@\n-      cmpw(Address(tmp, Method::intrinsic_id_offset_in_bytes()), vmIntrinsics::_compiledLambdaForm);\n+      cmpw(Address(tmp, Method::intrinsic_id_offset_in_bytes()), static_cast<int>(vmIntrinsics::_compiledLambdaForm));\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -481,1 +481,1 @@\n-      fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+      fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1291,1 +1291,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1649,1 +1649,1 @@\n-    fatal(\"unexpected intrinsic id %d\", iid);\n+    fatal(\"unexpected intrinsic id %d\", vmIntrinsics::as_int(iid));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4136,1 +4136,1 @@\n-    fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -1105,1 +1105,1 @@\n-      tty->print_cr(\"Eliminated Intrinsic %d's null check for value %d\", x->id(), recv->id());\n+      tty->print_cr(\"Eliminated Intrinsic %d's null check for value %d\", vmIntrinsics::as_int(x->id()), recv->id());\n@@ -1111,1 +1111,1 @@\n-      tty->print_cr(\"Intrinsic %d of value %d proves value to be non-null\", x->id(), recv->id());\n+      tty->print_cr(\"Intrinsic %d of value %d proves value to be non-null\", vmIntrinsics::as_int(x->id()), recv->id());\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classFileError.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5290,1 +5290,2 @@\n-      for (int id = vmIntrinsics::FIRST_ID; id < (int)vmIntrinsics::ID_LIMIT; ++id) {\n+      for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+        vmIntrinsicID id = *it;\n@@ -5298,1 +5299,1 @@\n-        if (vmIntrinsics::class_for(vmIntrinsics::ID_from(id)) == klass_id) {\n+        if (vmIntrinsics::class_for(id) == klass_id) {\n@@ -5314,2 +5315,1 @@\n-                        vmIntrinsics::short_name_as_C_string(vmIntrinsics::ID_from(id),\n-                                                             buf, sizeof(buf)),\n+                        vmIntrinsics::short_name_as_C_string(id, buf, sizeof(buf)),\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/stackMapFrame.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2521,1 +2521,1 @@\n-Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsics::ID iid,\n+Method* SystemDictionary::find_method_handle_intrinsic(vmIntrinsicID iid,\n@@ -2525,0 +2525,1 @@\n+  const int iid_as_int = vmIntrinsics::as_int(iid);\n@@ -2528,1 +2529,1 @@\n-         \"must be a known MH intrinsic iid=%d: %s\", iid, vmIntrinsics::name_at(iid));\n+         \"must be a known MH intrinsic iid=%d: %s\", iid_as_int, vmIntrinsics::name_at(iid));\n@@ -2530,1 +2531,1 @@\n-  unsigned int hash  = invoke_method_table()->compute_hash(signature, iid);\n+  unsigned int hash  = invoke_method_table()->compute_hash(signature, iid_as_int);\n@@ -2532,1 +2533,1 @@\n-  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, iid);\n+  SymbolPropertyEntry* spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n@@ -2551,1 +2552,1 @@\n-      spe = invoke_method_table()->find_entry(index, hash, signature, iid);\n+      spe = invoke_method_table()->find_entry(index, hash, signature, iid_as_int);\n@@ -2553,1 +2554,1 @@\n-        spe = invoke_method_table()->add_entry(index, hash, signature, iid);\n+        spe = invoke_method_table()->add_entry(index, hash, signature, iid_as_int);\n@@ -2704,1 +2705,1 @@\n-  vmIntrinsics::ID null_iid = vmIntrinsics::_none;  \/\/ distinct from all method handle invoker intrinsics\n+  int null_iid = vmIntrinsics::as_int(vmIntrinsics::_none);  \/\/ distinct from all method handle invoker intrinsics\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/vmEnums.hpp\"\n@@ -466,1 +467,1 @@\n-  static Method* find_method_handle_intrinsic(vmIntrinsics::ID iid,\n+  static Method* find_method_handle_intrinsic(vmIntrinsicID iid,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/verificationType.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -569,2 +569,2 @@\n-static const char* vm_intrinsic_name_table[vmIntrinsics::ID_LIMIT];\n-static TriBoolArray<vmIntrinsics::ID_LIMIT, int> vm_intrinsic_control_words;\n+static const char* vm_intrinsic_name_table[vmIntrinsics::number_of_intrinsics()];\n+static TriBoolArray<(size_t)vmIntrinsics::number_of_intrinsics(), int> vm_intrinsic_control_words;\n@@ -572,1 +572,1 @@\n-static void init_vm_intrinsic_name_table() {\n+void vmIntrinsics::init_vm_intrinsic_name_table() {\n@@ -575,2 +575,4 @@\n-  for (int index = vmIntrinsics::FIRST_ID; index < vmIntrinsics::ID_LIMIT; index++) {\n-    nt[index] = string;\n+\n+  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+    vmIntrinsicID index = *it;\n+    nt[as_int(index)] = string;\n@@ -580,2 +582,2 @@\n-  assert(!strcmp(nt[vmIntrinsics::_hashCode], \"_hashCode\"), \"lined up\");\n-  nt[vmIntrinsics::_none] = \"_none\";\n+  assert(!strcmp(nt[as_int(vmIntrinsics::_hashCode)], \"_hashCode\"), \"lined up\");\n+  nt[as_int(vmIntrinsics::_none)] = \"_none\";\n@@ -586,1 +588,1 @@\n-  if (nt[_none] == NULL) {\n+  if (nt[as_int(_none)] == NULL) {\n@@ -590,2 +592,2 @@\n-  if ((uint)id < (uint)ID_LIMIT)\n-    return vm_intrinsic_name_table[(uint)id];\n+  if (id < ID_LIMIT)\n+    return vm_intrinsic_name_table[as_int(id)];\n@@ -598,1 +600,1 @@\n-  if (nt[_none] == NULL) {\n+  if (nt[as_int(_none)] == NULL) {\n@@ -602,3 +604,4 @@\n-  for (int index = FIRST_ID; index < ID_LIMIT; ++index) {\n-    if (0 == strcmp(name, nt[index])) {\n-      return ID_from(index);\n+  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+    vmIntrinsicID index = *it;\n+    if (0 == strcmp(name, nt[as_int(index)])) {\n+      return index;\n@@ -620,1 +623,1 @@\n-  if (vm_intrinsic_control_words[_none].is_default()) {\n+  if (vm_intrinsic_control_words[as_int(_none)].is_default()) {\n@@ -625,1 +628,1 @@\n-        vm_intrinsic_control_words[id] = iter.is_enabled() && !disabled_by_jvm_flags(id);\n+        vm_intrinsic_control_words[as_int(id)] = iter.is_enabled() && !disabled_by_jvm_flags(id);\n@@ -634,1 +637,1 @@\n-        vm_intrinsic_control_words[id] = false;\n+        vm_intrinsic_control_words[as_int(id)] = false;\n@@ -638,1 +641,1 @@\n-    vm_intrinsic_control_words[_none] = true;\n+    vm_intrinsic_control_words[as_int(_none)] = true;\n@@ -641,1 +644,1 @@\n-  TriBool b = vm_intrinsic_control_words[id];\n+  TriBool b = vm_intrinsic_control_words[as_int(id)];\n@@ -644,1 +647,1 @@\n-    b = vm_intrinsic_control_words[id] = !disabled_by_jvm_flags(id);\n+    b = vm_intrinsic_control_words[as_int(id)] = !disabled_by_jvm_flags(id);\n@@ -709,1 +712,1 @@\n-static const jlong intrinsic_info_array[vmIntrinsics::ID_LIMIT+1] = {\n+static const jlong intrinsic_info_array[vmIntrinsics::number_of_intrinsics()+1] = {\n@@ -715,1 +718,1 @@\n-    0\n+  0\n@@ -720,1 +723,1 @@\n-  return intrinsic_info_array[vmIntrinsics::ID_from((int)id)];\n+  return intrinsic_info_array[vmIntrinsics::as_int(id)];\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/enumIterator.hpp\"\n@@ -1017,0 +1018,7 @@\n+#define VM_INTRINSIC_ID_ENUM(id, klass, name, sig, flags)  id,\n+#define VM_INTRINSICS_CONST(id, klass, name, sig, flags)   static const vmIntrinsicID id = vmIntrinsicID::id;\n+#define __IGNORE_CLASS(id, name)                      \/*ignored*\/\n+#define __IGNORE_NAME(id, name)                       \/*ignored*\/\n+#define __IGNORE_SIGNATURE(id, name)                  \/*ignored*\/\n+#define __IGNORE_ALIAS(id, name)                      \/*ignored*\/\n+\n@@ -1018,0 +1026,20 @@\n+enum class vmIntrinsicID : int {\n+  _none = 0,                      \/\/ not an intrinsic (default answer)\n+\n+  VM_INTRINSICS_DO(VM_INTRINSIC_ID_ENUM,\n+                   __IGNORE_CLASS, __IGNORE_NAME, __IGNORE_SIGNATURE, __IGNORE_ALIAS)\n+\n+  ID_LIMIT,\n+  LAST_COMPILER_INLINE = _VectorScatterOp,\n+  FIRST_MH_SIG_POLY    = _invokeGeneric,\n+  FIRST_MH_STATIC      = _linkToVirtual,\n+  LAST_MH_SIG_POLY     = _linkToNative,\n+\n+  FIRST_ID = _none + 1,\n+  LAST_ID = ID_LIMIT - 1,\n+};\n+\n+ENUMERATOR_RANGE(vmIntrinsicID, vmIntrinsicID::FIRST_ID, vmIntrinsicID::LAST_ID)\n+constexpr EnumRange<vmIntrinsicID> vmIntrinsicsRange; \/\/ the default range of all valid vmIntrinsicIDs\n+using vmIntrinsicsIterator = EnumIterator<vmIntrinsicID>; \/\/ convenience\n+\n@@ -1023,9 +1051,1 @@\n-  \/\/ Accessing\n-  enum ID {\n-    _none = 0,                      \/\/ not an intrinsic (default answer)\n-\n-    #define VM_INTRINSIC_ENUM(id, klass, name, sig, flags)  id,\n-    #define __IGNORE_CLASS(id, name)                      \/*ignored*\/\n-    #define __IGNORE_NAME(id, name)                       \/*ignored*\/\n-    #define __IGNORE_SIGNATURE(id, name)                  \/*ignored*\/\n-    #define __IGNORE_ALIAS(id, name)                      \/*ignored*\/\n+  typedef vmIntrinsicID ID;\n@@ -1033,7 +1053,8 @@\n-    VM_INTRINSICS_DO(VM_INTRINSIC_ENUM,\n-                     __IGNORE_CLASS, __IGNORE_NAME, __IGNORE_SIGNATURE, __IGNORE_ALIAS)\n-    #undef VM_INTRINSIC_ENUM\n-    #undef __IGNORE_CLASS\n-    #undef __IGNORE_NAME\n-    #undef __IGNORE_SIGNATURE\n-    #undef __IGNORE_ALIAS\n+  \/\/ Convenient access of vmIntrinsicID::FOO as vmIntrinsics::FOO\n+  static const ID _none                = vmIntrinsicID::_none;\n+  static const ID ID_LIMIT             = vmIntrinsicID::ID_LIMIT;\n+  static const ID LAST_COMPILER_INLINE = vmIntrinsicID::LAST_COMPILER_INLINE;\n+  static const ID FIRST_MH_SIG_POLY    = vmIntrinsicID::FIRST_MH_SIG_POLY;\n+  static const ID FIRST_MH_STATIC      = vmIntrinsicID::FIRST_MH_STATIC;\n+  static const ID LAST_MH_SIG_POLY     = vmIntrinsicID::LAST_MH_SIG_POLY;\n+  static const ID FIRST_ID             = vmIntrinsicID::FIRST_ID;\n@@ -1041,8 +1062,2 @@\n-    ID_LIMIT,\n-    LAST_COMPILER_INLINE = _VectorScatterOp,\n-    FIRST_MH_SIG_POLY    = _invokeGeneric,\n-    FIRST_MH_STATIC      = _linkToVirtual,\n-    LAST_MH_SIG_POLY     = _linkToNative,\n-\n-    FIRST_ID = _none + 1\n-  };\n+  VM_INTRINSICS_DO(VM_INTRINSICS_CONST,\n+                   __IGNORE_CLASS, __IGNORE_NAME, __IGNORE_SIGNATURE, __IGNORE_ALIAS)\n@@ -1065,0 +1080,14 @@\n+\n+  \/\/ Convert an arbitrary vmIntrinsicID to int (checks validity):\n+  \/\/    vmIntrinsicID x = ...; int n = vmIntrinsics::as_int(x);\n+  \/\/ Convert a known vmIntrinsicID to int (no need for validity check):\n+  \/\/    int n = static_cast<int>(vmIntrinsicID::_invokeGeneric);\n+  static constexpr int as_int(vmIntrinsicID id) {\n+    assert(is_valid_id(id), \"must be\");\n+    return static_cast<int>(id);\n+  }\n+\n+  static constexpr int number_of_intrinsics() {\n+    return static_cast<int>(ID_LIMIT);\n+  }\n+\n@@ -1066,4 +1095,11 @@\n-  static ID ID_from(int raw_id) {\n-    assert(raw_id >= (int)_none && raw_id < (int)ID_LIMIT,\n-           \"must be a valid intrinsic ID\");\n-    return (ID)raw_id;\n+  static constexpr bool is_valid_id(int raw_id) {\n+    return (raw_id >= static_cast<int>(_none) && raw_id < static_cast<int>(ID_LIMIT));\n+  }\n+\n+  static constexpr bool is_valid_id(ID id) {\n+    return is_valid_id(static_cast<int>(id));\n+  }\n+\n+  static constexpr ID ID_from(int raw_id) {\n+    assert(is_valid_id(raw_id), \"must be a valid intrinsic ID\");\n+    return static_cast<ID>(raw_id);\n@@ -1082,0 +1118,1 @@\n+  static void init_vm_intrinsic_name_table();\n@@ -1147,0 +1184,7 @@\n+#undef VM_INTRINSIC_ENUM\n+#undef VM_INTRINSICS_CONST\n+#undef __IGNORE_CLASS\n+#undef __IGNORE_NAME\n+#undef __IGNORE_SIGNATURE\n+#undef __IGNORE_ALIAS\n+\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":72,"deletions":28,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+\n@@ -125,2 +126,0 @@\n-  } else if (scaled_freq > nth_bit(max_freq_bits)) {\n-    return max_freq_bits;\n@@ -128,1 +127,6 @@\n-    return log2_intptr(scaled_freq);\n+    intx res = log2_intptr(scaled_freq);\n+    if (res > max_freq_bits) {\n+      return max_freq_bits;\n+    } else {\n+      return res;\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-      _intrinsic_control_words[id] = iter.is_enabled();\n+      _intrinsic_control_words[vmIntrinsics::as_int(id)] = iter.is_enabled();\n@@ -253,1 +253,1 @@\n-      _intrinsic_control_words[id] = false;\n+      _intrinsic_control_words[vmIntrinsics::as_int(id)] = false;\n@@ -362,1 +362,1 @@\n-#define init_default_cc(name, type, dvalue, cc_flag) { type v; if (!_modified[name##Index] && CompilerOracle::has_option_value(method, CompileCommand::cc_flag, v) && v != this->name##Option) { set.cloned()->name##Option = v; } }\n+#define init_default_cc(name, type, dvalue, cc_flag) { type v; if (!_modified[name##Index] && CompileCommand::cc_flag != CompileCommand::Unknown && CompilerOracle::has_option_value(method, CompileCommand::cc_flag, v) && v != this->name##Option) { set.cloned()->name##Option = v; } }\n@@ -383,1 +383,1 @@\n-          set.cloned()->_intrinsic_control_words[id] = iter.is_enabled();\n+          set.cloned()->_intrinsic_control_words[vmIntrinsics::as_int(id)] = iter.is_enabled();\n@@ -403,1 +403,1 @@\n-          set.cloned()->_intrinsic_control_words[id] = false;\n+          set.cloned()->_intrinsic_control_words[vmIntrinsics::as_int(id)] = false;\n@@ -502,1 +502,1 @@\n-  TriBool b = _intrinsic_control_words[id];\n+  TriBool b = _intrinsic_control_words[vmIntrinsics::as_int(id)];\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  TriBoolArray<vmIntrinsics::ID_LIMIT, int> _intrinsic_control_words;\n+  TriBoolArray<(size_t)vmIntrinsics::number_of_intrinsics(), int> _intrinsic_control_words;\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-  OptionType    _type;\n@@ -120,2 +119,1 @@\n-    _option(CompileCommand::Unknown),\n-    _type(OptionType::Unknown) {\n+    _option(CompileCommand::Unknown) {\n@@ -127,1 +125,1 @@\n-  TypedMethodOptionMatcher* match(const methodHandle &method, enum CompileCommand option, OptionType type);\n+  TypedMethodOptionMatcher* match(const methodHandle &method, enum CompileCommand option);\n@@ -129,1 +127,1 @@\n-  void init(enum CompileCommand option, OptionType type, TypedMethodOptionMatcher* next) {\n+  void init(enum CompileCommand option, TypedMethodOptionMatcher* next) {\n@@ -131,1 +129,0 @@\n-    _type = type;\n@@ -143,1 +140,0 @@\n-  OptionType type() { return _type; }\n@@ -197,2 +193,3 @@\n-  switch (_type) {\n-  case OptionType::Intx:\n+  enum OptionType type = option2type(_option);\n+  switch (type) {\n+    case OptionType::Intx:\n@@ -211,0 +208,1 @@\n+    case OptionType::Ccstrlist:\n@@ -247,1 +245,2 @@\n-  if (type() == OptionType::Ccstr) {\n+  enum OptionType type = option2type(_option);\n+  if (type == OptionType::Ccstr || type == OptionType::Ccstrlist) {\n@@ -266,1 +265,1 @@\n-TypedMethodOptionMatcher* TypedMethodOptionMatcher::match(const methodHandle& method, enum CompileCommand option, OptionType type) {\n+TypedMethodOptionMatcher* TypedMethodOptionMatcher::match(const methodHandle& method, enum CompileCommand option) {\n@@ -288,6 +287,3 @@\n-  enum OptionType type = option2type(option);\n-  if (type == OptionType::Ccstrlist) {\n-    type = OptionType::Ccstr; \/\/ ccstrlists are stores as ccstr\n-  }\n-  assert(type == get_type_for<T>(), \"sanity\");\n-  matcher->init(option, type, option_list);\n+  assert(CompilerOracle::option_matches_type(option, value), \"Value must match option type\");\n+\n+  matcher->init(option, option_list);\n@@ -311,18 +307,2 @@\n-bool CompilerOracle::has_option_value(const methodHandle& method, enum CompileCommand option, T& value, bool verify_type) {\n-  enum OptionType type = option2type(option);\n-  if (type == OptionType::Unknown) {\n-    return false; \/\/ Can't query options with type Unknown.\n-  }\n-  if (type == OptionType::Ccstrlist) {\n-    type = OptionType::Ccstr; \/\/ CCstrList type options are stored as Ccstr\n-  }\n-  if (verify_type) {\n-    if (type != get_type_for<T>()) {\n-      \/\/ Whitebox API expects false if option and type doesn't match\n-      return false;\n-    }\n-  } else {\n-    assert(type == get_type_for<T>(), \"Value type (%s) must match option %s (%s)\",\n-            optiontype2name(get_type_for<T>()),\n-           option2name(option), optiontype2name(option2type(option)));\n-  }\n+bool CompilerOracle::has_option_value(const methodHandle& method, enum CompileCommand option, T& value) {\n+  assert(option_matches_type(option, value), \"Value must match option type\");\n@@ -330,1 +310,1 @@\n-    TypedMethodOptionMatcher* m = option_list->match(method, option, type);\n+    TypedMethodOptionMatcher* m = option_list->match(method, option);\n@@ -364,5 +344,23 @@\n-template bool CompilerOracle::has_option_value<intx>(const methodHandle& method, enum CompileCommand option, intx& value, bool verify_type);\n-template bool CompilerOracle::has_option_value<uintx>(const methodHandle& method, enum CompileCommand option, uintx& value, bool verify_type);\n-template bool CompilerOracle::has_option_value<bool>(const methodHandle& method, enum CompileCommand option, bool& value, bool verify_type);\n-template bool CompilerOracle::has_option_value<ccstr>(const methodHandle& method, enum CompileCommand option, ccstr& value, bool verify_type);\n-template bool CompilerOracle::has_option_value<double>(const methodHandle& method, enum CompileCommand option, double& value, bool verify_type);\n+template bool CompilerOracle::has_option_value<intx>(const methodHandle& method, enum CompileCommand option, intx& value);\n+template bool CompilerOracle::has_option_value<uintx>(const methodHandle& method, enum CompileCommand option, uintx& value);\n+template bool CompilerOracle::has_option_value<bool>(const methodHandle& method, enum CompileCommand option, bool& value);\n+template bool CompilerOracle::has_option_value<ccstr>(const methodHandle& method, enum CompileCommand option, ccstr& value);\n+template bool CompilerOracle::has_option_value<double>(const methodHandle& method, enum CompileCommand option, double& value);\n+\n+template<typename T>\n+bool CompilerOracle::option_matches_type(enum CompileCommand option, T& value) {\n+  enum OptionType option_type = option2type(option);\n+  if (option_type == OptionType::Unknown) {\n+    return false; \/\/ Can't query options with type Unknown.\n+  }\n+  if (option_type == OptionType::Ccstrlist) {\n+    option_type = OptionType::Ccstr; \/\/ CCstrList type options are stored as Ccstr\n+  }\n+  return (get_type_for<T>() == option_type);\n+}\n+\n+template bool CompilerOracle::option_matches_type<intx>(enum CompileCommand option, intx& value);\n+template bool CompilerOracle::option_matches_type<uintx>(enum CompileCommand option, uintx& value);\n+template bool CompilerOracle::option_matches_type<bool>(enum CompileCommand option, bool& value);\n+template bool CompilerOracle::option_matches_type<ccstr>(enum CompileCommand option, ccstr& value);\n+template bool CompilerOracle::option_matches_type<double>(enum CompileCommand option, double& value);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":39,"deletions":41,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -152,1 +152,5 @@\n-  static bool has_option_value(const methodHandle& method, enum CompileCommand option, T& value, bool verfiy_type = false);\n+  static bool has_option_value(const methodHandle& method, enum CompileCommand option, T& value);\n+\n+  \/\/ This check is currently only needed by whitebox API\n+  template<typename T>\n+  static bool option_matches_type(enum CompileCommand option, T& value);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-ZLoadBarrierStubC2* ZLoadBarrierStubC2::create(const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) {\n+ZLoadBarrierStubC2* ZLoadBarrierStubC2::create(const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) {\n@@ -95,1 +95,1 @@\n-ZLoadBarrierStubC2::ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data) :\n+ZLoadBarrierStubC2::ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data) :\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  const int       _barrier_data;\n+  const uint8_t   _barrier_data;\n@@ -48,1 +48,1 @@\n-  ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data);\n+  ZLoadBarrierStubC2(const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data);\n@@ -51,1 +51,1 @@\n-  static ZLoadBarrierStubC2* create(const MachNode* node, Address ref_addr, Register ref, Register tmp, int barrier_data);\n+  static ZLoadBarrierStubC2* create(const MachNode* node, Address ref_addr, Register ref, Register tmp, uint8_t barrier_data);\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,2 +117,3 @@\n-    MethodKind kind = (MethodKind)( method_handle_invoke_FIRST +\n-                                    ((int)id - vmIntrinsics::FIRST_MH_SIG_POLY) );\n+    MethodKind kind = (MethodKind)(method_handle_invoke_FIRST +\n+                                   vmIntrinsics::as_int(id) -\n+                                   static_cast<int>(vmIntrinsics::FIRST_MH_SIG_POLY));\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -68,2 +69,2 @@\n-                                                                   + (vmIntrinsics::LAST_MH_SIG_POLY\n-                                                                      - vmIntrinsics::FIRST_MH_SIG_POLY)),\n+                                                                   + (static_cast<int>(vmIntrinsics::LAST_MH_SIG_POLY)\n+                                                                      - static_cast<int>(vmIntrinsics::FIRST_MH_SIG_POLY))),\n@@ -98,1 +99,1 @@\n-      return (vmIntrinsics::ID)( vmIntrinsics::FIRST_MH_SIG_POLY + (kind - method_handle_invoke_FIRST) );\n+      return vmIntrinsics::ID_from(static_cast<int>(vmIntrinsics::FIRST_MH_SIG_POLY) + (kind - method_handle_invoke_FIRST));\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1373,2 +1373,0 @@\n-      const int add_len = 32;                                                  \\\n-      STATIC_ASSERT(add_len == strlen(\"Index  out of bounds for length \"));    \\\n@@ -1376,1 +1374,1 @@\n-      char message[2 * jintAsStringSize + add_len + 1];                        \\\n+      char message[2 * jintAsStringSize + 33];                                 \\\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleDescription.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -164,1 +164,2 @@\n-  JVMCIObjectArray vmIntrinsics = JVMCIENV->new_VMIntrinsicMethod_array(vmIntrinsics::ID_LIMIT - 1, JVMCI_CHECK_NULL);\n+  int len = vmIntrinsics::number_of_intrinsics() - 1; \/\/ Exclude vmIntrinsics::_none, which is 0\n+  JVMCIObjectArray vmIntrinsics = JVMCIENV->new_VMIntrinsicMethod_array(len, JVMCI_CHECK_NULL);\n@@ -182,0 +183,1 @@\n+  \/\/ VM_INTRINSICS_DO does *not* iterate over vmIntrinsics::_none\n@@ -185,1 +187,0 @@\n-  assert(index == vmIntrinsics::ID_LIMIT - 1, \"must be\");\n@@ -187,0 +188,1 @@\n+  assert(index == len, \"must be\");\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/altHashing.hpp\"\n@@ -33,1 +34,1 @@\n-#include \"classfile\/altHashing.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1638,1 +1638,1 @@\n-  assert(_intrinsic_id == vmIntrinsics::_none, \"do this just once\");\n+  assert(_intrinsic_id == static_cast<int>(vmIntrinsics::_none), \"do this just once\");\n@@ -2365,1 +2365,1 @@\n-    st->print_cr(\" - intrinsic id:      %d %s\", intrinsic_id(), vmIntrinsics::name_at(intrinsic_id()));\n+    st->print_cr(\" - intrinsic id:      %d %s\", vmIntrinsics::as_int(intrinsic_id()), vmIntrinsics::name_at(intrinsic_id()));\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/vmSymbols.hpp\"\n@@ -772,1 +771,1 @@\n-  static methodHandle make_method_handle_intrinsic(vmIntrinsics::ID iid, \/\/ _invokeBasic, _linkToVirtual\n+  static methodHandle make_method_handle_intrinsic(vmIntrinsicID iid, \/\/ _invokeBasic, _linkToVirtual\n@@ -869,2 +868,2 @@\n-  vmIntrinsics::ID intrinsic_id() const          { return (vmIntrinsics::ID) _intrinsic_id;           }\n-  void     set_intrinsic_id(vmIntrinsics::ID id) {                           _intrinsic_id = (u2) id; }\n+  vmIntrinsicID intrinsic_id() const          { return (vmIntrinsicID) _intrinsic_id;           }\n+  void     set_intrinsic_id(vmIntrinsicID id) {                           _intrinsic_id = (u2) id; }\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -112,2 +112,2 @@\n-  const Type *t1 = phase->type( in(1) );\n-  const Type *t2 = phase->type( in(2) );\n+  const Type *t1 = phase->type(in(1));\n+  const Type *t2 = phase->type(in(2));\n@@ -118,1 +118,1 @@\n-  if( commute(this,con_left,con_right) ) return this;\n+  if (commute(this, con_left, con_right)) return this;\n@@ -129,2 +129,2 @@\n-  if( con_right && t2 != Type::TOP && \/\/ Right input is a constant?\n-      add1_op == this_op ) { \/\/ Left input is an Add?\n+  if (con_right && t2 != Type::TOP && \/\/ Right input is a constant?\n+      add1_op == this_op) { \/\/ Left input is an Add?\n@@ -133,2 +133,2 @@\n-    const Type *t12 = phase->type( add1->in(2) );\n-    if( t12->singleton() && t12 != Type::TOP ) { \/\/ Left input is an add of a constant?\n+    const Type *t12 = phase->type(add1->in(2));\n+    if (t12->singleton() && t12 != Type::TOP) { \/\/ Left input is an add of a constant?\n@@ -140,2 +140,2 @@\n-      if( (add1 == add1->in(1))\n-         || (add11_op == this_op && add11->in(1) == add1) ) {\n+      if ((add1 == add1->in(1))\n+          || (add11_op == this_op && add11->in(1) == add1)) {\n@@ -147,1 +147,1 @@\n-      Node *x2 = phase->makecon( add1->as_Add()->add_ring( t2, t12 ));\n+      Node *x2 = phase->makecon(add1->as_Add()->add_ring(t2, t12));\n@@ -149,1 +149,1 @@\n-      if( igvn ) {\n+      if (igvn) {\n@@ -163,1 +163,1 @@\n-  if( add1_op == this_op && !con_right ) {\n+  if (add1_op == this_op && !con_right) {\n@@ -166,2 +166,2 @@\n-    if( t12->singleton() && t12 != Type::TOP && (add1 != add1->in(1)) &&\n-       !(add1->in(1)->is_Phi() && add1->in(1)->as_Phi()->is_tripcount()) ) {\n+    if (t12->singleton() && t12 != Type::TOP && (add1 != add1->in(1)) &&\n+        !(add1->in(1)->is_Phi() && (add1->in(1)->as_Phi()->is_tripcount(T_INT) || add1->in(1)->as_Phi()->is_tripcount(T_LONG)))) {\n@@ -181,1 +181,1 @@\n-  if( add2_op == this_op && !con_left ) {\n+  if (add2_op == this_op && !con_left) {\n@@ -184,2 +184,2 @@\n-    if( t22->singleton() && t22 != Type::TOP && (add2 != add2->in(1)) &&\n-       !(add2->in(1)->is_Phi() && add2->in(1)->as_Phi()->is_tripcount()) ) {\n+    if (t22->singleton() && t22 != Type::TOP && (add2 != add2->in(1)) &&\n+        !(add2->in(1)->is_Phi() && (add2->in(1)->as_Phi()->is_tripcount(T_INT) || add2->in(1)->as_Phi()->is_tripcount(T_LONG)))) {\n@@ -238,0 +238,11 @@\n+AddNode* AddNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new AddINode(in1, in2);\n+    case T_LONG:\n+      return new AddLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n@@ -910,0 +921,8 @@\n+  Node* hook = NULL;\n+  if (gvn.is_IterGVN()) {\n+    \/\/ Make sure a and b are not destroyed\n+    hook = new Node(2);\n+    hook->init_req(0, a);\n+    hook->init_req(1, b);\n+  }\n+  Node* res = NULL;\n@@ -913,1 +932,1 @@\n-        Node* res =  gvn.transform(new MaxINode(a, b));\n+        res =  gvn.transform(new MaxINode(a, b));\n@@ -915,1 +934,0 @@\n-        return res;\n@@ -919,1 +937,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -925,1 +943,0 @@\n-        return res;\n@@ -929,1 +946,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -937,1 +954,1 @@\n-        return gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n+        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n@@ -941,1 +958,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -947,1 +964,1 @@\n-        return gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n+        res = gvn.transform(new CMoveINode(bol, a, b, t->is_int()));\n@@ -951,1 +968,1 @@\n-        return gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n+        res = gvn.transform(new CMoveLNode(bol, a, b, t->is_long()));\n@@ -955,0 +972,4 @@\n+  if (hook != NULL) {\n+    hook->destruct(&gvn);\n+  }\n+  return res;\n@@ -967,0 +988,8 @@\n+  Node* hook = NULL;\n+  if (gvn.is_IterGVN()) {\n+    \/\/ Make sure a and b are not destroyed\n+    hook = new Node(2);\n+    hook->init_req(0, a);\n+    hook->init_req(1, b);\n+  }\n+  Node* res = NULL;\n@@ -972,1 +1001,1 @@\n-      return gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n+      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n@@ -977,1 +1006,1 @@\n-      return gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n+      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n@@ -984,1 +1013,1 @@\n-      return gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n+      res = gvn.transform(new CMoveINode(bol, sub, zero, t->is_int()));\n@@ -989,1 +1018,1 @@\n-      return gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n+      res = gvn.transform(new CMoveLNode(bol, sub, zero, t->is_long()));\n@@ -992,0 +1021,4 @@\n+  if (hook != NULL) {\n+    hook->destruct(&gvn);\n+  }\n+  return res;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":63,"deletions":30,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -71,0 +71,5 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+  static AddNode* make(Node* in1, Node* in2, BasicType bt);\n@@ -84,0 +89,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -98,0 +107,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1034,1 +1034,1 @@\n-    fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n@@ -90,0 +94,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n@@ -102,0 +110,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1087,1 +1087,1 @@\n-  CountedLoopNode* l = r->is_CountedLoop() ? r->as_CountedLoop() : NULL;\n+  BaseCountedLoopNode* l = r->is_BaseCountedLoop() ? r->as_BaseCountedLoop() : NULL;\n@@ -1091,2 +1091,2 @@\n-      const Node *init   = l->init_trip();\n-      const Node *limit  = l->limit();\n+      const Node* init = l->init_trip();\n+      const Node* limit = l->limit();\n@@ -1095,3 +1095,3 @@\n-        const TypeInt* lo = phase->type(init)->isa_int();\n-        const TypeInt* hi = phase->type(limit)->isa_int();\n-        const TypeInt* stride_t = phase->type(stride)->isa_int();\n+        const TypeInteger* lo = phase->type(init)->isa_integer(l->bt());\n+        const TypeInteger* hi = phase->type(limit)->isa_integer(l->bt());\n+        const TypeInteger* stride_t = phase->type(stride)->isa_integer(l->bt());\n@@ -1099,1 +1099,1 @@\n-          assert(stride_t->_hi >= stride_t->_lo, \"bad stride type\");\n+          assert(stride_t->hi_as_long() >= stride_t->lo_as_long(), \"bad stride type\");\n@@ -1106,1 +1106,1 @@\n-            if (stride_t->_hi < 0) {          \/\/ Down-counter loop\n+            if (stride_t->hi_as_long() < 0) {          \/\/ Down-counter loop\n@@ -1108,3 +1108,5 @@\n-              return TypeInt::make(MIN2(lo->_lo, hi->_lo) , hi->_hi, 3)->filter_speculative(_type);\n-            } else if (stride_t->_lo >= 0) {\n-              return TypeInt::make(lo->_lo, MAX2(lo->_hi, hi->_hi), 3)->filter_speculative(_type);\n+              return TypeInteger::make(MIN2(lo->lo_as_long(), hi->lo_as_long()), hi->hi_as_long(), 3,\n+                                       l->bt())->filter_speculative(_type);\n+            } else if (stride_t->lo_as_long() >= 0) {\n+              return TypeInteger::make(lo->lo_as_long(), MAX2(lo->hi_as_long(), hi->hi_as_long()), 3,\n+                                       l->bt())->filter_speculative(_type);\n@@ -2449,3 +2451,4 @@\n-bool PhiNode::is_tripcount() const {\n-  return (in(0) != NULL && in(0)->is_CountedLoop() &&\n-          in(0)->as_CountedLoop()->phi() == this);\n+bool PhiNode::is_tripcount(BasicType bt) const {\n+  return (in(0) != NULL && in(0)->is_BaseCountedLoop() &&\n+          in(0)->as_BaseCountedLoop()->operates_on(bt, true) &&\n+          in(0)->as_BaseCountedLoop()->phi() == this);\n@@ -2478,1 +2481,1 @@\n-  if (is_tripcount()) {\n+  if (is_tripcount(T_INT) || is_tripcount(T_LONG)) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":18,"deletions":15,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  bool is_tripcount() const;\n+  bool is_tripcount(BasicType bt) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+macro(LongCountedLoop)\n+macro(LongCountedLoopEnd)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -172,2 +172,6 @@\n-juint  Compile::_intrinsic_hist_count[vmIntrinsics::ID_LIMIT] = {0};\n-jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::ID_LIMIT] = {0};\n+juint  Compile::_intrinsic_hist_count[vmIntrinsics::number_of_intrinsics()] = {0};\n+jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::number_of_intrinsics()] = {0};\n+\n+inline int as_int(vmIntrinsics::ID id) {\n+  return vmIntrinsics::as_int(id);\n+}\n@@ -177,1 +181,1 @@\n-  int oflags = _intrinsic_hist_flags[id];\n+  int oflags = _intrinsic_hist_flags[as_int(id)];\n@@ -184,1 +188,1 @@\n-    juint count = (_intrinsic_hist_count[id] += 1);\n+    juint count = (_intrinsic_hist_count[as_int(id)] += 1);\n@@ -189,1 +193,1 @@\n-    _intrinsic_hist_count[vmIntrinsics::_none] += 1;\n+    _intrinsic_hist_count[as_int(vmIntrinsics::_none)] += 1;\n@@ -205,1 +209,1 @@\n-    _intrinsic_hist_flags[id] = (jubyte) (oflags | flags);\n+    _intrinsic_hist_flags[as_int(id)] = (jubyte) (oflags | flags);\n@@ -208,1 +212,1 @@\n-  _intrinsic_hist_flags[vmIntrinsics::_none] |= (jubyte) flags;\n+  _intrinsic_hist_flags[as_int(vmIntrinsics::_none)] |= (jubyte) flags;\n@@ -229,1 +233,1 @@\n-  juint total = _intrinsic_hist_count[vmIntrinsics::_none];\n+  juint total = _intrinsic_hist_count[as_int(vmIntrinsics::_none)];\n@@ -233,4 +237,4 @@\n-  for (int index = 1 + (int)vmIntrinsics::_none; index < (int)vmIntrinsics::ID_LIMIT; index++) {\n-    vmIntrinsics::ID id = (vmIntrinsics::ID) index;\n-    int   flags = _intrinsic_hist_flags[id];\n-    juint count = _intrinsic_hist_count[id];\n+  for (vmIntrinsicsIterator it = vmIntrinsicsRange.begin(); it != vmIntrinsicsRange.end(); ++it) {\n+    vmIntrinsicID id = *it;\n+    int   flags = _intrinsic_hist_flags[as_int(id)];\n+    juint count = _intrinsic_hist_count[as_int(id)];\n@@ -241,1 +245,1 @@\n-  PRINT_STAT_LINE(\"total\", total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));\n+  PRINT_STAT_LINE(\"total\", total, format_flags(_intrinsic_hist_flags[as_int(vmIntrinsics::_none)], flagsbuf));\n@@ -256,1 +260,1 @@\n-  if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {\n+  if (_intrinsic_hist_flags[as_int(vmIntrinsics::_none)] != 0) {\n@@ -3394,0 +3398,1 @@\n+  case Op_LongCountedLoop:\n@@ -3712,1 +3717,1 @@\n-    if (n->is_OuterStripMinedLoopEnd()) {\n+    if (n->is_OuterStripMinedLoopEnd() || n->is_LongCountedLoopEnd()) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1086,2 +1086,2 @@\n-  static juint  _intrinsic_hist_count[vmIntrinsics::ID_LIMIT];\n-  static jubyte _intrinsic_hist_flags[vmIntrinsics::ID_LIMIT];\n+  static juint  _intrinsic_hist_count[];\n+  static jubyte _intrinsic_hist_flags[];\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,0 +463,1 @@\n+  const TypeInt* ti = TypeInt::INT;\n@@ -464,2 +465,4 @@\n-  \/\/ Easy case.\n-  return TypeInt::make((jint)tl->get_con());\n+    \/\/ Easy case.\n+    ti = TypeInt::make((jint)tl->get_con());\n+  } else if (tl->_lo >= min_jint && tl->_hi <= max_jint) {\n+    ti = TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen);\n@@ -467,4 +470,1 @@\n-  if (tl->_lo >= min_jint && tl->_hi <= max_jint) {\n-    return TypeInt::make((jint)tl->_lo, (jint)tl->_hi, tl->_widen);\n-  }\n-  return bottom_type();\n+  return ti->filter(_type);\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-class ConvL2INode : public Node {\n+class ConvL2INode : public TypeNode {\n@@ -183,1 +183,4 @@\n-  ConvL2INode( Node *in1 ) : Node(0,in1) {}\n+  ConvL2INode(Node *in1, const TypeInt* t = TypeInt::INT)\n+  : TypeNode(t, 2) {\n+    init_req(1, in1);\n+  }\n@@ -185,1 +188,0 @@\n-  virtual const Type *bottom_type() const { return TypeInt::INT; }\n","filename":"src\/hotspot\/share\/opto\/convertnode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1731,1 +1731,1 @@\n-  if (iff->is_CountedLoopEnd())  return NULL;\n+  if (iff->is_BaseCountedLoopEnd())  return NULL;\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -676,1 +676,1 @@\n-                    vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());\n+                    vmIntrinsics::name_at(intrinsic_id()), vmIntrinsics::as_int(intrinsic_id()));\n@@ -712,1 +712,1 @@\n-                    vmIntrinsics::name_at(intrinsic_id()), intrinsic_id());\n+                    vmIntrinsics::name_at(intrinsic_id()), vmIntrinsics::as_int(intrinsic_id()));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-    fatal(\"unexpected intrinsic %d: %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic %d: %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1280,1 +1280,1 @@\n-  if (head->is_valid_counted_loop()) {\n+  if (head->is_valid_counted_loop(T_INT)) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  if (!_head->as_Loop()->is_valid_counted_loop()) {\n+  if (!_head->as_Loop()->is_valid_counted_loop(T_INT)) {\n@@ -487,0 +487,1 @@\n+             test->Opcode() == Op_LongCountedLoopEnd ||\n@@ -771,1 +772,1 @@\n-  if (!cl->is_valid_counted_loop()) {\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n@@ -850,1 +851,1 @@\n-  if (!cl->is_valid_counted_loop()) {\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n@@ -3134,1 +3135,1 @@\n-  if (!cl->is_valid_counted_loop()) {\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n@@ -3247,1 +3248,1 @@\n-  if (!_head->as_Loop()->is_valid_counted_loop()) {\n+  if (!_head->as_Loop()->is_valid_counted_loop(T_INT)) {\n@@ -3263,1 +3264,0 @@\n-#ifdef ASSERT\n@@ -3265,2 +3265,2 @@\n-  assert(init_n->get_int() + cl->stride_con() >= cl->limit()->get_int(), \"should be one iteration\");\n-#endif\n+  assert((cl->stride_con() > 0 && init_n->get_int() + cl->stride_con() >= cl->limit()->get_int()) ||\n+         (cl->stride_con() < 0 && init_n->get_int() + cl->stride_con() <= cl->limit()->get_int()), \"should be one iteration\");\n@@ -3309,1 +3309,1 @@\n-  if (!cl->is_valid_counted_loop()) return true; \/\/ Ignore various kinds of broken loops\n+  if (!cl->is_valid_counted_loop(T_INT)) return true; \/\/ Ignore various kinds of broken loops\n@@ -3724,1 +3724,1 @@\n-  if (!head->is_valid_counted_loop() || !head->is_normal_loop()) {\n+  if (!head->is_valid_counted_loop(T_INT) || !head->is_normal_loop()) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-  if (!cl->is_valid_counted_loop()) {\n+  if (!cl->is_valid_counted_loop(T_INT)) {\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"opto\/castnode.hpp\"\n@@ -72,4 +73,4 @@\n-bool LoopNode::is_valid_counted_loop() const {\n-  if (is_CountedLoop()) {\n-    CountedLoopNode*    l  = as_CountedLoop();\n-    CountedLoopEndNode* le = l->loopexit_or_null();\n+bool LoopNode::is_valid_counted_loop(BasicType bt) const {\n+  if (is_BaseCountedLoop() && operates_on(bt, false)) {\n+    BaseCountedLoopNode*    l  = as_BaseCountedLoop();\n+    BaseCountedLoopEndNode* le = l->loopexit_or_null();\n@@ -245,1 +246,1 @@\n-void PhaseIdealLoop::set_early_ctrl( Node *n ) {\n+void PhaseIdealLoop::set_early_ctrl(Node* n, bool update_body) {\n@@ -250,0 +251,4 @@\n+  IdealLoopTree *loop = get_loop(early);\n+  if (update_body && loop->_child == NULL) {\n+    loop->_body.push(n);\n+  }\n@@ -254,1 +259,1 @@\n-void PhaseIdealLoop::set_subtree_ctrl( Node *n ) {\n+void PhaseIdealLoop::set_subtree_ctrl(Node* n, bool update_body) {\n@@ -256,1 +261,1 @@\n-  if( _nodes[n->_idx] ) return;\n+  if (_nodes[n->_idx]) return;\n@@ -259,1 +264,1 @@\n-  for( i = 0; i < n->req(); ++i ) {\n+  for (i = 0; i < n->req(); ++i) {\n@@ -261,2 +266,3 @@\n-    if( m && m != C->root() )\n-      set_subtree_ctrl( m );\n+    if (m && m != C->root()) {\n+      set_subtree_ctrl(m, update_body);\n+    }\n@@ -266,1 +272,1 @@\n-  set_early_ctrl( n );\n+  set_early_ctrl(n, update_body);\n@@ -348,1 +354,1 @@\n-  set_subtree_ctrl(bol);\n+  set_subtree_ctrl(bol, false);\n@@ -487,21 +493,1 @@\n-\/\/ Return 0 if it won't overflow, -1 if it must overflow, and 1 otherwise.\n-static int check_stride_overflow(jint stride_con, const TypeInt* limit_t) {\n-  if (stride_con > 0) {\n-    if (limit_t->_lo > (max_jint - stride_con)) {\n-      return -1;\n-    }\n-    if (limit_t->_hi > (max_jint - stride_con)) {\n-      return 1;\n-    }\n-  } else {\n-    if (limit_t->_hi < (min_jint - stride_con)) {\n-      return -1;\n-    }\n-    if (limit_t->_lo < (min_jint - stride_con)) {\n-      return 1;\n-    }\n-  }\n-  return 0;\n-}\n-\n-static int check_stride_overflow(jlong stride_con, const TypeLong* limit_t) {\n+static int check_stride_overflow(jlong stride_con, const TypeInteger* limit_t, BasicType bt) {\n@@ -509,1 +495,1 @@\n-    if (limit_t->_lo > (max_jlong - stride_con)) {\n+    if (limit_t->lo_as_long() > (max_signed_integer(bt) - stride_con)) {\n@@ -512,1 +498,1 @@\n-    if (limit_t->_hi > (max_jlong - stride_con)) {\n+    if (limit_t->hi_as_long() > (max_signed_integer(bt) - stride_con)) {\n@@ -516,1 +502,1 @@\n-    if (limit_t->_hi < (min_jlong - stride_con)) {\n+    if (limit_t->hi_as_long() < (min_signed_integer(bt) - stride_con)) {\n@@ -519,1 +505,1 @@\n-    if (limit_t->_lo < (min_jlong - stride_con)) {\n+    if (limit_t->lo_as_long() < (min_signed_integer(bt) - stride_con)) {\n@@ -571,1 +557,1 @@\n-    set_subtree_ctrl(bol);\n+    set_subtree_ctrl(bol, false);\n@@ -612,1 +598,1 @@\n-      set_subtree_ctrl(unc->in(i));\n+      set_subtree_ctrl(unc->in(i), false);\n@@ -630,0 +616,48 @@\n+static bool no_side_effect_since_safepoint(Compile* C, Node* x, Node* mem, MergeMemNode* mm) {\n+  SafePointNode* safepoint = NULL;\n+  for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n+    Node* u = x->fast_out(i);\n+    if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n+      Node* m = u->in(LoopNode::LoopBackControl);\n+      if (u->adr_type() == TypePtr::BOTTOM) {\n+        if (m->is_MergeMem() && mem->is_MergeMem()) {\n+          if (m != mem DEBUG_ONLY(|| true)) {\n+            for (MergeMemStream mms(m->as_MergeMem(), mem->as_MergeMem()); mms.next_non_empty2(); ) {\n+              if (!mms.is_empty()) {\n+                if (mms.memory() != mms.memory2()) {\n+                  return false;\n+                }\n+#ifdef ASSERT\n+                if (mms.alias_idx() != Compile::AliasIdxBot) {\n+                  mm->set_memory_at(mms.alias_idx(), mem->as_MergeMem()->base_memory());\n+                }\n+#endif\n+              }\n+            }\n+          }\n+        } else if (mem->is_MergeMem()) {\n+          if (m != mem->as_MergeMem()->base_memory()) {\n+            return false;\n+          }\n+        } else {\n+          return false;\n+        }\n+      } else {\n+        if (mem->is_MergeMem()) {\n+          if (m != mem->as_MergeMem()->memory_at(C->get_alias_index(u->adr_type()))) {\n+            return false;\n+          }\n+#ifdef ASSERT\n+          mm->set_memory_at(C->get_alias_index(u->adr_type()), mem->as_MergeMem()->base_memory());\n+#endif\n+        } else {\n+          if (m != mem) {\n+            return false;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -654,1 +688,0 @@\n-#ifdef ASSERT\n@@ -657,0 +690,1 @@\n+#ifdef ASSERT\n@@ -667,42 +701,4 @@\n-    for (DUIterator_Fast imax, i = x->fast_outs(imax); i < imax; i++) {\n-      Node* u = x->fast_out(i);\n-      if (u->is_Phi() && u->bottom_type() == Type::MEMORY) {\n-        Node* m = u->in(LoopNode::LoopBackControl);\n-        if (u->adr_type() == TypePtr::BOTTOM) {\n-          if (m->is_MergeMem() && mem->is_MergeMem()) {\n-            if (m != mem DEBUG_ONLY(|| true)) {\n-              for (MergeMemStream mms(m->as_MergeMem(), mem->as_MergeMem()); mms.next_non_empty2(); ) {\n-                if (!mms.is_empty()) {\n-                  if (mms.memory() != mms.memory2()) {\n-                    return NULL;\n-                  }\n-#ifdef ASSERT\n-                  if (mms.alias_idx() != Compile::AliasIdxBot) {\n-                    mm->set_memory_at(mms.alias_idx(), mem->as_MergeMem()->base_memory());\n-                  }\n-#endif\n-                }\n-              }\n-            }\n-          } else if (mem->is_MergeMem()) {\n-            if (m != mem->as_MergeMem()->base_memory()) {\n-              return NULL;\n-            }\n-          } else {\n-            return NULL;\n-          }\n-        } else {\n-          if (mem->is_MergeMem()) {\n-            if (m != mem->as_MergeMem()->memory_at(C->get_alias_index(u->adr_type()))) {\n-              return NULL;\n-            }\n-#ifdef ASSERT\n-            mm->set_memory_at(C->get_alias_index(u->adr_type()), mem->as_MergeMem()->base_memory());\n-#endif\n-          } else {\n-            if (m != mem) {\n-              return NULL;\n-            }\n-          }\n-        }\n-      }\n+    if (!no_side_effect_since_safepoint(C, x, mem, mm)) {\n+      safepoint = NULL;\n+    } else {\n+      assert(mm == NULL|| _igvn.transform(mm) == mem->as_MergeMem()->base_memory(), \"all memory state should have been processed\");\n@@ -712,1 +708,0 @@\n-      assert (_igvn.transform(mm) == mem->as_MergeMem()->base_memory(), \"all memory state should have been processed\");\n@@ -730,1 +725,0 @@\n-\/\/   \/\/ phi_incr := phi (test happens before increment)\n@@ -740,1 +734,0 @@\n-\/\/   \/\/ phi_incr := NULL (test happens after increment)\n@@ -770,1 +763,2 @@\n-bool PhaseIdealLoop::is_long_counted_loop(Node* x, IdealLoopTree* loop, Node_List &old_new) {\n+bool PhaseIdealLoop::transform_long_counted_loop(IdealLoopTree* loop, Node_List &old_new) {\n+  Node* x = loop->_head;\n@@ -772,1 +766,1 @@\n-  if (loop->_child != NULL) {\n+  if (loop->_child != NULL || !x->is_LongCountedLoop()) {\n@@ -776,5 +770,1 @@\n-  \/\/ Checks whether the loop has the shape of a counted loop\n-  Node* back_control = loop_exit_control(x, loop);\n-  if (back_control == NULL) {\n-    return false;\n-  }\n+  check_long_counted_loop(loop, x);\n@@ -782,22 +772,1 @@\n-  BoolTest::mask bt = BoolTest::illegal;\n-  float cl_prob = 0;\n-  Node* incr = NULL;\n-  Node* limit = NULL;\n-\n-  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n-  if (cmp == NULL || cmp->Opcode() != Op_CmpL) {\n-    return false; \/\/ Avoid pointer & float & 32-bit compares\n-  }\n-\n-  Node* phi_incr = NULL;\n-  incr = loop_iv_incr(incr, x, loop, phi_incr);\n-  if (incr == NULL || incr->Opcode() != Op_AddL) {\n-    return false;\n-  }\n-\n-  Node* xphi = NULL;\n-  Node* stride = loop_iv_stride(incr, loop, xphi);\n-\n-  if (stride == NULL) {\n-    return false;\n-  }\n+  LongCountedLoopNode* head = x->as_LongCountedLoop();\n@@ -809,1 +778,1 @@\n-  jlong stride_con = stride->get_long();\n+  jlong stride_con = head->stride_con();\n@@ -829,1 +798,2 @@\n-  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n+  PhiNode* phi = head->phi()->as_Phi();\n+  Node* incr = head->incr();\n@@ -831,8 +801,1 @@\n-  if (phi == NULL || phi->in(LoopNode::LoopBackControl) != incr) {\n-    return false;\n-  }\n-\n-  \/\/ Safepoint on backedge not supported\n-  if (x->in(LoopNode::LoopBackControl)->Opcode() == Op_SafePoint) {\n-    return false;\n-  }\n+  Node* back_control = head->in(LoopNode::LoopBackControl);\n@@ -845,4 +808,1 @@\n-  if (!condition_stride_ok(bt, stride_con)) {\n-    return false;\n-  }\n-\n+  Node* limit = head->limit();\n@@ -854,1 +814,6 @@\n-  IfNode* exit_test = back_control->in(0)->as_If();\n+  const TypeLong* phi_t = _igvn.type(phi)->is_long();\n+  assert(phi_t->_hi >= phi_t->_lo, \"dead phi?\");\n+  iters_limit = (int)MIN2((julong)iters_limit, (julong)(phi_t->_hi - phi_t->_lo));\n+\n+  LongCountedLoopEndNode* exit_test = head->loopexit();\n+  BoolTest::mask bt = exit_test->test_trip();\n@@ -858,12 +823,0 @@\n-  if (safepoint == NULL) {\n-    \/\/ If exit condition is ne, then a loop limit check is likely needed\n-    if (bt == BoolTest::ne) {\n-      return false;\n-    }\n-  } else if (C->too_many_traps(safepoint->jvms()->method(),\n-                        safepoint->jvms()->bci(),\n-                        Deoptimization::Reason_loop_limit_check)) {\n-    \/\/ We must have transformed the loop already and a loop limit\n-    \/\/ check must have failed.\n-    return false;\n-  }\n@@ -871,1 +824,2 @@\n-  Node* exit_branch = exit_test->proj_out(back_control->Opcode() == Op_IfFalse);\n+  assert(back_control->Opcode() == Op_IfTrue, \"wrong projection for back edge\");\n+  Node* exit_branch = exit_test->proj_out(false);\n@@ -873,20 +827,1 @@\n-\n-  \/\/ if the loop exit test is on the IV before it is incremented: i <\n-  \/\/ limit, we transform the exit test so it is performed on the exit\n-  \/\/ test after it is incremented: i + stride < limit + stride.  We\n-  \/\/ need limit + stride to not overflow. See adjusted_limit below.\n-  bool limit_check_required = false;\n-  if (phi_incr != NULL) {\n-    const TypeLong* limit_t = _igvn.type(limit)->is_long();\n-    int sov = check_stride_overflow(stride_con, limit_t);\n-    if (sov != 0) {\n-      if (sov < 0) {\n-        return false;  \/\/ Bailout: integer overflow is certain.\n-      }\n-      \/\/ Check that inserting a predicate is indeed possible\n-      if (find_predicate_insertion_point(x->in(LoopNode::EntryControl), Deoptimization::Reason_loop_limit_check) == NULL) {\n-        return false;\n-      }\n-      limit_check_required = true;\n-    }\n-  }\n+  Node* cmp = exit_test->cmp_node();\n@@ -896,1 +831,1 @@\n-  Node* outer_exit_test = exit_test->clone();\n+  Node* outer_exit_test = new IfNode(exit_test->in(0), exit_test->in(1), exit_test->_prob, exit_test->_fcnt);\n@@ -927,9 +862,0 @@\n-  Node* adjusted_limit = limit;\n-  if (phi_incr != NULL) {\n-    \/\/ If compare points directly to the phi we need to adjust the\n-    \/\/ compare so that it points to the incr.\n-    Node* long_stride = _igvn.longcon(stride_con);\n-    set_ctrl(long_stride, C->root());\n-    adjusted_limit = new AddLNode(limit, long_stride);\n-    _igvn.register_new_node_with_optimizer(adjusted_limit);\n-  }\n@@ -938,1 +864,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(adjusted_limit, outer_phi, TypeLong::LONG, _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(limit, outer_phi, TypeLong::LONG, _igvn);\n@@ -940,1 +866,1 @@\n-    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, adjusted_limit, TypeLong::LONG, _igvn);\n+    inner_iters_max = MaxNode::max_diff_with_zero(outer_phi, limit, TypeLong::LONG, _igvn);\n@@ -965,6 +891,1 @@\n-  if (cmp->in(1) == incr || cmp->in(1) == phi) {\n-    inner_cmp = new CmpINode(inner_incr, inner_iters_actual_int);\n-  }  else {\n-    assert(cmp->in(2) == incr || cmp->in(2) == phi, \"bad iv shape\");\n-    inner_cmp = new CmpINode(inner_iters_actual_int, inner_incr);\n-  }\n+  inner_cmp = new CmpINode(inner_incr, inner_iters_actual_int);\n@@ -981,34 +902,0 @@\n-  \/\/ Add a predicate to guarantee limit adjustment doesn't overflow\n-  if (limit_check_required) {\n-    assert(phi_incr != NULL, \"only when exit test must be transformed\");\n-    ProjNode *limit_check_proj = find_predicate_insertion_point(outer_head->in(LoopNode::EntryControl), Deoptimization::Reason_loop_limit_check);\n-    assert(limit_check_proj != NULL, \"was tested before\");\n-    IfNode* check_iff = limit_check_proj->in(0)->as_If();\n-    Node* cmp_limit;\n-    Node* bol;\n-\n-    if (stride_con > 0) {\n-      cmp_limit = new CmpLNode(limit, _igvn.longcon(max_jlong - stride_con));\n-      bol = new BoolNode(cmp_limit, BoolTest::le);\n-    } else {\n-      cmp_limit = new CmpLNode(limit, _igvn.longcon(min_jlong - stride_con));\n-      bol = new BoolNode(cmp_limit, BoolTest::ge);\n-    }\n-\n-    insert_loop_limit_check(limit_check_proj, cmp_limit, bol);\n-    Node* new_predicate = limit_check_proj->in(0)->in(0);\n-    Node* above_predicate = new_predicate->in(0)->in(0);\n-    Node* entry = outer_head->in(LoopNode::EntryControl);\n-    _igvn.replace_input_of(limit_check_proj->in(0), 0, above_predicate);\n-    _igvn.replace_input_of(new_predicate->in(0), 0, entry);\n-    _igvn.replace_input_of(outer_head, LoopNode::EntryControl, new_predicate);\n-    set_idom(new_predicate->in(0), entry, dom_depth(entry));\n-    set_idom(new_predicate, new_predicate->in(0), dom_depth(entry));\n-    Node* region = new_predicate->in(0)->as_If()->proj_out(new_predicate->Opcode() == Op_IfFalse)->unique_ctrl_out();\n-    assert(region->is_Region(), \"should be region merging predicates\");\n-    set_idom(region, entry, dom_depth(entry));\n-    set_idom(limit_check_proj->in(0), above_predicate, dom_depth(above_predicate));\n-  }\n-\n-  LoopNode* inner_head = x->as_Loop();\n-\n@@ -1016,2 +903,2 @@\n-  for (uint i = 0; i < inner_head->outcnt(); i++) {\n-    Node* u = inner_head->raw_out(i);\n+  for (uint i = 0; i < head->outcnt(); i++) {\n+    Node* u = head->raw_out(i);\n@@ -1019,1 +906,1 @@\n-      assert(u->in(0) == inner_head, \"inconsistent\");\n+      assert(u->in(0) == head, \"inconsistent\");\n@@ -1029,1 +916,1 @@\n-  long_loop_replace_long_iv(phi, inner_phi, outer_phi, inner_head);\n+  long_loop_replace_long_iv(phi, inner_phi, outer_phi, head);\n@@ -1033,1 +920,3 @@\n-  long_loop_replace_long_iv(incr, inner_incr, outer_phi, inner_head);\n+  long_loop_replace_long_iv(incr, inner_incr, outer_phi, head);\n+\n+  set_subtree_ctrl(inner_iters_actual_int, body_populated);\n@@ -1035,1 +924,1 @@\n-  set_subtree_ctrl(inner_iters_actual_int);\n+  LoopNode* inner_head = create_inner_head(loop, head, exit_test);\n@@ -1051,1 +940,0 @@\n-  \/\/   \/\/ test happens before increment => phi == phi_incr != NULL\n@@ -1099,0 +987,2 @@\n+  } else {\n+    C->set_major_progress();\n@@ -1122,0 +1012,59 @@\n+LoopNode* PhaseIdealLoop::create_inner_head(IdealLoopTree* loop, LongCountedLoopNode* head,\n+                                            LongCountedLoopEndNode* exit_test) {\n+  LoopNode* new_inner_head = new LoopNode(head->in(1), head->in(2));\n+  IfNode* new_inner_exit = new IfNode(exit_test->in(0), exit_test->in(1), exit_test->_prob, exit_test->_fcnt);\n+  _igvn.register_new_node_with_optimizer(new_inner_head);\n+  _igvn.register_new_node_with_optimizer(new_inner_exit);\n+  loop->_body.push(new_inner_head);\n+  loop->_body.push(new_inner_exit);\n+  loop->_body.yank(head);\n+  loop->_body.yank(exit_test);\n+  set_loop(new_inner_head, loop);\n+  set_loop(new_inner_exit, loop);\n+  set_idom(new_inner_head, idom(head), dom_depth(head));\n+  set_idom(new_inner_exit, idom(exit_test), dom_depth(exit_test));\n+  lazy_replace(head, new_inner_head);\n+  lazy_replace(exit_test, new_inner_exit);\n+  loop->_head = new_inner_head;\n+  return new_inner_head;\n+}\n+\n+#ifdef ASSERT\n+void PhaseIdealLoop::check_long_counted_loop(IdealLoopTree* loop, Node* x) {\n+  Node* back_control = loop_exit_control(x, loop);\n+  assert(back_control != NULL, \"no back control\");\n+\n+  BoolTest::mask bt = BoolTest::illegal;\n+  float cl_prob = 0;\n+  Node* incr = NULL;\n+  Node* limit = NULL;\n+\n+  Node* cmp = loop_exit_test(back_control, loop, incr, limit, bt, cl_prob);\n+  assert(cmp != NULL && cmp->Opcode() == Op_CmpL, \"no exit test\");\n+\n+  Node* phi_incr = NULL;\n+  incr = loop_iv_incr(incr, x, loop, phi_incr);\n+  assert(incr != NULL && incr->Opcode() == Op_AddL, \"no incr\");\n+\n+  Node* xphi = NULL;\n+  Node* stride = loop_iv_stride(incr, loop, xphi);\n+\n+  assert(stride != NULL, \"no stride\");\n+\n+  PhiNode* phi = loop_iv_phi(xphi, phi_incr, x, loop);\n+\n+  assert(phi != NULL && phi->in(LoopNode::LoopBackControl) == incr, \"No phi\");\n+\n+  jlong stride_con = stride->get_long();\n+\n+  assert(condition_stride_ok(bt, stride_con), \"illegal condition\");\n+\n+  assert(bt != BoolTest::ne, \"unexpected condition\");\n+  assert(phi_incr == NULL, \"bad loop shape\");\n+  assert(cmp->in(1) == incr, \"bad exit test shape\");\n+\n+  \/\/ Safepoint on backedge not supported\n+  assert(x->in(LoopNode::LoopBackControl)->Opcode() != Op_SafePoint, \"no safepoint on backedge\");\n+}\n+#endif\n+\n@@ -1193,1 +1142,1 @@\n-        set_subtree_ctrl(in_clone);\n+        set_subtree_ctrl(in_clone, false);\n@@ -1210,1 +1159,1 @@\n-    set_subtree_ctrl(clone);\n+    set_subtree_ctrl(clone, false);\n@@ -1220,1 +1169,1 @@\n-        set_subtree_ctrl(m);\n+        set_subtree_ctrl(m, false);\n@@ -1232,1 +1181,1 @@\n-bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*& loop) {\n+bool PhaseIdealLoop::is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt) {\n@@ -1245,1 +1194,1 @@\n-  if (cmp == NULL || cmp->Opcode() != Op_CmpI) {\n+  if (cmp == NULL || !(cmp->is_Cmp() && cmp->operates_on(iv_bt, true))) {\n@@ -1250,1 +1199,1 @@\n-  if (incr->Opcode() == Op_CastII) {\n+  if (incr->is_ConstraintCast() && incr->operates_on(iv_bt, false)) {\n@@ -1262,1 +1211,1 @@\n-  const TypeInt* iv_trunc_t = NULL;\n+  const TypeInteger* iv_trunc_t = NULL;\n@@ -1264,1 +1213,1 @@\n-  if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &trunc1, &trunc2, &iv_trunc_t))) {\n+  if (!(incr = CountedLoopNode::match_incr_with_optional_truncation(incr, &trunc1, &trunc2, &iv_trunc_t, iv_bt))) {\n@@ -1267,1 +1216,1 @@\n-  assert(incr->Opcode() == Op_AddI, \"wrong increment code\");\n+  assert(incr->is_Add() && incr->operates_on(iv_bt, false), \"wrong increment code\");\n@@ -1276,1 +1225,1 @@\n-  if (xphi->Opcode() == Op_CastII) {\n+  if (xphi->is_ConstraintCast() && xphi->operates_on(iv_bt, false)) {\n@@ -1281,1 +1230,1 @@\n-  int stride_con = stride->get_int();\n+  jlong stride_con = stride->get_integer_as_long(iv_bt);\n@@ -1293,1 +1242,2 @@\n-      LoopStripMiningIter != 0) {\n+          ((iv_bt == T_INT && LoopStripMiningIter != 0) ||\n+           iv_bt == T_LONG)) {\n@@ -1306,1 +1256,1 @@\n-  const TypeInt* limit_t = gvn->type(limit)->is_int();\n+  const TypeInteger* limit_t = gvn->type(limit)->is_integer(iv_bt);\n@@ -1325,2 +1275,2 @@\n-    const TypeInt* incr_t = gvn->type(orig_incr)->is_int();\n-    if (limit_t->_hi > incr_t->_hi) {\n+    const TypeInteger* incr_t = gvn->type(orig_incr)->is_integer(iv_bt);\n+    if (limit_t->hi_as_long() > incr_t->hi_as_long()) {\n@@ -1335,1 +1285,1 @@\n-  if (!TypeInt::INT->higher_equal(iv_trunc_t)) {\n+  if (!TypeInteger::bottom(iv_bt)->higher_equal(iv_trunc_t)) {\n@@ -1339,1 +1289,1 @@\n-    const TypeInt* phi_ft = filtered_type(phi);\n+    const TypeInteger* phi_ft = filtered_type(phi);\n@@ -1353,2 +1303,2 @@\n-      if (iv_trunc_t->_hi - phi_ft->_hi < stride_con ||\n-          iv_trunc_t->_lo > phi_ft->_lo) {\n+      if (iv_trunc_t->hi_as_long() - phi_ft->hi_as_long() < stride_con ||\n+          iv_trunc_t->lo_as_long() > phi_ft->lo_as_long()) {\n@@ -1358,2 +1308,2 @@\n-      if (iv_trunc_t->_lo - phi_ft->_lo > stride_con ||\n-          iv_trunc_t->_hi < phi_ft->_hi) {\n+      if (iv_trunc_t->lo_as_long() - phi_ft->lo_as_long() > stride_con ||\n+          iv_trunc_t->hi_as_long() < phi_ft->hi_as_long()) {\n@@ -1373,1 +1323,1 @@\n-  const TypeInt* init_t = gvn->type(init_trip)->is_int();\n+  const TypeInteger* init_t = gvn->type(init_trip)->is_integer(iv_bt);\n@@ -1376,3 +1326,3 @@\n-    jlong init_p = (jlong)init_t->_lo + stride_con;\n-    if (init_p > (jlong)max_jint || init_p > (jlong)limit_t->_hi)\n-      return false; \/\/ cyclic loop or this loop trips only once\n+    if (init_t->lo_as_long() > max_signed_integer(iv_bt) - stride_con) {\n+      return false; \/\/ cyclic loop\n+    }\n@@ -1380,3 +1330,3 @@\n-    jlong init_p = (jlong)init_t->_hi + stride_con;\n-    if (init_p < (jlong)min_jint || init_p < (jlong)limit_t->_lo)\n-      return false; \/\/ cyclic loop or this loop trips only once\n+    if (init_t->hi_as_long() < min_signed_integer(iv_bt) - stride_con) {\n+      return false; \/\/ cyclic loop\n+    }\n@@ -1388,1 +1338,1 @@\n-      if (init_t->_hi > max_jint - stride_con) {\n+      if (init_t->hi_as_long() > max_signed_integer(iv_bt) - stride_con) {\n@@ -1392,1 +1342,1 @@\n-      if (init_t->_lo < min_jint - stride_con) {\n+      if (init_t->lo_as_long() < min_signed_integer(iv_bt) - stride_con) {\n@@ -1401,1 +1351,1 @@\n-  assert(x->Opcode() == Op_Loop, \"regular loops only\");\n+  assert(x->Opcode() == Op_Loop || x->Opcode() == Op_LongCountedLoop, \"regular loops only\");\n@@ -1421,1 +1371,1 @@\n-  int stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n+  jlong stride_m  = stride_con - (incl_limit ? 0 : (stride_con > 0 ? 1 : -1));\n@@ -1434,1 +1384,1 @@\n-  int sov = check_stride_overflow(stride_m, limit_t);\n+  int sov = check_stride_overflow(stride_m, limit_t, iv_bt);\n@@ -1467,1 +1417,1 @@\n-      cmp_limit = new CmpINode(limit, _igvn.intcon(max_jint - stride_m));\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(max_jint - stride_m, iv_bt), iv_bt);\n@@ -1470,1 +1420,1 @@\n-      cmp_limit = new CmpINode(limit, _igvn.intcon(min_jint - stride_m));\n+      cmp_limit = CmpNode::make(limit, _igvn.integercon(min_jint - stride_m, iv_bt), iv_bt);\n@@ -1480,1 +1430,1 @@\n-    if (stride_con > 0 && init_t->_hi < limit_t->_lo) {\n+    if (stride_con > 0 && init_t->hi_as_long() < limit_t->lo_as_long()) {\n@@ -1483,1 +1433,1 @@\n-    } else if (stride_con < 0 && init_t->_lo > limit_t->_hi) {\n+    } else if (stride_con < 0 && init_t->lo_as_long() > limit_t->hi_as_long()) {\n@@ -1510,1 +1460,1 @@\n-        cmp_limit = new CmpINode(init_trip, limit);\n+        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n@@ -1513,1 +1463,1 @@\n-        cmp_limit = new CmpINode(init_trip, limit);\n+        cmp_limit = CmpNode::make(init_trip, limit, iv_bt);\n@@ -1530,1 +1480,5 @@\n-  if (!x->as_Loop()->is_transformed_long_loop() && StressLongCountedLoop > 0 && trunc1 == NULL && convert_to_long_loop(cmp, phi, loop)) {\n+  if (iv_bt == T_INT &&\n+      !x->as_Loop()->is_transformed_long_loop() &&\n+      StressLongCountedLoop > 0 &&\n+      trunc1 == NULL &&\n+      convert_to_long_loop(cmp, phi, loop)) {\n@@ -1545,1 +1499,1 @@\n-    adjusted_limit = gvn->transform(new AddINode(limit, stride));\n+    adjusted_limit = gvn->transform(AddNode::make(limit, stride, iv_bt));\n@@ -1552,2 +1506,2 @@\n-    Node* one = (stride_con > 0) ? gvn->intcon( 1) : gvn->intcon(-1);\n-    adjusted_limit = gvn->transform(new AddINode(adjusted_limit, one));\n+    Node* one = (stride_con > 0) ? gvn->integercon( 1, iv_bt) : gvn->integercon(-1, iv_bt);\n+    adjusted_limit = gvn->transform(AddNode::make(adjusted_limit, one, iv_bt));\n@@ -1561,1 +1515,1 @@\n-  set_subtree_ctrl(adjusted_limit);\n+  set_subtree_ctrl(adjusted_limit, false);\n@@ -1563,1 +1517,1 @@\n-  if (LoopStripMiningIter == 0) {\n+  if (iv_bt == T_INT && LoopStripMiningIter == 0) {\n@@ -1581,1 +1535,1 @@\n-  set_early_ctrl( incr );\n+  set_early_ctrl(incr, false);\n@@ -1588,2 +1542,2 @@\n-  if (!TypeInt::INT->higher_equal(phi->bottom_type())) {\n-    Node* nphi = PhiNode::make(phi->in(0), phi->in(LoopNode::EntryControl), TypeInt::INT);\n+  if (!TypeInteger::bottom(iv_bt)->higher_equal(phi->bottom_type())) {\n+    Node* nphi = PhiNode::make(phi->in(0), phi->in(LoopNode::EntryControl), TypeInteger::bottom(iv_bt));\n@@ -1609,1 +1563,1 @@\n-  Node *lex = _igvn.register_new_node_with_optimizer(new CountedLoopEndNode( iff->in(0), test, cl_prob, iff->as_If()->_fcnt ));\n+  Node *lex = _igvn.register_new_node_with_optimizer(BaseCountedLoopEndNode::make(iff->in(0), test, cl_prob, iff->as_If()->_fcnt, iv_bt));\n@@ -1649,2 +1603,5 @@\n-  bool strip_mine_loop = LoopStripMiningIter > 1 && loop->_child == NULL &&\n-    sfpt2->Opcode() == Op_SafePoint && !loop->_has_call;\n+  bool strip_mine_loop = iv_bt == T_INT &&\n+                         LoopStripMiningIter > 1 &&\n+                         loop->_child == NULL &&\n+                         sfpt2->Opcode() == Op_SafePoint &&\n+                         !loop->_has_call;\n@@ -1659,1 +1616,1 @@\n-  CountedLoopNode *l = new CountedLoopNode(entry_control, back_control);\n+  BaseCountedLoopNode *l = BaseCountedLoopNode::make(entry_control, back_control, iv_bt);\n@@ -1673,1 +1630,1 @@\n-  if (LoopStripMiningIter == 0 || strip_mine_loop) {\n+  if (iv_bt == T_INT && (LoopStripMiningIter == 0 || strip_mine_loop)) {\n@@ -1694,1 +1651,1 @@\n-  assert(l->is_valid_counted_loop(), \"counted loop shape is messed up\");\n+  assert(l->is_valid_counted_loop(iv_bt), \"counted loop shape is messed up\");\n@@ -1731,1 +1688,1 @@\n-  assert(cl->is_valid_counted_loop(), \"\");\n+  assert(cl->is_valid_counted_loop(T_INT), \"\");\n@@ -1781,1 +1738,1 @@\n-    if (!is_valid_counted_loop()) {\n+    if (!is_valid_counted_loop(T_INT)) {\n@@ -1790,1 +1747,1 @@\n-    assert(inner->is_valid_counted_loop() && inner->is_strip_mined(), \"OuterStripMinedLoop should have been removed\");\n+    assert(inner->is_valid_counted_loop(T_INT) && inner->is_strip_mined(), \"OuterStripMinedLoop should have been removed\");\n@@ -1887,2 +1844,11 @@\n-int CountedLoopEndNode::stride_con() const {\n-  return stride()->bottom_type()->is_int()->get_con();\n+jlong BaseCountedLoopEndNode::stride_con() const {\n+  return stride()->bottom_type()->is_integer(bt())->get_con_as_long(bt());\n+}\n+\n+\n+BaseCountedLoopEndNode* BaseCountedLoopEndNode::make(Node* control, Node* test, float prob, float cnt, BasicType bt) {\n+  if (bt == T_INT) {\n+    return new CountedLoopEndNode(control, test, prob, cnt);\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return new LongCountedLoopEndNode(control, test, prob, cnt);\n@@ -2019,2 +1985,3 @@\n-Node* CountedLoopNode::match_incr_with_optional_truncation(\n-                      Node* expr, Node** trunc1, Node** trunc2, const TypeInt** trunc_type) {\n+Node* CountedLoopNode::match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2,\n+                                                           const TypeInteger** trunc_type,\n+                                                           BasicType bt) {\n@@ -2026,1 +1993,0 @@\n-  const TypeInt* trunc_t = TypeInt::INT;\n@@ -2029,18 +1995,8 @@\n-\n-  \/\/ Try to strip (n1 & M) or (n1 << N >> N) from n1.\n-  if (n1op == Op_AndI &&\n-      n1->in(2)->is_Con() &&\n-      n1->in(2)->bottom_type()->is_int()->get_con() == 0x7fff) {\n-    \/\/ %%% This check should match any mask of 2**K-1.\n-    t1 = n1;\n-    n1 = t1->in(1);\n-    n1op = n1->Opcode();\n-    trunc_t = TypeInt::CHAR;\n-  } else if (n1op == Op_RShiftI &&\n-             n1->in(1) != NULL &&\n-             n1->in(1)->Opcode() == Op_LShiftI &&\n-             n1->in(2) == n1->in(1)->in(2) &&\n-             n1->in(2)->is_Con()) {\n-    jint shift = n1->in(2)->bottom_type()->is_int()->get_con();\n-    \/\/ %%% This check should match any shift in [1..31].\n-    if (shift == 16 || shift == 8) {\n+  const TypeInteger* trunc_t = TypeInteger::bottom(bt);\n+\n+  if (bt == T_INT) {\n+    \/\/ Try to strip (n1 & M) or (n1 << N >> N) from n1.\n+    if (n1op == Op_AndI &&\n+        n1->in(2)->is_Con() &&\n+        n1->in(2)->bottom_type()->is_int()->get_con() == 0x7fff) {\n+      \/\/ %%% This check should match any mask of 2**K-1.\n@@ -2048,2 +2004,1 @@\n-      t2 = t1->in(1);\n-      n1 = t2->in(1);\n+      n1 = t1->in(1);\n@@ -2051,4 +2006,18 @@\n-      if (shift == 16) {\n-        trunc_t = TypeInt::SHORT;\n-      } else if (shift == 8) {\n-        trunc_t = TypeInt::BYTE;\n+      trunc_t = TypeInt::CHAR;\n+    } else if (n1op == Op_RShiftI &&\n+               n1->in(1) != NULL &&\n+               n1->in(1)->Opcode() == Op_LShiftI &&\n+               n1->in(2) == n1->in(1)->in(2) &&\n+               n1->in(2)->is_Con()) {\n+      jint shift = n1->in(2)->bottom_type()->is_int()->get_con();\n+      \/\/ %%% This check should match any shift in [1..31].\n+      if (shift == 16 || shift == 8) {\n+        t1 = n1;\n+        t2 = t1->in(1);\n+        n1 = t2->in(1);\n+        n1op = n1->Opcode();\n+        if (shift == 16) {\n+          trunc_t = TypeInt::SHORT;\n+        } else if (shift == 8) {\n+          trunc_t = TypeInt::BYTE;\n+        }\n@@ -2060,1 +2029,1 @@\n-  if (n1op == Op_AddI) {\n+  if (n1->is_Add() && n1->operates_on(bt, true)) {\n@@ -2072,1 +2041,1 @@\n-  if (is_strip_mined() && is_valid_counted_loop()) {\n+  if (is_strip_mined() && is_valid_counted_loop(T_INT)) {\n@@ -2184,0 +2153,20 @@\n+\n+int CountedLoopNode::stride_con() const {\n+  CountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->stride_con() : 0;\n+}\n+\n+jlong LongCountedLoopNode::stride_con() const {\n+  LongCountedLoopEndNode* cle = loopexit_or_null();\n+  return cle != NULL ? cle->stride_con() : 0;\n+}\n+\n+BaseCountedLoopNode* BaseCountedLoopNode::make(Node* entry, Node* backedge, BasicType bt) {\n+  if (bt == T_INT) {\n+    return new CountedLoopNode(entry, backedge);\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return new LongCountedLoopNode(entry, backedge);\n+}\n+\n+\n@@ -2413,1 +2402,1 @@\n-    \/\/ If limit < init for stride > 0 (or limit > init for stride 0),\n+    \/\/ If limit < init for stride > 0 (or limit > init for stride < 0),\n@@ -3162,1 +3151,1 @@\n-  if (!cl->is_valid_counted_loop())\n+  if (!cl->is_valid_counted_loop(T_INT))\n@@ -3226,1 +3215,1 @@\n-      set_early_ctrl(ratio_init);\n+      set_early_ctrl(ratio_init, false);\n@@ -3229,1 +3218,1 @@\n-      set_early_ctrl(diff);\n+      set_early_ctrl(diff, false);\n@@ -3289,1 +3278,1 @@\n-      phase->is_counted_loop(_head, loop)) {\n+      phase->is_counted_loop(_head, loop, T_INT)) {\n@@ -3302,1 +3291,3 @@\n-\n+  } else if (_head->is_LongCountedLoop() ||\n+             phase->is_counted_loop(_head, loop, T_LONG)) {\n+    remove_safepoints(phase, true);\n@@ -3306,4 +3297,4 @@\n-    \/\/ Not a counted loop. Keep one safepoint.\n-    bool keep_one_sfpt = true;\n-    remove_safepoints(phase, keep_one_sfpt);\n-  }\n+      \/\/ Not a counted loop. Keep one safepoint.\n+      bool keep_one_sfpt = true;\n+      remove_safepoints(phase, keep_one_sfpt);\n+    }\n@@ -3942,5 +3933,0 @@\n-  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n-    IdealLoopTree* lpt = iter.current();\n-    is_long_counted_loop(lpt->_head, lpt, worklist);\n-  }\n-\n@@ -4013,0 +3999,7 @@\n+  if (C->has_loops() && !C->major_progress()) {\n+    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+      IdealLoopTree *lpt = iter.current();\n+      transform_long_counted_loop(lpt, worklist);\n+    }\n+  }\n+\n@@ -4773,1 +4766,1 @@\n-          set_early_ctrl( n );\n+          set_early_ctrl(n, false);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":318,"deletions":325,"binary":false,"changes":643,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class CountedLoopEndNode;\n+class BaseCountedLoopEndNode;\n@@ -153,1 +153,1 @@\n-  bool is_valid_counted_loop() const;\n+  bool is_valid_counted_loop(BasicType bt) const;\n@@ -195,1 +195,30 @@\n-class CountedLoopNode : public LoopNode {\n+class BaseCountedLoopNode : public LoopNode {\n+public:\n+  BaseCountedLoopNode(Node *entry, Node *backedge)\n+    : LoopNode(entry, backedge) {\n+  }\n+\n+  Node *init_control() const { return in(EntryControl); }\n+  Node *back_control() const { return in(LoopBackControl); }\n+\n+  Node* init_trip() const;\n+  Node* stride() const;\n+  bool stride_is_con() const;\n+  Node* limit() const;\n+  Node* incr() const;\n+  Node* phi() const;\n+\n+  BaseCountedLoopEndNode* loopexit_or_null() const;\n+  BaseCountedLoopEndNode* loopexit() const;\n+\n+  virtual BasicType bt() const = 0;\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+\n+  static BaseCountedLoopNode* make(Node* entry, Node* backedge, BasicType bt);\n+};\n+\n+\n+class CountedLoopNode : public BaseCountedLoopNode {\n@@ -219,2 +248,2 @@\n-  CountedLoopNode( Node *entry, Node *backedge )\n-    : LoopNode(entry, backedge), _main_idx(0), _trip_count(max_juint),\n+  CountedLoopNode(Node *entry, Node *backedge)\n+    : BaseCountedLoopNode(entry, backedge), _main_idx(0), _trip_count(max_juint),\n@@ -231,6 +260,2 @@\n-  Node *init_control() const { return in(EntryControl); }\n-  Node *back_control() const { return in(LoopBackControl); }\n-  CountedLoopEndNode *loopexit_or_null() const;\n-  CountedLoopEndNode *loopexit() const;\n-  Node *init_trip() const;\n-  Node *stride() const;\n+  CountedLoopEndNode* loopexit_or_null() const { return (CountedLoopEndNode*) BaseCountedLoopNode::loopexit_or_null(); }\n+  CountedLoopEndNode* loopexit() const { return (CountedLoopEndNode*) BaseCountedLoopNode::loopexit(); }\n@@ -238,4 +263,0 @@\n-  bool  stride_is_con() const;\n-  Node *limit() const;\n-  Node *incr() const;\n-  Node *phi() const;\n@@ -244,1 +265,3 @@\n-  static Node* match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2, const TypeInt** trunc_type);\n+  static Node*\n+  match_incr_with_optional_truncation(Node* expr, Node** trunc1, Node** trunc2, const TypeInteger** trunc_type,\n+                                      BasicType bt);\n@@ -319,0 +342,8 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n+  virtual BasicType bt() const {\n+    return T_INT;\n+  }\n+\n@@ -324,0 +355,24 @@\n+class LongCountedLoopNode : public BaseCountedLoopNode {\n+public:\n+  LongCountedLoopNode(Node *entry, Node *backedge)\n+    : BaseCountedLoopNode(entry, backedge) {\n+    init_class_id(Class_LongCountedLoop);\n+  }\n+\n+  virtual int Opcode() const;\n+\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n+\n+  virtual BasicType bt() const {\n+    return T_LONG;\n+  }\n+\n+  LongCountedLoopEndNode* loopexit_or_null() const { return (LongCountedLoopEndNode*) BaseCountedLoopNode::loopexit_or_null(); }\n+  LongCountedLoopEndNode* loopexit() const { return (LongCountedLoopEndNode*) BaseCountedLoopNode::loopexit(); }\n+  jlong   stride_con() const;\n+};\n+\n+\n@@ -327,1 +382,2 @@\n-class CountedLoopEndNode : public IfNode {\n+\n+class BaseCountedLoopEndNode : public IfNode {\n@@ -330,4 +386,3 @@\n-\n-  CountedLoopEndNode( Node *control, Node *test, float prob, float cnt )\n-    : IfNode( control, test, prob, cnt) {\n-    init_class_id(Class_CountedLoopEnd);\n+  BaseCountedLoopEndNode(Node *control, Node *test, float prob, float cnt)\n+    : IfNode(control, test, prob, cnt) {\n+    init_class_id(Class_BaseCountedLoopEnd);\n@@ -335,1 +390,0 @@\n-  virtual int Opcode() const;\n@@ -338,9 +392,8 @@\n-  Node *incr() const                { Node *tmp = cmp_node(); return (tmp && tmp->req()==3) ? tmp->in(1) : NULL; }\n-  Node *limit() const               { Node *tmp = cmp_node(); return (tmp && tmp->req()==3) ? tmp->in(2) : NULL; }\n-  Node *stride() const              { Node *tmp = incr    (); return (tmp && tmp->req()==3) ? tmp->in(2) : NULL; }\n-  Node *init_trip() const           { Node *tmp = phi     (); return (tmp && tmp->req()==3) ? tmp->in(1) : NULL; }\n-  int stride_con() const;\n-  bool stride_is_con() const        { Node *tmp = stride  (); return (tmp != NULL && tmp->is_Con()); }\n-  BoolTest::mask test_trip() const  { return in(TestValue)->as_Bool()->_test._test; }\n-  PhiNode *phi() const {\n-    Node *tmp = incr();\n+  Node* incr() const                { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n+  Node* limit() const               { Node* tmp = cmp_node(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n+  Node* stride() const              { Node* tmp = incr(); return (tmp && tmp->req() == 3) ? tmp->in(2) : NULL; }\n+  Node* init_trip() const           { Node* tmp = phi(); return (tmp && tmp->req() == 3) ? tmp->in(1) : NULL; }\n+  bool stride_is_con() const        { Node *tmp = stride(); return (tmp != NULL && tmp->is_Con()); }\n+\n+  PhiNode* phi() const {\n+    Node* tmp = incr();\n@@ -355,1 +408,2 @@\n-  CountedLoopNode *loopnode() const {\n+\n+  BaseCountedLoopNode* loopnode() const {\n@@ -363,3 +417,3 @@\n-    Node *ln = iv_phi->in(0);\n-    if (ln->is_CountedLoop() && ln->as_CountedLoop()->loopexit_or_null() == this) {\n-      return (CountedLoopNode*)ln;\n+    Node* ln = iv_phi->in(0);\n+    if (!ln->is_BaseCountedLoop() || ln->as_BaseCountedLoop()->loopexit_or_null() != this) {\n+      return NULL;\n@@ -367,1 +421,37 @@\n-    return NULL;\n+    if (!ln->operates_on(bt(), true)) {\n+      return NULL;\n+    }\n+    return ln->as_BaseCountedLoop();\n+  }\n+\n+  BoolTest::mask test_trip() const  { return in(TestValue)->as_Bool()->_test._test; }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n+\n+  jlong stride_con() const;\n+  virtual BasicType bt() const = 0;\n+\n+  static BaseCountedLoopEndNode* make(Node* control, Node* test, float prob, float cnt, BasicType bt);\n+};\n+\n+class CountedLoopEndNode : public BaseCountedLoopEndNode {\n+public:\n+\n+  CountedLoopEndNode(Node *control, Node *test, float prob, float cnt)\n+    : BaseCountedLoopEndNode(control, test, prob, cnt) {\n+    init_class_id(Class_CountedLoopEnd);\n+  }\n+  virtual int Opcode() const;\n+\n+  CountedLoopNode* loopnode() const {\n+    return (CountedLoopNode*) BaseCountedLoopEndNode::loopnode();\n+  }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT;\n+  }\n+\n+  virtual BasicType bt() const {\n+    return T_INT;\n@@ -375,0 +465,21 @@\n+class LongCountedLoopEndNode : public BaseCountedLoopEndNode {\n+public:\n+  LongCountedLoopEndNode(Node *control, Node *test, float prob, float cnt)\n+    : BaseCountedLoopEndNode(control, test, prob, cnt) {\n+    init_class_id(Class_LongCountedLoopEnd);\n+  }\n+\n+  LongCountedLoopNode* loopnode() const {\n+    return (LongCountedLoopNode*) BaseCountedLoopEndNode::loopnode();\n+  }\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG;\n+  }\n+  virtual int Opcode() const;\n+\n+  virtual BasicType bt() const {\n+    return T_LONG;\n+  }\n+};\n+\n@@ -376,1 +487,1 @@\n-inline CountedLoopEndNode* CountedLoopNode::loopexit_or_null() const {\n+inline BaseCountedLoopEndNode* BaseCountedLoopNode::loopexit_or_null() const {\n@@ -381,2 +492,8 @@\n-  return (CountedLoopEndNode*)\n-      (lexit->Opcode() == Op_CountedLoopEnd ? lexit : NULL);\n+  if (!lexit->is_BaseCountedLoopEnd()) {\n+    return NULL;\n+  }\n+  BaseCountedLoopEndNode* result = lexit->as_BaseCountedLoopEnd();\n+  if (!result->operates_on(bt(), true)) {\n+    return NULL;\n+  }\n+  return result;\n@@ -385,2 +502,2 @@\n-inline CountedLoopEndNode* CountedLoopNode::loopexit() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline BaseCountedLoopEndNode* BaseCountedLoopNode::loopexit() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -391,2 +508,2 @@\n-inline Node* CountedLoopNode::init_trip() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::init_trip() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -395,2 +512,2 @@\n-inline Node* CountedLoopNode::stride() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::stride() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -399,6 +516,3 @@\n-inline int CountedLoopNode::stride_con() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n-  return cle != NULL ? cle->stride_con() : 0;\n-}\n-inline bool CountedLoopNode::stride_is_con() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+\n+inline bool BaseCountedLoopNode::stride_is_con() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -407,2 +521,2 @@\n-inline Node* CountedLoopNode::limit() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::limit() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -411,2 +525,2 @@\n-inline Node* CountedLoopNode::incr() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::incr() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -415,2 +529,2 @@\n-inline Node* CountedLoopNode::phi() const {\n-  CountedLoopEndNode* cle = loopexit_or_null();\n+inline Node* BaseCountedLoopNode::phi() const {\n+  BaseCountedLoopEndNode* cle = loopexit_or_null();\n@@ -824,2 +938,2 @@\n-  void set_early_ctrl( Node *n );\n-  void set_subtree_ctrl( Node *root );\n+  void set_early_ctrl(Node* n, bool update_body);\n+  void set_subtree_ctrl(Node* n, bool update_body);\n@@ -934,11 +1048,0 @@\n-  \/\/ Perform verification that the graph is valid.\n-  PhaseIdealLoop( PhaseIterGVN &igvn) :\n-    PhaseTransform(Ideal_Loop),\n-    _igvn(igvn),\n-    _verify_me(NULL),\n-    _verify_only(true),\n-    _dom_lca_tags(arena()),  \/\/ Thread::resource_area\n-    _nodes_required(UINT_MAX) {\n-    build_and_optimize(LoopOptsVerify);\n-  }\n-\n@@ -952,1 +1055,1 @@\n-  PhaseIdealLoop(PhaseIterGVN &igvn, LoopOptsMode mode) :\n+  PhaseIdealLoop(PhaseIterGVN& igvn, LoopOptsMode mode) :\n@@ -955,1 +1058,1 @@\n-    _verify_me(NULL),\n+    _verify_me(nullptr),\n@@ -959,0 +1062,1 @@\n+    assert(mode != LoopOptsVerify, \"wrong constructor to verify IdealLoop\");\n@@ -962,2 +1066,4 @@\n-  \/\/ Verify that verify_me made the same decisions as a fresh run.\n-  PhaseIdealLoop(PhaseIterGVN &igvn, const PhaseIdealLoop *verify_me) :\n+#ifndef PRODUCT\n+  \/\/ Verify that verify_me made the same decisions as a fresh run\n+  \/\/ or only verify that the graph is valid if verify_me is null.\n+  PhaseIdealLoop(PhaseIterGVN& igvn, const PhaseIdealLoop* verify_me = nullptr) :\n@@ -967,1 +1073,1 @@\n-    _verify_only(false),\n+    _verify_only(verify_me == nullptr),\n@@ -972,0 +1078,1 @@\n+#endif\n@@ -1057,1 +1164,2 @@\n-  bool is_counted_loop(Node* n, IdealLoopTree* &loop);\n+  bool is_counted_loop(Node* x, IdealLoopTree*&loop, BasicType iv_bt);\n+\n@@ -1059,1 +1167,1 @@\n-  bool is_long_counted_loop(Node* x, IdealLoopTree* loop, Node_List &old_new);\n+  bool transform_long_counted_loop(IdealLoopTree* loop, Node_List &old_new);\n@@ -1493,0 +1601,4 @@\n+\n+  void check_long_counted_loop(IdealLoopTree* loop, Node* x) NOT_DEBUG_RETURN;\n+\n+  LoopNode* create_inner_head(IdealLoopTree* loop, LongCountedLoopNode* head, LongCountedLoopEndNode* exit_test);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":189,"deletions":77,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-      set_early_ctrl(cd);\n+      set_early_ctrl(cd, false);\n@@ -518,1 +518,1 @@\n-        loop_n->_head->as_Loop()->is_valid_counted_loop() &&\n+        loop_n->_head->as_Loop()->is_valid_counted_loop(T_INT) &&\n@@ -1041,1 +1041,2 @@\n-  if ((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_loop())) && n->Opcode() == Op_AddI) {\n+  if (((n_blk->is_CountedLoop() || (n_blk->is_Loop() && n_blk->as_Loop()->is_transformed_long_loop())) && n->Opcode() == Op_AddI) ||\n+      (n_blk->is_LongCountedLoop() && n->Opcode() == Op_AddL)) {\n@@ -2295,1 +2296,1 @@\n-  const TypeInt* ttype = NULL;\n+  const TypeInteger* ttype = NULL;\n@@ -2316,1 +2317,1 @@\n-                                &trunc1, &trunc2, &ttype);\n+                                &trunc1, &trunc2, &ttype, T_INT);\n@@ -2326,1 +2327,1 @@\n-                                &trunc1, &trunc2, &ttype);\n+                                &trunc1, &trunc2, &ttype, T_INT);\n@@ -3496,1 +3497,1 @@\n-  if (!loop->_head->as_Loop()->is_valid_counted_loop())\n+  if (!loop->_head->as_Loop()->is_valid_counted_loop(T_INT))\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1510,0 +1510,10 @@\n+const TypeInteger* Node::find_integer_type(BasicType bt) const {\n+  if (this->is_Type()) {\n+    return this->as_Type()->type()->isa_integer(bt);\n+  } else if (this->is_Con()) {\n+    assert(is_Mach(), \"should be ConNode(TypeNode) or else a MachNode\");\n+    return this->bottom_type()->isa_integer(bt);\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+class BaseCountedLoopNode;\n+class BaseCountedLoopEndNode;\n@@ -92,0 +94,2 @@\n+class LongCountedLoopNode;\n+class LongCountedLoopEndNode;\n@@ -644,1 +648,3 @@\n-          DEFINE_CLASS_ID(CountedLoopEnd,         If, 0)\n+          DEFINE_CLASS_ID(BaseCountedLoopEnd,     If, 0)\n+            DEFINE_CLASS_ID(CountedLoopEnd,       BaseCountedLoopEnd, 0)\n+            DEFINE_CLASS_ID(LongCountedLoopEnd,   BaseCountedLoopEnd, 1)\n@@ -716,1 +722,3 @@\n-        DEFINE_CLASS_ID(CountedLoop,         Loop, 1)\n+        DEFINE_CLASS_ID(BaseCountedLoop,     Loop, 1)\n+          DEFINE_CLASS_ID(CountedLoop,       BaseCountedLoop, 0)\n+          DEFINE_CLASS_ID(LongCountedLoop,   BaseCountedLoop, 1)\n@@ -819,0 +827,2 @@\n+  DEFINE_CLASS_QUERY(BaseCountedLoop)\n+  DEFINE_CLASS_QUERY(BaseCountedLoopEnd)\n@@ -857,0 +867,2 @@\n+  DEFINE_CLASS_QUERY(LongCountedLoop)\n+  DEFINE_CLASS_QUERY(LongCountedLoopEnd)\n@@ -1098,0 +1110,1 @@\n+  const TypeInteger* find_integer_type(BasicType bt) const;\n@@ -1111,0 +1124,5 @@\n+  jlong get_integer_as_long(BasicType bt) const {\n+    const TypeInteger* t = find_integer_type(bt);\n+    guarantee(t != NULL, \"must be con\");\n+    return t->get_con_as_long(bt);\n+  }\n@@ -1220,0 +1238,6 @@\n+public:\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    Unimplemented();\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1699,2 +1699,0 @@\n-      assert(!is_mcall || (call_returns[block->_pre_order] <= (uint) current_offset), \"ret_addr_offset() not within emitted code\");\n-\n@@ -1708,0 +1706,3 @@\n+      assert(!is_mcall || (call_returns[block->_pre_order] <= (uint)current_offset),\n+             \"ret_addr_offset() not within emitted code\");\n+\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -790,0 +790,10 @@\n+ConNode* PhaseTransform::integercon(jlong l, BasicType bt) {\n+  if (bt == T_INT) {\n+    jint int_con = (jint)l;\n+    assert(((long)int_con) == l, \"not an int\");\n+    return intcon(int_con);\n+  }\n+  assert(bt == T_LONG, \"not an integer\");\n+  return longcon(l);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -147,1 +147,21 @@\n-  return Size() == 1;\n+\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    uintptr_t v = _RM_UP[i];\n+    if (v != 0) {\n+      \/\/ Only one bit allowed -> v must be a power of two\n+      if (!is_power_of_2(v)) {\n+        return false;\n+      }\n+\n+      \/\/ A single bit was found - check there are no bits in the rest of the mask\n+      for (i++; i <= _hwm; i++) {\n+        if (_RM_UP[i] != 0) {\n+          return false;\n+        }\n+      }\n+      \/\/ Done; found a single bit\n+      return true;\n+    }\n+  }\n+  \/\/ No bit found\n+  return false;\n@@ -153,1 +173,1 @@\n-  uintptr_t bit = all;               \/\/ Set to hold the one bit allowed\n+\n@@ -156,5 +176,5 @@\n-    if (_RM_UP[i]) {               \/\/ Found some bits\n-      if (bit != all) return false; \/\/ Already had bits, so fail\n-      bit = uintptr_t(1) << find_lowest_bit(_RM_UP[i]); \/\/ Extract lowest bit from mask\n-      if ((bit << 1U) != 0) {      \/\/ Bit pair stays in same word?\n-        if ((bit | (bit << 1U)) != _RM_UP[i])\n+    if (_RM_UP[i] != 0) {               \/\/ Found some bits\n+      unsigned int bit_index = find_lowest_bit(_RM_UP[i]);\n+      if (bit_index != _WordBitMask) {   \/\/ Bit pair stays in same word?\n+        uintptr_t bit = uintptr_t(1) << bit_index; \/\/ Extract lowest bit from mask\n+        if ((bit | (bit << 1U)) != _RM_UP[i]) {\n@@ -162,0 +182,1 @@\n+        }\n@@ -163,1 +184,1 @@\n-        if (bit != _RM_UP[i]) return false; \/\/ Found many bits, so fail\n+        assert(is_power_of_2(_RM_UP[i]), \"invariant\");\n@@ -165,1 +186,1 @@\n-        if (i > _hwm || _RM_UP[i] != 1)\n+        if (i > _hwm || _RM_UP[i] != 1) {\n@@ -167,0 +188,8 @@\n+        }\n+      }\n+\n+      \/\/ A matching pair was found - check there are no bits in the rest of the mask\n+      for (i++; i <= _hwm; i++) {\n+        if (_RM_UP[i] != 0) {\n+          return false;\n+        }\n@@ -168,0 +197,2 @@\n+      \/\/ Found a bit pair\n+      return true;\n@@ -170,1 +201,1 @@\n-  \/\/ True for both the empty mask and for a bit pair\n+  \/\/ True for the empty mask, too\n@@ -184,0 +215,1 @@\n+\n@@ -306,1 +338,0 @@\n-  uintptr_t bit = all;         \/\/ Set to hold the one bit allowed\n@@ -308,3 +339,1 @@\n-    if (_RM_UP[i] ) {           \/\/ Found some bits\n-      if (bit != all)\n-        return false;           \/\/ Already had bits, so fail\n+    if (_RM_UP[i] != 0) {       \/\/ Found some bits\n@@ -312,3 +341,3 @@\n-      bit = uintptr_t(1) << bit_index;\n-      uintptr_t hi_bit = bit << (size - 1); \/\/ high bit\n-      if (hi_bit != 0) {        \/\/ Bit set stays in same word?\n+      uintptr_t bit = uintptr_t(1) << bit_index;\n+      if (bit_index + size <= BitsPerWord) { \/\/ Bit set stays in same word?\n+        uintptr_t hi_bit = bit << (size - 1);\n@@ -316,1 +345,1 @@\n-        if (set != _RM_UP[i])\n+        if (set != _RM_UP[i]) {\n@@ -318,0 +347,1 @@\n+        }\n@@ -319,2 +349,4 @@\n-        if ((all & ~(bit-1)) != _RM_UP[i])\n-          return false;         \/\/ Found many bits, so fail\n+        \/\/ All bits from bit to highest bit in the word must be set\n+        if ((all & ~(bit-1)) != _RM_UP[i]) {\n+          return false;\n+        }\n@@ -324,1 +356,1 @@\n-        if (i > _hwm || _RM_UP[i] != set)\n+        if (i > _hwm || _RM_UP[i] != set) {\n@@ -326,0 +358,8 @@\n+        }\n+      }\n+\n+      \/\/ A matching set found - check there are no bits in the rest of the mask\n+      for (i++; i <= _hwm; i++) {\n+        if (_RM_UP[i] != 0) {\n+          return false;\n+        }\n@@ -327,0 +367,2 @@\n+      \/\/ Done - found a bit set\n+      return true;\n@@ -329,1 +371,1 @@\n-  \/\/ True for both the empty mask and for a bit set\n+  \/\/ True for the empty mask, too\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":64,"deletions":22,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1314,1 +1314,2 @@\n-                                ch, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) \/* mismatched *\/);\n+                                ch, bt, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n+                                false \/* unaligned *\/, (bt != T_BYTE) \/* mismatched *\/);\n@@ -1352,1 +1353,2 @@\n-                            sign, bt, byte_adr_idx, MemNode::unordered, (bt != T_BYTE) \/* mismatched *\/);\n+                            sign, bt, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n+                            false \/* unaligned *\/, (bt != T_BYTE) \/* mismatched *\/);\n@@ -1545,1 +1547,2 @@\n-      __ store(__ ctrl(), adr, __ ConI(val), T_CHAR, byte_adr_idx, MemNode::unordered, true \/* mismatched *\/);\n+      __ store(__ ctrl(), adr, __ ConI(val), T_CHAR, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n+               true \/* mismatched *\/);\n@@ -1632,1 +1635,2 @@\n-    __ store(__ ctrl(), adr, val, T_CHAR, byte_adr_idx, MemNode::unordered, true \/* mismatched *\/);\n+    __ store(__ ctrl(), adr, val, T_CHAR, byte_adr_idx, MemNode::unordered, false \/* require_atomic_access *\/,\n+             true \/* mismatched *\/);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -118,0 +118,12 @@\n+SubNode* SubNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new SubINode(in1, in2);\n+    case T_LONG:\n+      return new SubLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+\n+  static SubNode* make(Node* in1, Node* in2, BasicType bt);\n@@ -151,0 +153,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return false;\n+  }\n@@ -161,0 +167,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT && signed_int;\n+  }\n@@ -172,0 +182,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_INT && !signed_int;\n+  }\n@@ -202,0 +216,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG && signed_int;\n+  }\n@@ -211,0 +229,4 @@\n+  virtual bool operates_on(BasicType bt, bool signed_int) const {\n+    assert(bt == T_INT || bt == T_LONG, \"unsupported\");\n+    return bt == T_LONG && !signed_int;\n+  }\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  if (!cl->is_valid_counted_loop()) return; \/\/ skip malformed counted loop\n+  if (!cl->is_valid_counted_loop(T_INT)) return; \/\/ skip malformed counted loop\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-void Type::check_symmetrical(const Type *t, const Type *mt) const {\n+void Type::check_symmetrical(const Type* t, const Type* mt) const {\n@@ -819,1 +819,9 @@\n-  assert(mt == t->xmeet(this), \"meet not commutative\");\n+  const Type* mt2 = t->xmeet(this);\n+  if (mt != mt2) {\n+    tty->print_cr(\"=== Meet Not Commutative ===\");\n+    tty->print(\"t           = \");   t->dump(); tty->cr();\n+    tty->print(\"this        = \");      dump(); tty->cr();\n+    tty->print(\"t meet this = \"); mt2->dump(); tty->cr();\n+    tty->print(\"this meet t = \");  mt->dump(); tty->cr();\n+    fatal(\"meet not commutative\");\n+  }\n@@ -821,2 +829,2 @@\n-  const Type *t2t    = dual_join->xmeet(t->_dual);\n-  const Type *t2this = dual_join->xmeet(this->_dual);\n+  const Type* t2t    = dual_join->xmeet(t->_dual);\n+  const Type* t2this = dual_join->xmeet(this->_dual);\n@@ -828,1 +836,1 @@\n-  if( !interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual) ) {\n+  if (!interface_vs_oop(t) && (t2t != t->_dual || t2this != this->_dual)) {\n@@ -841,1 +849,1 @@\n-    fatal(\"meet not symmetric\" );\n+    fatal(\"meet not symmetric\");\n@@ -1349,0 +1357,16 @@\n+jlong TypeInteger::get_con_as_long(BasicType bt) const {\n+  if (bt == T_INT) {\n+    return is_int()->get_con();\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return is_long()->get_con();\n+}\n+\n+const TypeInteger* TypeInteger::bottom(BasicType bt) {\n+  if (bt == T_INT) {\n+    return TypeInt::INT;\n+  }\n+  assert(bt == T_LONG, \"basic type not an int or long\");\n+  return TypeLong::LONG;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -287,1 +287,0 @@\n-  const TypeInteger* isa_integer() const;\n@@ -542,0 +541,2 @@\n+\n+  static const TypeInteger* bottom(BasicType type);\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/prims\/foreign_globals.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -310,0 +310,1 @@\n+  static void set_enabled_events_with_lock(JvmtiEnvBase *env, jlong now_enabled);\n@@ -412,0 +413,13 @@\n+void\n+JvmtiEventControllerPrivate::set_enabled_events_with_lock(JvmtiEnvBase* env, jlong now_enabled) {\n+  \/\/ The state for ObjectFree events must be enabled or disabled\n+  \/\/ under the TagMap lock, to allow pending object posting events to complete.\n+  JvmtiTagMap* tag_map = env->tag_map_acquire();\n+  if (tag_map != NULL) {\n+    MutexLocker ml(tag_map->lock(), Mutex::_no_safepoint_check_flag);\n+    env->env_event_enable()->_event_enabled.set_bits(now_enabled);\n+  } else {\n+    env->env_event_enable()->_event_enabled.set_bits(now_enabled);\n+  }\n+}\n+\n@@ -445,2 +459,2 @@\n-  \/\/ will we really send these events to this env\n-  env->env_event_enable()->_event_enabled.set_bits(now_enabled);\n+  \/\/ Set\/reset the event enabled under the tagmap lock.\n+  set_enabled_events_with_lock(env, now_enabled);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1161,0 +1161,2 @@\n+    \/\/ Recheck whether to post object free events under the lock.\n+    post_object_free = post_object_free && env()->is_enabled(JVMTI_EVENT_OBJECT_FREE);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,0 @@\n-  inline Mutex* lock()                      { return &_lock; }\n@@ -63,0 +62,1 @@\n+  inline Mutex* lock()                      { return &_lock; }\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -422,1 +422,1 @@\n-  assert(is_signature_polymorphic_intrinsic(iid), \"%d %s\", iid, vmIntrinsics::name_at(iid));\n+  assert(is_signature_polymorphic_intrinsic(iid), \"%d %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n@@ -431,1 +431,1 @@\n-    fatal(\"unexpected intrinsic id: %d %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic id: %d %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n@@ -458,1 +458,1 @@\n-    fatal(\"unexpected intrinsic id: %d %s\", iid, vmIntrinsics::name_at(iid));\n+    fatal(\"unexpected intrinsic id: %d %s\", vmIntrinsics::as_int(iid), vmIntrinsics::name_at(iid));\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1817,1 +1817,4 @@\n-  return CompilerOracle::has_option_value(mh, option, *value, true \/* verify type*\/);\n+  if (!CompilerOracle::option_matches_type(option, *value)) {\n+    return false;\n+  }\n+  return CompilerOracle::has_option_value(mh, option, *value);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/monitorDeflationThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  assert(_owner != self, \"invariant\");\n+  assert(owner() != self, \"invariant\");\n@@ -128,1 +128,1 @@\n-  assert(_owner != self, \"invariant\");\n+  assert(owner() != self, \"invariant\");\n@@ -148,1 +148,1 @@\n-  if (_owner == self) {\n+  if (owner() == self) {\n@@ -311,1 +311,1 @@\n-  return _owner == Thread::current();\n+  return owner() == Thread::current();\n@@ -317,1 +317,1 @@\n-  st->print(\" - owner thread: \" PTR_FORMAT, p2i(_owner));\n+  st->print(\" - owner thread: \" PTR_FORMAT, p2i(owner()));\n@@ -335,1 +335,1 @@\n-            p2i(this), _name, p2i(_owner));\n+            p2i(this), _name, p2i(owner()));\n@@ -353,1 +353,1 @@\n-  assert(_owner == expected,\n+  assert(owner() == expected,\n@@ -355,1 +355,1 @@\n-         msg, p2i(_owner), p2i(expected));\n+         msg, p2i(owner()), p2i(expected));\n@@ -472,2 +472,2 @@\n-    assert(_owner == NULL, \"setting the owner thread of an already owned mutex\");\n-    _owner = new_owner; \/\/ set the owner\n+    assert(owner() == NULL, \"setting the owner thread of an already owned mutex\");\n+    raw_set_owner(new_owner); \/\/ set the owner\n@@ -485,1 +485,1 @@\n-    Thread* old_owner = _owner;\n+    Thread* old_owner = owner();\n@@ -492,1 +492,1 @@\n-    _owner = NULL; \/\/ set the owner\n+    raw_set_owner(NULL); \/\/ set the owner\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -84,0 +85,7 @@\n+ private:\n+  \/\/ The _owner field is only set by the current thread, either to itself after it has acquired\n+  \/\/ the low-level _lock, or to NULL before it has released the _lock. Accesses by any thread other\n+  \/\/ than the lock owner are inherently racy.\n+  Thread* volatile _owner;\n+  void raw_set_owner(Thread* new_owner) { Atomic::store(&_owner, new_owner); }\n+\n@@ -85,1 +93,0 @@\n-  Thread * volatile _owner;              \/\/ The owner of the lock\n@@ -114,1 +121,1 @@\n-  void set_owner_implementation(Thread* owner)                        NOT_DEBUG({ _owner = owner;});\n+  void set_owner_implementation(Thread* owner)                        NOT_DEBUG({ raw_set_owner(owner);});\n@@ -183,1 +190,1 @@\n-  bool is_locked() const                     { return _owner != NULL; }\n+  bool is_locked() const                     { return owner() != NULL; }\n@@ -200,1 +207,1 @@\n-  \/\/ Current owner - not not MT-safe. Can only be used to guarantee that\n+  \/\/ Current owner - note not MT-safe. Can only be used to guarantee that\n@@ -202,1 +209,1 @@\n-  Thread* owner() const         { return _owner; }\n+  Thread* owner() const         { return Atomic::load(&_owner); }\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/signature.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -721,0 +721,16 @@\n+inline jlong max_signed_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return max_jint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return max_jlong;\n+}\n+\n+inline jlong min_signed_integer(BasicType bt) {\n+  if (bt == T_INT) {\n+    return min_jint;\n+  }\n+  assert(bt == T_LONG, \"unsupported\");\n+  return min_jlong;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+enum class vmIntrinsicID : int;\n","filename":"src\/hotspot\/share\/utilities\/vmEnums.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -580,7 +580,9 @@\n-     * invokes {@link #skip(long) skip()} with parameter {@code n}.  If the\n-     * return value of {@code skip(n)} is non-negative and less than {@code n},\n-     * then {@link #read()} is invoked repeatedly until the stream is {@code n}\n-     * bytes beyond its position when this method was invoked or end of stream\n-     * is reached.  If the return value of {@code skip(n)} is negative or\n-     * greater than {@code n}, then an {@code IOException} is thrown.  Any\n-     * exception thrown by {@code skip()} or {@code read()} will be propagated.\n+     * invokes {@link #skip(long) skip()} repeatedly with its parameter equal\n+     * to the remaining number of bytes to skip until the requested number\n+     * of bytes has been skipped or an error condition occurs.  If at any\n+     * point the return value of {@code skip()} is negative or greater than the\n+     * remaining number of bytes to be skipped, then an {@code IOException} is\n+     * thrown.  If {@code skip()} ever returns zero, then {@link #read()} is\n+     * invoked to read a single byte, and if it returns {@code -1}, then an\n+     * {@code EOFException} is thrown.  Any exception thrown by {@code skip()}\n+     * or {@code read()} will be propagated.\n@@ -599,1 +601,1 @@\n-        if (n > 0) {\n+        while (n > 0) {\n@@ -601,1 +603,1 @@\n-            if (ns >= 0 && ns < n) { \/\/ skipped too few bytes\n+            if (ns > 0 && ns <= n) {\n@@ -604,6 +606,3 @@\n-                \/\/ read until requested number skipped or EOS reached\n-                while (n > 0 && read() != -1) {\n-                    n--;\n-                }\n-                \/\/ if not enough skipped, then EOFE\n-                if (n != 0) {\n+            } else if (ns == 0) { \/\/ no bytes skipped\n+                \/\/ read one byte to check for EOS\n+                if (read() == -1) {\n@@ -612,1 +611,3 @@\n-            } else if (ns != n) { \/\/ skipped negative or too many bytes\n+                \/\/ one byte read so decrement number to skip\n+                n--;\n+            } else { \/\/ skipped negative or too many bytes\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStream.java","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1720,1 +1720,1 @@\n-        str.getBytes(value, off, index, coder, end);\n+        str.getBytes(value, off, index, coder, end - off);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2224,0 +2224,3 @@\n+            public void addExports(Module m, String pn) {\n+                m.implAddExports(pn);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -563,1 +563,1 @@\n-                ResolvedModule m2 = null;\n+                ResolvedModule m2;\n@@ -575,0 +575,8 @@\n+\n+                    \/\/ m2 is automatic module in parent configuration => m1 reads\n+                    \/\/ all automatic modules that m2 reads.\n+                    if (m2.descriptor().isAutomatic()) {\n+                        m2.reads().stream()\n+                                .filter(d -> d.descriptor().isAutomatic())\n+                                .forEach(reads::add);\n+                    }\n@@ -841,1 +849,0 @@\n-\n@@ -843,1 +850,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/Resolver.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,6 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Objects;\n+\n@@ -95,0 +101,193 @@\n+\n+    \/**\n+     * Invokes the specified default method on the given {@code proxy} instance with\n+     * the given parameters.  The given {@code method} must be a default method\n+     * declared in a proxy interface of the {@code proxy}'s class or inherited\n+     * from its superinterface directly or indirectly.\n+     * <p>\n+     * Invoking this method behaves as if {@code invokespecial} instruction executed\n+     * from the proxy class, targeting the default method in a proxy interface.\n+     * This is equivalent to the invocation:\n+     * {@code X.super.m(A* a)} where {@code X} is a proxy interface and the call to\n+     * {@code X.super::m(A*)} is resolved to the given {@code method}.\n+     * <p>\n+     * Examples: interface {@code A} and {@code B} both declare a default\n+     * implementation of method {@code m}. Interface {@code C} extends {@code A}\n+     * and inherits the default method {@code m} from its superinterface {@code A}.\n+     *\n+     * <blockquote><pre>{@code\n+     * interface A {\n+     *     default T m(A a) { return t1; }\n+     * }\n+     * interface B {\n+     *     default T m(A a) { return t2; }\n+     * }\n+     * interface C extends A {}\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The following creates a proxy instance that implements {@code A}\n+     * and invokes the default method {@code A::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class },\n+     *         (o, m, params) -> {\n+     *             if (m.isDefault()) {\n+     *                 \/\/ if it's a default method, invoke it\n+     *                 return InvocationHandler.invokeDefault(o, m, params);\n+     *             }\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * If a proxy instance implements both {@code A} and {@code B}, both\n+     * of which provides the default implementation of method {@code m},\n+     * the invocation handler can dispatch the method invocation to\n+     * {@code A::m} or {@code B::m} via the {@code invokeDefault} method.\n+     * For example, the following code delegates the method invocation\n+     * to {@code B::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { A.class, B.class },\n+     *         (o, m, params) -> {\n+     *             if (m.getName().equals(\"m\")) {\n+     *                 \/\/ invoke B::m instead of A::m\n+     *                 Method bMethod = B.class.getMethod(m.getName(), m.getParameterTypes());\n+     *                 return InvocationHandler.invokeDefault(o, bMethod, params);\n+     *             }\n+     *         });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * If a proxy instance implements {@code C} that inherits the default\n+     * method {@code m} from its superinterface {@code A}, then\n+     * the interface method invocation on {@code \"m\"} is dispatched to\n+     * the invocation handler's {@link #invoke(Object, Method, Object[]) invoke}\n+     * method with the {@code Method} object argument representing the\n+     * default method {@code A::m}.\n+     *\n+     * <blockquote><pre>{@code\n+     * Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     *        (o, m, params) -> {\n+     *             if (m.isDefault()) {\n+     *                 \/\/ behaves as if calling C.super.m(params)\n+     *                 return InvocationHandler.invokeDefault(o, m, params);\n+     *             }\n+     *        });\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The invocation of method {@code \"m\"} on this {@code proxy} will behave\n+     * as if {@code C.super::m} is called and that is resolved to invoking\n+     * {@code A::m}.\n+     * <p>\n+     * Adding a default method, or changing a method from abstract to default\n+     * may cause an exception if an existing code attempts to call {@code invokeDefault}\n+     * to invoke a default method.\n+     *\n+     * For example, if {@code C} is modified to implement a default method\n+     * {@code m}:\n+     *\n+     * <blockquote><pre>{@code\n+     * interface C extends A {\n+     *     default T m(A a) { return t3; }\n+     * }\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The code above that creates proxy instance {@code proxy} with\n+     * the modified {@code C} will run with no exception and it will result in\n+     * calling {@code C::m} instead of {@code A::m}.\n+     * <p>\n+     * The following is another example that creates a proxy instance of {@code C}\n+     * and the invocation handler calls the {@code invokeDefault} method\n+     * to invoke {@code A::m}:\n+     *\n+     * <blockquote><pre>{@code\n+     * C c = (C) Proxy.newProxyInstance(loader, new Class<?>[] { C.class },\n+     *         (o, m, params) -> {\n+     *             if (m.getName().equals(\"m\")) {\n+     *                 \/\/ IllegalArgumentException thrown as {@code A::m} is not a method\n+     *                 \/\/ inherited from its proxy interface C\n+     *                 Method aMethod = A.class.getMethod(m.getName(), m.getParameterTypes());\n+     *                 return InvocationHandler.invokeDefault(o, aMethod params);\n+     *             }\n+     *         });\n+     * c.m(...);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * The above code runs successfully with the old version of {@code C} and\n+     * {@code A::m} is invoked.  When running with the new version of {@code C},\n+     * the above code will fail with {@code IllegalArgumentException} because\n+     * {@code C} overrides the implementation of the same method and\n+     * {@code A::m} is not accessible by a proxy instance.\n+     *\n+     * @apiNote\n+     * The {@code proxy} parameter is of type {@code Object} rather than {@code Proxy}\n+     * to make it easy for {@link InvocationHandler#invoke(Object, Method, Object[])\n+     * InvocationHandler::invoke} implementation to call directly without the need\n+     * of casting.\n+     *\n+     * @param proxy   the {@code Proxy} instance on which the default method to be invoked\n+     * @param method  the {@code Method} instance corresponding to a default method\n+     *                declared in a proxy interface of the proxy class or inherited\n+     *                from its superinterface directly or indirectly\n+     * @param args    the parameters used for the method invocation; can be {@code null}\n+     *                if the number of formal parameters required by the method is zero.\n+     * @return the value returned from the method invocation\n+     *\n+     * @throws IllegalArgumentException if any of the following conditions is {@code true}:\n+     *         <ul>\n+     *         <li>{@code proxy} is not {@linkplain Proxy#isProxyClass(Class)\n+     *             a proxy instance}; or<\/li>\n+     *         <li>the given {@code method} is not a default method declared\n+     *             in a proxy interface of the proxy class and not inherited from\n+     *             any of its superinterfaces; or<\/li>\n+     *         <li>the given {@code method} is overridden directly or indirectly by\n+     *             the proxy interfaces and the method reference to the named\n+     *             method never resolves to the given {@code method}; or<\/li>\n+     *         <li>the length of the given {@code args} array does not match the\n+     *             number of parameters of the method to be invoked; or<\/li>\n+     *         <li>any of the {@code args} elements fails the unboxing\n+     *             conversion if the corresponding method parameter type is\n+     *             a primitive type; or if, after possible unboxing, any of the\n+     *             {@code args} elements cannot be assigned to the corresponding\n+     *             method parameter type.<\/li>\n+     *         <\/ul>\n+     * @throws IllegalAccessException if the declaring class of the specified\n+     *         default method is inaccessible to the caller class\n+     * @throws NullPointerException if {@code proxy} or {@code method} is {@code null}\n+     * @throws Throwable anything thrown by the default method\n+\n+     * @since 16\n+     * @jvms 5.4.3. Method Resolution\n+     *\/\n+    @CallerSensitive\n+    public static Object invokeDefault(Object proxy, Method method, Object... args)\n+            throws Throwable {\n+        Objects.requireNonNull(proxy);\n+        Objects.requireNonNull(method);\n+\n+        \/\/ verify that the object is actually a proxy instance\n+        if (!Proxy.isProxyClass(proxy.getClass())) {\n+            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n+        }\n+        if (!method.isDefault()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Proxy> proxyClass = (Class<? extends Proxy>)proxy.getClass();\n+\n+        Class<?> intf = method.getDeclaringClass();\n+        \/\/ access check on the default method\n+        method.checkAccess(Reflection.getCallerClass(), intf, proxyClass, method.getModifiers());\n+\n+        MethodHandle mh = Proxy.defaultMethodHandle(proxyClass, method);\n+        \/\/ invoke the super method\n+        try {\n+            \/\/ the args array can be null if the number of formal parameters required by\n+            \/\/ the method is zero (consistent with Method::invoke)\n+            Object[] params = args != null ? args : Proxy.EMPTY_ARGS;\n+            return mh.invokeExact(proxy, params);\n+        } catch (ClassCastException | NullPointerException e) {\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        } catch (Proxy.InvocationException e) {\n+            \/\/ unwrap and throw the exception thrown by the default method\n+            throw e.getCause();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":200,"deletions":1,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -69,0 +70,1 @@\n+    @Stable\n@@ -77,0 +79,1 @@\n+    @Stable\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.WrongMethodTypeException;\n@@ -31,0 +35,1 @@\n+import java.util.ArrayDeque;\n@@ -33,0 +38,1 @@\n+import java.util.Deque;\n@@ -40,0 +46,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -42,0 +49,1 @@\n+import java.util.function.BooleanSupplier;\n@@ -45,1 +53,0 @@\n-import jdk.internal.loader.BootLoader;\n@@ -51,0 +58,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -52,1 +60,0 @@\n-import sun.security.action.GetBooleanAction;\n@@ -56,0 +63,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -58,1 +66,0 @@\n-\n@@ -147,0 +154,6 @@\n+ * <li>A proxy interface may define a default method or inherit\n+ * a default method from its superinterface directly or indirectly.\n+ * An invocation handler can invoke a default method of a proxy interface\n+ * by calling {@link InvocationHandler#invokeDefault(Object, Method, Object...)\n+ * InvocationHandler::invokeDefault}.\n+ *\n@@ -175,3 +188,2 @@\n- *     <em>public<\/em> in a package exported by the\n- *     {@linkplain ClassLoader#getUnnamedModule() unnamed module} of the specified\n- *     loader. The name of the package is unspecified.<\/li>\n+ *     <em>public<\/em> in an unconditionally exported but non-open package.\n+ *     The name of the package and the module are unspecified.<\/li>\n@@ -486,0 +498,1 @@\n+            boolean nonExported = false;\n@@ -503,0 +516,5 @@\n+                } else {\n+                    if (!intf.getModule().isExported(intf.getPackageName())) {\n+                        \/\/ module-private types\n+                        nonExported = true;\n+                    }\n@@ -507,3 +525,5 @@\n-                \/\/ all proxy interfaces are public\n-                proxyPkg = m.isNamed() ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n-                                       : PROXY_PACKAGE_PREFIX;\n+                \/\/ all proxy interfaces are public and exported\n+                if (!m.isNamed())\n+                    throw new InternalError(\"ununamed module: \" + m);\n+                proxyPkg = nonExported ? PROXY_PACKAGE_PREFIX + \".\" + m.getName()\n+                                       : m.getName();\n@@ -647,0 +667,2 @@\n+            assert !module.isNamed() || module.isOpen(proxyClass.getPackageName(), Proxy.class.getModule());\n+\n@@ -743,3 +765,0 @@\n-         * If all proxy interfaces are public and in exported packages,\n-         * then the proxy class is in unnamed module.\n-         *\n@@ -749,0 +768,4 @@\n+         * If all proxy interfaces are public and in exported packages,\n+         * then the proxy class is in a dynamic module in an unconditionally\n+         * exported package.\n+         *\n@@ -751,2 +774,5 @@\n-         * non-exported package.  Reads edge and qualified exports are added\n-         * for dynamic module to access.\n+         * non-exported package.\n+         *\n+         * The package of proxy class is open to java.base for deep reflective access.\n+         *\n+         * Reads edge and qualified exports are added for dynamic module to access.\n@@ -757,1 +783,0 @@\n-            Map<Class<?>, Module> modulePrivateTypes = new HashMap<>();\n@@ -761,6 +786,1 @@\n-                if (Modifier.isPublic(intf.getModifiers())) {\n-                    \/\/ module-private types\n-                    if (!m.isExported(intf.getPackageName())) {\n-                        modulePrivateTypes.put(intf, m);\n-                    }\n-                } else {\n+                if (!Modifier.isPublic(intf.getModifiers())) {\n@@ -771,8 +791,0 @@\n-            \/\/ all proxy interfaces are public and exported, the proxy class\n-            \/\/ is in unnamed module.  Such proxy class is accessible to\n-            \/\/ any unnamed module and named module that can read unnamed module\n-            if (packagePrivateTypes.isEmpty() && modulePrivateTypes.isEmpty()) {\n-                return loader != null ? loader.getUnnamedModule()\n-                                      : BootLoader.getUnnamedModule();\n-            }\n-\n@@ -785,12 +797,10 @@\n-                if (packagePrivateTypes.size() > 1 &&\n-                        (packagePrivateTypes.keySet().stream()  \/\/ more than one package\n-                                 .map(Class::getPackageName).distinct().count() > 1 ||\n-                         packagePrivateTypes.values().stream()  \/\/ or more than one module\n-                                 .distinct().count() > 1)) {\n-                    throw new IllegalArgumentException(\n-                            \"non-public interfaces from different packages\");\n-                }\n-\n-                \/\/ all package-private types are in the same module (named or unnamed)\n-                Module target = null;\n-                for (Module m : packagePrivateTypes.values()) {\n+                Module targetModule = null;\n+                String targetPackageName = null;\n+                for (Map.Entry<Class<?>, Module> e : packagePrivateTypes.entrySet()) {\n+                    Class<?> intf = e.getKey();\n+                    Module m = e.getValue();\n+                    if ((targetModule != null && targetModule != m) ||\n+                        (targetPackageName != null && targetPackageName != intf.getPackageName())) {\n+                        throw new IllegalArgumentException(\n+                                \"cannot have non-public interfaces in different packages\");\n+                    }\n@@ -803,1 +813,3 @@\n-                    target = m;\n+\n+                    targetModule = m;\n+                    targetPackageName = e.getKey().getPackageName();\n@@ -809,1 +821,1 @@\n-                    if (m == target) continue;\n+                    if (m == targetModule) continue;\n@@ -811,2 +823,2 @@\n-                    if (!target.canRead(m) || !m.isExported(intf.getPackageName(), target)) {\n-                        throw new IllegalArgumentException(target + \" can't access \" + intf.getName());\n+                    if (!targetModule.canRead(m) || !m.isExported(intf.getPackageName(), targetModule)) {\n+                        throw new IllegalArgumentException(targetModule + \" can't access \" + intf.getName());\n@@ -816,0 +828,4 @@\n+                \/\/ opens the package of the non-public proxy class for java.base to access\n+                if (targetModule.isNamed()) {\n+                    Modules.addOpens(targetModule, targetPackageName, Proxy.class.getModule());\n+                }\n@@ -817,1 +833,1 @@\n-                return target;\n+                return targetModule;\n@@ -820,4 +836,3 @@\n-            \/\/ All proxy interfaces are public and at least one in a non-exported\n-            \/\/ package.  So maps to a dynamic proxy module and add reads edge\n-            \/\/ and qualified exports, if necessary\n-            Module target = getDynamicModule(loader);\n+            \/\/ All proxy interfaces are public.  So maps to a dynamic proxy module\n+            \/\/ and add reads edge and qualified exports, if necessary\n+            Module targetModule = getDynamicModule(loader);\n@@ -830,1 +845,1 @@\n-                ensureAccess(target, c);\n+                ensureAccess(targetModule, c);\n@@ -832,1 +847,1 @@\n-            return target;\n+            return targetModule;\n@@ -878,2 +893,3 @@\n-         * Define a dynamic module for the generated proxy classes in\n-         * a non-exported package named com.sun.proxy.$MODULE.\n+         * Define a dynamic module with a packge named $MODULE which\n+         * is unconditionally exported and another package named\n+         * com.sun.proxy.$MODULE which is encapsulated.\n@@ -889,3 +905,4 @@\n-                    ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n-                                    .packages(Set.of(pn))\n-                                    .build();\n+                        ModuleDescriptor.newModule(mn, Set.of(SYNTHETIC))\n+                                        .packages(Set.of(pn, mn))\n+                                        .exports(mn)\n+                                        .build();\n@@ -894,2 +911,4 @@\n-                \/\/ java.base to create proxy instance\n-                Modules.addExports(m, pn, Object.class.getModule());\n+                Modules.addExports(m, mn);\n+                \/\/ java.base to create proxy instance and access its Lookup instance\n+                Modules.addOpens(m, pn, Proxy.class.getModule());\n+                Modules.addOpens(m, mn, Proxy.class.getModule());\n@@ -1123,0 +1142,201 @@\n+\n+    \/**\n+     * A cache of Method -> MethodHandle for default methods.\n+     *\/\n+    private static final ClassValue<ConcurrentHashMap<Method, MethodHandle>>\n+            DEFAULT_METHODS_MAP = new ClassValue<>() {\n+        @Override\n+        protected ConcurrentHashMap<Method, MethodHandle> computeValue(Class<?> type) {\n+            return new ConcurrentHashMap<>(4);\n+        }\n+    };\n+\n+    private static ConcurrentHashMap<Method, MethodHandle> defaultMethodMap(Class<?> proxyClass) {\n+        assert isProxyClass(proxyClass);\n+        return DEFAULT_METHODS_MAP.get(proxyClass);\n+    }\n+\n+    static final Object[] EMPTY_ARGS = new Object[0];\n+\n+    static MethodHandle defaultMethodHandle(Class<? extends Proxy> proxyClass, Method method) {\n+        \/\/ lookup the cached method handle\n+        ConcurrentHashMap<Method, MethodHandle> methods = defaultMethodMap(proxyClass);\n+        MethodHandle superMH = methods.get(method);\n+        if (superMH == null) {\n+            MethodType type = methodType(method.getReturnType(), method.getParameterTypes());\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            Class<?> proxyInterface = findProxyInterfaceOrElseThrow(proxyClass, method);\n+            MethodHandle dmh;\n+            try {\n+                dmh = proxyClassLookup(lookup, proxyClass)\n+                        .findSpecial(proxyInterface, method.getName(), type, proxyClass)\n+                        .withVarargs(false);\n+            } catch (IllegalAccessException | NoSuchMethodException e) {\n+                \/\/ should not reach here\n+                throw new InternalError(e);\n+            }\n+            \/\/ this check can be turned into assertion as it is guaranteed to succeed by the virtue of\n+            \/\/ looking up a default (instance) method declared or inherited by proxyInterface\n+            \/\/ while proxyClass implements (is a subtype of) proxyInterface ...\n+            assert ((BooleanSupplier) () -> {\n+                try {\n+                    \/\/ make sure that the method type matches\n+                    dmh.asType(type.insertParameterTypes(0, proxyClass));\n+                    return true;\n+                } catch (WrongMethodTypeException e) {\n+                    return false;\n+                }\n+            }).getAsBoolean() : \"Wrong method type\";\n+            \/\/ change return type to Object\n+            MethodHandle mh = dmh.asType(dmh.type().changeReturnType(Object.class));\n+            \/\/ wrap any exception thrown with InvocationTargetException\n+            mh = MethodHandles.catchException(mh, Throwable.class, InvocationException.wrapMH());\n+            \/\/ spread array of arguments among parameters (skipping 1st parameter - target)\n+            mh = mh.asSpreader(1, Object[].class, type.parameterCount());\n+            \/\/ change target type to Object\n+            mh = mh.asType(MethodType.methodType(Object.class, Object.class, Object[].class));\n+\n+            \/\/ push MH into cache\n+            MethodHandle cached = methods.putIfAbsent(method, mh);\n+            if (cached != null) {\n+                superMH = cached;\n+            } else {\n+                superMH = mh;\n+            }\n+        }\n+        return superMH;\n+    }\n+\n+    \/**\n+     * Finds the first proxy interface that declares the given method\n+     * directly or indirectly.\n+     *\n+     * @throws IllegalArgumentException if not found\n+     *\/\n+    private static Class<?> findProxyInterfaceOrElseThrow(Class<?> proxyClass, Method method) {\n+        Class<?> declaringClass = method.getDeclaringClass();\n+        if (!declaringClass.isInterface()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method +\n+                    \"\\\" is not a method declared in the proxy class\");\n+        }\n+\n+        List<Class<?>> proxyInterfaces = Arrays.asList(proxyClass.getInterfaces());\n+        \/\/ the method's declaring class is a proxy interface\n+        if (proxyInterfaces.contains(declaringClass))\n+            return declaringClass;\n+\n+        \/\/ find the first proxy interface that inherits the default method\n+        \/\/ i.e. the declaring class of the default method is a superinterface\n+        \/\/ of the proxy interface\n+        Deque<Class<?>> deque = new ArrayDeque<>();\n+        Set<Class<?>> visited = new HashSet<>();\n+        boolean indirectMethodRef = false;\n+        for (Class<?> proxyIntf : proxyInterfaces) {\n+            assert proxyIntf != declaringClass;\n+            visited.add(proxyIntf);\n+            deque.add(proxyIntf);\n+\n+            \/\/ for each proxy interface, traverse its subinterfaces with\n+            \/\/ breadth-first search to find a subinterface declaring the\n+            \/\/ default method\n+            Class<?> c;\n+            while ((c = deque.poll()) != null) {\n+                if (c == declaringClass) {\n+                    try {\n+                        \/\/ check if this method is the resolved method if referenced from\n+                        \/\/ this proxy interface (i.e. this method is not implemented\n+                        \/\/ by any other superinterface)\n+                        Method m = proxyIntf.getMethod(method.getName(), method.getParameterTypes());\n+                        if (m.getDeclaringClass() == declaringClass) {\n+                            return proxyIntf;\n+                        }\n+                        indirectMethodRef = true;\n+                    } catch (NoSuchMethodException e) {}\n+\n+                    \/\/ skip traversing its superinterfaces\n+                    \/\/ another proxy interface may extend it and so\n+                    \/\/ the method's declaring class is left unvisited.\n+                    continue;\n+                }\n+                \/\/ visit all superinteraces of one proxy interface to find if\n+                \/\/ this proxy interface inherits the method directly or indirectly\n+                visited.add(c);\n+                for (Class<?> superIntf : c.getInterfaces()) {\n+                    if (!visited.contains(superIntf) && !deque.contains(superIntf)) {\n+                        if (superIntf == declaringClass) {\n+                            \/\/ fast-path as the matching subinterface is found\n+                            deque.addFirst(superIntf);\n+                        } else {\n+                            deque.add(superIntf);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        throw new IllegalArgumentException(\"\\\"\" + method + (indirectMethodRef\n+                ? \"\\\" is overridden directly or indirectly by the proxy interfaces\"\n+                : \"\\\" is not a method declared in the proxy class\"));\n+    }\n+\n+    \/**\n+     * This method invokes the proxy's proxyClassLookup method to get a\n+     * Lookup on the proxy class.\n+     *\n+     * @return a lookup for proxy class of this proxy instance\n+     *\/\n+    private static MethodHandles.Lookup proxyClassLookup(MethodHandles.Lookup caller, Class<?> proxyClass) {\n+        return AccessController.doPrivileged(new PrivilegedAction<>() {\n+            @Override\n+            public MethodHandles.Lookup run() {\n+                try {\n+                    Method m = proxyClass.getDeclaredMethod(\"proxyClassLookup\", MethodHandles.Lookup.class);\n+                    m.setAccessible(true);\n+                    return (MethodHandles.Lookup) m.invoke(null, caller);\n+                } catch (ReflectiveOperationException e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Internal exception type to wrap the exception thrown by the default method\n+     * so that it can distinguish CCE and NPE thrown due to the arguments\n+     * incompatible with the method signature.\n+     *\/\n+    static class InvocationException extends ReflectiveOperationException {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 0L;\n+\n+        InvocationException(Throwable cause) {\n+            super(cause);\n+        }\n+\n+        \/**\n+         * Wraps given cause with InvocationException and throws it.\n+         *\/\n+        static Object wrap(Throwable cause) throws InvocationException {\n+            throw new InvocationException(cause);\n+        }\n+\n+        @Stable\n+        static MethodHandle wrapMethodHandle;\n+\n+        static MethodHandle wrapMH() {\n+            MethodHandle mh = wrapMethodHandle;\n+            if (mh == null) {\n+                try {\n+                    wrapMethodHandle = mh = MethodHandles.lookup().findStatic(\n+                            InvocationException.class,\n+                            \"wrap\",\n+                            MethodType.methodType(Object.class, Throwable.class)\n+                    );\n+                } catch (NoSuchMethodException | IllegalAccessException e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+            return mh;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":279,"deletions":59,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.org.objectweb.asm.Type;\n@@ -62,0 +63,2 @@\n+    private static final String JL_ILLEGAL_ACCESS_EX = \"java\/lang\/IllegalAccessException\";\n+\n@@ -65,0 +68,2 @@\n+    private static final String JLI_LOOKUP = \"java\/lang\/invoke\/MethodHandles$Lookup\";\n+    private static final String JLI_METHODHANDLES = \"java\/lang\/invoke\/MethodHandles\";\n@@ -78,0 +83,1 @@\n+    private static final String NAME_LOOKUP_ACCESSOR = \"proxyClassLookup\";\n@@ -487,1 +493,1 @@\n-                visitField(Modifier.PRIVATE | Modifier.STATIC, pm.methodFieldName,\n+                visitField(ACC_PRIVATE | ACC_STATIC | ACC_FINAL, pm.methodFieldName,\n@@ -496,1 +502,1 @@\n-\n+        generateLookupAccessor();\n@@ -628,0 +634,40 @@\n+    \/**\n+     * Generate the static lookup accessor method that returns the Lookup\n+     * on this proxy class if the caller's lookup class is java.lang.reflect.Proxy;\n+     * otherwise, IllegalAccessException is thrown\n+     *\/\n+    private void generateLookupAccessor() {\n+        MethodVisitor mv = visitMethod(ACC_PRIVATE | ACC_STATIC, NAME_LOOKUP_ACCESSOR,\n+                \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;)Ljava\/lang\/invoke\/MethodHandles$Lookup;\", null,\n+                new String[] { JL_ILLEGAL_ACCESS_EX });\n+        mv.visitCode();\n+        Label L_illegalAccess = new Label();\n+\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"lookupClass\",\n+                \"()Ljava\/lang\/Class;\", false);\n+        mv.visitLdcInsn(Type.getType(Proxy.class));\n+        mv.visitJumpInsn(IF_ACMPNE, L_illegalAccess);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"hasFullPrivilegeAccess\",\n+                \"()Z\", false);\n+        mv.visitJumpInsn(IFEQ, L_illegalAccess);\n+        mv.visitMethodInsn(INVOKESTATIC, JLI_METHODHANDLES, \"lookup\",\n+                \"()Ljava\/lang\/invoke\/MethodHandles$Lookup;\", false);\n+        mv.visitInsn(ARETURN);\n+\n+        mv.visitLabel(L_illegalAccess);\n+        mv.visitTypeInsn(Opcodes.NEW, JL_ILLEGAL_ACCESS_EX);\n+        mv.visitInsn(DUP);\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKEVIRTUAL, JLI_LOOKUP, \"toString\",\n+                \"()Ljava\/lang\/String;\", false);\n+        mv.visitMethodInsn(INVOKESPECIAL, JL_ILLEGAL_ACCESS_EX,\n+                \"<init>\", \"(Ljava\/lang\/String;)V\", false);\n+        mv.visitInsn(ATHROW);\n+\n+        \/\/ Maxs computed by ClassWriter.COMPUTE_FRAMES, these arguments ignored\n+        mv.visitMaxs(-1, -1);\n+        mv.visitEnd();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ProxyGenerator.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -212,0 +212,5 @@\n+    \/**\n+     * Updates module m1 to export a package unconditionally.\n+     *\/\n+    void addExports(Module m1, String pkg);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -108,0 +108,7 @@\n+    \/**\n+     * Updates module m to export a package unconditionally.\n+     *\/\n+    public static void addExports(Module m, String pn) {\n+        JLA.addExports(m, pn);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Modules.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -266,2 +266,1 @@\n-        String pkg = cls.getPackageName();\n-        return pkg == null || !pkg.startsWith(PROXY_PACKAGE);\n+        return !Modifier.isPublic(cls.getModifiers());\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/misc\/ReflectUtil.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,3 +40,0 @@\n-    \/\/ Keyboard layout\n-    NSString *kbdLayout;\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTView.h","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+\/\/ keyboard layout\n+static NSString *kbdLayout;\n@@ -1003,1 +1005,1 @@\n-- (void)keyboardInputSourceChanged:(NSNotification *)notification\n++ (void)keyboardInputSourceChanged:(NSNotification *)notification\n@@ -1300,1 +1302,1 @@\n-    fprintf(stderr, \"characterIndexForPoint returning %ld\\n\", index);\n+    fprintf(stderr, \"characterIndexForPoint returning %d\\n\", index);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/AWTView.m","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,0 @@\n-import java.awt.GraphicsDevice;\n-import java.awt.GraphicsEnvironment;\n-import java.awt.Color;\n@@ -32,1 +29,0 @@\n-import java.awt.Rectangle;\n@@ -34,0 +30,2 @@\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n@@ -35,1 +33,1 @@\n-import java.awt.color.ColorSpace;\n+import java.awt.Rectangle;\n@@ -37,1 +35,1 @@\n-import java.awt.image.BufferedImage;\n+import java.awt.color.ColorSpace;\n@@ -43,1 +41,0 @@\n-import java.awt.peer.ComponentPeer;\n@@ -49,1 +46,0 @@\n-import sun.awt.X11GraphicsEnvironment;\n@@ -57,1 +53,0 @@\n-import sun.java2d.loops.SurfaceType;\n@@ -59,1 +54,0 @@\n-import sun.java2d.loops.RenderLoops;\n@@ -61,0 +55,2 @@\n+import sun.java2d.loops.RenderLoops;\n+import sun.java2d.loops.SurfaceType;\n@@ -62,2 +58,0 @@\n-import sun.java2d.loops.Blit;\n-import sun.java2d.pipe.ValidatePipe;\n@@ -65,1 +59,0 @@\n-import sun.java2d.pipe.TextPipe;\n@@ -67,0 +60,2 @@\n+import sun.java2d.pipe.TextPipe;\n+import sun.java2d.pipe.ValidatePipe;\n@@ -414,1 +409,2 @@\n-                                                  int transparency)\n+                                                  int transparency,\n+                                                  boolean isTexture)\n@@ -418,1 +414,1 @@\n-                                        cm, drawable, transparency);\n+                                        cm, drawable, transparency, isTexture);\n@@ -702,1 +698,4 @@\n-    public static class X11WindowSurfaceData extends X11SurfaceData {\n+    private final static class X11WindowSurfaceData extends X11SurfaceData {\n+\n+        private final int scale;\n+\n@@ -707,0 +706,1 @@\n+            this.scale = gc.getDevice().getScaleFactor();\n@@ -719,0 +719,2 @@\n+            r.width *= scale;\n+            r.height *= scale;\n@@ -733,0 +735,10 @@\n+\n+        @Override\n+        public double getDefaultScaleX() {\n+            return scale;\n+        }\n+\n+        @Override\n+        public double getDefaultScaleY() {\n+            return scale;\n+        }\n@@ -735,1 +747,1 @@\n-    public static class X11PixmapSurfaceData extends X11SurfaceData {\n+    private final static class X11PixmapSurfaceData extends X11SurfaceData {\n@@ -737,4 +749,5 @@\n-        Image                   offscreenImage;\n-        int                     width;\n-        int                     height;\n-        int                     transparency;\n+        private final Image offscreenImage;\n+        private final int width;\n+        private final int height;\n+        private final int transparency;\n+        private final int scale;\n@@ -746,1 +759,2 @@\n-                                    long drawable, int transparency)\n+                                    long drawable, int transparency,\n+                                    boolean isTexture)\n@@ -749,2 +763,3 @@\n-            this.width = width;\n-            this.height = height;\n+            this.scale = isTexture ? 1 : gc.getDevice().getScaleFactor();\n+            this.width = width * scale;\n+            this.height = height * scale;\n@@ -753,1 +768,1 @@\n-            initSurface(depth, width, height, drawable);\n+            initSurface(depth, this.width, this.height, drawable);\n@@ -801,0 +816,10 @@\n+\n+        @Override\n+        public double getDefaultScaleX() {\n+            return scale;\n+        }\n+\n+        @Override\n+        public double getDefaultScaleY() {\n+            return scale;\n+        }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/x11\/X11SurfaceData.java","additions":51,"deletions":26,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.awt.AlphaComposite;\n-import java.awt.GraphicsConfiguration;\n@@ -33,1 +31,0 @@\n-import java.awt.image.IndexColorModel;\n@@ -35,0 +32,1 @@\n+import java.awt.image.IndexColorModel;\n@@ -37,0 +35,1 @@\n+import sun.java2d.SunGraphics2D;\n@@ -39,2 +38,0 @@\n-import sun.java2d.SunGraphics2D;\n-import sun.java2d.loops.SurfaceType;\n@@ -109,1 +106,2 @@\n-                                                       null, 0, getTransparency());\n+                                                       null, 0,\n+                                                       getTransparency(), true);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/x11\/X11SurfaceDataProxy.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+\n@@ -96,1 +97,2 @@\n-                                              Transparency.OPAQUE);\n+                                              Transparency.OPAQUE,\n+                                              false);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/x11\/X11VolatileSurfaceManager.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -654,1 +654,1 @@\n-void AwtFrame::Reshape(int x, int y, int width, int height)\n+void AwtFrame::Reshape(int x, int y, int w, int h)\n@@ -658,0 +658,19 @@\n+        POINT pt = {x + w \/ 2, y + h \/ 2};\n+        Devices::InstanceAccess devices;\n+        HMONITOR monitor = MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);\n+        int screen = AwtWin32GraphicsDevice::GetScreenFromHMONITOR(monitor);\n+        AwtWin32GraphicsDevice *device = devices->GetDevice(screen);\n+        \/\/ Try to set the correct size and jump to the correct location, even if\n+        \/\/ it is on the different monitor. Note that for the \"size\" we use the\n+        \/\/ current monitor, so the WM_DPICHANGED will adjust it for the \"target\"\n+        \/\/ monitor.\n+        MONITORINFO *miInfo = AwtWin32GraphicsDevice::GetMonitorInfo(screen);\n+        x = device == NULL ? x : device->ScaleUpAbsX(x);\n+        y = device == NULL ? y : device->ScaleUpAbsY(y);\n+        w = ScaleUpX(w);\n+        h = ScaleUpY(h);\n+        \/\/ SetWindowPlacement takes workspace coordinates, but if taskbar is at\n+        \/\/ top\/left of screen, workspace coords != screen coords, so offset by\n+        \/\/ workspace origin\n+        x = x - (miInfo->rcWork.left - miInfo->rcMonitor.left);\n+        y = y - (miInfo->rcWork.top - miInfo->rcMonitor.top);\n@@ -659,13 +678,1 @@\n-        POINT       ptMinPosition = {x,y};\n-        POINT       ptMaxPosition = {0,0};\n-        RECT        rcNormalPosition = {x,y,x+width,y+height};\n-        RECT        rcWorkspace;\n-        HWND        hWndDesktop = GetDesktopWindow();\n-        HWND        hWndSelf = GetHWnd();\n-\n-        \/\/ SetWindowPlacement takes workspace coordinates, but\n-        \/\/ if taskbar is at top of screen, workspace coords !=\n-        \/\/ screen coords, so offset by workspace origin\n-        VERIFY(::SystemParametersInfo(SPI_GETWORKAREA, 0, (PVOID)&rcWorkspace, 0));\n-        ::OffsetRect(&rcNormalPosition, -rcWorkspace.left, -rcWorkspace.top);\n-\n+        ::ZeroMemory(&wp, sizeof(WINDOWPLACEMENT));\n@@ -676,3 +683,3 @@\n-        wp.ptMinPosition = ptMinPosition;\n-        wp.ptMaxPosition = ptMaxPosition;\n-        wp.rcNormalPosition = rcNormalPosition;\n+        wp.ptMinPosition = {x, y};\n+        wp.ptMaxPosition = {0, 0};\n+        wp.rcNormalPosition = {x, y, x + w, y + h};\n@@ -686,1 +693,1 @@\n-        ::SetWindowPlacement(hWndSelf, &wp);\n+        ::SetWindowPlacement(GetHWnd(), &wp);\n@@ -706,1 +713,1 @@\n-    AwtWindow::Reshape(x, y, width, height);\n+    AwtWindow::Reshape(x, y, w, h);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Frame.cpp","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1586,0 +1586,4 @@\n+            \/\/ Currently, an InapplicableMethodException occurs.\n+            \/\/ If bestSoFar.kind was ABSENT_MTH, return an InapplicableSymbolError(kind is WRONG_MTH).\n+            \/\/ If bestSoFar.kind was HIDDEN(AccessError)\/WRONG_MTH\/WRONG_MTHS, return an InapplicableSymbolsError(kind is WRONG_MTHS).\n+            \/\/ See JDK-8255968 for more information.\n@@ -1589,0 +1593,10 @@\n+                case HIDDEN:\n+                    if (bestSoFar instanceof AccessError) {\n+                        \/\/ Add the JCDiagnostic of previous AccessError to the currentResolutionContext\n+                        \/\/ and construct InapplicableSymbolsError.\n+                        \/\/ Intentionally fallthrough.\n+                        currentResolutionContext.addInapplicableCandidate(((AccessError) bestSoFar).sym,\n+                                ((AccessError) bestSoFar).getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT, null, null, site, null, argtypes, typeargtypes));\n+                    } else {\n+                        return bestSoFar;\n+                    }\n@@ -1596,3 +1610,25 @@\n-            return (bestSoFar.kind == ABSENT_MTH)\n-                ? new AccessError(env, site, sym)\n-                : bestSoFar;\n+            AccessError curAccessError = new AccessError(env, site, sym);\n+            JCDiagnostic curDiagnostic = curAccessError.getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT, null, null, site, null, argtypes, typeargtypes);\n+            \/\/ Currently, an AccessError occurs.\n+            \/\/ If bestSoFar.kind was ABSENT_MTH, return an AccessError(kind is HIDDEN).\n+            \/\/ If bestSoFar.kind was HIDDEN(AccessError), WRONG_MTH, WRONG_MTHS, return an InapplicableSymbolsError(kind is WRONG_MTHS).\n+            \/\/ See JDK-8255968 for more information.\n+            if (bestSoFar.kind == ABSENT_MTH) {\n+                bestSoFar = curAccessError;\n+            } else if (bestSoFar.kind == WRONG_MTH) {\n+                \/\/ Add the JCDiagnostic of current AccessError to the currentResolutionContext\n+                \/\/ and construct InapplicableSymbolsError.\n+                currentResolutionContext.addInapplicableCandidate(sym, curDiagnostic);\n+                bestSoFar = new InapplicableSymbolsError(currentResolutionContext);\n+            } else if (bestSoFar.kind == WRONG_MTHS) {\n+                \/\/ Add the JCDiagnostic of current AccessError to the currentResolutionContext\n+                currentResolutionContext.addInapplicableCandidate(sym, curDiagnostic);\n+            } else if (bestSoFar.kind == HIDDEN && bestSoFar instanceof AccessError) {\n+                \/\/ Add the JCDiagnostics of previous and current AccessError to the currentResolutionContext\n+                \/\/ and construct InapplicableSymbolsError.\n+                currentResolutionContext.addInapplicableCandidate(((AccessError) bestSoFar).sym,\n+                        ((AccessError) bestSoFar).getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT, null, null, site, null, argtypes, typeargtypes));\n+                currentResolutionContext.addInapplicableCandidate(sym, curDiagnostic);\n+                bestSoFar = new InapplicableSymbolsError(currentResolutionContext);\n+            }\n+            return bestSoFar;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":39,"deletions":3,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -668,2 +668,0 @@\n-                case VECTOR_OP_OR: return (v0, v1) ->\n-                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -2322,2 +2320,0 @@\n-              case VECTOR_OP_OR: return v ->\n-                      toBits(v.rOp((double)0, (i, a, b) -> fromBits(toBits(a) | toBits(b))));\n@@ -2339,2 +2335,0 @@\n-                case VECTOR_OP_OR:\n-                case VECTOR_OP_XOR:\n@@ -2344,2 +2338,0 @@\n-                case VECTOR_OP_AND:\n-                    return v -> v.broadcast(-1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -668,2 +668,0 @@\n-                case VECTOR_OP_OR: return (v0, v1) ->\n-                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n@@ -2342,2 +2340,0 @@\n-              case VECTOR_OP_OR: return v ->\n-                      toBits(v.rOp((float)0, (i, a, b) -> fromBits(toBits(a) | toBits(b))));\n@@ -2359,2 +2355,0 @@\n-                case VECTOR_OP_OR:\n-                case VECTOR_OP_XOR:\n@@ -2364,2 +2358,0 @@\n-                case VECTOR_OP_AND:\n-                    return v -> v.broadcast(-1);\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -734,4 +734,0 @@\n-#if[FP]\n-                case VECTOR_OP_OR: return (v0, v1) ->\n-                        v0.bOp(v1, (i, a, b) -> fromBits(toBits(a) | toBits(b)));\n-#end[FP]\n@@ -2839,4 +2835,0 @@\n-#if[FP]\n-              case VECTOR_OP_OR: return v ->\n-                      toBits(v.rOp(($type$)0, (i, a, b) -> fromBits(toBits(a) | toBits(b))));\n-#end[FP]\n@@ -2858,0 +2850,1 @@\n+#if[BITWISE]\n@@ -2860,0 +2853,1 @@\n+#end[BITWISE]\n@@ -2863,0 +2857,1 @@\n+#if[BITWISE]\n@@ -2865,0 +2860,1 @@\n+#end[BITWISE]\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+    private final Instant creationTime;\n@@ -89,0 +90,2 @@\n+        this.creationTime = Instant.now();\n+        this.recording.setName(\"Recording Stream: \" + creationTime);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/RecordingStream.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8,1 +8,1 @@\n-%if \"xAPPLICATION_PREFIX\" != x\n+%if \"xAPPLICATION_PREFIX\" != \"x\"\n@@ -14,1 +14,1 @@\n-%if \"xAPPLICATION_GROUP\" != x\n+%if \"xAPPLICATION_GROUP\" != \"x\"\n@@ -20,1 +20,1 @@\n-%if \"xPACKAGE_DEFAULT_DEPENDENCIES\" != x || \"xPACKAGE_CUSTOM_DEPENDENCIES\" != x\n+%if \"xPACKAGE_DEFAULT_DEPENDENCIES\" != \"x\" || \"xPACKAGE_CUSTOM_DEPENDENCIES\" != \"x\"\n@@ -46,1 +46,1 @@\n-%if \"xAPPLICATION_LICENSE_FILE\" != x\n+%if \"xAPPLICATION_LICENSE_FILE\" != \"x\"\n@@ -56,1 +56,1 @@\n-%if \"xAPPLICATION_LICENSE_FILE\" != x\n+%if \"xAPPLICATION_LICENSE_FILE\" != \"x\"\n@@ -61,1 +61,1 @@\n-%if \"xAPPLICATION_LICENSE_FILE\" != x\n+%if \"xAPPLICATION_LICENSE_FILE\" != \"x\"\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/template.spec","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#ifdef AARCH64\n+#if defined(AARCH64) && !defined(ZERO)\n","filename":"test\/hotspot\/gtest\/aarch64\/test_assembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Frame;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Rectangle;\n+import java.awt.Toolkit;\n+\n+\/**\n+ * @test\n+ * @bug 8256373\n+ * @key headful\n+ * @summary setBounds() should work if the frame is minimized\n+ *\/\n+public final class RestoreToOppositeScreen {\n+\n+    public static void main(String[] args) throws Exception {\n+        Toolkit toolkit = Toolkit.getDefaultToolkit();\n+        if (!toolkit.isFrameStateSupported(Frame.ICONIFIED)) {\n+            return;\n+        }\n+\n+        var ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        GraphicsDevice[] gds = ge.getScreenDevices();\n+        for (GraphicsDevice gd1 : gds) {\n+            Rectangle screen1 = gd1.getDefaultConfiguration().getBounds();\n+            int x1 = (int) screen1.getCenterX();\n+            int y1 = (int) screen1.getCenterY();\n+            for (GraphicsDevice gd2 : gds) {\n+                Rectangle screen2 = gd2.getDefaultConfiguration().getBounds();\n+                \/\/ tweak the (x2, y2) point so even if the screen1 and screen2\n+                \/\/ are the same, we will use different bounds, otherwise\n+                \/\/ setBounds() will be ignored\n+                int x2 = (int) screen2.getCenterX() - 50;\n+                int y2 = (int) screen2.getCenterY() - 50;\n+                Frame frame = new Frame();\n+                try {\n+                    \/\/ show the frame on one monitor, and then move it to\n+                    \/\/ another while the frame minimized\n+                    frame.setBounds(x1, y1, 400, 400);\n+                    frame.setVisible(true);\n+                    Thread.sleep(2000);\n+                    frame.setExtendedState(Frame.ICONIFIED);\n+                    Thread.sleep(2000);\n+                    Rectangle before = new Rectangle(x2, y2, 380, 380);\n+                    frame.setBounds(before);\n+                    Thread.sleep(2000);\n+                    frame.setExtendedState(Frame.NORMAL);\n+                    Thread.sleep(2000);\n+                    Rectangle after = frame.getBounds();\n+                    checkSize(after.x, before.x, \"x\");\n+                    checkSize(after.y, before.y, \"y\");\n+                    checkSize(after.width, before.width, \"width\");\n+                    checkSize(after.height, before.height, \"height\");\n+                } finally {\n+                    frame.dispose();\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkSize(int actual, int expected, String prop) {\n+        if (Math.abs(actual - expected) > 10) { \/\/ let's allow size variation,\n+                                                \/\/ the bug is reproduced anyway\n+            System.err.println(\"Expected: \" + expected);\n+            System.err.println(\"Actual: \" + actual);\n+            throw new RuntimeException(prop + \" is wrong\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Frame\/RestoreToOppositeScreen\/RestoreToOppositeScreen.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-   @ignore Test truncates system files when run as root, see 7042603\n+   @ignore 7042603 - Test truncates system files when run as root\n","filename":"test\/jdk\/java\/io\/IOException\/LastErrorString.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,4 @@\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n@@ -26,2 +30,3 @@\n- * @bug 4914802\n- * @summary Test Insert method for infinite loop\n+ * @run testng Insert\n+ * @bug 4914802 8257511\n+ * @summary Test StringBuilder.insert sanity tests\n@@ -29,1 +34,1 @@\n-\n+@Test\n@@ -31,4 +36,15 @@\n-   public static void main (String argv[]) throws Exception {\n-       StringBuilder sb = new StringBuilder();\n-       sb.insert(0, false);\n-   }\n+\n+    public void insertFalse() {\n+        \/\/ Caused an infinite loop before 4914802\n+        StringBuilder sb = new StringBuilder();\n+        assertEquals(\"false\", sb.insert(0, false).toString());\n+    }\n+\n+    public void insertOffset() {\n+        \/\/ 8254082 made the String variant cause an AIOOBE, fixed in 8257511\n+        assertEquals(\"efabc\", new StringBuilder(\"abc\").insert(0, \"def\",                      1, 3).toString());\n+        assertEquals(\"efabc\", new StringBuilder(\"abc\").insert(0, new StringBuilder(\"def\"),   1, 3).toString());\n+        \/\/ insert(I[CII) and insert(ILjava\/lang\/CharSequence;II) are inconsistently specified\n+        assertEquals(\"efabc\", new StringBuilder(\"abc\").insert(0, new char[] {'d', 'e', 'f'}, 1, 2).toString());\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/StringBuilder\/Insert.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8142968 8253751\n@@ -45,1 +46,0 @@\n-import java.nio.file.Paths;\n@@ -63,2 +63,1 @@\n-    private static final Path USER_DIR\n-         = Paths.get(System.getProperty(\"user.dir\"));\n+    private static final Path USER_DIR = Path.of(System.getProperty(\"user.dir\"));\n@@ -169,1 +168,0 @@\n-\n@@ -913,0 +911,66 @@\n+    \/**\n+     * Basic test for a module requiring an automatic module in a parent\n+     * configuration. If an explicit module in a child configuration reads an\n+     * automatic module in a parent configuration then it should read all\n+     * automatic modules in the parent configuration.\n+     *\/\n+    public void testInConfiguration7() throws Exception {\n+        \/\/ m1 requires auto1\n+        ModuleDescriptor descriptor1 = ModuleDescriptor.newModule(\"m1\")\n+                .requires(\"auto1\")\n+                .build();\n+\n+        Path dir1 = Files.createTempDirectory(USER_DIR, \"mods\");\n+        createDummyJarFile(dir1.resolve(\"auto1.jar\"), \"p1\/C.class\");\n+        createDummyJarFile(dir1.resolve(\"auto2.jar\"), \"p2\/C.class\");\n+\n+        \/\/ module finder locates m1, auto1, and auto2\n+        ModuleFinder finder1 = ModuleFinder.compose(ModuleUtils.finderOf(descriptor1),\n+                                                    ModuleFinder.of(dir1));\n+\n+        Configuration parent = ModuleLayer.boot().configuration();\n+        ResolvedModule base = parent.findModule(\"java.base\").orElseThrow();\n+\n+        Configuration cf1 = resolve(parent, finder1, \"m1\");\n+        assertTrue(cf1.modules().size() == 3);\n+\n+        ResolvedModule m1 = cf1.findModule(\"m1\").orElseThrow();\n+        ResolvedModule auto1 = cf1.findModule(\"auto1\").orElseThrow();\n+        ResolvedModule auto2 = cf1.findModule(\"auto2\").orElseThrow();\n+\n+        assertTrue(m1.reads().size() == 3);\n+        assertTrue(m1.reads().contains(base));\n+        assertTrue(m1.reads().contains(auto1));\n+        assertTrue(m1.reads().contains(auto2));\n+\n+        assertTrue(auto1.reads().contains(base));\n+        assertTrue(auto1.reads().contains(m1));\n+        assertTrue(auto1.reads().contains(auto2));\n+\n+        assertTrue(auto2.reads().contains(base));\n+        assertTrue(auto2.reads().contains(m1));\n+        assertTrue(auto2.reads().contains(auto1));\n+\n+        \/\/ m2 requires auto1\n+        ModuleDescriptor descriptor2 = ModuleDescriptor.newModule(\"m2\")\n+                .requires(\"auto1\")\n+                .build();\n+\n+        Path dir2 = Files.createTempDirectory(USER_DIR, \"mods\");\n+        createDummyJarFile(dir1.resolve(\"auto3.jar\"), \"p3\/C.class\");\n+\n+        \/\/ module finder locates m2 and auto3\n+        ModuleFinder finder2 = ModuleFinder.compose(ModuleUtils.finderOf(descriptor2),\n+                                                    ModuleFinder.of(dir2));\n+\n+        Configuration cf2 = resolve(cf1, finder2, \"m2\");\n+        assertTrue(cf2.modules().size() == 1);   \/\/ auto3 should not be resolved\n+\n+        ResolvedModule m2 = cf2.findModule(\"m2\").orElseThrow();\n+\n+        assertTrue(m2.reads().size() == 3);\n+        assertTrue(m2.reads().contains(base));\n+        assertTrue(m2.reads().contains(auto1));\n+        assertTrue(m2.reads().contains(auto2));\n+    }\n+\n@@ -1108,1 +1172,1 @@\n-        Path[] paths = Stream.of(entries).map(Paths::get).toArray(Path[]::new);\n+        Path[] paths = Stream.of(entries).map(Path::of).toArray(Path[]::new);\n","filename":"test\/jdk\/java\/lang\/module\/AutomaticModulesTest.java","additions":70,"deletions":6,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,386 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.Arrays;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * @test\n+ * @bug 8159746\n+ * @run testng DefaultMethods\n+ * @summary Basic tests for Proxy::invokeSuper default method\n+ *\/\n+\n+public class DefaultMethods {\n+    public interface I1 {\n+        default int m() {\n+            return 10;\n+        }\n+    }\n+\n+    public interface I2 {\n+        default int m() {\n+            return 20;\n+        }\n+\n+        private void privateMethod() {\n+            throw new Error(\"should not reach here\");\n+        }\n+    }\n+\n+    \/\/ I3::m inherits from I2:m\n+    public interface I3 extends I2 {\n+        default int m3(String... s) {\n+            return Arrays.stream(s).mapToInt(String::length).sum();\n+        }\n+    }\n+\n+    public interface I4 extends I1, I2 {\n+        default int m() {\n+            return 40;\n+        }\n+\n+        default int mix(int a, String b) {\n+            return 0;\n+        }\n+    }\n+\n+    public interface I12 extends I1, I2 {\n+        @Override\n+        int m();\n+\n+        default int sum(int a, int b) {\n+            return a + b;\n+        }\n+\n+        default Object[] concat(Object first, Object... rest) {\n+            Object[] result = new Object[1 + rest.length];\n+            result[0] = first;\n+            System.arraycopy(rest, 0, result, 1, rest.length);\n+            return result;\n+        }\n+    }\n+\n+    public interface IX {\n+        default void doThrow(Throwable exception) throws Throwable {\n+            throw exception;\n+        }\n+    }\n+\n+    private static Method findDefaultMethod(Class<?> refc, Method m) {\n+        try {\n+            assertTrue(refc.isInterface());\n+\n+            Method method = refc.getMethod(m.getName(), m.getParameterTypes());\n+            assertTrue(method.isDefault());\n+            return method;\n+        } catch (NoSuchMethodException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Test\n+    public void test() {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, new Class<?>[] { I1.class, I2.class},\n+                (o, method, params) -> {\n+                    return InvocationHandler.invokeDefault(o, findDefaultMethod(I2.class, method), params);\n+                });\n+        I1 i1 = (I1) proxy;\n+        assertEquals(i1.m(), 20);\n+    }\n+\n+    \/\/ a default method is declared in one of the proxy interfaces\n+    @DataProvider(name = \"defaultMethods\")\n+    private Object[][] defaultMethods() {\n+        return new Object[][]{\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, true, 10},\n+            new Object[]{new Class<?>[]{I1.class, I3.class}, true, 10},\n+            new Object[]{new Class<?>[]{I1.class, I12.class}, true, 10},\n+            new Object[]{new Class<?>[]{I2.class, I12.class}, true, 20},\n+            new Object[]{new Class<?>[]{I4.class}, true, 40},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, true, 40},\n+            new Object[]{new Class<?>[]{I12.class}, false, -1},\n+            new Object[]{new Class<?>[]{I12.class, I1.class, I2.class}, false, -1}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"defaultMethods\")\n+    public void testDefaultMethod(Class<?>[] intfs, boolean isDefault, int expected) throws Throwable {\n+        InvocationHandler ih = (proxy, method, params) -> {\n+            System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+            switch (method.getName()) {\n+                case \"m\":\n+                    assertTrue(method.isDefault() == isDefault);\n+                    assertTrue(Arrays.stream(proxy.getClass().getInterfaces())\n+                                     .anyMatch(intf -> method.getDeclaringClass() == intf),\n+                               Arrays.toString(proxy.getClass().getInterfaces()));\n+                    if (method.isDefault()) {\n+                        return InvocationHandler.invokeDefault(proxy, method, params);\n+                    } else {\n+                        return -1;\n+                    }\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+\n+        Object proxy = Proxy.newProxyInstance(DefaultMethods.class.getClassLoader(), intfs, ih);\n+        Method m = proxy.getClass().getMethod(\"m\");\n+        int result = (int)m.invoke(proxy);\n+        assertEquals(result, expected);\n+    }\n+\n+    \/\/ a default method may be declared in a proxy interface or\n+    \/\/ inherited from a superinterface of a proxy interface\n+    @DataProvider(name = \"supers\")\n+    private Object[][] supers() {\n+        return new Object[][]{\n+            \/\/ invoke \"m\" implemented in the first proxy interface\n+            \/\/ same as the method passed to InvocationHandler::invoke\n+            new Object[]{new Class<?>[]{I1.class}, I1.class, 10},\n+            new Object[]{new Class<?>[]{I2.class}, I2.class, 20},\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, I1.class, 10},\n+            \/\/ \"m\" is implemented in I2, an indirect superinterface of I3\n+            new Object[]{new Class<?>[]{I3.class}, I3.class, 20},\n+            \/\/ \"m\" is implemented in I1, I2 and overridden in I4\n+            new Object[]{new Class<?>[]{I4.class}, I4.class, 40},\n+            \/\/ invoke \"m\" implemented in the second proxy interface\n+            \/\/ different from the method passed to InvocationHandler::invoke\n+            new Object[]{new Class<?>[]{I1.class, I2.class}, I2.class, 20},\n+            new Object[]{new Class<?>[]{I1.class, I3.class}, I3.class, 20},\n+            \/\/ I2::m is implemented in more than one proxy interface directly or indirectly\n+            \/\/ I3::m resolves to I2::m (indirect superinterface)\n+            \/\/ I2 is the superinterface of I4 and I4 overrides m\n+            \/\/ the proxy class can invoke I4::m and I2::m\n+            new Object[]{new Class<?>[]{I3.class, I4.class}, I3.class, 20},\n+            new Object[]{new Class<?>[]{I3.class, I4.class}, I4.class, 40},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, I3.class, 20},\n+            new Object[]{new Class<?>[]{I4.class, I3.class}, I4.class, 40}\n+        };\n+    }\n+\n+    @Test(dataProvider = \"supers\")\n+    public void testSuper(Class<?>[] intfs, Class<?> proxyInterface, int expected) throws Throwable {\n+        final InvocationHandler ih = (proxy, method, params) -> {\n+            switch (method.getName()) {\n+                case \"m\":\n+                    assertTrue(method.isDefault());\n+                    return InvocationHandler.invokeDefault(proxy, findDefaultMethod(proxyInterface, method), params);\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+        ClassLoader loader = proxyInterface.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, intfs, ih);\n+        if (proxyInterface == I1.class) {\n+            I1 i1 = (I1) proxy;\n+            assertEquals(i1.m(), expected);\n+        } else if (proxyInterface == I2.class) {\n+            I2 i2 = (I2) proxy;\n+            assertEquals(i2.m(), expected);\n+        } else if (proxyInterface == I3.class) {\n+            I3 i3 = (I3) proxy;\n+            assertEquals(i3.m(), expected);\n+        } else if (proxyInterface == I4.class) {\n+            I4 i4 = (I4) proxy;\n+            assertEquals(i4.m(), expected);\n+        } else {\n+            throw new UnsupportedOperationException(proxyInterface.toString());\n+        }\n+        \/\/ invoke via InvocationHandler.invokeDefaultMethod directly\n+        assertEquals(InvocationHandler.invokeDefault(proxy, proxyInterface.getMethod(\"m\")), expected);\n+    }\n+\n+    \/\/ invoke I12 default methods with parameters and var args\n+    @Test\n+    public void testI12() throws Throwable {\n+        final InvocationHandler ih = (proxy, method, params) -> {\n+            System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+            switch (method.getName()) {\n+                case \"sum\":\n+                case \"concat\":\n+                    assertTrue(method.isDefault());\n+                    return InvocationHandler.invokeDefault(proxy, method, params);\n+                default:\n+                    throw new UnsupportedOperationException(method.toString());\n+            }\n+        };\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I12 i12 = (I12) Proxy.newProxyInstance(loader, new Class<?>[] { I12.class }, ih);\n+        assertEquals(i12.sum(1, 2), 3);\n+        assertEquals(i12.concat(1, 2, 3, 4), new Object[]{1, 2, 3, 4});\n+        Method m = I12.class.getMethod(\"concat\", Object.class, Object[].class);\n+        assertTrue(m.isDefault());\n+        assertEquals(InvocationHandler.invokeDefault(i12, m, 100, new Object[] {\"foo\", true, \"bar\"}),\n+                     new Object[] {100, \"foo\", true, \"bar\"});\n+    }\n+\n+    \/\/ test a no-arg default method with and without arguments passed in the invocation\n+    @Test\n+    public void testEmptyArgument() throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n+        Method m1 = I4.class.getMethod(\"m\");\n+        assertTrue(m1.getDeclaringClass() == I4.class);\n+        assertTrue(m1.isDefault());\n+        InvocationHandler.invokeDefault(proxy, m1);\n+        InvocationHandler.invokeDefault(proxy, m1, new Object[0]);\n+\n+        Method m2 = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m1.getDeclaringClass() == I4.class);\n+        assertTrue(m1.isDefault());\n+        InvocationHandler.invokeDefault(proxy, m2, Integer.valueOf(100), \"foo\");\n+    }\n+\n+    @Test\n+    public void testVarArgs() throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I3 proxy = (I3)Proxy.newProxyInstance(loader, new Class<?>[]{I3.class}, HANDLER);\n+        Method m = I3.class.getMethod(\"m3\", String[].class);\n+        assertTrue(m.isVarArgs() && m.isDefault());\n+        assertEquals(proxy.m3(\"a\", \"b\", \"cde\"), 5);\n+        assertEquals(InvocationHandler.invokeDefault(proxy, m, (Object)new String[] { \"a\", \"bc\" }), 3);\n+    }\n+\n+    \/*\n+     * Invoke I12::m which is an abstract method\n+     *\/\n+    @Test(expectedExceptions = {IllegalArgumentException.class})\n+    public void invokeAbstractMethod() throws Exception {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I12 proxy = (I12) Proxy.newProxyInstance(loader, new Class<?>[]{I12.class}, HANDLER);\n+        Method method = I12.class.getMethod(\"m\");\n+        assertTrue(method.getDeclaringClass() == I12.class);\n+        assertFalse(method.isDefault());\n+        proxy.m();\n+    }\n+\n+    \/*\n+     * Invoke a non proxy (default) method with parameters\n+     *\/\n+    @Test(expectedExceptions = {IllegalArgumentException.class})\n+    public void invokeNonProxyMethod() throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I3 proxy = (I3) Proxy.newProxyInstance(loader, new Class<?>[]{I3.class}, HANDLER);\n+        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m.isDefault());\n+        InvocationHandler.invokeDefault(proxy, m);\n+    }\n+\n+    \/\/ negative cases\n+    @DataProvider(name = \"negativeCases\")\n+    private Object[][] negativeCases() {\n+        return new Object[][]{\n+            \/\/ I4::m overrides I1::m and I2::m\n+            new Object[] { new Class<?>[]{I4.class}, I1.class, \"m\" },\n+            new Object[] { new Class<?>[]{I4.class}, I2.class, \"m\" },\n+            \/\/ I12::m is not a default method\n+            new Object[] { new Class<?>[]{I12.class}, I12.class, \"m\" },\n+            \/\/ non-proxy default method\n+            new Object[] { new Class<?>[]{I3.class}, I1.class, \"m\" },\n+            \/\/ not a default method and not a proxy interface\n+            new Object[] { new Class<?>[]{I12.class}, DefaultMethods.class, \"test\" },\n+            new Object[] { new Class<?>[]{I12.class}, Runnable.class, \"run\" },\n+            \/\/ I2::privateMethod is a private method\n+            new Object[] { new Class<?>[]{I3.class}, I2.class, \"privateMethod\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"negativeCases\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testNegativeCase(Class<?>[] interfaces, Class<?> defc, String name)\n+            throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        Object proxy = Proxy.newProxyInstance(loader, interfaces, HANDLER);\n+        try {\n+            Method method = defc.getDeclaredMethod(name);\n+            InvocationHandler.invokeDefault(proxy, method);\n+        } catch (Throwable e) {\n+            System.out.format(\"%s method %s::%s exception thrown: %s%n\",\n+                              Arrays.toString(interfaces), defc.getName(), name, e.getMessage());\n+            throw e;\n+        }\n+    }\n+\n+    @DataProvider(name = \"illegalArguments\")\n+    private Object[][] illegalArguments() {\n+        return new Object[][] {\n+            new Object[] {},\n+            new Object[] { 100 },\n+            new Object[] { 100, \"foo\", 100 },\n+            new Object[] { 100L, \"foo\" },\n+            new Object[] { \"foo\", 100},\n+            new Object[] { null, \"foo\" }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"illegalArguments\", expectedExceptions = {IllegalArgumentException.class})\n+    public void testIllegalArgument(Object... args) throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        I4 proxy = (I4)Proxy.newProxyInstance(loader, new Class<?>[]{I4.class}, HANDLER);\n+        Method m = I4.class.getMethod(\"mix\", int.class, String.class);\n+        assertTrue(m.isDefault());\n+        if (args.length == 0) {\n+            \/\/ substitute empty args with null since @DataProvider doesn't allow null array\n+            args = null;\n+        }\n+        InvocationHandler.invokeDefault(proxy, m, args);\n+    }\n+\n+    @DataProvider(name = \"throwables\")\n+    private Object[][] throwables() {\n+        return new Object[][] {\n+            new Object[] { new IOException() },\n+            new Object[] { new IllegalArgumentException() },\n+            new Object[] { new ClassCastException() },\n+            new Object[] { new NullPointerException() },\n+            new Object[] { new AssertionError() },\n+            new Object[] { new Throwable() }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"throwables\")\n+    public void testInvocationException(Throwable exception) throws Throwable {\n+        ClassLoader loader = DefaultMethods.class.getClassLoader();\n+        IX proxy = (IX)Proxy.newProxyInstance(loader, new Class<?>[]{IX.class}, HANDLER);\n+        Method m = IX.class.getMethod(\"doThrow\", Throwable.class);\n+        try {\n+            InvocationHandler.invokeDefault(proxy, m, exception);\n+        } catch (Throwable e) {\n+            assertEquals(e, exception);\n+        }\n+    }\n+\n+    private static final InvocationHandler HANDLER = (proxy, method, params) -> {\n+        System.out.format(\"invoking %s with parameters: %s%n\", method, Arrays.toString(params));\n+        return InvocationHandler.invokeDefault(proxy, method, params);\n+    };\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/DefaultMethods.java","additions":386,"deletions":0,"binary":false,"changes":386,"status":"added"},{"patch":"@@ -90,1 +90,1 @@\n-    public void testNoReadAccess() throws Exception {\n+    public void testNoReadAccess() throws Throwable {\n@@ -107,1 +107,1 @@\n-    private void checkIAE(ClassLoader loader, Class<?>[] interfaces) {\n+    private void checkIAE(ClassLoader loader, Class<?>[] interfaces)  throws Throwable {\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyClassAccessTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,2 +102,3 @@\n-        assertFalse(proxyClass.getModule().isNamed());\n-        assertFalse(pkg.isSealed());\n+        assertTrue(proxyClass.getModule().isNamed());\n+        assertTrue(pkg.isSealed());\n+        assertTrue(proxyClass.getModule().isExported(pkg.getName()));\n@@ -135,0 +136,1 @@\n+        assertFalse(proxyClass.getModule().isExported(pkg.getName()));\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyLayerTest.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-        new ProxyModuleMapping(unnamed, Runnable.class).test();\n+        new ProxyModuleMapping(Runnable.class).test();\n@@ -82,1 +82,2 @@\n-            if (module.isNamed()) {\n+            \/\/ the exported package name is same as the module name\n+            if (!c.getPackageName().equals(module.getName())) {\n@@ -86,1 +87,2 @@\n-            if (!module.isNamed()) {\n+            \/\/ non-exported package from the dynamic module\n+            if (c.getPackageName().equals(module.getName())) {\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyModuleMapping.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -84,0 +84,16 @@\n+\n+    \/**\n+     * Tests invocation of default methods in exported and non-exported types\n+     * in a named module\n+     *\/\n+    @Test\n+    public void runDefaultMethodsTest() throws Exception {\n+        int exitValue = executeTestJava(\"-cp\", CPATH_DIR.toString(),\n+                \"--module-path\", MODS_DIR.toString(),\n+                \"-m\", \"test\/jdk.test.DefaultMethods\")\n+                .outputTo(System.out)\n+                .errorTo(System.out)\n+                .getExitValue();\n+\n+        assertTrue(exitValue == 0);\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyTest.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.*;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8159746\n+ * @summary Test invoking a default method in a non-public proxy interface\n+ * @build p.Foo p.Bar p.ProxyMaker\n+ * @run testng DefaultMethodProxy\n+ *\/\n+public class DefaultMethodProxy {\n+    public interface I {\n+        default String m() { return \"I\"; }\n+    }\n+\n+    @Test\n+    public static void publicInterface() throws ReflectiveOperationException {\n+        \/\/ create a proxy instance of a public proxy interface should succeed\n+        Proxy proxy = (Proxy)Proxy.newProxyInstance(DefaultMethodProxy.class.getClassLoader(),\n+                new Class<?>[] { I.class }, IH);\n+\n+        testDefaultMethod(proxy, \"I\");\n+\n+        \/\/ can get the invocation handler\n+        assertTrue(Proxy.getInvocationHandler(proxy) == IH);\n+    }\n+\n+\n+    @DataProvider(name = \"nonPublicIntfs\")\n+    private static Object[][] nonPublicIntfs() throws ClassNotFoundException {\n+        Class<?> fooClass = Class.forName(\"p.Foo\");\n+        Class<?> barClass = Class.forName(\"p.Bar\");\n+        return new Object[][]{\n+                new Object[]{new Class<?>[]{ fooClass }, \"foo\"},\n+                new Object[]{new Class<?>[]{ barClass, fooClass }, \"bar\"},\n+                new Object[]{new Class<?>[]{ barClass }, \"bar\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"nonPublicIntfs\")\n+    public static void hasPackageAccess(Class<?>[] intfs, String expected) throws ReflectiveOperationException {\n+        Proxy proxy = (Proxy)Proxy.newProxyInstance(DefaultMethodProxy.class.getClassLoader(), intfs, IH);\n+        testDefaultMethod(proxy, expected);\n+\n+        \/\/ proxy instance is created successfully even invocation handler has no access\n+        Proxy.newProxyInstance(DefaultMethodProxy.class.getClassLoader(), intfs, IH_NO_ACCESS);\n+    }\n+\n+    \/\/ IAE thrown at invocation time\n+    @Test(dataProvider = \"nonPublicIntfs\", expectedExceptions = {IllegalAccessException.class})\n+    public static void noPackageAccess(Class<?>[] intfs, String ignored) throws Throwable {\n+        Proxy proxy = (Proxy)Proxy.newProxyInstance(DefaultMethodProxy.class.getClassLoader(), intfs, IH_NO_ACCESS);\n+        try {\n+            testDefaultMethod(proxy, \"dummy\");\n+        } catch (InvocationTargetException e) {\n+            \/\/ unwrap the exception\n+            if (e.getCause() instanceof UndeclaredThrowableException) {\n+                Throwable cause = e.getCause();\n+                throw cause.getCause();\n+            }\n+            throw e;\n+        }\n+    }\n+\n+    \/*\n+     * Verify if a default method \"m\" can be invoked successfully\n+     *\/\n+    static void testDefaultMethod(Proxy proxy, String expected) throws ReflectiveOperationException {\n+        Method m = proxy.getClass().getDeclaredMethod(\"m\");\n+        m.setAccessible(true);\n+        String name = (String) m.invoke(proxy);\n+        if (!expected.equals(name)) {\n+            throw new RuntimeException(\"return value: \" + name + \" expected: \" + expected);\n+        }\n+    }\n+\n+    \/\/ invocation handler with access to the non-public interface in package p\n+    private static final InvocationHandler IH = (proxy, method, params) -> {\n+        System.out.format(\"Proxy for %s: invoking %s%n\",\n+                Arrays.stream(proxy.getClass().getInterfaces())\n+                      .map(Class::getName)\n+                      .collect(Collectors.joining(\", \")), method.getName());\n+        if (method.isDefault()) {\n+            return p.ProxyMaker.invoke(proxy, method, params);\n+        }\n+        throw new UnsupportedOperationException(method.toString());\n+    };\n+\n+    \/\/ invocation handler with no access to the non-public interface in package p\n+    \/\/ expect IllegalAccessException thrown\n+    private static final InvocationHandler IH_NO_ACCESS = (proxy, method, params) -> {\n+        System.out.format(\"Proxy for %s: invoking %s%n\",\n+                Arrays.stream(proxy.getClass().getInterfaces())\n+                        .map(Class::getName)\n+                        .collect(Collectors.joining(\", \")), method.getName());\n+        if (method.isDefault()) {\n+            InvocationHandler.invokeDefault(proxy, method, params);\n+        }\n+        throw new UnsupportedOperationException(method.toString());\n+    };\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/DefaultMethodProxy.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/NonPublicProxyClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+    default String m() { return \"bar\"; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/Bar.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+    default String m() { return \"foo\"; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/Foo.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p;\n+import java.lang.reflect.*;\n+\n+public class ProxyMaker {\n+     public static Object invoke(Object proxy, Method method, Object... args)\n+            throws Throwable {\n+         return InvocationHandler.invokeDefault(proxy, method, args);\n+     }\n+\n+    \/\/ get the invocation handler associated with the proxy\n+    public static InvocationHandler getInvocationHandler(Object proxy) {\n+        return Proxy.getInvocationHandler(proxy);\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/nonPublicProxy\/p\/ProxyMaker.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,2 @@\n+\n+    default int m() { return 1; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m1\/p\/one\/I.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+    default int m() { return 2; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m2\/p\/two\/internal\/C.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+    default int m() {\n+        throw new UnsupportedOperationException(\"Q::m is in a non-exported package\");\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/m3\/p\/three\/internal\/Q.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.UndeclaredThrowableException;\n+\n+\/**\n+ * Tests invocation of default methods in exported types and inaccessible types\n+ * in a named module\n+ *\/\n+public class DefaultMethods {\n+    private final static Module TEST_MODULE = DefaultMethods.class.getModule();\n+    private final static InvocationHandler IH = (proxy, method, params) -> {\n+        return InvocationHandler.invokeDefault(proxy, method, params);\n+    };\n+\n+    public static void main(String... args) throws Throwable {\n+        \/\/ exported types from m1\n+        testDefaultMethod(new Class<?>[] { p.one.I.class, p.two.A.class}, 1);\n+        \/\/ qualified-exported type from m2\n+        testDefaultMethod(new Class<?>[] { p.two.internal.C.class, p.two.A.class }, 2);\n+        \/\/ module-private type from test module\n+        testDefaultMethod(new Class<?>[] { jdk.test.internal.R.class }, 10);\n+        \/\/ non-public interface in the same runtime package\n+        testDefaultMethod(new Class<?>[] { Class.forName(\"jdk.test.NP\") }, 100);\n+\n+        \/\/ inaccessible type - not exported to test module\n+        Class<?> qType = Class.forName(\"p.three.internal.Q\");\n+        inaccessibleDefaultMethod(qType);\n+        \/\/ non-public interface in the same runtime package\n+        Class<?> nonPublicType = Class.forName(\"jdk.test.internal.NP\");\n+        inaccessibleDefaultMethod(nonPublicType);\n+    }\n+\n+    static void testDefaultMethod(Class<?>[] intfs, int expected) throws Exception {\n+        Object proxy = Proxy.newProxyInstance(TEST_MODULE.getClassLoader(), intfs, IH);\n+        if (!proxy.getClass().getModule().isNamed()) {\n+            throw new RuntimeException(proxy.getClass() + \" expected to be in a named module\");\n+        }\n+        Method m = intfs[0].getMethod(\"m\");\n+        int result = (int)m.invoke(proxy);\n+        if (result != expected) {\n+            throw new RuntimeException(\"return value: \" + result + \" expected: \" + expected);\n+        }\n+    }\n+\n+    static void inaccessibleDefaultMethod(Class<?> intf) throws Throwable {\n+        Object proxy = Proxy.newProxyInstance(TEST_MODULE.getClassLoader(), new Class<?>[] { intf }, IH);\n+        if (!proxy.getClass().getModule().isNamed()) {\n+            throw new RuntimeException(proxy.getClass() + \" expected to be in a named module\");\n+        }\n+        Method m = intf.getMethod(\"m\");\n+        try {\n+            InvocationHandler.invokeDefault(proxy, m, null);\n+            throw new RuntimeException(\"IAE not thrown invoking: \" + m);\n+        } catch (IllegalAccessException e) {}\n+\n+        if (m.trySetAccessible()) {\n+            try {\n+                m.invoke(proxy);\n+                throw new RuntimeException(\"IAE not thrown invoking: \" + m);\n+            } catch (InvocationTargetException e) {\n+                \/\/ IAE wrapped by InvocationHandler::invoke with UndeclaredThrowableException\n+                \/\/ then wrapped by Method::invoke with InvocationTargetException\n+                assert e.getCause() instanceof UndeclaredThrowableException;\n+                Throwable cause = e.getCause().getCause();\n+                if (!(cause instanceof IllegalAccessException))\n+                    throw e;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/DefaultMethods.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,0 @@\n-        Module unnamed = ld.getUnnamedModule();\n@@ -71,1 +70,0 @@\n-        Module unnamed2 = ld2.getUnnamedModule();\n@@ -74,11 +72,11 @@\n-            new Data(unnamed,  ld, Runnable.class),\n-            new Data(unnamed,  ld, p.one.I.class),\n-            new Data(unnamed,  ld, p.one.I.class, p.two.A.class),\n-            new Data(unnamed,  ld, p.one.I.class, unnamedModuleClass),\n-            new Data(unnamed2, ld2, Runnable.class),\n-            new Data(unnamed2, ld2, p.one.I.class),\n-            new Data(unnamed2, ld2, p.one.I.class, p.two.A.class),\n-            new Data(unnamed2, ld2, p.one.I.class, unnamedModuleClass),\n-            new Data(unnamed, m1.getClassLoader(), p.one.I.class),\n-            new Data(unnamed, m2.getClassLoader(), p.two.A.class),\n-            new Data(unnamed, m3.getClassLoader(), p.three.P.class),\n+            new Data(ld, Runnable.class),\n+            new Data(ld, p.one.I.class),\n+            new Data(ld, p.one.I.class, p.two.A.class),\n+            new Data(ld, p.one.I.class, unnamedModuleClass),\n+            new Data(ld2, Runnable.class),\n+            new Data(ld2, p.one.I.class),\n+            new Data(ld2, p.one.I.class, p.two.A.class),\n+            new Data(ld2, p.one.I.class, unnamedModuleClass),\n+            new Data(m1.getClassLoader(), p.one.I.class),\n+            new Data(m2.getClassLoader(), p.two.A.class),\n+            new Data(m3.getClassLoader(), p.three.P.class),\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/Main.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+\n+    default int m() {\n+        return 100;\n+    }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/NP.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,4 @@\n-            throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n+            \/\/ the exported package has the same name as the dynamic module\n+            if (!proxyClass.getPackageName().equals(m.getName())) {\n+                throw new RuntimeException(\"Expected IllegalAccessException: \" + proxyClass);\n+            }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/ProxyTest.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.internal;\n+\n+\/*\n+ * Non-public interface\n+ *\/\n+interface NP {\n+    default int m() {\n+        throw new UnsupportedOperationException(\"non-public interface: \" + NP.class.getName());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/internal\/NP.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+\n+    default int m() { return 10; }\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/src\/test\/jdk\/test\/internal\/R.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, NTT DATA.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.consumer.recordingstream;\n+\n+import jdk.jfr.consumer.RecordingStream;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/**\n+* @test\n+* @bug 8257424\n+* @summary Tests recording name for RecordingStrream\n+* @key jfr\n+* @requires vm.hasJFR\n+* @library \/test\/lib\n+* @run main\/othervm jdk.jfr.api.consumer.recordingstream.TestRecordingName\n+*\/\n+public class TestRecordingName {\n+\n+   public static void main(String... args) throws Exception {\n+       try (RecordingStream r = new RecordingStream()) {\n+           r.enable(EventNames.ActiveRecording);\n+           r.onEvent(e -> {\n+               System.out.println(e);\n+               String name = e.getString(\"name\");\n+               if (name.startsWith(\"Recording Stream: \")) {\n+                   r.close();\n+                   return;\n+               }\n+               System.err.println(\"Recording name not set, was \" + name + \", but expected \\\"Recording Stream: <Instant>\\\"\");\n+           });\n+           r.start();\n+       }\n+   }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/recordingstream\/TestRecordingName.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,1 @@\n-                        new StackTraceElement(\"com.sun.proxy.$Proxy0\", \"hashCode\", null, -1),\n+                        new StackTraceElement(\"jdk.proxy1.$Proxy0\", \"hashCode\", null, -1),\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_1.out -XDrawDiagnostics T8255968_1.java\n+ *\/\n+\n+class T8255968_1 {\n+    T8255968_1_Test c = new T8255968_1_Test(0);\n+}\n+\n+class T8255968_1_Test {\n+    private T8255968_1_Test(int x) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_1.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_1.java:32:25: compiler.err.report.access: T8255968_1_Test(int), private, T8255968_1_Test\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_1.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_10.out -XDrawDiagnostics T8255968_10.java\n+ *\/\n+\n+class T8255968_10 {\n+    T8255968_10_TestMethodReference c = T8255968_10_Test::new;\n+}\n+\n+interface T8255968_10_TestMethodReference {\n+    T8255968_10_Test create(int x);\n+}\n+\n+class T8255968_10_Test {\n+    private T8255968_10_Test(int x) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_10.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_10.java:32:41: compiler.err.prob.found.req: (compiler.misc.invalid.mref: kindname.constructor, (compiler.misc.report.access: T8255968_10_Test(int), private, T8255968_10_Test))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_10.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_11.out -XDrawDiagnostics T8255968_11.java\n+ *\/\n+\n+class T8255968_11 {\n+    T8255968_11_TestMethodReference c = T8255968_11_Test::new;\n+}\n+\n+interface T8255968_11_TestMethodReference {\n+    T8255968_11_Test create(int x);\n+}\n+\n+class T8255968_11_Test {\n+    T8255968_11_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_11.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_11.java:32:41: compiler.err.prob.found.req: (compiler.misc.invalid.mref: kindname.constructor, (compiler.misc.cant.apply.symbol: kindname.constructor, T8255968_11_Test, java.lang.String, int, kindname.class, T8255968_11_Test, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String))))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_11.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_12.out -XDrawDiagnostics T8255968_12.java\n+ *\/\n+\n+class T8255968_12 {\n+    T8255968_12_TestMethodReference c = T8255968_12_Test::new;\n+}\n+\n+interface T8255968_12_TestMethodReference {\n+    T8255968_12_Test create(int x);\n+}\n+\n+class T8255968_12_Test {\n+    private T8255968_12_Test(int x) {}  \/\/ This method is not at the end.\n+    T8255968_12_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_12.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_12.java:32:41: compiler.err.prob.found.req: (compiler.misc.invalid.mref: kindname.constructor, (compiler.misc.cant.apply.symbols: kindname.constructor, T8255968_12_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_12_Test, T8255968_12_Test(int), (compiler.misc.report.access: T8255968_12_Test(int), private, T8255968_12_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_12_Test, T8255968_12_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String)))}))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_12.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_13.out -XDrawDiagnostics T8255968_13.java\n+ *\/\n+\n+class T8255968_13 {\n+    T8255968_13_TestMethodReference c = T8255968_13_Test::new;\n+}\n+\n+interface T8255968_13_TestMethodReference {\n+    T8255968_13_Test create(int x);\n+}\n+\n+class T8255968_13_Test {\n+    T8255968_13_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+    private T8255968_13_Test(int x) {}  \/\/ This method is at the end.\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_13.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_13.java:32:41: compiler.err.prob.found.req: (compiler.misc.invalid.mref: kindname.constructor, (compiler.misc.cant.apply.symbols: kindname.constructor, T8255968_13_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_13_Test, T8255968_13_Test(int), (compiler.misc.report.access: T8255968_13_Test(int), private, T8255968_13_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_13_Test, T8255968_13_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String)))}))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_13.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_14.out -XDrawDiagnostics T8255968_14.java\n+ *\/\n+\n+class T8255968_14 {\n+    T8255968_14_TestMethodReference c = T8255968_14_Test::new;\n+}\n+\n+interface T8255968_14_TestMethodReference {\n+    T8255968_14_Test create(int x);\n+}\n+\n+class T8255968_14_Test {\n+    private T8255968_14_Test(int x) {}  \/\/ This method is not at the end.\n+    T8255968_14_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+    private T8255968_14_Test(int[] x) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_14.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_14.java:32:41: compiler.err.prob.found.req: (compiler.misc.invalid.mref: kindname.constructor, (compiler.misc.cant.apply.symbols: kindname.constructor, T8255968_14_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_14_Test, T8255968_14_Test(int), (compiler.misc.report.access: T8255968_14_Test(int), private, T8255968_14_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_14_Test, T8255968_14_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String))),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_14_Test, T8255968_14_Test(int[]), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, int[])))}))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_14.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_15.out -XDrawDiagnostics T8255968_15.java\n+ *\/\n+\n+class T8255968_15 {\n+    T8255968_15_TestMethodReference c = T8255968_15_Test::new;\n+}\n+\n+interface T8255968_15_TestMethodReference {\n+    T8255968_15_Test create(int x);\n+}\n+\n+class T8255968_15_Test {\n+    T8255968_15_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+    private T8255968_15_Test(int x) {}  \/\/ This method is not at the end.\n+    private T8255968_15_Test(int[] x) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_15.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_15.java:32:41: compiler.err.prob.found.req: (compiler.misc.invalid.mref: kindname.constructor, (compiler.misc.cant.apply.symbols: kindname.constructor, T8255968_15_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_15_Test, T8255968_15_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String))),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_15_Test, T8255968_15_Test(int), (compiler.misc.report.access: T8255968_15_Test(int), private, T8255968_15_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_15_Test, T8255968_15_Test(int[]), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, int[])))}))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_15.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_16.out -XDrawDiagnostics T8255968_16.java\n+ *\/\n+\n+class T8255968_16 {\n+    T8255968_16_TestMethodReference c = T8255968_16_Test::new;\n+}\n+\n+interface T8255968_16_TestMethodReference {\n+    T8255968_16_Test create(int x);\n+}\n+\n+class T8255968_16_Test {\n+    T8255968_16_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+    private T8255968_16_Test(int[] x) {}\n+    private T8255968_16_Test(int x) {}  \/\/ This method is at the end.\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_16.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_16.java:32:41: compiler.err.prob.found.req: (compiler.misc.invalid.mref: kindname.constructor, (compiler.misc.cant.apply.symbols: kindname.constructor, T8255968_16_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_16_Test, T8255968_16_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String))),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_16_Test, T8255968_16_Test(int), (compiler.misc.report.access: T8255968_16_Test(int), private, T8255968_16_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_16_Test, T8255968_16_Test(int[]), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, int[])))}))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_16.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_2.out -XDrawDiagnostics T8255968_2.java\n+ *\/\n+\n+class T8255968_2 {\n+    T8255968_2_Test c = new T8255968_2_Test(0);\n+}\n+\n+class T8255968_2_Test {\n+    T8255968_2_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_2.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_2.java:32:25: compiler.err.cant.apply.symbol: kindname.constructor, T8255968_2_Test, java.lang.String, int, kindname.class, T8255968_2_Test, (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String))\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_2.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_3.out -XDrawDiagnostics T8255968_3.java\n+ *\/\n+\n+class T8255968_3 {\n+    T8255968_3_Test c = new T8255968_3_Test(0);\n+}\n+\n+class T8255968_3_Test {\n+    private T8255968_3_Test(int x) {}  \/\/ This method is not at the end.\n+    T8255968_3_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_3.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_3.java:32:25: compiler.err.cant.apply.symbols: kindname.constructor, T8255968_3_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_3_Test, T8255968_3_Test(int), (compiler.misc.report.access: T8255968_3_Test(int), private, T8255968_3_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_3_Test, T8255968_3_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String)))}\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_3.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_4.out -XDrawDiagnostics T8255968_4.java\n+ *\/\n+\n+class T8255968_4 {\n+    T8255968_4_Test c = new T8255968_4_Test(0);\n+}\n+\n+class T8255968_4_Test {\n+    T8255968_4_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+    private T8255968_4_Test(int x) {}  \/\/ This method is at the end.\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_4.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_4.java:32:25: compiler.err.cant.apply.symbols: kindname.constructor, T8255968_4_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_4_Test, T8255968_4_Test(int), (compiler.misc.report.access: T8255968_4_Test(int), private, T8255968_4_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_4_Test, T8255968_4_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String)))}\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_4.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_5.out -XDrawDiagnostics T8255968_5.java\n+ *\/\n+\n+class T8255968_5 {\n+    T8255968_5_Test c = new T8255968_5_Test(0);\n+}\n+\n+class T8255968_5_Test {\n+    private T8255968_5_Test(int x) {}  \/\/ This method is not at the end.\n+    T8255968_5_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+    private T8255968_5_Test(int[] x) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_5.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_5.java:32:25: compiler.err.cant.apply.symbols: kindname.constructor, T8255968_5_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_5_Test, T8255968_5_Test(int), (compiler.misc.report.access: T8255968_5_Test(int), private, T8255968_5_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_5_Test, T8255968_5_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String))),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_5_Test, T8255968_5_Test(int[]), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, int[])))}\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_5.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_6.out -XDrawDiagnostics T8255968_6.java\n+ *\/\n+\n+class T8255968_6 {\n+    T8255968_6_Test c = new T8255968_6_Test(0);\n+}\n+\n+class T8255968_6_Test {\n+    T8255968_6_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+    private T8255968_6_Test(int x) {}  \/\/ This method is not at the end.\n+    private T8255968_6_Test(int[] x) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_6.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_6.java:32:25: compiler.err.cant.apply.symbols: kindname.constructor, T8255968_6_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_6_Test, T8255968_6_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String))),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_6_Test, T8255968_6_Test(int), (compiler.misc.report.access: T8255968_6_Test(int), private, T8255968_6_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_6_Test, T8255968_6_Test(int[]), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, int[])))}\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_6.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile\/fail\/ref=T8255968_7.out -XDrawDiagnostics T8255968_7.java\n+ *\/\n+\n+class T8255968_7 {\n+    T8255968_7_Test c = new T8255968_7_Test(0);\n+}\n+\n+class T8255968_7_Test {\n+    T8255968_7_Test(String x) {}  \/\/ If this method is private, compiler will output the same error message.\n+    private T8255968_7_Test(int[] x) {}\n+    private T8255968_7_Test(int x) {}  \/\/ This method is at the end.\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_7.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+T8255968_7.java:32:25: compiler.err.cant.apply.symbols: kindname.constructor, T8255968_7_Test, int,{(compiler.misc.inapplicable.method: kindname.constructor, T8255968_7_Test, T8255968_7_Test(java.lang.String), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, java.lang.String))),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_7_Test, T8255968_7_Test(int), (compiler.misc.report.access: T8255968_7_Test(int), private, T8255968_7_Test)),(compiler.misc.inapplicable.method: kindname.constructor, T8255968_7_Test, T8255968_7_Test(int[]), (compiler.misc.no.conforming.assignment.exists: (compiler.misc.inconvertible.types: int, int[])))}\n+1 error\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_7.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile -XDrawDiagnostics T8255968_8.java\n+ *\/\n+\n+class T8255968_8_Outer {\n+    void m() {}\n+    void m(String s) {}\n+\n+    class T8255968_8_Inner extends T8255968_8_Sup {\n+        void test() {\n+            m();\n+        }\n+    }\n+}\n+\n+class T8255968_8_Sup {\n+    private void m(String s) {}\n+    private void m() {}\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_8.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255968\n+ * @summary Confusing error message for inaccessible constructor\n+ * @run compile -XDrawDiagnostics T8255968_9.java\n+ *\/\n+\n+class T8255968_9 {\n+    T8255968_9_TestMethodReference c = T8255968_9_Test::new;\n+}\n+\n+interface T8255968_9_TestMethodReference {\n+    T8255968_9_Test create(int x);\n+}\n+\n+class T8255968_9_Test {\n+    T8255968_9_Test(int x) {}\n+}\n","filename":"test\/langtools\/tools\/javac\/T8255968\/T8255968_9.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -27,0 +27,12 @@\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n@@ -28,0 +40,1 @@\n+import java.lang.reflect.Method;\n@@ -29,1 +42,1 @@\n-import java.util.concurrent.Callable;\n+import java.util.concurrent.ThreadLocalRandom;\n@@ -32,3 +45,0 @@\n-@Warmup(iterations = 5)\n-@Measurement(iterations = 10)\n-@Fork(value = 1)\n@@ -36,0 +46,1 @@\n+@Fork(1)\n@@ -37,1 +48,3 @@\n-@State(Scope.Thread)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 2)\n+@State(Scope.Benchmark)\n@@ -39,0 +52,3 @@\n+    Interfaze implClass, implProxy;\n+    PpInterfaze ppImplClass, ppImplProxy;\n+    int a, b, c;\n@@ -40,17 +56,14 @@\n-    \/**\n-     * On Dell T7610:\n-     *\n-     * Benchmark w\/ the old ProxyGenerator\n-     * Benchmark                      Mode  Cnt   Score   Error  Units\n-     * ProxyBench.getProxyClass1i     avgt   10  20.472 +\/- 0.209  ns\/op\n-     * ProxyBench.getProxyClass4i     avgt   10  57.353 +\/- 0.461  ns\/op\n-     * ProxyBench.newProxyInstance1i  avgt   10  31.459 +\/- 0.516  ns\/op\n-     * ProxyBench.newProxyInstance4i  avgt   10  66.580 +\/- 0.983  ns\/op\n-     *\n-     * Benchmark w\/ the new ProxyGenerator using ASM\n-     * Benchmark                      Mode  Cnt   Score   Error  Units\n-     * ProxyBench.getProxyClass1i     avgt   10  21.291 +\/- 0.475  ns\/op\n-     * ProxyBench.getProxyClass4i     avgt   10  61.481 +\/- 4.709  ns\/op\n-     * ProxyBench.newProxyInstance1i  avgt   10  30.177 +\/- 0.761  ns\/op\n-     * ProxyBench.newProxyInstance4i  avgt   10  68.302 +\/- 1.344  ns\/op\n-     *\/\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        implClass = new Clazz();\n+        implProxy = (Interfaze) Proxy.newProxyInstance(\n+                Interfaze.class.getClassLoader(),\n+                new Class<?>[]{Interfaze.class},\n+                new IHandler()\n+        );\n+        ppImplClass = new PpClazz();\n+        ppImplProxy = (PpInterfaze) Proxy.newProxyInstance(\n+                PpInterfaze.class.getClassLoader(),\n+                new Class<?>[]{PpInterfaze.class},\n+                new IHandler()\n+        );\n@@ -58,2 +71,4 @@\n-    interface PkgPrivate1 {\n-        void m1();\n+        ThreadLocalRandom tlr = ThreadLocalRandom.current();\n+        a = tlr.nextInt();\n+        b = tlr.nextInt();\n+        c = tlr.nextInt();\n@@ -62,2 +77,3 @@\n-    interface PkgPrivate2 {\n-        void m2();\n+    @Benchmark\n+    public int implClass() {\n+        return implClass.sum(a, b, c);\n@@ -66,9 +82,0 @@\n-    static final InvocationHandler handler = (proxy, method, args) -> null;\n-\n-    static final ClassLoader loader1 = null;\n-    static final Class<?>[] interfaces1 = {Runnable.class};\n-\n-    static final ClassLoader loader4 = PkgPrivate1.class.getClassLoader();\n-    static final Class<?>[] interfaces4 = {Runnable.class, Callable.class,\n-                                           PkgPrivate1.class, PkgPrivate2.class};\n-\n@@ -76,3 +83,2 @@\n-    @SuppressWarnings(\"deprecation\")\n-    public Class<?> getProxyClass1i() {\n-        return Proxy.getProxyClass(loader1, interfaces1);\n+    public int implProxy() {\n+        return implProxy.sum(a, b, c);\n@@ -82,3 +88,2 @@\n-    @SuppressWarnings(\"deprecation\")\n-    public Class<?> getProxyClass4i() {\n-        return Proxy.getProxyClass(loader4, interfaces4);\n+    public int ppImplClass() {\n+        return ppImplClass.sum(a, b, c);\n@@ -88,2 +93,2 @@\n-    public Object newProxyInstance1i() {\n-        return Proxy.newProxyInstance(loader1, interfaces1, handler);\n+    public int ppImplProxy() {\n+        return ppImplProxy.sum(a, b, c);\n@@ -92,3 +97,31 @@\n-    @Benchmark\n-    public Object newProxyInstance4i() {\n-        return Proxy.newProxyInstance(loader4, interfaces4, handler);\n+    public interface Interfaze {\n+        default int sum(int a, int b, int c) {\n+            return a + b + c;\n+        }\n+    }\n+\n+    static class Clazz implements Interfaze {\n+        @Override\n+        public int sum(int a, int b, int c) {\n+            return Interfaze.super.sum(a, b, c);\n+        }\n+    }\n+\n+    interface PpInterfaze {\n+        default int sum(int a, int b, int c) {\n+            return a + b + c;\n+        }\n+    }\n+\n+    static class PpClazz implements PpInterfaze {\n+        @Override\n+        public int sum(int a, int b, int c) {\n+            return PpInterfaze.super.sum(a, b, c);\n+        }\n+    }\n+\n+    static class IHandler implements InvocationHandler {\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return InvocationHandler.invokeDefault(proxy, method, args);\n+        }\n@@ -96,1 +129,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/Proxy\/ProxyBench.java","additions":80,"deletions":47,"binary":false,"changes":127,"status":"modified"}]}