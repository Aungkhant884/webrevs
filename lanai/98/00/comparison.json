{"files":[{"patch":"@@ -27,1 +27,2 @@\n-@property jboolean aa;\n+@property (assign) jboolean aa;\n+@property (retain) MTLPaint* paint;\n@@ -62,0 +63,1 @@\n+@synthesize paint = _paint;\n@@ -145,1 +147,1 @@\n-    [_paint copyFrom:mtlc.paint];\n+    self.paint = mtlc.paint;\n@@ -153,0 +155,1 @@\n+\n@@ -158,4 +161,4 @@\n-        [mtlc.paint setPipelineState:encoder\n-                        context:mtlc\n-                  renderOptions:renderOptions\n-           pipelineStateStorage:_pipelineStateStorage];\n+        [mtlc.paint  setPipelineState:encoder\n+                              context:mtlc\n+                        renderOptions:renderOptions\n+                 pipelineStateStorage:_pipelineStateStorage];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/EncoderManager.m","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-@property (readonly) MTLPaint * paint;\n+@property (readwrite, retain) MTLPaint * paint;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-            texturePool;\n+            texturePool, paint=_paint;\n@@ -321,1 +321,1 @@\n-    [_paint reset];\n+    self.paint = [[[MTLPaint alloc] init] autorelease];\n@@ -326,1 +326,1 @@\n-    [_paint setColor:pixel];\n+    self.paint = [[[MTLColorPaint alloc] initWithColor:pixel] autorelease];\n@@ -338,7 +338,7 @@\n-    [_paint setGradientUseMask:useMask\n-                            cyclic:cyclic\n-                                p0:p0\n-                                p1:p1\n-                                p3:p3\n-                            pixel1:pixel1\n-                            pixel2:pixel2];\n+    self.paint = [[[MTLGradPaint alloc] initWithUseMask:useMask\n+                                                cyclic:cyclic\n+                                                    p0:p0\n+                                                    p1:p1\n+                                                    p3:p3\n+                                                pixel1:pixel1\n+                                                pixel2:pixel2] autorelease];\n@@ -362,1 +362,1 @@\n-    [_paint setLinearGradient:useMask\n+    self.paint = [[[MTLLinearGradPaint alloc] initWithUseMask:useMask\n@@ -370,1 +370,1 @@\n-                       pixels:pixels];\n+                       pixels:pixels] autorelease];\n@@ -388,13 +388,13 @@\n-    [_paint setRadialGradient:useMask\n-                       linear:linear\n-                  cycleMethod:cycleMethod\n-                     numStops:numStops\n-                          m00:m00\n-                          m01:m01\n-                          m02:m02\n-                          m10:m10\n-                          m11:m11\n-                          m12:m12\n-                       focusX:focusX\n-                    fractions:fractions\n-                       pixels:pixels];\n+    self.paint = [[[MTLRadialGradPaint alloc] initWithUseMask:useMask\n+                                                      linear:linear\n+                                                 cycleMethod:cycleMethod\n+                                                    numStops:numStops\n+                                                         m00:m00\n+                                                         m01:m01\n+                                                         m02:m02\n+                                                         m10:m10\n+                                                         m11:m11\n+                                                         m12:m12\n+                                                      focusX:focusX\n+                                                   fractions:fractions\n+                                                      pixels:pixels] autorelease];\n@@ -422,10 +422,9 @@\n-\n-    [_paint setTexture:useMask\n-               textureID:srcOps->pTexture\n-                filter:filter\n-                   xp0:xp0\n-                   xp1:xp1\n-                   xp3:xp3\n-                   yp0:yp0\n-                   yp1:yp1\n-                   yp3:yp3];\n+    self.paint = [[[MTLTexturePaint alloc] initWithUseMask:useMask\n+                                                textureID:srcOps->pTexture\n+                                                   filter:filter\n+                                                      xp0:xp0\n+                                                      xp1:xp1\n+                                                      xp3:xp3\n+                                                      yp0:yp0\n+                                                      yp1:yp1\n+                                                      yp3:yp3] autorelease] ;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.m","additions":34,"deletions":35,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#import <awt\/common.h>\n@@ -44,1 +45,2 @@\n-- (id)init;\n+\n+- (id)initWithState:(jint)state;\n@@ -46,1 +48,0 @@\n-- (void)copyFrom:(MTLPaint *)other; \/\/ used to save cached\n@@ -48,45 +49,0 @@\n-- (jint)getColor;\n-- (void)reset;\n-\n-- (void)setColor:(jint)pixelColor;\n-- (void)setGradientUseMask:(jboolean)useMask\n-                    cyclic:(jboolean)cyclic\n-                        p0:(jdouble)p0\n-                        p1:(jdouble)p1\n-                        p3:(jdouble)p3\n-                    pixel1:(jint)pixel1\n-                    pixel2:(jint)pixel2;\n-\n-- (void)setLinearGradient:(jboolean)useMask\n-                   linear:(jboolean)linear\n-              cycleMethod:(jboolean)cycleMethod\n-                 numStops:(jint)numStops\n-                       p0:(jfloat)p0\n-                       p1:(jfloat)p1\n-                       p3:(jfloat)p3\n-                fractions:(jfloat *)fractions\n-                   pixels:(jint *)pixels;\n-\n-- (void)setRadialGradient:(jboolean)useMask\n-                   linear:(jboolean)linear\n-              cycleMethod:(jint)cycleMethod\n-                 numStops:(jint)numStops\n-                      m00:(jfloat)m00\n-                      m01:(jfloat)m01\n-                      m02:(jfloat)m02\n-                      m10:(jfloat)m10\n-                      m11:(jfloat)m11\n-                      m12:(jfloat)m12\n-                   focusX:(jfloat)focusX\n-                fractions:(void *)fractions\n-                   pixels:(void *)pixels;\n-\n-- (void)setTexture:(jboolean)useMask\n-           textureID:(id<MTLTexture>)textureID\n-            filter:(jboolean)filter\n-               xp0:(jdouble)xp0\n-               xp1:(jdouble)xp1\n-               xp3:(jdouble)xp3\n-               yp0:(jdouble)yp0\n-               yp1:(jdouble)yp1\n-               yp3:(jdouble)yp3;\n@@ -97,0 +53,1 @@\n+\n@@ -102,0 +59,1 @@\n+\n@@ -108,0 +66,79 @@\n+@interface MTLColorPaint : MTLPaint\n+- (id)initWithColor:(jint)color;\n+@property (nonatomic, readonly) jint color;\n+@end\n+\n+@interface MTLBaseGradPaint : MTLPaint {\n+@public\n+    jint _cyclic;\n+}\n+- (id)initWithState:(jint)state\n+               mask:(jboolean)useMask\n+             cyclic:(jboolean)cyclic;\n+@end\n+\n+@interface MTLGradPaint : MTLBaseGradPaint\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+               cyclic:(jboolean)cyclic\n+                   p0:(jdouble)p0\n+                   p1:(jdouble)p1\n+                   p3:(jdouble)p3\n+               pixel1:(jint)pixel1\n+               pixel2:(jint)pixel2;\n+@end\n+\n+@interface MTLBaseMultiGradPaint : MTLBaseGradPaint\n+\n+- (id)initWithState:(jint)state\n+               mask:(jboolean)useMask\n+             linear:(jboolean)linear\n+        cycleMethod:(jboolean)cycleMethod\n+           numStops:(jint)numStops\n+          fractions:(jfloat *)fractions\n+             pixels:(jint *)pixels;\n+@end\n+\n+@interface MTLLinearGradPaint : MTLBaseMultiGradPaint\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+               linear:(jboolean)linear\n+          cycleMethod:(jboolean)cycleMethod\n+             numStops:(jint)numStops\n+                   p0:(jfloat)p0\n+                   p1:(jfloat)p1\n+                   p3:(jfloat)p3\n+            fractions:(jfloat *)fractions\n+               pixels:(jint *)pixels;\n+@end\n+\n+@interface MTLRadialGradPaint : MTLBaseMultiGradPaint\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+               linear:(jboolean)linear\n+          cycleMethod:(jint)cycleMethod\n+             numStops:(jint)numStops\n+                  m00:(jfloat)m00\n+                  m01:(jfloat)m01\n+                  m02:(jfloat)m02\n+                  m10:(jfloat)m10\n+                  m11:(jfloat)m11\n+                  m12:(jfloat)m12\n+               focusX:(jfloat)focusX\n+            fractions:(void *)fractions\n+               pixels:(void *)pixels;\n+@end\n+\n+@interface MTLTexturePaint : MTLPaint\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+              textureID:(id <MTLTexture>)textureID\n+                 filter:(jboolean)filter\n+                    xp0:(jdouble)xp0\n+                    xp1:(jdouble)xp1\n+                    xp3:(jdouble)xp3\n+                    yp0:(jdouble)yp0\n+                    yp1:(jdouble)yp1\n+                    yp3:(jdouble)yp3;\n+@end\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.h","additions":84,"deletions":47,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -59,0 +59,4 @@\n+static void setTxtUniforms(\n+        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,\n+        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags\n+);\n@@ -96,6 +100,0 @@\n-@implementation MTLPaint {\n-    \/\/ TODO: remove paintState, split into heirarchy of Paint-objects (i.e. PaintColor, PaintGrad, e.t.c)\n-    jint          _paintState;\n-\n-    \/\/ color-mode\n-    jint          _color;\n@@ -103,24 +101,3 @@\n-    \/\/ grad-mode\n-    jdouble       _p0;\n-    jdouble       _p1;\n-    jdouble       _p3;\n-    jint          _cyclic;\n-    jboolean      _useMask;\n-    jint          _pixel[GRAD_MAX_FRACTIONS];\n-    jfloat        _fract[GRAD_MAX_FRACTIONS];\n-\n-    \/\/ lin-grad-mode\n-    jint          _numFracts;\n-    jboolean      _linear;\n-\n-    \/\/ rad-grad-mode\n-    jfloat        _m00;\n-    jfloat        _m01;\n-    jfloat        _m02;\n-    jfloat        _m10;\n-    jfloat        _m11;\n-    jfloat        _m12;\n-    jfloat        _focusX;\n-    \/\/ texture paint\n-    id<MTLTexture> _paintTexture;\n-    struct AnchorData _anchor;\n+@implementation MTLColorPaint {\n+\/\/ color-mode\n+jint _color;\n@@ -128,0 +105,2 @@\n+- (id)initWithColor:(jint)color {\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR];\n@@ -129,2 +108,0 @@\n-- (id)init {\n-    self = [super init];\n@@ -132,1 +109,1 @@\n-        _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;\n+        _color = color;\n@@ -137,2 +114,6 @@\n-- (BOOL)isEqual:(MTLPaint *)other {\n-    if (self == other)\n+- (jint)color {\n+    return _color;\n+}\n+\n+- (BOOL)isEqual:(MTLColorPaint *)other {\n+    if (other == self)\n@@ -140,3 +121,1 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)\n-        return _paintState == other->_paintState;\n-    if (_paintState != other->_paintState)\n+    if (!other || ![[other class] isEqual:[self class]])\n@@ -144,7 +123,0 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {\n-        return _p0 == other->_p0\n-               && _p1 == other->_p1\n-               && _p3 == other->_p3\n-               && _pixel[0] == other->_pixel[0]\n-               && _pixel[1] == other->_pixel[1];\n-    }\n@@ -152,5 +124,2 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_LIN_GRADIENT) {\n-        if (_p0 != other->_p0\n-            || _p1 != other->_p1\n-            || _p3 != other->_p3\n-            || _numFracts != other->_numFracts) return NO;\n+    return _color == other->_color;\n+}\n@@ -158,0 +127,5 @@\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + _color;\n+    return h;\n+}\n@@ -159,6 +133,15 @@\n-        for (int i = 0; i < _numFracts; i++) {\n-            if (_fract[i] != other->_fract[i]) return NO;\n-            if (_pixel[i] != other->_pixel[i]) return NO;\n-        }\n-        return YES;\n-    }\n+- (NSString *)description {\n+    return [NSString stringWithFormat:\n+            @\"[r=%d g=%d b=%d a=%d]\",\n+            (_color >> 16) & (0xFF),\n+            (_color >> 8) & 0xFF,\n+            (_color) & 0xFF,\n+            (_color >> 24) & 0xFF];\n+}\n+\n+- (void)setPipelineState:(id<MTLRenderCommandEncoder>)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    initTemplatePipelineDescriptors();\n@@ -166,9 +149,1 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n-        if (_m00 != other->_m00\n-            || _m01 != other->_m01\n-            || _m02 != other->_m02\n-            || _m10 != other->_m10\n-            || _m11 != other->_m11\n-            || _m12 != other->_m12\n-            || _focusX != other->_focusX\n-            || _numFracts != other->_numFracts) return NO;\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n@@ -176,0 +151,2 @@\n+    NSString *vertShader = @\"vert_col\";\n+    NSString *fragShader = @\"frag_col\";\n@@ -177,3 +154,7 @@\n-        for (int i = 0; i < _numFracts; i++) {\n-            if (_fract[i] != other->_fract[i]) return NO;\n-            if (_pixel[i] != other->_pixel[i]) return NO;\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt\";\n+        fragShader = @\"frag_txt\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+        if (renderOptions->isAA) {\n+            fragShader = @\"aa_frag_txt\";\n+            rpDesc = [[templateAATexturePipelineDesc copy] autorelease];\n@@ -181,1 +162,5 @@\n-        return YES;\n+        setTxtUniforms(encoder, _color, 1,\n+                       renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha], &renderOptions->srcFlags,\n+                       &renderOptions->dstFlags);\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n@@ -184,2 +169,44 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {\n-        return _color == other->_color;\n+    struct FrameUniforms uf = {RGBA_TO_V4(_color)};\n+    [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+- (void)setXorModePipelineState:(id<MTLRenderCommandEncoder>)encoder\n+                        context:(MTLContext *)mtlc\n+                  renderOptions:(const RenderOptions *)renderOptions\n+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    initTemplatePipelineDescriptors();\n+    NSString * vertShader = @\"vert_col_xorMode\";\n+    NSString * fragShader = @\"frag_col_xorMode\";\n+    MTLRenderPipelineDescriptor * rpDesc = nil;\n+    jint xorColor = (jint) [mtlc.composite getXorColor];\n+    \/\/ Calculate _color ^ xorColor for RGB components\n+    \/\/ This color gets XORed with destination framebuffer pixel color\n+    const int col = _color ^ xorColor;\n+    BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_xorMode\";\n+        fragShader = @\"frag_txt_xorMode\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+\n+        setTxtUniforms(encoder, col, 1,\n+                       renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha],\n+                       &renderOptions->srcFlags, &renderOptions->dstFlags);\n+        [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex:0];\n+\n+        [encoder setFragmentTexture:dstOps->pTexture atIndex:1];\n+    } else {\n+        struct FrameUniforms uf = {RGBA_TO_V4(col)};\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+\n+        [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n+        [encoder setFragmentTexture:dstOps->pTexture atIndex:0];\n@@ -187,8 +214,21 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {\n-        return _paintTexture == other->_paintTexture\n-               && _anchor.xParams[0] == other->_anchor.xParams[0]\n-               && _anchor.xParams[1] == other->_anchor.xParams[1]\n-               && _anchor.xParams[2] == other->_anchor.xParams[2]\n-               && _anchor.yParams[0] == other->_anchor.yParams[0]\n-               && _anchor.yParams[1] == other->_anchor.yParams[1]\n-               && _anchor.yParams[2] == other->_anchor.yParams[2];\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+@end\n+\n+@implementation MTLBaseGradPaint {\n+    jboolean      _useMask;\n+}\n+\n+- (id)initWithState:(jint)state mask:(jboolean)useMask cyclic:(jboolean)cyclic {\n+    self = [super initWithState:state];\n+\n+    if (self) {\n+        _useMask = useMask;\n+        _cyclic = cyclic;\n@@ -196,0 +236,8 @@\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLBaseGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]])\n+        return NO;\n@@ -197,2 +245,1 @@\n-    J2dTraceLn1(J2D_TRACE_ERROR, \"Unimplemented paint mode %d\", _paintState);\n-    return NO;\n+    return [super isEqual:self] && _cyclic == other->_cyclic && _useMask == other->_useMask;\n@@ -201,4 +248,6 @@\n-- (void)copyFrom:(MTLPaint *)other {\n-    _paintState = other->_paintState;\n-    if (other->_paintState == sun_java2d_SunGraphics2D_PAINT_UNDEFINED)\n-        return;\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + _cyclic;\n+    h = h*31 + _useMask;\n+    return h;\n+}\n@@ -206,7 +255,27 @@\n-    if (other->_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {\n-        _p0 = other->_p0;\n-        _p1 = other->_p1;\n-        _p3 = other->_p3;\n-        _pixel[0] = other->_pixel[0];\n-        _pixel[1] = other->_pixel[1];\n-        return;\n+@end\n+\n+@implementation MTLGradPaint {\n+    jdouble _p0;\n+    jdouble _p1;\n+    jdouble _p3;\n+    jint _pixel1;\n+    jint _pixel2;\n+}\n+- (id)initWithUseMask:(jboolean)useMask\n+               cyclic:(jboolean)cyclic\n+                   p0:(jdouble)p0\n+                   p1:(jdouble)p1\n+                   p3:(jdouble)p3\n+               pixel1:(jint)pixel1\n+               pixel2:(jint)pixel2\n+{\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_GRADIENT\n+                           mask:useMask\n+                         cyclic:cyclic];\n+\n+    if (self) {\n+        _p0 = p0;\n+        _p1 = p1;\n+        _p3 = p3;\n+        _pixel1 = pixel1;\n+        _pixel2 = pixel2;\n@@ -214,0 +283,8 @@\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]])\n+        return NO;\n@@ -215,1 +292,4 @@\n-    if (other->_paintState == sun_java2d_SunGraphics2D_PAINT_LIN_GRADIENT) {\n+    return [super isEqual:self] && _p0 == other->_p0 &&\n+           _p1 == other->_p1 && _p3 == other->_p3 &&\n+           _pixel1 == other->_pixel1 && _pixel2 == other->_pixel2;\n+}\n@@ -217,8 +297,38 @@\n-        _p0 = other->_p0;\n-        _p1 = other->_p1;\n-        _p3 = other->_p3;\n-        _cyclic = other->_cyclic;\n-        memcpy(_fract, other->_fract, other->_numFracts*sizeof(jfloat));\n-        memcpy(_pixel, other->_pixel, other->_numFracts*sizeof(jint));\n-        _numFracts = other->_numFracts;\n-        return;\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + [@(_p0) hash];\n+    h = h*31 + [@(_p1) hash];;\n+    h = h*31 + [@(_p3) hash];;\n+    h = h*31 + _pixel1;\n+    h = h*31 + _pixel2;\n+    return h;\n+}\n+- (NSString *)description {\n+    return [NSString stringWithFormat:@\"gradient\"];\n+}\n+\n+- (void)setPipelineState:(id)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    initTemplatePipelineDescriptors();\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n+\n+    NSString *vertShader = @\"vert_grad\";\n+    NSString *fragShader = @\"frag_grad\";\n+\n+    struct GradFrameUniforms uf = {\n+            {_p0, _p1, _p3},\n+            RGBA_TO_V4(_pixel1),\n+            RGBA_TO_V4(_pixel2),\n+            _cyclic\n+    };\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_grad\";\n+        fragShader = @\"frag_txt_grad\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n@@ -227,14 +337,70 @@\n-    if (other->_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n-\n-        _m00 = other->_m00;\n-        _m01 = other->_m01;\n-        _m02 = other->_m02;\n-        _m10 = other->_m10;\n-        _m11 = other->_m11;\n-        _m12 = other->_m12;\n-        _focusX = other->_focusX;\n-        _cyclic = other->_cyclic;\n-        memcpy(_fract, other->_fract, other->_numFracts*sizeof(jfloat));\n-        memcpy(_pixel, other->_pixel, other->_numFracts*sizeof(jint));\n-        _numFracts = other->_numFracts;\n-        return;\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+- (void)setXorModePipelineState:(id)encoder\n+                        context:(MTLContext *)mtlc\n+                  renderOptions:(const RenderOptions *)renderOptions\n+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    \/\/ This block is not reached in current implementation.\n+    \/\/ Gradient paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)\n+    NSString* vertShader = @\"vert_grad_xorMode\";\n+    NSString* fragShader = @\"frag_grad_xorMode\";\n+    MTLRenderPipelineDescriptor *rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+    jint xorColor = (jint) [mtlc.composite getXorColor];\n+\n+    struct GradFrameUniforms uf = {\n+            {_p0, _p1, _p3},\n+            RGBA_TO_V4(_pixel1 ^ xorColor),\n+            RGBA_TO_V4(_pixel2 ^ xorColor),\n+            _cyclic\n+    };\n+\n+    [encoder setFragmentBytes: &uf length:sizeof(uf) atIndex:0];\n+    BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+    [encoder setFragmentTexture:dstOps->pTexture atIndex:0];\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints - setXorModePipelineState -- PAINT_GRADIENT\");\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+@end\n+\n+@implementation MTLBaseMultiGradPaint {\n+    jboolean _linear;\n+    @protected\n+    jint _numFracts;\n+    jfloat _fract[GRAD_MAX_FRACTIONS];\n+    jint _pixel[GRAD_MAX_FRACTIONS];\n+}\n+\n+- (id)initWithState:(jint)state\n+               mask:(jboolean)useMask\n+             linear:(jboolean)linear\n+        cycleMethod:(jboolean)cycleMethod\n+           numStops:(jint)numStops\n+          fractions:(jfloat *)fractions\n+             pixels:(jint *)pixels\n+{\n+    self = [super initWithState:state\n+                           mask:useMask\n+                         cyclic:cycleMethod];\n+\n+    if (self) {\n+        _linear = linear;\n+        memcpy(_fract, fractions,numStops*sizeof(jfloat));\n+        memcpy(_pixel, pixels, numStops*sizeof(jint));\n+        _numFracts = numStops;\n@@ -242,0 +408,2 @@\n+    return self;\n+}\n@@ -243,3 +411,11 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {\n-        _color = other->_color;\n-        return;\n+- (BOOL)isEqual:(MTLBaseMultiGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]])\n+        return NO;\n+\n+    if (_numFracts != other->_numFracts || ![super isEqual:self])\n+        return NO;\n+    for (int i = 0; i < _numFracts; i++) {\n+        if (_fract[i] != other->_fract[i]) return NO;\n+        if (_pixel[i] != other->_pixel[i]) return NO;\n@@ -247,0 +423,2 @@\n+    return YES;\n+}\n@@ -248,5 +426,6 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {\n-        _color = other->_color;\n-        _paintTexture = other->_paintTexture;\n-        _anchor = other->_anchor;\n-        return;\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + _numFracts;\n+    for (int i = 0; i < _numFracts; i++) {\n+        h = h*31 + [@(_fract[i]) hash];\n+        h = h*31 + _pixel[i];\n@@ -254,0 +433,4 @@\n+    return h;\n+}\n+\n+@end\n@@ -255,1 +438,4 @@\n-    J2dTraceLn1(J2D_TRACE_ERROR, \"Unsupported paint mode %d\", _paintState);\n+@implementation MTLLinearGradPaint {\n+    jdouble _p0;\n+    jdouble _p1;\n+    jdouble _p3;\n@@ -257,0 +443,4 @@\n+- (void)setPipelineState:(id)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n@@ -258,8 +448,2 @@\n-- (NSString *)getDescription {\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {\n-        return [NSString stringWithFormat:@\"[r=%d g=%d b=%d a=%d]\", (_color >> 16) & (0xFF), (_color >> 8) & 0xFF, (_color) & 0xFF, (_color >> 24) & 0xFF];\n-    }\n-    \n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {\n-        return [NSString stringWithFormat:@\"gradient\"];\n-    }\n+{\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n@@ -267,2 +451,9 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_LIN_GRADIENT) {\n-        return [NSString stringWithFormat:@\"linear_gradient\"];\n+    NSString *vertShader = @\"vert_grad\";\n+    NSString *fragShader = @\"frag_lin_grad\";\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_grad\";\n+        fragShader = @\"frag_txt_lin_grad\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n@@ -271,2 +462,12 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n-        return [NSString stringWithFormat:@\"radial_gradient\"];\n+    struct LinGradFrameUniforms uf = {\n+            {_p0, _p1, _p3},\n+            {},\n+            {},\n+            _numFracts,\n+            _cyclic\n+    };\n+\n+    memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n+    for (int i = 0; i < _numFracts; i++) {\n+        vector_float4 v = RGBA_TO_V4(_pixel[i]);\n+        uf.color[i] = v;\n@@ -274,0 +475,1 @@\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n@@ -275,2 +477,31 @@\n-    if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {\n-        return [NSString stringWithFormat:@\"texture_paint\"];\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+               linear:(jboolean)linear\n+          cycleMethod:(jboolean)cycleMethod\n+             numStops:(jint)numStops\n+                   p0:(jfloat)p0\n+                   p1:(jfloat)p1\n+                   p3:(jfloat)p3\n+            fractions:(jfloat *)fractions\n+               pixels:(jint *)pixels\n+{\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_LIN_GRADIENT\n+                           mask:useMask\n+                         linear:linear\n+                    cycleMethod:cycleMethod\n+                       numStops:numStops\n+                      fractions:fractions\n+                         pixels:pixels];\n+\n+    if (self) {\n+        _p0 = p0;\n+        _p1 = p1;\n+        _p3 = p3;\n@@ -278,0 +509,2 @@\n+    return self;\n+}\n@@ -279,1 +512,7 @@\n-    return @\"unknown-paint\";\n+- (BOOL)isEqual:(MTLLinearGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]] || ![super isEqual:other])\n+        return NO;\n+\n+    return _p0 == other->_p0 && _p1 == other->_p1 && _p3 == other->_p3;\n@@ -282,2 +521,6 @@\n-- (jint)getColor {\n-    return _color;\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + [@(_p0) hash];\n+    h = h*31 + [@(_p1) hash];\n+    h = h*31 + [@(_p3) hash];\n+    return h;\n@@ -286,5 +529,2 @@\n-- (void)reset {\n-    _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;\n-    _paintTexture = nil;\n-    _anchor.xParams[0] = _anchor.xParams[1] = _anchor.xParams[2] = 0.0f;\n-    _anchor.yParams[0] = _anchor.yParams[1] = _anchor.yParams[2] = 0.0f; \n+- (NSString *)description {\n+    return [NSString stringWithFormat:@\"linear_gradient\"];\n@@ -292,0 +532,1 @@\n+@end\n@@ -293,3 +534,8 @@\n-- (void)setColor:(jint)pixelColor {\n-    _paintState = sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR;\n-    _color = pixelColor;\n+@implementation MTLRadialGradPaint {\n+    jfloat _m00;\n+    jfloat _m01;\n+    jfloat _m02;\n+    jfloat _m10;\n+    jfloat _m11;\n+    jfloat _m12;\n+    jfloat _focusX;\n@@ -298,7 +544,13 @@\n-- (void)setGradientUseMask:(jboolean)useMask\n-                    cyclic:(jboolean)cyclic\n-                        p0:(jdouble)p0\n-                        p1:(jdouble)p1\n-                        p3:(jdouble)p3\n-                    pixel1:(jint)pixel1\n-                    pixel2:(jint)pixel2\n+- (id)initWithUseMask:(jboolean)useMask\n+               linear:(jboolean)linear\n+          cycleMethod:(jint)cycleMethod\n+             numStops:(jint)numStops\n+                  m00:(jfloat)m00\n+                  m01:(jfloat)m01\n+                  m02:(jfloat)m02\n+                  m10:(jfloat)m10\n+                  m11:(jfloat)m11\n+                  m12:(jfloat)m12\n+               focusX:(jfloat)focusX\n+            fractions:(void *)fractions\n+               pixels:(void *)pixels\n@@ -306,19 +558,51 @@\n-    _paintState = sun_java2d_SunGraphics2D_PAINT_GRADIENT;\n-    _useMask = useMask;\n-    _pixel[0] = pixel1;\n-    _pixel[1] = pixel2;\n-    _p0 = p0;\n-    _p1 = p1;\n-    _p3 = p3;\n-    _cyclic = cyclic;\n-}\n-\n-- (void)setLinearGradient:(jboolean)useMask\n-                   linear:(jboolean)linear\n-              cycleMethod:(jboolean)cycleMethod\n-                 numStops:(jint)numStops\n-                       p0:(jfloat)p0\n-                       p1:(jfloat)p1\n-                       p3:(jfloat)p3\n-                fractions:(jfloat*)fractions\n-                   pixels:(jint*)pixels\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT\n+                           mask:useMask\n+                         linear:linear\n+                    cycleMethod:cycleMethod\n+                       numStops:numStops\n+                      fractions:fractions\n+                         pixels:pixels];\n+\n+    if (self) {\n+        _m00 = m00;\n+        _m01 = m01;\n+        _m02 = m02;\n+        _m10 = m10;\n+        _m11 = m11;\n+        _m12 = m12;\n+        _focusX = focusX;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLRadialGradPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]]\n+            || ![super isEqual:self])\n+        return NO;\n+\n+    return _m00 == other->_m00 && _m01 == other->_m01 && _m02 == other->_m02 &&\n+           _m10 == other->_m10 && _m11 == other->_m11 && _m12 == other->_m12 &&\n+           _focusX == other->_focusX;\n+}\n+\n+- (NSUInteger)hash {\n+    NSUInteger h = [super hash];\n+    h = h*31 + [@(_m00) hash];\n+    h = h*31 + [@(_m01) hash];\n+    h = h*31 + [@(_m02) hash];\n+    h = h*31 + [@(_m10) hash];\n+    h = h*31 + [@(_m11) hash];\n+    h = h*31 + [@(_m12) hash];\n+    return h;\n+}\n+\n+- (NSString *)description {\n+    return [NSString stringWithFormat:@\"radial_gradient\"];\n+}\n+\n+- (void)setPipelineState:(id)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n@@ -326,25 +610,59 @@\n-    _paintState = sun_java2d_SunGraphics2D_PAINT_LIN_GRADIENT;\n-    _useMask = useMask;\n-    _linear = linear; \/\/ TODO: to be implemented\n-    memcpy(_fract, fractions, numStops*sizeof(jfloat));\n-    memcpy(_pixel, pixels, numStops*sizeof(jint));\n-    _p0 = p0;\n-    _p1 = p1;\n-    _p3 = p3;\n-    _cyclic = cycleMethod;\n-    _numFracts = numStops;\n-}\n-\n-- (void)setRadialGradient:(jboolean)useMask\n-                   linear:(jboolean)linear\n-              cycleMethod:(jint)cycleMethod\n-                 numStops:(jint)numStops\n-                      m00:(jfloat)m00\n-                      m01:(jfloat)m01\n-                      m02:(jfloat)m02\n-                      m10:(jfloat)m10\n-                      m11:(jfloat)m11\n-                      m12:(jfloat)m12\n-                   focusX:(jfloat)focusX\n-                fractions:(void *)fractions\n-                   pixels:(void *)pixels\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n+\n+    NSString *vertShader = @\"vert_grad\";\n+    NSString *fragShader = @\"frag_rad_grad\";\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_grad\";\n+        fragShader = @\"frag_txt_rad_grad\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+    }\n+\n+    struct RadGradFrameUniforms uf = {\n+            {},\n+            {},\n+            _numFracts,\n+            _cyclic,\n+            {_m00, _m01, _m02},\n+            {_m10, _m11, _m12},\n+            {}\n+    };\n+\n+    uf.precalc[0] = _focusX;\n+    uf.precalc[1] = 1.0 - (_focusX * _focusX);\n+    uf.precalc[2] = 1.0 \/ uf.precalc[1];\n+\n+    memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n+    for (int i = 0; i < _numFracts; i++) {\n+        vector_float4 v = RGBA_TO_V4(_pixel[i]);\n+        uf.color[i] = v;\n+    }\n+    [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+\n+@end\n+\n+@implementation MTLTexturePaint {\n+    struct AnchorData _anchor;\n+    id <MTLTexture> _paintTexture;\n+}\n+\n+- (id)initWithUseMask:(jboolean)useMask\n+              textureID:(id)textureId\n+                 filter:(jboolean)filter\n+                    xp0:(jdouble)xp0\n+                    xp1:(jdouble)xp1\n+                    xp3:(jdouble)xp3\n+                    yp0:(jdouble)yp0\n+                    yp1:(jdouble)yp1\n+                    yp3:(jdouble)yp3\n@@ -352,24 +670,39 @@\n-    _paintState = sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT;\n-    _useMask = useMask;\n-    _cyclic = cycleMethod;\n-    _numFracts = numStops;\n-    memcpy(_fract, fractions, numStops * sizeof(jfloat));\n-    memcpy(_pixel, pixels, numStops * sizeof(jint));\n-    _m00 = m00;\n-    _m01 = m01;\n-    _m02 = m02;\n-    _m10 = m10;\n-    _m11 = m11;\n-    _m12 = m12;\n-    _focusX = focusX;\n-}\n-\n-- (void)setTexture:(jboolean)useMask\n-           textureID:(id<MTLTexture>)textureID\n-            filter:(jboolean)filter\n-               xp0:(jdouble)xp0\n-               xp1:(jdouble)xp1\n-               xp3:(jdouble)xp3\n-               yp0:(jdouble)yp0\n-               yp1:(jdouble)yp1\n-               yp3:(jdouble)yp3\n+    self = [super initWithState:sun_java2d_SunGraphics2D_PAINT_TEXTURE];\n+\n+    if (self) {\n+        _paintTexture = textureId;\n+        _anchor.xParams[0] = xp0;\n+        _anchor.xParams[1] = xp1;\n+        _anchor.xParams[2] = xp3;\n+\n+        _anchor.yParams[0] = yp0;\n+        _anchor.yParams[1] = yp1;\n+        _anchor.yParams[2] = yp3;\n+    }\n+    return self;\n+\n+}\n+\n+- (BOOL)isEqual:(MTLTexturePaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![[other class] isEqual:[self class]])\n+        return NO;\n+\n+    return [_paintTexture isEqual:other->_paintTexture]\n+            && _anchor.xParams[0] == other->_anchor.xParams[0]\n+            && _anchor.xParams[1] == other->_anchor.xParams[1]\n+            && _anchor.xParams[2] == other->_anchor.xParams[2]\n+            && _anchor.yParams[0] == other->_anchor.yParams[0]\n+            && _anchor.yParams[1] == other->_anchor.yParams[1]\n+            && _anchor.yParams[2] == other->_anchor.yParams[2];\n+}\n+\n+- (NSString *)description {\n+    return [NSString stringWithFormat:@\"radial_gradient\"];\n+}\n+\n+- (void)setPipelineState:(id)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n@@ -377,6 +710,40 @@\n-    _paintState = sun_java2d_SunGraphics2D_PAINT_TEXTURE;\n-    _paintTexture = textureID;\n-    \n-    _anchor.xParams[0] = xp0;\n-    _anchor.xParams[1] = xp1;\n-    _anchor.xParams[2] = xp3;\n+    initTemplatePipelineDescriptors();\n+    MTLRenderPipelineDescriptor *rpDesc = nil;\n+\n+    NSString* vertShader = @\"vert_tp\";\n+    NSString* fragShader = @\"frag_tp\";\n+\n+    [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];\n+\n+    if (renderOptions->isTexture) {\n+        vertShader = @\"vert_txt_tp\";\n+        fragShader = @\"frag_txt_tp\";\n+        rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+        [encoder setFragmentTexture:_paintTexture atIndex:1];\n+        setTxtUniforms(encoder, 0, 0, renderOptions->interpolation, YES, [mtlc.composite getExtraAlpha],\n+                   &renderOptions->srcFlags, &renderOptions->dstFlags);\n+    } else {\n+        rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+        [encoder setFragmentTexture:_paintTexture atIndex:0];\n+    }\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+- (void)setXorModePipelineState:(id)encoder\n+                        context:(MTLContext *)mtlc\n+                  renderOptions:(const RenderOptions *)renderOptions\n+           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+{\n+    \/\/ This block is not reached in current implementation.\n+    \/\/ Texture paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)\n+    NSString* vertShader = @\"vert_tp_xorMode\";\n+    NSString* fragShader = @\"frag_tp_xorMode\";\n+    MTLRenderPipelineDescriptor *rpDesc = [[templateRenderPipelineDesc copy] autorelease];\n+    jint xorColor = (jint) [mtlc.composite getXorColor];\n@@ -384,3 +751,54 @@\n-    _anchor.yParams[0] = yp0;\n-    _anchor.yParams[1] = yp1;\n-    _anchor.yParams[2] = yp3;\n+    [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];\n+    [encoder setFragmentTexture:_paintTexture atIndex: 0];\n+    BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n+    [encoder setFragmentTexture:dstOps->pTexture atIndex:1];\n+    [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex: 0];\n+\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints - setXorModePipelineState -- PAINT_TEXTURE\");\n+\n+    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                        vertexShaderId:vertShader\n+                                                                      fragmentShaderId:fragShader\n+                                                                             composite:mtlc.composite\n+                                                                         renderOptions:renderOptions\n+                                                                         stencilNeeded:[mtlc.clip isShape]];\n+    [encoder setRenderPipelineState:pipelineState];\n+}\n+\n+@end\n+\n+@implementation MTLPaint {\n+    jint _paintState;\n+}\n+\n+- (instancetype)init {\n+    self = [super init];\n+    if (self) {\n+        _paintState = sun_java2d_SunGraphics2D_PAINT_UNDEFINED;\n+    }\n+\n+    return self;\n+}\n+\n+- (instancetype)initWithState:(jint)state {\n+    self = [super init];\n+    if (self) {\n+        _paintState = state;\n+    }\n+    return self;\n+}\n+\n+- (BOOL)isEqual:(MTLPaint *)other {\n+    if (other == self)\n+        return YES;\n+    if (!other || ![other isKindOfClass:[self class]])\n+        return NO;\n+    return _paintState == other->_paintState;\n+}\n+\n+- (NSUInteger)hash {\n+    return _paintState;\n+}\n+\n+- (NSString *)description {\n+    return @\"unknown-paint\";\n@@ -400,1 +818,1 @@\n-    MTLSamplerDescriptor *samplerDescriptor = [MTLSamplerDescriptor new];\n+    MTLSamplerDescriptor *samplerDescriptor = [[MTLSamplerDescriptor new] autorelease];\n@@ -450,1 +868,2 @@\n-- (void)setPipelineState:(id<MTLRenderCommandEncoder>)encoder\n+\/\/ Base implementation is used in drawTex2Tex\n+- (void)setPipelineState:(id <MTLRenderCommandEncoder>)encoder\n@@ -456,5 +875,1 @@\n-\n-    NSString * vertShader = @\"vert_txt\";\n-    NSString * fragShader = @\"frag_txt\";\n-    MTLRenderPipelineDescriptor * rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n-\n+    \/\/ Called from drawTex2Tex used in flushBuffer and for buffered image ops\n@@ -462,0 +877,4 @@\n+        NSString * vertShader = @\"vert_txt\";\n+        NSString * fragShader = @\"frag_txt\";\n+        MTLRenderPipelineDescriptor* rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+\n@@ -466,1 +885,0 @@\n-                vertShader = @\"vert_txt\";\n@@ -477,2 +895,1 @@\n-                MTLConvolveOp * convolveOp = bufImgOp;\n-                vertShader = @\"vert_txt\";\n+                MTLConvolveOp *convolveOp = bufImgOp;\n@@ -482,1 +899,2 @@\n-                        [mtlc.composite getExtraAlpha], renderOptions->srcFlags.isOpaque, FLOAT_ARR_TO_V4([convolveOp getImgEdge]),\n+                        [mtlc.composite getExtraAlpha], renderOptions->srcFlags.isOpaque,\n+                        FLOAT_ARR_TO_V4([convolveOp getImgEdge]),\n@@ -490,2 +908,1 @@\n-                MTLLookupOp * lookupOp = bufImgOp;\n-                vertShader = @\"vert_txt\";\n+                MTLLookupOp *lookupOp = bufImgOp;\n@@ -500,38 +917,1 @@\n-                [encoder setFragmentTexture:[lookupOp getLookupTexture] atIndex: 1];\n-            }\n-        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {\n-            vertShader = @\"vert_txt_tp\";\n-            fragShader = @\"frag_txt_tp\";\n-            [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];\n-            [encoder setFragmentTexture:_paintTexture atIndex:1];\n-\n-            setTxtUniforms(encoder, 0, 0, renderOptions->interpolation, YES, [mtlc.composite getExtraAlpha],\n-                           &renderOptions->srcFlags, &renderOptions->dstFlags);\n-        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {\n-            \/\/ Gradient paint in AA mode\n-            vertShader = @\"vert_txt_grad\";\n-            fragShader = @\"frag_txt_grad\";\n-            struct GradFrameUniforms uf = {\n-                    {_p0, _p1, _p3},\n-                    RGBA_TO_V4(_pixel[0]),\n-                    RGBA_TO_V4(_pixel[1]),\n-                    _cyclic};\n-            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n-\n-        }  else if (_paintState == sun_java2d_SunGraphics2D_PAINT_LIN_GRADIENT) {\n-            \/\/ Linear gradient paint in AA mode\n-            vertShader = @\"vert_txt_grad\";\n-            fragShader = @\"frag_txt_lin_grad\";\n-\n-            struct LinGradFrameUniforms uf = {\n-                    {_p0, _p1, _p3},\n-                    {},\n-                    {},\n-                    _numFracts,\n-                    _cyclic\n-            };\n-\n-            memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n-            for (int i = 0; i < _numFracts; i++) {\n-                vector_float4 v = RGBA_TO_V4(_pixel[i]);\n-                uf.color[i] = v;\n+                [encoder setFragmentTexture:[lookupOp getLookupTexture] atIndex:1];\n@@ -539,25 +919,0 @@\n-            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n-        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n-            vertShader = @\"vert_txt_grad\";\n-            fragShader = @\"frag_txt_rad_grad\";\n-\n-            struct RadGradFrameUniforms uf = {\n-                    {},\n-                    {},\n-                    _numFracts,\n-                    _cyclic,\n-                    {_m00, _m01, _m02},\n-                    {_m10, _m11, _m12},\n-                    {}\n-            };\n-\n-            uf.precalc[0] = _focusX;\n-            uf.precalc[1] = 1.0 - (_focusX * _focusX);\n-            uf.precalc[2] = 1.0 \/ uf.precalc[1];\n-\n-            memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n-            for (int i = 0; i < _numFracts; i++) {\n-                vector_float4 v = RGBA_TO_V4(_pixel[i]);\n-                uf.color[i] = v;\n-            }\n-            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n@@ -565,9 +920,3 @@\n-            vertShader = @\"vert_txt\";\n-            fragShader = @\"frag_txt\";\n-            if (renderOptions->isAA) {\n-                fragShader = @\"aa_frag_txt\";\n-                rpDesc = templateAATexturePipelineDesc;\n-            }\n-\n-            setTxtUniforms(encoder, _color, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,\n-                           renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha], &renderOptions->srcFlags,\n+            setTxtUniforms(encoder, 0, 0,\n+                           renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha],\n+                           &renderOptions->srcFlags,\n@@ -575,71 +924,0 @@\n-        }\n-    } else {\n-        rpDesc = templateRenderPipelineDesc;\n-\n-        if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {\n-            vertShader = @\"vert_col\";\n-            fragShader = @\"frag_col\";\n-\n-            struct FrameUniforms uf = {RGBA_TO_V4(_color)};\n-            [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n-        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {\n-            vertShader = @\"vert_grad\";\n-            fragShader = @\"frag_grad\";\n-\n-            struct GradFrameUniforms uf = {\n-                    {_p0, _p1, _p3},\n-                    RGBA_TO_V4(_pixel[0]),\n-                    RGBA_TO_V4(_pixel[1]),\n-                    _cyclic\n-            };\n-            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n-        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_LIN_GRADIENT) {\n-            vertShader = @\"vert_grad\";\n-            fragShader = @\"frag_lin_grad\";\n-\n-            struct LinGradFrameUniforms uf = {\n-                    {_p0, _p1, _p3},\n-                    {},\n-                    {},\n-                    _numFracts,\n-                    _cyclic\n-            };\n-\n-            memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n-            for (int i = 0; i < _numFracts; i++) {\n-                vector_float4 v = RGBA_TO_V4(_pixel[i]);\n-                uf.color[i] = v;\n-            }\n-            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n-\n-        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n-            vertShader = @\"vert_grad\";\n-            fragShader = @\"frag_rad_grad\";\n-\n-            struct RadGradFrameUniforms uf = {\n-                    {},\n-                    {},\n-                    _numFracts,\n-                    _cyclic,\n-                    {_m00, _m01, _m02},\n-                    {_m10, _m11, _m12},\n-                    {}\n-            };\n-\n-            uf.precalc[0] = _focusX;\n-            uf.precalc[1] = 1.0 - (_focusX * _focusX);\n-            uf.precalc[2] = 1.0 \/ uf.precalc[1];\n-\n-            memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n-            for (int i = 0; i < _numFracts; i++) {\n-                vector_float4 v = RGBA_TO_V4(_pixel[i]);\n-                uf.color[i] = v;\n-            }\n-            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n-\n-        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {\n-            vertShader = @\"vert_tp\";\n-            fragShader = @\"frag_tp\";\n-\n-            [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];\n-            [encoder setFragmentTexture:_paintTexture atIndex:0];\n@@ -648,0 +926,7 @@\n+        id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                            vertexShaderId:vertShader\n+                                                                          fragmentShaderId:fragShader\n+                                                                                 composite:mtlc.composite\n+                                                                             renderOptions:renderOptions\n+                                                                             stencilNeeded:[mtlc.clip isShape]];\n+        [encoder setRenderPipelineState:pipelineState];\n@@ -649,8 +934,0 @@\n-\n-    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n-                                                                        vertexShaderId:vertShader\n-                                                                      fragmentShaderId:fragShader\n-                                                                             composite:mtlc.composite\n-                                                                         renderOptions:renderOptions\n-                                                                         stencilNeeded:[mtlc.clip isShape]];\n-    [encoder setRenderPipelineState:pipelineState];\n@@ -659,2 +936,1 @@\n-\n-\/\/ For the current paint mode: and for XOR composite - a separate method is added as fragment shader differ in some cases\n+\/\/ For the current paint mode:\n@@ -663,4 +939,4 @@\n-- (void)setXorModePipelineState:(id<MTLRenderCommandEncoder>)encoder\n-                        context:(MTLContext *)mtlc\n-                  renderOptions:(const RenderOptions *)renderOptions\n-           pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n+- (void)setXorModePipelineState:(id <MTLRenderCommandEncoder>)encoder\n+                 context:(MTLContext *)mtlc\n+           renderOptions:(const RenderOptions *)renderOptions\n+    pipelineStateStorage:(MTLPipelineStatesStorage *)pipelineStateStorage\n@@ -668,8 +944,0 @@\n-    initTemplatePipelineDescriptors();\n-\n-    jint xorColor = (jint) [mtlc.composite getXorColor];\n-\n-    NSString * vertShader = @\"vert_txt_xorMode\";\n-    NSString * fragShader = @\"frag_txt_xorMode\";\n-    MTLRenderPipelineDescriptor * rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n-\n@@ -677,2 +945,8 @@\n-        const int col = _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? _color ^ xorColor : 0 ^ xorColor;\n-        setTxtUniforms(encoder, col, _paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR ? 1 : 0,\n+        initTemplatePipelineDescriptors();\n+        jint xorColor = (jint) [mtlc.composite getXorColor];\n+        NSString * vertShader = @\"vert_txt_xorMode\";\n+        NSString * fragShader = @\"frag_txt_xorMode\";\n+        MTLRenderPipelineDescriptor * rpDesc = [[templateTexturePipelineDesc copy] autorelease];\n+\n+        const int col = 0 ^ xorColor;\n+        setTxtUniforms(encoder, col, 0,\n@@ -686,50 +960,12 @@\n-        J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints - setXorModePipelineState -- TEXTURE DRAW\");\n-    } else {\n-        if (_paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {\n-            vertShader = @\"vert_col_xorMode\";\n-            fragShader = @\"frag_col_xorMode\";\n-            rpDesc = templateRenderPipelineDesc;\n-\n-            \/\/ Calculate _color ^ xorColor for RGB components\n-            \/\/ This color gets XORed with destination framebuffer pixel color\n-            struct FrameUniforms uf = {RGBA_TO_V4(_color ^ xorColor)};\n-            [encoder setVertexBytes:&uf length:sizeof(uf) atIndex:FrameUniformBuffer];\n-\n-            BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n-            [encoder setFragmentTexture:dstOps->pTexture atIndex:0];\n-\n-            J2dTraceLn(J2D_TRACE_INFO ,\"MTLPaints - setXorModePipelineState -- PAINT_ALPHACOLOR\");\n-        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_GRADIENT) {\n-            \/\/ This block is not reached in current implementation.\n-            \/\/ Gradient paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)\n-            vertShader = @\"vert_grad_xorMode\";\n-            fragShader = @\"frag_grad_xorMode\";\n-            rpDesc = templateRenderPipelineDesc;\n-\n-            struct GradFrameUniforms uf = {\n-                        {_p0, _p1, _p3},\n-                        RGBA_TO_V4(_pixel[0] ^ xorColor),\n-                        RGBA_TO_V4(_pixel[1] ^ xorColor),\n-                        _cyclic\n-            };\n-\n-            [encoder setFragmentBytes: &uf length:sizeof(uf) atIndex:0];\n-            BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n-            [encoder setFragmentTexture:dstOps->pTexture atIndex:0];\n-\n-            J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints - setXorModePipelineState -- PAINT_GRADIENT\");\n-        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_TEXTURE) {\n-            \/\/ This block is not reached in current implementation.\n-            \/\/ Texture paint XOR mode rendering uses a tile based rendering using a SW pipe (similar to OGL)\n-            vertShader = @\"vert_tp_xorMode\";\n-            fragShader = @\"frag_tp_xorMode\";\n-            rpDesc = templateRenderPipelineDesc;\n-\n-            [encoder setVertexBytes:&_anchor length:sizeof(_anchor) atIndex:FrameUniformBuffer];\n-            [encoder setFragmentTexture:_paintTexture atIndex: 0];\n-            BMTLSDOps *dstOps = MTLRenderQueue_GetCurrentDestination();\n-            [encoder setFragmentTexture:dstOps->pTexture atIndex:1];\n-            [encoder setFragmentBytes:&xorColor length:sizeof(xorColor) atIndex: 0];\n-\n-            J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints - setXorModePipelineState -- PAINT_TEXTURE\");\n-        }\n+        setTxtUniforms(encoder, 0, 0,\n+                       renderOptions->interpolation, NO, [mtlc.composite getExtraAlpha],\n+                       &renderOptions->srcFlags,\n+                       &renderOptions->dstFlags);\n+\n+        id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n+                                                                            vertexShaderId:vertShader\n+                                                                          fragmentShaderId:fragShader\n+                                                                                 composite:mtlc.composite\n+                                                                             renderOptions:renderOptions\n+                                                                             stencilNeeded:[mtlc.clip isShape]];\n+        [encoder setRenderPipelineState:pipelineState];\n@@ -737,8 +973,0 @@\n-\n-    id <MTLRenderPipelineState> pipelineState = [pipelineStateStorage getPipelineState:rpDesc\n-                                                                        vertexShaderId:vertShader\n-                                                                      fragmentShaderId:fragShader\n-                                                                             composite:mtlc.composite\n-                                                                         renderOptions:renderOptions\n-                                                                         stencilNeeded:[mtlc.clip isShape]];\n-    [encoder setRenderPipelineState:pipelineState];\n@@ -749,0 +977,1 @@\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.m","additions":700,"deletions":471,"binary":false,"changes":1171,"status":"modified"},{"patch":"@@ -283,0 +283,4 @@\n+    if (![mtlc.paint isKindOfClass:[MTLColorPaint class]]) {\n+        return JNI_FALSE;\n+    }\n+    MTLColorPaint* cPaint = (MTLColorPaint *) mtlc.paint;\n@@ -321,1 +325,1 @@\n-    jint col = [mtlc.paint getColor];\n+    jint col = cPaint.color;\n@@ -385,0 +389,4 @@\n+    if (![mtlc.paint isKindOfClass:[MTLColorPaint class]]) {\n+        return JNI_FALSE;\n+    }\n+    MTLColorPaint* cPaint = (MTLColorPaint *) mtlc.paint;\n@@ -390,1 +398,1 @@\n-    jint col = [mtlc.paint getColor];\n+    jint col = cPaint.color;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"}]}