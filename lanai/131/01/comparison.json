{"files":[{"patch":"@@ -17,1 +17,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n@@ -91,1 +91,1 @@\n-        run: sh make\/build-all.sh ${JAVA_HOME}\n+        run: sh make\/build-all.sh ${JAVA_HOME_8_X64}\n@@ -109,1 +109,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n@@ -192,1 +192,3 @@\n-        run: sudo apt-get install libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n+        run: |\n+          sudo apt-get install gcc-10=10.2.0-5ubuntu1~20.04 g++-10=10.2.0-5ubuntu1~20.04 libxrandr-dev libxtst-dev libcups2-dev libasound2-dev\n+          sudo update-alternatives --install \/usr\/bin\/gcc gcc \/usr\/bin\/gcc-10 100 --slave \/usr\/bin\/g++ g++ \/usr\/bin\/g++-10\n@@ -224,1 +226,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n@@ -403,1 +405,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n@@ -539,1 +541,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n@@ -675,1 +677,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n@@ -811,1 +813,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n@@ -947,1 +949,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n@@ -1021,1 +1023,2 @@\n-          sudo apt-get install gcc-multilib g++-multilib libfreetype6-dev:i386 libxrandr-dev:i386 libxtst-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libcups2-dev:i386 libasound2-dev:i386\n+          sudo apt-get install gcc-10-multilib g++-10-multilib libfreetype6-dev:i386 libxrandr-dev:i386 libxtst-dev:i386 libtiff-dev:i386 libcupsimage2-dev:i386 libcups2-dev:i386 libasound2-dev:i386\n+          sudo update-alternatives --install \/usr\/bin\/gcc gcc \/usr\/bin\/gcc-10 100 --slave \/usr\/bin\/g++ g++ \/usr\/bin\/g++-10\n@@ -1054,1 +1057,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n@@ -1845,1 +1848,1 @@\n-    runs-on: \"ubuntu-latest\"\n+    runs-on: \"ubuntu-20.04\"\n","filename":".github\/workflows\/submit.yml","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm\n+files=.*\\.cpp|.*\\.hpp|.*\\.c|.*\\.h|.*\\.java|.*\\.cc|.*\\.hh|.*\\.m|.*\\.mm|.*\\.gmk|.*\\.m4|.*\\.ac|Makefile\n+ignore-tabs=.*\\.gmk|Makefile\n","filename":".jcheck\/conf","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-        [--enable-jvm-feature-FEATURE], \n+        [--enable-jvm-feature-FEATURE],\n","filename":"make\/autoconf\/jvm-features.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -808,1 +808,2 @@\n-            $$($1_OPT_CFLAGS) -x c++-header -c $(C_FLAG_DEPS) $$($1_PCH_DEPS_FILE)\n+            $$($1_OPT_CFLAGS) -x c++-header -c $(C_FLAG_DEPS) \\\n+            $$(addsuffix .tmp, $$($1_PCH_DEPS_FILE))\n@@ -815,0 +816,1 @@\n+\t\t$$(call fix-deps-file, $$($1_PCH_DEPS_FILE))\n","filename":"make\/common\/NativeCompilation.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-# We now create 2 complete initial sets of policy files and package into \n+# We now create 2 complete initial sets of policy files and package into\n","filename":"make\/modules\/java.base\/gendata\/GendataCryptoPolicy.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-RENDERPERF_RESOURCES = $(CLASSES)\/renderperf\/images\/duke.png \n+RENDERPERF_RESOURCES = $(CLASSES)\/renderperf\/images\/duke.png\n","filename":"src\/demo\/share\/java2d\/RenderPerfTest\/Makefile","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -507,2 +507,1 @@\n-          if (_ext.shift() > 0)\n-            assert(_ext.shift() == (int)size, \"bad shift\");\n+          assert(_ext.shift() <= 0 || _ext.shift() == (int)size, \"bad shift\");\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-address StubRoutines::aarch64::_get_previous_fp_entry = NULL;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  static address _get_previous_fp_entry;\n@@ -80,5 +79,0 @@\n-  static address get_previous_fp_entry()\n-  {\n-    return _get_previous_fp_entry;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -267,0 +268,2 @@\n+  \/\/ Generated code assumes that buffer index is pointer sized.\n+  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n@@ -317,12 +320,7 @@\n-  __ cmpl(queue_index, 0);\n-  __ jcc(Assembler::equal, runtime);\n-  __ subl(queue_index, wordSize);\n-  __ movptr(tmp2, buffer);\n-#ifdef _LP64\n-  __ movslq(rscratch1, queue_index);\n-  __ addq(tmp2, rscratch1);\n-  __ movq(Address(tmp2, 0), card_addr);\n-#else\n-  __ addl(tmp2, queue_index);\n-  __ movl(Address(tmp2, 0), card_addr);\n-#endif\n+  __ movptr(tmp2, queue_index);\n+  __ testptr(tmp2, tmp2);\n+  __ jcc(Assembler::zero, runtime);\n+  __ subptr(tmp2, wordSize);\n+  __ movptr(queue_index, tmp2);\n+  __ addptr(tmp2, buffer);\n+  __ movptr(Address(tmp2, 0), card_addr);\n@@ -456,0 +454,3 @@\n+  \/\/ Generated code assumes that buffer index is pointer sized.\n+  STATIC_ASSERT(in_bytes(SATBMarkQueue::byte_width_of_index()) == sizeof(intptr_t));\n+\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -531,0 +531,6 @@\n+    \/\/ Note: We want to allow trace_method_handle from any call site.\n+    \/\/ While trace_method_handle creates a frame, it may be entered\n+    \/\/ without a PC on the stack top (e.g. not just after a call).\n+    \/\/ Walking that frame could lead to failures due to that invalid PC.\n+    \/\/ => carefully detect that frame when doing the stack walking\n+\n@@ -539,6 +545,0 @@\n-      \/\/ Note: We want to allow trace_method_handle from any call site.\n-      \/\/ While trace_method_handle creates a frame, it may be entered\n-      \/\/ without a PC on the stack top (e.g. not just after a call).\n-      \/\/ Walking that frame could lead to failures due to that invalid PC.\n-      \/\/ => carefully detect that frame when doing the stack walking\n-\n@@ -548,28 +548,29 @@\n-      \/\/ Robust search of trace_calling_frame (independant of inlining).\n-      \/\/ Assumes saved_regs comes from a pusha in the trace_calling_frame.\n-      assert(cur_frame.sp() < saved_regs, \"registers not saved on stack ?\");\n-      frame trace_calling_frame = os::get_sender_for_C_frame(&cur_frame);\n-      while (trace_calling_frame.fp() < saved_regs) {\n-        trace_calling_frame = os::get_sender_for_C_frame(&trace_calling_frame);\n-      }\n-\n-      \/\/ safely create a frame and call frame::describe\n-      intptr_t *dump_sp = trace_calling_frame.sender_sp();\n-      intptr_t *dump_fp = trace_calling_frame.link();\n-\n-      bool walkable = has_mh; \/\/ whether the traced frame shoud be walkable\n-\n-      if (walkable) {\n-        \/\/ The previous definition of walkable may have to be refined\n-        \/\/ if new call sites cause the next frame constructor to start\n-        \/\/ failing. Alternatively, frame constructors could be\n-        \/\/ modified to support the current or future non walkable\n-        \/\/ frames (but this is more intrusive and is not considered as\n-        \/\/ part of this RFE, which will instead use a simpler output).\n-        frame dump_frame = frame(dump_sp, dump_fp);\n-        dump_frame.describe(values, 1);\n-      } else {\n-        \/\/ Stack may not be walkable (invalid PC above FP):\n-        \/\/ Add descriptions without building a Java frame to avoid issues\n-        values.describe(-1, dump_fp, \"fp for #1 <not parsed, cannot trust pc>\");\n-        values.describe(-1, dump_sp, \"sp for #1\");\n+      if (cur_frame.fp() != 0) {  \/\/ not walkable\n+\n+        \/\/ Robust search of trace_calling_frame (independent of inlining).\n+        \/\/ Assumes saved_regs comes from a pusha in the trace_calling_frame.\n+        assert(cur_frame.sp() < saved_regs, \"registers not saved on stack ?\");\n+        frame trace_calling_frame = os::get_sender_for_C_frame(&cur_frame);\n+        while (trace_calling_frame.fp() < saved_regs) {\n+          trace_calling_frame = os::get_sender_for_C_frame(&trace_calling_frame);\n+        }\n+\n+        \/\/ safely create a frame and call frame::describe\n+        intptr_t *dump_sp = trace_calling_frame.sender_sp();\n+        intptr_t *dump_fp = trace_calling_frame.link();\n+\n+        if (has_mh) {\n+          \/\/ The previous definition of walkable may have to be refined\n+          \/\/ if new call sites cause the next frame constructor to start\n+          \/\/ failing. Alternatively, frame constructors could be\n+          \/\/ modified to support the current or future non walkable\n+          \/\/ frames (but this is more intrusive and is not considered as\n+          \/\/ part of this RFE, which will instead use a simpler output).\n+          frame dump_frame = frame(dump_sp, dump_fp);\n+          dump_frame.describe(values, 1);\n+        } else {\n+          \/\/ Stack may not be walkable (invalid PC above FP):\n+          \/\/ Add descriptions without building a Java frame to avoid issues\n+          values.describe(-1, dump_fp, \"fp for #1 <not parsed, cannot trust pc>\");\n+          values.describe(-1, dump_sp, \"sp for #1\");\n+        }\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":35,"deletions":34,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -31,6 +31,25 @@\n-    int regBase = reg->value() - ConcreteRegisterImpl::max_fpr;\n-    if (regBase % 4 == 0) {\n-      \/\/ Reads of the low and high 16 byte parts should be handled by location itself\n-      \/\/ because they have separate callee saved entries.\n-      \/\/ See RegisterSaver::save_live_registers().\n-      return NULL;\n+    int reg_base = reg->value() - ConcreteRegisterImpl::max_fpr;\n+    int base_reg_enc = (reg_base \/ XMMRegisterImpl::max_slots_per_register);\n+    assert(base_reg_enc >= 0 && base_reg_enc < XMMRegisterImpl::number_of_registers, \"invalid XMMRegister: %d\", base_reg_enc);\n+    VMReg base_reg = as_XMMRegister(base_reg_enc)->as_VMReg();\n+    intptr_t offset_in_bytes = (reg->value() - base_reg->value()) * VMRegImpl::stack_slot_size;\n+    if (base_reg_enc > 15) {\n+      if (offset_in_bytes == 0) {\n+        return NULL; \/\/ ZMM16-31 are stored in full.\n+      }\n+    } else {\n+      if (offset_in_bytes == 0 || offset_in_bytes == 16 || offset_in_bytes == 32) {\n+        \/\/ Reads of the low and high 16 byte parts should be handled by location itself because\n+        \/\/ they have separate callee saved entries (see RegisterSaver::save_live_registers()).\n+        return NULL;\n+      }\n+      \/\/ The upper part of YMM0-15 and ZMM0-15 registers are saved separately in the frame.\n+      if (offset_in_bytes > 32) {\n+        base_reg = base_reg->next(8);\n+        offset_in_bytes -= 32;\n+      } else if (offset_in_bytes > 16) {\n+        base_reg = base_reg->next(4);\n+        offset_in_bytes -= 16;\n+      } else {\n+        \/\/ XMM0-15 case (0 < offset_in_bytes < 16). No need to adjust base register (or offset).\n+      }\n@@ -38,10 +57,3 @@\n-    VMReg baseReg = as_XMMRegister(regBase \/ XMMRegisterImpl::max_slots_per_register)->as_VMReg();\n-    intptr_t offset = (reg->value() - baseReg->value()) * VMRegImpl::stack_slot_size; \/\/ offset in bytes\n-    if (offset >= 16) {\n-      \/\/ The high part of YMM registers are saved in a their own area in the frame\n-      baseReg = baseReg->next()->next()->next()->next();\n-      offset -= 16;\n-    }\n-    address baseLocation = location(baseReg);\n-    if (baseLocation != NULL) {\n-      return baseLocation + offset;\n+    address base_location = location(base_reg);\n+    if (base_location != NULL) {\n+      return base_location + offset_in_bytes;\n","filename":"src\/hotspot\/cpu\/x86\/registerMap_x86.cpp","additions":28,"deletions":16,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -92,3 +92,4 @@\n-#define DEF_XMM_OFFS(regnum) xmm ## regnum ## _off = xmm_off + (regnum)*16\/BytesPerInt, xmm ## regnum ## H_off\n-#define DEF_YMM_OFFS(regnum) ymm ## regnum ## _off = ymm_off + (regnum)*16\/BytesPerInt, ymm ## regnum ## H_off\n-#define DEF_ZMM_OFFS(regnum) zmm ## regnum ## _off = zmm_off + (regnum-16)*64\/BytesPerInt, zmm ## regnum ## H_off\n+#define DEF_XMM_OFFS(regnum)       xmm ## regnum ## _off = xmm_off + (regnum)*16\/BytesPerInt, xmm ## regnum ## H_off\n+#define DEF_YMM_OFFS(regnum)       ymm ## regnum ## _off = ymm_off + (regnum)*16\/BytesPerInt, ymm ## regnum ## H_off\n+#define DEF_ZMM_OFFS(regnum)       zmm ## regnum ## _off = zmm_off + (regnum)*32\/BytesPerInt, zmm ## regnum ## H_off\n+#define DEF_ZMM_UPPER_OFFS(regnum) zmm ## regnum ## _off = zmm_upper_off + (regnum-16)*64\/BytesPerInt, zmm ## regnum ## H_off\n@@ -105,4 +106,6 @@\n-    zmm_high = xmm_off + (XSAVE_AREA_ZMM_BEGIN - XSAVE_AREA_BEGIN)\/BytesPerInt,\n-    zmm_off = xmm_off + (XSAVE_AREA_UPPERBANK - XSAVE_AREA_BEGIN)\/BytesPerInt,\n-    DEF_ZMM_OFFS(16),\n-    DEF_ZMM_OFFS(17),\n+    zmm_off = xmm_off + (XSAVE_AREA_ZMM_BEGIN - XSAVE_AREA_BEGIN)\/BytesPerInt,\n+    DEF_ZMM_OFFS(0),\n+    DEF_ZMM_OFFS(1),\n+    zmm_upper_off = xmm_off + (XSAVE_AREA_UPPERBANK - XSAVE_AREA_BEGIN)\/BytesPerInt,\n+    DEF_ZMM_UPPER_OFFS(16),\n+    DEF_ZMM_UPPER_OFFS(17),\n@@ -140,1 +143,1 @@\n-  static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors = false);\n+  static OopMap* save_live_registers(MacroAssembler* masm, int additional_frame_words, int* total_frame_words, bool save_vectors);\n@@ -165,3 +168,2 @@\n-  if (save_vectors) {\n-    assert(UseAVX > 0, \"Vectors larger than 16 byte long are supported only with AVX\");\n-    assert(MaxVectorSize <= 64, \"Only up to 64 byte long vectors are supported\");\n+  if (save_vectors && UseAVX == 0) {\n+    save_vectors = false; \/\/ vectors larger than 16 byte long are supported only with AVX\n@@ -169,0 +171,1 @@\n+  assert(!save_vectors || MaxVectorSize <= 64, \"Only up to 64 byte long vectors are supported\");\n@@ -170,1 +173,1 @@\n-  assert(!save_vectors, \"vectors are generated only by C2 and JVMCI\");\n+  save_vectors = false; \/\/ vectors are generated only by C2 and JVMCI\n@@ -262,1 +265,1 @@\n-  if(UseAVX > 2) {\n+  if (UseAVX > 2) {\n@@ -275,0 +278,1 @@\n+    \/\/ Save upper half of YMM registers(0..15)\n@@ -276,1 +280,1 @@\n-    int delta = ymm1_off - off;\n+    delta = ymm1_off - ymm0_off;\n@@ -282,0 +286,10 @@\n+    if (VM_Version::supports_evex()) {\n+      \/\/ Save upper half of ZMM registers(0..15)\n+      off = zmm0_off;\n+      delta = zmm1_off - zmm0_off;\n+      for (int n = 0; n < 16; n++) {\n+        XMMRegister zmm_name = as_XMMRegister(n);\n+        map->set_callee_saved(STACK_OFFSET(off), zmm_name->as_VMReg()->next(8));\n+        off += delta;\n+      }\n+    }\n@@ -2609,0 +2623,3 @@\n+  if (UseAVX > 2) {\n+    pad += 1024;\n+  }\n@@ -2614,1 +2631,1 @@\n-  CodeBuffer buffer(\"deopt_blob\", 2048+pad, 1024);\n+  CodeBuffer buffer(\"deopt_blob\", 2560+pad, 1024);\n@@ -2656,1 +2673,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, \/*save_vectors*\/ true);\n@@ -2674,1 +2691,1 @@\n-  (void) RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  (void) RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, \/*save_vectors*\/ true);\n@@ -2693,1 +2710,1 @@\n-    RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+    RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, \/*save_vectors*\/ true);\n@@ -2740,1 +2757,1 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, \/*save_vectors*\/ true);\n@@ -3342,1 +3359,2 @@\n-  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words);\n+  \/\/ No need to save vector registers since they are caller-saved anyway.\n+  map = RegisterSaver::save_live_registers(masm, 0, &frame_size_in_words, \/*save_vectors*\/ false);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":38,"deletions":20,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -569,20 +569,0 @@\n-  \/\/ Support for intptr_t get_previous_fp()\n-  \/\/\n-  \/\/ This routine is used to find the previous frame pointer for the\n-  \/\/ caller (current_frame_guess). This is used as part of debugging\n-  \/\/ ps() is seemingly lost trying to find frames.\n-  \/\/ This code assumes that caller current_frame_guess) has a frame.\n-  address generate_get_previous_fp() {\n-    StubCodeMark mark(this, \"StubRoutines\", \"get_previous_fp\");\n-    const Address old_fp(rbp, 0);\n-    const Address older_fp(rax, 0);\n-    address start = __ pc();\n-\n-    __ enter();\n-    __ movptr(rax, old_fp); \/\/ callers fp\n-    __ movptr(rax, older_fp); \/\/ the frame for ps()\n-    __ pop(rbp);\n-    __ ret(0);\n-\n-    return start;\n-  }\n@@ -6720,1 +6700,0 @@\n-    StubRoutines::x86::_get_previous_fp_entry = generate_get_previous_fp();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,0 @@\n-  static address _get_previous_fp_entry;\n@@ -60,4 +59,0 @@\n-  static address get_previous_fp_entry() {\n-    return _get_previous_fp_entry;\n-  }\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-address StubRoutines::x86::_get_previous_fp_entry = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86_64.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,0 +50,8 @@\n+\/\/ Glibc on Linux uses the SA_RESTORER flag to indicate\n+\/\/ the use of a \"signal trampoline\". We have no interest\n+\/\/ in this flag and need to ignore it when checking our\n+\/\/ own flag settings.\n+\/\/ Note: SA_RESTORER is not exposed through signal.h so we\n+\/\/ have to hardwire its 0x04000000 value in the mask.\n+LINUX_ONLY(const int SA_RESTORER_FLAG_MASK = ~0x04000000;)\n+\n@@ -660,0 +668,10 @@\n+  const unsigned int unknown_flag = ~(SA_NOCLDSTOP |\n+                                      SA_ONSTACK   |\n+                                      SA_NOCLDSTOP |\n+                                      SA_RESTART   |\n+                                      SA_SIGINFO   |\n+                                      SA_NOCLDWAIT |\n+                                      SA_NODEFER\n+                                      AIX_ONLY(| SA_OLDSTYLE)\n+                                      );\n+\n@@ -662,1 +680,1 @@\n-    \/\/ systems 0x80000000, which is implicitly unsigned.  Assignining\n+    \/\/ systems 0x80000000, which is implicitly unsigned.  Assigning\n@@ -678,1 +696,1 @@\n-    { 0, NULL }\n+    { unknown_flag, \"NOT USED\"     }\n@@ -681,1 +699,1 @@\n-  for (idx = 0; flaginfo[idx].s && remaining > 1; idx++) {\n+  for (idx = 0; flaginfo[idx].i != unknown_flag && remaining > 1; idx++) {\n@@ -694,0 +712,4 @@\n+  unsigned int unknowns = flags & unknown_flag;\n+  if (unknowns != 0) {\n+    jio_snprintf(p, remaining, \"|Unknown_flags:%x\", unknowns);\n+  }\n@@ -737,0 +759,3 @@\n+  \/\/ See comment for SA_RESTORER_FLAG_MASK\n+  LINUX_ONLY(act.sa_flags &= SA_RESTORER_FLAG_MASK;)\n+\n@@ -1313,0 +1338,3 @@\n+  \/\/ See comment for SA_RESTORER_FLAG_MASK\n+  LINUX_ONLY(sa.sa_flags &= SA_RESTORER_FLAG_MASK;)\n+\n@@ -1334,1 +1362,2 @@\n-    sa.sa_flags = VMError::get_resetted_sigflags(sig);\n+    \/\/ See comment for SA_RESTORER_FLAG_MASK\n+    sa.sa_flags = VMError::get_resetted_sigflags(sig) LINUX_ONLY(& SA_RESTORER_FLAG_MASK);\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":33,"deletions":4,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -145,2 +145,0 @@\n-\/\/ By default, gcc always saves frame pointer rfp on this stack. This\n-\/\/ may get turned off by -fomit-frame-pointer.\n@@ -148,1 +146,2 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  ShouldNotReachHere();\n+  return frame();\n@@ -152,19 +151,2 @@\n-  typedef intptr_t*      get_fp_func           ();\n-  get_fp_func* func = CAST_TO_FN_PTR(get_fp_func*,\n-                                     StubRoutines::aarch64::get_previous_fp_entry());\n-  if (func == NULL) return frame();\n-  intptr_t* fp = (*func)();\n-  if (fp == NULL) {\n-    return frame();\n-  }\n-\n-  frame myframe((intptr_t*)os::current_stack_pointer(),\n-                (intptr_t*)fp,\n-                CAST_FROM_FN_PTR(address, os::current_frame));\n-  if (os::is_first_C_frame(&myframe)) {\n-\n-    \/\/ stack is not walkable\n-    return frame();\n-  } else {\n-    return os::get_sender_for_C_frame(&myframe);\n-  }\n+  return frame();  \/\/ cannot walk Windows frames this way.  See os::get_native_stack\n+                   \/\/ and os::platform_print_native_stack\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -326,7 +326,0 @@\n-\/\/ VC++ does not save frame pointer on stack in optimized build. It\n-\/\/ can be turned off by \/Oy-. If we really want to walk C frames,\n-\/\/ we can use the StackWalk() API.\n-frame os::get_sender_for_C_frame(frame* fr) {\n-  return frame(fr->sender_sp(), fr->link(), fr->sender_pc());\n-}\n-\n@@ -393,15 +386,7 @@\n-#ifndef AMD64\n-intptr_t* _get_previous_fp() {\n-  intptr_t **frameptr;\n-  __asm {\n-    mov frameptr, ebp\n-  };\n-  \/\/ ebp (frameptr) is for this frame (_get_previous_fp). We want the ebp for the\n-  \/\/ caller of os::current_frame*(), so go up two frames. However, for\n-  \/\/ optimized builds, _get_previous_fp() will be inlined, so only go\n-  \/\/ up 1 frame in that case.\n-#ifdef _NMT_NOINLINE_\n-  return **(intptr_t***)frameptr;\n-#else\n-  return *frameptr;\n-#endif\n+\n+\/\/ VC++ does not save frame pointer on stack in optimized build. It\n+\/\/ can be turned off by \/Oy-. If we really want to walk C frames,\n+\/\/ we can use the StackWalk() API.\n+frame os::get_sender_for_C_frame(frame* fr) {\n+  ShouldNotReachHere();\n+  return frame();\n@@ -409,1 +394,0 @@\n-#endif \/\/ !AMD64\n@@ -412,24 +396,2 @@\n-\n-#ifdef AMD64\n-  \/\/ apparently _asm not supported on windows amd64\n-  typedef intptr_t*      get_fp_func           ();\n-  get_fp_func* func = CAST_TO_FN_PTR(get_fp_func*,\n-                                     StubRoutines::x86::get_previous_fp_entry());\n-  if (func == NULL) return frame();\n-  intptr_t* fp = (*func)();\n-  if (fp == NULL) {\n-    return frame();\n-  }\n-#else\n-  intptr_t* fp = _get_previous_fp();\n-#endif \/\/ AMD64\n-\n-  frame myframe((intptr_t*)os::current_stack_pointer(),\n-                (intptr_t*)fp,\n-                CAST_FROM_FN_PTR(address, os::current_frame));\n-  if (os::is_first_C_frame(&myframe)) {\n-    \/\/ stack is not walkable\n-    return frame();\n-  } else {\n-    return os::get_sender_for_C_frame(&myframe);\n-  }\n+  return frame();  \/\/ cannot walk Windows frames this way.  See os::get_native_stack\n+                   \/\/ and os::platform_print_native_stack\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":9,"deletions":47,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-  static ByteSize byte_width_of_index() { return in_ByteSize(sizeof(size_t)); }\n+  static constexpr ByteSize byte_width_of_index() { return in_ByteSize(sizeof(size_t)); }\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1693,1 +1693,3 @@\n-    parallel_cleaning(false \/* full gc*\/);\n+    if (is_degenerated_gc_in_progress()) {\n+      parallel_cleaning(false \/* full gc*\/);\n+    }\n@@ -1764,4 +1766,2 @@\n-          \/\/ We only evacuate\/update thread and serial weak roots at this pause\n-          ShenandoahRootVerifier::RootTypes types = ShenandoahRootVerifier::combine(ShenandoahRootVerifier::ThreadRoots,\n-                                                                                    ShenandoahRootVerifier::SerialWeakRoots);\n-          verifier()->verify_roots_no_forwarded(types);\n+          \/\/ We only evacuate\/update thread roots at this pause\n+          verifier()->verify_roots_no_forwarded(ShenandoahRootVerifier::ThreadRoots);\n@@ -1854,0 +1854,3 @@\n+    \/\/ Setup EvacOOM scope below reentrant lock to avoid deadlock with\n+    \/\/ nmethod_entry_barrier\n+    ShenandoahEvacOOMScope oom;\n@@ -1890,1 +1893,0 @@\n-    ShenandoahEvacOOMScope oom;\n@@ -1892,5 +1894,7 @@\n-      \/\/ vm_roots and weak_roots are OopStorage backed roots, concurrent iteration\n-      \/\/ may race against OopStorage::release() calls.\n-      ShenandoahEvacUpdateOopStorageRootsClosure cl;\n-      _vm_roots.oops_do<ShenandoahEvacUpdateOopStorageRootsClosure>(&cl, worker_id);\n-    }\n+      ShenandoahEvacOOMScope oom;\n+      {\n+        \/\/ vm_roots and weak_roots are OopStorage backed roots, concurrent iteration\n+        \/\/ may race against OopStorage::release() calls.\n+        ShenandoahEvacUpdateOopStorageRootsClosure cl;\n+        _vm_roots.oops_do<ShenandoahEvacUpdateOopStorageRootsClosure>(&cl, worker_id);\n+      }\n@@ -1898,4 +1902,5 @@\n-    {\n-      ShenandoahEvacuateUpdateRootsClosure<> cl;\n-      CLDToOopClosure clds(&cl, ClassLoaderData::_claim_strong);\n-      _cld_roots.cld_do(&clds, worker_id);\n+      {\n+        ShenandoahEvacuateUpdateRootsClosure<> cl;\n+        CLDToOopClosure clds(&cl, ClassLoaderData::_claim_strong);\n+        _cld_roots.cld_do(&clds, worker_id);\n+      }\n@@ -1904,0 +1909,1 @@\n+    \/\/ Cannot setup ShenandoahEvacOOMScope here, due to potential deadlock with nmethod_entry_barrier.\n@@ -1994,0 +2000,2 @@\n+\n+    _dedup_roots.prologue();\n@@ -1997,0 +2005,2 @@\n+    _dedup_roots.epilogue();\n+\n@@ -2414,1 +2424,0 @@\n-\n@@ -2419,1 +2428,1 @@\n-                            ShenandoahPhaseTimings::purge_class_unload);\n+                            ShenandoahPhaseTimings::degen_gc_purge_class_unload);\n@@ -2431,1 +2440,1 @@\n-                            ShenandoahPhaseTimings::purge_cldg);\n+                            ShenandoahPhaseTimings::degen_gc_purge_cldg);\n@@ -2446,1 +2455,1 @@\n-                               ShenandoahPhaseTimings::purge);\n+                               ShenandoahPhaseTimings::degen_gc_purge);\n@@ -2450,1 +2459,1 @@\n-                                               ShenandoahPhaseTimings::purge_weak_par;\n+                                               ShenandoahPhaseTimings::degen_gc_purge_weak_par;\n@@ -2459,1 +2468,1 @@\n-      cleaning_task(timing_phase, &is_alive, &keep_alive, num_workers, is_stw_gc_in_progress());\n+      cleaning_task(timing_phase, &is_alive, &keep_alive, num_workers);\n@@ -2466,1 +2475,1 @@\n-      cleaning_task(timing_phase, &is_alive, &verify_cl, num_workers, is_stw_gc_in_progress());\n+      cleaning_task(timing_phase, &is_alive, &verify_cl, num_workers);\n@@ -2469,1 +2478,1 @@\n-      cleaning_task(timing_phase, &is_alive, &do_nothing_cl, num_workers, is_stw_gc_in_progress());\n+      cleaning_task(timing_phase, &is_alive, &do_nothing_cl, num_workers);\n@@ -2477,0 +2486,1 @@\n+  assert(is_stw_gc_in_progress(), \"Only for Degenerated and Full GC\");\n@@ -2478,3 +2488,1 @@\n-  if (!ShenandoahConcurrentRoots::should_do_concurrent_class_unloading()) {\n-    stw_unload_classes(full_gc);\n-  }\n+  stw_unload_classes(full_gc);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":34,"deletions":26,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-  bool                      _include_concurrent_roots;\n@@ -49,2 +48,1 @@\n-                                          uint num_workers,\n-                                          bool include_concurrent_roots);\n+                                          uint num_workers);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,2 +39,1 @@\n-                                                                                                     uint num_workers,\n-                                                                                                     bool include_concurrent_roots) :\n+                                                                                                     uint num_workers) :\n@@ -43,1 +42,1 @@\n-  _is_alive(is_alive), _keep_alive(keep_alive), _include_concurrent_roots(include_concurrent_roots) {\n+  _is_alive(is_alive), _keep_alive(keep_alive) {\n@@ -56,3 +55,1 @@\n-  if (_include_concurrent_roots) {\n-    _weak_processing_task.report_num_dead();\n-  }\n+  _weak_processing_task.report_num_dead();\n@@ -63,3 +60,1 @@\n-  if (_include_concurrent_roots) {\n-    _weak_processing_task.work<IsAlive, KeepAlive>(worker_id, _is_alive, _keep_alive);\n-  }\n+  _weak_processing_task.work<IsAlive, KeepAlive>(worker_id, _is_alive, _keep_alive);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahParallelCleaning.inline.hpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -111,2 +111,2 @@\n-    case purge_class_unload:\n-    case purge_weak_par:\n+    case degen_gc_purge_class_unload:\n+    case degen_gc_purge_weak_par:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,6 +69,0 @@\n-  f(purge,                                          \"  System Purge\")                  \\\n-  f(purge_class_unload,                             \"    Unload Classes\")              \\\n-  SHENANDOAH_PAR_PHASE_DO(purge_cu_par_,            \"      CU: \", f)                   \\\n-  f(purge_weak_par,                                 \"    Weak Roots\")                  \\\n-  SHENANDOAH_PAR_PHASE_DO(purge_weak_par_,          \"      WR: \", f)                   \\\n-  f(purge_cldg,                                     \"    CLDG\")                        \\\n@@ -127,0 +121,6 @@\n+  f(degen_gc_purge,                                  \"   System Purge\")                \\\n+  f(degen_gc_purge_class_unload,                     \"     Unload Classes\")            \\\n+  SHENANDOAH_PAR_PHASE_DO(degen_gc_purge_cu_par_,    \"       DCU: \", f)                \\\n+  f(degen_gc_purge_weak_par,                         \"     Weak Roots\")                \\\n+  SHENANDOAH_PAR_PHASE_DO(degen_gc_purge_weak_p_,    \"       DWR: \", f)                \\\n+  f(degen_gc_purge_cldg,                             \"     CLDG\")                      \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+}\n+\n+void ShenandoahConcurrentStringDedupRoots::prologue() {\n@@ -88,1 +91,1 @@\n-ShenandoahConcurrentStringDedupRoots::~ShenandoahConcurrentStringDedupRoots() {\n+void ShenandoahConcurrentStringDedupRoots::epilogue() {\n@@ -172,2 +175,0 @@\n-\n-  \/\/ Process light-weight\/limited parallel roots then\n@@ -226,0 +227,1 @@\n+   _dedup_roots.prologue();\n@@ -228,0 +230,4 @@\n+ShenandoahHeapIterationRootScanner::~ShenandoahHeapIterationRootScanner() {\n+  _dedup_roots.epilogue();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -96,1 +96,3 @@\n-  ~ShenandoahConcurrentStringDedupRoots();\n+\n+  void prologue();\n+  void epilogue();\n@@ -194,0 +196,1 @@\n+  ~ShenandoahHeapIterationRootScanner();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -102,3 +102,1 @@\n-    concurrent_weak_roots_do(oops);\n-  } else if (verify(ConcurrentWeakRoots)) {\n-    concurrent_weak_roots_do(oops);\n+    weak_roots_do(oops);\n@@ -158,1 +156,1 @@\n-void ShenandoahRootVerifier::concurrent_weak_roots_do(OopClosure* cl) {\n+void ShenandoahRootVerifier::weak_roots_do(OopClosure* cl) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,5 +50,3 @@\n-    SerialWeakRoots     = 1 << 4,\n-    ConcurrentWeakRoots = 1 << 5,\n-    WeakRoots           = (SerialWeakRoots | ConcurrentWeakRoots),\n-    StringDedupRoots    = 1 << 6,\n-    JNIHandleRoots      = 1 << 7,\n+    WeakRoots           = 1 << 4,\n+    StringDedupRoots    = 1 << 5,\n+    JNIHandleRoots      = 1 << 6,\n@@ -75,1 +73,1 @@\n-  void concurrent_weak_roots_do(OopClosure* cl);\n+  void weak_roots_do(OopClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootVerifier.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -718,13 +718,0 @@\n-    switch (weak_roots) {\n-      case _verify_serial_weak_roots:\n-        verifier.excludes(ShenandoahRootVerifier::ConcurrentWeakRoots);\n-        break;\n-      case _verify_concurrent_weak_roots:\n-        verifier.excludes(ShenandoahRootVerifier::SerialWeakRoots);\n-        break;\n-      case _verify_all_weak_roots:\n-        break;\n-      default:\n-        ShouldNotReachHere();\n-    }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -201,19 +201,0 @@\n-uintptr_t ZBarrier::mark_barrier_on_root_oop_slow_path(uintptr_t addr) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at safepoint\");\n-  assert(during_mark(), \"Invalid phase\");\n-\n-  \/\/ Mark\n-  return mark<Follow, Strong, Publish>(addr);\n-}\n-\n-\/\/\n-\/\/ Relocate barrier\n-\/\/\n-uintptr_t ZBarrier::relocate_barrier_on_root_oop_slow_path(uintptr_t addr) {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Should be at safepoint\");\n-  assert(during_relocate(), \"Invalid phase\");\n-\n-  \/\/ Relocate\n-  return relocate(addr);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.cpp","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -76,3 +76,0 @@\n-  static uintptr_t mark_barrier_on_root_oop_slow_path(uintptr_t addr);\n-\n-  static uintptr_t relocate_barrier_on_root_oop_slow_path(uintptr_t addr);\n@@ -115,1 +112,0 @@\n-  static void mark_barrier_on_root_oop_field(oop* p);\n@@ -118,3 +114,0 @@\n-  \/\/ Relocate barrier\n-  static void relocate_barrier_on_root_oop_field(oop* p);\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -410,13 +410,0 @@\n-inline void ZBarrier::mark_barrier_on_root_oop_field(oop* p) {\n-  const oop o = *p;\n-  root_barrier<is_good_or_null_fast_path, mark_barrier_on_root_oop_slow_path>(p, o);\n-}\n-\n-\/\/\n-\/\/ Relocate barrier\n-\/\/\n-inline void ZBarrier::relocate_barrier_on_root_oop_field(oop* p) {\n-  const oop o = *p;\n-  root_barrier<is_good_or_null_fast_path, relocate_barrier_on_root_oop_slow_path>(p, o);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-const uint64_t    ZMarkCompleteTimeout          = 1000; \/\/ us\n+const uint64_t    ZMarkCompleteTimeout          = 200; \/\/ us\n","filename":"src\/hotspot\/share\/gc\/z\/zGlobals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/z\/zRootsIterator.hpp\"\n@@ -56,5 +55,0 @@\n-class ZPhantomKeepAliveOopClosure : public OopClosure {\n-public:\n-  virtual void do_oop(oop* p);\n-  virtual void do_oop(narrowOop* p);\n-};\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,8 +79,0 @@\n-inline void ZPhantomKeepAliveOopClosure::do_oop(oop* p) {\n-  ZBarrier::keep_alive_barrier_on_phantom_oop_field(p);\n-}\n-\n-inline void ZPhantomKeepAliveOopClosure::do_oop(narrowOop* p) {\n-  ShouldNotReachHere();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.inline.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-#include \"gc\/z\/zHeap.hpp\"\n-#include \"gc\/z\/zOopClosures.inline.hpp\"\n+#include \"gc\/z\/zHeap.inline.hpp\"\n@@ -42,1 +41,0 @@\n-static const ZStatSubPhase ZSubPhasePauseRootsJVMTITagMap(\"Pause Roots JVMTITagMap\");\n@@ -47,11 +45,0 @@\n-class ZRelocateRootsIteratorClosure : public OopClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    ZBarrier::relocate_barrier_on_root_oop_field(p);\n-  }\n-\n-  virtual void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocate.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/threadLocalAllocBuffer.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zStackWatermark.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/z\/zRootsIterator.hpp\"\n","filename":"src\/hotspot\/share\/gc\/z\/zWeakRootsProcessor.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-  void process_weak_roots();\n","filename":"src\/hotspot\/share\/gc\/z\/zWeakRootsProcessor.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -385,0 +385,11 @@\n+\/\/ Calculates the total number of committed words over all chunks. Walks chunks.\n+size_t ChunkManager::calc_committed_word_size() const {\n+  MutexLocker fcl(MetaspaceExpand_lock, Mutex::_no_safepoint_check_flag);\n+  return calc_committed_word_size_locked();\n+}\n+\n+size_t ChunkManager::calc_committed_word_size_locked() const {\n+  assert_lock_strong(MetaspaceExpand_lock);\n+  return _chunks.calc_committed_word_size();\n+}\n+\n@@ -390,1 +401,1 @@\n-    out->_committed_word_size[l] += _chunks.committed_word_size_at_level(l);\n+    out->_committed_word_size[l] += _chunks.calc_committed_word_size_at_level(l);\n@@ -421,2 +432,2 @@\n-  st->print_cr(\"cm %s: %d chunks, total word size: \" SIZE_FORMAT \", committed word size: \" SIZE_FORMAT, _name,\n-               total_num_chunks(), total_word_size(), _chunks.committed_word_size());\n+  st->print_cr(\"cm %s: %d chunks, total word size: \" SIZE_FORMAT \".\", _name,\n+               total_num_chunks(), total_word_size());\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.cpp","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -110,0 +110,3 @@\n+  \/\/ Calculates the total number of committed words over all chunks. Walks chunks.\n+  size_t calc_committed_word_size_locked() const;\n+\n@@ -170,2 +173,2 @@\n-  \/\/ Returns number of committed words in all free chunks.\n-  size_t total_committed_word_size() const  { return _chunks.committed_word_size(); }\n+  \/\/ Calculates the total number of committed words over all chunks. Walks chunks.\n+  size_t calc_committed_word_size() const;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,9 @@\n+\/\/ Calculates total number of committed words over all chunks (walks chunks).\n+size_t FreeChunkList::calc_committed_word_size() const {\n+  size_t s = 0;\n+  for (const Metachunk* c = _first; c != NULL; c = c->next()) {\n+    s += c->committed_words();\n+  }\n+  return s;\n+}\n+\n@@ -63,1 +72,0 @@\n-    size_t committed = 0;\n@@ -74,1 +82,0 @@\n-      committed += c->committed_words();\n@@ -78,1 +85,0 @@\n-    _committed_word_size.check(committed);\n@@ -93,2 +99,2 @@\n-\/\/ Returns total committed size in all lists\n-size_t FreeChunkListVector::committed_word_size() const {\n+\/\/ Calculates total number of committed words over all chunks (walks chunks).\n+size_t FreeChunkListVector::calc_committed_word_size() const {\n@@ -97,1 +103,1 @@\n-    sum += list_for_level(l)->committed_word_size();\n+    sum += calc_committed_word_size_at_level(l);\n@@ -102,0 +108,4 @@\n+size_t FreeChunkListVector::calc_committed_word_size_at_level(chunklevel_t lvl) const {\n+  return list_for_level(lvl)->calc_committed_word_size();\n+}\n+\n@@ -149,2 +159,2 @@\n-  st->print_cr(\"total chunks: %d, total word size: \" SIZE_FORMAT \", committed word size: \" SIZE_FORMAT \".\",\n-               num_chunks(), word_size(), committed_word_size());\n+  st->print_cr(\"total chunks: %d, total word size: \" SIZE_FORMAT \".\",\n+               num_chunks(), word_size());\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeChunkList.cpp","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  SizeCounter _committed_word_size;\n@@ -132,1 +131,0 @@\n-    _committed_word_size.decrement_by(c->committed_words());\n@@ -147,1 +145,0 @@\n-    _committed_word_size.increment_by(c->committed_words());\n@@ -189,2 +186,2 @@\n-  \/\/ Returns total committed word size\n-  size_t committed_word_size() const { return _committed_word_size.get(); }\n+  \/\/ Calculates total number of committed words over all chunks (walks chunks).\n+  size_t calc_committed_word_size() const;\n@@ -229,5 +226,0 @@\n-  \/\/ Returns number of chunks for a given level.\n-  size_t committed_word_size_at_level(chunklevel_t lvl) const {\n-    return list_for_level(lvl)->committed_word_size();\n-  }\n-\n@@ -250,1 +242,1 @@\n-  \/\/ Returns total size in all lists (regardless of commit state of underlying memory)\n+  \/\/ Returns total size in all lists (including uncommitted areas)\n@@ -253,2 +245,5 @@\n-  \/\/ Returns total committed size in all lists\n-  size_t committed_word_size() const;\n+  \/\/ Calculates total number of committed words over all chunks (walks chunks).\n+  size_t calc_committed_word_size_at_level(chunklevel_t lvl) const;\n+\n+  \/\/ Calculates total number of committed words over all chunks (walks chunks).\n+  size_t calc_committed_word_size() const;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeChunkList.hpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -409,0 +409,12 @@\n+\/\/---------------------print_method_with_lineno--------------------------------\n+void JVMState::print_method_with_lineno(outputStream* st, bool show_name) const {\n+  if (show_name) _method->print_short_name(st);\n+\n+  int lineno = _method->line_number_from_bci(_bci);\n+  if (lineno != -1) {\n+    st->print(\" @ bci:%d (line %d)\", _bci, lineno);\n+  } else {\n+    st->print(\" @ bci:%d\", _bci);\n+  }\n+}\n+\n@@ -413,2 +425,1 @@\n-    _method->print_short_name(st);\n-    st->print(\" @ bci:%d \",_bci);\n+    print_method_with_lineno(st, true);\n@@ -540,3 +551,1 @@\n-    if (!printed)\n-      _method->print_short_name(st);\n-    st->print(\" @ bci:%d\",_bci);\n+    print_method_with_lineno(st, !printed);\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -309,0 +309,1 @@\n+  void      print_method_with_lineno(outputStream* st, bool show_name) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -892,0 +892,5 @@\n+\n+  \/\/ Vector API support (implemented in vectorIntrinsics.cpp)\n+  Node* box_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool deoptimize_on_exception = false);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n+  Node* vector_shift_count(Node* cnt, int shift_op, BasicType bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -327,3 +327,0 @@\n-  Node* box_vector(Node* in, const TypeInstPtr* vbox_type, BasicType bt, int num_elem);\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType bt, int num_elem, bool shuffle_to_vector = false);\n-  Node* shift_count(Node* cnt, int shift_op, BasicType bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -963,1 +963,3 @@\n-      assert( false, \"Parse::remove_useless_nodes missed this node\");\n+      \/\/ If remove_useless_nodes() has run, we expect no such nodes left.\n+      assert(!UseLoopSafepoints || !OptoRemoveUseless,\n+             \"remove_useless_nodes missed this node\");\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -195,6 +195,0 @@\n-        PreserveReexecuteState prs(&kit);\n-\n-        kit.jvms()->set_should_reexecute(true);\n-\n-        const TypeInstPtr* vbox_type = vec_box->box_type();\n-        const TypeVect* vect_type = vec_box->vec_type();\n@@ -202,0 +196,4 @@\n+        const TypeInstPtr* vbox_type = vec_box->box_type();\n+        const TypeVect* vt = vec_box->vec_type();\n+        BasicType elem_bt = vt->element_basic_type();\n+        int num_elem = vt->length();\n@@ -203,8 +201,1 @@\n-        VectorBoxAllocateNode* alloc = new VectorBoxAllocateNode(C, vbox_type);\n-        kit.set_edges_for_java_call(alloc, \/*must_throw=*\/false, \/*separate_io_proj=*\/true);\n-        kit.make_slow_call_ex(alloc, C->env()->Throwable_klass(), \/*separate_io_proj=*\/true, \/*deoptimize=*\/true);\n-        kit.set_i_o(gvn.transform( new ProjNode(alloc, TypeFunc::I_O) ));\n-        kit.set_all_memory(gvn.transform( new ProjNode(alloc, TypeFunc::Memory) ));\n-        Node* ret = gvn.transform(new ProjNode(alloc, TypeFunc::Parms));\n-\n-        new_vbox = gvn.transform(new VectorBoxNode(C, ret, vect, vbox_type, vect_type));\n+        new_vbox = kit.box_vector(vect, vbox_type, elem_bt, num_elem, \/*deoptimize=*\/true);\n@@ -370,6 +361,6 @@\n-                                                            vec_field,\n-                                                            vec_adr_type,\n-                                                            arr,\n-                                                            TypeOopPtr::make_from_klass(field->type()->as_klass()),\n-                                                            T_OBJECT,\n-                                                            IN_HEAP));\n+                                                        vec_field,\n+                                                        vec_adr_type,\n+                                                        arr,\n+                                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n+                                                        T_OBJECT,\n+                                                        IN_HEAP));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -32,0 +32,70 @@\n+#ifdef ASSERT\n+static bool is_vector(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n+}\n+\n+static bool check_vbox(const TypeInstPtr* vbox_type) {\n+  assert(vbox_type->klass_is_exact(), \"\");\n+\n+  ciInstanceKlass* ik = vbox_type->klass()->as_instance_klass();\n+  assert(is_vector(ik), \"not a vector\");\n+\n+  ciField* fd1 = ik->get_field_by_name(ciSymbol::ETYPE_name(), ciSymbol::class_signature(), \/* is_static *\/ true);\n+  assert(fd1 != NULL, \"element type info is missing\");\n+\n+  ciConstant val1 = fd1->constant_value();\n+  BasicType elem_bt = val1.as_object()->as_instance()->java_mirror_type()->basic_type();\n+  assert(is_java_primitive(elem_bt), \"element type info is missing\");\n+\n+  ciField* fd2 = ik->get_field_by_name(ciSymbol::VLENGTH_name(), ciSymbol::int_signature(), \/* is_static *\/ true);\n+  assert(fd2 != NULL, \"vector length info is missing\");\n+\n+  ciConstant val2 = fd2->constant_value();\n+  assert(val2.as_int() > 0, \"vector length info is missing\");\n+\n+  return true;\n+}\n+#endif\n+\n+Node* GraphKit::box_vector(Node* vector, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool deoptimize_on_exception) {\n+  assert(EnableVectorSupport, \"\");\n+\n+  PreserveReexecuteState preexecs(this);\n+  jvms()->set_should_reexecute(true);\n+\n+  VectorBoxAllocateNode* alloc = new VectorBoxAllocateNode(C, vbox_type);\n+  set_edges_for_java_call(alloc, \/*must_throw=*\/false, \/*separate_io_proj=*\/true);\n+  make_slow_call_ex(alloc, env()->Throwable_klass(), \/*separate_io_proj=*\/true, deoptimize_on_exception);\n+  set_i_o(gvn().transform( new ProjNode(alloc, TypeFunc::I_O) ));\n+  set_all_memory(gvn().transform( new ProjNode(alloc, TypeFunc::Memory) ));\n+  Node* ret = gvn().transform(new ProjNode(alloc, TypeFunc::Parms));\n+\n+  assert(check_vbox(vbox_type), \"\");\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  VectorBoxNode* vbox = new VectorBoxNode(C, ret, vector, vbox_type, vt);\n+  return gvn().transform(vbox);\n+}\n+\n+Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n+  assert(EnableVectorSupport, \"\");\n+  const TypeInstPtr* vbox_type_v = gvn().type(v)->is_instptr();\n+  if (vbox_type->klass() != vbox_type_v->klass()) {\n+    return NULL; \/\/ arguments don't agree on vector shapes\n+  }\n+  if (vbox_type_v->maybe_null()) {\n+    return NULL; \/\/ no nulls are allowed\n+  }\n+  assert(check_vbox(vbox_type), \"\");\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory(), shuffle_to_vector));\n+  return unbox;\n+}\n+\n+Node* GraphKit::vector_shift_count(Node* cnt, int shift_op, BasicType bt, int num_elem) {\n+  assert(bt == T_INT || bt == T_LONG || bt == T_SHORT || bt == T_BYTE, \"byte, short, long and int are supported\");\n+  juint mask = (type2aelembytes(bt) * BitsPerByte - 1);\n+  Node* nmask = gvn().transform(ConNode::make(TypeInt::make(mask)));\n+  Node* mcnt = gvn().transform(new AndINode(cnt, nmask));\n+  return gvn().transform(VectorNode::shift_count(shift_op, mcnt, num_elem, bt));\n+}\n+\n@@ -111,60 +181,0 @@\n-#ifdef ASSERT\n-static bool is_vector(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n-}\n-\n-static bool check_vbox(const TypeInstPtr* vbox_type) {\n-  assert(vbox_type->klass_is_exact(), \"\");\n-\n-  ciInstanceKlass* ik = vbox_type->klass()->as_instance_klass();\n-  assert(is_vector(ik), \"not a vector\");\n-\n-  ciField* fd1 = ik->get_field_by_name(ciSymbol::ETYPE_name(), ciSymbol::class_signature(), \/* is_static *\/ true);\n-  assert(fd1 != NULL, \"element type info is missing\");\n-\n-  ciConstant val1 = fd1->constant_value();\n-  BasicType elem_bt = val1.as_object()->as_instance()->java_mirror_type()->basic_type();\n-  assert(is_java_primitive(elem_bt), \"element type info is missing\");\n-\n-  ciField* fd2 = ik->get_field_by_name(ciSymbol::VLENGTH_name(), ciSymbol::int_signature(), \/* is_static *\/ true);\n-  assert(fd2 != NULL, \"vector length info is missing\");\n-\n-  ciConstant val2 = fd2->constant_value();\n-  assert(val2.as_int() > 0, \"vector length info is missing\");\n-\n-  return true;\n-}\n-#endif\n-\n-Node* LibraryCallKit::box_vector(Node* vector, const TypeInstPtr* vbox_type,\n-                                 BasicType elem_bt, int num_elem) {\n-  assert(EnableVectorSupport, \"\");\n-  const TypeVect* vec_type = TypeVect::make(elem_bt, num_elem);\n-\n-  VectorBoxAllocateNode* alloc = new VectorBoxAllocateNode(C, vbox_type);\n-  set_edges_for_java_call(alloc, \/*must_throw=*\/false, \/*separate_io_proj=*\/true);\n-  make_slow_call_ex(alloc, env()->Throwable_klass(), \/*separate_io_proj=*\/true);\n-  set_i_o(gvn().transform( new ProjNode(alloc, TypeFunc::I_O) ));\n-  set_all_memory(gvn().transform( new ProjNode(alloc, TypeFunc::Memory) ));\n-  Node* ret = gvn().transform(new ProjNode(alloc, TypeFunc::Parms));\n-\n-  assert(check_vbox(vbox_type), \"\");\n-  VectorBoxNode* vbox = new VectorBoxNode(C, ret, vector, vbox_type, vec_type);\n-  return gvn().transform(vbox);\n-}\n-\n-Node* LibraryCallKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n-  assert(EnableVectorSupport, \"\");\n-  const TypeInstPtr* vbox_type_v = gvn().type(v)->is_instptr();\n-  if (vbox_type->klass() != vbox_type_v->klass()) {\n-    return NULL; \/\/ arguments don't agree on vector shapes\n-  }\n-  if (vbox_type_v->maybe_null()) {\n-    return NULL; \/\/ no nulls are allowed\n-  }\n-  assert(check_vbox(vbox_type), \"\");\n-  const TypeVect* vec_type = TypeVect::make(elem_bt, num_elem);\n-  Node* unbox = gvn().transform(new VectorUnboxNode(C, vec_type, v, merged_memory(), shuffle_to_vector));\n-  return unbox;\n-}\n-\n@@ -1168,8 +1178,0 @@\n-Node* LibraryCallKit::shift_count(Node* cnt, int shift_op, BasicType bt, int num_elem) {\n-  assert(bt == T_INT || bt == T_LONG || bt == T_SHORT || bt == T_BYTE, \"byte, short, long and int are supported\");\n-  juint mask = (type2aelembytes(bt) * BitsPerByte - 1);\n-  Node* nmask = gvn().transform(ConNode::make(TypeInt::make(mask)));\n-  Node* mcnt = gvn().transform(new AndINode(cnt, nmask));\n-  return gvn().transform(VectorNode::shift_count(shift_op, mcnt, num_elem, bt));\n-}\n-\n@@ -1226,1 +1228,1 @@\n-  Node* opd2 = shift_count(argument(5), opc, elem_bt, num_elem);\n+  Node* opd2 = vector_shift_count(argument(5), opc, elem_bt, num_elem);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":71,"deletions":69,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -86,3 +86,9 @@\n-void VectorSupport::init_vector_array(typeArrayOop arr, BasicType elem_bt, int num_elem, address value_addr) {\n-  int elem_size = type2aelembytes(elem_bt);\n-  for (int i = 0; i < num_elem; i++) {\n+void VectorSupport::init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr) {\n+  if (is_mask) {\n+    \/\/ Masks require special handling: when boxed they are packed and stored in boolean\n+    \/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n+    \/\/ For example, Int512Mask is represented in memory as boolean[16], but\n+    \/\/ occupies the whole 512-bit vector register when scalarized.\n+    \/\/ (In generated code, the conversion is performed by VectorStoreMask.)\n+    \/\/\n+    \/\/ TODO: revisit when predicate registers are fully supported.\n@@ -90,32 +96,8 @@\n-      case T_BYTE: {\n-        jbyte elem_value = *(jbyte*) (value_addr + i * elem_size);\n-        arr->byte_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_SHORT: {\n-        jshort elem_value = *(jshort*) (value_addr + i * elem_size);\n-        arr->short_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_INT: {\n-        jint elem_value = *(jint*) (value_addr + i * elem_size);\n-        arr->int_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_LONG: {\n-        jlong elem_value = *(jlong*) (value_addr + i * elem_size);\n-        arr->long_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_FLOAT: {\n-        jfloat elem_value = *(jfloat*) (value_addr + i * elem_size);\n-        arr->float_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_DOUBLE: {\n-        jdouble elem_value = *(jdouble*) (value_addr + i * elem_size);\n-        arr->double_at_put(i, elem_value);\n-        break;\n-      }\n-      default:\n-        fatal(\"unsupported: %s\", type2name(elem_bt));\n+      case T_BYTE:   arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n+      case T_SHORT:  arr->bool_at_put(index, (*(jshort*)addr) != 0); break;\n+      case T_INT:    \/\/ fall-through\n+      case T_FLOAT:  arr->bool_at_put(index,   (*(jint*)addr) != 0); break;\n+      case T_LONG:   \/\/ fall-through\n+      case T_DOUBLE: arr->bool_at_put(index,  (*(jlong*)addr) != 0); break;\n+\n+      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n@@ -123,7 +105,1 @@\n-  }\n-}\n-\n-void VectorSupport::init_mask_array(typeArrayOop arr, BasicType elem_bt, int num_elem, address value_addr) {\n-  int elem_size = type2aelembytes(elem_bt);\n-\n-  for (int i = 0; i < num_elem; i++) {\n+  } else {\n@@ -131,24 +107,8 @@\n-      case T_BYTE: {\n-        jbyte elem_value = *(jbyte*) (value_addr + i * elem_size);\n-        arr->bool_at_put(i, elem_value != 0);\n-        break;\n-      }\n-      case T_SHORT: {\n-        jshort elem_value = *(jshort*) (value_addr + i * elem_size);\n-        arr->bool_at_put(i, elem_value != 0);\n-        break;\n-      }\n-      case T_INT:   \/\/ fall-through\n-      case T_FLOAT: {\n-        jint elem_value = *(jint*) (value_addr + i * elem_size);\n-        arr->bool_at_put(i, elem_value != 0);\n-        break;\n-      }\n-      case T_LONG: \/\/ fall-through\n-      case T_DOUBLE: {\n-        jlong elem_value = *(jlong*) (value_addr + i * elem_size);\n-        arr->bool_at_put(i, elem_value != 0);\n-        break;\n-      }\n-      default:\n-        fatal(\"unsupported: %s\", type2name(elem_bt));\n+      case T_BYTE:   arr->  byte_at_put(index,   *(jbyte*)addr); break;\n+      case T_SHORT:  arr-> short_at_put(index,  *(jshort*)addr); break;\n+      case T_INT:    arr->   int_at_put(index,    *(jint*)addr); break;\n+      case T_FLOAT:  arr-> float_at_put(index,  *(jfloat*)addr); break;\n+      case T_LONG:   arr->  long_at_put(index,   *(jlong*)addr); break;\n+      case T_DOUBLE: arr->double_at_put(index, *(jdouble*)addr); break;\n+\n+      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n@@ -159,2 +119,1 @@\n-oop VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, BasicType elem_bt, int num_elem, address value_addr, TRAPS) {\n-\n+Handle VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS) {\n@@ -163,0 +122,4 @@\n+  int num_elem = klass2length(ik);\n+  BasicType elem_bt = klass2bt(ik);\n+  int elem_size = type2aelembytes(elem_bt);\n+\n@@ -166,1 +129,1 @@\n-  typeArrayOop arr = tak->allocate(num_elem, CHECK_NULL); \/\/ safepoint\n+  typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); \/\/ safepoint\n@@ -168,2 +131,27 @@\n-  if (is_mask) {\n-    init_mask_array(arr, elem_bt, num_elem, value_addr);\n+  if (location.is_register()) {\n+    \/\/ Value was in a callee-saved register.\n+    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+\n+    for (int i = 0; i < num_elem; i++) {\n+      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n+      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+\n+      address elem_addr = reg_map->location(vreg->next(vslot)) + off;\n+      init_payload_element(arr, is_mask, elem_bt, i, elem_addr);\n+    }\n+  } else {\n+    \/\/ Value was directly saved on the stack.\n+    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+    for (int i = 0; i < num_elem; i++) {\n+      init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size);\n+    }\n+  }\n+  return Handle(THREAD, arr);\n+}\n+\n+Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS) {\n+  if (payload->is_location() &&\n+      payload->as_LocationValue()->location().type() == Location::vector) {\n+    \/\/ Vector value in an aligned adjacent tuple (1, 2, 4, 8, or 16 slots).\n+    Location location = payload->as_LocationValue()->location();\n+    return allocate_vector_payload_helper(ik, fr, reg_map, location, THREAD); \/\/ safepoint\n@@ -171,1 +159,3 @@\n-    init_vector_array(arr, elem_bt, num_elem, value_addr);\n+    \/\/ Scalar-replaced boxed vector representation.\n+    StackValue* value = StackValue::create_stack_value(fr, reg_map, payload);\n+    return value->get_obj();\n@@ -173,1 +163,0 @@\n-  return arr;\n@@ -176,1 +165,1 @@\n-oop VectorSupport::allocate_vector(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n+instanceOop VectorSupport::allocate_vector(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n@@ -180,26 +169,5 @@\n-  \/\/ Vector value in an aligned adjacent tuple (1, 2, 4, 8, or 16 slots).\n-  LocationValue* loc_value = ov->field_at(0)->as_LocationValue();\n-\n-  BasicType elem_bt = klass2bt(ik);\n-  int num_elem = klass2length(ik);\n-\n-  Handle vbox = ik->allocate_instance_handle(CHECK_NULL);\n-\n-  Location loc = loc_value->location();\n-\n-  oop payload = NULL;\n-  if (loc.type() == Location::vector) {\n-    address value_addr = loc.is_register()\n-        \/\/ Value was in a callee-save register\n-        ? reg_map->location(VMRegImpl::as_VMReg(loc.register_number()))\n-        \/\/ Else value was directly saved on the stack. The frame's original stack pointer,\n-        \/\/ before any extension by its callee (due to Compiler1 linkage on SPARC), must be used.\n-        : ((address)fr->unextended_sp()) + loc.stack_offset();\n-    payload = allocate_vector_payload_helper(ik, elem_bt, num_elem, value_addr, CHECK_NULL); \/\/ safepoint\n-  } else {\n-    \/\/ assert(false, \"interesting\");\n-    StackValue* value = StackValue::create_stack_value(fr, reg_map, loc_value);\n-    payload = value->get_obj()();\n-  }\n-  vector_VectorPayload::set_payload(vbox(), payload);\n-  return vbox();\n+  ScopeValue* payload_value = ov->field_at(0);\n+  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, fr, reg_map, payload_value, CHECK_NULL);\n+  instanceOop vbox = ik->allocate_instance(CHECK_NULL);\n+  vector_VectorPayload::set_payload(vbox, payload_instance());\n+  return vbox;\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":68,"deletions":100,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -42,3 +42,4 @@\n-  static void init_mask_array(typeArrayOop arr, BasicType elem_bt, int num_elem, address value_addr);\n-  static void init_vector_array(typeArrayOop arr, BasicType elem_bt, int num_elem, address value_addr);\n-  static oop  allocate_vector_payload_helper(InstanceKlass* ik, BasicType elem_bt, int num_elem, address value_addr, TRAPS);\n+  static Handle allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS);\n+  static Handle allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS);\n+\n+  static void init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr);\n@@ -84,1 +85,1 @@\n-  static oop  allocate_vector(InstanceKlass* holder, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);\n+  static instanceOop allocate_vector(InstanceKlass* holder, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1173,2 +1173,1 @@\n-\/\/ stack is walkable beyond current frame. The check for fp() is not\n-\/\/ necessary on Sparc, but it's harmless.\n+\/\/ stack is walkable beyond current frame.\n@@ -1176,0 +1175,5 @@\n+\n+#ifdef _WINDOWS\n+  return true; \/\/ native stack isn't walkable on windows this way.\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.UncheckedIOException;\n@@ -172,2 +173,3 @@\n-        }\n-        catch (IOException e) {\n+        } catch (UncheckedIOException e) {\n+            return defaultRetval;\n+        } catch (IOException e) {\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.io.UncheckedIOException;\n@@ -48,0 +49,2 @@\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n@@ -71,0 +74,2 @@\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n@@ -81,0 +86,2 @@\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.UncheckedIOException;\n@@ -78,0 +79,2 @@\n+        } catch (UncheckedIOException e) {\n+            return null;\n@@ -112,0 +115,2 @@\n+        } catch (UncheckedIOException e) {\n+            return null;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.UncheckedIOException;\n@@ -72,0 +73,2 @@\n+        } catch (UncheckedIOException e) {\n+            return null;\n@@ -90,0 +93,2 @@\n+        } catch (UncheckedIOException e) {\n+            return null;\n@@ -332,0 +337,2 @@\n+        } catch (UncheckedIOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -595,0 +595,2 @@\n+     *\n+     * @since 12\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStream.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,1 +245,2 @@\n- * [Section 1.14, \"Circular References\"<\/a> for additional information).\n+ * <cite>Java Object Serialization Specification,<\/cite>\n+ * Section 1.14, \"Circular References\"<\/a> for additional information).\n@@ -265,1 +266,1 @@\n- *     Object Serialization Specification, Section 3, Object Input Classes<\/a>\n+ *      <cite>Java Object Serialization Specification,<\/cite> Section 3, \"Object Input Classes\"<\/a>\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n- *     Object Serialization Specification, Section 2, Object Output Classes<\/a>\n+ *      <cite>Java Object Serialization Specification,<\/cite> Section 2, \"Object Output Classes\"<\/a>\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n- *     Object Serialization Specification, Section 4.6, Stream Unique Identifiers<\/a>.\n+ *    <cite>Java Object Serialization Specification,<\/cite> Section 4.6, \"Stream Unique Identifiers\"<\/a>.\n@@ -85,1 +85,1 @@\n- *     Object Serialization Specification, Section 4, Class Descriptors<\/a>\n+ *      <cite>Java Object Serialization Specification,<\/cite> Section 4, \"Class Descriptors\"<\/a>\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,14 +46,13 @@\n- * To allow subtypes of non-serializable classes to be serialized, the\n- * subtype may assume responsibility for saving and restoring the\n- * state of the supertype's public, protected, and (if accessible)\n- * package fields.  The subtype may assume this responsibility only if\n- * the class it extends has an accessible no-arg constructor to\n- * initialize the class's state.  It is an error to declare a class\n- * Serializable if this is not the case.  The error will be detected at\n- * runtime. <p>\n- *\n- * During deserialization, the fields of non-serializable classes will\n- * be initialized using the public or protected no-arg constructor of\n- * the class.  A no-arg constructor must be accessible to the subclass\n- * that is serializable.  The fields of serializable subclasses will\n- * be restored from the stream. <p>\n+ * It is possible for subtypes of non-serializable classes to be serialized\n+ * and deserialized. During serialization, no data will be written for the\n+ * fields of non-serializable superclasses. During deserialization, the fields of non-serializable\n+ * superclasses will be initialized using the no-arg constructor of the first (bottommost)\n+ * non-serializable superclass. This constructor must be accessible to the subclass that is being\n+ * deserialized. It is an error to declare a class Serializable if this is not\n+ * the case; the error will be detected at runtime. A serializable subtype may\n+ * assume responsibility for saving and restoring the state of a non-serializable\n+ * supertype's public, protected, and (if accessible) package-access fields. See\n+ * the <a href=\"{@docRoot}\/..\/specs\/serialization\/input.html#the-objectinputstream-class\">\n+ * <cite>Java Object Serialization Specification,<\/cite><\/a> section 3.1, for\n+ * a detailed specification of the deserialization process, including handling of\n+ * serializable and non-serializable classes. <p>\n@@ -138,1 +137,2 @@\n- * the <cite>Java Object Serialization Specification<\/cite> during\n+ * the <a href=\"{@docRoot}\/..\/specs\/serialization\/index.html\"><cite>\n+ * Java Object Serialization Specification<\/cite><\/a> during\n@@ -160,1 +160,2 @@\n- * Java Object Serialization Specification.  This specification defines the\n+ * <a href=\"{@docRoot}\/..\/specs\/serialization\/index.html\"><cite>Java Object Serialization\n+ * Specification.<\/cite><\/a> This specification defines the\n@@ -182,0 +183,2 @@\n+ * @see <a href=\"{@docRoot}\/..\/specs\/serialization\/index.html\">\n+ *      <cite>Java Object Serialization Specification<\/cite><\/a>\n","filename":"src\/java.base\/share\/classes\/java\/io\/Serializable.java","additions":19,"deletions":16,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n- *       Java Object Serialization Specification <\/a>\n+ *       <cite>Java Object Serialization Specification<\/cite><\/a>\n","filename":"src\/java.base\/share\/classes\/java\/io\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3953,3 +3953,9 @@\n-        \/\/ If it's small enough, use smallToString.\n-        if (mag.length <= SCHOENHAGE_BASE_CONVERSION_THRESHOLD)\n-           return smallToString(radix);\n+        BigInteger abs = this.abs();\n+\n+        \/\/ Ensure buffer capacity sufficient to contain string representation\n+        \/\/     floor(bitLength*log(2)\/log(radix)) + 1\n+        \/\/ plus an additional character for the sign if negative.\n+        int b = abs.bitLength();\n+        int numChars = (int)(Math.floor(b*LOG_TWO\/logCache[radix]) + 1) +\n+            (signum < 0 ? 1 : 0);\n+        StringBuilder sb = new StringBuilder(numChars);\n@@ -3957,3 +3963,0 @@\n-        \/\/ Otherwise use recursive toString, which requires positive arguments.\n-        \/\/ The results will be concatenated into this StringBuilder\n-        StringBuilder sb = new StringBuilder();\n@@ -3961,2 +3964,1 @@\n-            toString(this.negate(), sb, radix, 0);\n-            sb.insert(0, '-');\n+            sb.append('-');\n@@ -3964,2 +3966,3 @@\n-        else\n-            toString(this, sb, radix, 0);\n+\n+        \/\/ Use recursive toString.\n+        toString(abs, sb, radix, 0);\n@@ -3970,2 +3973,29 @@\n-    \/** This method is used to perform toString when arguments are small. *\/\n-    private String smallToString(int radix) {\n+    \/**\n+     * If {@code numZeros > 0}, appends that many zeros to the\n+     * specified StringBuilder; otherwise, does nothing.\n+     *\n+     * @param sb        The StringBuilder that will be appended to.\n+     * @param numZeros  The number of zeros to append.\n+     *\/\n+    private static void padWithZeros(StringBuilder buf, int numZeros) {\n+        while (numZeros >= NUM_ZEROS) {\n+            buf.append(ZEROS);\n+            numZeros -= NUM_ZEROS;\n+        }\n+        if (numZeros > 0) {\n+            buf.append(ZEROS, 0, numZeros);\n+        }\n+    }\n+\n+    \/**\n+     * This method is used to perform toString when arguments are small.\n+     * The value must be non-negative. If {@code digits <= 0} no padding\n+     * (pre-pending with zeros) will be effected.\n+     *\n+     * @param radix  The base to convert to.\n+     * @param sb     The StringBuilder that will be appended to in place.\n+     * @param digits The minimum number of digits to pad to.\n+     *\/\n+    private void smallToString(int radix, StringBuilder buf, int digits) {\n+        assert signum >= 0;\n+\n@@ -3973,1 +4003,2 @@\n-            return \"0\";\n+            padWithZeros(buf, digits);\n+            return;\n@@ -3978,1 +4009,1 @@\n-        String digitGroup[] = new String[maxNumDigitGroups];\n+        long[] digitGroups = new long[maxNumDigitGroups];\n@@ -3981,1 +4012,1 @@\n-        BigInteger tmp = this.abs();\n+        BigInteger tmp = this;\n@@ -3993,1 +4024,1 @@\n-            digitGroup[numGroups++] = Long.toString(r2.longValue(), radix);\n+            digitGroups[numGroups++] = r2.longValue();\n@@ -3997,6 +4028,6 @@\n-        \/\/ Put sign (if any) and first digit group into result buffer\n-        StringBuilder buf = new StringBuilder(numGroups*digitsPerLong[radix]+1);\n-        if (signum < 0) {\n-            buf.append('-');\n-        }\n-        buf.append(digitGroup[numGroups-1]);\n+        \/\/ Get string version of first digit group\n+        String s = Long.toString(digitGroups[numGroups-1], radix);\n+\n+        \/\/ Pad with internal zeros if necessary.\n+        padWithZeros(buf, digits - (s.length() +\n+            (numGroups - 1)*digitsPerLong[radix]));\n@@ -4004,1 +4035,4 @@\n-        \/\/ Append remaining digit groups padded with leading zeros\n+        \/\/ Put first digit group into result buffer\n+        buf.append(s);\n+\n+        \/\/ Append remaining digit groups each padded with leading zeros\n@@ -4007,1 +4041,2 @@\n-            int numLeadingZeros = digitsPerLong[radix]-digitGroup[i].length();\n+            s = Long.toString(digitGroups[i], radix);\n+            int numLeadingZeros = digitsPerLong[radix] - s.length();\n@@ -4009,1 +4044,1 @@\n-                buf.append(zeros[numLeadingZeros]);\n+                buf.append(ZEROS, 0, numLeadingZeros);\n@@ -4011,1 +4046,1 @@\n-            buf.append(digitGroup[i]);\n+            buf.append(s);\n@@ -4013,1 +4048,0 @@\n-        return buf.toString();\n@@ -4019,1 +4053,2 @@\n-     * for base conversions.\n+     * for base conversions. This method can only be called for non-negative\n+     * numbers.\n@@ -4029,2 +4064,4 @@\n-    private static void toString(BigInteger u, StringBuilder sb, int radix,\n-                                 int digits) {\n+    private static void toString(BigInteger u, StringBuilder sb,\n+                                 int radix, int digits) {\n+        assert u.signum() >= 0;\n+\n@@ -4032,1 +4069,3 @@\n-        \/\/ method, padding with leading zeroes when necessary.\n+        \/\/ method, padding with leading zeroes when necessary unless we're\n+        \/\/ at the beginning of the string or digits <= 0. As u.signum() >= 0,\n+        \/\/ smallToString() will not prepend a negative sign.\n@@ -4034,11 +4073,1 @@\n-            String s = u.smallToString(radix);\n-\n-            \/\/ Pad with internal zeros if necessary.\n-            \/\/ Don't pad if we're at the beginning of the string.\n-            if ((s.length() < digits) && (sb.length() > 0)) {\n-                for (int i=s.length(); i < digits; i++) {\n-                    sb.append('0');\n-                }\n-            }\n-\n-            sb.append(s);\n+            u.smallToString(radix, sb, digits);\n@@ -4048,3 +4077,0 @@\n-        int b, n;\n-        b = u.bitLength();\n-\n@@ -4054,1 +4080,4 @@\n-        n = (int) Math.round(Math.log(b * LOG_TWO \/ logCache[radix]) \/ LOG_TWO - 1.0);\n+        int b = u.bitLength();\n+        int n = (int) Math.round(Math.log(b * LOG_TWO \/ logCache[radix]) \/\n+                                 LOG_TWO - 1.0);\n+\n@@ -4062,1 +4091,1 @@\n-        toString(results[0], sb, radix, digits-expectedDigits);\n+        toString(results[0], sb, radix, digits - expectedDigits);\n@@ -4094,8 +4123,5 @@\n-    \/* zero[i] is a string of i consecutive zeros. *\/\n-    private static String zeros[] = new String[64];\n-    static {\n-        zeros[63] =\n-            \"000000000000000000000000000000000000000000000000000000000000000\";\n-        for (int i=0; i < 63; i++)\n-            zeros[i] = zeros[63].substring(0, i);\n-    }\n+    \/* Size of ZEROS string. *\/\n+    private static int NUM_ZEROS = 63;\n+\n+    \/* ZEROS is a string of NUM_ZEROS consecutive zeros. *\/\n+    private static final String ZEROS = \"0\".repeat(NUM_ZEROS);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":81,"deletions":55,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n- * localized minus sign ({@code '-'} in most locales) is used as the\n+ * minus sign ({@code '-' U+002D HYPHEN-MINUS}) is used as the\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,0 +130,17 @@\n+\/\/ In order to use a new NSAccessibility API and since our components\n+\/\/ are represented as a custom UI elements we need to implement a set\n+\/\/ of custom protocols. Definitions of these protocols will start here.\n+\n+\/\/ This is a root interface in the NSAccessibility* protocols hierarchy\n+\/\/ and all the component-specific protocols should be derived from it.\n+\/\/ It is also a place for the functions that might be exposed by all the\n+\/\/ component accessibility peers.\n+\/\/ Please see https:\/\/developer.apple.com\/documentation\/appkit\/nsaccessibilityprotocol\n+\/\/ for more details.\n+@interface CommonComponentAccessibility : JavaComponentAccessibility <NSAccessibilityElement> {\n+\n+}\n+- (NSRect)accessibilityFrame;\n+- (nullable id)accessibilityParent;\n+@end\n+\n@@ -1920,0 +1937,26 @@\n+@implementation CommonComponentAccessibility\n+\/\/ NSAccessibilityElement protocol implementation\n+- (NSRect)accessibilityFrame\n+{\n+    JNIEnv* env = [ThreadUtilities getJNIEnv];\n+    jobject axComponent = JNFCallStaticObjectMethod(env, sjm_getAccessibleComponent,\n+                                                    fAccessible, fComponent);\n+\n+    NSSize size = getAxComponentSize(env, axComponent, fComponent);\n+    NSPoint point = getAxComponentLocationOnScreen(env, axComponent, fComponent);\n+    (*env)->DeleteLocalRef(env, axComponent);\n+    point.y += size.height;\n+\n+    point.y = [[[[self view] window] screen] frame].size.height - point.y;\n+\n+    NSRect retval = NSMakeRect(point.x, point.y, size.width, size.height);\n+    return retval;\n+}\n+\n+- (nullable id)accessibilityParent\n+{\n+    return [self accessibilityParentAttribute];\n+}\n+\n+@end\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/JavaComponentAccessibility.m","additions":44,"deletions":1,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.LongSupplier;\n@@ -260,0 +261,3 @@\n+                    \/\/ getTotalPhysicalMemorySize and getFreePhysicalMemorySize are deprecated,\n+                    \/\/ but we want be able to get the data for old target VMs (see JDK-8255934).\n+                    @SuppressWarnings(\"deprecation\")\n@@ -261,2 +265,4 @@\n-                        formatKByteStrings(sunOSMBean.getTotalMemorySize(),\n-                                           sunOSMBean.getFreeMemorySize(),\n+                        formatKByteStrings(tryToGet(sunOSMBean::getTotalMemorySize,\n+                                                    sunOSMBean::getTotalPhysicalMemorySize),\n+                                           tryToGet(sunOSMBean::getFreeMemorySize,\n+                                                    sunOSMBean::getFreePhysicalMemorySize),\n@@ -320,0 +326,14 @@\n+    \/**\n+     * Tries to get the specified value from the list of suppliers.\n+     * Returns -1 if all suppliers fail.\n+     *\/\n+    private long tryToGet(LongSupplier ... getters) {\n+        for (LongSupplier getter : getters) {\n+            try {\n+                return getter.getAsLong();\n+            } catch (UndeclaredThrowableException e) {\n+            }\n+        }\n+        return -1;\n+    }\n+\n","filename":"src\/jdk.jconsole\/share\/classes\/sun\/tools\/jconsole\/SummaryTab.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-    EXPECT_EQ(lst.committed_word_size(), committed_cnt.total_size());\n+    EXPECT_EQ(lst.calc_committed_word_size(), committed_cnt.total_size());\n@@ -140,1 +140,1 @@\n-      EXPECT_EQ(lst.committed_word_size(), committed_cnt.total_size());\n+      EXPECT_EQ(lst.calc_committed_word_size(), committed_cnt.total_size());\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metachunklist.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-  EXPECT_0(context.cm().total_committed_word_size());\n+  EXPECT_0(context.cm().calc_committed_word_size());\n@@ -518,1 +518,1 @@\n-  EXPECT_GT(context.cm().total_committed_word_size(), (size_t)0);\n+  EXPECT_GT(context.cm().calc_committed_word_size(), (size_t)0);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+runtime\/ReservedStack\/ReservedStackTestCompiler.java 8256359 linux-aarch64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 6232281\n+ * @requires vm.debug == true & vm.compiler2.enabled\n+ * @summary Tests that C2 does not crash trivially with a \"remove_useless_nodes\n+ *          missed this node\" message when UseLoopSafepoints is disabled.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+        -XX:CompileOnly=TestDisableUseLoopSafepoints -XX:-UseLoopSafepoints\n+ *      compiler.arguments.TestDisableUseLoopSafepoints\n+ *\/\n+\n+package compiler.arguments;\n+\n+public class TestDisableUseLoopSafepoints {\n+    public static void main(String[] args) {\n+        System.out.println(\"Passed\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestDisableUseLoopSafepoints.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8033441\n+ * @summary Test to ensure that line numbers are now present with the -XX:+PrintOptoAssembly command line option\n+ *\n+ * @requires vm.compiler2.enabled & vm.debug == true\n+ *\n+ * @library \/compiler\/patches \/test\/lib\n+ * @run main\/othervm compiler.arguments.TestPrintOptoAssemblyLineNumbers\n+*\/\n+\n+package compiler.arguments;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class TestPrintOptoAssemblyLineNumbers {\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ create subprocess to run some code with -XX:+PrintOptoAssembly enabled\n+        String[] procArgs = new String[]{\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+PrintOptoAssembly\",\n+            \"compiler.arguments.TestPrintOptoAssemblyLineNumbers$CheckC2OptoAssembly\"\n+            };\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(procArgs);\n+        String output = new OutputAnalyzer(pb.start()).getOutput();\n+\n+        if(output.contains(\"TestPrintOptoAssemblyLineNumbers$CheckC2OptoAssembly::main @ bci:11\")){\n+            \/\/ if C2 optimizer invoked ensure output includes line numbers:\n+            Asserts.assertTrue(output.contains(\"TestPrintOptoAssemblyLineNumbers$CheckC2OptoAssembly::main @ bci:11 (line 68)\"));\n+        }\n+    }\n+\n+    public static class CheckC2OptoAssembly{ \/\/ contents of this class serves to just invoke C2\n+        public static boolean foo(String arg){\n+            return arg.contains(\"45\");\n+        }\n+\n+        public static void main(String[] args){\n+            int count = 0;\n+            for(int x = 0; x < 200_000; x++){\n+                if(foo(\"something\" + x)){ \/\/ <- test expects this line of code to be on line 68\n+                    count += 1;\n+                }\n+            }\n+            System.out.println(\"count: \" + count);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arguments\/TestPrintOptoAssemblyLineNumbers.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx512m\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx128m\n@@ -36,1 +36,1 @@\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx512m\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx128m\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx512m\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx128m\n@@ -52,1 +52,1 @@\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx512m\n+ * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xmx128m\n@@ -68,2 +68,2 @@\n-    private static final int OBJS_COUNT    = 1_000;\n-    private static final int GARBAGE_COUNT = 1_000_000;\n+    private static final int OBJS_COUNT    = 1 << 10;\n+    private static final int GARBAGE_COUNT = 1 << 18;\n@@ -75,0 +75,1 @@\n+        Random rng = Utils.getRandomInstance();\n@@ -76,1 +77,1 @@\n-            test();\n+            test(rng);\n@@ -80,1 +81,1 @@\n-    private static void test() {\n+    private static void test(Random rng) {\n@@ -87,1 +88,0 @@\n-        Random rng = Utils.getRandomInstance();\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/jni\/TestPinnedGarbage.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -Xlog:all=trace:file=all.log RedefineClasses\n+ * @run main\/othervm -Xmx256m -XX:MaxMetaspaceSize=64m -javaagent:redefineagent.jar -XX:+Verbose -Xlog:all=trace:file=all.log RedefineClasses\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/RedefineClasses.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n- * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+Verbose -Xlog:methodhandles TestMethodHandlesVerbose\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+Verbose -Xlog:methodhandles TestMethodHandlesVerbose a b\n@@ -34,0 +34,1 @@\n+        System.out.println(args[0] + args[1]);\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/TestMethodHandlesVerbose.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,0 +260,1 @@\n+        var rng = Utils.getRandomInstance();\n@@ -286,0 +287,7 @@\n+                    \/\/ Stress* are c2-specific stress flags, so IgnoreUnrecognizedVMOptions is needed\n+                    \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                    \"-XX:+StressLCM\",\n+                    \"-XX:+StressGCM\",\n+                    \"-XX:+StressIGVN\",\n+                    \/\/ StressSeed is uint\n+                    \"-XX:StressSeed=\" + Math.abs(rng.nextLong()),\n","filename":"test\/hotspot\/jtreg\/testlibrary\/ctw\/src\/sun\/hotspot\/tools\/ctw\/CtwRunner.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,0 +65,2 @@\n+import sun.hotspot.WhiteBox;\n+import sun.hotspot.gc.GC;\n@@ -68,1 +70,1 @@\n-        sun.hotspot.WhiteBox wb = sun.hotspot.WhiteBox.getWhiteBox();\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n@@ -70,4 +72,4 @@\n-        Boolean isUseG1GCon = wb.getBooleanVMFlag(\"UseG1GC\");\n-        Boolean isUseZGCon = wb.getBooleanVMFlag(\"UseZGC\");\n-        Boolean isShenandoahGCon = wb.getBooleanVMFlag(\"UseShenandoahGC\");\n-        Boolean isUseEpsilonGCon = wb.getBooleanVMFlag(\"UseEpsilonGC\");\n+        boolean isUseG1GCon = GC.G1.isSelected();\n+        boolean isUseZGCon = GC.Z.isSelected();\n+        boolean isShenandoahGCon = GC.Shenandoah.isSelected();\n+        boolean isUseEpsilonGCon = GC.Epsilon.isSelected();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/general_functions\/GF08\/gf08t001\/TestDriver.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465 8074460 8078672 8032027\n+ * @bug 4181191 4161971 4227146 4194389 4823171 4624738 4812225 4837946 4026465 8074460 8078672 8032027 8229845\n@@ -798,1 +798,1 @@\n-            byte xBytes[] = new byte[Math.abs(random.nextInt())%100+1];\n+            byte xBytes[] = new byte[Math.abs(random.nextInt())%200+1];\n@@ -839,0 +839,10 @@\n+        \/\/ Check value with many trailing zeros.\n+        String val = \"123456789\" + \"0\".repeat(200);\n+        BigInteger b = new BigInteger(val);\n+        String s = b.toString();\n+        if (!val.equals(s)) {\n+            System.err.format(\"Expected length %d but got %d%n\",\n+                val.length(), s.length());\n+            failCount++;\n+        }\n+\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.tests;\n+\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.Annotations.Test;\n+\n+\/**\n+ * Test --vendor parameter. Output of the test should be\n+ * vendortest*.* package bundle. The output package should provide the\n+ * same functionality as the default package with the default value of vendor\n+ * property overridden.\n+ *\n+ * Linux DEB:\n+ *\n+ * Value of \"Maintainer\" property of .deb package should start with \"Test Vendor\" string.\n+ *\n+ * Linux RPM:\n+ *\n+ * Value of \"Vendor\" property of .rpm package should be set to \"Test Vendor\" string.\n+ *\n+ * Mac:\n+ *\n+ * --vendor parameter is ignored.\n+ *\n+ * Windows:\n+ *\n+ * Publisher value displayed in the Add\/Remove Programs should be set\n+ * to \"Test Vendor\" string.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test --vendor jpackage command option\n+ * @library ..\/..\/..\/..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @requires (os.family == \"windows\")\n+ * @requires jpackage.test.SQETest != null\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile VendorTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=jdk.jpackage.tests.VendorTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test --vendor jpackage command option\n+ * @library ..\/..\/..\/..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @requires (os.family != \"mac\")\n+ * @requires jpackage.test.SQETest == null\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile VendorTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=jdk.jpackage.tests.VendorTest\n+ *\/\n+public class VendorTest {\n+\n+    @Test\n+    public static void test() {\n+        final String vendorValue = \"Test Vendor\";\n+\n+        new PackageTest()\n+        .configureHelloApp()\n+        .addBundleDesktopIntegrationVerifier(false)\n+        .addInitializer(cmd -> {\n+            cmd.addArguments(\"--vendor\", vendorValue);\n+        })\n+        .forTypes(PackageType.LINUX_DEB)\n+        .addBundlePropertyVerifier(\"Maintainer\", value -> {\n+            return value.startsWith(vendorValue + \" \");\n+        }, \"starts with\")\n+        .forTypes(PackageType.LINUX_RPM)\n+        .addBundlePropertyVerifier(\"Vendor\", value -> {\n+            return value.equals(vendorValue);\n+        }, \"equals to\")\n+        .forTypes(PackageType.WIN_MSI)\n+        .addBundlePropertyVerifier(\"Manufacturer\", value -> {\n+            return value.equals(vendorValue);\n+        }, \"equals to\")\n+        .run();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/jdk\/jpackage\/tests\/VendorTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.security;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateFactory;\n+import java.security.spec.PKCS8EncodedKeySpec;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+\/**\n+ * Tests various algorithm settings for PKCS12 keystores.\n+ *\/\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 2)\n+@Measurement(iterations = 10)\n+@BenchmarkMode(Mode.AverageTime)\n+@Fork(jvmArgsAppend = {\"-Xms1024m\", \"-Xmx1024m\", \"-Xmn768m\", \"-XX:+UseParallelGC\"}, value = 5)\n+public class PKCS12KeyStores {\n+\n+    private static final char[] PASS = \"changeit\".toCharArray();\n+\n+    private Key pk;\n+    private Certificate[] certs;\n+\n+    \/\/ Several pkcs12 keystores in byte arrays\n+    private byte[] bw2048;\n+    private byte[] bw50000;     \/\/ Default old\n+    private byte[] bs50000;\n+    private byte[] bs10000;     \/\/ Default new\n+    private byte[] bs2048;\n+\n+    \/\/ Decodes HEX string to byte array\n+    private static byte[] xeh(String in) {\n+        return new BigInteger(in, 16).toByteArray();\n+    }\n+\n+    @Setup\n+    public void setup() throws Exception {\n+        \/\/ Just generate a keypair and dump getEncoded() of key and cert.\n+        byte[] x1 = xeh(\"3041020100301306072A8648CE3D020106082A8648CE3D03\" +\n+                \"0107042730250201010420B561D1FBE150488508BBE8FF4540F09057\" +\n+                \"58712F5D2D3CC80F9A15BA5D481117\");\n+        byte[] x2 = xeh(\"3082012D3081D5A00302010202084EE6ECC5585640A7300A\" +\n+                \"06082A8648CE3D040302300C310A30080603550403130161301E170D\" +\n+                \"3230313131373230343730355A170D3233303831343230343730355A\" +\n+                \"300C310A300806035504031301613059301306072A8648CE3D020106\" +\n+                \"082A8648CE3D030107034200041E761F511841602E272B40A021995D\" +\n+                \"1BD828DDC7F71412D6A66CC0CB858C856D32C58273E494676D1D2B05\" +\n+                \"B8E9B08207A122265C2AA5FCBDCE19E5E88CA7A1B6A321301F301D06\" +\n+                \"03551D0E04160414173F278D77096E5C8EA182D12F147694587B5D9A\" +\n+                \"300A06082A8648CE3D04030203470030440220760CEAF1FA7041CB8C\" +\n+                \"1CA80AF60E4F9C9D5136D96B2AF0AAA9440F79561C44E502205D5C72\" +\n+                \"886C92B95A681C4393C67AAEC8DA9FD7910FF9BF2BCB721AE71D1B6F88\");\n+        KeyFactory kf = KeyFactory.getInstance(\"EC\");\n+        pk = kf.generatePrivate(new PKCS8EncodedKeySpec(x1));\n+        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+        certs = new Certificate[]{cf.generateCertificate(new ByteArrayInputStream(x2))};\n+\n+        bw2048 = outweak2048();\n+        bw50000 = outweak50000_Old();\n+        bs50000 = outstrong50000();\n+        bs10000 = outstrong10000_New();\n+        bs2048 = outstrong2048();\n+    }\n+\n+    \/\/ Reads in a pkcs12 keystore\n+    private KeyStore in(byte[] b) throws Exception {\n+        KeyStore ks = KeyStore.getInstance(\"pkcs12\");\n+        ks.load(new ByteArrayInputStream(b), PASS);\n+        if (!ks.getCertificate(\"a\").getPublicKey().getAlgorithm().equals(\n+                ks.getKey(\"a\", PASS).getAlgorithm())) {\n+            throw new RuntimeException(\"Not same alg\");\n+        }\n+        return ks;\n+    }\n+\n+    \/\/ Generates a pkcs12 keystore with the specified algorithm\/ic\n+    private byte[] out(String cAlg, String cIc, String kAlg, String kIc,\n+                      String mAlg, String mIc) throws Exception {\n+        System.setProperty(\"keystore.pkcs12.certProtectionAlgorithm\", cAlg);\n+        System.setProperty(\"keystore.pkcs12.certPbeIterationCount\", cIc);\n+        System.setProperty(\"keystore.pkcs12.keyProtectionAlgorithm\", kAlg);\n+        System.setProperty(\"keystore.pkcs12.keyPbeIterationCount\", kIc);\n+        System.setProperty(\"keystore.pkcs12.macAlgorithm\", mAlg);\n+        System.setProperty(\"keystore.pkcs12.macIterationCount\", mIc);\n+        KeyStore ks = KeyStore.getInstance(\"pkcs12\");\n+        ks.load(null, null);\n+        ks.setKeyEntry(\"a\", pk, PASS, certs);\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        ks.store(bout, PASS);\n+        return bout.toByteArray();\n+    }\n+\n+    \/\/ Benchmark methods start here:\n+\n+    \/\/ Reading a keystore\n+    @Benchmark\n+    public KeyStore inweak2048() throws Exception {\n+        return in(bw2048);\n+    }\n+\n+    @Benchmark\n+    public KeyStore inweak50000_Old() throws Exception {\n+        return in(bw50000);\n+    }\n+\n+    @Benchmark\n+    public KeyStore instrong50000() throws Exception {\n+        return in(bs50000);\n+    }\n+\n+    @Benchmark\n+    public KeyStore instrong10000_New() throws Exception {\n+        return in(bs10000);\n+    }\n+\n+    @Benchmark\n+    public KeyStore instrong2048() throws Exception {\n+        return in(bs2048);\n+    }\n+\n+    \/\/ Writing a keystore\n+    @Benchmark\n+    public byte[] outweak2048() throws Exception {\n+        return out(\"PBEWithSHA1AndRC2_40\", \"2048\",\n+                \"PBEWithSHA1AndDESede\", \"2048\",\n+                \"HmacPBESHA1\", \"2048\");\n+    }\n+\n+    @Benchmark\n+    public byte[] outweak50000_Old() throws Exception {\n+        return out(\"PBEWithSHA1AndRC2_40\", \"50000\",\n+                \"PBEWithSHA1AndDESede\", \"50000\",\n+                \"HmacPBESHA1\", \"100000\");\n+                \/\/ Attention: 100000 is old default Mac ic\n+    }\n+\n+    @Benchmark\n+    public byte[] outstrong50000() throws Exception {\n+        return out(\"PBEWithHmacSHA256AndAES_256\", \"50000\",\n+                \"PBEWithHmacSHA256AndAES_256\", \"50000\",\n+                \"HmacPBESHA256\", \"100000\");\n+                \/\/ Attention: 100000 is old default Mac ic\n+    }\n+\n+    @Benchmark\n+    public byte[] outstrong10000_New() throws Exception {\n+        return out(\"PBEWithHmacSHA256AndAES_256\", \"10000\",\n+                \"PBEWithHmacSHA256AndAES_256\", \"10000\",\n+                \"HmacPBESHA256\", \"10000\");\n+    }\n+\n+    @Benchmark\n+    public byte[] outstrong2048() throws Exception {\n+        return out(\"PBEWithHmacSHA256AndAES_256\", \"2048\",\n+                \"PBEWithHmacSHA256AndAES_256\", \"2048\",\n+                \"HmacPBESHA256\", \"2048\");\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/security\/PKCS12KeyStores.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"}]}