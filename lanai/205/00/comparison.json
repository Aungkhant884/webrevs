{"files":[{"patch":"@@ -364,0 +364,6 @@\n+    \/\/ Verify if we use a valid MTLContext\n+    MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps->privOps;\n+    RETURN_IF_TRUE(dstMTLOps->configInfo != NULL && mtlc != dstMTLOps->configInfo->context);\n+\n+    MTLSDOps *srcMTLOps = (MTLSDOps *)srcOps->privOps;\n+    RETURN_IF_TRUE(srcMTLOps->configInfo != NULL && mtlc != srcMTLOps->configInfo->context);\n@@ -487,0 +493,3 @@\n+    \/\/ Verify if we use a valid MTLContext\n+    MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps->privOps;\n+    RETURN_IF_TRUE(dstMTLOps->configInfo != NULL && mtlc != dstMTLOps->configInfo->context);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLBlitLoops.m","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"MTLStencilManager.h\"\n@@ -32,1 +33,0 @@\n-static id<MTLDepthStencilState> stencilState = nil;\n@@ -53,21 +53,0 @@\n-static id<MTLDepthStencilState> getStencilState(id<MTLDevice> device) {\n-    if (stencilState == nil) {\n-        MTLDepthStencilDescriptor* stencilDescriptor;\n-        stencilDescriptor = [[MTLDepthStencilDescriptor new] autorelease];\n-        stencilDescriptor.frontFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n-        stencilDescriptor.frontFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n-\n-        \/\/ TODO : backFaceStencil can be set to nil if all primitives are drawn as front-facing primitives\n-        \/\/ currently, fill parallelogram uses back-facing primitive drawing - that needs to be changed.\n-        \/\/ Once that part is changed, set backFaceStencil to nil\n-        \/\/stencilDescriptor.backFaceStencil = nil;\n-\n-        stencilDescriptor.backFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n-        stencilDescriptor.backFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n-\n-        stencilState = [device newDepthStencilStateWithDescriptor:stencilDescriptor];\n-    }\n-\n-    return stencilState;\n-}\n-\n@@ -131,0 +110,1 @@\n+    _mtlc = other->_mtlc;\n@@ -141,6 +121,0 @@\n-- (void)resetStencilState {\n-    if (stencilState != nil) {\n-        [stencilState release];\n-        stencilState = nil;\n-    }\n-}\n@@ -311,1 +285,1 @@\n-        [encoder setDepthStencilState:getStencilState(device)];\n+        [encoder setDepthStencilState:_mtlc.stencilManager.stencilState];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLClip.m","additions":3,"deletions":29,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+#include \"MTLSamplerManager.h\"\n+\n+@class MTLStencilManager;\n@@ -77,0 +80,2 @@\n+@property (readonly) MTLSamplerManager * samplerManager;\n+@property (readonly) MTLStencilManager * stencilManager;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.h","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+#import \"MTLSamplerManager.h\"\n+#import \"MTLStencilManager.h\"\n@@ -111,0 +113,2 @@\n+    MTLSamplerManager * _samplerManager;\n+    MTLStencilManager * _stencilManager;\n@@ -116,1 +120,2 @@\n-            texturePool, paint=_paint;\n+            texturePool, paint=_paint, encoderManager=_encoderManager,\n+            samplerManager=_samplerManager, stencilManager=_stencilManager;\n@@ -140,0 +145,2 @@\n+        _samplerManager = [[MTLSamplerManager alloc] initWithDevice:device];\n+        _stencilManager = [[MTLStencilManager alloc] initWithDevice:device];\n@@ -153,2 +160,0 @@\n-\n-        initSamplers(device);\n@@ -168,0 +173,2 @@\n+    [_samplerManager release];\n+    [_stencilManager release];\n@@ -180,1 +187,0 @@\n-    [_clip resetStencilState];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.m","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -57,4 +57,3 @@\n-static void setTxtUniforms(\n-        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,\n-        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags\n-);\n+static void\n+setTxtUniforms(MTLContext *mtlc, int color, id <MTLRenderCommandEncoder> encoder, int interpolation, bool repeat,\n+               jfloat extraAlpha, const SurfaceRasterFlags *srcFlags, const SurfaceRasterFlags *dstFlags, int mode);\n@@ -208,1 +207,1 @@\n-        setTxtUniforms(encoder, _color, 1,\n+        setTxtUniforms(mtlc, _color, encoder,\n@@ -210,1 +209,1 @@\n-                       &renderOptions->dstFlags);\n+                       &renderOptions->dstFlags, 1);\n@@ -251,1 +250,1 @@\n-        setTxtUniforms(encoder, col, 1,\n+        setTxtUniforms(mtlc, col, encoder,\n@@ -253,1 +252,1 @@\n-                       &renderOptions->srcFlags, &renderOptions->dstFlags);\n+                       &renderOptions->srcFlags, &renderOptions->dstFlags, 1);\n@@ -789,1 +788,1 @@\n-    setTxtUniforms(encoder, 0, 0,\n+    setTxtUniforms(mtlc, 0, encoder,\n@@ -791,1 +790,1 @@\n-                   &srcFlags, &renderOptions->dstFlags);\n+                   &srcFlags, &renderOptions->dstFlags, 0);\n@@ -870,62 +869,3 @@\n-static bool samplersInitialized = false;\n-static id<MTLSamplerState> samplerNearestClamp = nil;\n-static id<MTLSamplerState> samplerLinearClamp = nil;\n-static id<MTLSamplerState> samplerNearestRepeat = nil;\n-static id<MTLSamplerState> samplerLinearRepeat = nil;\n-\n-void initSamplers(id<MTLDevice> device) {\n-    \/\/ TODO: move this code into SamplerManager (need implement)\n-\n-    if (samplersInitialized) {\n-        \/\/ Release old samplers if any\n-        [samplerNearestClamp release];\n-        [samplerLinearClamp release];\n-        [samplerNearestRepeat release];\n-        [samplerLinearRepeat release];\n-\n-        samplersInitialized = false;\n-    }\n-\n-    MTLSamplerDescriptor *samplerDescriptor = [[MTLSamplerDescriptor new] autorelease];\n-\n-    samplerDescriptor.rAddressMode = MTLSamplerAddressModeClampToEdge;\n-    samplerDescriptor.sAddressMode = MTLSamplerAddressModeClampToEdge;\n-    samplerDescriptor.tAddressMode = MTLSamplerAddressModeClampToEdge;\n-\n-    samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n-    samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n-    samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n-\n-    samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n-    samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n-    samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n-\n-    samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;\n-    samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;\n-    samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;\n-\n-    samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n-    samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n-    samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n-\n-    samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n-    samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n-    samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n-\n-    samplersInitialized = true;\n-}\n-\n-static void setSampler(id<MTLRenderCommandEncoder> encoder, int interpolation, bool repeat) {\n-    id<MTLSamplerState> sampler;\n-    if (repeat) {\n-        sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearRepeat : samplerNearestRepeat;\n-    } else {\n-        sampler = interpolation == INTERPOLATION_BILINEAR ? samplerLinearClamp : samplerNearestClamp;\n-    }\n-    [encoder setFragmentSamplerState:sampler atIndex:0];\n-}\n-\n-static void setTxtUniforms(\n-        id<MTLRenderCommandEncoder> encoder, int color, int mode, int interpolation, bool repeat, jfloat extraAlpha,\n-        const SurfaceRasterFlags * srcFlags, const SurfaceRasterFlags * dstFlags\n-) {\n+static void\n+setTxtUniforms(MTLContext *mtlc, int color, id <MTLRenderCommandEncoder> encoder, int interpolation, bool repeat,\n+               jfloat extraAlpha, const SurfaceRasterFlags *srcFlags, const SurfaceRasterFlags *dstFlags, int mode) {\n@@ -934,2 +874,1 @@\n-\n-    setSampler(encoder, interpolation, repeat);\n+    [mtlc.samplerManager setSamplerWithEncoder:encoder interpolation:interpolation repeat:repeat];\n@@ -966,1 +905,1 @@\n-                setSampler(encoder, renderOptions->interpolation, NO);\n+                [mtlc.samplerManager setSamplerWithEncoder:encoder interpolation:renderOptions->interpolation repeat:NO];\n@@ -977,1 +916,1 @@\n-                setSampler(encoder, renderOptions->interpolation, NO);\n+                [mtlc.samplerManager setSamplerWithEncoder:encoder interpolation:renderOptions->interpolation repeat:NO];\n@@ -989,1 +928,1 @@\n-                setSampler(encoder, renderOptions->interpolation, NO);\n+                [mtlc.samplerManager setSamplerWithEncoder:encoder interpolation:renderOptions->interpolation repeat:NO];\n@@ -993,1 +932,1 @@\n-            setTxtUniforms(encoder, 0, 0,\n+            setTxtUniforms(mtlc, 0, encoder,\n@@ -996,1 +935,1 @@\n-                           &renderOptions->dstFlags);\n+                           &renderOptions->dstFlags, 0);\n@@ -1025,1 +964,1 @@\n-        setTxtUniforms(encoder, col, 0,\n+        setTxtUniforms(mtlc, col, encoder,\n@@ -1027,1 +966,1 @@\n-                       &renderOptions->srcFlags, &renderOptions->dstFlags);\n+                       &renderOptions->srcFlags, &renderOptions->dstFlags, 0);\n@@ -1033,1 +972,1 @@\n-        setTxtUniforms(encoder, 0, 0,\n+        setTxtUniforms(mtlc, 0, encoder,\n@@ -1036,1 +975,1 @@\n-                       &renderOptions->dstFlags);\n+                       &renderOptions->dstFlags, 0);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.m","additions":22,"deletions":83,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -91,0 +91,9 @@\n+#define ACT_IF_TRUE(ACTION, value)         \\\n+    if ((value)) {                         \\\n+        J2dTraceLn1(J2D_TRACE_ERROR,       \\\n+                    \"%s is false\", #value);\\\n+        ACTION;                            \\\n+    } else do { } while (0)\n+\n+#define RETURN_IF_TRUE(value)   ACT_IF_TRUE(return, value)\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderQueue.h","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLSamplerManager_h_Included\n+#define MTLSamplerManager_h_Included\n+\n+#import <Metal\/Metal.h>\n+\n+#include \"RenderOptions.h\"\n+\n+@class MTLContex;\n+\n+\n+@interface MTLSamplerManager : NSObject\n+- (id _Nonnull)initWithDevice:(_Nonnull id<MTLDevice>) device;\n+- (void)dealloc;\n+\n+- (void) setSamplerWithEncoder:(_Nonnull id<MTLRenderCommandEncoder>) encoder\n+                 interpolation:(int) interpolation\n+                        repeat:(bool) repeat;\n+@end\n+\n+#endif \/\/ MTLSamplerManager_h_Included\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSamplerManager.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MTLSamplerManager.h\"\n+#include \"MTLContext.h\"\n+#include \"sun_java2d_SunGraphics2D.h\"\n+#import \"common.h\"\n+\n+@implementation MTLSamplerManager {\n+    id<MTLSamplerState> _samplerNearestClamp;\n+    id<MTLSamplerState> _samplerLinearClamp;\n+    id<MTLSamplerState> _samplerNearestRepeat;\n+    id<MTLSamplerState> _samplerLinearRepeat;\n+}\n+\n+- (id _Nonnull)initWithDevice:(id<MTLDevice>) device {\n+    self = [super init];\n+    if (self) {\n+        MTLSamplerDescriptor *samplerDescriptor = [[MTLSamplerDescriptor new] autorelease];\n+\n+        samplerDescriptor.rAddressMode = MTLSamplerAddressModeClampToEdge;\n+        samplerDescriptor.sAddressMode = MTLSamplerAddressModeClampToEdge;\n+        samplerDescriptor.tAddressMode = MTLSamplerAddressModeClampToEdge;\n+\n+        samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n+        samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n+        _samplerNearestClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+\n+        samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n+        samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n+        _samplerLinearClamp = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+\n+        samplerDescriptor.rAddressMode = MTLSamplerAddressModeRepeat;\n+        samplerDescriptor.sAddressMode = MTLSamplerAddressModeRepeat;\n+        samplerDescriptor.tAddressMode = MTLSamplerAddressModeRepeat;\n+\n+        samplerDescriptor.minFilter = MTLSamplerMinMagFilterNearest;\n+        samplerDescriptor.magFilter = MTLSamplerMinMagFilterNearest;\n+        _samplerNearestRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+\n+        samplerDescriptor.minFilter = MTLSamplerMinMagFilterLinear;\n+        samplerDescriptor.magFilter = MTLSamplerMinMagFilterLinear;\n+        _samplerLinearRepeat = [device newSamplerStateWithDescriptor:samplerDescriptor];\n+    }\n+    return self;\n+}\n+\n+- (void) setSamplerWithEncoder:(id<MTLRenderCommandEncoder>) encoder\n+                 interpolation:(int) interpolation\n+                        repeat:(bool) repeat {\n+    id<MTLSamplerState> sampler;\n+    if (repeat) {\n+        sampler = interpolation == INTERPOLATION_BILINEAR ? _samplerLinearRepeat : _samplerNearestRepeat;\n+    } else {\n+        sampler = interpolation == INTERPOLATION_BILINEAR ? _samplerLinearClamp : _samplerNearestClamp;\n+    }\n+    [encoder setFragmentSamplerState:sampler atIndex:0];\n+}\n+\n+- (void)dealloc {\n+    [_samplerNearestClamp release];\n+    [_samplerLinearClamp release];\n+    [_samplerNearestRepeat release];\n+    [_samplerLinearRepeat release];\n+    [super dealloc];\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSamplerManager.m","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MTLStencilManager_h_Included\n+#define MTLStencilManager_h_Included\n+\n+#import <Metal\/Metal.h>\n+\n+#include \"RenderOptions.h\"\n+\n+@class MTLContex;\n+\n+\n+@interface MTLStencilManager : NSObject\n+- (id _Nonnull)initWithDevice:(_Nonnull id<MTLDevice>) device;\n+- (void)dealloc;\n+@property (readonly) _Nonnull id<MTLDepthStencilState> stencilState;\n+@end\n+\n+#endif \/\/ MTLSamplerManager_h_Included\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLStencilManager.h","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MTLStencilManager.h\"\n+\/\/#include \"MTLContext.h\"\n+\/\/#include \"sun_java2d_SunGraphics2D.h\"\n+\/\/#import \"common.h\"\n+\n+@implementation MTLStencilManager {\n+    id<MTLDepthStencilState> _stencilState;\n+}\n+\n+@synthesize stencilState = _stencilState;\n+\n+- (id _Nonnull)initWithDevice:(id<MTLDevice>) device {\n+    self = [super init];\n+    if (self) {\n+        MTLDepthStencilDescriptor* stencilDescriptor;\n+        stencilDescriptor = [[MTLDepthStencilDescriptor new] autorelease];\n+        stencilDescriptor.frontFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n+        stencilDescriptor.frontFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n+\n+        \/\/ TODO : backFaceStencil can be set to nil if all primitives are drawn as front-facing primitives\n+        \/\/ currently, fill parallelogram uses back-facing primitive drawing - that needs to be changed.\n+        \/\/ Once that part is changed, set backFaceStencil to nil\n+        \/\/stencilDescriptor.backFaceStencil = nil;\n+\n+        stencilDescriptor.backFaceStencil.stencilCompareFunction = MTLCompareFunctionEqual;\n+        stencilDescriptor.backFaceStencil.stencilFailureOperation = MTLStencilOperationKeep;\n+        _stencilState = [device newDepthStencilStateWithDescriptor:stencilDescriptor];\n+    }\n+    return self;\n+}\n+\n+- (void)dealloc {\n+    [_stencilState release];\n+    [super dealloc];\n+}\n+\n+@end\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLStencilManager.m","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}