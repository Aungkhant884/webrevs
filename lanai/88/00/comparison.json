{"files":[{"patch":"@@ -349,0 +349,21 @@\n+    static class RadGrad3OvalRotParticleRenderer extends FlatOvalRotParticleRenderer {\n+\n+\n+        RadGrad3OvalRotParticleRenderer(int n, float r) {\n+            super(n, r);\n+        }\n+\n+        @Override\n+        void setPaint(Graphics2D g2d, int id) {\n+            Point2D start = new Point2D.Double();\n+            float[] dist = {0.0f, 0.5f, 1.0f};\n+            Color[] cls = {\n+                colors[id %colors.length],\n+                colors[(colors.length - id) %colors.length],\n+                colors[(id*5) %colors.length]};\n+            RadialGradientPaint p =\n+                new RadialGradientPaint(start, r, dist, cls);\n+            g2d.setPaint(p);\n+        }\n+    }\n+\n@@ -642,0 +663,1 @@\n+    private static final ParticleRenderer radGrad3OvalRotRenderer = new RadGrad3OvalRotParticleRenderer(N, R);\n@@ -728,0 +750,8 @@\n+    public void testRadGrad3OvalRotBubbles() throws Exception {\n+        (new PerfMeter(\"RadGrad3RotatedOval\")).exec(createPR(radGrad3OvalRotRenderer)).report();\n+    }\n+\n+    public void testRadGrad3OvalRotBubblesAA() throws Exception {\n+        (new PerfMeter(\"RadGrad3RotatedOvalAA\")).exec(createPR(radGrad3OvalRotRenderer).configure(AA)).report();\n+    }\n+\n","filename":"src\/demo\/share\/java2d\/RenderPerfTest\/src\/renderperf\/RenderPerfTest.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -196,4 +196,0 @@\n-        @Override\n-        boolean isPaintValid(SunGraphics2D sg2d) {\n-            return false;\n-        }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLPaints.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+struct RadGradFrameUniforms {\n+    float fract[GRAD_MAX_FRACTIONS];\n+    vector_float4 color[GRAD_MAX_FRACTIONS];\n+    int numFracts;\n+    int cycleMethod;\n+    vector_float3 m0;\n+    vector_float3 m1;\n+    vector_float3 precalc;\n+};\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/common.h","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -260,0 +260,41 @@\n+fragment half4 frag_txt_rad_grad(GradShaderInOut in [[stage_in]],\n+                                 constant RadGradFrameUniforms& uniforms [[buffer(0)]],\n+                                 texture2d<float, access::sample> renderTexture [[texture(0)]])\n+{\n+    constexpr sampler textureSampler (address::repeat, mag_filter::nearest,\n+                                      min_filter::nearest);\n+\n+    float4 renderColor = renderTexture.sample(textureSampler, in.texCoords);\n+\n+    float3 fragCoord = float3(in.position.x+0.5, in.position.y-0.5, 1);\n+    float  x = dot(fragCoord, uniforms.m0);\n+    float  y = dot(fragCoord, uniforms.m1);\n+    float  xfx = x - uniforms.precalc.x;\n+    float  a = (uniforms.precalc.x*xfx + sqrt(xfx*xfx + y*y*uniforms.precalc.y))*uniforms.precalc.z;\n+\n+    float lf = 1.0\/(uniforms.numFracts - 1);\n+\n+    if (uniforms.cycleMethod > GradNoCycle) {\n+        int fa = floor(a);\n+        a = a - fa;\n+        if (uniforms.cycleMethod == GradReflect && fa%2) {\n+            a = 1.0 - a;\n+        }\n+    }\n+\n+    int n = floor(a\/lf);\n+    if (uniforms.cycleMethod > GradNoCycle) {\n+        n = ((n % uniforms.numFracts) + uniforms.numFracts) % uniforms.numFracts;\n+    } else {\n+        if (n < 0) n = 0;\n+        if (n > uniforms.numFracts - 2) n = uniforms.numFracts - 2;\n+    }\n+    a = (a - n*lf)\/lf;\n+    float4 c = mix(uniforms.color[n], uniforms.color[n + 1], a);\n+    return half4(c.r*renderColor.a,\n+                     c.g*renderColor.a,\n+                     c.b*renderColor.a,\n+                     renderColor.a);\n+}\n+\n+\n@@ -438,0 +479,31 @@\n+fragment half4 frag_rad_grad(GradShaderInOut in [[stage_in]],\n+                             constant RadGradFrameUniforms& uniforms [[buffer(0)]]) {\n+    float3 fragCoord = float3(in.position.x+0.5, in.position.y-0.5, 1);\n+    float  x = dot(fragCoord, uniforms.m0);\n+    float  y = dot(fragCoord, uniforms.m1);\n+    float  xfx = x - uniforms.precalc.x;\n+    float  a = (uniforms.precalc.x*xfx + sqrt(xfx*xfx + y*y*uniforms.precalc.y))*uniforms.precalc.z;\n+\n+    float lf = 1.0\/(uniforms.numFracts - 1);\n+\n+    if (uniforms.cycleMethod > GradNoCycle) {\n+        int fa = floor(a);\n+        a = a - fa;\n+        if (uniforms.cycleMethod == GradReflect && fa%2) {\n+            a = 1.0 - a;\n+        }\n+    }\n+\n+    int n = floor(a\/lf);\n+    if (uniforms.cycleMethod > GradNoCycle) {\n+        n = ((n % uniforms.numFracts) + uniforms.numFracts) % uniforms.numFracts;\n+    } else {\n+        if (n < 0) n = 0;\n+        if (n > uniforms.numFracts - 2) n = uniforms.numFracts - 2;\n+    }\n+    a = (a - n*lf)\/lf;\n+    float4 c = mix(uniforms.color[n], uniforms.color[n + 1], a);\n+    return half4(c);\n+}\n+\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/shaders.metal","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-              cycleMethod:(jboolean)cycleMethod\n+              cycleMethod:(jint)cycleMethod\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    \/\/ lin-grad-mode\n+    \/\/ grad-mode\n@@ -108,0 +108,1 @@\n+    jboolean      _useMask;\n@@ -110,2 +111,0 @@\n-    jint          _numFracts;\n-    jboolean      _useMask;\n@@ -113,0 +112,12 @@\n+    \/\/ lin-grad-mode\n+    jint          _numFracts;\n+    jboolean      _linear;\n+\n+    \/\/ rad-grad-mode\n+    jfloat        _m00;\n+    jfloat        _m01;\n+    jfloat        _m02;\n+    jfloat        _m10;\n+    jfloat        _m11;\n+    jfloat        _m12;\n+    jfloat        _focusX;\n@@ -155,0 +166,18 @@\n+    if (_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n+        if (_m00 != other->_m00\n+            || _m01 != other->_m01\n+            || _m02 != other->_m02\n+            || _m10 != other->_m10\n+            || _m11 != other->_m11\n+            || _m12 != other->_m12\n+            || _focusX != other->_focusX\n+            || _numFracts != other->_numFracts) return NO;\n+\n+\n+        for (int i = 0; i < _numFracts; i++) {\n+            if (_fract[i] != other->_fract[i]) return NO;\n+            if (_pixel[i] != other->_pixel[i]) return NO;\n+        }\n+        return YES;\n+    }\n+\n@@ -198,0 +227,16 @@\n+    if (other->_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n+\n+        _m00 = other->_m00;\n+        _m01 = other->_m01;\n+        _m02 = other->_m02;\n+        _m10 = other->_m10;\n+        _m11 = other->_m11;\n+        _m12 = other->_m12;\n+        _focusX = other->_focusX;\n+        _cyclic = other->_cyclic;\n+        memcpy(_fract, other->_fract, other->_numFracts*sizeof(jfloat));\n+        memcpy(_pixel, other->_pixel, other->_numFracts*sizeof(jint));\n+        _numFracts = other->_numFracts;\n+        return;\n+    }\n+\n@@ -226,0 +271,4 @@\n+    if (_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n+        return [NSString stringWithFormat:@\"radial_gradient\"];\n+    }\n+\n@@ -257,8 +306,0 @@\n-    \/\/TODO Resolve gradient distribution problem\n-    \/\/TODO Implement useMask\n-    \/\/TODO Implement cyclic\n-    \/\/fprintf(stderr,\n-    \/\/        \"MTLPaints_SetGradientPaint useMask=%d cyclic=%d \"\n-    \/\/        \"p0=%f p1=%f p3=%f pix1=%d pix2=%d\\n\", useMask, cyclic,\n-    \/\/        p0, p1, p3, pixel1, pixel2);\n-\n@@ -285,1 +326,0 @@\n-    J2dTraceLn(J2D_TRACE_ERROR, \"setLinearGradient: UNIMPLEMENTED\");\n@@ -288,0 +328,1 @@\n+    _linear = linear; \/\/ TODO: to be implemented\n@@ -295,1 +336,0 @@\n-\n@@ -300,1 +340,1 @@\n-              cycleMethod:(jboolean)cycleMethod\n+              cycleMethod:(jint)cycleMethod\n@@ -312,2 +352,13 @@\n-    J2dTraceLn(J2D_TRACE_ERROR, \"setRadialGradient: UNIMPLEMENTED\");\n-    [self setColor:0];\n+    _paintState = sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT;\n+    _useMask = useMask;\n+    _cyclic = cycleMethod;\n+    _numFracts = numStops;\n+    memcpy(_fract, fractions, numStops * sizeof(jfloat));\n+    memcpy(_pixel, pixels, numStops * sizeof(jint));\n+    _m00 = m00;\n+    _m01 = m01;\n+    _m02 = m02;\n+    _m10 = m10;\n+    _m11 = m11;\n+    _m12 = m12;\n+    _focusX = focusX;\n@@ -489,0 +540,13 @@\n+        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n+            vertShader = @\"vert_txt_grad\";\n+            fragShader = @\"frag_txt_rad_grad\";\n+\n+            struct RadGradFrameUniforms uf = {\n+                    {},\n+                    {},\n+                    _numFracts,\n+                    _cyclic,\n+                    {_m00, _m01, _m02},\n+                    {_m10, _m11, _m12},\n+                    {}\n+            };\n@@ -490,0 +554,10 @@\n+            uf.precalc[0] = _focusX;\n+            uf.precalc[1] = 1.0 - (_focusX * _focusX);\n+            uf.precalc[2] = 1.0 \/ uf.precalc[1];\n+\n+            memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n+            for (int i = 0; i < _numFracts; i++) {\n+                vector_float4 v = RGBA_TO_V4(_pixel[i]);\n+                uf.color[i] = v;\n+            }\n+            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n@@ -536,0 +610,25 @@\n+                vector_float4 v = RGBA_TO_V4(_pixel[i]);\n+                uf.color[i] = v;\n+            }\n+            [encoder setFragmentBytes:&uf length:sizeof(uf) atIndex:0];\n+\n+        } else if (_paintState == sun_java2d_SunGraphics2D_PAINT_RAD_GRADIENT) {\n+            vertShader = @\"vert_grad\";\n+            fragShader = @\"frag_rad_grad\";\n+\n+            struct RadGradFrameUniforms uf = {\n+                    {},\n+                    {},\n+                    _numFracts,\n+                    _cyclic,\n+                    {_m00, _m01, _m02},\n+                    {_m10, _m11, _m12},\n+                    {}\n+            };\n+\n+            uf.precalc[0] = _focusX;\n+            uf.precalc[1] = 1.0 - (_focusX * _focusX);\n+            uf.precalc[2] = 1.0 \/ uf.precalc[1];\n+\n+            memcpy(uf.fract, _fract, _numFracts*sizeof(jfloat));\n+            for (int i = 0; i < _numFracts; i++) {\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.m","additions":115,"deletions":16,"binary":false,"changes":131,"status":"modified"}]}