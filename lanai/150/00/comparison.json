{"files":[{"patch":"@@ -47,1 +47,1 @@\n-     * For Mac OS X, this method returns either an CGL-specific\n+     * For Mac OS X, this method returns either an CGL\/MTL-specific\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/MacosxSurfaceManagerFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-            MTLSurfaceData oglDst = (MTLSurfaceData)dstData;\n+            MTLSurfaceData mtlDst = (MTLSurfaceData)dstData;\n@@ -280,1 +280,1 @@\n-                MTLGraphicsConfig gc = oglDst.getMTLGraphicsConfig();\n+                MTLGraphicsConfig gc = mtlDst.getMTLGraphicsConfig();\n@@ -283,1 +283,1 @@\n-                MTLContext.validateContext(oglDst, oglDst,\n+                MTLContext.validateContext(mtlDst, mtlDst,\n@@ -328,3 +328,3 @@\n-            MTLSurfaceData oglSrc = (MTLSurfaceData)srcData;\n-            MTLSurfaceData oglDst = (MTLSurfaceData)dstData;\n-            int srctype = oglSrc.getType();\n+            MTLSurfaceData mtlSrc = (MTLSurfaceData)srcData;\n+            MTLSurfaceData mtlDst = (MTLSurfaceData)dstData;\n+            int srctype = mtlSrc.getType();\n@@ -338,1 +338,1 @@\n-                srcCtxData = oglDst;\n+                srcCtxData = mtlDst;\n@@ -345,1 +345,1 @@\n-                    srcCtxData = oglDst;\n+                    srcCtxData = mtlDst;\n@@ -347,1 +347,1 @@\n-                    srcCtxData = oglSrc;\n+                    srcCtxData = mtlSrc;\n@@ -351,1 +351,1 @@\n-            MTLContext.validateContext(srcCtxData, oglDst,\n+            MTLContext.validateContext(srcCtxData, mtlDst,\n@@ -356,1 +356,1 @@\n-                MTLBufImgOps.enableBufImgOp(rq, oglSrc, srcImg, biop);\n+                MTLBufImgOps.enableBufImgOp(rq, mtlSrc, srcImg, biop);\n@@ -371,1 +371,1 @@\n-            if (rtt && oglDst.isOnScreen()) {\n+            if (rtt && mtlDst.isOnScreen()) {\n@@ -796,1 +796,1 @@\n- * (premultiplied) surface down to OpenGL using simple blit.\n+ * (premultiplied) surface down to Metal using simple blit.\n@@ -830,1 +830,1 @@\n-        \/\/ copy IntArgbPre intermediate surface to OpenGL surface\n+        \/\/ copy IntArgbPre intermediate surface to Metal surface\n@@ -845,1 +845,1 @@\n- * (premultiplied) surface down to OpenGL using simple transformBlit.\n+ * (premultiplied) surface down to Metal using simple transformBlit.\n@@ -873,1 +873,1 @@\n-        \/\/ transform IntArgbPre intermediate surface to OpenGL surface\n+        \/\/ transform IntArgbPre intermediate surface to Metal surface\n@@ -888,1 +888,1 @@\n- * intermediate surface down to OpenGL.\n+ * intermediate surface down to Metal.\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLBlitLoops.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    private static final int kOpenGLSwapInterval = 0; \/\/ TODO\n+    private static final int kMetalSwapInterval = 0; \/\/ TODO\n@@ -85,4 +85,2 @@\n-     * Returns GL_MAX_TEXTURE_SIZE from the shared opengl context. Must be\n-     * called under OGLRQ lock, because this method change current context.\n-     *\n-     * @return GL_MAX_TEXTURE_SIZE\n+     * Returns maximum texture size supported by Metal. Must be\n+     * called under MTLRQ lock.\n@@ -137,1 +135,1 @@\n-            \/\/ getCGLConfigInfo() creates and destroys temporary\n+            \/\/ getMTLConfigInfo() creates and destroys temporary\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLGraphicsConfig.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        \/\/ and blits the buffer to the layer surface (in drawInCGLContext callback)\n+        \/\/ and blits the buffer to the layer surface (in display callback)\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLLayer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-        MTLSurfaceData oglDst = (MTLSurfaceData)dstData;\n-        MTLContext.validateContext(oglDst, oglDst,\n+        MTLSurfaceData mtlDst = (MTLSurfaceData)dstData;\n+        MTLContext.validateContext(mtlDst, mtlDst,\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLMaskBlit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,3 +100,2 @@\n-         *   - the texture image dimensions are power-of-two (or the\n-         *     GL_ARB_texture_non_power_of_two extension is present)\n-         *   - the texture image can be (or is already) cached in an OpenGL\n+         *   - the texture image dimensions are power-of-two\n+         *   - the texture image can be (or is already) cached in an Metal\n@@ -118,1 +117,1 @@\n-                \/\/         OpenGL texture...\n+                \/\/         Metal texture...\n@@ -129,2 +128,2 @@\n-            MTLSurfaceData oglData = (MTLSurfaceData)srcData;\n-            if (oglData.getType() != MTLSurfaceData.TEXTURE) {\n+            MTLSurfaceData mtlData = (MTLSurfaceData)srcData;\n+            if (mtlData.getType() != MTLSurfaceData.TEXTURE) {\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLPaints.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * OGL-specific implementation of RenderQueue.  This class provides a\n+ * MTL-specific implementation of RenderQueue.  This class provides a\n@@ -73,1 +73,1 @@\n-     * to flush the OGL pipeline, but only if the OGL pipeline is currently\n+     * to flush the MTL pipeline, but only if the MTL pipeline is currently\n@@ -76,1 +76,1 @@\n-     * of the OGL pipeline and related classes.\n+     * of the MTL pipeline and related classes.\n@@ -116,1 +116,1 @@\n-     * Returns true if the current thread is the OGL QueueFlusher thread.\n+     * Returns true if the current thread is the MTL QueueFlusher thread.\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLRenderQueue.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -160,1 +160,1 @@\n-     * Returns the appropriate SurfaceType corresponding to the given OpenGL\n+     * Returns the appropriate SurfaceType corresponding to the given Metal\n@@ -163,2 +163,2 @@\n-    private static SurfaceType getCustomSurfaceType(int oglType) {\n-        switch (oglType) {\n+    private static SurfaceType getCustomSurfaceType(int mtlType) {\n+        switch (mtlType) {\n@@ -299,1 +299,1 @@\n-     * Initializes the appropriate OpenGL offscreen surface based on the value\n+     * Initializes the appropriate Metal offscreen surface based on the value\n@@ -356,1 +356,1 @@\n-     * Eventually, we could enhance the native OGL text rendering code\n+     * Eventually, we could enhance the native MTL text rendering code\n@@ -479,1 +479,1 @@\n-        \/\/ always override the image pipe with the specialized OGL pipe\n+        \/\/ always override the image pipe with the specialized MTL pipe\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLSurfaceData.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * SurfaceData with a cached OGL Texture and the code to create\n+ * SurfaceData with a cached MTL Texture and the code to create\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLSurfaceDataProxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-        MTLSurfaceData oglDst = (MTLSurfaceData)sg2d.surfaceData;\n-        MTLContext.validateContext(oglDst, oglDst,\n+        MTLSurfaceData mtlDst = (MTLSurfaceData)sg2d.surfaceData;\n+        MTLContext.validateContext(mtlDst, mtlDst,\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLTextRenderer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-     * These OGL-specific surface type constants are the same as those\n+     * These MTL-specific surface type constants are the same as those\n@@ -57,1 +57,1 @@\n-     * Returns true if the current thread is the OGL QueueFlusher thread.\n+     * Returns true if the current thread is the MTL QueueFlusher thread.\n@@ -120,1 +120,1 @@\n-     * method so that the given Runnable can query the OpenGL capabilities\n+     * method so that the given Runnable can query the Metal capabilities\n@@ -202,1 +202,1 @@\n-        \/\/ (in OpenGL coordinates)\n+        \/\/ (in Metal coordinates)\n@@ -252,1 +252,1 @@\n-        \/\/ lower-left origin of the surface (in OpenGL coordinates)\n+        \/\/ lower-left origin of the surface (in Metal coordinates)\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/java2d\/metal\/MTLUtilities.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-        \/\/ flush the OGL pipeline (this is a no-op if OGL is not enabled)\n+        \/\/ flush the OGL\/MTL pipeline (this is a no-op if OGL\/MTL is not enabled)\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,10 +129,1 @@\n- * Initializes the OpenGL state responsible for applying extra alpha.  This\n- * step is only necessary for any operation that uses glDrawPixels() or\n- * glCopyPixels() with a non-1.0f extra alpha value.  Since the source is\n- * always premultiplied, we apply the extra alpha value to both alpha and\n- * color components using GL_*_SCALE.\n- *\/\n-- (void)setExtraAlpha:(jfloat)ea;\n-\n-\/**\n- * Resets all OpenGL compositing state (disables blending and logic\n+ * Resets all Metal compositing state (disables blending and logic\n@@ -144,1 +135,1 @@\n- * Initializes the OpenGL blending state.  XOR mode is disabled and the\n+ * Initializes the Metal blending state.  XOR mode is disabled and the\n@@ -162,1 +153,1 @@\n- * Initializes the OpenGL logic op state to XOR mode.  Blending is disabled\n+ * Initializes the Metal logic op state to XOR mode.  Blending is disabled\n@@ -170,1 +161,1 @@\n- * Resets the OpenGL transform state back to the identity matrix.\n+ * Resets the Metal transform state back to the identity matrix.\n@@ -175,1 +166,1 @@\n- * Initializes the OpenGL transform state by setting the modelview transform\n+ * Initializes the Metal transform state by setting the modelview transform\n@@ -186,23 +177,0 @@\n-\/**\n- * Initializes a small texture tile for use with tiled blit operations (see\n- * MTLBlitLoops.c and MTLMaskBlit.c for usage examples).  The texture ID for\n- * the tile is stored in the given MTLContext.  The tile is initially filled\n- * with garbage values, but the tile is updated as needed (via\n- * glTexSubImage2D()) with real RGBA values used in tiled blit situations.\n- * The internal format for the texture is GL_RGBA8, which should be sufficient\n- * for storing system memory surfaces of any known format (see PixelFormats\n- * for a list of compatible surface formats).\n- *\/\n-- (jboolean)initBlitTileTexture;\n-\n-\n-\/**\n- * Creates a 2D texture of the given format and dimensions and returns the\n- * texture object identifier.  This method is typically used to create a\n- * temporary texture for intermediate work, such as in the\n- * MTLContext_InitBlitTileTexture() method below.\n- *\/\n-- (jint)createBlitTextureFormat:(jint)internalFormat pixelFormat:(jint)pixelFormat\n-                          width:(jint)width height:(jint)height;\n-\n-- (void)destroyContextResources;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.h","additions":5,"deletions":37,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -224,2 +224,2 @@\n-    MTLSDOps *dstCGLOps = (MTLSDOps *)dstOps->privOps;\n-    mtlc = dstCGLOps->configInfo->context;\n+    MTLSDOps *dstMTLOps = (MTLSDOps *)dstOps->privOps;\n+    mtlc = dstMTLOps->configInfo->context;\n@@ -317,15 +317,0 @@\n-- (jboolean)initBlitTileTexture {\n-    \/\/TODO\n-    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext_InitBlitTileTexture -- :TODO\");\n-\n-    return JNI_TRUE;\n-}\n-\n-- (jint)createBlitTextureFormat:(jint)internalFormat pixelFormat:(jint)pixelFormat\n-                          width:(jint)width height:(jint)height {\n-    J2dTraceLn(J2D_TRACE_INFO, \"MTLContext_InitBlitTileTexture -- :TODO\");\n-\n-    \/\/TODO\n-    return 0;\n-}\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLContext.m","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,21 +40,0 @@\n-\/\/ REMIND: Using an NSOpenGLPixelBuffer as the scratch surface has been\n-\/\/ problematic thus far (seeing garbage and flickering when switching\n-\/\/ between an NSView and the scratch surface), so the following enables\n-\/\/ an alternate codepath that uses a hidden NSWindow\/NSView as the scratch\n-\/\/ surface, for the purposes of making a context current in certain\n-\/\/ situations.  It appears that calling [NSOpenGLContext setView] too\n-\/\/ frequently contributes to the bad behavior, so we should try to avoid\n-\/\/ switching to the scratch surface whenever possible.\n-\n-\/* Do we need this if we are using all off-screen drawing ? *\/\n-#define USE_NSVIEW_FOR_SCRATCH 1\n-\n-\/* Uncomment to have an additional CAOGLLayer instance tied to\n- * each instance, which can be used to test remoting the layer\n- * to an out of process window. The additional layer is needed\n- * because a layer can only be attached to one context (view\/window).\n- * This is only for testing purposes and can be removed if\/when no\n- * longer needed.\n- *\/\n-\n-\n@@ -63,1 +42,1 @@\n- * given CGLGraphicsConfig (pixel format).\n+ * given MTLGraphicsConfig (pixel format).\n@@ -66,4 +45,1 @@\n- * The screen and PixelFormat for the associated CGLGraphicsConfig.\n- *\n- *     NSOpenGLPixelFormat *pixfmt;\n- * The pixel format of the native NSOpenGL context.\n+ * The screen for the associated MTLGraphicsConfig.\n@@ -72,1 +48,1 @@\n- * The context associated with this CGLGraphicsConfig.\n+ * The context associated with this MTLGraphicsConfig.\n@@ -76,1 +52,0 @@\n-    NSOpenGLPixelFormat *pixfmt;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGraphicsConfig.h","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n- * CGLGraphicsConfigInfo (including its native MTLContext data).\n+ * MTLGraphicsConfigInfo (including its native MTLContext data).\n@@ -74,1 +74,1 @@\n- * Attempts to initialize CGL and the core OpenGL library.\n+ * Attempts to initialize MTL and the core Metal library.\n@@ -124,1 +124,1 @@\n- * Determines whether the CGL pipeline can be used for a given GraphicsConfig\n+ * Determines whether the MTL pipeline can be used for a given GraphicsConfig\n@@ -126,1 +126,1 @@\n- * met, the native CGLGraphicsConfigInfo structure is initialized for this\n+ * met, the native MTLGraphicsConfigInfo structure is initialized for this\n@@ -129,1 +129,1 @@\n- * initialization fails at any point, zero is returned, indicating that CGL\n+ * initialization fails at any point, zero is returned, indicating that MTL\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLGraphicsConfig.m","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-#endif \/* CGLLayer_h_Included *\/\n+#endif \/* MTLLayer_h_Included *\/\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLLayer.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,3 +35,1 @@\n- * This implementation first copies the alpha tile into a texture and then\n- * maps that texture to the destination surface.  This approach appears to\n- * offer the best performance despite being a two-step process.\n+ * In case of Metal we use shader for texture mapping.\n@@ -39,39 +37,1 @@\n- * When the source paint is a Color, we can simply use the GL_MODULATE\n- * function to multiply the current color (already premultiplied with the\n- * extra alpha value from the AlphaComposite) with the alpha value from\n- * the mask texture tile.  In picture form, this process looks like:\n- *\n- *                        A     R    G     B\n- *     primary color      Pa    Pr   Pg    Pb    (modulated with...)\n- *     texture unit 0     Ca    Ca   Ca    Ca\n- *     ---------------------------------------\n- *     resulting color    Ra    Rr   Rg    Rb\n- *\n- * where:\n- *     Px = current color (already premultiplied by extra alpha)\n- *     Cx = coverage value from mask tile\n- *     Rx = resulting color\/alpha component\n- *\n- * When the source paint is not a Color, it means that we are rendering with\n- * a complex paint (e.g. GradientPaint, TexturePaint).  In this case, we\n- * rely on the GL_ARB_multitexture extension to effectively multiply the\n- * paint fragments (autogenerated on texture unit 1, see the\n- * MTLPaints_Set{Gradient,Texture,etc}Paint() methods for more details)\n- * with the coverage values from the mask texture tile (provided on texture\n- * unit 0), all of which is multiplied with the current color value (which\n- * contains the extra alpha value).  In picture form:\n- *\n- *                        A     R    G     B\n- *     primary color      Ea    Ea   Ea    Ea    (modulated with...)\n- *     texture unit 0     Ca    Ca   Ca    Ca    (modulated with...)\n- *     texture unit 1     Pa    Pr   Pg    Pb\n- *     ---------------------------------------\n- *     resulting color    Ra    Rr   Rg    Rb\n- *\n- * where:\n- *     Ea = extra alpha\n- *     Cx = coverage value from mask tile\n- *     Px = gradient\/texture paint color (generated for each fragment)\n- *     Rx = resulting color\/alpha component\n- *\n- * Here are some descriptions of the many variables used in this method:\n+ * Descriptions of the many variables used in this method:\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLMaskFill.m","additions":2,"deletions":42,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -994,367 +994,0 @@\n-\n-\n-\/************************* GradientPaint support ****************************\/\n-\n-static void\n-MTLPaints_InitGradientTexture()\n-{\n-    \/\/TODO\n-    J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints_InitGradientTexture -- :TODO\");\n-}\n-\n-\/****************** Shared MultipleGradientPaint support ********************\/\n-\n-\/**\n- * These constants are identical to those defined in the\n- * MultipleGradientPaint.CycleMethod enum; they are copied here for\n- * convenience (ideally we would pull them directly from the Java level,\n- * but that entails more hassle than it is worth).\n- *\/\n-#define CYCLE_NONE    0\n-#define CYCLE_REFLECT 1\n-#define CYCLE_REPEAT  2\n-\n-\/**\n- * The following constants are flags that can be bitwise-or'ed together\n- * to control how the MultipleGradientPaint shader source code is generated:\n- *\n- *   MULTI_CYCLE_METHOD\n- *     Placeholder for the CycleMethod enum constant.\n- *\n- *   MULTI_LARGE\n- *     If set, use the (slower) shader that supports a larger number of\n- *     gradient colors; otherwise, use the optimized codepath.  See\n- *     the MAX_FRACTIONS_SMALL\/LARGE constants below for more details.\n- *\n- *   MULTI_USE_MASK\n- *     If set, apply the alpha mask value from texture unit 0 to the\n- *     final color result (only used in the MaskFill case).\n- *\n- *   MULTI_LINEAR_RGB\n- *     If set, convert the linear RGB result back into the sRGB color space.\n- *\/\n-#define MULTI_CYCLE_METHOD (3 << 0)\n-#define MULTI_LARGE        (1 << 2)\n-#define MULTI_USE_MASK     (1 << 3)\n-#define MULTI_LINEAR_RGB   (1 << 4)\n-\n-\/**\n- * This value determines the size of the array of programs for each\n- * MultipleGradientPaint type.  This value reflects the maximum value that\n- * can be represented by performing a bitwise-or of all the MULTI_*\n- * constants defined above.\n- *\/\n-#define MAX_PROGRAMS 32\n-\n-\/** Evaluates to true if the given bit is set on the local flags variable. *\/\n-#define IS_SET(flagbit) \\\n-    (((flags) & (flagbit)) != 0)\n-\n-\/** Composes the given parameters as flags into the given flags variable.*\/\n-#define COMPOSE_FLAGS(flags, cycleMethod, large, useMask, linear) \\\n-    do {                                                   \\\n-        flags |= ((cycleMethod) & MULTI_CYCLE_METHOD);     \\\n-        if (large)   flags |= MULTI_LARGE;                 \\\n-        if (useMask) flags |= MULTI_USE_MASK;              \\\n-        if (linear)  flags |= MULTI_LINEAR_RGB;            \\\n-    } while (0)\n-\n-\/** Extracts the CycleMethod enum value from the given flags variable. *\/\n-#define EXTRACT_CYCLE_METHOD(flags) \\\n-    ((flags) & MULTI_CYCLE_METHOD)\n-\n-\/**\n- * The maximum number of gradient \"stops\" supported by the fragment shader\n- * and related code.  When the MULTI_LARGE flag is set, we will use\n- * MAX_FRACTIONS_LARGE; otherwise, we use MAX_FRACTIONS_SMALL.  By having\n- * two separate values, we can have one highly optimized shader (SMALL) that\n- * supports only a few fractions\/colors, and then another, less optimal\n- * shader that supports more stops.\n- *\/\n-#define MAX_FRACTIONS sun_java2d_pipe_BufferedPaints_MULTI_MAX_FRACTIONS\n-#define MAX_FRACTIONS_LARGE MAX_FRACTIONS\n-#define MAX_FRACTIONS_SMALL 4\n-\n-\/**\n- * The maximum number of gradient colors supported by all of the gradient\n- * fragment shaders.  Note that this value must be a power of two, as it\n- * determines the size of the 1D texture created below.  It also must be\n- * greater than or equal to MAX_FRACTIONS (there is no strict requirement\n- * that the two values be equal).\n- *\/\n-#define MAX_COLORS 16\n-\n-\/**\n- * The handle to the gradient color table texture object used by the shaders.\n- *\/\n-static jint multiGradientTexID = 0;\n-\n-\/**\n- * This is essentially a template of the shader source code that can be used\n- * for either LinearGradientPaint or RadialGradientPaint.  It includes the\n- * structure and some variables that are common to each; the remaining\n- * code snippets (for CycleMethod, ColorSpaceType, and mask modulation)\n- * are filled in prior to compiling the shader at runtime depending on the\n- * paint parameters.  See MTLPaints_CreateMultiGradProgram() for more details.\n- *\/\n-static const char *multiGradientShaderSource =\n-    \/\/ gradient texture size (in texels)\n-    \"const int TEXTURE_SIZE = %d;\"\n-    \/\/ maximum number of fractions\/colors supported by this shader\n-    \"const int MAX_FRACTIONS = %d;\"\n-    \/\/ size of a single texel\n-    \"const float FULL_TEXEL = (1.0 \/ float(TEXTURE_SIZE));\"\n-    \/\/ size of half of a single texel\n-    \"const float HALF_TEXEL = (FULL_TEXEL \/ 2.0);\"\n-    \/\/ texture containing the gradient colors\n-    \"uniform sampler1D colors;\"\n-    \/\/ array of gradient stops\/fractions\n-    \"uniform float fractions[MAX_FRACTIONS];\"\n-    \/\/ array of scale factors (one for each interval)\n-    \"uniform float scaleFactors[MAX_FRACTIONS-1];\"\n-    \/\/ (placeholder for mask variable)\n-    \"%s\"\n-    \/\/ (placeholder for Linear\/RadialGP-specific variables)\n-    \"%s\"\n-    \"\"\n-    \"void main(void)\"\n-    \"{\"\n-    \"    float dist;\"\n-         \/\/ (placeholder for Linear\/RadialGradientPaint-specific code)\n-    \"    %s\"\n-    \"\"\n-    \"    float tc;\"\n-         \/\/ (placeholder for CycleMethod-specific code)\n-    \"    %s\"\n-    \"\"\n-         \/\/ calculate interpolated color\n-    \"    vec4 result = texture1D(colors, tc);\"\n-    \"\"\n-         \/\/ (placeholder for ColorSpace conversion code)\n-    \"    %s\"\n-    \"\"\n-         \/\/ (placeholder for mask modulation code)\n-    \"    %s\"\n-    \"\"\n-         \/\/ modulate with gl_Color in order to apply extra alpha\n-    \"    gl_FragColor = result * gl_Color;\"\n-    \"}\";\n-\n-\/**\n- * This code takes a \"dist\" value as input (as calculated earlier by the\n- * LGP\/RGP-specific code) in the range [0,1] and produces a texture\n- * coordinate value \"tc\" that represents the position of the chosen color\n- * in the one-dimensional gradient texture (also in the range [0,1]).\n- *\n- * One naive way to implement this would be to iterate through the fractions\n- * to figure out in which interval \"dist\" falls, and then compute the\n- * relative distance between the two nearest stops.  This approach would\n- * require an \"if\" check on every iteration, and it is best to avoid\n- * conditionals in fragment shaders for performance reasons.  Also, one might\n- * be tempted to use a break statement to jump out of the loop once the\n- * interval was found, but break statements (and non-constant loop bounds)\n- * are not natively available on most graphics hardware today, so that is\n- * a non-starter.\n- *\n- * The more optimal approach used here avoids these issues entirely by using\n- * an accumulation function that is equivalent to the process described above.\n- * The scaleFactors array is pre-initialized at enable time as follows:\n- *     scaleFactors[i] = 1.0 \/ (fractions[i+1] - fractions[i]);\n- *\n- * For each iteration, we subtract fractions[i] from dist and then multiply\n- * that value by scaleFactors[i].  If we are within the target interval,\n- * this value will be a fraction in the range [0,1] indicating the relative\n- * distance between fraction[i] and fraction[i+1].  If we are below the\n- * target interval, this value will be negative, so we clamp it to zero\n- * to avoid accumulating any value.  If we are above the target interval,\n- * the value will be greater than one, so we clamp it to one.  Upon exiting\n- * the loop, we will have accumulated zero or more 1.0's and a single\n- * fractional value.  This accumulated value tells us the position of the\n- * fragment color in the one-dimensional gradient texture, i.e., the\n- * texcoord called \"tc\".\n- *\/\n-static const char *texCoordCalcCode =\n-    \"int i;\"\n-    \"float relFraction = 0.0;\"\n-    \"for (i = 0; i < MAX_FRACTIONS-1; i++) {\"\n-    \"    relFraction +=\"\n-    \"        clamp((dist - fractions[i]) * scaleFactors[i], 0.0, 1.0);\"\n-    \"}\"\n-    \/\/ we offset by half a texel so that we find the linearly interpolated\n-    \/\/ color between the two texel centers of interest\n-    \"tc = HALF_TEXEL + (FULL_TEXEL * relFraction);\";\n-\n-\/** Code for NO_CYCLE that gets plugged into the CycleMethod placeholder. *\/\n-static const char *noCycleCode =\n-    \"if (dist <= 0.0) {\"\n-    \"    tc = 0.0;\"\n-    \"} else if (dist >= 1.0) {\"\n-    \"    tc = 1.0;\"\n-    \"} else {\"\n-         \/\/ (placeholder for texcoord calculation)\n-    \"    %s\"\n-    \"}\";\n-\n-\/** Code for REFLECT that gets plugged into the CycleMethod placeholder. *\/\n-static const char *reflectCode =\n-    \"dist = 1.0 - (abs(fract(dist * 0.5) - 0.5) * 2.0);\"\n-    \/\/ (placeholder for texcoord calculation)\n-    \"%s\";\n-\n-\/** Code for REPEAT that gets plugged into the CycleMethod placeholder. *\/\n-static const char *repeatCode =\n-    \"dist = fract(dist);\"\n-    \/\/ (placeholder for texcoord calculation)\n-    \"%s\";\n-\n-static void\n-MTLPaints_InitMultiGradientTexture()\n-{\n-    J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints_InitMultiGradientTexture -- :TODO\");\n-}\n-\n-\/**\n- * Compiles and links the MultipleGradientPaint shader program.  If\n- * successful, this function returns a handle to the newly created\n- * shader program; otherwise returns 0.\n- *\/\n-static void*\n-MTLPaints_CreateMultiGradProgram(jint flags,\n-                                 char *paintVars, char *distCode)\n-{\n-\n-    \/\/TODO\n-    J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints_CreateMultiGradProgram -- :TODO\");\n-\n-    return NULL;\n-}\n-\n-\/**\n- * Called from the MTLPaints_SetLinear\/RadialGradientPaint() methods\n- * in order to setup the fraction\/color values that are common to both.\n- *\/\n-static void\n-MTLPaints_SetMultiGradientPaint(void* multiGradProgram,\n-                                jint numStops,\n-                                void *pFractions, void *pPixels)\n-{\n-    \/\/TODO\n-    J2dTraceLn(J2D_TRACE_INFO, \"MTLPaints_SetMultiGradientPaint -- :TODO\");\n-\n-}\n-\n-\/********************** LinearGradientPaint support *************************\/\n-\n-\/**\n- * The handles to the LinearGradientPaint fragment program objects.  The\n- * index to the array should be a bitwise-or'ing of the MULTI_* flags defined\n- * above.  Note that most applications will likely need to initialize one\n- * or two of these elements, so the array is usually sparsely populated.\n- *\/\n-static void* linearGradPrograms[MAX_PROGRAMS];\n-\n-\/**\n- * Compiles and links the LinearGradientPaint shader program.  If successful,\n- * this function returns a handle to the newly created shader program;\n- * otherwise returns 0.\n- *\/\n-static void*\n-MTLPaints_CreateLinearGradProgram(jint flags)\n-{\n-    char *paintVars;\n-    char *distCode;\n-\n-    J2dTraceLn1(J2D_TRACE_INFO,\n-                \"MTLPaints_CreateLinearGradProgram\",\n-                flags);\n-\n-    \/*\n-     * To simplify the code and to make it easier to upload a number of\n-     * uniform values at once, we pack a bunch of scalar (float) values\n-     * into vec3 values below.  Here's how the values are related:\n-     *\n-     *   params.x = p0\n-     *   params.y = p1\n-     *   params.z = p3\n-     *\n-     *   yoff = dstOps->yOffset + dstOps->height\n-     *\/\n-    paintVars =\n-        \"uniform vec3 params;\"\n-        \"uniform float yoff;\";\n-    distCode =\n-        \/\/ note that gl_FragCoord is in window space relative to the\n-        \/\/ lower-left corner, so we have to flip the y-coordinate here\n-        \"vec3 fragCoord = vec3(gl_FragCoord.x, yoff-gl_FragCoord.y, 1.0);\"\n-        \"dist = dot(params, fragCoord);\";\n-\n-    return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);\n-}\n-\n-\/********************** RadialGradientPaint support *************************\/\n-\n-\/**\n- * The handles to the RadialGradientPaint fragment program objects.  The\n- * index to the array should be a bitwise-or'ing of the MULTI_* flags defined\n- * above.  Note that most applications will likely need to initialize one\n- * or two of these elements, so the array is usually sparsely populated.\n- *\/\n-static void* radialGradPrograms[MAX_PROGRAMS];\n-\n-\/**\n- * Compiles and links the RadialGradientPaint shader program.  If successful,\n- * this function returns a handle to the newly created shader program;\n- * otherwise returns 0.\n- *\/\n-static void*\n-MTLPaints_CreateRadialGradProgram(jint flags)\n-{\n-    char *paintVars;\n-    char *distCode;\n-\n-    J2dTraceLn1(J2D_TRACE_INFO,\n-                \"MTLPaints_CreateRadialGradProgram\",\n-                flags);\n-\n-    \/*\n-     * To simplify the code and to make it easier to upload a number of\n-     * uniform values at once, we pack a bunch of scalar (float) values\n-     * into vec3 and vec4 values below.  Here's how the values are related:\n-     *\n-     *   m0.x = m00\n-     *   m0.y = m01\n-     *   m0.z = m02\n-     *\n-     *   m1.x = m10\n-     *   m1.y = m11\n-     *   m1.z = m12\n-     *\n-     *   precalc.x = focusX\n-     *   precalc.y = yoff = dstOps->yOffset + dstOps->height\n-     *   precalc.z = 1.0 - (focusX * focusX)\n-     *   precalc.w = 1.0 \/ precalc.z\n-     *\/\n-    paintVars =\n-        \"uniform vec3 m0;\"\n-        \"uniform vec3 m1;\"\n-        \"uniform vec4 precalc;\";\n-\n-    \/*\n-     * The following code is derived from Daniel Rice's whitepaper on\n-     * radial gradient performance (attached to the bug report for 6521533).\n-     * Refer to that document as well as the setup code in the Java-level\n-     * BufferedPaints.setRadialGradientPaint() method for more details.\n-     *\/\n-    distCode =\n-        \/\/ note that gl_FragCoord is in window space relative to the\n-        \/\/ lower-left corner, so we have to flip the y-coordinate here\n-        \"vec3 fragCoord =\"\n-        \"    vec3(gl_FragCoord.x, precalc.y - gl_FragCoord.y, 1.0);\"\n-        \"float x = dot(fragCoord, m0);\"\n-        \"float y = dot(fragCoord, m1);\"\n-        \"float xfx = x - precalc.x;\"\n-        \"dist = (precalc.x*xfx + sqrt(xfx*xfx + y*y*precalc.z))*precalc.w;\";\n-\n-    return MTLPaints_CreateMultiGradProgram(flags, paintVars, distCode);\n-}\n-\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLPaints.m","additions":0,"deletions":367,"binary":false,"changes":367,"status":"modified"},{"patch":"@@ -42,7 +42,2 @@\n- * translation to line segments.  The OpenGL specification lays out the\n- * \"diamond exit rule\" for line rasterization, but it is loose enough to\n- * allow for a wide range of line rendering hardware.  (It appears that\n- * some hardware, such as the Nvidia GeForce2 series, does not even meet\n- * the spec in all cases.)  As such it is difficult to find a mapping\n- * between the Java2D and OpenGL line specs that works consistently across\n- * all hardware combinations.\n+ * translation to line segments. It is same as what we have in\n+ * OGLrenderer.\n@@ -50,1 +45,1 @@\n- * Therefore the \"magic numbers\" you see here have been empirically derived\n+ * The \"magic numbers\" you see here have been empirically derived\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLRenderer.m","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * The CGLSDOps structure contains the CGL-specific information for a given\n+ * The MTLSDOps structure contains the MTL-specific information for a given\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceData.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-        bmtlsdo->textureTarget = -1;\n@@ -202,1 +201,1 @@\n- * Deletes native OpenGL resources associated with this surface.\n+ * Deletes native Metal resources associated with this surface.\n@@ -229,1 +228,1 @@\n- * native OpenGL resources and then frees any memory allocated within the\n+ * native Metal resources and then frees any memory allocated within the\n@@ -341,1 +340,1 @@\n-    J2dTraceLn(J2D_TRACE_ERROR, \"OGLSD_SwapBuffers -- :TODO\");\n+    J2dTraceLn(J2D_TRACE_ERROR, \"MTLSD_SwapBuffers -- :TODO\");\n@@ -345,1 +344,1 @@\n-#pragma mark \"--- CGLSurfaceData methods ---\"\n+#pragma mark \"--- MTLSurfaceData methods ---\"\n@@ -407,1 +406,1 @@\n-    J2dTraceLn(J2D_TRACE_INFO, \"CGLSurfaceData_clearWindow\");\n+    J2dTraceLn(J2D_TRACE_INFO, \"MTLSurfaceData_clearWindow\");\n@@ -409,2 +408,2 @@\n-    BMTLSDOps *mtlsdo = (MTLSDOps*) SurfaceData_GetOps(env, cglsd);\n-    MTLSDOps *cglsdo = (MTLSDOps*) mtlsdo->privOps;\n+    BMTLSDOps *bmtlsdo = (MTLSDOps*) SurfaceData_GetOps(env, cglsd);\n+    MTLSDOps *mtlsdo = (MTLSDOps*) bmtlsdo->privOps;\n@@ -412,2 +411,2 @@\n-    cglsdo->peerData = NULL;\n-    cglsdo->layer = NULL;\n+    mtlsdo->peerData = NULL;\n+    mtlsdo->layer = NULL;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceData.m","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -37,42 +37,0 @@\n-\n-\/**\n- * The MTLPixelFormat structure contains all the information OpenGL needs to\n- * know when copying from or into a particular system memory image buffer (via\n- * glDrawPixels(), glReadPixels, glTexSubImage2D(), etc).\n- *\n- *     GLenum format;\n- * The pixel format parameter used in glDrawPixels() and other similar calls.\n- * Indicates the component ordering for each pixel (e.g. GL_BGRA).\n- *\n- *     GLenum type;\n- * The pixel data type parameter used in glDrawPixels() and other similar\n- * calls.  Indicates the data type for an entire pixel or for each component\n- * in a pixel (e.g. GL_UNSIGNED_BYTE with GL_BGR means a pixel consists of\n- * 3 unsigned byte components, blue first, then green, then red;\n- * GL_UNSIGNED_INT_8_8_8_8_REV with GL_BGRA means a pixel consists of 1\n- * unsigned integer comprised of four byte components, alpha first, then red,\n- * then green, then blue).\n- *\n- *     jint alignment;\n- * The byte alignment parameter used in glPixelStorei(GL_UNPACK_ALIGNMENT).  A\n- * value of 4 indicates that each pixel starts on a 4-byte aligned region in\n- * memory, and so on.  This alignment parameter helps OpenGL speed up pixel\n- * transfer operations by transferring memory in aligned blocks.\n- *\n- *     jboolean hasAlpha;\n- * If true, indicates that this pixel format contains an alpha component.\n- *\n- *     jboolean isPremult;\n- * If true, indicates that this pixel format contains color components that\n- * have been pre-multiplied by their corresponding alpha component.\n- *\/\n-typedef struct {\n-    \/\/GLenum   format;\n-    \/\/GLenum   type;\n-    jint format;\n-    jint type;\n-    jint     alignment;\n-    jboolean hasAlpha;\n-    jboolean isPremult;\n-} MTPixelFormat;\n-\n@@ -92,5 +50,0 @@\n- *     GLenum activeBuffer;\n- * Can be either GL_FRONT if this is the front buffer surface of an onscreen\n- * window or a pbuffer surface, or GL_BACK if this is the backbuffer surface\n- * of an onscreen window.\n- *\n@@ -110,1 +63,1 @@\n- * The offset in pixels of the OpenGL viewport origin from the lower-left\n+ * The offset in pixels of the Metal viewport origin from the lower-left\n@@ -112,1 +65,1 @@\n- * Windows XP has lower-left insets of (4,4).  The OpenGL viewport origin\n+ * Windows XP has lower-left insets of (4,4).  The Metal viewport origin\n@@ -116,1 +69,1 @@\n- * need to adjust the OpenGL viewport origin by an x\/yOffset of (-4,-4).  On\n+ * need to adjust the Metal viewport origin by an x\/yOffset of (-4,-4).  On\n@@ -129,3 +82,3 @@\n- *     GLuint textureID;\n- * The texture object handle, as generated by glGenTextures().  If this value\n- * is zero, the texture has not yet been initialized.\n+ *     void* pTexture;\n+ * The texture object handle, as generated by MTLTextureDescriptor(). If this\n+ * value is null, the texture has not yet been initialized.\n@@ -143,18 +96,0 @@\n- *\n- *     GLenum textureTarget;\n- * The texture target of the texture object for this surface.  If this\n- * surface is not backed by a texture, this value is set to zero.  Otherwise,\n- * this value is GL_TEXTURE_RECTANGLE_ARB when the GL_ARB_texture_rectangle\n- * extension is in use; if not, it is set to GL_TEXTURE_2D.\n- *\n- *     GLint textureFilter;\n- * The current filter state for this texture object (can be either GL_NEAREST\n- * or GL_LINEAR).  We cache this value here and check it before updating\n- * the filter state to avoid redundant calls to glTexParameteri() when the\n- * filter state remains constant (see the MTLSD_UPDATE_TEXTURE_FILTER()\n- * macro below).\n- *\n- *     GLuint fbobjectID, depthID;\n- * The object handles for the framebuffer object and depth renderbuffer\n- * associated with this surface.  These fields are only used when\n- * drawableType is MTLSD_FBOBJECT, otherwise they are zero.\n@@ -182,4 +117,0 @@\n-   \/* GLenum *\/ jint                      textureTarget;\n-   \/* GLint  *\/ jint                      textureFilter;\n-   \/* GLuint *\/ jint                      fbobjectID;\n-   \/* GLuint  *\/ jint                     depthID;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLSurfaceDataBase.h","additions":6,"deletions":75,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n- * as intensity values (which work well with the GL_MODULATE function).\n+ * as intensity values.\n@@ -134,1 +134,1 @@\n-    \/\/ TODO : Need to fix RGB order in case of LCD\n+    \/\/ TODO : Need to verify RGB order in case of LCD\n@@ -423,1 +423,0 @@\n-    MTLVertexCache_RestoreColorState(mtlc);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -72,1 +72,0 @@\n-void MTLVertexCache_RestoreColorState(MTLContext *mtlc);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLVertexCache.h","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -133,40 +133,0 @@\n-\/**\n- * This method is somewhat hacky, but necessary for the foreseeable future.\n- * The problem is the way OpenGL handles color values in vertex arrays.  When\n- * a vertex in a vertex array contains a color, and then the vertex array\n- * is rendered via glDrawArrays(), the global OpenGL color state is actually\n- * modified each time a vertex is rendered.  This means that after all\n- * vertices have been flushed, the global OpenGL color state will be set to\n- * the color of the most recently rendered element in the vertex array.\n- *\n- * The reason this is a problem for us is that we do not want to flush the\n- * vertex array (in the case of mask\/glyph operations) or issue a glEnd()\n- * (in the case of non-antialiased primitives) everytime the current color\n- * changes, which would defeat any benefit from batching in the first place.\n- * We handle this in practice by not calling CHECK\/RESET_PREVIOUS_OP() when\n- * the simple color state is changing in MTLPaints_SetColor().  This is\n- * problematic for vertex caching because we may end up with the following\n- * situation, for example:\n- *   SET_COLOR (orange)\n- *   MASK_FILL\n- *   MASK_FILL\n- *   SET_COLOR (blue; remember, this won't cause a flush)\n- *   FILL_RECT (this will cause the vertex array to be flushed)\n- *\n- * In this case, we would actually end up rendering an orange FILL_RECT,\n- * not a blue one as intended, because flushing the vertex cache flush would\n- * override the color state from the most recent SET_COLOR call.\n- *\n- * Long story short, the easiest way to resolve this problem is to call\n- * this method just after disabling the mask\/glyph cache, which will ensure\n- * that the appropriate color state is restored.\n- *\/\n-void\n-MTLVertexCache_RestoreColorState(MTLContext *mtlc)\n-{\n-\/\/    TODO\n-\/\/    if (mtlc.paint.paintState == sun_java2d_SunGraphics2D_PAINT_ALPHACOLOR) {\n-\/\/        \/\/mtlc.paint.color = mtlc.paint.pixel;\n-\/\/    }\n-}\n-\n@@ -176,3 +136,0 @@\n-    \/\/ TODO : We are creating mask cache only of type MTLPixelFormatA8Unorm\n-    \/\/ when we need more than 1 byte to store a pixel(LCD) we need to update\n-    \/\/ below code.\n@@ -238,1 +195,1 @@\n-    \/\/ we are force flusging vertexcache.\n+    \/\/ we are force flushing vertexcache.\n@@ -241,1 +198,0 @@\n-    MTLVertexCache_RestoreColorState(mtlc);\n@@ -250,1 +206,0 @@\n-    \/\/encoder = [mtlc.encoderManager getTextureEncoder:dstOps isSrcOpaque:NO];\n@@ -273,4 +228,0 @@\n-        \/\/ TODO : Since we are not committing command buffer\n-        \/\/ in FlushVertexCache we need to create new maskcache\n-        \/\/ after present cache is full. Check whether we can\n-        \/\/ avoid multiple cache creation.\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLVertexCache.m","additions":1,"deletions":50,"binary":false,"changes":51,"status":"modified"}]}