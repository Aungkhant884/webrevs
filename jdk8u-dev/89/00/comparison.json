{"files":[{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -388,2 +389,12 @@\n-        return new DOMSerializerImpl();\n-    }\n+            try {\n+                Class serializerClass = ObjectFactory.findProviderClass(\n+                    \"com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl\",\n+                    ObjectFactory.findClassLoader(), true);\n+                return (LSSerializer) serializerClass.newInstance();\n+            }\n+            catch (Exception e) {}\n+            \/\/ Fall back to Xerces' deprecated serializer if\n+            \/\/ the Xalan based serializer is unavailable.\n+            return new DOMSerializerImpl();\n+        }\n+\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xerces\/internal\/dom\/CoreDOMImplementationImpl.java","additions":18,"deletions":7,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -125,0 +125,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/BaseMarkupSerializer.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2002,2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -38,0 +39,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/DOMSerializer.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, replaced by\n+ * {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/DOMSerializerImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- *\n@@ -34,0 +33,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/ElementState.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 2000-2002,2004,2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -32,0 +33,4 @@\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/EncodingInfo.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/Encodings.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n- *\n@@ -49,0 +48,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/HTMLdtd.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2002,2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -35,0 +36,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/IndentPrinter.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2002,2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -28,0 +29,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/LineSeparator.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2002,2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -28,0 +29,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/Method.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2002,2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -62,0 +63,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/OutputFormat.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2002,2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -43,0 +44,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/Printer.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2002,2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -63,0 +64,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/Serializer.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,0 +39,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/SerializerFactory.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2002,2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -37,0 +38,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/SerializerFactoryImpl.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -6,5 +6,6 @@\n- * Copyright 1999-2002,2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n@@ -61,0 +62,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/TextSerializer.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+ *\n@@ -80,0 +81,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/XML11Serializer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+ *\n@@ -89,0 +90,5 @@\n+ *\n+ * @deprecated As of JDK 1.9, Xerces 2.9.0, Xerces DOM L3 Serializer implementation\n+ * is replaced by that of Xalan. Main class\n+ * {@link com.sun.org.apache.xml.internal.serialize.DOMSerializerImpl} is replaced\n+ * by {@link com.sun.org.apache.xml.internal.serializer.dom3.LSSerializerImpl}.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serialize\/XMLSerializer.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+\n+package com.sun.org.apache.xml.internal.serializer;\n+\n+import java.io.IOException;\n+\n+import org.w3c.dom.Node;\n+import org.w3c.dom.DOMErrorHandler;\n+import org.w3c.dom.ls.LSSerializerFilter;\n+\n+\/**\n+ * Interface for a DOM serializer capable of serializing DOMs as specified in\n+ * the DOM Level 3 Save Recommendation.\n+ * <p>\n+ * The DOM3Serializer is a facet of a serializer and is obtained from the\n+ * asDOM3Serializer() method of the org.apache.xml.serializer.Serializer interface.\n+ * A serializer may or may not support a level 3 DOM serializer, if it does not then the\n+ * return value from asDOM3Serializer() is null.\n+ * <p>\n+ * Example:\n+ * <pre>\n+ * Document     doc;\n+ * Serializer   ser;\n+ * OutputStream os;\n+ * DOMErrorHandler handler;\n+ *\n+ * ser = ...;\n+ * os = ...;\n+ * handler = ...;\n+ *\n+ * ser.setOutputStream( os );\n+ * DOM3Serialzier dser = (DOM3Serialzier)ser.asDOM3Serializer();\n+ * dser.setErrorHandler(handler);\n+ * dser.serialize(doc);\n+ * <\/pre>\n+ *\n+ * @see org.apache.xml.serializer.Serializer\n+ *\n+ * @xsl.usage general\n+ *\n+ *\/\n+public interface DOM3Serializer {\n+    \/**\n+     * Serializes the Level 3 DOM node. Throws an exception only if an I\/O\n+     * exception occured while serializing.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @param node the Level 3 DOM node to serialize\n+     * @throws IOException if an I\/O exception occured while serializing\n+     *\/\n+    public void serializeDOM3(Node node) throws IOException;\n+\n+    \/**\n+     * Sets a DOMErrorHandler on the DOM Level 3 Serializer.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @param handler the Level 3 DOMErrorHandler\n+     *\/\n+    public void setErrorHandler(DOMErrorHandler handler);\n+\n+    \/**\n+     * Returns a DOMErrorHandler set on the DOM Level 3 Serializer.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @return A Level 3 DOMErrorHandler\n+     *\/\n+    public DOMErrorHandler getErrorHandler();\n+\n+    \/**\n+     * Sets a LSSerializerFilter on the DOM Level 3 Serializer to filter nodes\n+     * during serialization.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @param filter the Level 3 LSSerializerFilter\n+     *\/\n+    public void setNodeFilter(LSSerializerFilter filter);\n+\n+    \/**\n+     * Returns a LSSerializerFilter set on the DOM Level 3 Serializer to filter nodes\n+     * during serialization.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @return The Level 3 LSSerializerFilter\n+     *\/\n+    public LSSerializerFilter getNodeFilter();\n+\n+    \/**\n+     * Sets the new line character to be used during serialization\n+     * @param newLine a String that is the end-of-line character sequence to be\n+     * used in serialization.\n+     *\/\n+    public void setNewLine(String newLine);\n+}\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/DOM3Serializer.java","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -773,0 +773,9 @@\n+\n+    \/**\n+     * @see org.apache.xml.serializer.Serializer#asDOM3Serializer()\n+     *\/\n+    public Object asDOM3Serializer() throws IOException\n+    {\n+        couldThrowIOException();\n+        return null;\n+    }\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/EmptySerializer.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -154,0 +154,18 @@\n+    \/**\n+     * Determines if the encoding specified was recognized by the\n+     * serializer or not.\n+     *\n+     * @param encoding The encoding\n+     * @return boolean - true if the encoding was recognized else false\n+     *\/\n+    public static boolean isRecognizedEncoding(String encoding)\n+    {\n+        EncodingInfo ei;\n+\n+        String normalizedEncoding = toUpperCaseFast(encoding);\n+        ei = _encodingInfos.findEncoding(normalizedEncoding);\n+        if (ei != null)\n+            return true;\n+        return false;\n+    }\n+\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/Encodings.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2003-2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -113,3 +115,23 @@\n-     * Flush any pending events currently queued up in the serializer. This will\n-     * flush any input that the serializer has which it has not yet sent as\n-     * output.\n+     * A SerializationHandler accepts SAX-like events, so\n+     * it can accumulate attributes or namespace nodes after\n+     * a startElement().\n+     * <p>\n+     * If the SerializationHandler has a Writer or OutputStream,\n+     * a call to this method will flush such accumulated\n+     * events as a closed start tag for an element.\n+     * <p>\n+     * If the SerializationHandler wraps a ContentHandler,\n+     * a call to this method will flush such accumulated\n+     * events as a SAX (not SAX-like) calls to\n+     * startPrefixMapping() and startElement().\n+     * <p>\n+     * If one calls endDocument() then one need not call\n+     * this method since a call to endDocument() will\n+     * do what this method does. However, in some\n+     * circumstances, such as with document fragments,\n+     * endDocument() is not called and it may be\n+     * necessary to call this method to flush\n+     * any pending events.\n+     * <p>\n+     * For performance reasons this method should not be called\n+     * very often.\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/SerializationHandler.java","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 1999-2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -223,0 +225,16 @@\n+\n+    \/**\n+     * Return an Object into this serializer to be cast to a DOM3Serializer.\n+     * Through the returned object the document to be serialized,\n+     * a DOM (Level 3), can be provided to the serializer.\n+     * If the serializer does not support casting to a {@link DOM3Serializer}\n+     * interface, it should return null.\n+     * <p>\n+     * In principle only one of asDOM3Serializer() or asContentHander()\n+     * should be called.\n+     *\n+     * @return An Object to be cast to a DOM3Serializer interface into this serializer,\n+     *  or null if the serializer is not DOM capable\n+     * @throws IOException An I\/O exception occured\n+     *\/\n+    public Object asDOM3Serializer() throws IOException;\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/Serializer.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1561,0 +1561,15 @@\n+    \/**\n+     * Return a {@link DOM3Serializer} interface into this serializer. If the\n+     * serializer does not support the {@link DOM3Serializer} interface, it should\n+     * return null.\n+     *\n+     * @return A {@link DOM3Serializer} interface into this serializer,  or null\n+     * if the serializer is not DOM capable\n+     * @throws IOException An I\/O exception occured\n+     * @see org.apache.xml.serializer.Serializer#asDOM3Serializer()\n+     *\/\n+    public Object asDOM3Serializer() throws IOException\n+    {\n+        return new com.sun.org.apache.xml.internal.serializer.dom3.DOM3SerializerImpl(this);\n+    }\n+\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/SerializerBase.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-            ser = (Serializer) cls.newInstance();\n+            ser = (Serializer) obj;\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/SerializerFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -542,1 +542,1 @@\n-                    boolean b = \"yes\".equals(val) ? true : false;\n+                    boolean b = val.endsWith(\"yes\") ? true : false;\n@@ -561,1 +561,1 @@\n-                    boolean b = \"yes\".equals(val) ? true : false;\n+                    boolean b = val.endsWith(\"yes\") ? true : false;\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/ToStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1338,0 +1338,8 @@\n+\n+    \/**\n+     * @see org.apache.xml.serializer.Serializer#asDOM3Serializer()\n+     *\/\n+    public Object asDOM3Serializer() throws IOException\n+    {\n+        return m_handler.asDOM3Serializer();\n+    }\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/ToUnknownStream.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\n+package com.sun.org.apache.xml.internal.serializer.dom3;\n+\n+import java.io.IOException;\n+\n+import com.sun.org.apache.xml.internal.serializer.DOM3Serializer;\n+import com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n+import com.sun.org.apache.xml.internal.serializer.utils.WrappedRuntimeException;\n+import org.w3c.dom.DOMErrorHandler;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.ls.LSSerializerFilter;\n+\n+\/**\n+ * This class implements the DOM3Serializer interface.\n+ *\n+ * @xsl.usage internal\n+ *\/\n+public final class DOM3SerializerImpl implements DOM3Serializer {\n+\n+    \/**\n+     * Private class members\n+     *\/\n+    \/\/ The DOMErrorHandler\n+    private DOMErrorHandler fErrorHandler;\n+\n+    \/\/ A LSSerializerFilter\n+    private LSSerializerFilter fSerializerFilter;\n+\n+    \/\/ The end-of-line character sequence\n+    private String fNewLine;\n+\n+    \/\/ A SerializationHandler ex. an instance of ToXMLStream\n+    private SerializationHandler fSerializationHandler;\n+\n+    \/**\n+     * Constructor\n+     *\n+     * @param handler An instance of the SerializationHandler interface.\n+     *\/\n+    public DOM3SerializerImpl(SerializationHandler handler) {\n+        fSerializationHandler = handler;\n+    }\n+\n+    \/\/ Public memebers\n+\n+    \/**\n+     * Returns a DOMErrorHandler set on the DOM Level 3 Serializer.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @return A Level 3 DOMErrorHandler\n+     *\/\n+    public DOMErrorHandler getErrorHandler() {\n+        return fErrorHandler;\n+    }\n+\n+    \/**\n+     * Returns a LSSerializerFilter set on the DOM Level 3 Serializer to filter nodes\n+     * during serialization.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @return The Level 3 LSSerializerFilter\n+     *\/\n+    public LSSerializerFilter getNodeFilter() {\n+        return fSerializerFilter;\n+    }\n+\n+\n+    \/**\n+     * Serializes the Level 3 DOM node by creating an instance of DOM3TreeWalker\n+     * which traverses the DOM tree and invokes handler events to serialize\n+     * the DOM NOde. Throws an exception only if an I\/O exception occured\n+     * while serializing.\n+     * This interface is a public API.\n+     *\n+     * @param node the Level 3 DOM node to serialize\n+     * @throws IOException if an I\/O exception occured while serializing\n+     *\/\n+    public void serializeDOM3(Node node) throws IOException {\n+        try {\n+            DOM3TreeWalker walker = new DOM3TreeWalker(fSerializationHandler,\n+                    fErrorHandler, fSerializerFilter, fNewLine);\n+\n+            walker.traverse(node);\n+        } catch (org.xml.sax.SAXException se) {\n+            throw new WrappedRuntimeException(se);\n+        }\n+    }\n+\n+    \/**\n+     * Sets a DOMErrorHandler on the DOM Level 3 Serializer.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @param handler the Level 3 DOMErrorHandler\n+     *\/\n+    public void setErrorHandler(DOMErrorHandler handler) {\n+        fErrorHandler = handler;\n+    }\n+\n+    \/**\n+     * Sets a LSSerializerFilter on the DOM Level 3 Serializer to filter nodes\n+     * during serialization.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @param filter the Level 3 LSSerializerFilter\n+     *\/\n+    public void setNodeFilter(LSSerializerFilter filter) {\n+        fSerializerFilter = filter;\n+    }\n+\n+    \/**\n+     * Sets a SerializationHandler on the DOM Serializer.\n+     *\n+     * This interface is a public API.\n+     *\n+     * @param handler An instance of SerializationHandler\n+     *\/\n+    public void setSerializationHandler(SerializationHandler handler) {\n+        fSerializationHandler = handler;\n+    }\n+\n+    \/**\n+     * Sets the new line character to be used during serialization\n+     * @param newLine a String that is the end-of-line character sequence to be\n+     * used in serialization.\n+     *\/\n+    public void setNewLine(String newLine) {\n+        fNewLine = newLine;\n+    }\n+}\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/DOM3SerializerImpl.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -0,0 +1,2145 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+\n+package com.sun.org.apache.xml.internal.serializer.dom3;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.Enumeration;\n+import java.util.Hashtable;\n+import java.util.Properties;\n+\n+import com.sun.org.apache.xml.internal.serializer.OutputPropertiesFactory;\n+import com.sun.org.apache.xml.internal.serializer.SerializationHandler;\n+import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;\n+import com.sun.org.apache.xml.internal.serializer.utils.Utils;\n+import com.sun.org.apache.xerces.internal.util.XML11Char;\n+import com.sun.org.apache.xerces.internal.util.XMLChar;\n+import org.w3c.dom.Attr;\n+import org.w3c.dom.CDATASection;\n+import org.w3c.dom.Comment;\n+import org.w3c.dom.DOMError;\n+import org.w3c.dom.DOMErrorHandler;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.DocumentType;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Entity;\n+import org.w3c.dom.EntityReference;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.w3c.dom.ProcessingInstruction;\n+import org.w3c.dom.Text;\n+import org.w3c.dom.ls.LSSerializerFilter;\n+import org.w3c.dom.traversal.NodeFilter;\n+import org.xml.sax.Locator;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.ext.LexicalHandler;\n+import org.xml.sax.helpers.LocatorImpl;\n+\n+\/**\n+ * Built on org.apache.xml.serializer.TreeWalker and adds functionality to\n+ * traverse and serialize a DOM Node (Level 2 or Level 3) as specified in\n+ * the DOM Level 3 LS Recommedation by evaluating and applying DOMConfiguration\n+ * parameters and filters if any during serialization.\n+ *\n+ * @xsl.usage internal\n+ *\/\n+final class DOM3TreeWalker {\n+\n+    \/**\n+     * The SerializationHandler, it extends ContentHandler and when\n+     * this class is instantiated via the constructor provided, a\n+     * SerializationHandler object is passed to it.\n+     *\/\n+    private SerializationHandler fSerializer = null;\n+\n+    \/** We do not need DOM2Helper since DOM Level 3 LS applies to DOM Level 2 or newer *\/\n+\n+    \/** Locator object for this TreeWalker          *\/\n+    private LocatorImpl fLocator = new LocatorImpl();\n+\n+    \/** ErrorHandler *\/\n+    private DOMErrorHandler fErrorHandler = null;\n+\n+    \/** LSSerializerFilter *\/\n+    private LSSerializerFilter fFilter = null;\n+\n+    \/** If the serializer is an instance of a LexicalHandler *\/\n+    private LexicalHandler fLexicalHandler = null;\n+\n+    private int fWhatToShowFilter;\n+\n+    \/** New Line character to use in serialization *\/\n+    private String fNewLine = null;\n+\n+    \/** DOMConfiguration Properties *\/\n+    private Properties fDOMConfigProperties = null;\n+\n+    \/** Keeps track if we are in an entity reference when entities=true *\/\n+    private boolean fInEntityRef = false;\n+\n+    \/** Stores the version of the XML document to be serialize *\/\n+    private String fXMLVersion = null;\n+\n+    \/** XML Version, default 1.0 *\/\n+    private boolean fIsXMLVersion11 = false;\n+\n+    \/** Is the Node a Level 3 DOM node *\/\n+    private boolean fIsLevel3DOM = false;\n+\n+    \/** DOM Configuration Parameters *\/\n+    private int fFeatures = 0;\n+\n+    \/** Flag indicating whether following text to be processed is raw text          *\/\n+    boolean fNextIsRaw = false;\n+\n+    \/\/\n+    private static final String XMLNS_URI = \"http:\/\/www.w3.org\/2000\/xmlns\/\";\n+\n+    \/\/\n+    private static final String XMLNS_PREFIX = \"xmlns\";\n+\n+    \/\/\n+    private static final String XML_URI = \"http:\/\/www.w3.org\/XML\/1998\/namespace\";\n+\n+    \/\/\n+    private static final String XML_PREFIX = \"xml\";\n+\n+    \/** stores namespaces in scope *\/\n+    protected NamespaceSupport fNSBinder;\n+\n+    \/** stores all namespace bindings on the current element *\/\n+    protected NamespaceSupport fLocalNSBinder;\n+\n+    \/** stores the current element depth *\/\n+    private int fElementDepth = 0;\n+\n+    \/\/ ***********************************************************************\n+    \/\/ DOMConfiguration paramter settings\n+    \/\/ ***********************************************************************\n+    \/\/ Parameter canonical-form, true [optional] - NOT SUPPORTED\n+    private final static int CANONICAL = 0x1 << 0;\n+\n+    \/\/ Parameter cdata-sections, true [required] (default)\n+    private final static int CDATA = 0x1 << 1;\n+\n+    \/\/ Parameter check-character-normalization, true [optional] - NOT SUPPORTED\n+    private final static int CHARNORMALIZE = 0x1 << 2;\n+\n+    \/\/ Parameter comments, true [required] (default)\n+    private final static int COMMENTS = 0x1 << 3;\n+\n+    \/\/ Parameter datatype-normalization, true [optional] - NOT SUPPORTED\n+    private final static int DTNORMALIZE = 0x1 << 4;\n+\n+    \/\/ Parameter element-content-whitespace, true [required] (default) - value - false [optional] NOT SUPPORTED\n+    private final static int ELEM_CONTENT_WHITESPACE = 0x1 << 5;\n+\n+    \/\/ Parameter entities, true [required] (default)\n+    private final static int ENTITIES = 0x1 << 6;\n+\n+    \/\/ Parameter infoset, true [required] (default), false has no effect --> True has no effect for the serializer\n+    private final static int INFOSET = 0x1 << 7;\n+\n+    \/\/ Parameter namespaces, true [required] (default)\n+    private final static int NAMESPACES = 0x1 << 8;\n+\n+    \/\/ Parameter namespace-declarations, true [required] (default)\n+    private final static int NAMESPACEDECLS = 0x1 << 9;\n+\n+    \/\/ Parameter normalize-characters, true [optional] - NOT SUPPORTED\n+    private final static int NORMALIZECHARS = 0x1 << 10;\n+\n+    \/\/ Parameter split-cdata-sections, true [required] (default)\n+    private final static int SPLITCDATA = 0x1 << 11;\n+\n+    \/\/ Parameter validate, true [optional] - NOT SUPPORTED\n+    private final static int VALIDATE = 0x1 << 12;\n+\n+    \/\/ Parameter validate-if-schema, true [optional] - NOT SUPPORTED\n+    private final static int SCHEMAVALIDATE = 0x1 << 13;\n+\n+    \/\/ Parameter split-cdata-sections, true [required] (default)\n+    private final static int WELLFORMED = 0x1 << 14;\n+\n+    \/\/ Parameter discard-default-content, true [required] (default)\n+    \/\/ Not sure how this will be used in level 2 Documents\n+    private final static int DISCARDDEFAULT = 0x1 << 15;\n+\n+    \/\/ Parameter format-pretty-print, true [optional]\n+    private final static int PRETTY_PRINT = 0x1 << 16;\n+\n+    \/\/ Parameter ignore-unknown-character-denormalizations, true [required] (default)\n+    \/\/ We currently do not support XML 1.1 character normalization\n+    private final static int IGNORE_CHAR_DENORMALIZE = 0x1 << 17;\n+\n+    \/\/ Parameter discard-default-content, true [required] (default)\n+    private final static int XMLDECL = 0x1 << 18;\n+\n+    \/**\n+     * Constructor.\n+     * @param   contentHandler serialHandler The implemention of the SerializationHandler interface\n+     *\/\n+    DOM3TreeWalker(\n+        SerializationHandler serialHandler,\n+        DOMErrorHandler errHandler,\n+        LSSerializerFilter filter,\n+        String newLine) {\n+        fSerializer = serialHandler;\n+        \/\/fErrorHandler = errHandler == null ? new DOMErrorHandlerImpl() : errHandler; \/\/ Should we be using the default?\n+        fErrorHandler = errHandler;\n+        fFilter = filter;\n+        fLexicalHandler = null;\n+        fNewLine = newLine;\n+\n+        fNSBinder = new NamespaceSupport();\n+        fLocalNSBinder = new NamespaceSupport();\n+\n+        fDOMConfigProperties = fSerializer.getOutputFormat();\n+        fSerializer.setDocumentLocator(fLocator);\n+        initProperties(fDOMConfigProperties);\n+\n+        try {\n+            \/\/ Bug see Bugzilla  26741\n+            fLocator.setSystemId(\n+                System.getProperty(\"user.dir\") + File.separator + \"dummy.xsl\");\n+        } catch (SecurityException se) { \/\/ user.dir not accessible from applet\n+\n+        }\n+    }\n+\n+    \/**\n+     * Perform a pre-order traversal non-recursive style.\n+     *\n+     * Note that TreeWalker assumes that the subtree is intended to represent\n+     * a complete (though not necessarily well-formed) document and, during a\n+     * traversal, startDocument and endDocument will always be issued to the\n+     * SAX listener.\n+     *\n+     * @param pos Node in the tree where to start traversal\n+     *\n+     * @throws TransformerException\n+     *\/\n+    public void traverse(Node pos) throws org.xml.sax.SAXException {\n+        this.fSerializer.startDocument();\n+\n+        \/\/ Determine if the Node is a DOM Level 3 Core Node.\n+        if (pos.getNodeType() != Node.DOCUMENT_NODE) {\n+            Document ownerDoc = pos.getOwnerDocument();\n+            if (ownerDoc != null\n+                && ownerDoc.getImplementation().hasFeature(\"Core\", \"3.0\")) {\n+                fIsLevel3DOM = true;\n+            }\n+        } else {\n+            if (((Document) pos)\n+                .getImplementation()\n+                .hasFeature(\"Core\", \"3.0\")) {\n+                fIsLevel3DOM = true;\n+            }\n+        }\n+\n+        if (fSerializer instanceof LexicalHandler) {\n+            fLexicalHandler = ((LexicalHandler) this.fSerializer);\n+        }\n+\n+        if (fFilter != null)\n+            fWhatToShowFilter = fFilter.getWhatToShow();\n+\n+        Node top = pos;\n+\n+        while (null != pos) {\n+            startNode(pos);\n+\n+            Node nextNode = null;\n+\n+            nextNode = pos.getFirstChild();\n+\n+            while (null == nextNode) {\n+                endNode(pos);\n+\n+                if (top.equals(pos))\n+                    break;\n+\n+                nextNode = pos.getNextSibling();\n+\n+                if (null == nextNode) {\n+                    pos = pos.getParentNode();\n+\n+                    if ((null == pos) || (top.equals(pos))) {\n+                        if (null != pos)\n+                            endNode(pos);\n+\n+                        nextNode = null;\n+\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            pos = nextNode;\n+        }\n+        this.fSerializer.endDocument();\n+    }\n+\n+    \/**\n+     * Perform a pre-order traversal non-recursive style.\n+\n+     * Note that TreeWalker assumes that the subtree is intended to represent\n+     * a complete (though not necessarily well-formed) document and, during a\n+     * traversal, startDocument and endDocument will always be issued to the\n+     * SAX listener.\n+     *\n+     * @param pos Node in the tree where to start traversal\n+     * @param top Node in the tree where to end traversal\n+     *\n+     * @throws TransformerException\n+     *\/\n+    public void traverse(Node pos, Node top) throws org.xml.sax.SAXException {\n+\n+        this.fSerializer.startDocument();\n+\n+        \/\/ Determine if the Node is a DOM Level 3 Core Node.\n+        if (pos.getNodeType() != Node.DOCUMENT_NODE) {\n+            Document ownerDoc = pos.getOwnerDocument();\n+            if (ownerDoc != null\n+                && ownerDoc.getImplementation().hasFeature(\"Core\", \"3.0\")) {\n+                fIsLevel3DOM = true;\n+            }\n+        } else {\n+            if (((Document) pos)\n+                .getImplementation()\n+                .hasFeature(\"Core\", \"3.0\")) {\n+                fIsLevel3DOM = true;\n+            }\n+        }\n+\n+        if (fSerializer instanceof LexicalHandler) {\n+            fLexicalHandler = ((LexicalHandler) this.fSerializer);\n+        }\n+\n+        if (fFilter != null)\n+            fWhatToShowFilter = fFilter.getWhatToShow();\n+\n+        while (null != pos) {\n+            startNode(pos);\n+\n+            Node nextNode = null;\n+\n+            nextNode = pos.getFirstChild();\n+\n+            while (null == nextNode) {\n+                endNode(pos);\n+\n+                if ((null != top) && top.equals(pos))\n+                    break;\n+\n+                nextNode = pos.getNextSibling();\n+\n+                if (null == nextNode) {\n+                    pos = pos.getParentNode();\n+\n+                    if ((null == pos) || ((null != top) && top.equals(pos))) {\n+                        nextNode = null;\n+\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            pos = nextNode;\n+        }\n+        this.fSerializer.endDocument();\n+    }\n+\n+    \/**\n+     * Optimized dispatch of characters.\n+     *\/\n+    private final void dispatachChars(Node node)\n+        throws org.xml.sax.SAXException {\n+        if (fSerializer != null) {\n+            this.fSerializer.characters(node);\n+        } else {\n+            String data = ((Text) node).getData();\n+            this.fSerializer.characters(data.toCharArray(), 0, data.length());\n+        }\n+    }\n+\n+    \/**\n+     * Start processing given node\n+     *\n+     * @param node Node to process\n+     *\n+     * @throws org.xml.sax.SAXException\n+     *\/\n+    protected void startNode(Node node) throws org.xml.sax.SAXException {\n+        if (node instanceof Locator) {\n+            Locator loc = (Locator) node;\n+            fLocator.setColumnNumber(loc.getColumnNumber());\n+            fLocator.setLineNumber(loc.getLineNumber());\n+            fLocator.setPublicId(loc.getPublicId());\n+            fLocator.setSystemId(loc.getSystemId());\n+        } else {\n+            fLocator.setColumnNumber(0);\n+            fLocator.setLineNumber(0);\n+        }\n+\n+        switch (node.getNodeType()) {\n+            case Node.DOCUMENT_TYPE_NODE :\n+                serializeDocType((DocumentType) node, true);\n+                break;\n+            case Node.COMMENT_NODE :\n+                serializeComment((Comment) node);\n+                break;\n+            case Node.DOCUMENT_FRAGMENT_NODE :\n+                \/\/ Children are traversed\n+                break;\n+            case Node.DOCUMENT_NODE :\n+                break;\n+            case Node.ELEMENT_NODE :\n+                serializeElement((Element) node, true);\n+                break;\n+            case Node.PROCESSING_INSTRUCTION_NODE :\n+                serializePI((ProcessingInstruction) node);\n+                break;\n+            case Node.CDATA_SECTION_NODE :\n+                serializeCDATASection((CDATASection) node);\n+                break;\n+            case Node.TEXT_NODE :\n+                serializeText((Text) node);\n+                break;\n+            case Node.ENTITY_REFERENCE_NODE :\n+                serializeEntityReference((EntityReference) node, true);\n+                break;\n+            default :\n+                }\n+    }\n+\n+    \/**\n+     * End processing of given node\n+     *\n+     *\n+     * @param node Node we just finished processing\n+     *\n+     * @throws org.xml.sax.SAXException\n+     *\/\n+    protected void endNode(Node node) throws org.xml.sax.SAXException {\n+\n+        switch (node.getNodeType()) {\n+            case Node.DOCUMENT_NODE :\n+                break;\n+            case Node.DOCUMENT_TYPE_NODE :\n+                serializeDocType((DocumentType) node, false);\n+                break;\n+            case Node.ELEMENT_NODE :\n+                serializeElement((Element) node, false);\n+                break;\n+            case Node.CDATA_SECTION_NODE :\n+                break;\n+            case Node.ENTITY_REFERENCE_NODE :\n+                serializeEntityReference((EntityReference) node, false);\n+                break;\n+            default :\n+                }\n+    }\n+\n+    \/\/ ***********************************************************************\n+    \/\/ Node serialization methods\n+    \/\/ ***********************************************************************\n+    \/**\n+     * Applies a filter on the node to serialize\n+     *\n+     * @param node The Node to serialize\n+     * @return True if the node is to be serialized else false if the node\n+     *         is to be rejected or skipped.\n+     *\/\n+    protected boolean applyFilter(Node node, int nodeType) {\n+        if (fFilter != null && (fWhatToShowFilter & nodeType) != 0) {\n+\n+            short code = fFilter.acceptNode(node);\n+            switch (code) {\n+                case NodeFilter.FILTER_REJECT :\n+                case NodeFilter.FILTER_SKIP :\n+                    return false; \/\/ skip the node\n+                default : \/\/ fall through..\n+            }\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Serializes a Document Type Node.\n+     *\n+     * @param node The Docuemnt Type Node to serialize\n+     * @param bStart Invoked at the start or end of node.  Default true.\n+     *\/\n+    protected void serializeDocType(DocumentType node, boolean bStart)\n+        throws SAXException {\n+        \/\/ The DocType and internalSubset can not be modified in DOM and is\n+        \/\/ considered to be well-formed as the outcome of successful parsing.\n+        String docTypeName = node.getNodeName();\n+        String publicId = node.getPublicId();\n+        String systemId = node.getSystemId();\n+        String internalSubset = node.getInternalSubset();\n+\n+        \/\/DocumentType nodes are never passed to the filter\n+\n+        if (internalSubset != null && !\"\".equals(internalSubset)) {\n+\n+            if (bStart) {\n+                try {\n+                    \/\/ The Serializer does not provide a way to write out the\n+                    \/\/ DOCTYPE internal subset via an event call, so we write it\n+                    \/\/ out here.\n+                    Writer writer = fSerializer.getWriter();\n+                    StringBuffer dtd = new StringBuffer();\n+\n+                    dtd.append(\"<!DOCTYPE \");\n+                    dtd.append(docTypeName);\n+                    if (null != publicId) {\n+                        dtd.append(\" PUBLIC \\\"\");\n+                        dtd.append(publicId);\n+                        dtd.append('\\\"');\n+                    }\n+\n+                    if (null != systemId) {\n+                        if (null == publicId) {\n+                            dtd.append(\" SYSTEM \\\"\");\n+                        } else {\n+                            dtd.append(\" \\\"\");\n+                        }\n+                        dtd.append(systemId);\n+                        dtd.append('\\\"');\n+                    }\n+\n+                    dtd.append(\" [ \");\n+\n+                    dtd.append(fNewLine);\n+                    dtd.append(internalSubset);\n+                    dtd.append(\"]>\");\n+                    dtd.append(fNewLine);\n+\n+                    writer.write(dtd.toString());\n+                    writer.flush();\n+\n+                } catch (IOException e) {\n+                    throw new SAXException(Utils.messages.createMessage(\n+                            MsgKey.ER_WRITING_INTERNAL_SUBSET, null), e);\n+                }\n+            } \/\/ else if !bStart do nothing\n+\n+        } else {\n+\n+            if (bStart) {\n+                if (fLexicalHandler != null) {\n+                    fLexicalHandler.startDTD(docTypeName, publicId, systemId);\n+                }\n+            } else {\n+                if (fLexicalHandler != null) {\n+                    fLexicalHandler.endDTD();\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Serializes a Comment Node.\n+     *\n+     * @param node The Comment Node to serialize\n+     *\/\n+    protected void serializeComment(Comment node) throws SAXException {\n+        \/\/ comments=true\n+        if ((fFeatures & COMMENTS) != 0) {\n+            String data = node.getData();\n+\n+            \/\/ well-formed=true\n+            if ((fFeatures & WELLFORMED) != 0) {\n+                isCommentWellFormed(data);\n+            }\n+\n+            if (fLexicalHandler != null) {\n+                \/\/ apply the LSSerializer filter after the operations requested by the\n+                \/\/ DOMConfiguration parameters have been applied\n+                if (!applyFilter(node, NodeFilter.SHOW_COMMENT)) {\n+                    return;\n+                }\n+\n+                fLexicalHandler.comment(data.toCharArray(), 0, data.length());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Serializes an Element Node.\n+     *\n+     * @param node The Element Node to serialize\n+     * @param bStart Invoked at the start or end of node.\n+     *\/\n+    protected void serializeElement(Element node, boolean bStart)\n+        throws SAXException {\n+        if (bStart) {\n+            fElementDepth++;\n+\n+            \/\/ We use the Xalan specific startElement and starPrefixMapping calls\n+            \/\/ (and addAttribute and namespaceAfterStartElement) as opposed to\n+            \/\/ SAX specific, for performance reasons as they reduce the overhead\n+            \/\/ of creating an AttList object upfront.\n+\n+            \/\/ well-formed=true\n+            if ((fFeatures & WELLFORMED) != 0) {\n+                isElementWellFormed(node);\n+            }\n+\n+            \/\/ REVISIT: We apply the LSSerializer filter for elements before\n+            \/\/ namesapce fixup\n+            if (!applyFilter(node, NodeFilter.SHOW_ELEMENT)) {\n+                return;\n+            }\n+\n+            \/\/ namespaces=true, record and fixup namspaced element\n+            if ((fFeatures & NAMESPACES) != 0) {\n+                fNSBinder.pushContext();\n+                fLocalNSBinder.reset();\n+\n+                recordLocalNSDecl(node);\n+                fixupElementNS(node);\n+            }\n+\n+            \/\/ Namespace normalization\n+            fSerializer.startElement(\n+                        node.getNamespaceURI(),\n+                    node.getLocalName(),\n+                    node.getNodeName());\n+\n+            serializeAttList(node);\n+\n+        } else {\n+                fElementDepth--;\n+\n+            \/\/ apply the LSSerializer filter\n+            if (!applyFilter(node, NodeFilter.SHOW_ELEMENT)) {\n+                return;\n+            }\n+\n+            this.fSerializer.endElement(\n+                node.getNamespaceURI(),\n+                node.getLocalName(),\n+                node.getNodeName());\n+            \/\/ since endPrefixMapping was not used by SerializationHandler it was removed\n+            \/\/ for performance reasons.\n+\n+            if ((fFeatures & NAMESPACES) != 0 ) {\n+                    fNSBinder.popContext();\n+            }\n+\n+        }\n+    }\n+\n+    \/**\n+     * Serializes the Attr Nodes of an Element.\n+     *\n+     * @param node The OwnerElement whose Attr Nodes are to be serialized.\n+     *\/\n+    protected void serializeAttList(Element node) throws SAXException {\n+        NamedNodeMap atts = node.getAttributes();\n+        int nAttrs = atts.getLength();\n+\n+        for (int i = 0; i < nAttrs; i++) {\n+            Node attr = atts.item(i);\n+\n+            String localName = attr.getLocalName();\n+            String attrName = attr.getNodeName();\n+            String attrPrefix = attr.getPrefix() == null ? \"\" : attr.getPrefix();\n+            String attrValue = attr.getNodeValue();\n+\n+            \/\/ Determine the Attr's type.\n+            String type = null;\n+            if (fIsLevel3DOM) {\n+                type = ((Attr) attr).getSchemaTypeInfo().getTypeName();\n+            }\n+            type = type == null ? \"CDATA\" : type;\n+\n+            String attrNS = attr.getNamespaceURI();\n+            if (attrNS !=null && attrNS.length() == 0) {\n+                attrNS=null;\n+                \/\/ we must remove prefix for this attribute\n+                attrName=attr.getLocalName();\n+            }\n+\n+            boolean isSpecified = ((Attr) attr).getSpecified();\n+            boolean addAttr = true;\n+            boolean applyFilter = false;\n+            boolean xmlnsAttr =\n+                attrName.equals(\"xmlns\") || attrName.startsWith(\"xmlns:\");\n+\n+            \/\/ well-formed=true\n+            if ((fFeatures & WELLFORMED) != 0) {\n+                isAttributeWellFormed(attr);\n+            }\n+\n+            \/\/-----------------------------------------------------------------\n+            \/\/ start Attribute namespace fixup\n+            \/\/-----------------------------------------------------------------\n+            \/\/ namespaces=true, normalize all non-namespace attributes\n+            \/\/ Step 3. Attribute\n+            if ((fFeatures & NAMESPACES) != 0 && !xmlnsAttr) {\n+\n+                        \/\/ If the Attr has a namespace URI\n+                        if (attrNS != null) {\n+                                attrPrefix = attrPrefix == null ? \"\" : attrPrefix;\n+\n+                                String declAttrPrefix = fNSBinder.getPrefix(attrNS);\n+                                String declAttrNS = fNSBinder.getURI(attrPrefix);\n+\n+                                \/\/ attribute has no prefix (default namespace decl does not apply to\n+                                \/\/ attributes)\n+                                \/\/ OR\n+                                \/\/ attribute prefix is not declared\n+                                \/\/ OR\n+                                \/\/ conflict: attribute has a prefix that conflicts with a binding\n+                                if (\"\".equals(attrPrefix) || \"\".equals(declAttrPrefix)\n+                                                || !attrPrefix.equals(declAttrPrefix)) {\n+\n+                                        \/\/ namespaceURI matches an in scope declaration of one or\n+                                        \/\/ more prefixes\n+                                        if (declAttrPrefix != null && !\"\".equals(declAttrPrefix)) {\n+                                                \/\/ pick the prefix that was found and change attribute's\n+                                                \/\/ prefix and nodeName.\n+                                                attrPrefix = declAttrPrefix;\n+\n+                                                if (declAttrPrefix.length() > 0 ) {\n+                                                        attrName = declAttrPrefix + \":\" + localName;\n+                                                } else {\n+                                                        attrName = localName;\n+                                                }\n+                                        } else {\n+                                                \/\/ The current prefix is not null and it has no in scope\n+                                                \/\/ declaration\n+                                                if (attrPrefix != null && !\"\".equals(attrPrefix)\n+                                                                && declAttrNS == null) {\n+                                                        \/\/ declare this prefix\n+                                                        if ((fFeatures & NAMESPACEDECLS) != 0) {\n+                                                                fSerializer.addAttribute(XMLNS_URI, attrPrefix,\n+                                                                                XMLNS_PREFIX + \":\" + attrPrefix, \"CDATA\",\n+                                                                                attrNS);\n+                                                                fNSBinder.declarePrefix(attrPrefix, attrNS);\n+                                                                fLocalNSBinder.declarePrefix(attrPrefix, attrNS);\n+                                                        }\n+                                                } else {\n+                                                        \/\/ find a prefix following the pattern \"NS\" +index\n+                                                        \/\/ (starting at 1)\n+                                                        \/\/ make sure this prefix is not declared in the current\n+                                                        \/\/ scope.\n+                                                        int counter = 1;\n+                                                        attrPrefix = \"NS\" + counter++;\n+\n+                                                        while (fLocalNSBinder.getURI(attrPrefix) != null) {\n+                                                                attrPrefix = \"NS\" + counter++;\n+                                                        }\n+                                                        \/\/ change attribute's prefix and Name\n+                                                        attrName = attrPrefix + \":\" + localName;\n+\n+                                                        \/\/ create a local namespace declaration attribute\n+                                                        \/\/ Add the xmlns declaration attribute\n+                                                        if ((fFeatures & NAMESPACEDECLS) != 0) {\n+\n+                                                                fSerializer.addAttribute(XMLNS_URI, attrPrefix,\n+                                                                                XMLNS_PREFIX + \":\" + attrPrefix, \"CDATA\",\n+                                                                                attrNS);\n+                                                        fNSBinder.declarePrefix(attrPrefix, attrNS);\n+                                                        fLocalNSBinder.declarePrefix(attrPrefix, attrNS);\n+                                                        }\n+                                                }\n+                                        }\n+                                }\n+\n+                        } else { \/\/ if the Attr has no namespace URI\n+                                \/\/ Attr has no localName\n+                                if (localName == null) {\n+                                        \/\/ DOM Level 1 node!\n+                                        String msg = Utils.messages.createMessage(\n+                                                        MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                                                        new Object[] { attrName });\n+\n+                                        if (fErrorHandler != null) {\n+                                                fErrorHandler\n+                                                                .handleError(new DOMErrorImpl(\n+                                                                                DOMError.SEVERITY_ERROR, msg,\n+                                                                                MsgKey.ER_NULL_LOCAL_ELEMENT_NAME, null,\n+                                                                                null, null));\n+                                        }\n+\n+                                } else { \/\/ uri=null and no colon\n+                                        \/\/ attr has no namespace URI and no prefix\n+                                        \/\/ no action is required, since attrs don't use default\n+                                }\n+                        }\n+\n+            }\n+\n+\n+            \/\/ discard-default-content=true\n+            \/\/ Default attr's are not passed to the filter and this contraint\n+            \/\/ is applied only when discard-default-content=true\n+            \/\/ What about default xmlns attributes???? check for xmlnsAttr\n+            if ((((fFeatures & DISCARDDEFAULT) != 0) && isSpecified)\n+                || ((fFeatures & DISCARDDEFAULT) == 0)) {\n+                applyFilter = true;\n+            } else {\n+                addAttr = false;\n+            }\n+\n+            if (applyFilter) {\n+                \/\/ apply the filter for Attributes that are not default attributes\n+                \/\/ or namespace decl attributes\n+                if (fFilter != null\n+                    && (fFilter.getWhatToShow() & NodeFilter.SHOW_ATTRIBUTE)\n+                        != 0) {\n+\n+                    if (!xmlnsAttr) {\n+                        short code = fFilter.acceptNode(attr);\n+                        switch (code) {\n+                            case NodeFilter.FILTER_REJECT :\n+                            case NodeFilter.FILTER_SKIP :\n+                                addAttr = false;\n+                                break;\n+                            default : \/\/fall through..\n+                        }\n+                    }\n+                }\n+            }\n+\n+            \/\/ if the node is a namespace node\n+            if (addAttr && xmlnsAttr) {\n+                \/\/ If namespace-declarations=true, add the node , else don't add it\n+                if ((fFeatures & NAMESPACEDECLS) != 0) {\n+                        \/\/ The namespace may have been fixed up, in that case don't add it.\n+                        if (localName != null && !\"\".equals(localName)) {\n+                                fSerializer.addAttribute(attrNS, localName, attrName, type, attrValue);\n+                        }\n+                }\n+            } else if (\n+                addAttr && !xmlnsAttr) { \/\/ if the node is not a namespace node\n+                \/\/ If namespace-declarations=true, add the node with the Attr nodes namespaceURI\n+                \/\/ else add the node setting it's namespace to null or else the serializer will later\n+                \/\/ attempt to add a xmlns attr for the prefixed attribute\n+                if (((fFeatures & NAMESPACEDECLS) != 0) && (attrNS != null)) {\n+                    fSerializer.addAttribute(\n+                        attrNS,\n+                        localName,\n+                        attrName,\n+                        type,\n+                        attrValue);\n+                } else {\n+                    fSerializer.addAttribute(\n+                        \"\",\n+                        localName,\n+                        attrName,\n+                        type,\n+                        attrValue);\n+                }\n+            }\n+\n+            \/\/\n+            if (xmlnsAttr && ((fFeatures & NAMESPACEDECLS) != 0)) {\n+                int index;\n+                \/\/ Use \"\" instead of null, as Xerces likes \"\" for the\n+                \/\/ name of the default namespace.  Fix attributed\n+                \/\/ to \"Steven Murray\" <smurray@ebt.com>.\n+                String prefix =\n+                    (index = attrName.indexOf(\":\")) < 0\n+                        ? \"\"\n+                        : attrName.substring(index + 1);\n+\n+                if (!\"\".equals(prefix)) {\n+                    fSerializer.namespaceAfterStartElement(prefix, attrValue);\n+                }\n+            }\n+        }\n+\n+    }\n+\n+    \/**\n+     * Serializes an ProcessingInstruction Node.\n+     *\n+     * @param node The ProcessingInstruction Node to serialize\n+     *\/\n+    protected void serializePI(ProcessingInstruction node)\n+        throws SAXException {\n+        ProcessingInstruction pi = node;\n+        String name = pi.getNodeName();\n+\n+        \/\/ well-formed=true\n+        if ((fFeatures & WELLFORMED) != 0) {\n+            isPIWellFormed(node);\n+        }\n+\n+        \/\/ apply the LSSerializer filter\n+        if (!applyFilter(node, NodeFilter.SHOW_PROCESSING_INSTRUCTION)) {\n+            return;\n+        }\n+\n+        \/\/ String data = pi.getData();\n+        if (name.equals(\"xslt-next-is-raw\")) {\n+            fNextIsRaw = true;\n+        } else {\n+            this.fSerializer.processingInstruction(name, pi.getData());\n+        }\n+    }\n+\n+    \/**\n+     * Serializes an CDATASection Node.\n+     *\n+     * @param node The CDATASection Node to serialize\n+     *\/\n+    protected void serializeCDATASection(CDATASection node)\n+        throws SAXException {\n+        \/\/ well-formed=true\n+        if ((fFeatures & WELLFORMED) != 0) {\n+            isCDATASectionWellFormed(node);\n+        }\n+\n+        \/\/ cdata-sections = true\n+        if ((fFeatures & CDATA) != 0) {\n+\n+            \/\/ split-cdata-sections = true\n+            \/\/ Assumption: This parameter has an effect only when\n+                        \/\/ cdata-sections=true\n+            \/\/ ToStream, by default splits cdata-sections. Hence the check\n+                        \/\/ below.\n+            String nodeValue = node.getNodeValue();\n+            int endIndex = nodeValue.indexOf(\"]]>\");\n+            if ((fFeatures & SPLITCDATA) != 0) {\n+                if (endIndex >= 0) {\n+                    \/\/ The first node split will contain the ]] markers\n+                    String relatedData = nodeValue.substring(0, endIndex + 2);\n+\n+                    String msg =\n+                        Utils.messages.createMessage(\n+                            MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+                            null);\n+\n+                    if (fErrorHandler != null) {\n+                        fErrorHandler.handleError(\n+                            new DOMErrorImpl(\n+                                DOMError.SEVERITY_WARNING,\n+                                msg,\n+                                MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+                                null,\n+                                relatedData,\n+                                null));\n+                    }\n+                }\n+            } else {\n+                if (endIndex >= 0) {\n+                    \/\/ The first node split will contain the ]] markers\n+                    String relatedData = nodeValue.substring(0, endIndex + 2);\n+\n+                    String msg =\n+                        Utils.messages.createMessage(\n+                            MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+                            null);\n+\n+                    if (fErrorHandler != null) {\n+                        fErrorHandler.handleError(\n+                            new DOMErrorImpl(\n+                                DOMError.SEVERITY_ERROR,\n+                                msg,\n+                                MsgKey.ER_CDATA_SECTIONS_SPLIT));\n+                    }\n+                    \/\/ Report an error and return.  What error???\n+                    return;\n+                }\n+            }\n+\n+            \/\/ apply the LSSerializer filter\n+            if (!applyFilter(node, NodeFilter.SHOW_CDATA_SECTION)) {\n+                return;\n+            }\n+\n+            \/\/ splits the cdata-section\n+            if (fLexicalHandler != null) {\n+                fLexicalHandler.startCDATA();\n+            }\n+            dispatachChars(node);\n+            if (fLexicalHandler != null) {\n+                fLexicalHandler.endCDATA();\n+            }\n+        } else {\n+            dispatachChars(node);\n+        }\n+    }\n+\n+    \/**\n+     * Serializes an Text Node.\n+     *\n+     * @param node The Text Node to serialize\n+     *\/\n+    protected void serializeText(Text node) throws SAXException {\n+        if (fNextIsRaw) {\n+            fNextIsRaw = false;\n+            fSerializer.processingInstruction(\n+                javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING,\n+                \"\");\n+            dispatachChars(node);\n+            fSerializer.processingInstruction(\n+                javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING,\n+                \"\");\n+        } else {\n+            \/\/ keep track of dispatch or not to avoid duplicaiton of filter code\n+            boolean bDispatch = false;\n+\n+            \/\/ well-formed=true\n+            if ((fFeatures & WELLFORMED) != 0) {\n+                isTextWellFormed(node);\n+            }\n+\n+            \/\/ if the node is whitespace\n+            \/\/ Determine the Attr's type.\n+            boolean isElementContentWhitespace = false;\n+            if (fIsLevel3DOM) {\n+                isElementContentWhitespace =\n+                       node.isElementContentWhitespace();\n+            }\n+\n+            if (isElementContentWhitespace) {\n+                \/\/ element-content-whitespace=true\n+                if ((fFeatures & ELEM_CONTENT_WHITESPACE) != 0) {\n+                    bDispatch = true;\n+                }\n+            } else {\n+                bDispatch = true;\n+            }\n+\n+            \/\/ apply the LSSerializer filter\n+            if (!applyFilter(node, NodeFilter.SHOW_TEXT)) {\n+                return;\n+            }\n+\n+            if (bDispatch) {\n+                dispatachChars(node);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Serializes an EntityReference Node.\n+     *\n+     * @param node The EntityReference Node to serialize\n+     * @param bStart Inicates if called from start or endNode\n+     *\/\n+    protected void serializeEntityReference(\n+        EntityReference node,\n+        boolean bStart)\n+        throws SAXException {\n+        if (bStart) {\n+            EntityReference eref = node;\n+            \/\/ entities=true\n+            if ((fFeatures & ENTITIES) != 0) {\n+\n+                \/\/ perform well-formedness and other checking only if\n+                \/\/ entities = true\n+\n+                \/\/ well-formed=true\n+                if ((fFeatures & WELLFORMED) != 0) {\n+                    isEntityReferneceWellFormed(node);\n+                }\n+\n+                \/\/ check \"unbound-prefix-in-entity-reference\" [fatal]\n+                \/\/ Raised if the configuration parameter \"namespaces\" is set to true\n+                if ((fFeatures & NAMESPACES) != 0) {\n+                    checkUnboundPrefixInEntRef(node);\n+                }\n+\n+                \/\/ The filter should not apply in this case, since the\n+                \/\/ EntityReference is not being expanded.\n+                \/\/ should we pass entity reference nodes to the filter???\n+            }\n+\n+            if (fLexicalHandler != null) {\n+\n+                \/\/ startEntity outputs only Text but not Element, Attr, Comment\n+                \/\/ and PI child nodes.  It does so by setting the m_inEntityRef\n+                \/\/ in ToStream and using this to decide if a node is to be\n+                \/\/ serialized or not.\n+                fLexicalHandler.startEntity(eref.getNodeName());\n+            }\n+\n+        } else {\n+            EntityReference eref = node;\n+            \/\/ entities=true or false,\n+            if (fLexicalHandler != null) {\n+                fLexicalHandler.endEntity(eref.getNodeName());\n+            }\n+        }\n+    }\n+\n+\n+    \/\/ ***********************************************************************\n+    \/\/ Methods to check well-formedness\n+    \/\/ ***********************************************************************\n+    \/**\n+     * Taken from org.apache.xerces.dom.CoreDocumentImpl\n+     *\n+     * Check the string against XML's definition of acceptable names for\n+     * elements and attributes and so on using the XMLCharacterProperties\n+     * utility class\n+     *\/\n+    protected boolean isXMLName(String s, boolean xml11Version) {\n+\n+        if (s == null) {\n+            return false;\n+        }\n+        if (!xml11Version)\n+            return XMLChar.isValidName(s);\n+        else\n+            return XML11Char.isXML11ValidName(s);\n+    }\n+\n+    \/**\n+     * Taken from org.apache.xerces.dom.CoreDocumentImpl\n+     *\n+     * Checks if the given qualified name is legal with respect\n+     * to the version of XML to which this document must conform.\n+     *\n+     * @param prefix prefix of qualified name\n+     * @param local local part of qualified name\n+     *\/\n+    protected boolean isValidQName(\n+        String prefix,\n+        String local,\n+        boolean xml11Version) {\n+\n+        \/\/ check that both prefix and local part match NCName\n+        if (local == null)\n+            return false;\n+        boolean validNCName = false;\n+\n+        if (!xml11Version) {\n+            validNCName =\n+                (prefix == null || XMLChar.isValidNCName(prefix))\n+                    && XMLChar.isValidNCName(local);\n+        } else {\n+            validNCName =\n+                (prefix == null || XML11Char.isXML11ValidNCName(prefix))\n+                    && XML11Char.isXML11ValidNCName(local);\n+        }\n+\n+        return validNCName;\n+    }\n+\n+    \/**\n+     * Checks if a XML character is well-formed\n+     *\n+     * @param characters A String of characters to be checked for Well-Formedness\n+     * @param refInvalidChar A reference to the character to be returned that was determined invalid.\n+     *\/\n+    protected boolean isWFXMLChar(String chardata, Character refInvalidChar) {\n+        if (chardata == null || (chardata.length() == 0)) {\n+            return true;\n+        }\n+\n+        char[] dataarray = chardata.toCharArray();\n+        int datalength = dataarray.length;\n+\n+        \/\/ version of the document is XML 1.1\n+        if (fIsXMLVersion11) {\n+            \/\/we need to check all characters as per production rules of XML11\n+            int i = 0;\n+            while (i < datalength) {\n+                if (XML11Char.isXML11Invalid(dataarray[i++])) {\n+                    \/\/ check if this is a supplemental character\n+                    char ch = dataarray[i - 1];\n+                    if (XMLChar.isHighSurrogate(ch) && i < datalength) {\n+                        char ch2 = dataarray[i++];\n+                        if (XMLChar.isLowSurrogate(ch2)\n+                            && XMLChar.isSupplemental(\n+                                XMLChar.supplemental(ch, ch2))) {\n+                            continue;\n+                        }\n+                    }\n+                    \/\/ Reference to invalid character which is returned\n+                    refInvalidChar = new Character(ch);\n+                    return false;\n+                }\n+            }\n+        } \/\/ version of the document is XML 1.0\n+        else {\n+            \/\/ we need to check all characters as per production rules of XML 1.0\n+            int i = 0;\n+            while (i < datalength) {\n+                if (XMLChar.isInvalid(dataarray[i++])) {\n+                    \/\/ check if this is a supplemental character\n+                    char ch = dataarray[i - 1];\n+                    if (XMLChar.isHighSurrogate(ch) && i < datalength) {\n+                        char ch2 = dataarray[i++];\n+                        if (XMLChar.isLowSurrogate(ch2)\n+                            && XMLChar.isSupplemental(\n+                                XMLChar.supplemental(ch, ch2))) {\n+                            continue;\n+                        }\n+                    }\n+                    \/\/ Reference to invalid character which is returned\n+                    refInvalidChar = new Character(ch);\n+                    return false;\n+                }\n+            }\n+        } \/\/ end-else fDocument.isXMLVersion()\n+\n+        return true;\n+    } \/\/ isXMLCharWF\n+\n+    \/**\n+     * Checks if a XML character is well-formed.  If there is a problem with\n+     * the character a non-null Character is returned else null is returned.\n+     *\n+     * @param characters A String of characters to be checked for Well-Formedness\n+     * @return Character A reference to the character to be returned that was determined invalid.\n+     *\/\n+    protected Character isWFXMLChar(String chardata) {\n+        Character refInvalidChar;\n+        if (chardata == null || (chardata.length() == 0)) {\n+            return null;\n+        }\n+\n+        char[] dataarray = chardata.toCharArray();\n+        int datalength = dataarray.length;\n+\n+        \/\/ version of the document is XML 1.1\n+        if (fIsXMLVersion11) {\n+            \/\/we need to check all characters as per production rules of XML11\n+            int i = 0;\n+            while (i < datalength) {\n+                if (XML11Char.isXML11Invalid(dataarray[i++])) {\n+                    \/\/ check if this is a supplemental character\n+                    char ch = dataarray[i - 1];\n+                    if (XMLChar.isHighSurrogate(ch) && i < datalength) {\n+                        char ch2 = dataarray[i++];\n+                        if (XMLChar.isLowSurrogate(ch2)\n+                            && XMLChar.isSupplemental(\n+                                XMLChar.supplemental(ch, ch2))) {\n+                            continue;\n+                        }\n+                    }\n+                    \/\/ Reference to invalid character which is returned\n+                    refInvalidChar = new Character(ch);\n+                    return refInvalidChar;\n+                }\n+            }\n+        } \/\/ version of the document is XML 1.0\n+        else {\n+            \/\/ we need to check all characters as per production rules of XML 1.0\n+            int i = 0;\n+            while (i < datalength) {\n+                if (XMLChar.isInvalid(dataarray[i++])) {\n+                    \/\/ check if this is a supplemental character\n+                    char ch = dataarray[i - 1];\n+                    if (XMLChar.isHighSurrogate(ch) && i < datalength) {\n+                        char ch2 = dataarray[i++];\n+                        if (XMLChar.isLowSurrogate(ch2)\n+                            && XMLChar.isSupplemental(\n+                                XMLChar.supplemental(ch, ch2))) {\n+                            continue;\n+                        }\n+                    }\n+                    \/\/ Reference to invalid character which is returned\n+                    refInvalidChar = new Character(ch);\n+                    return refInvalidChar;\n+                }\n+            }\n+        } \/\/ end-else fDocument.isXMLVersion()\n+\n+        return null;\n+    } \/\/ isXMLCharWF\n+\n+    \/**\n+     * Checks if a comment node is well-formed\n+     *\n+     * @param data The contents of the comment node\n+     * @return a boolean indiacating if the comment is well-formed or not.\n+     *\/\n+    protected void isCommentWellFormed(String data) {\n+        if (data == null || (data.length() == 0)) {\n+            return;\n+        }\n+\n+        char[] dataarray = data.toCharArray();\n+        int datalength = dataarray.length;\n+\n+        \/\/ version of the document is XML 1.1\n+        if (fIsXMLVersion11) {\n+            \/\/ we need to check all chracters as per production rules of XML11\n+            int i = 0;\n+            while (i < datalength) {\n+                char c = dataarray[i++];\n+                if (XML11Char.isXML11Invalid(c)) {\n+                    \/\/ check if this is a supplemental character\n+                    if (XMLChar.isHighSurrogate(c) && i < datalength) {\n+                        char c2 = dataarray[i++];\n+                        if (XMLChar.isLowSurrogate(c2)\n+                            && XMLChar.isSupplemental(\n+                                XMLChar.supplemental(c, c2))) {\n+                            continue;\n+                        }\n+                    }\n+                    String msg =\n+                        Utils.messages.createMessage(\n+                            MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                            new Object[] { new Character(c)});\n+\n+                    if (fErrorHandler != null) {\n+                        fErrorHandler.handleError(\n+                            new DOMErrorImpl(\n+                                DOMError.SEVERITY_FATAL_ERROR,\n+                                msg,\n+                                MsgKey.ER_WF_INVALID_CHARACTER,\n+                                null,\n+                                null,\n+                                null));\n+                    }\n+                } else if (c == '-' && i < datalength && dataarray[i] == '-') {\n+                    String msg =\n+                        Utils.messages.createMessage(\n+                            MsgKey.ER_WF_DASH_IN_COMMENT,\n+                            null);\n+\n+                    if (fErrorHandler != null) {\n+                        fErrorHandler.handleError(\n+                            new DOMErrorImpl(\n+                                DOMError.SEVERITY_FATAL_ERROR,\n+                                msg,\n+                                MsgKey.ER_WF_INVALID_CHARACTER,\n+                                null,\n+                                null,\n+                                null));\n+                    }\n+                }\n+            }\n+        } \/\/ version of the document is XML 1.0\n+        else {\n+            \/\/ we need to check all chracters as per production rules of XML 1.0\n+            int i = 0;\n+            while (i < datalength) {\n+                char c = dataarray[i++];\n+                if (XMLChar.isInvalid(c)) {\n+                    \/\/ check if this is a supplemental character\n+                    if (XMLChar.isHighSurrogate(c) && i < datalength) {\n+                        char c2 = dataarray[i++];\n+                        if (XMLChar.isLowSurrogate(c2)\n+                            && XMLChar.isSupplemental(\n+                                XMLChar.supplemental(c, c2))) {\n+                            continue;\n+                        }\n+                    }\n+                    String msg =\n+                        Utils.messages.createMessage(\n+                            MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                            new Object[] { new Character(c)});\n+\n+                    if (fErrorHandler != null) {\n+                        fErrorHandler.handleError(\n+                            new DOMErrorImpl(\n+                                DOMError.SEVERITY_FATAL_ERROR,\n+                                msg,\n+                                MsgKey.ER_WF_INVALID_CHARACTER,\n+                                null,\n+                                null,\n+                                null));\n+                    }\n+                } else if (c == '-' && i < datalength && dataarray[i] == '-') {\n+                    String msg =\n+                        Utils.messages.createMessage(\n+                            MsgKey.ER_WF_DASH_IN_COMMENT,\n+                            null);\n+\n+                    if (fErrorHandler != null) {\n+                        fErrorHandler.handleError(\n+                            new DOMErrorImpl(\n+                                DOMError.SEVERITY_FATAL_ERROR,\n+                                msg,\n+                                MsgKey.ER_WF_INVALID_CHARACTER,\n+                                null,\n+                                null,\n+                                null));\n+                    }\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    \/**\n+     * Checks if an element node is well-formed, by checking its Name for well-formedness.\n+     *\n+     * @param data The contents of the comment node\n+     * @return a boolean indiacating if the comment is well-formed or not.\n+     *\/\n+    protected void isElementWellFormed(Node node) {\n+        boolean isNameWF = false;\n+        if ((fFeatures & NAMESPACES) != 0) {\n+            isNameWF =\n+                isValidQName(\n+                    node.getPrefix(),\n+                    node.getLocalName(),\n+                    fIsXMLVersion11);\n+        } else {\n+            isNameWF = isXMLName(node.getNodeName(), fIsXMLVersion11);\n+        }\n+\n+        if (!isNameWF) {\n+            String msg =\n+                Utils.messages.createMessage(\n+                    MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                    new Object[] { \"Element\", node.getNodeName()});\n+\n+            if (fErrorHandler != null) {\n+                fErrorHandler.handleError(\n+                    new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR,\n+                        msg,\n+                        MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                        null,\n+                        null,\n+                        null));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Checks if an attr node is well-formed, by checking it's Name and value\n+     * for well-formedness.\n+     *\n+     * @param data The contents of the comment node\n+     * @return a boolean indiacating if the comment is well-formed or not.\n+     *\/\n+    protected void isAttributeWellFormed(Node node) {\n+        boolean isNameWF = false;\n+        if ((fFeatures & NAMESPACES) != 0) {\n+            isNameWF =\n+                isValidQName(\n+                    node.getPrefix(),\n+                    node.getLocalName(),\n+                    fIsXMLVersion11);\n+        } else {\n+            isNameWF = isXMLName(node.getNodeName(), fIsXMLVersion11);\n+        }\n+\n+        if (!isNameWF) {\n+            String msg =\n+                Utils.messages.createMessage(\n+                    MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                    new Object[] { \"Attr\", node.getNodeName()});\n+\n+            if (fErrorHandler != null) {\n+                fErrorHandler.handleError(\n+                    new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR,\n+                        msg,\n+                        MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                        null,\n+                        null,\n+                        null));\n+            }\n+        }\n+\n+        \/\/ Check the Attr's node value\n+        \/\/ WFC: No < in Attribute Values\n+        String value = node.getNodeValue();\n+        if (value.indexOf('<') >= 0) {\n+            String msg =\n+                Utils.messages.createMessage(\n+                    MsgKey.ER_WF_LT_IN_ATTVAL,\n+                    new Object[] {\n+                        ((Attr) node).getOwnerElement().getNodeName(),\n+                        node.getNodeName()});\n+\n+            if (fErrorHandler != null) {\n+                fErrorHandler.handleError(\n+                    new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR,\n+                        msg,\n+                        MsgKey.ER_WF_LT_IN_ATTVAL,\n+                        null,\n+                        null,\n+                        null));\n+            }\n+        }\n+\n+        \/\/ we need to loop through the children of attr nodes and check their values for\n+        \/\/ well-formedness\n+        NodeList children = node.getChildNodes();\n+        for (int i = 0; i < children.getLength(); i++) {\n+            Node child = children.item(i);\n+            \/\/ An attribute node with no text or entity ref child for example\n+            \/\/ doc.createAttributeNS(\"http:\/\/www.w3.org\/2000\/xmlns\/\", \"xmlns:ns\");\n+            \/\/ followes by\n+            \/\/ element.setAttributeNodeNS(attribute);\n+            \/\/ can potentially lead to this situation.  If the attribute\n+            \/\/ was a prefix Namespace attribute declaration then then DOM Core\n+            \/\/ should have some exception defined for this.\n+            if (child == null) {\n+                \/\/ we should probably report an error\n+                continue;\n+            }\n+            switch (child.getNodeType()) {\n+                case Node.TEXT_NODE :\n+                    isTextWellFormed((Text) child);\n+                    break;\n+                case Node.ENTITY_REFERENCE_NODE :\n+                    isEntityReferneceWellFormed((EntityReference) child);\n+                    break;\n+                default :\n+            }\n+        }\n+\n+        \/\/ TODO:\n+        \/\/ WFC: Check if the attribute prefix is bound to\n+        \/\/ http:\/\/www.w3.org\/2000\/xmlns\/\n+\n+        \/\/ WFC: Unique Att Spec\n+        \/\/ Perhaps pass a seen boolean value to this method.  serializeAttList will determine\n+        \/\/ if the attr was seen before.\n+    }\n+\n+    \/**\n+     * Checks if a PI node is well-formed, by checking it's Name and data\n+     * for well-formedness.\n+     *\n+     * @param data The contents of the comment node\n+     *\/\n+    protected void isPIWellFormed(ProcessingInstruction node) {\n+        \/\/ Is the PI Target a valid XML name\n+        if (!isXMLName(node.getNodeName(), fIsXMLVersion11)) {\n+            String msg =\n+                Utils.messages.createMessage(\n+                    MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                    new Object[] { \"ProcessingInstruction\", node.getTarget()});\n+\n+            if (fErrorHandler != null) {\n+                fErrorHandler.handleError(\n+                    new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR,\n+                        msg,\n+                        MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                        null,\n+                        null,\n+                        null));\n+            }\n+        }\n+\n+        \/\/ Does the PI Data carry valid XML characters\n+\n+        \/\/ REVISIT: Should we check if the PI DATA contains a ?> ???\n+        Character invalidChar = isWFXMLChar(node.getData());\n+        if (invalidChar != null) {\n+            String msg =\n+                Utils.messages.createMessage(\n+                    MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                    new Object[] { Integer.toHexString(Character.getNumericValue(invalidChar.charValue())) });\n+\n+            if (fErrorHandler != null) {\n+                fErrorHandler.handleError(\n+                    new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR,\n+                        msg,\n+                        MsgKey.ER_WF_INVALID_CHARACTER,\n+                        null,\n+                        null,\n+                        null));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Checks if an CDATASection node is well-formed, by checking it's data\n+     * for well-formedness.  Note that the presence of a CDATA termination mark\n+     * in the contents of a CDATASection is handled by the parameter\n+     * spli-cdata-sections\n+     *\n+     * @param data The contents of the comment node\n+     *\/\n+    protected void isCDATASectionWellFormed(CDATASection node) {\n+        \/\/ Does the data valid XML character data\n+        Character invalidChar = isWFXMLChar(node.getData());\n+        \/\/if (!isWFXMLChar(node.getData(), invalidChar)) {\n+        if (invalidChar != null) {\n+            String msg =\n+                Utils.messages.createMessage(\n+                    MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                    new Object[] { Integer.toHexString(Character.getNumericValue(invalidChar.charValue())) });\n+\n+            if (fErrorHandler != null) {\n+                fErrorHandler.handleError(\n+                    new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR,\n+                        msg,\n+                        MsgKey.ER_WF_INVALID_CHARACTER,\n+                        null,\n+                        null,\n+                        null));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Checks if an Text node is well-formed, by checking if it contains invalid\n+     * XML characters.\n+     *\n+     * @param data The contents of the comment node\n+     *\/\n+    protected void isTextWellFormed(Text node) {\n+        \/\/ Does the data valid XML character data\n+        Character invalidChar = isWFXMLChar(node.getData());\n+        if (invalidChar != null) {\n+            String msg =\n+                Utils.messages.createMessage(\n+                    MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                    new Object[] { Integer.toHexString(Character.getNumericValue(invalidChar.charValue())) });\n+\n+            if (fErrorHandler != null) {\n+                fErrorHandler.handleError(\n+                    new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR,\n+                        msg,\n+                        MsgKey.ER_WF_INVALID_CHARACTER,\n+                        null,\n+                        null,\n+                        null));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Checks if an EntityRefernece node is well-formed, by checking it's node name.  Then depending\n+     * on whether it is referenced in Element content or in an Attr Node, checks if the EntityReference\n+     * references an unparsed entity or a external entity and if so throws raises the\n+     * appropriate well-formedness error.\n+     *\n+     * @param data The contents of the comment node\n+     * @parent The parent of the EntityReference Node\n+     *\/\n+    protected void isEntityReferneceWellFormed(EntityReference node) {\n+        \/\/ Is the EntityReference name a valid XML name\n+        if (!isXMLName(node.getNodeName(), fIsXMLVersion11)) {\n+            String msg =\n+                Utils.messages.createMessage(\n+                    MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                    new Object[] { \"EntityReference\", node.getNodeName()});\n+\n+            if (fErrorHandler != null) {\n+                fErrorHandler.handleError(\n+                    new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR,\n+                        msg,\n+                        MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                        null,\n+                        null,\n+                        null));\n+            }\n+        }\n+\n+        \/\/ determine the parent node\n+        Node parent = node.getParentNode();\n+\n+        \/\/ Traverse the declared entities and check if the nodeName and namespaceURI\n+        \/\/ of the EntityReference matches an Entity.  If so, check the if the notationName\n+        \/\/ is not null, if so, report an error.\n+        DocumentType docType = node.getOwnerDocument().getDoctype();\n+        if (docType != null) {\n+            NamedNodeMap entities = docType.getEntities();\n+            for (int i = 0; i < entities.getLength(); i++) {\n+                Entity ent = (Entity) entities.item(i);\n+\n+                String nodeName =\n+                    node.getNodeName() == null ? \"\" : node.getNodeName();\n+                String nodeNamespaceURI =\n+                    node.getNamespaceURI() == null\n+                        ? \"\"\n+                        : node.getNamespaceURI();\n+                String entName =\n+                    ent.getNodeName() == null ? \"\" : ent.getNodeName();\n+                String entNamespaceURI =\n+                    ent.getNamespaceURI() == null ? \"\" : ent.getNamespaceURI();\n+                \/\/ If referenced in Element content\n+                \/\/ WFC: Parsed Entity\n+                if (parent.getNodeType() == Node.ELEMENT_NODE) {\n+                    if (entNamespaceURI.equals(nodeNamespaceURI)\n+                        && entName.equals(nodeName)) {\n+\n+                        if (ent.getNotationName() != null) {\n+                            String msg =\n+                                Utils.messages.createMessage(\n+                                    MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                                    new Object[] { node.getNodeName()});\n+\n+                            if (fErrorHandler != null) {\n+                                fErrorHandler.handleError(\n+                                    new DOMErrorImpl(\n+                                        DOMError.SEVERITY_FATAL_ERROR,\n+                                        msg,\n+                                        MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                                        null,\n+                                        null,\n+                                        null));\n+                            }\n+                        }\n+                    }\n+                } \/\/ end if WFC: Parsed Entity\n+\n+                \/\/ If referenced in an Attr value\n+                \/\/ WFC: No External Entity References\n+                if (parent.getNodeType() == Node.ATTRIBUTE_NODE) {\n+                    if (entNamespaceURI.equals(nodeNamespaceURI)\n+                        && entName.equals(nodeName)) {\n+\n+                        if (ent.getPublicId() != null\n+                            || ent.getSystemId() != null\n+                            || ent.getNotationName() != null) {\n+                            String msg =\n+                                Utils.messages.createMessage(\n+                                    MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                                    new Object[] { node.getNodeName()});\n+\n+                            if (fErrorHandler != null) {\n+                                fErrorHandler.handleError(\n+                                    new DOMErrorImpl(\n+                                        DOMError.SEVERITY_FATAL_ERROR,\n+                                        msg,\n+                                        MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                                        null,\n+                                        null,\n+                                        null));\n+                            }\n+                        }\n+                    }\n+                } \/\/end if WFC: No External Entity References\n+            }\n+        }\n+    } \/\/ isEntityReferneceWellFormed\n+\n+    \/**\n+     * If the configuration parameter \"namespaces\" is set to true, this methods\n+     * checks if an entity whose replacement text contains unbound namespace\n+     * prefixes is referenced in a location where there are no bindings for\n+     * the namespace prefixes and if so raises a LSException with the error-type\n+     * \"unbound-prefix-in-entity-reference\"\n+     *\n+     * @param Node, The EntityReference nodes whose children are to be checked\n+     *\/\n+    protected void checkUnboundPrefixInEntRef(Node node) {\n+        Node child, next;\n+        for (child = node.getFirstChild(); child != null; child = next) {\n+            next = child.getNextSibling();\n+\n+            if (child.getNodeType() == Node.ELEMENT_NODE) {\n+\n+                \/\/If a NamespaceURI is not declared for the current\n+                \/\/node's prefix, raise a fatal error.\n+                String prefix = child.getPrefix();\n+                if (prefix != null\n+                                && fNSBinder.getURI(prefix) == null) {\n+                    String msg =\n+                        Utils.messages.createMessage(\n+                            MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                            new Object[] {\n+                                node.getNodeName(),\n+                                child.getNodeName(),\n+                                prefix });\n+\n+                    if (fErrorHandler != null) {\n+                        fErrorHandler.handleError(\n+                            new DOMErrorImpl(\n+                                DOMError.SEVERITY_FATAL_ERROR,\n+                                msg,\n+                                MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                                null,\n+                                null,\n+                                null));\n+                    }\n+                }\n+\n+                NamedNodeMap attrs = child.getAttributes();\n+\n+                for (int i = 0; i < attrs.getLength(); i++) {\n+                    String attrPrefix = attrs.item(i).getPrefix();\n+                    if (attrPrefix != null\n+                                && fNSBinder.getURI(attrPrefix) == null) {\n+                        String msg =\n+                            Utils.messages.createMessage(\n+                                MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                                new Object[] {\n+                                    node.getNodeName(),\n+                                    child.getNodeName(),\n+                                    attrs.item(i)});\n+\n+                        if (fErrorHandler != null) {\n+                            fErrorHandler.handleError(\n+                                new DOMErrorImpl(\n+                                    DOMError.SEVERITY_FATAL_ERROR,\n+                                    msg,\n+                                    MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                                    null,\n+                                    null,\n+                                    null));\n+                        }\n+                    }\n+                }\n+            }\n+\n+            if (child.hasChildNodes()) {\n+                checkUnboundPrefixInEntRef(child);\n+            }\n+        }\n+    }\n+\n+    \/\/ ***********************************************************************\n+    \/\/ Namespace normalization\n+    \/\/ ***********************************************************************\n+    \/**\n+     * Records local namespace declarations, to be used for normalization later\n+     *\n+     * @param Node, The element node, whose namespace declarations are to be recorded\n+     *\/\n+    protected void recordLocalNSDecl(Node node) {\n+        NamedNodeMap atts = ((Element) node).getAttributes();\n+        int length = atts.getLength();\n+\n+        for (int i = 0; i < length; i++) {\n+            Node attr = atts.item(i);\n+\n+            String localName = attr.getLocalName();\n+            String attrPrefix = attr.getPrefix();\n+            String attrValue = attr.getNodeValue();\n+            String attrNS = attr.getNamespaceURI();\n+\n+            localName =\n+                localName == null\n+                    || XMLNS_PREFIX.equals(localName) ? \"\" : localName;\n+            attrPrefix = attrPrefix == null ? \"\" : attrPrefix;\n+            attrValue = attrValue == null ? \"\" : attrValue;\n+            attrNS = attrNS == null ? \"\" : attrNS;\n+\n+            \/\/ check if attribute is a namespace decl\n+            if (XMLNS_URI.equals(attrNS)) {\n+\n+                \/\/ No prefix may be bound to http:\/\/www.w3.org\/2000\/xmlns\/.\n+                if (XMLNS_URI.equals(attrValue)) {\n+                    String msg =\n+                        Utils.messages.createMessage(\n+                            MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                            new Object[] { attrPrefix, XMLNS_URI });\n+\n+                    if (fErrorHandler != null) {\n+                        fErrorHandler.handleError(\n+                            new DOMErrorImpl(\n+                                DOMError.SEVERITY_ERROR,\n+                                msg,\n+                                MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                                null,\n+                                null,\n+                                null));\n+                    }\n+                } else {\n+                    \/\/ store the namespace-declaration\n+                        if (XMLNS_PREFIX.equals(attrPrefix) ) {\n+                        \/\/ record valid decl\n+                        if (attrValue.length() != 0) {\n+                            fNSBinder.declarePrefix(localName, attrValue);\n+                        } else {\n+                            \/\/ Error; xmlns:prefix=\"\"\n+                        }\n+                    } else { \/\/ xmlns\n+                        \/\/ empty prefix is always bound (\"\" or some string)\n+                        fNSBinder.declarePrefix(\"\", attrValue);\n+                    }\n+                }\n+\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Fixes an element's namespace\n+     *\n+     * @param Node, The element node, whose namespace is to be fixed\n+     *\/\n+    protected void fixupElementNS(Node node) throws SAXException {\n+        String namespaceURI = ((Element) node).getNamespaceURI();\n+        String prefix = ((Element) node).getPrefix();\n+        String localName = ((Element) node).getLocalName();\n+\n+        if (namespaceURI != null) {\n+            \/\/if ( Element's prefix\/namespace pair (or default namespace,\n+            \/\/ if no prefix) are within the scope of a binding )\n+            prefix = prefix == null ? \"\" : prefix;\n+            String inScopeNamespaceURI = fNSBinder.getURI(prefix);\n+\n+            if ((inScopeNamespaceURI != null\n+                && inScopeNamespaceURI.equals(namespaceURI))) {\n+                \/\/ do nothing, declaration in scope is inherited\n+\n+            } else {\n+                \/\/ Create a local namespace declaration attr for this namespace,\n+                \/\/ with Element's current prefix (or a default namespace, if\n+                \/\/ no prefix). If there's a conflicting local declaration\n+                \/\/ already present, change its value to use this namespace.\n+\n+                \/\/ Add the xmlns declaration attribute\n+                \/\/fNSBinder.pushNamespace(prefix, namespaceURI, fElementDepth);\n+                if ((fFeatures & NAMESPACEDECLS) != 0) {\n+                    if (\"\".equals(prefix) || \"\".equals(namespaceURI)) {\n+                        ((Element)node).setAttributeNS(XMLNS_URI, XMLNS_PREFIX, namespaceURI);\n+                    } else {\n+                        ((Element)node).setAttributeNS(XMLNS_URI, XMLNS_PREFIX + \":\" + prefix, namespaceURI);\n+                    }\n+                }\n+                fLocalNSBinder.declarePrefix(prefix, namespaceURI);\n+                fNSBinder.declarePrefix(prefix, namespaceURI);\n+\n+            }\n+        } else {\n+            \/\/ Element has no namespace\n+            \/\/ DOM Level 1\n+            if (localName == null || \"\".equals(localName)) {\n+                \/\/  DOM Level 1 node!\n+                String msg =\n+                    Utils.messages.createMessage(\n+                        MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                        new Object[] { node.getNodeName()});\n+\n+                if (fErrorHandler != null) {\n+                    fErrorHandler.handleError(\n+                        new DOMErrorImpl(\n+                            DOMError.SEVERITY_ERROR,\n+                            msg,\n+                            MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                            null,\n+                            null,\n+                            null));\n+                }\n+            } else {\n+                namespaceURI = fNSBinder.getURI(\"\");\n+                if (namespaceURI !=null && namespaceURI.length() > 0) {\n+                    ((Element)node).setAttributeNS(XMLNS_URI, XMLNS_PREFIX, \"\");\n+                        fLocalNSBinder.declarePrefix(\"\", \"\");\n+                    fNSBinder.declarePrefix(\"\", \"\");\n+                }\n+            }\n+        }\n+    }\n+    \/**\n+     * This table is a quick lookup of a property key (String) to the integer that\n+     * is the bit to flip in the fFeatures field, so the integers should have\n+     * values 1,2,4,8,16...\n+     *\n+     *\/\n+    private static final Hashtable s_propKeys = new Hashtable();\n+    static {\n+\n+        \/\/ Initialize the mappings of property keys to bit values (Integer objects)\n+        \/\/ or mappings to a String object \"\", which indicates we are interested\n+        \/\/ in the property, but it does not have a simple bit value to flip\n+\n+        \/\/ cdata-sections\n+        int i = CDATA;\n+        Integer val = new Integer(i);\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS + DOMConstants.DOM_CDATA_SECTIONS,\n+            val);\n+\n+        \/\/ comments\n+        int i1 = COMMENTS;\n+        val = new Integer(i1);\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS + DOMConstants.DOM_COMMENTS,\n+            val);\n+\n+        \/\/ element-content-whitespace\n+        int i2 = ELEM_CONTENT_WHITESPACE;\n+        val = new Integer(i2);\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE,\n+            val);\n+        int i3 = ENTITIES;\n+\n+        \/\/ entities\n+        val = new Integer(i3);\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS + DOMConstants.DOM_ENTITIES,\n+            val);\n+\n+        \/\/ namespaces\n+        int i4 = NAMESPACES;\n+        val = new Integer(i4);\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS + DOMConstants.DOM_NAMESPACES,\n+            val);\n+\n+        \/\/ namespace-declarations\n+        int i5 = NAMESPACEDECLS;\n+        val = new Integer(i5);\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_NAMESPACE_DECLARATIONS,\n+            val);\n+\n+        \/\/ split-cdata-sections\n+        int i6 = SPLITCDATA;\n+        val = new Integer(i6);\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS + DOMConstants.DOM_SPLIT_CDATA,\n+            val);\n+\n+        \/\/ discard-default-content\n+        int i7 = WELLFORMED;\n+        val = new Integer(i7);\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS + DOMConstants.DOM_WELLFORMED,\n+            val);\n+\n+        \/\/ discard-default-content\n+        int i8 = DISCARDDEFAULT;\n+        val = new Integer(i8);\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_DISCARD_DEFAULT_CONTENT,\n+            val);\n+\n+        \/\/ We are interested in these properties, but they don't have a simple\n+        \/\/ bit value to deal with.\n+        s_propKeys.put(\n+            DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_FORMAT_PRETTY_PRINT,\n+            \"\");\n+        s_propKeys.put(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, \"\");\n+        s_propKeys.put(\n+            DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION,\n+            \"\");\n+        s_propKeys.put(DOMConstants.S_XSL_OUTPUT_ENCODING, \"\");\n+        s_propKeys.put(OutputPropertiesFactory.S_KEY_ENTITIES, \"\");\n+    }\n+\n+    \/**\n+     * Initializes fFeatures based on the DOMConfiguration Parameters set.\n+     *\n+     * @param properties DOMConfiguraiton properties that were set and which are\n+     * to be used while serializing the DOM.\n+     *\/\n+    protected void initProperties(Properties properties) {\n+\n+        for (Enumeration keys = properties.keys(); keys.hasMoreElements();) {\n+\n+            final String key = (String) keys.nextElement();\n+\n+            \/\/ caonical-form\n+            \/\/ Other features will be enabled or disabled when this is set to true or false.\n+\n+            \/\/ error-handler; set via the constructor\n+\n+            \/\/ infoset\n+            \/\/ Other features will be enabled or disabled when this is set to true\n+\n+            \/\/ A quick lookup for the given set of properties (cdata-sections ...)\n+            final Object iobj = s_propKeys.get(key);\n+            if (iobj != null) {\n+                if (iobj instanceof Integer) {\n+                    \/\/ Dealing with a property that has a simple bit value that\n+                    \/\/ we need to set\n+\n+                    \/\/ cdata-sections\n+                    \/\/ comments\n+                    \/\/ element-content-whitespace\n+                    \/\/ entities\n+                    \/\/ namespaces\n+                    \/\/ namespace-declarations\n+                    \/\/ split-cdata-sections\n+                    \/\/ well-formed\n+                    \/\/ discard-default-content\n+                    final int BITFLAG = ((Integer) iobj).intValue();\n+                    if ((properties.getProperty(key).endsWith(\"yes\"))) {\n+                        fFeatures = fFeatures | BITFLAG;\n+                    } else {\n+                        fFeatures = fFeatures & ~BITFLAG;\n+                    }\n+                } else {\n+                    \/\/ We are interested in the property, but it is not\n+                    \/\/ a simple bit that we need to set.\n+\n+                    if ((DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_FORMAT_PRETTY_PRINT)\n+                        .equals(key)) {\n+                        \/\/ format-pretty-print; set internally on the serializers via xsl:output properties in LSSerializer\n+                        if ((properties.getProperty(key).endsWith(\"yes\"))) {\n+                            fSerializer.setIndent(true);\n+                            fSerializer.setIndentAmount(4);\n+                        } else {\n+                            fSerializer.setIndent(false);\n+                        }\n+                    } else if (\n+                        (DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL).equals(\n+                            key)) {\n+                        \/\/ omit-xml-declaration; set internally on the serializers via xsl:output properties in LSSerializer\n+                        if ((properties.getProperty(key).endsWith(\"yes\"))) {\n+                            fSerializer.setOmitXMLDeclaration(true);\n+                        } else {\n+                            fSerializer.setOmitXMLDeclaration(false);\n+                        }\n+                    } else if (\n+                        (\n+                            DOMConstants.S_XERCES_PROPERTIES_NS\n+                                + DOMConstants.S_XML_VERSION).equals(\n+                            key)) {\n+                        \/\/ Retreive the value of the XML Version attribute via the xml-version\n+                        String version = properties.getProperty(key);\n+                        if (\"1.1\".equals(version)) {\n+                            fIsXMLVersion11 = true;\n+                            fSerializer.setVersion(version);\n+                        } else {\n+                            fSerializer.setVersion(\"1.0\");\n+                        }\n+                    } else if (\n+                        (DOMConstants.S_XSL_OUTPUT_ENCODING).equals(key)) {\n+                        \/\/ Retreive the value of the XML Encoding attribute\n+                        String encoding = properties.getProperty(key);\n+                        if (encoding != null) {\n+                            fSerializer.setEncoding(encoding);\n+                        }\n+                    } else if ((OutputPropertiesFactory.S_KEY_ENTITIES).equals(key)) {\n+                        \/\/ Retreive the value of the XML Encoding attribute\n+                        String entities = properties.getProperty(key);\n+                        if (DOMConstants.S_XSL_VALUE_ENTITIES.equals(entities)) {\n+                            fSerializer.setDTDEntityExpansion(false);\n+                        }\n+                    } else {\n+                        \/\/ We shouldn't get here, ever, now what?\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Set the newLine character to use\n+        if (fNewLine != null) {\n+            fSerializer.setOutputProperty(OutputPropertiesFactory.S_KEY_LINE_SEPARATOR, fNewLine);\n+        }\n+    }\n+\n+} \/\/TreeWalker\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/DOM3TreeWalker.java","additions":2145,"deletions":0,"binary":false,"changes":2145,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+\n+package com.sun.org.apache.xml.internal.serializer.dom3;\n+\n+\/**\n+ * DOM Constants used by the DOM Level 3 LSSerializer implementation.\n+ *\n+ * @xsl.usage internal\n+ *\/\n+final class DOMConstants {\n+    \/\/\n+    \/\/ Constants: DOM Level 3 feature ids\n+    \/\/\n+    public static final String DOM3_REC_URL = \"http:\/\/www.w3.org\/TR\/DOM-Level-3-LS\";\n+\n+    public static final String XERCES_URL = \"http:\/\/xml.apache.org\/xerces-2j\";\n+\n+    \/\/ The namespace used to qualified DOM Level 3 DOMConfiguration parameters\n+    public static final String S_DOM3_PROPERTIES_NS = \"{\"\n+            + DOMConstants.DOM3_REC_URL + \"}\";\n+\n+    public static final String S_XERCES_PROPERTIES_NS = \"{\"\n+            + DOMConstants.XERCES_URL + \"}\";\n+\n+    \/\/ xmlns namespaces\n+    private static final String XMLNS_URI = \"http:\/\/www.w3.org\/2000\/xmlns\/\";\n+\n+    \/\/ namespace prefix\n+    private static final String XMLNS_PREFIX = \"xmlns\";\n+\n+    \/\/ ************************************************************************\n+    \/\/ DOM Level 3 DOM Configuration parameter names\n+    \/\/ ************************************************************************\n+    \/\/ DOM Level 3 parameters defined in Core\n+    public static final String DOM_CANONICAL_FORM = \"canonical-form\"; \/\/ Unsupported, we only appear to support this\n+\n+    public static final String DOM_CDATA_SECTIONS = \"cdata-sections\";\n+\n+    public static final String DOM_CHECK_CHAR_NORMALIZATION = \"check-character-normalization\"; \/\/ Unsupported\n+\n+    public static final String DOM_COMMENTS = \"comments\";\n+\n+    public static final String DOM_DATATYPE_NORMALIZATION = \"datatype-normalization\"; \/\/ Unsupported\n+\n+    public static final String DOM_ELEMENT_CONTENT_WHITESPACE = \"element-content-whitespace\";\n+\n+    public static final String DOM_ENTITIES = \"entities\";\n+\n+    public static final String DOM_INFOSET = \"infoset\";\n+\n+    public static final String DOM_NAMESPACES = \"namespaces\";\n+\n+    public static final String DOM_NAMESPACE_DECLARATIONS = \"namespace-declarations\";\n+\n+    public static final String DOM_NORMALIZE_CHARACTERS = \"normalize-characters\"; \/\/ Unsupported\n+\n+    public static final String DOM_SPLIT_CDATA = \"split-cdata-sections\";\n+\n+    public static final String DOM_VALIDATE_IF_SCHEMA = \"validate-if-schema\"; \/\/ Unsopported\n+\n+    public static final String DOM_VALIDATE = \"validate\"; \/\/ Unsopported\n+\n+    public static final String DOM_WELLFORMED = \"well-formed\";\n+\n+    \/\/ DOM Level 3 Save\n+    public static final String DOM_DISCARD_DEFAULT_CONTENT = \"discard-default-content\";\n+\n+    public static final String DOM_FORMAT_PRETTY_PRINT = \"format-pretty-print\";\n+\n+    public static final String DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS = \"ignore-unknown-character-denormalizations\"; \/\/ Unsupported\n+\n+    public static final String DOM_XMLDECL = \"xml-declaration\";\n+\n+    \/\/ DOM Properties\n+    public static final String DOM_ERROR_HANDLER = \"error-handler\";\n+\n+    public static final String DOM_SCHEMA_TYPE = \"schema-type\"; \/\/ Unsupported\n+\n+    public static final String DOM_SCHEMA_LOCATION = \"schema-location\"; \/\/ Unsupported\n+\n+    \/\/ ************************************************************************\n+\n+    \/\/ XSL Output properties\n+    \/\/ The xsl:output 'indent' property used in LSSerializer\n+    public static final String S_XSL_OUTPUT_INDENT = \"indent\";\n+\n+    \/\/ The xsl:output 'indent' property used in LSSerializer\n+    public static final String S_XSL_OUTPUT_ENCODING = \"encoding\";\n+\n+    \/\/ The xsl:output 'omit-xml-declaration' property used in LSSerializer\n+    public static final String S_XSL_OUTPUT_OMIT_XML_DECL = \"omit-xml-declaration\";\n+\n+    \/\/ The xerces serializer specific 'omit-xml-declaration' property used in LSSerializer\n+    public static final String S_XML_VERSION = \"xml-version\";\n+\n+    \/\/\n+    public static final String S_XSL_VALUE_ENTITIES = \"com\/sun\/org\/apache\/xml\/internal\/serializer\/XMLEntities\";\n+\n+    \/\/ Parameter values\n+    public static final String DOM3_EXPLICIT_TRUE = \"explicit:yes\";\n+\n+    public static final String DOM3_DEFAULT_TRUE = \"default:yes\";\n+\n+    public static final String DOM3_EXPLICIT_FALSE = \"explicit:no\";\n+\n+    public static final String DOM3_DEFAULT_FALSE = \"default:no\";\n+\n+    \/\/ DOM Exceptions\n+    public static final String DOM_EXCEPTION_FEATURE_NOT_FOUND = \"FEATURE_NOT_FOUND\";\n+\n+    public static final String DOM_EXCEPTION_FEATURE_NOT_SUPPORTED = \"FEATURE_NOT_SUPPORTED\";\n+\n+    public static final String DOM_LSEXCEPTION_SERIALIZER_ERR = \"SERIALIZER_ERROR\";\n+\n+}\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/DOMConstants.java","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+\n+package com.sun.org.apache.xml.internal.serializer.dom3;\n+\n+import org.w3c.dom.DOMError;\n+import org.w3c.dom.DOMErrorHandler;\n+\n+\/**\n+ * This is the default implementation of the ErrorHandler interface and is\n+ * used if one is not provided.  The default implementation simply reports\n+ * DOMErrors to System.err.\n+ *\n+ * @xsl.usage internal\n+ *\/\n+final class DOMErrorHandlerImpl implements DOMErrorHandler {\n+\n+    \/**\n+     * Default Constructor\n+     *\/\n+    DOMErrorHandlerImpl() {\n+    }\n+\n+    \/**\n+     * Implementation of DOMErrorHandler.handleError that\n+     * adds copy of error to list for later retrieval.\n+     *\n+     *\/\n+    public boolean handleError(DOMError error) {\n+        boolean fail = true;\n+        String severity = null;\n+        if (error.getSeverity() == DOMError.SEVERITY_WARNING) {\n+            fail = false;\n+            severity = \"[Warning]\";\n+        } else if (error.getSeverity() == DOMError.SEVERITY_ERROR) {\n+            severity = \"[Error]\";\n+        } else if (error.getSeverity() == DOMError.SEVERITY_FATAL_ERROR) {\n+            severity = \"[Fatal Error]\";\n+        }\n+\n+        System.err.println(severity + \": \" + error.getMessage() + \"\\t\");\n+        System.err.println(\"Type : \" + error.getType() + \"\\t\" + \"Related Data: \"\n+                + error.getRelatedData() + \"\\t\" + \"Related Exception: \"\n+                + error.getRelatedException() );\n+\n+        return fail;\n+    }\n+}\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/DOMErrorHandlerImpl.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+\n+package com.sun.org.apache.xml.internal.serializer.dom3;\n+\n+import org.w3c.dom.DOMError;\n+import org.w3c.dom.DOMLocator;\n+\n+\/**\n+ * Implementation of the DOM Level 3 DOMError interface.\n+ *\n+ * <p>See also the <a href='http:\/\/www.w3.org\/TR\/2004\/REC-DOM-Level-3-Core-20040407\/core.html#ERROR-Interfaces-DOMError'>DOMError Interface definition from Document Object Model (DOM) Level 3 Core Specification<\/a>.\n+ *\n+ * @xsl.usage internal\n+ *\/\n+\n+final class DOMErrorImpl implements DOMError {\n+\n+    \/** private data members *\/\n+\n+    \/\/ The DOMError Severity\n+    private short fSeverity = DOMError.SEVERITY_WARNING;\n+\n+    \/\/ The Error message\n+    private String fMessage = null;\n+\n+    \/\/  A String indicating which related data is expected in relatedData.\n+    private String fType;\n+\n+    \/\/ The platform related exception\n+    private Exception fException = null;\n+\n+    \/\/\n+    private Object fRelatedData;\n+\n+    \/\/ The location of the exception\n+    private DOMLocatorImpl fLocation = new DOMLocatorImpl();\n+\n+\n+    \/\/\n+    \/\/ Constructors\n+    \/\/\n+\n+    \/**\n+     * Default constructor.\n+     *\/\n+    DOMErrorImpl () {\n+    }\n+\n+    \/**\n+     * @param severity\n+     * @param message\n+     * @param type\n+     *\/\n+    DOMErrorImpl(short severity, String message, String type) {\n+        fSeverity = severity;\n+        fMessage = message;\n+        fType = type;\n+    }\n+\n+    \/**\n+     * @param severity\n+     * @param message\n+     * @param type\n+     * @param exception\n+     *\/\n+    DOMErrorImpl(short severity, String message, String type,\n+            Exception exception) {\n+        fSeverity = severity;\n+        fMessage = message;\n+        fType = type;\n+        fException = exception;\n+    }\n+\n+    \/**\n+     * @param severity\n+     * @param message\n+     * @param type\n+     * @param exception\n+     * @param relatedData\n+     * @param location\n+     *\/\n+    DOMErrorImpl(short severity, String message, String type,\n+            Exception exception, Object relatedData, DOMLocatorImpl location) {\n+        fSeverity = severity;\n+        fMessage = message;\n+        fType = type;\n+        fException = exception;\n+        fRelatedData = relatedData;\n+        fLocation = location;\n+    }\n+\n+\n+    \/**\n+     * The severity of the error, either <code>SEVERITY_WARNING<\/code>,\n+     * <code>SEVERITY_ERROR<\/code>, or <code>SEVERITY_FATAL_ERROR<\/code>.\n+     *\n+     * @return A short containing the DOMError severity\n+     *\/\n+    public short getSeverity() {\n+        return fSeverity;\n+    }\n+\n+    \/**\n+     * The DOMError message string.\n+     *\n+     * @return String\n+     *\/\n+    public String getMessage() {\n+        return fMessage;\n+    }\n+\n+    \/**\n+     * The location of the DOMError.\n+     *\n+     * @return A DOMLocator object containing the DOMError location.\n+     *\/\n+    public DOMLocator getLocation() {\n+        return fLocation;\n+    }\n+\n+    \/**\n+     * The related platform dependent exception if any.\n+     *\n+     * @return A java.lang.Exception\n+     *\/\n+    public Object getRelatedException(){\n+        return fException;\n+    }\n+\n+    \/**\n+     * Returns a String indicating which related data is expected in relatedData.\n+     *\n+     * @return A String\n+     *\/\n+    public String getType(){\n+        return fType;\n+    }\n+\n+    \/**\n+     * The related DOMError.type dependent data if any.\n+     *\n+     * @return java.lang.Object\n+     *\/\n+    public Object getRelatedData(){\n+        return fRelatedData;\n+    }\n+\n+    public void reset(){\n+        fSeverity = DOMError.SEVERITY_WARNING;\n+        fException = null;\n+        fMessage = null;\n+        fType = null;\n+        fRelatedData = null;\n+        fLocation = null;\n+    }\n+\n+}\/\/ class DOMErrorImpl\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/DOMErrorImpl.java","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+\n+package com.sun.org.apache.xml.internal.serializer.dom3;\n+\n+import org.w3c.dom.DOMLocator;\n+import org.w3c.dom.Node;\n+\n+\n+\/**\n+ * <code>DOMLocatorImpl<\/code> is an implementaion that describes a location (e.g.\n+ * where an error occured).\n+ * <p>See also the <a href='http:\/\/www.w3.org\/TR\/2004\/REC-DOM-Level-3-Core-20040407'>Document Object Model (DOM) Level 3 Core Specification<\/a>.\n+ * This class is a copy of the Xerces-2J class org.apache.xerces.dom.DOMLocatorImpl.java v 1.10\n+ *\n+ * @author Gopal Sharma, SUN Microsystems Inc.\n+ * @version $Id:\n+ *\n+ * @xsl.usage internal\n+ *\/\n+final class DOMLocatorImpl implements DOMLocator {\n+\n+    \/\/\n+    \/\/ Data\n+    \/\/\n+\n+    \/**\n+     * The column number where the error occured,\n+     * or -1 if there is no column number available.\n+     *\/\n+    private final int fColumnNumber;\n+\n+    \/**\n+     * The line number where the error occured,\n+     * or -1 if there is no line number available.\n+     *\/\n+    private final int fLineNumber;\n+\n+    \/** related data node*\/\n+    private final Node fRelatedNode;\n+\n+    \/**\n+     * The URI where the error occured,\n+     * or null if there is no URI available.\n+     *\/\n+    private final String fUri;\n+\n+    \/**\n+     * The byte offset into the input source this locator is pointing to or -1\n+     * if there is no byte offset available\n+     *\/\n+    private final int fByteOffset;\n+\n+    \/**\n+     * The UTF-16, as defined in [Unicode] and Amendment 1 of [ISO\/IEC 10646],\n+     * offset into the input source this locator is pointing to or -1 if there\n+     * is no UTF-16 offset available.\n+     *\/\n+    private final int fUtf16Offset;\n+\n+    \/\/\n+    \/\/ Constructors\n+    \/\/\n+\n+    DOMLocatorImpl(){\n+        fColumnNumber = -1;\n+        fLineNumber = -1;\n+        fRelatedNode = null;\n+        fUri = null;\n+        fByteOffset = -1;\n+        fUtf16Offset = -1;\n+    }\n+\n+    DOMLocatorImpl (int lineNumber, int columnNumber, String uri ){\n+        fLineNumber = lineNumber ;\n+        fColumnNumber = columnNumber ;\n+        fUri = uri;\n+\n+        fRelatedNode = null;\n+        fByteOffset = -1;\n+        fUtf16Offset = -1;\n+    } \/\/ DOMLocatorImpl (int lineNumber, int columnNumber, String uri )\n+\n+    DOMLocatorImpl (int lineNumber, int columnNumber, int utf16Offset, String uri ){\n+        fLineNumber = lineNumber ;\n+        fColumnNumber = columnNumber ;\n+        fUri = uri;\n+        fUtf16Offset = utf16Offset;\n+\n+\n+        fRelatedNode = null;\n+        fByteOffset = -1;\n+    } \/\/ DOMLocatorImpl (int lineNumber, int columnNumber, int utf16Offset, String uri )\n+\n+    DOMLocatorImpl (int lineNumber, int columnNumber, int byteoffset, Node relatedData, String uri ){\n+        fLineNumber = lineNumber ;\n+        fColumnNumber = columnNumber ;\n+        fByteOffset = byteoffset ;\n+        fRelatedNode = relatedData ;\n+        fUri = uri;\n+\n+        fUtf16Offset = -1;\n+    } \/\/ DOMLocatorImpl (int lineNumber, int columnNumber, int offset, Node errorNode, String uri )\n+\n+    DOMLocatorImpl (int lineNumber, int columnNumber, int byteoffset, Node relatedData, String uri, int utf16Offset ){\n+        fLineNumber = lineNumber ;\n+        fColumnNumber = columnNumber ;\n+        fByteOffset = byteoffset ;\n+        fRelatedNode = relatedData ;\n+        fUri = uri;\n+        fUtf16Offset = utf16Offset;\n+    } \/\/ DOMLocatorImpl (int lineNumber, int columnNumber, int offset, Node errorNode, String uri )\n+\n+\n+    \/**\n+     * The line number where the error occured, or -1 if there is no line\n+     * number available.\n+     *\/\n+    public int getLineNumber(){\n+        return fLineNumber;\n+    }\n+\n+    \/**\n+     * The column number where the error occured, or -1 if there is no column\n+     * number available.\n+     *\/\n+    public int getColumnNumber(){\n+        return fColumnNumber;\n+    }\n+\n+\n+    \/**\n+     * The URI where the error occured, or null if there is no URI available.\n+     *\/\n+    public String getUri(){\n+        return fUri;\n+    }\n+\n+\n+    public Node getRelatedNode(){\n+        return fRelatedNode;\n+    }\n+\n+\n+    \/**\n+     * The byte offset into the input source this locator is pointing to or -1\n+     * if there is no byte offset available\n+     *\/\n+    public int getByteOffset(){\n+        return fByteOffset;\n+    }\n+\n+    \/**\n+     * The UTF-16, as defined in [Unicode] and Amendment 1 of [ISO\/IEC 10646],\n+     * offset into the input source this locator is pointing to or -1 if there\n+     * is no UTF-16 offset available.\n+     *\/\n+    public int getUtf16Offset(){\n+        return fUtf16Offset;\n+    }\n+\n+}\/\/ class DOMLocatorImpl\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/DOMLocatorImpl.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,177 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+\n+package org.apache.xml.serializer.dom3;\n+\n+import org.w3c.dom.ls.LSOutput;\n+\n+import java.io.Writer;\n+import java.io.OutputStream;\n+\n+\/**\n+ * This is a copy of the Xerces-2J class org.apache.xerces.dom.DOMOutputImpl.java\n+ *\n+ * This class represents an output destination for data.\n+ * This interface allows an application to encapsulate information about an\n+ * output destination in a single object, which may include a URI, a byte stream\n+ * (possibly with a specifiedencoding), a base URI, and\/or a character stream.\n+ * The exact definitions of a byte stream and a character stream are binding\n+ * dependent.\n+ * The application is expected to provide objects that implement this interface\n+ * whenever such objects are needed. The application can either provide its\n+ * own objects that implement this interface, or it can use the generic factory\n+ * method DOMImplementationLS.createLSOutput() to create objects that\n+ * implement this interface.\n+ * The DOMSerializer will use the LSOutput object to determine where to\n+ * serialize the output to. The DOMSerializer will look at the different\n+ * outputs specified in the LSOutput in the following order to know which one\n+ * to output to, the first one that data can be output to will be used:\n+ * 1.LSOutput.characterStream\n+ * 2.LSOutput.byteStream\n+ * 3.LSOutput.systemId\n+ * LSOutput objects belong to the application. The DOM implementation will\n+ * never modify them (though it may make copies and modify the copies,\n+ * if necessary).\n+ *\n+ *\n+ * @author Arun Yadav, Sun Microsytems\n+ * @author Gopal Sharma, Sun Microsystems\n+ * @version $Id :\n+ * @xsl.usage internal\n+ *\/\n+\n+final class DOMOutputImpl implements LSOutput {\n+\n+    private Writer fCharStream = null;\n+    private OutputStream fByteStream = null;\n+    private String fSystemId = null;\n+    private String fEncoding = null;\n+\n+    \/**\n+     * Default Constructor\n+     *\/\n+    DOMOutputImpl() {}\n+\n+    \/**\n+     * An attribute of a language and binding dependent type that represents a\n+     * writable stream of bytes. If the application knows the character encoding\n+     * of the byte stream, it should set the encoding attribute. Setting the\n+     * encoding in this way will override any encoding specified in an XML\n+     * declaration in the data.\n+     *\/\n+\n+    public Writer getCharacterStream(){\n+        return fCharStream;\n+    };\n+\n+    \/**\n+     * An attribute of a language and binding dependent type that represents a\n+     * writable stream of bytes. If the application knows the character encoding\n+     * of the byte stream, it should set the encoding attribute. Setting the\n+     * encoding in this way will override any encoding specified in an XML\n+     * declaration in the data.\n+     *\/\n+\n+    public void setCharacterStream(Writer characterStream){\n+        fCharStream = characterStream;\n+    };\n+\n+    \/**\n+     * Depending on the language binding in use, this attribute may not be\n+     * available. An attribute of a language and binding dependent type that\n+     * represents a writable stream to which 16-bit units can be output. The\n+     * application must encode the stream using UTF-16 (defined in [Unicode] and\n+     *  Amendment 1 of [ISO\/IEC 10646]).\n+     *\/\n+\n+    public OutputStream getByteStream(){\n+        return fByteStream;\n+    };\n+\n+    \/**\n+     * Depending on the language binding in use, this attribute may not be\n+     * available. An attribute of a language and binding dependent type that\n+     * represents a writable stream to which 16-bit units can be output. The\n+     * application must encode the stream using UTF-16 (defined in [Unicode] and\n+     *  Amendment 1 of [ISO\/IEC 10646]).\n+     *\/\n+\n+    public void setByteStream(OutputStream byteStream){\n+        fByteStream = byteStream;\n+    };\n+\n+    \/**\n+     * The system identifier, a URI reference [IETF RFC 2396], for this output\n+     *  destination. If the application knows the character encoding of the\n+     *  object pointed to by the system identifier, it can set the encoding\n+     *  using the encoding attribute. If the system ID is a relative URI\n+     *  reference (see section 5 in [IETF RFC 2396]), the behavior is\n+     *  implementation dependent.\n+     *\/\n+\n+    public String getSystemId(){\n+        return fSystemId;\n+    };\n+\n+    \/**\n+     * The system identifier, a URI reference [IETF RFC 2396], for this output\n+     *  destination. If the application knows the character encoding of the\n+     *  object pointed to by the system identifier, it can set the encoding\n+     *  using the encoding attribute. If the system ID is a relative URI\n+     *  reference (see section 5 in [IETF RFC 2396]), the behavior is\n+     *  implementation dependent.\n+     *\/\n+\n+    public void setSystemId(String systemId){\n+        fSystemId = systemId;\n+    };\n+\n+    \/**\n+     * The character encoding, if known. The encoding must be a string\n+     * acceptable for an XML encoding declaration ([XML 1.0] section 4.3.3\n+     * \"Character Encoding in Entities\"). This attribute has no effect when the\n+     * application provides a character stream or string data. For other sources\n+     * of input, an encoding specified by means of this attribute will override\n+     * any encoding specified in the XML declaration or the Text declaration, or\n+     * an encoding obtained from a higher level protocol, such as HTTP\n+     * [IETF RFC 2616].\n+     *\/\n+\n+    public String getEncoding(){\n+        return fEncoding;\n+    };\n+\n+    \/**\n+     * The character encoding, if known. The encoding must be a string\n+     * acceptable for an XML encoding declaration ([XML 1.0] section 4.3.3\n+     * \"Character Encoding in Entities\"). This attribute has no effect when the\n+     * application provides a character stream or string data. For other sources\n+     * of input, an encoding specified by means of this attribute will override\n+     * any encoding specified in the XML declaration or the Text declaration, or\n+     * an encoding obtained from a higher level protocol, such as HTTP\n+     * [IETF RFC 2616].\n+     *\/\n+\n+    public void setEncoding(String encoding){\n+        fEncoding = encoding;\n+    };\n+\n+}\/\/DOMOutputImpl\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/DOMOutputImpl.java","additions":177,"deletions":0,"binary":false,"changes":177,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+package com.sun.org.apache.xml.internal.serializer.dom3;\n+\n+import java.util.Vector;\n+\n+\/\/import org.apache.xerces.dom3.DOMStringList;\n+import org.w3c.dom.DOMStringList;\n+\n+\/**\n+ * This class implemets the DOM Level 3 Core interface DOMStringList.\n+ *\n+ * @xsl.usage internal\n+ *\/\n+final class DOMStringListImpl implements DOMStringList {\n+\n+    \/\/A collection of DOMString values\n+    private Vector fStrings;\n+\n+    \/**\n+     * Construct an empty list of DOMStringListImpl\n+     *\/\n+    DOMStringListImpl() {\n+        fStrings = new Vector();\n+    }\n+\n+    \/**\n+     * Construct an empty list of DOMStringListImpl\n+     *\/\n+    DOMStringListImpl(Vector params) {\n+        fStrings = params;\n+    }\n+\n+    \/**\n+     * Construct an empty list of DOMStringListImpl\n+     *\/\n+    DOMStringListImpl(String[] params ) {\n+        fStrings = new Vector();\n+        if (params != null) {\n+            for (int i=0; i < params.length; i++) {\n+                fStrings.add(params[i]);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * @see org.apache.xerces.dom3.DOMStringList#item(int)\n+     *\/\n+    public String item(int index) {\n+        try {\n+            return (String) fStrings.elementAt(index);\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * @see org.apache.xerces.dom3.DOMStringList#getLength()\n+     *\/\n+    public int getLength() {\n+        return fStrings.size();\n+    }\n+\n+    \/**\n+     * @see org.apache.xerces.dom3.DOMStringList#contains(String)\n+     *\/\n+    public boolean contains(String param) {\n+        return fStrings.contains(param) ;\n+    }\n+\n+    \/**\n+     * DOM Internal:\n+     * Add a <code>DOMString<\/code> to the list.\n+     *\n+     * @param domString A string to add to the list\n+     *\/\n+    public void add(String param) {\n+        fStrings.add(param);\n+    }\n+\n+}\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/DOMStringListImpl.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,1405 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+\n+package com.sun.org.apache.xml.internal.serializer.dom3;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.StringWriter;\n+import java.io.UnsupportedEncodingException;\n+import java.io.Writer;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.net.URLConnection;\n+import java.util.Properties;\n+\n+import com.sun.org.apache.xml.internal.serializer.DOM3Serializer;\n+import com.sun.org.apache.xml.internal.serializer.Encodings;\n+import com.sun.org.apache.xml.internal.serializer.Serializer;\n+import com.sun.org.apache.xml.internal.serializer.OutputPropertiesFactory;\n+import com.sun.org.apache.xml.internal.serializer.SerializerFactory;\n+import com.sun.org.apache.xml.internal.serializer.utils.MsgKey;\n+import com.sun.org.apache.xml.internal.serializer.utils.Utils;\n+import com.sun.org.apache.xml.internal.serializer.utils.SystemIDResolver;\n+import org.w3c.dom.DOMConfiguration;\n+import org.w3c.dom.DOMError;\n+import org.w3c.dom.DOMErrorHandler;\n+import org.w3c.dom.DOMException;\n+import org.w3c.dom.DOMStringList;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.ls.LSException;\n+import org.w3c.dom.ls.LSOutput;\n+import org.w3c.dom.ls.LSSerializer;\n+import org.w3c.dom.ls.LSSerializerFilter;\n+\n+\n+\/**\n+ * Implemenatation of DOM Level 3 org.w3c.ls.LSSerializer and\n+ * org.w3c.dom.ls.DOMConfiguration.  Serialization is achieved by delegating\n+ * serialization calls to <CODE>org.apache.xml.serializer.ToStream<\/CODE> or\n+ * one of its derived classes depending on the serialization method, while walking\n+ * the DOM in DOM3TreeWalker.\n+ * @see <a href=\"http:\/\/www.w3.org\/TR\/2004\/REC-DOM-Level-3-LS-20040407\/load-save.html#LS-LSSerializer\">org.w3c.dom.ls.LSSerializer<\/a>\n+ * @see <a href=\"http:\/\/www.w3.org\/TR\/2004\/REC-DOM-Level-3-Core-20040407\/core.html#DOMConfiguration\">org.w3c.dom.DOMConfiguration<\/a>\n+ *\n+ * @version $Id:\n+ *\n+ * @xsl.usage internal\n+ *\/\n+final public class LSSerializerImpl implements DOMConfiguration, LSSerializer {\n+\n+    \/** private data members *\/\n+    private Serializer fXMLSerializer = null;\n+\n+    \/\/ Tracks DOMConfiguration features.\n+    protected int fFeatures = 0;\n+\n+    \/\/ Common DOM serializer\n+    private  DOM3Serializer fDOMSerializer = null;\n+\n+    \/\/ A filter set on the LSSerializer\n+    private LSSerializerFilter fSerializerFilter = null;\n+\n+    \/\/ Stores the nodeArg parameter to speed up multiple writes of the same node.\n+    private Node fVisitedNode = null;\n+\n+    \/\/ The end-of-line character sequence used in serialization.  \"\\n\" is whats used on the web.\n+    private String fEndOfLine = \"\\n\";\n+\n+    \/\/ The DOMErrorhandler.\n+    private DOMErrorHandler fDOMErrorHandler = null;\n+\n+    \/\/ The Configuration parameter to pass to the Underlying serilaizer.\n+    private Properties fDOMConfigProperties = null;\n+\n+    \/\/ The encoding to use during serialization.\n+    private String fEncoding;\n+\n+    \/\/ ************************************************************************\n+    \/\/ DOM Level 3 DOM Configuration parameter names\n+    \/\/ ************************************************************************\n+    \/\/ Parameter canonical-form, true [optional] - NOT SUPPORTED\n+    private final static int CANONICAL = 0x1 << 0;\n+\n+    \/\/ Parameter cdata-sections, true [required] (default)\n+    private final static int CDATA = 0x1 << 1;\n+\n+    \/\/ Parameter check-character-normalization, true [optional] - NOT SUPPORTED\n+    private final static int CHARNORMALIZE = 0x1 << 2;\n+\n+    \/\/ Parameter comments, true [required] (default)\n+    private final static int COMMENTS = 0x1 << 3;\n+\n+    \/\/ Parameter datatype-normalization, true [optional] - NOT SUPPORTED\n+    private final static int DTNORMALIZE = 0x1 << 4;\n+\n+    \/\/ Parameter element-content-whitespace, true [required] (default) - value - false [optional] NOT SUPPORTED\n+    private final static int ELEM_CONTENT_WHITESPACE = 0x1 << 5;\n+\n+    \/\/ Parameter entities, true [required] (default)\n+    private final static int ENTITIES = 0x1 << 6;\n+\n+    \/\/ Parameter infoset, true [required] (default), false has no effect --> True has no effect for the serializer\n+    private final static int INFOSET = 0x1 << 7;\n+\n+    \/\/ Parameter namespaces, true [required] (default)\n+    private final static int NAMESPACES = 0x1 << 8;\n+\n+    \/\/ Parameter namespace-declarations, true [required] (default)\n+    private final static int NAMESPACEDECLS = 0x1 << 9;\n+\n+    \/\/ Parameter normalize-characters, true [optional] - NOT SUPPORTED\n+    private final static int NORMALIZECHARS = 0x1 << 10;\n+\n+    \/\/ Parameter split-cdata-sections, true [required] (default)\n+    private final static int SPLITCDATA = 0x1 << 11;\n+\n+    \/\/ Parameter validate, true [optional] - NOT SUPPORTED\n+    private final static int VALIDATE = 0x1 << 12;\n+\n+    \/\/ Parameter validate-if-schema, true [optional] - NOT SUPPORTED\n+    private final static int SCHEMAVALIDATE = 0x1 << 13;\n+\n+    \/\/ Parameter split-cdata-sections, true [required] (default)\n+    private final static int WELLFORMED = 0x1 << 14;\n+\n+    \/\/ Parameter discard-default-content, true [required] (default)\n+    \/\/ Not sure how this will be used in level 2 Documents\n+    private final static int DISCARDDEFAULT = 0x1 << 15;\n+\n+    \/\/ Parameter format-pretty-print, true [optional]\n+    private final static int PRETTY_PRINT = 0x1 << 16;\n+\n+    \/\/ Parameter ignore-unknown-character-denormalizations, true [required] (default)\n+    \/\/ We currently do not support XML 1.1 character normalization\n+    private final static int IGNORE_CHAR_DENORMALIZE = 0x1 << 17;\n+\n+    \/\/ Parameter discard-default-content, true [required] (default)\n+    private final static int XMLDECL = 0x1 << 18;\n+    \/\/ ************************************************************************\n+\n+    \/\/ Recognized parameters for which atleast one value can be set\n+    private String fRecognizedParameters [] = {\n+            DOMConstants.DOM_CANONICAL_FORM,\n+            DOMConstants.DOM_CDATA_SECTIONS,\n+            DOMConstants.DOM_CHECK_CHAR_NORMALIZATION,\n+            DOMConstants.DOM_COMMENTS,\n+            DOMConstants.DOM_DATATYPE_NORMALIZATION,\n+            DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE,\n+            DOMConstants.DOM_ENTITIES,\n+            DOMConstants.DOM_INFOSET,\n+            DOMConstants.DOM_NAMESPACES,\n+            DOMConstants.DOM_NAMESPACE_DECLARATIONS,\n+            \/\/DOMConstants.DOM_NORMALIZE_CHARACTERS,\n+            DOMConstants.DOM_SPLIT_CDATA,\n+            DOMConstants.DOM_VALIDATE,\n+            DOMConstants.DOM_VALIDATE_IF_SCHEMA,\n+            DOMConstants.DOM_WELLFORMED,\n+            DOMConstants.DOM_DISCARD_DEFAULT_CONTENT,\n+            DOMConstants.DOM_FORMAT_PRETTY_PRINT,\n+            DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS,\n+            DOMConstants.DOM_XMLDECL,\n+            DOMConstants.DOM_ERROR_HANDLER\n+    };\n+\n+\n+    \/**\n+     * Constructor:  Creates a LSSerializerImpl object.  The underlying\n+     * XML 1.0 or XML 1.1 org.apache.xml.serializer.Serializer object is\n+     * created and initialized the first time any of the write methods are\n+     * invoked to serialize the Node.  Subsequent write methods on the same\n+     * LSSerializerImpl object will use the previously created Serializer object.\n+     *\/\n+    public LSSerializerImpl () {\n+        \/\/ set default parameters\n+        fFeatures |= CDATA;\n+        fFeatures |= COMMENTS;\n+        fFeatures |= ELEM_CONTENT_WHITESPACE;\n+        fFeatures |= ENTITIES;\n+        fFeatures |= NAMESPACES;\n+        fFeatures |= NAMESPACEDECLS;\n+        fFeatures |= SPLITCDATA;\n+        fFeatures |= WELLFORMED;\n+        fFeatures |= DISCARDDEFAULT;\n+        fFeatures |= XMLDECL;\n+\n+        \/\/ New OutputFormat properties\n+        fDOMConfigProperties = new Properties();\n+\n+        \/\/ Initialize properties to be passed on the underlying serializer\n+        initializeSerializerProps();\n+\n+        \/\/ Read output_xml.properties and System Properties to initialize properties\n+        Properties  configProps = OutputPropertiesFactory.getDefaultMethodProperties(\"xml\");\n+\n+        \/\/ change xml version from 1.0 to 1.1\n+        \/\/configProps.setProperty(\"version\", \"1.1\");\n+\n+        \/\/ Get a serializer that seriailizes according to the properties,\n+        \/\/ which in this case is to xml\n+        fXMLSerializer = SerializerFactory.getSerializer(configProps);\n+\n+        \/\/ Initialize Serializer\n+        fXMLSerializer.setOutputFormat(fDOMConfigProperties);\n+    }\n+\n+    \/**\n+     * Initializes the underlying serializer's configuration depending on the\n+     * default DOMConfiguration parameters. This method must be called before a\n+     * node is to be serialized.\n+     *\n+     * @xsl.usage internal\n+     *\/\n+    public void initializeSerializerProps () {\n+        \/\/ canonical-form\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_CANONICAL_FORM, DOMConstants.DOM3_DEFAULT_FALSE);\n+\n+        \/\/ cdata-sections\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_CDATA_SECTIONS, DOMConstants.DOM3_DEFAULT_TRUE);\n+\n+        \/\/ \"check-character-normalization\"\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_CHECK_CHAR_NORMALIZATION,\n+                DOMConstants.DOM3_DEFAULT_FALSE);\n+\n+        \/\/ comments\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_DEFAULT_TRUE);\n+\n+        \/\/ datatype-normalization\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_DATATYPE_NORMALIZATION,\n+                DOMConstants.DOM3_DEFAULT_FALSE);\n+\n+        \/\/ element-content-whitespace\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE,\n+                DOMConstants.DOM3_DEFAULT_TRUE);\n+\n+        \/\/ entities\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_DEFAULT_TRUE);\n+        \/\/ preserve entities\n+        fDOMConfigProperties.setProperty(\n+                OutputPropertiesFactory.S_KEY_ENTITIES, DOMConstants.S_XSL_VALUE_ENTITIES);\n+\n+        \/\/ error-handler\n+        \/\/ Should we set our default ErrorHandler\n+        \/*\n+         * if (fDOMConfig.getParameter(Constants.DOM_ERROR_HANDLER) != null) {\n+         * fDOMErrorHandler =\n+         * (DOMErrorHandler)fDOMConfig.getParameter(Constants.DOM_ERROR_HANDLER); }\n+         *\/\n+\n+        \/\/ infoset\n+        if ((fFeatures & INFOSET) != 0) {\n+            fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                    + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_DEFAULT_TRUE);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                    + DOMConstants.DOM_NAMESPACE_DECLARATIONS,\n+                    DOMConstants.DOM3_DEFAULT_TRUE);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                    + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_DEFAULT_TRUE);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                    + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE,\n+                    DOMConstants.DOM3_DEFAULT_TRUE);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                    + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_DEFAULT_TRUE);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                    + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_DEFAULT_FALSE);\n+            \/\/ preserve entities\n+            fDOMConfigProperties.setProperty(\n+                    OutputPropertiesFactory.S_KEY_ENTITIES, \"\");\n+            fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                    + DOMConstants.DOM_CDATA_SECTIONS,\n+                    DOMConstants.DOM3_DEFAULT_FALSE);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                    + DOMConstants.DOM_VALIDATE_IF_SCHEMA,\n+                    DOMConstants.DOM3_DEFAULT_FALSE);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                    + DOMConstants.DOM_DATATYPE_NORMALIZATION,\n+                    DOMConstants.DOM3_DEFAULT_FALSE);\n+        }\n+\n+        \/\/ namespaces\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_DEFAULT_TRUE);\n+\n+        \/\/ namespace-declarations\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_NAMESPACE_DECLARATIONS,\n+                DOMConstants.DOM3_DEFAULT_TRUE);\n+\n+        \/\/ normalize-characters\n+        \/*\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_NORMALIZE_CHARACTERS,\n+                DOMConstants.DOM3_DEFAULT_FALSE);\n+        *\/\n+\n+        \/\/ split-cdata-sections\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_SPLIT_CDATA, DOMConstants.DOM3_DEFAULT_TRUE);\n+\n+        \/\/ validate\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_VALIDATE, DOMConstants.DOM3_DEFAULT_FALSE);\n+\n+        \/\/ validate-if-schema\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_VALIDATE_IF_SCHEMA,\n+                DOMConstants.DOM3_DEFAULT_FALSE);\n+\n+        \/\/ well-formed\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_DEFAULT_TRUE);\n+\n+        \/\/ pretty-print\n+        fDOMConfigProperties.setProperty(\n+                DOMConstants.S_XSL_OUTPUT_INDENT,\n+                DOMConstants.DOM3_DEFAULT_FALSE);\n+        fDOMConfigProperties.setProperty(\n+                OutputPropertiesFactory.S_KEY_INDENT_AMOUNT, Integer.toString(4));\n+\n+        \/\/\n+\n+        \/\/ discard-default-content\n+        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                + DOMConstants.DOM_DISCARD_DEFAULT_CONTENT,\n+                DOMConstants.DOM3_DEFAULT_TRUE);\n+\n+        \/\/ xml-declaration\n+        fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, \"no\");\n+\n+    }\n+\n+    \/\/ ************************************************************************\n+    \/\/ DOMConfiguraiton implementation\n+    \/\/ ************************************************************************\n+\n+    \/**\n+     * Checks if setting a parameter to a specific value is supported.\n+     *\n+     * @see org.w3c.dom.DOMConfiguration#canSetParameter(java.lang.String, java.lang.Object)\n+     * @since DOM Level 3\n+     * @param name A String containing the DOMConfiguration parameter name.\n+     * @param value An Object specifying the value of the corresponding parameter.\n+     *\/\n+    public boolean canSetParameter(String name, Object value) {\n+        if (value instanceof Boolean){\n+            if ( name.equalsIgnoreCase(DOMConstants.DOM_CDATA_SECTIONS)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_COMMENTS)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_ENTITIES)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_INFOSET)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACES)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACE_DECLARATIONS)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_SPLIT_CDATA)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_WELLFORMED)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_DISCARD_DEFAULT_CONTENT)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_FORMAT_PRETTY_PRINT)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_XMLDECL)){\n+                \/\/ both values supported\n+                return true;\n+            }\n+            else if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)\n+                    \/\/ || name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)\n+                    ) {\n+                \/\/ true is not supported\n+                return !((Boolean)value).booleanValue();\n+            }\n+            else if (name.equalsIgnoreCase(DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {\n+                \/\/ false is not supported\n+                return ((Boolean)value).booleanValue();\n+            }\n+        }\n+        else if (name.equalsIgnoreCase(DOMConstants.DOM_ERROR_HANDLER) &&\n+                value == null || value instanceof DOMErrorHandler){\n+            return true;\n+        }\n+        return false;\n+    }\n+    \/**\n+     * This method returns the value of a parameter if known.\n+     *\n+     * @see org.w3c.dom.DOMConfiguration#getParameter(java.lang.String)\n+     *\n+     * @param name A String containing the DOMConfiguration parameter name\n+     *             whose value is to be returned.\n+     * @return Object The value of the parameter if known.\n+     *\/\n+    public Object getParameter(String name) throws DOMException {\n+\n+        if(name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)){\n+                      return null;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_COMMENTS)) {\n+            return ((fFeatures & COMMENTS) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_CDATA_SECTIONS)) {\n+            return ((fFeatures & CDATA) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_ENTITIES)) {\n+            return ((fFeatures & ENTITIES) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACES)) {\n+            return ((fFeatures & NAMESPACES) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACE_DECLARATIONS)) {\n+            return ((fFeatures & NAMESPACEDECLS) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_SPLIT_CDATA)) {\n+            return ((fFeatures & SPLITCDATA) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_WELLFORMED)) {\n+            return ((fFeatures & WELLFORMED) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        }  else if (name.equalsIgnoreCase(DOMConstants.DOM_DISCARD_DEFAULT_CONTENT)) {\n+            return ((fFeatures & DISCARDDEFAULT) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_FORMAT_PRETTY_PRINT)) {\n+            return ((fFeatures & PRETTY_PRINT) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_XMLDECL)) {\n+            return ((fFeatures & XMLDECL) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE)) {\n+            return ((fFeatures & ELEM_CONTENT_WHITESPACE) != 0) ? Boolean.TRUE : Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {\n+            return Boolean.TRUE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM)\n+                || name.equalsIgnoreCase(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION)\n+                || name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION)\n+                \/\/ || name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)\n+                || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)\n+                || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)) {\n+            return Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_INFOSET)){\n+            if ((fFeatures & ENTITIES) == 0 &&\n+                    (fFeatures & CDATA) == 0 &&\n+                    (fFeatures & ELEM_CONTENT_WHITESPACE) != 0 &&\n+                    (fFeatures & NAMESPACES) != 0 &&\n+                    (fFeatures & NAMESPACEDECLS) != 0 &&\n+                    (fFeatures & WELLFORMED) != 0 &&\n+                    (fFeatures & COMMENTS) != 0) {\n+                return Boolean.TRUE;\n+            }\n+            return Boolean.FALSE;\n+        } else if (name.equalsIgnoreCase(DOMConstants.DOM_ERROR_HANDLER)) {\n+            return fDOMErrorHandler;\n+        } else if (\n+                name.equalsIgnoreCase(DOMConstants.DOM_SCHEMA_LOCATION)\n+                || name.equalsIgnoreCase(DOMConstants.DOM_SCHEMA_TYPE)) {\n+            return null;\n+        } else {\n+            \/\/ Here we have to add the Xalan specific DOM Message Formatter\n+            String msg = Utils.messages.createMessage(\n+                    MsgKey.ER_FEATURE_NOT_FOUND,\n+                    new Object[] { name });\n+            throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n+        }\n+    }\n+\n+    \/**\n+     * This method returns a of the parameters supported by this DOMConfiguration object\n+     * and for which at least one value can be set by the application\n+     *\n+     * @see org.w3c.dom.DOMConfiguration#getParameterNames()\n+     *\n+     * @return DOMStringList A list of DOMConfiguration parameters recognized\n+     *                       by the serializer\n+     *\/\n+    public DOMStringList getParameterNames() {\n+        return new DOMStringListImpl(fRecognizedParameters);\n+    }\n+\n+    \/**\n+     * This method sets the value of the named parameter.\n+     *\n+     * @see org.w3c.dom.DOMConfiguration#setParameter(java.lang.String, java.lang.Object)\n+     *\n+     * @param name A String containing the DOMConfiguration parameter name.\n+     * @param value An Object contaiing the parameters value to set.\n+     *\/\n+    public void setParameter(String name, Object value) throws DOMException {\n+        \/\/ If the value is a boolean\n+        if (value instanceof Boolean) {\n+            boolean state = ((Boolean) value).booleanValue();\n+\n+            if (name.equalsIgnoreCase(DOMConstants.DOM_COMMENTS)) {\n+                fFeatures = state ? fFeatures | COMMENTS : fFeatures\n+                        & ~COMMENTS;\n+                \/\/ comments\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_CDATA_SECTIONS)) {\n+                fFeatures =  state ? fFeatures | CDATA : fFeatures\n+                        & ~CDATA;\n+                \/\/ cdata-sections\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_CDATA_SECTIONS, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_CDATA_SECTIONS, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_ENTITIES)) {\n+                fFeatures = state ? fFeatures | ENTITIES : fFeatures\n+                        & ~ENTITIES;\n+                \/\/ entities\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                    fDOMConfigProperties.setProperty(\n+                            OutputPropertiesFactory.S_KEY_ENTITIES, DOMConstants.S_XSL_VALUE_ENTITIES);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_NAMESPACES)) {\n+                fFeatures = state ? fFeatures | NAMESPACES : fFeatures\n+                        & ~NAMESPACES;\n+                \/\/ namespaces\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name\n+                    .equalsIgnoreCase(DOMConstants.DOM_NAMESPACE_DECLARATIONS)) {\n+                fFeatures = state ? fFeatures | NAMESPACEDECLS\n+                        : fFeatures & ~NAMESPACEDECLS;\n+                \/\/ namespace-declarations\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_NAMESPACE_DECLARATIONS, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_NAMESPACE_DECLARATIONS, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_SPLIT_CDATA)) {\n+                fFeatures = state ? fFeatures | SPLITCDATA : fFeatures\n+                        & ~SPLITCDATA;\n+                \/\/ split-cdata-sections\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_SPLIT_CDATA, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_SPLIT_CDATA, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_WELLFORMED)) {\n+                fFeatures = state ? fFeatures | WELLFORMED : fFeatures\n+                        & ~WELLFORMED;\n+                \/\/ well-formed\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name\n+                    .equalsIgnoreCase(DOMConstants.DOM_DISCARD_DEFAULT_CONTENT)) {\n+                fFeatures = state ? fFeatures | DISCARDDEFAULT\n+                        : fFeatures & ~DISCARDDEFAULT;\n+                \/\/ discard-default-content\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_DISCARD_DEFAULT_CONTENT, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_DISCARD_DEFAULT_CONTENT, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_FORMAT_PRETTY_PRINT)) {\n+                fFeatures = state ? fFeatures | PRETTY_PRINT : fFeatures\n+                        & ~PRETTY_PRINT;\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_INDENT,DOMConstants.DOM3_EXPLICIT_TRUE);\n+                    fDOMConfigProperties.setProperty(OutputPropertiesFactory.S_KEY_INDENT_AMOUNT, Integer.toString(4));\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_INDENT,DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_XMLDECL)) {\n+                fFeatures = state ? fFeatures | XMLDECL : fFeatures\n+                        & ~XMLDECL;\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, \"no\");\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL, \"yes\");\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE)) {\n+                fFeatures = state ? fFeatures | ELEM_CONTENT_WHITESPACE : fFeatures\n+                        & ~ELEM_CONTENT_WHITESPACE;\n+                \/\/ element-content-whitespace\n+                if (state) {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS)) {\n+                \/\/ false is not supported\n+                if (!state) {\n+                    \/\/ Here we have to add the Xalan specific DOM Message Formatter\n+                    String msg = Utils.messages.createMessage(\n+                            MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+                            new Object[] { name });\n+                    throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);\n+                } else {\n+                    fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                            + DOMConstants.DOM_IGNORE_UNKNOWN_CHARACTER_DENORMALIZATIONS, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION)\n+                    || name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION)\n+                    \/\/ || name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)\n+                    ) {\n+                \/\/ true is not supported\n+                if (state) {\n+                    String msg = Utils.messages.createMessage(\n+                            MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+                            new Object[] { name });\n+                    throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);\n+                } else {\n+                    if (name.equalsIgnoreCase(DOMConstants.DOM_CANONICAL_FORM)) {\n+                        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                                + DOMConstants.DOM_CANONICAL_FORM, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                    } else if (name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)) {\n+                        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                                + DOMConstants.DOM_VALIDATE_IF_SCHEMA, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                    } else if (name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE)) {\n+                        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                                + DOMConstants.DOM_VALIDATE, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                    } else if (name.equalsIgnoreCase(DOMConstants.DOM_VALIDATE_IF_SCHEMA)) {\n+                        fDOMConfigProperties.setProperty(DOMConstants.DOM_CHECK_CHAR_NORMALIZATION\n+                                + DOMConstants.DOM_CHECK_CHAR_NORMALIZATION, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                    } else if (name.equalsIgnoreCase(DOMConstants.DOM_DATATYPE_NORMALIZATION)) {\n+                        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                                + DOMConstants.DOM_DATATYPE_NORMALIZATION, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                    } \/* else if (name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)) {\n+                        fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                                + DOMConstants.DOM_NORMALIZE_CHARACTERS, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                    } *\/\n+                }\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_INFOSET)) {\n+                if (state) {\n+                    fFeatures &= ~ENTITIES;\n+                    fFeatures &= ~CDATA;\n+                    fFeatures &= ~SCHEMAVALIDATE;\n+                    fFeatures &= ~DTNORMALIZE;\n+                    fFeatures |= NAMESPACES;\n+                    fFeatures |= NAMESPACEDECLS;\n+                    fFeatures |= WELLFORMED;\n+                    fFeatures |= ELEM_CONTENT_WHITESPACE;\n+                    fFeatures |= COMMENTS;\n+                }\n+\n+                \/\/ infoset\n+                fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_NAMESPACES, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_NAMESPACE_DECLARATIONS, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_COMMENTS, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_ELEMENT_CONTENT_WHITESPACE, DOMConstants.DOM3_EXPLICIT_TRUE);\n+                fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_WELLFORMED, DOMConstants.DOM3_EXPLICIT_TRUE);\n+\n+                fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_ENTITIES, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                fDOMConfigProperties.setProperty(\n+                        OutputPropertiesFactory.S_KEY_ENTITIES, \"\");\n+\n+                fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_CDATA_SECTIONS, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_VALIDATE_IF_SCHEMA, DOMConstants.DOM3_EXPLICIT_FALSE);\n+                fDOMConfigProperties.setProperty(DOMConstants.S_DOM3_PROPERTIES_NS\n+                        + DOMConstants.DOM_DATATYPE_NORMALIZATION, DOMConstants.DOM3_EXPLICIT_FALSE);\n+            } else if (name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)) {\n+                String msg = Utils.messages.createMessage(\n+                    MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+                    new Object[] { name });\n+                throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);\n+            } else {\n+                \/\/ Setting this to false has no effect\n+            }\n+        } \/\/ If the parameter value is not a boolean\n+        else if (name.equalsIgnoreCase(DOMConstants.DOM_ERROR_HANDLER)) {\n+            if (value == null || value instanceof DOMErrorHandler) {\n+                fDOMErrorHandler = (DOMErrorHandler)value;\n+            } else {\n+                String msg = Utils.messages.createMessage(\n+                        MsgKey.ER_TYPE_MISMATCH_ERR,\n+                        new Object[] { name });\n+                throw new DOMException(DOMException.TYPE_MISMATCH_ERR, msg);\n+            }\n+        } else if (\n+                name.equalsIgnoreCase(DOMConstants.DOM_SCHEMA_LOCATION)\n+                || name.equalsIgnoreCase(DOMConstants.DOM_SCHEMA_TYPE)\n+                || name.equalsIgnoreCase(DOMConstants.DOM_NORMALIZE_CHARACTERS)\n+                && value != null) {\n+            String msg = Utils.messages.createMessage(\n+                    MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+                    new Object[] { name });\n+            throw new DOMException(DOMException.NOT_SUPPORTED_ERR, msg);\n+        } else {\n+            String msg = Utils.messages.createMessage(\n+                    MsgKey.ER_FEATURE_NOT_FOUND,\n+                    new Object[] { name });\n+            throw new DOMException(DOMException.NOT_FOUND_ERR, msg);\n+        }\n+    }\n+    \/\/ ************************************************************************\n+\n+\n+    \/\/ ************************************************************************\n+    \/\/ DOMConfiguraiton implementation\n+    \/\/ ************************************************************************\n+\n+    \/**\n+     * Returns the DOMConfiguration of the LSSerializer.\n+     *\n+     * @see org.w3c.dom.ls.LSSerializer#getDomConfig()\n+     * @since DOM Level 3\n+     * @return A DOMConfiguration object.\n+     *\/\n+    public DOMConfiguration getDomConfig() {\n+        return (DOMConfiguration)this;\n+    }\n+\n+    \/**\n+     * Returns the DOMConfiguration of the LSSerializer.\n+     *\n+     * @see org.w3c.dom.ls.LSSerializer#getFilter()\n+     * @since DOM Level 3\n+     * @return A LSSerializerFilter object.\n+     *\/\n+    public LSSerializerFilter getFilter() {\n+        return fSerializerFilter;\n+    }\n+\n+    \/**\n+     * Returns the End-Of-Line sequence of characters to be used in the XML\n+     * being serialized.  If none is set a default \"\\n\" is returned.\n+     *\n+     * @see org.w3c.dom.ls.LSSerializer#getNewLine()\n+     * @since DOM Level 3\n+     * @return A String containing the end-of-line character sequence  used in\n+     * serialization.\n+     *\/\n+    public String getNewLine() {\n+        return fEndOfLine;\n+    }\n+\n+    \/**\n+     * Set a LSSerilizerFilter on the LSSerializer.  When set, the filter is\n+     * called before each node is serialized which depending on its implemention\n+     * determines if the node is to be serialized or not.\n+     *\n+     * @see org.w3c.dom.ls.LSSerializer#setFilter\n+     * @since DOM Level 3\n+     * @param filter A LSSerializerFilter to be applied to the stream to serialize.\n+     *\/\n+    public void setFilter(LSSerializerFilter filter) {\n+        fSerializerFilter = filter;\n+    }\n+\n+    \/**\n+     * Sets the End-Of-Line sequence of characters to be used in the XML\n+     * being serialized.  Setting this attribute to null will reset its\n+     * value to the default value i.e. \"\\n\".\n+     *\n+     * @see org.w3c.dom.ls.LSSerializer#setNewLine\n+     * @since DOM Level 3\n+     * @param newLine a String that is the end-of-line character sequence to be used in\n+     * serialization.\n+     *\/\n+    public void setNewLine(String newLine) {\n+        fEndOfLine = newLine !=null? newLine: fEndOfLine;\n+    }\n+\n+    \/**\n+     * Serializes the specified node to the specified LSOutput and returns true if the Node\n+     * was successfully serialized.\n+     *\n+     * @see org.w3c.dom.ls.LSSerializer#write(org.w3c.dom.Node, org.w3c.dom.ls.LSOutput)\n+     * @since DOM Level 3\n+     * @param nodeArg The Node to serialize.\n+     * @throws org.w3c.dom.ls.LSException SERIALIZE_ERR: Raised if the\n+     * LSSerializer was unable to serialize the node.\n+     *\n+     *\/\n+    public boolean write(Node nodeArg, LSOutput destination) throws LSException {\n+        \/\/ If the destination is null\n+        if (destination == null) {\n+            String msg = Utils.messages\n+            .createMessage(\n+                    MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+                    null);\n+            if (fDOMErrorHandler != null) {\n+                fDOMErrorHandler.handleError(new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR, msg,\n+                        MsgKey.ER_NO_OUTPUT_SPECIFIED));\n+            }\n+            throw new LSException(LSException.SERIALIZE_ERR, msg);\n+        }\n+\n+        \/\/ If nodeArg is null, return false.  Should we throw and LSException instead?\n+        if (nodeArg == null ) {\n+            return false;\n+        }\n+\n+        \/\/ Obtain a reference to the serializer to use\n+        \/\/ Serializer serializer = getXMLSerializer(xmlVersion);\n+        Serializer serializer = fXMLSerializer;\n+        serializer.reset();\n+\n+        \/\/ If the node has not been seen\n+        if ( nodeArg != fVisitedNode) {\n+            \/\/ Determine the XML Document version of the Node\n+            String xmlVersion = getXMLVersion(nodeArg);\n+\n+            \/\/ Determine the encoding: 1.LSOutput.encoding, 2.Document.inputEncoding, 3.Document.xmlEncoding.\n+            fEncoding = destination.getEncoding();\n+            if (fEncoding == null ) {\n+                fEncoding = getInputEncoding(nodeArg);\n+                fEncoding = fEncoding != null ? fEncoding : getXMLEncoding(nodeArg) == null? \"UTF-8\": getXMLEncoding(nodeArg);\n+            }\n+\n+            \/\/ If the encoding is not recognized throw an exception.\n+            \/\/ Note: The serializer defaults to UTF-8 when created\n+            if (!Encodings.isRecognizedEncoding(fEncoding)) {\n+                String msg = Utils.messages\n+                .createMessage(\n+                        MsgKey.ER_UNSUPPORTED_ENCODING,\n+                        null);\n+                if (fDOMErrorHandler != null) {\n+                    fDOMErrorHandler.handleError(new DOMErrorImpl(\n+                            DOMError.SEVERITY_FATAL_ERROR, msg,\n+                            MsgKey.ER_UNSUPPORTED_ENCODING));\n+                }\n+                throw new LSException(LSException.SERIALIZE_ERR, msg);\n+            }\n+\n+            serializer.getOutputFormat().setProperty(\"version\", xmlVersion);\n+\n+            \/\/ Set the output encoding and xml version properties\n+            fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, fEncoding);\n+\n+            \/\/ If the node to be serialized is not a Document, Element, or Entity\n+            \/\/ node\n+            \/\/ then the XML declaration, or text declaration, should be never be\n+            \/\/ serialized.\n+            if ( (nodeArg.getNodeType() != Node.DOCUMENT_NODE\n+                    || nodeArg.getNodeType() != Node.ELEMENT_NODE\n+                    || nodeArg.getNodeType() != Node.ENTITY_NODE)\n+                    && ((fFeatures & XMLDECL) != 0)) {\n+                fDOMConfigProperties.setProperty(\n+                        DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL,\n+                        DOMConstants.DOM3_DEFAULT_FALSE);\n+            }\n+\n+            fVisitedNode = nodeArg;\n+        }\n+\n+        \/\/ Update the serializer properties\n+        fXMLSerializer.setOutputFormat(fDOMConfigProperties);\n+\n+        \/\/\n+        try {\n+\n+            \/\/ The LSSerializer will use the LSOutput object to determine\n+            \/\/ where to serialize the output to in the following order the\n+            \/\/ first one that is not null and not an empty string will be\n+            \/\/ used: 1.LSOutput.characterStream, 2.LSOutput.byteStream,\n+            \/\/ 3. LSOutput.systemId\n+            \/\/ 1.LSOutput.characterStream\n+            Writer writer = destination.getCharacterStream();\n+            if (writer == null ) {\n+\n+                \/\/ 2.LSOutput.byteStream\n+                OutputStream outputStream = destination.getByteStream();\n+                if ( outputStream == null) {\n+\n+                    \/\/ 3. LSOutput.systemId\n+                    String uri = destination.getSystemId();\n+                    if (uri == null) {\n+                        String msg = Utils.messages\n+                        .createMessage(\n+                                MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+                                null);\n+                        if (fDOMErrorHandler != null) {\n+                            fDOMErrorHandler.handleError(new DOMErrorImpl(\n+                                    DOMError.SEVERITY_FATAL_ERROR, msg,\n+                                    MsgKey.ER_NO_OUTPUT_SPECIFIED));\n+                        }\n+                        throw new LSException(LSException.SERIALIZE_ERR, msg);\n+\n+                    } else {\n+                        \/\/ Expand the System Id and obtain an absolute URI for it.\n+                        String absoluteURI = SystemIDResolver.getAbsoluteURI(uri);\n+\n+                        URL url = new URL(absoluteURI);\n+                        OutputStream urlOutStream = null;\n+                        String protocol = url.getProtocol();\n+                        String host = url.getHost();\n+\n+                        \/\/ For file protocols, there is no need to use a URL to get its\n+                        \/\/ corresponding OutputStream\n+\n+                        \/\/ Scheme names consist of a sequence of characters. The lower case\n+                        \/\/ letters \"a\"--\"z\", digits, and the characters plus (\"+\"), period\n+                        \/\/ (\".\"), and hyphen (\"-\") are allowed. For resiliency, programs\n+                        \/\/ interpreting URLs should treat upper case letters as equivalent to\n+                        \/\/ lower case in scheme names (e.g., allow \"HTTP\" as well as \"http\").\n+                        if (protocol.equalsIgnoreCase(\"file\")\n+                                && (host == null || host.length() == 0 || host.equals(\"localhost\"))) {\n+                            \/\/ do we also need to check for host.equals(hostname)\n+                            urlOutStream = new FileOutputStream(new File(url.getPath()));\n+\n+                        } else {\n+                            \/\/ This should support URL's whose schemes are mentioned in\n+                            \/\/ RFC1738 other than file\n+\n+                            URLConnection urlCon = url.openConnection();\n+                            urlCon.setDoInput(false);\n+                            urlCon.setDoOutput(true);\n+                            urlCon.setUseCaches(false);\n+                            urlCon.setAllowUserInteraction(false);\n+\n+                            \/\/ When writing to a HTTP URI, a HTTP PUT is performed.\n+                            if (urlCon instanceof HttpURLConnection) {\n+                                HttpURLConnection httpCon = (HttpURLConnection) urlCon;\n+                                httpCon.setRequestMethod(\"PUT\");\n+                            }\n+                            urlOutStream = urlCon.getOutputStream();\n+                        }\n+                        \/\/ set the OutputStream to that obtained from the systemId\n+                        serializer.setWriter(new OutputStreamWriter(urlOutStream));\n+                    }\n+                } else {\n+                    \/\/ 2.LSOutput.byteStream\n+                    serializer.setWriter(new OutputStreamWriter(outputStream, fEncoding));\n+                }\n+            } else {\n+                \/\/ 1.LSOutput.characterStream\n+                serializer.setWriter(writer);\n+            }\n+\n+            \/\/ The associated media type by default is set to text\/xml on\n+            \/\/ org.apache.xml.serializer.SerializerBase.\n+\n+            \/\/ Get a reference to the serializer then lets you serilize a DOM\n+            \/\/ Use this hack till Xalan support JAXP1.3\n+            if (fDOMSerializer == null) {\n+               fDOMSerializer = (DOM3Serializer)serializer.asDOM3Serializer();\n+            }\n+\n+            \/\/ Set the error handler on the DOM3Serializer interface implementation\n+            if (fDOMErrorHandler != null) {\n+                fDOMSerializer.setErrorHandler(fDOMErrorHandler);\n+            }\n+\n+            \/\/ Set the filter on the DOM3Serializer interface implementation\n+            if (fSerializerFilter != null) {\n+                fDOMSerializer.setNodeFilter(fSerializerFilter);\n+            }\n+\n+            \/\/ Set the NewLine character to be used\n+            fDOMSerializer.setNewLine(fEndOfLine);\n+\n+            \/\/ Serializer your DOM, where node is an org.w3c.dom.Node\n+            \/\/ Assuming that Xalan's serializer can serialize any type of DOM node\n+            fDOMSerializer.serializeDOM3(nodeArg);\n+\n+        } catch( UnsupportedEncodingException ue) {\n+\n+            String msg = Utils.messages\n+            .createMessage(\n+                    MsgKey.ER_UNSUPPORTED_ENCODING,\n+                    null);\n+            if (fDOMErrorHandler != null) {\n+                fDOMErrorHandler.handleError(new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR, msg,\n+                        MsgKey.ER_UNSUPPORTED_ENCODING, ue));\n+            }\n+            throw new LSException(LSException.SERIALIZE_ERR, ue.getMessage());\n+        } catch (LSException lse) {\n+            \/\/ Rethrow LSException.\n+            throw lse;\n+        } catch (RuntimeException e) {\n+            e.printStackTrace();\n+            throw new LSException(LSException.SERIALIZE_ERR, e!=null?e.getMessage():\"NULL Exception\") ;\n+        }  catch (Exception e) {\n+            if (fDOMErrorHandler != null) {\n+                fDOMErrorHandler.handleError(new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR, e.getMessage(),\n+                        null, e));\n+            }\n+            e.printStackTrace();\n+            throw new LSException(LSException.SERIALIZE_ERR, e.toString());\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Serializes the specified node and returns a String with the serialized\n+     * data to the caller.\n+     *\n+     * @see org.w3c.dom.ls.LSSerializer#writeToString(org.w3c.dom.Node)\n+     * @since DOM Level 3\n+     * @param nodeArg The Node to serialize.\n+     * @throws org.w3c.dom.ls.LSException SERIALIZE_ERR: Raised if the\n+     * LSSerializer was unable to serialize the node.\n+     *\n+     *\/\n+    public String writeToString(Node nodeArg) throws DOMException, LSException {\n+        \/\/ return null is nodeArg is null.  Should an Exception be thrown instead?\n+        if (nodeArg == null) {\n+            return null;\n+        }\n+\n+        \/\/ Should we reset the serializer configuration before each write operation?\n+        \/\/ Obtain a reference to the serializer to use\n+        Serializer serializer = fXMLSerializer;\n+        serializer.reset();\n+\n+        if (nodeArg != fVisitedNode){\n+            \/\/ Determine the XML Document version of the Node\n+            String xmlVersion = getXMLVersion(nodeArg);\n+\n+            serializer.getOutputFormat().setProperty(\"version\", xmlVersion);\n+\n+            \/\/ Set the output encoding and xml version properties\n+            fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, \"UTF-16\");\n+\n+            \/\/ If the node to be serialized is not a Document, Element, or Entity\n+            \/\/ node\n+            \/\/ then the XML declaration, or text declaration, should be never be\n+            \/\/ serialized.\n+            if  ((nodeArg.getNodeType() != Node.DOCUMENT_NODE\n+                    || nodeArg.getNodeType() != Node.ELEMENT_NODE\n+                    || nodeArg.getNodeType() != Node.ENTITY_NODE)\n+                    && ((fFeatures & XMLDECL) != 0)) {\n+                fDOMConfigProperties.setProperty(\n+                        DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL,\n+                        DOMConstants.DOM3_DEFAULT_FALSE);\n+            }\n+\n+            fVisitedNode = nodeArg;\n+        }\n+        \/\/ Update the serializer properties\n+        fXMLSerializer.setOutputFormat(fDOMConfigProperties);\n+\n+        \/\/ StringWriter to Output to\n+        StringWriter output = new StringWriter();\n+\n+        \/\/\n+        try {\n+\n+            \/\/ Set the Serializer's Writer to a StringWriter\n+            serializer.setWriter(output);\n+\n+            \/\/ Get a reference to the serializer then lets you serilize a DOM\n+            \/\/ Use this hack till Xalan support JAXP1.3\n+            if (fDOMSerializer == null) {\n+                fDOMSerializer = (DOM3Serializer)serializer.asDOM3Serializer();\n+            }\n+\n+            \/\/ Set the error handler on the DOM3Serializer interface implementation\n+            if (fDOMErrorHandler != null) {\n+                fDOMSerializer.setErrorHandler(fDOMErrorHandler);\n+            }\n+\n+            \/\/ Set the filter on the DOM3Serializer interface implementation\n+            if (fSerializerFilter != null) {\n+                fDOMSerializer.setNodeFilter(fSerializerFilter);\n+            }\n+\n+            \/\/ Set the NewLine character to be used\n+            fDOMSerializer.setNewLine(fEndOfLine);\n+\n+            \/\/ Serializer your DOM, where node is an org.w3c.dom.Node\n+            fDOMSerializer.serializeDOM3(nodeArg);\n+        } catch (LSException lse) {\n+            \/\/ Rethrow LSException.\n+            throw lse;\n+        } catch (RuntimeException e) {\n+            e.printStackTrace();\n+            throw new LSException(LSException.SERIALIZE_ERR, e.toString());\n+        }  catch (Exception e) {\n+            if (fDOMErrorHandler != null) {\n+                fDOMErrorHandler.handleError(new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR, e.getMessage(),\n+                        null, e));\n+            }\n+            e.printStackTrace();\n+            throw new LSException(LSException.SERIALIZE_ERR, e.toString());\n+        }\n+\n+        \/\/ return the serialized string\n+        return output.toString();\n+    }\n+\n+    \/**\n+     * Serializes the specified node to the specified URI and returns true if the Node\n+     * was successfully serialized.\n+     *\n+     * @see org.w3c.dom.ls.LSSerializer#writeToURI(org.w3c.dom.Node, String)\n+     * @since DOM Level 3\n+     * @param nodeArg The Node to serialize.\n+     * @throws org.w3c.dom.ls.LSException SERIALIZE_ERR: Raised if the\n+     * LSSerializer was unable to serialize the node.\n+     *\n+     *\/\n+    public boolean writeToURI(Node nodeArg, String uri) throws LSException {\n+        \/\/ If nodeArg is null, return false.  Should we throw and LSException instead?\n+        if (nodeArg == null ) {\n+            return false;\n+        }\n+\n+        \/\/ Obtain a reference to the serializer to use\n+        Serializer serializer = fXMLSerializer;\n+        serializer.reset();\n+\n+        if (nodeArg != fVisitedNode) {\n+            \/\/ Determine the XML Document version of the Node\n+            String xmlVersion = getXMLVersion(nodeArg);\n+\n+            \/\/ Determine the encoding: 1.LSOutput.encoding,\n+            \/\/ 2.Document.inputEncoding, 3.Document.xmlEncoding.\n+            fEncoding = getInputEncoding(nodeArg);\n+            if (fEncoding == null ) {\n+                fEncoding = fEncoding != null ? fEncoding : getXMLEncoding(nodeArg) == null? \"UTF-8\": getXMLEncoding(nodeArg);\n+            }\n+\n+            serializer.getOutputFormat().setProperty(\"version\", xmlVersion);\n+\n+            \/\/ Set the output encoding and xml version properties\n+            fDOMConfigProperties.setProperty(DOMConstants.S_XERCES_PROPERTIES_NS + DOMConstants.S_XML_VERSION, xmlVersion);\n+            fDOMConfigProperties.setProperty(DOMConstants.S_XSL_OUTPUT_ENCODING, fEncoding);\n+\n+            \/\/ If the node to be serialized is not a Document, Element, or Entity\n+            \/\/ node\n+            \/\/ then the XML declaration, or text declaration, should be never be\n+            \/\/ serialized.\n+            if ( (nodeArg.getNodeType() != Node.DOCUMENT_NODE\n+                    || nodeArg.getNodeType() != Node.ELEMENT_NODE\n+                    || nodeArg.getNodeType() != Node.ENTITY_NODE)\n+                    && ((fFeatures & XMLDECL) != 0))  {\n+                fDOMConfigProperties.setProperty(\n+                        DOMConstants.S_XSL_OUTPUT_OMIT_XML_DECL,\n+                        DOMConstants.DOM3_DEFAULT_FALSE);\n+            }\n+\n+            fVisitedNode = nodeArg;\n+        }\n+\n+        \/\/ Update the serializer properties\n+        fXMLSerializer.setOutputFormat(fDOMConfigProperties);\n+\n+        \/\/\n+        try {\n+            \/\/ If the specified encoding is not supported an\n+            \/\/ \"unsupported-encoding\" fatal error is raised. ??\n+            if (uri == null) {\n+                String msg = Utils.messages.createMessage(\n+                        MsgKey.ER_NO_OUTPUT_SPECIFIED, null);\n+                if (fDOMErrorHandler != null) {\n+                    fDOMErrorHandler.handleError(new DOMErrorImpl(\n+                            DOMError.SEVERITY_FATAL_ERROR, msg,\n+                            MsgKey.ER_NO_OUTPUT_SPECIFIED));\n+                }\n+                throw new LSException(LSException.SERIALIZE_ERR, msg);\n+\n+            } else {\n+                \/\/ REVISIT: Can this be used to get an absolute expanded URI\n+                String absoluteURI = SystemIDResolver.getAbsoluteURI(uri);\n+\n+                URL url = new URL(absoluteURI);\n+                OutputStream urlOutStream = null;\n+                String protocol = url.getProtocol();\n+                String host = url.getHost();\n+\n+                \/\/ For file protocols, there is no need to use a URL to get its\n+                \/\/ corresponding OutputStream\n+\n+                \/\/ Scheme names consist of a sequence of characters. The lower\n+                \/\/ case letters \"a\"--\"z\", digits, and the characters plus (\"+\"),\n+                \/\/ period (\".\"), and hyphen (\"-\") are allowed. For resiliency,\n+                \/\/ programs interpreting URLs should treat upper case letters as\n+                \/\/ equivalent to lower case in scheme names\n+                \/\/ (e.g., allow \"HTTP\" as well as \"http\").\n+                if (protocol.equalsIgnoreCase(\"file\")\n+                        && (host == null || host.length() == 0 || host\n+                                .equals(\"localhost\"))) {\n+                    \/\/ do we also need to check for host.equals(hostname)\n+                    urlOutStream = new FileOutputStream(new File(url.getPath()));\n+\n+                } else {\n+                    \/\/ This should support URL's whose schemes are mentioned in\n+                    \/\/ RFC1738 other than file\n+\n+                    URLConnection urlCon = url.openConnection();\n+                    urlCon.setDoInput(false);\n+                    urlCon.setDoOutput(true);\n+                    urlCon.setUseCaches(false);\n+                    urlCon.setAllowUserInteraction(false);\n+\n+                    \/\/ When writing to a HTTP URI, a HTTP PUT is performed.\n+                    if (urlCon instanceof HttpURLConnection) {\n+                        HttpURLConnection httpCon = (HttpURLConnection) urlCon;\n+                        httpCon.setRequestMethod(\"PUT\");\n+                    }\n+                    urlOutStream = urlCon.getOutputStream();\n+                }\n+                \/\/ set the OutputStream to that obtained from the systemId\n+                serializer.setWriter(new OutputStreamWriter(urlOutStream, fEncoding));\n+            }\n+\n+            \/\/ Get a reference to the serializer then lets you serilize a DOM\n+            \/\/ Use this hack till Xalan support JAXP1.3\n+            if (fDOMSerializer == null) {\n+                fDOMSerializer = (DOM3Serializer)serializer.asDOM3Serializer();\n+            }\n+\n+            \/\/ Set the error handler on the DOM3Serializer interface implementation\n+            if (fDOMErrorHandler != null) {\n+                fDOMSerializer.setErrorHandler(fDOMErrorHandler);\n+            }\n+\n+            \/\/ Set the filter on the DOM3Serializer interface implementation\n+            if (fSerializerFilter != null) {\n+                fDOMSerializer.setNodeFilter(fSerializerFilter);\n+            }\n+\n+            \/\/ Set the NewLine character to be used\n+            fDOMSerializer.setNewLine(fEndOfLine);\n+\n+            \/\/ Serializer your DOM, where node is an org.w3c.dom.Node\n+            \/\/ Assuming that Xalan's serializer can serialize any type of DOM\n+            \/\/ node\n+            fDOMSerializer.serializeDOM3(nodeArg);\n+\n+        } catch (LSException lse) {\n+            \/\/ Rethrow LSException.\n+            throw lse;\n+        } catch (RuntimeException e) {\n+            e.printStackTrace();\n+            throw new LSException(LSException.SERIALIZE_ERR, e.toString());\n+        }  catch (Exception e) {\n+            if (fDOMErrorHandler != null) {\n+                fDOMErrorHandler.handleError(new DOMErrorImpl(\n+                        DOMError.SEVERITY_FATAL_ERROR, e.getMessage(),\n+                        null, e));\n+            }\n+            e.printStackTrace();\n+            throw new LSException(LSException.SERIALIZE_ERR, e.toString());\n+        }\n+\n+        return true;\n+    }\n+    \/\/ ************************************************************************\n+\n+\n+    \/\/ ************************************************************************\n+    \/\/ Implementaion methods\n+    \/\/ ************************************************************************\n+\n+    \/**\n+     * Determines the XML Version of the Document Node to serialize.  If the Document Node\n+     * is not a DOM Level 3 Node, then the default version returned is 1.0.\n+     *\n+     * @param  nodeArg The Node to serialize\n+     * @return A String containing the version pseudo-attribute of the XMLDecl.\n+     * @throws Throwable if the DOM implementation does not implement Document.getXmlVersion()\n+     *\/\n+    \/\/protected String getXMLVersion(Node nodeArg) throws Throwable {\n+    protected String getXMLVersion(Node nodeArg) {\n+        Document doc = null;\n+\n+        \/\/ Determine the XML Version of the document\n+        if (nodeArg != null) {\n+            if (nodeArg.getNodeType() == Node.DOCUMENT_NODE) {\n+                \/\/ The Document node is the Node argument\n+                doc = (Document)nodeArg;\n+            } else {\n+                \/\/ The Document node is the Node argument's ownerDocument\n+                doc = nodeArg.getOwnerDocument();\n+            }\n+\n+            \/\/ Determine the DOM Version.\n+            if (doc != null && doc.getImplementation().hasFeature(\"Core\",\"3.0\")) {\n+                try {\n+                    return doc.getXmlVersion();\n+                } catch (AbstractMethodError e) {\n+                    \/\/ignore, impl does not support the method\n+                }\n+            }\n+        }\n+        \/\/ The version will be treated as \"1.0\" which may result in\n+        \/\/ an ill-formed document being serialized.\n+        \/\/ If nodeArg does not have an ownerDocument, treat this as XML 1.0\n+        return \"1.0\";\n+    }\n+\n+    \/**\n+     * Determines the XML Encoding of the Document Node to serialize.  If the Document Node\n+     * is not a DOM Level 3 Node, then the default encoding \"UTF-8\" is returned.\n+     *\n+     * @param  nodeArg The Node to serialize\n+     * @return A String containing the encoding pseudo-attribute of the XMLDecl.\n+     * @throws Throwable if the DOM implementation does not implement Document.getXmlEncoding()\n+     *\/\n+    protected String getXMLEncoding(Node nodeArg) {\n+        Document doc = null;\n+\n+        \/\/ Determine the XML Encoding of the document\n+        if (nodeArg != null) {\n+            if (nodeArg.getNodeType() == Node.DOCUMENT_NODE) {\n+                \/\/ The Document node is the Node argument\n+                doc = (Document)nodeArg;\n+            } else {\n+                \/\/ The Document node is the Node argument's ownerDocument\n+                doc = nodeArg.getOwnerDocument();\n+            }\n+\n+            \/\/ Determine the XML Version.\n+            if (doc != null && doc.getImplementation().hasFeature(\"Core\",\"3.0\")) {\n+                return doc.getXmlEncoding();\n+            }\n+        }\n+        \/\/ The default encoding is UTF-8 except for the writeToString method\n+        return \"UTF-8\";\n+    }\n+\n+    \/**\n+     * Determines the Input Encoding of the Document Node to serialize.  If the Document Node\n+     * is not a DOM Level 3 Node, then null is returned.\n+     *\n+     * @param  nodeArg The Node to serialize\n+     * @return A String containing the input encoding.\n+     *\/\n+    protected String getInputEncoding(Node nodeArg)  {\n+        Document doc = null;\n+\n+        \/\/ Determine the Input Encoding of the document\n+        if (nodeArg != null) {\n+            if (nodeArg.getNodeType() == Node.DOCUMENT_NODE) {\n+                \/\/ The Document node is the Node argument\n+                doc = (Document)nodeArg;\n+            } else {\n+                \/\/ The Document node is the Node argument's ownerDocument\n+                doc = nodeArg.getOwnerDocument();\n+            }\n+\n+            \/\/ Determine the DOM Version.\n+            if (doc != null && doc.getImplementation().hasFeature(\"Core\",\"3.0\")) {\n+                return doc.getInputEncoding();\n+            }\n+        }\n+        \/\/ The default encoding returned is null\n+        return null;\n+    }\n+\n+    \/**\n+     * This method returns the LSSerializer's error handler.\n+     *\n+     * @return Returns the fDOMErrorHandler.\n+     *\/\n+    public DOMErrorHandler getErrorHandler() {\n+        return fDOMErrorHandler;\n+    }\n+\n+}\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/LSSerializerImpl.java","additions":1405,"deletions":0,"binary":false,"changes":1405,"status":"added"},{"patch":"@@ -0,0 +1,315 @@\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\/\n+\/*\n+ * $Id:  $\n+ *\/\n+\n+package com.sun.org.apache.xml.internal.serializer.dom3;\n+\n+import java.util.Enumeration;\n+import java.util.NoSuchElementException;\n+\n+\/**\n+ * Namespace support for XML document handlers. This class doesn't\n+ * perform any error checking and assumes that all strings passed\n+ * as arguments to methods are unique symbols. The SymbolTable class\n+ * can be used for this purpose.\n+ *\n+ * Derived from org.apache.xerces.util.NamespaceSupport\n+ *\n+ * @author Andy Clark, IBM\n+ *\n+ * @version $Id: Exp $\n+ *\/\n+public class NamespaceSupport {\n+\n+        static final String PREFIX_XML = \"xml\".intern();\n+\n+        static final String PREFIX_XMLNS = \"xmlns\".intern();\n+\n+    \/**\n+     * The XML Namespace (\"http:\/\/www.w3.org\/XML\/1998\/namespace\"). This is\n+     * the Namespace URI that is automatically mapped to the \"xml\" prefix.\n+     *\/\n+    public final static String XML_URI = \"http:\/\/www.w3.org\/XML\/1998\/namespace\".intern();\n+\n+    \/**\n+     * XML Information Set REC\n+     * all namespace attributes (including those named xmlns,\n+     * whose [prefix] property has no value) have a namespace URI of http:\/\/www.w3.org\/2000\/xmlns\/\n+     *\/\n+    public final static String XMLNS_URI = \"http:\/\/www.w3.org\/2000\/xmlns\/\".intern();\n+\n+        \/\/\n+    \/\/ Data\n+    \/\/\n+\n+    \/**\n+     * Namespace binding information. This array is composed of a\n+     * series of tuples containing the namespace binding information:\n+     * &lt;prefix, uri&gt;. The default size can be set to anything\n+     * as long as it is a power of 2 greater than 1.\n+     *\n+     * @see #fNamespaceSize\n+     * @see #fContext\n+     *\/\n+    protected String[] fNamespace = new String[16 * 2];\n+\n+    \/** The top of the namespace information array. *\/\n+    protected int fNamespaceSize;\n+\n+    \/\/ NOTE: The constructor depends on the initial context size\n+    \/\/       being at least 1. -Ac\n+\n+    \/**\n+     * Context indexes. This array contains indexes into the namespace\n+     * information array. The index at the current context is the start\n+     * index of declared namespace bindings and runs to the size of the\n+     * namespace information array.\n+     *\n+     * @see #fNamespaceSize\n+     *\/\n+    protected int[] fContext = new int[8];\n+\n+    \/** The current context. *\/\n+    protected int fCurrentContext;\n+\n+    protected String[] fPrefixes = new String[16];\n+\n+    \/\/\n+    \/\/ Constructors\n+    \/\/\n+\n+    \/** Default constructor. *\/\n+    public NamespaceSupport() {\n+    } \/\/ <init>()\n+\n+    \/\/\n+    \/\/ Public methods\n+    \/\/\n+\n+        \/**\n+         * @see org.apache.xerces.xni.NamespaceContext#reset()\n+         *\/\n+    public void reset() {\n+\n+        \/\/ reset namespace and context info\n+        fNamespaceSize = 0;\n+        fCurrentContext = 0;\n+        fContext[fCurrentContext] = fNamespaceSize;\n+\n+        \/\/ bind \"xml\" prefix to the XML uri\n+        fNamespace[fNamespaceSize++] = PREFIX_XML;\n+        fNamespace[fNamespaceSize++] = XML_URI;\n+        \/\/ bind \"xmlns\" prefix to the XMLNS uri\n+        fNamespace[fNamespaceSize++] = PREFIX_XMLNS;\n+        fNamespace[fNamespaceSize++] = XMLNS_URI;\n+        ++fCurrentContext;\n+\n+    } \/\/ reset(SymbolTable)\n+\n+\n+        \/**\n+         * @see org.apache.xerces.xni.NamespaceContext#pushContext()\n+         *\/\n+    public void pushContext() {\n+\n+        \/\/ extend the array, if necessary\n+        if (fCurrentContext + 1 == fContext.length) {\n+            int[] contextarray = new int[fContext.length * 2];\n+            System.arraycopy(fContext, 0, contextarray, 0, fContext.length);\n+            fContext = contextarray;\n+        }\n+\n+        \/\/ push context\n+        fContext[++fCurrentContext] = fNamespaceSize;\n+\n+    } \/\/ pushContext()\n+\n+\n+        \/**\n+         * @see org.apache.xerces.xni.NamespaceContext#popContext()\n+         *\/\n+    public void popContext() {\n+        fNamespaceSize = fContext[fCurrentContext--];\n+    } \/\/ popContext()\n+\n+        \/**\n+         * @see org.apache.xerces.xni.NamespaceContext#declarePrefix(String, String)\n+         *\/\n+    public boolean declarePrefix(String prefix, String uri) {\n+        \/\/ ignore \"xml\" and \"xmlns\" prefixes\n+        if (prefix == PREFIX_XML || prefix == PREFIX_XMLNS) {\n+            return false;\n+        }\n+\n+        \/\/ see if prefix already exists in current context\n+        for (int i = fNamespaceSize; i > fContext[fCurrentContext]; i -= 2) {\n+            \/\/if (fNamespace[i - 2] == prefix) {\n+                if (fNamespace[i - 2].equals(prefix) )  {\n+                \/\/ REVISIT: [Q] Should the new binding override the\n+                \/\/          previously declared binding or should it\n+                \/\/          it be ignored? -Ac\n+                \/\/ NOTE:    The SAX2 \"NamespaceSupport\" helper allows\n+                \/\/          re-bindings with the new binding overwriting\n+                \/\/          the previous binding. -Ac\n+                fNamespace[i - 1] = uri;\n+                return true;\n+            }\n+        }\n+\n+        \/\/ resize array, if needed\n+        if (fNamespaceSize == fNamespace.length) {\n+            String[] namespacearray = new String[fNamespaceSize * 2];\n+            System.arraycopy(fNamespace, 0, namespacearray, 0, fNamespaceSize);\n+            fNamespace = namespacearray;\n+        }\n+\n+        \/\/ bind prefix to uri in current context\n+        fNamespace[fNamespaceSize++] = prefix;\n+        fNamespace[fNamespaceSize++] = uri;\n+\n+        return true;\n+\n+    } \/\/ declarePrefix(String,String):boolean\n+\n+        \/**\n+         * @see org.apache.xerces.xni.NamespaceContext#getURI(String)\n+         *\/\n+    public String getURI(String prefix) {\n+\n+        \/\/ find prefix in current context\n+        for (int i = fNamespaceSize; i > 0; i -= 2) {\n+            \/\/if (fNamespace[i - 2] == prefix) {\n+                if (fNamespace[i - 2].equals(prefix) ) {\n+                return fNamespace[i - 1];\n+            }\n+        }\n+\n+        \/\/ prefix not found\n+        return null;\n+\n+    } \/\/ getURI(String):String\n+\n+\n+        \/**\n+         * @see org.apache.xerces.xni.NamespaceContext#getPrefix(String)\n+         *\/\n+    public String getPrefix(String uri) {\n+\n+        \/\/ find uri in current context\n+        for (int i = fNamespaceSize; i > 0; i -= 2) {\n+            \/\/if (fNamespace[i - 1] == uri) {\n+                if (fNamespace[i - 1].equals(uri) ) {\n+                \/\/if (getURI(fNamespace[i - 2]) == uri)\n+                        if (getURI(fNamespace[i - 2]).equals(uri) )\n+                    return fNamespace[i - 2];\n+            }\n+        }\n+\n+        \/\/ uri not found\n+        return null;\n+\n+    } \/\/ getPrefix(String):String\n+\n+\n+        \/**\n+         * @see org.apache.xerces.xni.NamespaceContext#getDeclaredPrefixCount()\n+         *\/\n+    public int getDeclaredPrefixCount() {\n+        return (fNamespaceSize - fContext[fCurrentContext]) \/ 2;\n+    } \/\/ getDeclaredPrefixCount():int\n+\n+        \/**\n+         * @see org.apache.xerces.xni.NamespaceContext#getDeclaredPrefixAt(int)\n+         *\/\n+    public String getDeclaredPrefixAt(int index) {\n+        return fNamespace[fContext[fCurrentContext] + index * 2];\n+    } \/\/ getDeclaredPrefixAt(int):String\n+\n+        \/**\n+         * @see org.apache.xerces.xni.NamespaceContext#getAllPrefixes()\n+         *\/\n+        public Enumeration getAllPrefixes() {\n+        int count = 0;\n+        if (fPrefixes.length < (fNamespace.length\/2)) {\n+            \/\/ resize prefix array\n+            String[] prefixes = new String[fNamespaceSize];\n+            fPrefixes = prefixes;\n+        }\n+        String prefix = null;\n+        boolean unique = true;\n+        for (int i = 2; i < (fNamespaceSize-2); i += 2) {\n+            prefix = fNamespace[i + 2];\n+            for (int k=0;k<count;k++){\n+                if (fPrefixes[k]==prefix){\n+                    unique = false;\n+                    break;\n+                }\n+            }\n+            if (unique){\n+                fPrefixes[count++] = prefix;\n+            }\n+            unique = true;\n+        }\n+                return new Prefixes(fPrefixes, count);\n+        }\n+\n+    protected final class Prefixes implements Enumeration {\n+        private String[] prefixes;\n+        private int counter = 0;\n+        private int size = 0;\n+\n+                \/**\n+                 * Constructor for Prefixes.\n+                 *\/\n+                public Prefixes(String [] prefixes, int size) {\n+                        this.prefixes = prefixes;\n+            this.size = size;\n+                }\n+\n+       \/**\n+                 * @see java.util.Enumeration#hasMoreElements()\n+                 *\/\n+                public boolean hasMoreElements() {\n+                        return (counter< size);\n+                }\n+\n+                \/**\n+                 * @see java.util.Enumeration#nextElement()\n+                 *\/\n+                public Object nextElement() {\n+            if (counter< size){\n+                return fPrefixes[counter++];\n+            }\n+                        throw new NoSuchElementException(\"Illegal access to Namespace prefixes enumeration.\");\n+                }\n+\n+        public String toString(){\n+            StringBuffer buf = new StringBuffer();\n+            for (int i=0;i<size;i++){\n+                buf.append(prefixes[i]);\n+                buf.append(\" \");\n+            }\n+\n+            return buf.toString();\n+        }\n+\n+}\n+\n+} \/\/ class NamespaceSupport\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/dom3\/NamespaceSupport.java","additions":315,"deletions":0,"binary":false,"changes":315,"status":"added"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -102,0 +104,32 @@\n+    \/\/ DOM Exceptions\n+    public static final String ER_FEATURE_NOT_FOUND = \"FEATURE_NOT_FOUND\";\n+    public static final String ER_FEATURE_NOT_SUPPORTED = \"FEATURE_NOT_SUPPORTED\";\n+    public static final String ER_STRING_TOO_LONG = \"DOMSTRING_SIZE_ERR\";\n+    public static final String ER_TYPE_MISMATCH_ERR = \"TYPE_MISMATCH_ERR\";\n+\n+    \/\/ DOM Level 3 load and save messages\n+    public static final String ER_NO_OUTPUT_SPECIFIED = \"no-output-specified\";\n+    public static final String ER_UNSUPPORTED_ENCODING = \"unsupported-encoding\";\n+    public static final String ER_ELEM_UNBOUND_PREFIX_IN_ENTREF = \"unbound-prefix-in-entity-reference\";\n+    public static final String ER_ATTR_UNBOUND_PREFIX_IN_ENTREF = \"unbound-prefix-in-entity-reference\";\n+    public static final String ER_CDATA_SECTIONS_SPLIT = \"cdata-sections-splitted\";\n+    public static final String ER_WF_INVALID_CHARACTER = \"wf-invalid-character\";\n+    public static final String ER_WF_INVALID_CHARACTER_IN_NODE_NAME = \"wf-invalid-character-in-node-name\";\n+\n+    \/\/ DOM Level 3 Implementation specific Exceptions\n+    public static final String ER_UNABLE_TO_SERIALIZE_NODE = \"ER_UNABLE_TO_SERIALIZE_NODE\";\n+    public static final String ER_WARNING_WF_NOT_CHECKED = \"ER_WARNING_WF_NOT_CHECKED\";\n+\n+    public static final String ER_WF_INVALID_CHARACTER_IN_COMMENT = \"ER_WF_INVALID_CHARACTER_IN_COMMENT\";\n+    public static final String ER_WF_INVALID_CHARACTER_IN_PI = \"ER_WF_INVALID_CHARACTER_IN_PI\";\n+    public static final String ER_WF_INVALID_CHARACTER_IN_CDATA = \"ER_WF_INVALID_CHARACTER_IN_CDATA\";\n+    public static final String ER_WF_INVALID_CHARACTER_IN_TEXT = \"ER_WF_INVALID_CHARACTER_IN_TEXT\";\n+    public static final String ER_WF_DASH_IN_COMMENT = \"ER_WF_DASH_IN_COMMENT\";\n+    public static final String ER_WF_LT_IN_ATTVAL = \"ER_WF_LT_IN_ATTVAL\";\n+    public static final String ER_WF_REF_TO_UNPARSED_ENT = \"ER_WF_REF_TO_UNPARSED_ENT\";\n+    public static final String ER_WF_REF_TO_EXTERNAL_ENT =  \"ER_WF_REF_TO_EXTERNAL_ENT\";\n+    public static final String ER_NS_PREFIX_CANNOT_BE_BOUND =  \"ER_NS_PREFIX_CANNOT_BE_BOUND\";\n+    public static final String ER_NULL_LOCAL_ELEMENT_NAME = \"ER_NULL_LOCAL_ELEMENT_NAME\";\n+    public static final String ER_NULL_LOCAL_ATTR_NAME = \"ER_NULL_LOCAL_ATTR_NAME\";\n+    public static final String ER_WRITING_INTERNAL_SUBSET = \"ER_WRITING_INTERNAL_SUBSET\";\n+\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/MsgKey.java","additions":37,"deletions":3,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -200,0 +202,91 @@\n+             {MsgKey.ER_FEATURE_NOT_FOUND,\n+             \"The parameter ''{0}'' is not recognized.\"},\n+\n+             {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+             \"The parameter ''{0}'' is recognized but the requested value cannot be set.\"},\n+\n+             {MsgKey.ER_STRING_TOO_LONG,\n+             \"The resulting string is too long to fit in a DOMString: ''{0}''.\"},\n+\n+             {MsgKey.ER_TYPE_MISMATCH_ERR,\n+             \"The value type for this parameter name is incompatible with the expected value type.\"},\n+\n+             {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+             \"The output destination for data to be written to was null.\"},\n+\n+             {MsgKey.ER_UNSUPPORTED_ENCODING,\n+             \"An unsupported encoding is encountered.\"},\n+\n+             {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+             \"The node could not be serialized.\"},\n+\n+             {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+             \"The CDATA Section contains one or more termination markers ']]>'.\"},\n+\n+             {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+                 \"An instance of the Well-Formedness checker could not be created.  The well-formed parameter was set to true but well-formedness checking can not be performed.\"\n+             },\n+\n+             {MsgKey.ER_WF_INVALID_CHARACTER,\n+                 \"The node ''{0}'' contains invalid XML characters.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                 \"An invalid XML character (Unicode: 0x{0}) was found in the comment.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                 \"An invalid XML character (Unicode: 0x{0}) was found in the processing instructiondata.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                 \"An invalid XML character (Unicode: 0x{0}) was found in the contents of the CDATASection.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                 \"An invalid XML character (Unicode: 0x{0}) was found in the node''s character data content.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                 \"An invalid XML character(s) was found in the {0} node named ''{1}''.\"\n+             },\n+\n+             { MsgKey.ER_WF_DASH_IN_COMMENT,\n+                 \"The string \\\"--\\\" is not permitted within comments.\"\n+             },\n+\n+             {MsgKey.ER_WF_LT_IN_ATTVAL,\n+                 \"The value of attribute \\\"{1}\\\" associated with an element type \\\"{0}\\\" must not contain the ''<'' character.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                 \"The unparsed entity reference \\\"&{0};\\\" is not permitted.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                 \"The external entity reference \\\"&{0};\\\" is not permitted in an attribute value.\"\n+             },\n+\n+             {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                 \"The prefix \\\"{0}\\\" can not be bound to namespace \\\"{1}\\\".\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                 \"The local name of element \\\"{0}\\\" is null.\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+                 \"The local name of attr \\\"{0}\\\" is null.\"\n+             },\n+\n+             { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"The replacement text of the entity node \\\"{0}\\\" contains an element node \\\"{1}\\\" with an unbound prefix \\\"{2}\\\".\"\n+             },\n+\n+             { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"The replacement text of the entity node \\\"{0}\\\" contains an attribute node \\\"{1}\\\" with an unbound prefix \\\"{2}\\\".\"\n+             },\n+\n+             { MsgKey.ER_WRITING_INTERNAL_SUBSET,\n+                 \"An error occured while writing the internal subset.\"\n+             },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages.java","additions":96,"deletions":3,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 1999-2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -125,1 +127,100 @@\n-        \"Scheme is required!\"}\n+        \"Scheme is required!\"},\n+\n+      \/*\n+       * Note to translators:  The words 'Properties' and\n+       * 'SerializerFactory' in this message are Java class names\n+       * and should not be translated.\n+       *\/\n+      {   MsgKey.ER_FACTORY_PROPERTY_MISSING,\n+          \"L''objecte de propietats passat a SerializerFactory no t\\u00e9 cap propietat ''{0}''.\" },\n+\n+      {   MsgKey.ER_ENCODING_NOT_SUPPORTED,\n+          \"Av\\u00eds: el temps d''execuci\\u00f3 de Java no d\\u00f3na suport a la codificaci\\u00f3 ''{0}''.\" },\n+\n+       {MsgKey.ER_FEATURE_NOT_FOUND,\n+       \"El par\\u00e0metre ''{0}'' no es reconeix.\"},\n+\n+       {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+       \"El par\\u00e0metre ''{0}'' es reconeix per\\u00f2 el valor sol\\u00b7licitat no es pot establir.\"},\n+\n+       {MsgKey.ER_STRING_TOO_LONG,\n+       \"La cadena resultant \\u00e9s massa llarga per cabre en una DOMString: ''{0}''.\"},\n+\n+       {MsgKey.ER_TYPE_MISMATCH_ERR,\n+       \"El tipus de valor per a aquest nom de par\\u00e0metre \\u00e9s incompatible amb el tipus de valor esperat.\"},\n+\n+       {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+       \"La destinaci\\u00f3 de sortida per a les dades que s'ha d'escriure era nul\\u00b7la.\"},\n+\n+       {MsgKey.ER_UNSUPPORTED_ENCODING,\n+       \"S'ha trobat una codificaci\\u00f3 no suportada.\"},\n+\n+       {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+       \"El node no s'ha pogut serialitzat.\"},\n+\n+       {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+       \"La secci\\u00f3 CDATA cont\\u00e9 un o m\\u00e9s marcadors d'acabament ']]>'.\"},\n+\n+       {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+           \"No s'ha pogut crear cap inst\\u00e0ncia per comprovar si t\\u00e9 un format correcte o no. El par\\u00e0metre del tipus ben format es va establir en cert, per\\u00f2 la comprovaci\\u00f3 de format no s'ha pogut realitzar.\"\n+       },\n+\n+       {MsgKey.ER_WF_INVALID_CHARACTER,\n+           \"El node ''{0}'' cont\\u00e9 car\\u00e0cters XML no v\\u00e0lids.\"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+           \"S''ha trobat un car\\u00e0cter XML no v\\u00e0lid (Unicode: 0x{0}) en el comentari.\"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+           \"S''ha trobat un car\\u00e0cter XML no v\\u00e0lid (Unicode: 0x{0}) en les dades d''instrucci\\u00f3 de proc\\u00e9s.\"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+           \"S''ha trobat un car\\u00e0cter XML no v\\u00e0lid (Unicode: 0x''{0})'' en els continguts de la CDATASection.\"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+           \"S''ha trobat un car\\u00e0cter XML no v\\u00e0lid (Unicode: 0x''{0})'' en el contingut de dades de car\\u00e0cter del node.\"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+           \"S''han trobat car\\u00e0cters XML no v\\u00e0lids al node {0} anomenat ''{1}''.\"\n+       },\n+\n+       { MsgKey.ER_WF_DASH_IN_COMMENT,\n+           \"La cadena \\\"--\\\" no est\\u00e0 permesa dins dels comentaris.\"\n+       },\n+\n+       {MsgKey.ER_WF_LT_IN_ATTVAL,\n+           \"El valor d''atribut \\\"{1}\\\" associat amb un tipus d''element \\\"{0}\\\" no pot contenir el car\\u00e0cter ''<''.\"\n+       },\n+\n+       {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+           \"La refer\\u00e8ncia de l''entitat no analitzada \\\"&{0};\\\" no est\\u00e0 permesa.\"\n+       },\n+\n+       {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+           \"La refer\\u00e8ncia externa de l''entitat \\\"&{0};\\\" no est\\u00e0 permesa en un valor d''atribut.\"\n+       },\n+\n+       {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+           \"El prefix \\\"{0}\\\" no es pot vincular a l''espai de noms \\\"{1}\\\".\"\n+       },\n+\n+       {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+           \"El nom local de l''element \\\"{0}\\\" \\u00e9s nul.\"\n+       },\n+\n+       {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+           \"El nom local d''atr \\\"{0}\\\" \\u00e9s nul.\"\n+       },\n+\n+       { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+           \"El text de recanvi del node de l''entitat \\\"{0}\\\" cont\\u00e9 un node d''element \\\"{1}\\\" amb un prefix de no enlla\\u00e7at \\\"{2}\\\".\"\n+       },\n+\n+       { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+           \"El text de recanvi del node de l''entitat \\\"{0}\\\" cont\\u00e9 un node d''atribut \\\"{1}\\\" amb un prefix de no enlla\\u00e7at \\\"{2}\\\".\"\n+       },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_ca.java","additions":105,"deletions":4,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 1999-2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -117,1 +119,100 @@\n-        \"Je vy\\u017eadov\\u00e1no sch\\u00e9ma!\"}\n+        \"Je vy\\u017eadov\\u00e1no sch\\u00e9ma!\"},\n+\n+      \/*\n+       * Note to translators:  The words 'Properties' and\n+       * 'SerializerFactory' in this message are Java class names\n+       * and should not be translated.\n+       *\/\n+      {   MsgKey.ER_FACTORY_PROPERTY_MISSING,\n+          \"Objekt vlastnost\\u00ed p\\u0159edan\\u00fd faktorii SerializerFactory neobsahuje vlastnost ''{0}''. \" },\n+\n+      {   MsgKey.ER_ENCODING_NOT_SUPPORTED,\n+          \"Varov\\u00e1n\\u00ed: K\\u00f3dov\\u00e1n\\u00ed ''{0}'' nen\\u00ed v b\\u011bhov\\u00e9m prost\\u0159ed\\u00ed Java podporov\\u00e1no.\" },\n+\n+       {MsgKey.ER_FEATURE_NOT_FOUND,\n+       \"Parametr ''{0}'' nebyl rozpozn\\u00e1n.\"},\n+\n+       {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+       \"Parametr ''{0}'' byl rozpozn\\u00e1n, ale nelze nastavit po\\u017eadovanou hodnotu.\"},\n+\n+       {MsgKey.ER_STRING_TOO_LONG,\n+       \"V\\u00fdsledn\\u00fd \\u0159et\\u011bzec je p\\u0159\\u00edli\\u0161 dlouh\\u00fd pro \\u0159et\\u011bzec DOMString: ''{0}''.\"},\n+\n+       {MsgKey.ER_TYPE_MISMATCH_ERR,\n+       \"Typ hodnoty pro tento n\\u00e1zev parametru nen\\u00ed kompatibiln\\u00ed s o\\u010dek\\u00e1van\\u00fdm typem hodnoty.\"},\n+\n+       {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+       \"C\\u00edlov\\u00e9 um\\u00edst\\u011bn\\u00ed v\\u00fdstupu pro data ur\\u010den\\u00e1 k z\\u00e1pisu je rovno hodnot\\u011b Null. \"},\n+\n+       {MsgKey.ER_UNSUPPORTED_ENCODING,\n+       \"Bylo nalezeno nepodporovan\\u00e9 k\\u00f3dov\\u00e1n\\u00ed.\"},\n+\n+       {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+       \"Nelze prov\\u00e9st serializaci uzlu. \"},\n+\n+       {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+       \"Sekce CDATA obsahuje jednu nebo v\\u00edce ukon\\u010dovac\\u00edch zna\\u010dek ']]>'.\"},\n+\n+       {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+           \"Nelze vytvo\\u0159it instanci modulu pro kontrolu spr\\u00e1vn\\u00e9ho utvo\\u0159en\\u00ed. Parametr spr\\u00e1vn\\u00e9ho utvo\\u0159en\\u00ed byl nastaven na hodnotu true, nepoda\\u0159ilo se v\\u0161ak zkontrolovat spr\\u00e1vnost utvo\\u0159en\\u00ed. \"\n+       },\n+\n+       {MsgKey.ER_WF_INVALID_CHARACTER,\n+           \"Uzel ''{0}'' obsahuje neplatn\\u00e9 znaky XML. \"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+           \"V pozn\\u00e1mce byl zji\\u0161t\\u011bn neplatn\\u00fd znak XML (Unicode: 0x{0}).\"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+           \"V datech instrukce zpracov\\u00e1n\\u00ed byl nalezen neplatn\\u00fd znak XML (Unicode: 0x{0}).\"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+           \"V odd\\u00edlu CDATASection byl nalezen neplatn\\u00fd znak XML (Unicode: 0x{0}).\"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+           \"V obsahu znakov\\u00fdch dat uzlu byl nalezen neplatn\\u00fd znak XML (Unicode: 0x{0}).\"\n+       },\n+\n+       { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+           \"V objektu {0} s n\\u00e1zvem ''{1}'' byl nalezen neplatn\\u00fd znak XML. \"\n+       },\n+\n+       { MsgKey.ER_WF_DASH_IN_COMMENT,\n+           \"V pozn\\u00e1mk\\u00e1ch nen\\u00ed povolen \\u0159et\\u011bzec \\\"--\\\".\"\n+       },\n+\n+       {MsgKey.ER_WF_LT_IN_ATTVAL,\n+           \"Hodnota atributu \\\"{1}\\\" souvisej\\u00edc\\u00edho s typem prvku \\\"{0}\\\" nesm\\u00ed obsahovat znak ''<''.\"\n+       },\n+\n+       {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+           \"Odkaz na neanalyzovanou entitu \\\"&{0};\\\" nen\\u00ed povolen.\"\n+       },\n+\n+       {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+           \"Extern\\u00ed odkaz na entitu \\\"&{0};\\\" nen\\u00ed v hodnot\\u011b atributu povolen.\"\n+       },\n+\n+       {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+           \"P\\u0159edpona \\\"{0}\\\" nesm\\u00ed b\\u00fdt v\\u00e1zan\\u00e1 k oboru n\\u00e1zv\\u016f \\\"{1}\\\".\"\n+       },\n+\n+       {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+           \"Lok\\u00e1ln\\u00ed n\\u00e1zev prvku \\\"{0}\\\" m\\u00e1 hodnotu Null. \"\n+       },\n+\n+       {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+           \"Lok\\u00e1ln\\u00ed n\\u00e1zev atributu \\\"{0}\\\" m\\u00e1 hodnotu Null. \"\n+       },\n+\n+       { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+           \"Nov\\u00fd text uzlu entity \\\"{0}\\\" obsahuje uzel prvku \\\"{1}\\\" s nesv\\u00e1zanou p\\u0159edponou \\\"{2}\\\".\"\n+       },\n+\n+       { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+           \"Nov\\u00fd text uzlu entity \\\"{0}\\\" obsahuje uzel atributu \\\"{1}\\\" s nesv\\u00e1zanou p\\u0159edponou \\\"{2}\\\". \"\n+       },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_cs.java","additions":105,"deletions":4,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -200,0 +202,87 @@\n+             {MsgKey.ER_FEATURE_NOT_FOUND,\n+             \"Der Parameter ''{0}'' wird nicht erkannt.\"},\n+\n+             {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+             \"Der Parameter ''{0}'' wird erkannt, der angeforderte Wert kann jedoch nicht festgelegt werden.\"},\n+\n+             {MsgKey.ER_STRING_TOO_LONG,\n+             \"Die Ergebniszeichenfolge ist zu lang f\\u00fcr eine DOM-Zeichenfolge: ''{0}''.\"},\n+\n+             {MsgKey.ER_TYPE_MISMATCH_ERR,\n+             \"Der Werttyp f\\u00fcr diesen Parameternamen ist nicht kompatibel mit dem erwarteten Werttyp.\"},\n+\n+             {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+             \"Das Ausgabeziel f\\u00fcr die zu schreibenden Daten war leer.\"},\n+\n+             {MsgKey.ER_UNSUPPORTED_ENCODING,\n+             \"Eine nicht unterst\\u00fctzte Codierung wurde festgestellt.\"},\n+\n+             {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+             \"Der Knoten konnte nicht serialisiert werden.\"},\n+\n+             {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+             \"Der Abschnitt CDATA enth\\u00e4lt mindestens eine Beendigungsmarkierung ']]>'.\"},\n+\n+             {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+                 \"Eine Instanz des Pr\\u00fcfprogramms f\\u00fcr korrekte Formatierung konnte nicht erstellt werden.  F\\u00fcr den korrekt formatierten Parameter wurde der Wert 'True' festgelegt, die Pr\\u00fcfung auf korrekte Formatierung kann jedoch nicht durchgef\\u00fchrt werden.\"\n+             },\n+\n+             {MsgKey.ER_WF_INVALID_CHARACTER,\n+                 \"Der Knoten ''{0}'' enth\\u00e4lt ung\\u00fcltige XML-Zeichen.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                 \"Im Kommentar wurde ein ung\\u00fcltiges XML-Zeichen (Unicode: 0x{0}) gefunden.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                 \"In der Verarbeitungsanweisung wurde ein ung\\u00fcltiges XML-Zeichen (Unicode: 0x{0}) gefunden.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                 \"Im Inhalt von CDATASection wurde ein ung\\u00fcltiges XML-Zeichen (Unicode: 0x{0}) gefunden.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                 \"Ein ung\\u00fcltiges XML-Zeichen  (Unicode: 0x{0}) wurde im Inhalt der Zeichendaten des Knotens gefunden.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                 \"Ung\\u00fcltige XML-Zeichen wurden gefunden in {0} im Knoten ''{1}''.\"\n+             },\n+\n+             { MsgKey.ER_WF_DASH_IN_COMMENT,\n+                 \"Die Zeichenfolge \\\"--\\\" ist innerhalb von Kommentaren nicht zul\\u00e4ssig.\"\n+             },\n+\n+             {MsgKey.ER_WF_LT_IN_ATTVAL,\n+                 \"Der Wert des Attributs \\\"{1}\\\" mit einem Elementtyp \\\"{0}\\\" darf nicht das Zeichen ''<'' enthalten.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                 \"Der syntaktisch nicht analysierte Entit\\u00e4tenverweis \\\"&{0};\\\" ist nicht zul\\u00e4ssig.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                 \"Der externe Entit\\u00e4tenverweis \\\"&{0};\\\" ist in einem Attributwert nicht zul\\u00e4ssig.\"\n+             },\n+\n+             {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                 \"Das Pr\\u00e4fix \\\"{0}\\\" kann nicht an den Namensbereich \\\"{1}\\\" gebunden werden.\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                 \"Der lokale Name von Element \\\"{0}\\\" ist nicht angegeben.\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+                 \"Der lokale Name des Attributs \\\"{0}\\\" ist nicht angegeben.\"\n+             },\n+\n+             { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"Der Ersatztext des Entit\\u00e4tenknotens \\\"{0}\\\" enth\\u00e4lt einen Elementknoten \\\"{1}\\\" mit einem nicht gebundenen Pr\\u00e4fix \\\"{2}\\\".\"\n+             },\n+\n+             { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"Der Ersatztext des Entit\\u00e4tenknotens \\\"{0}\\\" enth\\u00e4lt einen Attributknoten \\\"{1}\\\" mit einem nicht gebundenen Pr\\u00e4fix \\\"{2}\\\".\"\n+             },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_de.java","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -198,1 +200,85 @@\n-                \"Advertencia: el tiempo de ejecuci\\u00F3n de Java no soporta la codificaci\\u00F3n ''{0}''.\" },\n+                \"Aviso: La codificaci\\u00f3n ''{0}'' no est\\u00e1 soportada por Java Runtime.\" },\n+\n+             {MsgKey.ER_FEATURE_NOT_FOUND,\n+             \"El par\\u00e1metro ''{0}'' no se reconoce.\"},\n+\n+             {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+             \"Se reconoce el par\\u00e1metro ''{0}'' pero no puede establecerse el valor solicitado.\"},\n+\n+             {MsgKey.ER_STRING_TOO_LONG,\n+             \"La serie producida es demasiado larga para ajustarse a DOMString: ''{0}''.\"},\n+\n+             {MsgKey.ER_TYPE_MISMATCH_ERR,\n+             \"El tipo de valor para este nombre de par\\u00e1metro es incompatible con el tipo de valor esperado.\"},\n+\n+             {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+             \"El destino de salida de escritura de los datos es nulo.\"},\n+\n+             {MsgKey.ER_UNSUPPORTED_ENCODING,\n+             \"Se ha encontrado una codificaci\\u00f3n no soportada.\"},\n+\n+             {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+             \"No se ha podido serializar el nodo.\"},\n+\n+             {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+             \"La secci\\u00f3n CDATA contiene uno o m\\u00e1s marcadores ']]>' de terminaci\\u00f3n.\"},\n+\n+             {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+                 \"No se ha podido crear una instancia del comprobador de gram\\u00e1tica correcta.  El par\\u00e1metro well-formed se ha establecido en true pero no se puede realizar la comprobaci\\u00f3n de gram\\u00e1tica correcta.\"\n+             },\n+\n+             {MsgKey.ER_WF_INVALID_CHARACTER,\n+                 \"El nodo ''{0}'' contiene caracteres XML no v\\u00e1lidos.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                 \"Se ha encontrado un car\\u00e1cter XML no v\\u00e1lido (Unicode: 0x{0}) en el comentario.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                 \"Se ha encontrado un car\\u00e1cter XML no v\\u00e1lido (Unicode: 0x{0}) en los datos de la instrucci\\u00f3n de proceso.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                 \"Se ha encontrado un car\\u00e1cter XML no v\\u00e1lido (Unicode: 0x{0}) en el contenido de CDATASection.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                 \"Se ha encontrado un car\\u00e1cter XML no v\\u00e1lido (Unicode: 0x{0}) en el contenido de datos de caracteres del nodo.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                 \"Se ha encontrado un car\\u00e1cter o caracteres XML no v\\u00e1lidos en el nodo {0} denominado ''{1}''.\"\n+             },\n+\n+             { MsgKey.ER_WF_DASH_IN_COMMENT,\n+                 \"No se permite la serie \\\"--\\\" dentro de los comentarios.\"\n+             },\n+\n+             {MsgKey.ER_WF_LT_IN_ATTVAL,\n+                 \"El valor del atributo \\\"{1}\\\" asociado a un tipo de elemento \\\"{0}\\\" no debe contener el car\\u00e1cter ''''<''''.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                 \"No se permite la referencia de entidad no analizada \\\"&{0};\\\".\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                 \"La referencia de entidad externa \\\"&{0};\\\" no est\\u00e1 permitida en un valor de atributo.\"\n+             },\n+\n+             {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                 \"No se puede encontrar el prefijo \\\"{0}\\\" en el espacio de nombres \\\"{1}\\\".\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                 \"El nombre local del elemento \\\"{0}\\\" es null.\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+                 \"El nombre local del atributo \\\"{0}\\\" es null.\"\n+             },\n+\n+             { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"El texto de sustituci\\u00f3n del nodo de entidad \\\"{0}\\\" contiene un nodo de elemento \\\"{1}\\\" con un prefijo no enlazado \\\"{2}\\\".\"\n+             },\n@@ -200,0 +286,3 @@\n+             { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"El texto de sustituci\\u00f3n del nodo de entidad \\\"{0}\\\" contiene un nodo de atributo \\\"{1}\\\" con un prefijo no enlazado \\\"{2}\\\".\"\n+             },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_es.java","additions":93,"deletions":4,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -200,0 +202,87 @@\n+             {MsgKey.ER_FEATURE_NOT_FOUND,\n+             \"Le param\\u00e8tre ''{0}'' n''est pas reconnu.\"},\n+\n+             {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+             \"Le param\\u00e8tre ''{0}'' est reconnu mas la valeur demand\\u00e9e ne peut pas \\u00eatre d\\u00e9finie.\"},\n+\n+             {MsgKey.ER_STRING_TOO_LONG,\n+             \"La cha\\u00eene obtenue est trop longue pour un DOMString : ''{0}''.\"},\n+\n+             {MsgKey.ER_TYPE_MISMATCH_ERR,\n+             \"Le type de valeur de ce param\\u00e8tre est incompatible avec le type de valeur attendu.\"},\n+\n+             {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+             \"La sortie de destination des donn\\u00e9es \\u00e0 \\u00e9crire \\u00e9tait vide.\"},\n+\n+             {MsgKey.ER_UNSUPPORTED_ENCODING,\n+             \"Codage non pris en charge.\"},\n+\n+             {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+             \"Le noeud ne peut pas \\u00eatre s\\u00e9rialis\\u00e9.\"},\n+\n+             {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+             \"La section CDATA contient un ou plusieurs marqueurs de fin ']]>'.\"},\n+\n+             {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+                 \"Aucune instance du programme de v\\u00e9rification de la formation n'a pu \\u00eatre cr\\u00e9\\u00e9e.  La valeur true a \\u00e9t\\u00e9 attribu\\u00e9e au param\\u00e8tre well-formed mais la v\\u00e9rification de la formation n'a pas pu \\u00eatre effectu\\u00e9e.\"\n+             },\n+\n+             {MsgKey.ER_WF_INVALID_CHARACTER,\n+                 \"Le noeud ''{0}'' contient des caract\\u00e8res XML non valides.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                 \"Un caract\\u00e8re XML non valide (Unicode : 0x{0}) a \\u00e9t\\u00e9 trouv\\u00e9 dans le commentaire.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                 \"Un caract\\u00e8re XML non valide (Unicode : 0x{0}) a \\u00e9t\\u00e9 trouv\\u00e9 dans les donn\\u00e9es de l''instruction de traitement.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                 \"Un caract\\u00e8re XML non valide (Unicode: 0x{0}) a \\u00e9t\\u00e9 trouv\\u00e9 dans le contenu de la CDATASection\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                 \"Un caract\\u00e8re XML non valide (Unicode : 0x{0}) a \\u00e9t\\u00e9 trouv\\u00e9 dans le contenu des donn\\u00e9es de type caract\\u00e8res du noeud.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                 \"Un ou plusieurs caract\\u00e8res non valides ont \\u00e9t\\u00e9 trouv\\u00e9s dans le noeud {0} nomm\\u00e9 ''{1}''.\"\n+             },\n+\n+             { MsgKey.ER_WF_DASH_IN_COMMENT,\n+                 \"La cha\\u00eene \\\"--\\\" est interdite dans des commentaires.\"\n+             },\n+\n+             {MsgKey.ER_WF_LT_IN_ATTVAL,\n+                 \"La valeur de l''attribut \\\"{1}\\\" associ\\u00e9 \\u00e0 un type d''\\u00e9l\\u00e9ment \\\"{0}\\\" ne doit pas contenir le caract\\u00e8re ''<''.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                 \"La r\\u00e9f\\u00e9rence d''entit\\u00e9 non analys\\u00e9e \\\"&{0};\\\" n''est pas admise.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                 \"La r\\u00e9f\\u00e9rence d''entit\\u00e9 externe \\\"&{0};\\\" n''est pas admise dans une valeur d''attribut.\"\n+             },\n+\n+             {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                 \"Le pr\\u00e9fixe \\\"{0}\\\" ne peut pas \\u00eatre li\\u00e9 \\u00e0 l''espace de noms \\\"{1}\\\".\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                 \"Le nom local de l''\\u00e9l\\u00e9ment \\\"{0}\\\" a une valeur null.\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+                 \"Le nom local de l''attribut \\\"{0}\\\" a une valeur null.\"\n+             },\n+\n+             { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"le texte de remplacement du noeud de l''entit\\u00e9 \\\"{0}\\\" contaient un noeud d''\\u00e9l\\u00e9ment \\\"{1}\\\" avec un pr\\u00e9fixe non li\\u00e9 \\\"{2}\\\".\"\n+             },\n+\n+             { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"Le texte de remplacement du noeud de l''entit\\u00e9 \\\"{0}\\\" contient un noeud d''attribut \\\"{1}\\\" avec un pr\\u00e9fixe non li\\u00e9 \\\"{2}\\\".\"\n+             },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_fr.java","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -200,0 +202,87 @@\n+             {MsgKey.ER_FEATURE_NOT_FOUND,\n+             \"Il parametro ''{0}'' non \\u00e8 riconosciuto.\"},\n+\n+             {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+             \"Il parametro ''{0}'' \\u00e8 riconosciuto ma non \\u00e8 possibile impostare il valore richiesto.\"},\n+\n+             {MsgKey.ER_STRING_TOO_LONG,\n+             \"La stringa risultante \\u00e8 troppo lunga per essere inserita in DOMString: ''{0}''.\"},\n+\n+             {MsgKey.ER_TYPE_MISMATCH_ERR,\n+             \"Il tipo di valore per questo nome di parametro non \\u00e8 compatibile con il tipo di valore previsto.\"},\n+\n+             {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+             \"La destinazione di output in cui scrivere i dati era nulla.\"},\n+\n+             {MsgKey.ER_UNSUPPORTED_ENCODING,\n+             \"\\u00c8 stata rilevata una codifica non supportata.\"},\n+\n+             {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+             \"Impossibile serializzare il nodo.\"},\n+\n+             {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+             \"La Sezione CDATA contiene uno o pi\\u00f9 markers di termine ']]>'.\"},\n+\n+             {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+                 \"Impossibile creare un'istanza del controllore Well-Formedness.  Il parametro well-formed \\u00e8 stato impostato su true ma non \\u00e8 possibile eseguire i controlli well-formedness.\"\n+             },\n+\n+             {MsgKey.ER_WF_INVALID_CHARACTER,\n+                 \"Il nodo ''{0}'' contiene caratteri XML non validi.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                 \"Trovato un carattere XML non valido (Unicode: 0x{0}) nel commento.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                 \"Carattere XML non valido (Unicode: 0x{0}) rilevato nell''elaborazione di instructiondata.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                 \"Carattere XML non valido (Unicode: 0x{0}) rilevato nel contenuto di CDATASection.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                 \"Carattere XML non valido (Unicode: 0x{0}) rilevato nel contenuto dati di caratteri del nodo. \"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                 \"Carattere XML non valido rilevato nel nodo {0} denominato ''{1}''.\"\n+             },\n+\n+             { MsgKey.ER_WF_DASH_IN_COMMENT,\n+                 \"La stringa \\\"--\\\" non \\u00e8 consentita nei commenti.\"\n+             },\n+\n+             {MsgKey.ER_WF_LT_IN_ATTVAL,\n+                 \"Il valore dell''''attributo \\\"{1}\\\" associato con un tipo di elemento \\\"{0}\\\" non deve contenere il carattere ''<''.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                 \"Il riferimento entit\\u00e0 non analizzata \\\"&{0};\\\" non \\u00e8 permesso.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                 \"Il riferimento all''''entit\\u00e0 esterna \\\"&{0};\\\" non \\u00e8 permesso in un valore attributo.\"\n+             },\n+\n+             {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                 \"Il prefisso \\\"{0}\\\" non pu\\u00f2 essere associato allo spazio nome \\\"{1}\\\".\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                 \"Il nome locale dell''''elemento \\\"{0}\\\" \\u00e8 null.\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+                 \"Il nome locale dell''''attributo \\\"{0}\\\" \\u00e8  null.\"\n+             },\n+\n+             { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"Il testo di sostituzione del nodo di entit\\u00e0 \\\"{0}\\\" contiene un nodo di elemento \\\"{1}\\\" con un prefisso non associato \\\"{2}\\\".\"\n+             },\n+\n+             { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"Il testo di sostituzione del nodo di entit\\u00e0 \\\"{0}\\\" contiene un nodo di attributo \\\"{1}\\\" con un prefisso non associato \\\"{2}\\\".\"\n+             },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_it.java","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -200,0 +202,87 @@\n+             {MsgKey.ER_FEATURE_NOT_FOUND,\n+             \"\\u30d1\\u30e9\\u30e1\\u30fc\\u30bf\\u30fc ''{0}'' \\u306f\\u8a8d\\u8b58\\u3055\\u308c\\u307e\\u305b\\u3093\\u3002\"},\n+\n+             {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+             \"\\u30d1\\u30e9\\u30e1\\u30fc\\u30bf\\u30fc ''{0}'' \\u306f\\u8a8d\\u8b58\\u3055\\u308c\\u307e\\u3059\\u304c\\u3001\\u8981\\u6c42\\u3055\\u308c\\u305f\\u5024\\u306f\\u8a2d\\u5b9a\\u3067\\u304d\\u307e\\u305b\\u3093\\u3002\"},\n+\n+             {MsgKey.ER_STRING_TOO_LONG,\n+             \"\\u7d50\\u679c\\u306e\\u30b9\\u30c8\\u30ea\\u30f3\\u30b0\\u304c\\u9577\\u3059\\u304e\\u308b\\u305f\\u3081\\u3001DOMString \\u5185\\u306b\\u53ce\\u307e\\u308a\\u307e\\u305b\\u3093: ''{0}''\\u3002\"},\n+\n+             {MsgKey.ER_TYPE_MISMATCH_ERR,\n+             \"\\u3053\\u306e\\u30d1\\u30e9\\u30e1\\u30fc\\u30bf\\u30fc\\u540d\\u306e\\u5024\\u306e\\u578b\\u306f\\u3001\\u671f\\u5f85\\u3055\\u308c\\u308b\\u5024\\u306e\\u578b\\u3068\\u4e0d\\u9069\\u5408\\u3067\\u3059\\u3002\"},\n+\n+             {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+             \"\\u66f8\\u304d\\u8fbc\\u307e\\u308c\\u308b\\u30c7\\u30fc\\u30bf\\u306e\\u51fa\\u529b\\u5b9b\\u5148\\u304c\\u30cc\\u30eb\\u3067\\u3059\\u3002\"},\n+\n+             {MsgKey.ER_UNSUPPORTED_ENCODING,\n+             \"\\u30b5\\u30dd\\u30fc\\u30c8\\u3055\\u308c\\u306a\\u3044\\u30a8\\u30f3\\u30b3\\u30fc\\u30c9\\u304c\\u691c\\u51fa\\u3055\\u308c\\u307e\\u3057\\u305f\\u3002\"},\n+\n+             {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+             \"\\u30ce\\u30fc\\u30c9\\u3092\\u76f4\\u5217\\u5316\\u3067\\u304d\\u307e\\u305b\\u3093\\u3067\\u3057\\u305f\\u3002\"},\n+\n+             {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+             \"CDATA \\u30bb\\u30af\\u30b7\\u30e7\\u30f3\\u306b 1 \\u3064\\u4ee5\\u4e0a\\u306e\\u7d42\\u4e86\\u30de\\u30fc\\u30ab\\u30fc ']]>' \\u304c\\u542b\\u307e\\u308c\\u3066\\u3044\\u307e\\u3059\\u3002\"},\n+\n+             {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+                 \"\\u6574\\u5f62\\u5f0f\\u6027\\u30c1\\u30a7\\u30c3\\u30ab\\u30fc\\u306e\\u30a4\\u30f3\\u30b9\\u30bf\\u30f3\\u30b9\\u3092\\u4f5c\\u6210\\u3067\\u304d\\u307e\\u305b\\u3093\\u3067\\u3057\\u305f\\u3002  well-formed \\u30d1\\u30e9\\u30e1\\u30fc\\u30bf\\u30fc\\u306e\\u8a2d\\u5b9a\\u306f true \\u3067\\u3057\\u305f\\u304c\\u3001\\u6574\\u5f62\\u5f0f\\u6027\\u306e\\u691c\\u67fb\\u306f\\u5b9f\\u884c\\u3067\\u304d\\u307e\\u305b\\u3093\\u3002\"\n+             },\n+\n+             {MsgKey.ER_WF_INVALID_CHARACTER,\n+                 \"\\u30ce\\u30fc\\u30c9 ''{0}'' \\u306b\\u7121\\u52b9\\u306a XML \\u6587\\u5b57\\u304c\\u3042\\u308a\\u307e\\u3059\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                 \"\\u30b3\\u30e1\\u30f3\\u30c8\\u306e\\u4e2d\\u306b\\u7121\\u52b9\\u306a XML \\u6587\\u5b57 (Unicode: 0x{0}) \\u304c\\u898b\\u3064\\u304b\\u308a\\u307e\\u3057\\u305f\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                 \"\\u51e6\\u7406\\u547d\\u4ee4\\u30c7\\u30fc\\u30bf\\u306e\\u4e2d\\u306b\\u7121\\u52b9\\u306a XML \\u6587\\u5b57 (Unicode: 0x{0}) \\u304c\\u898b\\u3064\\u304b\\u308a\\u307e\\u3057\\u305f\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                 \"CDATA \\u30bb\\u30af\\u30b7\\u30e7\\u30f3\\u306e\\u4e2d\\u306b\\u7121\\u52b9\\u306a XML \\u6587\\u5b57 (Unicode: 0x{0}) \\u304c\\u898b\\u3064\\u304b\\u308a\\u307e\\u3057\\u305f\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                 \"\\u30ce\\u30fc\\u30c9\\u306e\\u6587\\u5b57\\u30c7\\u30fc\\u30bf\\u306e\\u5185\\u5bb9\\u306b\\u7121\\u52b9\\u306a XML \\u6587\\u5b57 (Unicode: 0x{0}) \\u304c\\u898b\\u3064\\u304b\\u308a\\u307e\\u3057\\u305f\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                 \"''{1}'' \\u3068\\u3044\\u3046\\u540d\\u524d\\u306e {0} \\u30ce\\u30fc\\u30c9\\u306e\\u4e2d\\u306b\\u7121\\u52b9\\u306a XML \\u6587\\u5b57\\u304c\\u898b\\u3064\\u304b\\u308a\\u307e\\u3057\\u305f\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_DASH_IN_COMMENT,\n+                 \"\\u30b9\\u30c8\\u30ea\\u30f3\\u30b0 \\\"--\\\" \\u306f\\u30b3\\u30e1\\u30f3\\u30c8\\u5185\\u3067\\u306f\\u4f7f\\u7528\\u3067\\u304d\\u307e\\u305b\\u3093\\u3002\"\n+             },\n+\n+             {MsgKey.ER_WF_LT_IN_ATTVAL,\n+                 \"\\u8981\\u7d20\\u578b \\\"{0}\\\" \\u306b\\u95a2\\u9023\\u3057\\u305f\\u5c5e\\u6027 \\\"{1}\\\" \\u306e\\u5024\\u306b\\u306f ''<'' \\u6587\\u5b57\\u3092\\u542b\\u3081\\u3066\\u306f\\u3044\\u3051\\u307e\\u305b\\u3093\\u3002\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                 \"\\u89e3\\u6790\\u5bfe\\u8c61\\u5916\\u5b9f\\u4f53\\u53c2\\u7167 \\\"&{0};\\\" \\u306f\\u8a31\\u53ef\\u3055\\u308c\\u307e\\u305b\\u3093\\u3002\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                 \"\\u5c5e\\u6027\\u5024\\u3067\\u306e\\u5916\\u90e8\\u5b9f\\u4f53\\u53c2\\u7167 \\\"&{0};\\\" \\u306f\\u8a31\\u53ef\\u3055\\u308c\\u307e\\u305b\\u3093\\u3002\"\n+             },\n+\n+             {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                 \"\\u63a5\\u982d\\u90e8 \\\"{0}\\\" \\u306f\\u540d\\u524d\\u7a7a\\u9593 \\\"{1}\\\" \\u306b\\u7d50\\u5408\\u3067\\u304d\\u307e\\u305b\\u3093\\u3002\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                 \"\\u8981\\u7d20 \\\"{0}\\\" \\u306e\\u30ed\\u30fc\\u30ab\\u30eb\\u540d\\u304c\\u30cc\\u30eb\\u3067\\u3059\\u3002\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+                 \"\\u5c5e\\u6027 \\\"{0}\\\" \\u306e\\u30ed\\u30fc\\u30ab\\u30eb\\u540d\\u304c\\u30cc\\u30eb\\u3067\\u3059\\u3002\"\n+             },\n+\n+             { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"\\u5b9f\\u4f53\\u30ce\\u30fc\\u30c9 \\\"{0}\\\" \\u306e\\u7f6e\\u63db\\u30c6\\u30ad\\u30b9\\u30c8\\u306b\\u3001\\u672a\\u7d50\\u5408\\u306e\\u63a5\\u982d\\u90e8 \\\"{2}\\\" \\u3092\\u6301\\u3064\\u8981\\u7d20\\u30ce\\u30fc\\u30c9 \\\"{1}\\\" \\u304c\\u542b\\u307e\\u308c\\u3066\\u3044\\u307e\\u3059\\u3002\"\n+             },\n+\n+             { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"\\u5b9f\\u4f53\\u30ce\\u30fc\\u30c9 \\\"{0}\\\" \\u306e\\u7f6e\\u63db\\u30c6\\u30ad\\u30b9\\u30c8\\u306b\\u3001\\u672a\\u7d50\\u5408\\u306e\\u63a5\\u982d\\u90e8 \\\"{2}\\\" \\u3092\\u6301\\u3064\\u5c5e\\u6027\\u30ce\\u30fc\\u30c9 \\\"{1}\\\" \\u304c\\u542b\\u307e\\u308c\\u3066\\u3044\\u307e\\u3059\\u3002\"\n+             },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_ja.java","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -200,0 +202,87 @@\n+             {MsgKey.ER_FEATURE_NOT_FOUND,\n+             \"''{0}'' \\ub9e4\\uac1c\\ubcc0\\uc218\\ub97c \\uc778\\uc2dd\\ud560 \\uc218 \\uc5c6\\uc2b5\\ub2c8\\ub2e4.\"},\n+\n+             {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+             \"''{0}'' \\ub9e4\\uac1c\\ubcc0\\uc218\\ub294 \\uc778\\uc2dd\\ud560 \\uc218 \\uc788\\uc73c\\ub098 \\uc694\\uccad\\ub41c \\uac12\\uc744 \\uc124\\uc815\\ud560 \\uc218 \\uc5c6\\uc2b5\\ub2c8\\ub2e4.\"},\n+\n+             {MsgKey.ER_STRING_TOO_LONG,\n+             \"\\uacb0\\uacfc \\ubb38\\uc790\\uc5f4\\uc774 \\ub108\\ubb34 \\uae38\\uc5b4 DOMString\\uc5d0 \\ub9de\\uc9c0 \\uc54a\\uc2b5\\ub2c8\\ub2e4: ''{0}'' \"},\n+\n+             {MsgKey.ER_TYPE_MISMATCH_ERR,\n+             \"\\uc774 \\ub9e4\\uac1c\\ubcc0\\uc218 \\uc774\\ub984\\uc5d0 \\ub300\\ud55c \\uac12 \\uc720\\ud615\\uc774 \\uc608\\uc0c1 \\uac12 \\uc720\\ud615\\uacfc \\ud638\\ud658\\ub418\\uc9c0 \\uc54a\\uc2b5\\ub2c8\\ub2e4.\"},\n+\n+             {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+             \"\\ub370\\uc774\\ud130\\ub97c \\uae30\\ub85d\\ud560 \\ucd9c\\ub825 \\ub300\\uc0c1\\uc774 \\ub110(null)\\uc785\\ub2c8\\ub2e4.\"},\n+\n+             {MsgKey.ER_UNSUPPORTED_ENCODING,\n+             \"\\uc9c0\\uc6d0\\ub418\\uc9c0 \\uc54a\\ub294 \\uc778\\ucf54\\ub529\\uc774 \\ubc1c\\uacac\\ub418\\uc5c8\\uc2b5\\ub2c8\\ub2e4.\"},\n+\n+             {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+             \"\\ub178\\ub4dc\\ub97c \\uc9c1\\ub82c\\ud654\\ud560 \\uc218 \\uc5c6\\uc2b5\\ub2c8\\ub2e4.\"},\n+\n+             {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+             \"CDATA \\uc139\\uc158\\uc5d0 \\uc885\\ub8cc \\ud45c\\uc2dc \\ubb38\\uc790\\uc778 ']]>'\\uac00 \\ud558\\ub098 \\uc774\\uc0c1 \\ud3ec\\ud568\\ub418\\uc5b4 \\uc788\\uc2b5\\ub2c8\\ub2e4.\"},\n+\n+             {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+                 \"Well-Formedness \\uac80\\uc0ac\\uae30\\uc758 \\uc778\\uc2a4\\ud134\\uc2a4\\ub97c \\uc791\\uc131\\ud560 \\uc218 \\uc5c6\\uc2b5\\ub2c8\\ub2e4. Well-Formed \\ub9e4\\uac1c\\ubcc0\\uc218\\uac00 true\\ub85c \\uc124\\uc815\\ub418\\uc5c8\\uc9c0\\ub9cc Well-Formedness \\uac80\\uc0ac\\ub97c \\uc218\\ud589\\ud560 \\uc218 \\uc5c6\\uc2b5\\ub2c8\\ub2e4.\"\n+             },\n+\n+             {MsgKey.ER_WF_INVALID_CHARACTER,\n+                 \"''{0}'' \\ub178\\ub4dc\\uc5d0 \\uc720\\ud6a8\\ud558\\uc9c0 \\uc54a\\uc740 XML \\ubb38\\uc790\\uac00 \\uc788\\uc2b5\\ub2c8\\ub2e4.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                 \"\\uc124\\uba85\\uc5d0 \\uc720\\ud6a8\\ud558\\uc9c0 \\uc54a\\uc740 XML \\ubb38\\uc790(Unicode: 0x{0})\\uac00 \\uc788\\uc2b5\\ub2c8\\ub2e4. \"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                 \"\\ucc98\\ub9ac \\uba85\\ub839\\uc5b4 \\ub370\\uc774\\ud130\\uc5d0 \\uc720\\ud6a8\\ud558\\uc9c0 \\uc54a\\uc740 XML \\ubb38\\uc790(Unicode: 0x{0})\\uac00 \\uc788\\uc2b5\\ub2c8\\ub2e4 \"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                 \"CDATASection\\uc758 \\ub0b4\\uc6a9\\uc5d0 \\uc720\\ud6a8\\ud558\\uc9c0 \\uc54a\\uc740 XML \\ubb38\\uc790(Unicode: 0x{0})\\uac00 \\uc788\\uc2b5\\ub2c8\\ub2e4. \"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                 \"\\ub178\\ub4dc\\uc758 \\ubb38\\uc790 \\ub370\\uc774\\ud130 \\ub0b4\\uc6a9\\uc5d0 \\uc720\\ud6a8\\ud558\\uc9c0 \\uc54a\\uc740 XML \\ubb38\\uc790(Unicode: 0x{0})\\uac00 \\uc788\\uc2b5\\ub2c8\\ub2e4. \"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                 \"\\uc774\\ub984\\uc774 ''{1}''\\uc778 {0} \\ub178\\ub4dc\\uc5d0 \\uc720\\ud6a8\\ud558\\uc9c0 \\uc54a\\uc740 XML \\ubb38\\uc790\\uac00 \\uc788\\uc2b5\\ub2c8\\ub2e4. \"\n+             },\n+\n+             { MsgKey.ER_WF_DASH_IN_COMMENT,\n+                 \"\\uc124\\uba85 \\ub0b4\\uc5d0\\uc11c\\ub294 \\\"--\\\" \\ubb38\\uc790\\uc5f4\\uc774 \\ud5c8\\uc6a9\\ub418\\uc9c0 \\uc54a\\uc2b5\\ub2c8\\ub2e4.\"\n+             },\n+\n+             {MsgKey.ER_WF_LT_IN_ATTVAL,\n+                 \"\\\"{0}\\\" \\uc694\\uc18c \\uc720\\ud615\\uacfc \\uc5f0\\uad00\\ub41c \\\"{1}\\\" \\uc18d\\uc131\\uac12\\uc5d0 ''<'' \\ubb38\\uc790\\uac00 \\ud3ec\\ud568\\ub418\\uba74 \\uc548\\ub429\\ub2c8\\ub2e4.\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                 \"\\\"&{0};\\\"\\uc758 \\uad6c\\ubd84 \\ubd84\\uc11d\\ub418\\uc9c0 \\uc54a\\uc740 \\uc5d4\\ud2f0\\ud2f0 \\ucc38\\uc870\\ub294 \\ud5c8\\uc6a9\\ub418\\uc9c0 \\uc54a\\uc2b5\\ub2c8\\ub2e4. \"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                 \"\\uc18d\\uc131\\uac12\\uc5d0\\ub294 \\\"&{0};\\\" \\uc678\\ubd80 \\uc5d4\\ud2f0\\ud2f0 \\ucc38\\uc870\\uac00 \\ud5c8\\uc6a9\\ub418\\uc9c0 \\uc54a\\uc2b5\\ub2c8\\ub2e4. \"\n+             },\n+\n+             {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                 \"\\\"{0}\\\" \\uc811\\ub450\\ubd80\\ub97c \\\"{1}\\\" \\uc774\\ub984 \\uacf5\\uac04\\uc5d0 \\ubc14\\uc778\\ub4dc\\ud560 \\uc218 \\uc5c6\\uc2b5\\ub2c8\\ub2e4.\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                 \"\\\"{0}\\\" \\uc694\\uc18c\\uc758 \\ub85c\\uceec \\uc774\\ub984\\uc774 \\ub110(null)\\uc785\\ub2c8\\ub2e4.\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+                 \"\\\"{0}\\\" \\uc18d\\uc131\\uc758 \\ub85c\\uceec \\uc774\\ub984\\uc774 \\ub110(null)\\uc785\\ub2c8\\ub2e4.\"\n+             },\n+\n+             { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"\\\"{0}\\\" \\uc5d4\\ud2f0\\ud2f0 \\ub178\\ub4dc\\uc758 \\ub300\\uccb4 \\ud14d\\uc2a4\\ud2b8\\uc5d0 \\ubc14\\uc778\\ub4dc\\ub418\\uc9c0 \\uc54a\\uc740 \\uc811\\ub450\\ubd80 \\\"{2}\\\"\\uc744(\\ub97c) \\uac16\\ub294 \\\"{1}\\\" \\uc694\\uc18c \\ub178\\ub4dc\\uac00 \\uc788\\uc2b5\\ub2c8\\ub2e4.\"\n+             },\n+\n+             { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"\\\"{0}\\\" \\uc5d4\\ud2f0\\ud2f0 \\ub178\\ub4dc\\uc758 \\ub300\\uccb4 \\ud14d\\uc2a4\\ud2b8\\uc5d0 \\ubc14\\uc778\\ub4dc\\ub418\\uc9c0 \\uc54a\\uc740 \\uc811\\ub450\\ubd80 \\\"{2}\\\"\\uc744(\\ub97c) \\uac16\\ub294 \\\"{1}\\\" \\uc18d\\uc131 \\ub178\\ub4dc\\uac00 \\uc788\\uc2b5\\ub2c8\\ub2e4.\"\n+             },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_ko.java","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -200,0 +202,87 @@\n+             {MsgKey.ER_FEATURE_NOT_FOUND,\n+             \"O par\\u00e2metro ''{0}'' n\\u00e3o \\u00e9 reconhecido.\"},\n+\n+             {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+             \"O par\\u00e2metro ''{0}'' \\u00e9 reconhecido, mas o valor pedido n\\u00e3o pode ser definido. \"},\n+\n+             {MsgKey.ER_STRING_TOO_LONG,\n+             \"A cadeia resultante \\u00e9 muito longa para caber em uma DOMString: ''{0}''. \"},\n+\n+             {MsgKey.ER_TYPE_MISMATCH_ERR,\n+             \"O tipo de valor para este nome de par\\u00e2metro \\u00e9 incompat\\u00edvel com o tipo de valor esperado. \"},\n+\n+             {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+             \"O destino de sa\\u00edda para os dados a serem gravados era nulo. \"},\n+\n+             {MsgKey.ER_UNSUPPORTED_ENCODING,\n+             \"Uma codifica\\u00e7\\u00e3o n\\u00e3o suportada foi encontrada. \"},\n+\n+             {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+             \"O n\\u00f3 n\\u00e3o p\\u00f4de ser serializado.\"},\n+\n+             {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+             \"A Se\\u00e7\\u00e3o CDATA cont\\u00e9m um ou mais marcadores de t\\u00e9rmino ']]>'.\"},\n+\n+             {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+                 \"Uma inst\\u00e2ncia do verificador Well-Formedness n\\u00e3o p\\u00f4de ser criada. O par\\u00e2metro well-formed foi definido como true, mas a verifica\\u00e7\\u00e3o well-formedness n\\u00e3o pode ser executada.\"\n+             },\n+\n+             {MsgKey.ER_WF_INVALID_CHARACTER,\n+                 \"O n\\u00f3 ''{0}'' cont\\u00e9m caracteres XML inv\\u00e1lidos. \"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                 \"Um caractere XML inv\\u00e1lido (Unicode: 0x{0}) foi encontrado no coment\\u00e1rio. \"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                 \"Um caractere XML inv\\u00e1lido (Unicode: 0x{0}) foi encontrado no processo instructiondata.\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                 \"Um caractere XML inv\\u00e1lido (Unicode: 0x{0}) foi encontrado nos conte\\u00fados do CDATASection. \"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                 \"Um caractere XML inv\\u00e1lido (Unicode: 0x{0}) foi encontrado no conte\\u00fado dos dados de caractere dos n\\u00f3s. \"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                 \"Um caractere inv\\u00e1lido foi encontrado no {0} do n\\u00f3 denominado ''{1}''.\"\n+             },\n+\n+             { MsgKey.ER_WF_DASH_IN_COMMENT,\n+                 \"A cadeia \\\"--\\\" n\\u00e3o \\u00e9 permitida dentro dos coment\\u00e1rios. \"\n+             },\n+\n+             {MsgKey.ER_WF_LT_IN_ATTVAL,\n+                 \"O valor do atributo \\\"{1}\\\" associado a um tipo de elemento \\\"{0}\\\" n\\u00e3o deve conter o caractere ''<''. \"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                 \"A refer\\u00eancia de entidade n\\u00e3o analisada \\\"&{0};\\\" n\\u00e3o \\u00e9 permitida. \"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                 \"A refer\\u00eancia de entidade externa \\\"&{0};\\\" n\\u00e3o \\u00e9 permitida em um valor de atributo. \"\n+             },\n+\n+             {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                 \"O prefixo \\\"{0}\\\" n\\u00e3o pode ser vinculado ao espa\\u00e7o de nomes \\\"{1}\\\".\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                 \"O nome local do elemento \\\"{0}\\\" \\u00e9 nulo.\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+                 \"O nome local do atributo \\\"{0}\\\" \\u00e9 nulo.\"\n+             },\n+\n+             { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"O texto de substitui\\u00e7\\u00e3o do n\\u00f3 de entidade \\\"{0}\\\" cont\\u00e9m um n\\u00f3 de elemento \\\"{1}\\\" com um prefixo n\\u00e3o vinculado \\\"{2}\\\".\"\n+             },\n+\n+             { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"O texto de substitui\\u00e7\\u00e3o do n\\u00f3 de entidade \\\"{0}\\\" cont\\u00e9m um n\\u00f3 de atributo \\\"{1}\\\" com um prefixo n\\u00e3o vinculado \\\"{2}\\\".\"\n+             },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_pt_BR.java","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -200,0 +202,87 @@\n+             {MsgKey.ER_FEATURE_NOT_FOUND,\n+             \"\\u7121\\u6cd5\\u8fa8\\u8b58\\u53c3\\u6578 ''{0}''\\u3002\"},\n+\n+             {MsgKey.ER_FEATURE_NOT_SUPPORTED,\n+             \"\\u53ef\\u8fa8\\u8b58 ''{0}'' \\u53c3\\u6578\\uff0c\\u4f46\\u6240\\u8981\\u6c42\\u7684\\u503c\\u7121\\u6cd5\\u8a2d\\u5b9a\\u3002\"},\n+\n+             {MsgKey.ER_STRING_TOO_LONG,\n+             \"\\u7d50\\u679c\\u5b57\\u4e32\\u904e\\u9577\\uff0c\\u7121\\u6cd5\\u7f6e\\u5165 DOMString: ''{0}'' \\u4e2d\\u3002\"},\n+\n+             {MsgKey.ER_TYPE_MISMATCH_ERR,\n+             \"\\u9019\\u500b\\u53c3\\u6578\\u540d\\u7a31\\u7684\\u503c\\u985e\\u578b\\u8207\\u671f\\u671b\\u503c\\u985e\\u578b\\u4e0d\\u76f8\\u5bb9\\u3002\"},\n+\n+             {MsgKey.ER_NO_OUTPUT_SPECIFIED,\n+             \"\\u8cc7\\u6599\\u8981\\u5beb\\u5165\\u7684\\u8f38\\u51fa\\u76ee\\u7684\\u5730\\u70ba\\u7a7a\\u503c\\u3002\"},\n+\n+             {MsgKey.ER_UNSUPPORTED_ENCODING,\n+             \"\\u767c\\u73fe\\u4e0d\\u652f\\u63f4\\u7684\\u7de8\\u78bc\\u3002\"},\n+\n+             {MsgKey.ER_UNABLE_TO_SERIALIZE_NODE,\n+             \"\\u7bc0\\u9ede\\u7121\\u6cd5\\u5e8f\\u5217\\u5316\\u3002\"},\n+\n+             {MsgKey.ER_CDATA_SECTIONS_SPLIT,\n+             \"CDATA \\u5340\\u6bb5\\u5305\\u542b\\u4e00\\u6216\\u591a\\u500b\\u7d42\\u6b62\\u6a19\\u8a18 ']]>'\\u3002\"},\n+\n+             {MsgKey.ER_WARNING_WF_NOT_CHECKED,\n+                 \"\\u7121\\u6cd5\\u5efa\\u7acb\\u300c\\u5f62\\u5f0f\\u5b8c\\u6574\\u300d\\u6aa2\\u67e5\\u7a0b\\u5f0f\\u7684\\u5be6\\u4f8b\\u3002Well-formed \\u53c3\\u6578\\u96d6\\u8a2d\\u70ba true\\uff0c\\u4f46\\u7121\\u6cd5\\u57f7\\u884c\\u5f62\\u5f0f\\u5b8c\\u6574\\u6aa2\\u67e5\\u3002\"\n+             },\n+\n+             {MsgKey.ER_WF_INVALID_CHARACTER,\n+                 \"\\u7bc0\\u9ede ''{0}'' \\u5305\\u542b\\u7121\\u6548\\u7684 XML \\u5b57\\u5143\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_COMMENT,\n+                 \"\\u5728\\u8a3b\\u89e3\\u4e2d\\u767c\\u73fe\\u7121\\u6548\\u7684 XML \\u5b57\\u5143 (Unicode: 0x{0})\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_PI,\n+                 \"\\u5728\\u8655\\u7406\\u7a0b\\u5e8f instructiondata \\u4e2d\\u767c\\u73fe\\u7121\\u6548\\u7684 XML \\u5b57\\u5143 (Unicode: 0x{0})\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_CDATA,\n+                 \"\\u5728 CDATASection \\u7684\\u5167\\u5bb9\\u4e2d\\u767c\\u73fe\\u7121\\u6548\\u7684 XML \\u5b57\\u5143 (Unicode: 0x{0})\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_TEXT,\n+                 \"\\u5728\\u7bc0\\u9ede\\u7684\\u5b57\\u5143\\u8cc7\\u6599\\u5167\\u5bb9\\u4e2d\\u767c\\u73fe\\u7121\\u6548\\u7684 XML \\u5b57\\u5143 (Unicode: 0x{0})\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_INVALID_CHARACTER_IN_NODE_NAME,\n+                 \"\\u5728\\u540d\\u70ba ''{1}'' \\u7684 ''{0}'' \\u4e2d\\u767c\\u73fe\\u7121\\u6548\\u7684 XML \\u5b57\\u5143\\u3002\"\n+             },\n+\n+             { MsgKey.ER_WF_DASH_IN_COMMENT,\n+                 \"\\u8a3b\\u89e3\\u4e2d\\u4e0d\\u5141\\u8a31\\u4f7f\\u7528\\u5b57\\u4e32 \\\"--\\\"\\u3002\"\n+             },\n+\n+             {MsgKey.ER_WF_LT_IN_ATTVAL,\n+                 \"\\u8207\\u5143\\u7d20\\u985e\\u578b \\\"{0}\\\" \\u76f8\\u95dc\\u806f\\u7684\\u5c6c\\u6027 \\\"{1}\\\" \\u503c\\u4e0d\\u53ef\\u5305\\u542b ''<'' \\u5b57\\u5143\\u3002\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_UNPARSED_ENT,\n+                 \"\\u4e0d\\u5141\\u8a31\\u4f7f\\u7528\\u672a\\u5256\\u6790\\u7684\\u5be6\\u9ad4\\u53c3\\u7167 \\\"&{0};\\\"\\u3002\"\n+             },\n+\n+             {MsgKey.ER_WF_REF_TO_EXTERNAL_ENT,\n+                 \"\\u5c6c\\u6027\\u503c\\u4e2d\\u4e0d\\u5141\\u8a31\\u4f7f\\u7528\\u5916\\u90e8\\u5be6\\u9ad4\\u53c3\\u7167 \\\"&{0};\\\"\\u3002\"\n+             },\n+\n+             {MsgKey.ER_NS_PREFIX_CANNOT_BE_BOUND,\n+                 \"\\u5b57\\u9996 \\\"{0}\\\" \\u7121\\u6cd5\\u9023\\u7d50\\u5230\\u540d\\u7a31\\u7a7a\\u9593 \\\"{1}\\\"\\u3002\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ELEMENT_NAME,\n+                 \"\\u5143\\u7d20 \\\"{0}\\\" \\u7684\\u672c\\u7aef\\u540d\\u7a31\\u662f\\u7a7a\\u503c\\u3002\"\n+             },\n+\n+             {MsgKey.ER_NULL_LOCAL_ATTR_NAME,\n+                 \"\\u5c6c\\u6027 \\\"{0}\\\" \\u7684\\u672c\\u7aef\\u540d\\u7a31\\u662f\\u7a7a\\u503c\\u3002\"\n+             },\n+\n+             { MsgKey.ER_ELEM_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"\\u5be6\\u9ad4\\u7bc0\\u9ede \\\"{0}\\\" \\u7684\\u53d6\\u4ee3\\u6587\\u5b57\\u5305\\u542b\\u9644\\u6709\\u5df2\\u5207\\u65b7\\u9023\\u7d50\\u5b57\\u9996 \\\"{2}\\\" \\u7684\\u5143\\u7d20\\u7bc0\\u9ede \\\"{1}\\\"\\u3002\"\n+             },\n+\n+             { MsgKey.ER_ATTR_UNBOUND_PREFIX_IN_ENTREF,\n+                 \"\\u5be6\\u9ad4\\u7bc0\\u9ede \\\"{0}\\\" \\u7684\\u53d6\\u4ee3\\u6587\\u5b57\\u5305\\u542b\\u9644\\u6709\\u5df2\\u5207\\u65b7\\u9023\\u7d50\\u5b57\\u9996 \\\"{2}\\\" \\u7684\\u5c6c\\u6027\\u7bc0\\u9ede \\\"{1}\\\"\\u3002\"\n+             },\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/utils\/SerializerMessages_zh_TW.java","additions":92,"deletions":3,"binary":false,"changes":95,"status":"modified"}]}