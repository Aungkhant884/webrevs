{"files":[{"patch":"@@ -2403,1 +2403,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2411,1 +2411,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2419,1 +2419,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2427,1 +2427,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2435,1 +2435,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2443,1 +2443,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2451,1 +2451,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2459,1 +2459,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);\n","filename":"hotspot\/src\/cpu\/aarch64\/vm\/aarch64.ad","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,0 +39,11 @@\n+define(LOADL,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{\n+    $3Register dst_reg = as_$3Register($dst$$reg);\n+    loadStore(MacroAssembler(&cbuf), &MacroAssembler::$2, dst_reg, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, $4);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n@@ -109,8 +120,8 @@\n-LOAD(iRegI,ldrshw)\n-LOAD(iRegI,ldrsh)\n-LOAD(iRegI,ldrh)\n-LOAD(iRegL,ldrh)\n-LOAD(iRegI,ldrw)\n-LOAD(iRegL,ldrw)\n-LOAD(iRegL,ldrsw)\n-LOAD(iRegL,ldr)\n+LOADL(iRegI,ldrshw,,2)\n+LOADL(iRegI,ldrsh,,2)\n+LOADL(iRegI,ldrh,,2)\n+LOADL(iRegL,ldrh,,2)\n+LOADL(iRegI,ldrw,,4)\n+LOADL(iRegL,ldrw,,4)\n+LOADL(iRegL,ldrsw,,4)\n+LOADL(iRegL,ldr,,8)\n","filename":"hotspot\/src\/cpu\/aarch64\/vm\/ad_encode.m4","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+\n+import java.util.Arrays;\n@@ -40,1 +42,1 @@\n- * @bug 8235385\n+ * @bug 8235385 8287508\n@@ -105,1 +107,1 @@\n-    private static final boolean    useShortCompressFloat = random.nextInt(100) > 60;\n+    private static final boolean useShortCompressFloat = random.nextInt(100) > 60;\n@@ -112,1 +114,1 @@\n-    private static final int    BOOLEAN_SIZE = 1;\n+    private static final int BOOLEAN_SIZE = 1;\n@@ -122,2 +124,1 @@\n-\n-    public static final void toBytes(short obj, byte[] rawBytes, int start) {\n+    private static final void toBytes(short obj, byte[] rawBytes, int start) {\n@@ -128,3 +129,3 @@\n-    public static final void toBytes(int obj, byte[] rawBytes, int start) {\n-        premitiveAssert(rawBytes.length >= (start +         INT_SIZE));\n-        unsafe.putInt(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    private static final short bytes2short(byte[] rawBytes, int start){\n+        premitiveAssert(rawBytes.length >= (start + SHORT_SIZE));\n+        return unsafe.getShort(rawBytes, (long) BYTE_ARRAY_OFFSET + start);\n@@ -133,3 +134,3 @@\n-    public static final void toBytes(long obj, byte[] rawBytes, int start) {\n-        premitiveAssert(rawBytes.length >= (start +         LONG_SIZE));\n-        unsafe.putLong(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    private static final void toBytes(int obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         INT_SIZE));\n+        unsafe.putInt(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n@@ -138,3 +139,3 @@\n-    public static final void toBytes(float obj, byte[] rawBytes, int start) {\n-        premitiveAssert(rawBytes.length >= (start +         FLOAT_SIZE));\n-        unsafe.putFloat(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    private static final int bytes2int(byte[] rawBytes, int start){\n+        premitiveAssert(rawBytes.length >= (start + INT_SIZE));\n+        return unsafe.getInt(rawBytes, (long) BYTE_ARRAY_OFFSET + start);\n@@ -143,3 +144,3 @@\n-    public static final void toBytes(double obj, byte[] rawBytes, int start) {\n-        premitiveAssert(rawBytes.length >= (start +         DOUBLE_SIZE));\n-        unsafe.putDouble(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    private static final void toBytes(long obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         LONG_SIZE));\n+        unsafe.putLong(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n@@ -148,3 +149,3 @@\n-    public static final void toBytes(char obj, byte[] rawBytes, int start) {\n-        premitiveAssert(rawBytes.length >= (start +         CHAR_SIZE));\n-        unsafe.putChar(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    private static final long bytes2long(byte[] rawBytes, int start){\n+        premitiveAssert(rawBytes.length >= (start + LONG_SIZE));\n+        return unsafe.getLong(rawBytes, (long) BYTE_ARRAY_OFFSET + start);\n@@ -153,1 +154,1 @@\n-    public static final void toBytes(boolean obj, byte[] rawBytes, int start) {\n+    private static final void toBytes(boolean obj, byte[] rawBytes, int start) {\n@@ -158,2 +159,3 @@\n-    private static int bytesSize() {\n-        return MAX_LENGTH;\n+    private static final boolean bytes2boolen(byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start + 1));\n+        return unsafe.getBoolean(rawBytes, (long) BYTE_ARRAY_OFFSET + start);\n@@ -161,1 +163,2 @@\n-    static byte[] toBytesDup() {\n+\n+    private static final byte[] toBytesDup() {\n@@ -276,1 +279,1 @@\n-    static byte[] toBytes() {\n+    private static final byte[] toBytes() {\n@@ -299,1 +302,0 @@\n-        \/\/if (version.getVersion() < DetailColumn.VERSION_EIGHT) {\n@@ -394,0 +396,125 @@\n+    private static final void fromBytes(byte[] rawBytes) throws Throwable {\n+        int offset = 0;\n+\n+        if (valueType != bytes2int(rawBytes, offset)) throw new RuntimeException(\"valueType does not match\");\n+        offset += INT_SIZE;\n+\n+        if (numNulls != bytes2int(rawBytes, offset)) throw new RuntimeException(\"numNulls does not match\");\n+        offset += INT_SIZE;\n+\n+        if (numRows != bytes2int(rawBytes, offset)) throw new RuntimeException(\"numRows does not match\");\n+        offset += INT_SIZE;\n+\n+        if (countDistinct != bytes2int(rawBytes, offset)) throw new RuntimeException(\"countDistinct does not match\");\n+        offset += INT_SIZE;\n+\n+        if (rawDataSize != bytes2long(rawBytes, offset)) throw new RuntimeException(\"rawDataSize does not match\");\n+        offset += LONG_SIZE;\n+\n+        if (sum != bytes2long(rawBytes, offset)) throw new RuntimeException(\"sum does not match\");\n+        offset += LONG_SIZE;\n+\n+        byte[] maxValue_ = new byte[MAX_VALUE_LENGTH];\n+        byte[] minValue_ = new byte[MAX_VALUE_LENGTH];\n+        if (version > 50) {\n+            System.arraycopy(rawBytes, offset, maxValue_, 0, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+            if (!Arrays.equals(maxValue, maxValue_)) throw new RuntimeException(\"maxValue does not match\");\n+\n+            System.arraycopy(rawBytes, offset, minValue_, 0, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+            if (!Arrays.equals(minValue, minValue_)) throw new RuntimeException(\"minValue does not match\");\n+        } else {\n+            System.arraycopy(rawBytes, offset, maxValue_, 0, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+            if (!Arrays.equals(maxValue, maxValue_)) throw new RuntimeException(\"maxValue does not match\");\n+\n+            System.arraycopy(rawBytes, offset, minValue_, 0, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+            if (!Arrays.equals(minValue, minValue_)) throw new RuntimeException(\"minValue does not match\");\n+        }\n+\n+        if (dictOffset != bytes2int(rawBytes, offset)) throw new RuntimeException(\"dictOffset does not match\");\n+        offset += INT_SIZE;\n+\n+        if (dictLength != bytes2int(rawBytes, offset)) throw new RuntimeException(\"dictLength does not match\");\n+        offset += INT_SIZE;\n+\n+        if (histOffset != bytes2int(rawBytes, offset)) throw new RuntimeException(\"histOffset does not match\");\n+        offset += INT_SIZE;\n+\n+        if (histLength != bytes2int(rawBytes, offset)) throw new RuntimeException(\"histLength does not match\");\n+        offset += INT_SIZE;\n+\n+        if (dpnOffset != bytes2int(rawBytes, offset)) throw new RuntimeException(\"dpnOffset does not match\");\n+        offset += INT_SIZE;\n+\n+        if (dpnCount != bytes2int(rawBytes, offset)) throw new RuntimeException(\"dpnCount does not match\");\n+        offset +=         INT_SIZE;\n+\n+        if (version >= 60) {\n+            if (maxRowCount != bytes2long(rawBytes, offset)) throw new RuntimeException(\"maxRowCount does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (minRowCount != bytes2long(rawBytes, offset)) throw new RuntimeException(\"minRowCount does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (totalRowCount != bytes2long(rawBytes, offset)) throw new RuntimeException(\"totalRowCount does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (maxMemSize != bytes2long(rawBytes, offset)) throw new RuntimeException(\"maxMemSize does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (minMemSize != bytes2long(rawBytes, offset)) throw new RuntimeException(\"minMemSize does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (totalMemSize != bytes2long(rawBytes, offset)) throw new RuntimeException(\"totalMemSize does not match\");\n+            offset += LONG_SIZE;\n+        }\n+\n+        if (version >= 65) {\n+            if (toastOffset != bytes2long(rawBytes, offset)) throw new RuntimeException(\"toastOffset does not match\");\n+            offset += LONG_SIZE;\n+\n+            if (hasToast != bytes2boolen(rawBytes, offset)) throw new RuntimeException(\"hasToast does not match\");\n+            offset += BOOLEAN_SIZE;\n+        }\n+\n+        if (version >= 70) {\n+            byte[] maxString_ = new byte[MAX_STRING_LENGTH];\n+            System.arraycopy(rawBytes, offset, maxString_, 0, MAX_STRING_LENGTH);\n+            offset += MAX_STRING_LENGTH;\n+            if (!Arrays.equals(maxString, maxString_)) throw new RuntimeException(\"maxString does not match\");\n+\n+            byte[] minString_ = new byte[MAX_STRING_LENGTH];\n+            System.arraycopy(rawBytes, offset, minString_, 0, MAX_STRING_LENGTH);\n+            offset += MAX_STRING_LENGTH;\n+            if (!Arrays.equals(minString, minString_)) throw new RuntimeException(\"minString does not match\");\n+\n+            if (maxStringLength != bytes2int(rawBytes, offset)) throw new RuntimeException(\"maxStringLength does not match\");\n+            offset += INT_SIZE;\n+\n+            if (minStringLength != bytes2int(rawBytes, offset)) throw new RuntimeException(\"minStringLength does not match\");\n+            offset += INT_SIZE;\n+\n+            if (maxStringIsNull != bytes2boolen(rawBytes, offset)) throw new RuntimeException(\"maxStringIsNull does not match\");\n+            offset += BOOLEAN_SIZE;\n+\n+            if (minStringIsNull != bytes2boolen(rawBytes, offset)) throw new RuntimeException(\"minStringIsNull does not match\");\n+            offset += BOOLEAN_SIZE;\n+        }\n+\n+        if (version >= 75) {\n+            if (precision != bytes2short(rawBytes, offset)) throw new RuntimeException(\"precision does not match\");\n+            offset += SHORT_SIZE;\n+\n+            if (scale != bytes2short(rawBytes, offset)) throw new RuntimeException(\"scale does not match\");\n+            offset += SHORT_SIZE;\n+        }\n+\n+        if (version >= 80) {\n+            if (useShortCompressFloat != bytes2boolen(rawBytes, offset)) throw new RuntimeException(\"useShortCompressFloat does not match\");\n+            offset += BOOLEAN_SIZE;\n+        }\n+    }\n+\n@@ -408,0 +535,2 @@\n+            fromBytes(input0);\n+            fromBytes(input1);\n@@ -411,0 +540,7 @@\n+\n+\n+\n+\n+\n+\n+\n","filename":"hotspot\/test\/compiler\/8235385\/NonVolatileMemoryAccessWithLongOffset.java","additions":162,"deletions":26,"binary":false,"changes":188,"status":"modified"}]}