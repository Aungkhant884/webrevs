{"files":[{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.crypto.provider;\n+\n+import java.util.Arrays;\n+\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.spec.PBEParameterSpec;\n+import java.security.*;\n+import java.security.spec.*;\n+\n+\/**\n+ * This is an implementation of the HMAC algorithms as defined\n+ * in PKCS#12 v1.1 standard (see RFC 7292 Appendix B.4).\n+ *\n+ * @author Valerie Peng\n+ *\/\n+abstract class HmacPKCS12PBECore extends HmacCore {\n+\n+    public static final class HmacPKCS12PBE_SHA1 extends HmacPKCS12PBECore {\n+        public HmacPKCS12PBE_SHA1() throws NoSuchAlgorithmException {\n+            super(\"SHA1\", 64);\n+        }\n+    }\n+\n+    public static final class HmacPKCS12PBE_SHA224 extends HmacPKCS12PBECore {\n+        public HmacPKCS12PBE_SHA224() throws NoSuchAlgorithmException {\n+            super(\"SHA-224\", 64);\n+        }\n+    }\n+\n+    public static final class HmacPKCS12PBE_SHA256 extends HmacPKCS12PBECore {\n+        public HmacPKCS12PBE_SHA256() throws NoSuchAlgorithmException {\n+            super(\"SHA-256\", 64);\n+        }\n+    }\n+\n+    public static final class HmacPKCS12PBE_SHA384 extends HmacPKCS12PBECore {\n+        public HmacPKCS12PBE_SHA384() throws NoSuchAlgorithmException {\n+            super(\"SHA-384\", 128);\n+        }\n+    }\n+\n+    public static final class HmacPKCS12PBE_SHA512 extends HmacPKCS12PBECore {\n+        public HmacPKCS12PBE_SHA512() throws NoSuchAlgorithmException {\n+            super(\"SHA-512\", 128);\n+        }\n+    }\n+\n+    public static final class HmacPKCS12PBE_SHA512_224 extends HmacPKCS12PBECore {\n+        public HmacPKCS12PBE_SHA512_224() throws NoSuchAlgorithmException {\n+            super(\"SHA-512\/224\", 128);\n+        }\n+    }\n+\n+    public static final class HmacPKCS12PBE_SHA512_256 extends HmacPKCS12PBECore {\n+        public HmacPKCS12PBE_SHA512_256() throws NoSuchAlgorithmException {\n+            super(\"SHA-512\/256\", 128);\n+        }\n+    }\n+\n+    private final String algorithm;\n+    private final int bl;\n+\n+    \/**\n+     * Standard constructor, creates a new HmacSHA1 instance.\n+     *\/\n+    public HmacPKCS12PBECore(String algorithm, int bl) throws NoSuchAlgorithmException {\n+        super(algorithm, bl);\n+        this.algorithm = algorithm;\n+        this.bl = bl;\n+    }\n+\n+    \/**\n+     * Initializes the HMAC with the given secret key and algorithm parameters.\n+     *\n+     * @param key the secret key.\n+     * @param params the algorithm parameters.\n+     *\n+     * @exception InvalidKeyException if the given key is inappropriate for\n+     * initializing this MAC.\n+     * @exception InvalidAlgorithmParameterException if the given algorithm\n+     * parameters are inappropriate for this MAC.\n+     *\/\n+    protected void engineInit(Key key, AlgorithmParameterSpec params)\n+        throws InvalidKeyException, InvalidAlgorithmParameterException {\n+        char[] passwdChars;\n+        byte[] salt = null;\n+        int iCount = 0;\n+        if (key instanceof javax.crypto.interfaces.PBEKey) {\n+            javax.crypto.interfaces.PBEKey pbeKey =\n+                (javax.crypto.interfaces.PBEKey) key;\n+            passwdChars = pbeKey.getPassword();\n+            salt = pbeKey.getSalt(); \/\/ maybe null if unspecified\n+            iCount = pbeKey.getIterationCount(); \/\/ maybe 0 if unspecified\n+        } else if (key instanceof SecretKey) {\n+            byte[] passwdBytes;\n+            if (!(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0, 3)) ||\n+                    (passwdBytes = key.getEncoded()) == null) {\n+                throw new InvalidKeyException(\"Missing password\");\n+            }\n+            passwdChars = new char[passwdBytes.length];\n+            for (int i=0; i<passwdChars.length; i++) {\n+                passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n+            }\n+            Arrays.fill(passwdBytes, (byte)0x00);\n+        } else {\n+            throw new InvalidKeyException(\"SecretKey of PBE type required\");\n+        }\n+\n+        byte[] derivedKey;\n+        try {\n+            if (params == null) {\n+                \/\/ should not auto-generate default values since current\n+                \/\/ javax.crypto.Mac api does not have any method for caller to\n+                \/\/ retrieve the generated defaults.\n+                if ((salt == null) || (iCount == 0)) {\n+                    throw new InvalidAlgorithmParameterException\n+                            (\"PBEParameterSpec required for salt and iteration count\");\n+                }\n+            } else if (!(params instanceof PBEParameterSpec)) {\n+                throw new InvalidAlgorithmParameterException\n+                        (\"PBEParameterSpec type required\");\n+            } else {\n+                PBEParameterSpec pbeParams = (PBEParameterSpec) params;\n+                \/\/ make sure the parameter values are consistent\n+                if (salt != null) {\n+                    if (!Arrays.equals(salt, pbeParams.getSalt())) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Inconsistent value of salt between key and params\");\n+                    }\n+                } else {\n+                    salt = pbeParams.getSalt();\n+                }\n+                if (iCount != 0) {\n+                    if (iCount != pbeParams.getIterationCount()) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Different iteration count between key and params\");\n+                    }\n+                } else {\n+                    iCount = pbeParams.getIterationCount();\n+                }\n+            }\n+            \/\/ For security purpose, we need to enforce a minimum length\n+            \/\/ for salt; just require the minimum salt length to be 8-byte\n+            \/\/ which is what PKCS#5 recommends and openssl does.\n+            if (salt.length < 8) {\n+                throw new InvalidAlgorithmParameterException\n+                        (\"Salt must be at least 8 bytes long\");\n+            }\n+            if (iCount <= 0) {\n+                throw new InvalidAlgorithmParameterException\n+                        (\"IterationCount must be a positive number\");\n+            }\n+            derivedKey = PKCS12PBECipherCore.derive(passwdChars, salt,\n+                    iCount, engineGetMacLength(), PKCS12PBECipherCore.MAC_KEY,\n+                    algorithm, bl);\n+        } finally {\n+            Arrays.fill(passwdChars, '\\0');\n+        }\n+        SecretKey cipherKey = new SecretKeySpec(derivedKey, \"HmacSHA1\");\n+        super.engineInit(cipherKey, null);\n+    }\n+}\n","filename":"jdk\/src\/share\/classes\/com\/sun\/crypto\/provider\/HmacPKCS12PBECore.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.crypto.provider;\n-\n-import java.util.Arrays;\n-import java.nio.ByteBuffer;\n-\n-import javax.crypto.MacSpi;\n-import javax.crypto.SecretKey;\n-import javax.crypto.spec.SecretKeySpec;\n-import javax.crypto.spec.PBEParameterSpec;\n-import java.security.*;\n-import java.security.spec.*;\n-\n-\/**\n- * This is an implementation of the HMAC-PBESHA1 algorithm as defined\n- * in PKCS#12 v1.0 standard.\n- *\n- * @author Valerie Peng\n- *\/\n-public final class HmacPKCS12PBESHA1 extends HmacCore {\n-\n-    \/**\n-     * Standard constructor, creates a new HmacSHA1 instance.\n-     *\/\n-    public HmacPKCS12PBESHA1() throws NoSuchAlgorithmException {\n-        super(\"SHA1\", 64);\n-    }\n-\n-    \/**\n-     * Initializes the HMAC with the given secret key and algorithm parameters.\n-     *\n-     * @param key the secret key.\n-     * @param params the algorithm parameters.\n-     *\n-     * @exception InvalidKeyException if the given key is inappropriate for\n-     * initializing this MAC.\n-     * @exception InvalidAlgorithmParameterException if the given algorithm\n-     * parameters are inappropriate for this MAC.\n-     *\/\n-    protected void engineInit(Key key, AlgorithmParameterSpec params)\n-        throws InvalidKeyException, InvalidAlgorithmParameterException {\n-        char[] passwdChars;\n-        byte[] salt = null;\n-        int iCount = 0;\n-        if (key instanceof javax.crypto.interfaces.PBEKey) {\n-            javax.crypto.interfaces.PBEKey pbeKey =\n-                (javax.crypto.interfaces.PBEKey) key;\n-            passwdChars = pbeKey.getPassword();\n-            salt = pbeKey.getSalt(); \/\/ maybe null if unspecified\n-            iCount = pbeKey.getIterationCount(); \/\/ maybe 0 if unspecified\n-        } else if (key instanceof SecretKey) {\n-            byte[] passwdBytes;\n-            if (!(key.getAlgorithm().regionMatches(true, 0, \"PBE\", 0, 3)) ||\n-                    (passwdBytes = key.getEncoded()) == null) {\n-                throw new InvalidKeyException(\"Missing password\");\n-            }\n-            passwdChars = new char[passwdBytes.length];\n-            for (int i=0; i<passwdChars.length; i++) {\n-                passwdChars[i] = (char) (passwdBytes[i] & 0x7f);\n-            }\n-            Arrays.fill(passwdBytes, (byte)0x00);\n-        } else {\n-            throw new InvalidKeyException(\"SecretKey of PBE type required\");\n-        }\n-\n-        byte[] derivedKey;\n-        try {\n-            if (params == null) {\n-                \/\/ should not auto-generate default values since current\n-                \/\/ javax.crypto.Mac api does not have any method for caller to\n-                \/\/ retrieve the generated defaults.\n-                if ((salt == null) || (iCount == 0)) {\n-                    throw new InvalidAlgorithmParameterException\n-                            (\"PBEParameterSpec required for salt and iteration count\");\n-                }\n-            } else if (!(params instanceof PBEParameterSpec)) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"PBEParameterSpec type required\");\n-            } else {\n-                PBEParameterSpec pbeParams = (PBEParameterSpec) params;\n-                \/\/ make sure the parameter values are consistent\n-                if (salt != null) {\n-                    if (!Arrays.equals(salt, pbeParams.getSalt())) {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Inconsistent value of salt between key and params\");\n-                    }\n-                } else {\n-                    salt = pbeParams.getSalt();\n-                }\n-                if (iCount != 0) {\n-                    if (iCount != pbeParams.getIterationCount()) {\n-                        throw new InvalidAlgorithmParameterException\n-                                (\"Different iteration count between key and params\");\n-                    }\n-                } else {\n-                    iCount = pbeParams.getIterationCount();\n-                }\n-            }\n-            \/\/ For security purpose, we need to enforce a minimum length\n-            \/\/ for salt; just require the minimum salt length to be 8-byte\n-            \/\/ which is what PKCS#5 recommends and openssl does.\n-            if (salt.length < 8) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"Salt must be at least 8 bytes long\");\n-            }\n-            if (iCount <= 0) {\n-                throw new InvalidAlgorithmParameterException\n-                        (\"IterationCount must be a positive number\");\n-            }\n-            derivedKey = PKCS12PBECipherCore.derive(passwdChars, salt,\n-                    iCount, engineGetMacLength(), PKCS12PBECipherCore.MAC_KEY);\n-        } finally {\n-            Arrays.fill(passwdChars, '\\0');\n-        }\n-        SecretKey cipherKey = new SecretKeySpec(derivedKey, \"HmacSHA1\");\n-        super.engineInit(cipherKey, null);\n-    }\n-}\n","filename":"jdk\/src\/share\/classes\/com\/sun\/crypto\/provider\/HmacPKCS12PBESHA1.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -315,0 +315,2 @@\n+\n+        DerValue prf = null;\n@@ -320,0 +322,3 @@\n+            } else {\n+                \/\/ Should be the prf\n+                prf = keyLength;\n@@ -324,15 +329,26 @@\n-        if (pBKDF2_params.data.available() > 0) {\n-            if (pBKDF2_params.tag == DerValue.tag_Sequence) {\n-                DerValue prf = pBKDF2_params.data.getDerValue();\n-                kdfAlgo_OID = prf.data.getOID();\n-                if (hmacWithSHA1_OID.equals(kdfAlgo_OID)) {\n-                    kdfAlgo = \"HmacSHA1\";\n-                } else if (hmacWithSHA224_OID.equals(kdfAlgo_OID)) {\n-                    kdfAlgo = \"HmacSHA224\";\n-                } else if (hmacWithSHA256_OID.equals(kdfAlgo_OID)) {\n-                    kdfAlgo = \"HmacSHA256\";\n-                } else if (hmacWithSHA384_OID.equals(kdfAlgo_OID)) {\n-                    kdfAlgo = \"HmacSHA384\";\n-                } else if (hmacWithSHA512_OID.equals(kdfAlgo_OID)) {\n-                    kdfAlgo = \"HmacSHA512\";\n-                } else {\n+        if (prf == null) {\n+            if (pBKDF2_params.data.available() > 0) {\n+                prf = pBKDF2_params.data.getDerValue();\n+            }\n+        }\n+        if (prf != null) {\n+            kdfAlgo_OID = prf.data.getOID();\n+            if (hmacWithSHA1_OID.equals(kdfAlgo_OID)) {\n+                kdfAlgo = \"HmacSHA1\";\n+            } else if (hmacWithSHA224_OID.equals(kdfAlgo_OID)) {\n+                kdfAlgo = \"HmacSHA224\";\n+            } else if (hmacWithSHA256_OID.equals(kdfAlgo_OID)) {\n+                kdfAlgo = \"HmacSHA256\";\n+            } else if (hmacWithSHA384_OID.equals(kdfAlgo_OID)) {\n+                kdfAlgo = \"HmacSHA384\";\n+            } else if (hmacWithSHA512_OID.equals(kdfAlgo_OID)) {\n+                kdfAlgo = \"HmacSHA512\";\n+            } else {\n+                throw new IOException(\"PBE parameter parsing error: \"\n+                        + \"expecting the object identifier for a HmacSHA key \"\n+                        + \"derivation function\");\n+            }\n+            if (prf.data.available() != 0) {\n+                \/\/ parameter is 'NULL' for all HmacSHA KDFs\n+                DerValue parameter = prf.data.getDerValue();\n+                if (parameter.tag != DerValue.tag_Null) {\n@@ -340,10 +356,1 @@\n-                            + \"expecting the object identifier for a HmacSHA key \"\n-                            + \"derivation function\");\n-                }\n-                if (prf.data.available() != 0) {\n-                    \/\/ parameter is 'NULL' for all HmacSHA KDFs\n-                    DerValue parameter = prf.data.getDerValue();\n-                    if (parameter.tag != DerValue.tag_Null) {\n-                        throw new IOException(\"PBE parameter parsing error: \"\n-                                + \"not an ASN.1 NULL tag\");\n-                    }\n+                            + \"not an ASN.1 NULL tag\");\n","filename":"jdk\/src\/share\/classes\/com\/sun\/crypto\/provider\/PBES2Parameters.java","additions":32,"deletions":25,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -710,1 +710,13 @@\n-                        \"com.sun.crypto.provider.HmacPKCS12PBESHA1\");\n+                        \"com.sun.crypto.provider.HmacPKCS12PBECore$HmacPKCS12PBE_SHA1\");\n+                    put(\"Mac.HmacPBESHA224\",\n+                        \"com.sun.crypto.provider.HmacPKCS12PBECore$HmacPKCS12PBE_SHA224\");\n+                    put(\"Mac.HmacPBESHA256\",\n+                        \"com.sun.crypto.provider.HmacPKCS12PBECore$HmacPKCS12PBE_SHA256\");\n+                    put(\"Mac.HmacPBESHA384\",\n+                        \"com.sun.crypto.provider.HmacPKCS12PBECore$HmacPKCS12PBE_SHA384\");\n+                    put(\"Mac.HmacPBESHA512\",\n+                        \"com.sun.crypto.provider.HmacPKCS12PBECore$HmacPKCS12PBE_SHA512\");\n+                    put(\"Mac.HmacPBESHA512\/224\",\n+                        \"com.sun.crypto.provider.HmacPKCS12PBECore$HmacPKCS12PBE_SHA512_224\");\n+                    put(\"Mac.HmacPBESHA512\/256\",\n+                        \"com.sun.crypto.provider.HmacPKCS12PBECore$HmacPKCS12PBE_SHA512_256\");\n@@ -737,0 +749,6 @@\n+                    put(\"Mac.HmacPBESHA224 SupportedKeyFormats\", \"RAW\");\n+                    put(\"Mac.HmacPBESHA256 SupportedKeyFormats\", \"RAW\");\n+                    put(\"Mac.HmacPBESHA384 SupportedKeyFormats\", \"RAW\");\n+                    put(\"Mac.HmacPBESHA512 SupportedKeyFormats\", \"RAW\");\n+                    put(\"Mac.HmacPBESHA512\/224 SupportedKeyFormats\", \"RAW\");\n+                    put(\"Mac.HmacPBESHA512\/256 SupportedKeyFormats\", \"RAW\");\n","filename":"jdk\/src\/share\/classes\/com\/sun\/crypto\/provider\/SunJCE.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import sun.security.util.SecurityProperties;\n@@ -81,3 +82,5 @@\n- * Currently we support following PBE algorithms:\n- *  - pbeWithSHAAnd3KeyTripleDESCBC to encrypt private keys\n- *  - pbeWithSHAAnd40BitRC2CBC to encrypt certificates\n+ * Currently these PBE algorithms are used by default:\n+ *  - PBEWithSHA1AndDESede to encrypt private keys, iteration count 50000.\n+ *  - PBEWithSHA1AndRC2_40 to encrypt certificates, iteration count 50000.\n+ *\n+ * The default Mac algorithm is  HmacPBESHA1, iteration count 100000.\n@@ -126,1 +129,0 @@\n- * @see KeyProtector\n@@ -128,3 +130,0 @@\n- * @see KeyTool\n- *\n- *\n@@ -136,5 +135,0 @@\n-    private static final String[] KEY_PROTECTION_ALGORITHM = {\n-        \"keystore.pkcs12.keyProtectionAlgorithm\",\n-        \"keystore.PKCS12.keyProtectionAlgorithm\"\n-    };\n-\n@@ -142,2 +136,0 @@\n-    private static final int PBE_ITERATION_COUNT = 50000; \/\/ default\n-    private static final int MAC_ITERATION_COUNT = 100000; \/\/ default\n@@ -164,4 +156,0 @@\n-    private static final int pbeWithSHAAnd40BitRC2CBC[] =\n-                                        {1, 2, 840, 113549, 1, 12, 1, 6};\n-    private static final int pbeWithSHAAnd3KeyTripleDESCBC[] =\n-                                        {1, 2, 840, 113549, 1, 12, 1, 3};\n@@ -178,11 +166,9 @@\n-    private static ObjectIdentifier PKCS8ShroudedKeyBag_OID;\n-    private static ObjectIdentifier CertBag_OID;\n-    private static ObjectIdentifier SecretBag_OID;\n-    private static ObjectIdentifier PKCS9FriendlyName_OID;\n-    private static ObjectIdentifier PKCS9LocalKeyId_OID;\n-    private static ObjectIdentifier PKCS9CertType_OID;\n-    private static ObjectIdentifier pbeWithSHAAnd40BitRC2CBC_OID;\n-    private static ObjectIdentifier pbeWithSHAAnd3KeyTripleDESCBC_OID;\n-    private static ObjectIdentifier pbes2_OID;\n-    private static ObjectIdentifier TrustedKeyUsage_OID;\n-    private static ObjectIdentifier[] AnyUsage;\n+    private static final ObjectIdentifier PKCS8ShroudedKeyBag_OID;\n+    private static final ObjectIdentifier CertBag_OID;\n+    private static final ObjectIdentifier SecretBag_OID;\n+    private static final ObjectIdentifier PKCS9FriendlyName_OID;\n+    private static final ObjectIdentifier PKCS9LocalKeyId_OID;\n+    private static final ObjectIdentifier PKCS9CertType_OID;\n+    private static final ObjectIdentifier pbes2_OID;\n+    private static final ObjectIdentifier TrustedKeyUsage_OID;\n+    private static final ObjectIdentifier[] AnyUsage;\n@@ -203,0 +189,11 @@\n+    \/\/ Alg\/params used for *this* keystore. Initialized as -1 for ic and\n+    \/\/ null for algorithm names. When an existing file is read, they will be\n+    \/\/ assigned inside engineLoad() so storing an existing keystore uses the\n+    \/\/ old alg\/params. This makes sure if a keystore is created password-less\n+    \/\/ it will be password-less forever. Otherwise, engineStore() will read\n+    \/\/ the default values. These fields are always reset when load() is called.\n+    private String certProtectionAlgorithm = null;\n+    private int certPbeIterationCount = -1;\n+    private String macAlgorithm = null;\n+    private int macIterationCount = -1;\n+\n@@ -214,4 +211,0 @@\n-            pbeWithSHAAnd40BitRC2CBC_OID =\n-                        new ObjectIdentifier(pbeWithSHAAnd40BitRC2CBC);\n-            pbeWithSHAAnd3KeyTripleDESCBC_OID =\n-                        new ObjectIdentifier(pbeWithSHAAnd3KeyTripleDESCBC);\n@@ -223,1 +216,1 @@\n-            \/\/ should not happen\n+            throw new AssertionError(\"OID not initialized\", ioe);\n@@ -384,1 +377,1 @@\n-                    throw new IOException(\"PBE iteration count too large\");\n+                    throw new IOException(\"key PBE iteration count too large\");\n@@ -420,1 +413,1 @@\n-                                new AlgorithmId(algOid).getName() +\n+                                mapPBEParamsToAlgorithm(algOid, algParams) +\n@@ -445,1 +438,1 @@\n-                                new AlgorithmId(algOid).getName() +\n+                                mapPBEParamsToAlgorithm(algOid, algParams) +\n@@ -694,1 +687,1 @@\n-            throw new KeyStoreException(\"Key protection \" +\n+            throw new KeyStoreException(\"Key protection\" +\n@@ -791,3 +784,2 @@\n-    private AlgorithmParameters getPBEAlgorithmParameters(String algorithm)\n-        throws IOException\n-    {\n+    private AlgorithmParameters getPBEAlgorithmParameters(\n+            String algorithm, int iterationCount) throws IOException {\n@@ -798,1 +790,1 @@\n-                new PBEParameterSpec(getSalt(), PBE_ITERATION_COUNT);\n+                new PBEParameterSpec(getSalt(), iterationCount);\n@@ -861,1 +853,1 @@\n-     * Encrypt private key using Password-based encryption (PBE)\n+     * Encrypt private key or secret key using Password-based encryption (PBE)\n@@ -867,1 +859,2 @@\n-     * @return encrypted private key encoded as EncryptedPrivateKeyInfo\n+     * @return encrypted private key or secret key encoded as\n+     *         EncryptedPrivateKeyInfo\n@@ -889,1 +882,2 @@\n-                    algParams = getPBEAlgorithmParameters(algorithm);\n+                    algParams = getPBEAlgorithmParameters(algorithm,\n+                            defaultKeyPbeIterationCount());\n@@ -893,17 +887,3 @@\n-                algorithm = AccessController.doPrivileged(\n-                    new PrivilegedAction<String>() {\n-                        public String run() {\n-                            String prop =\n-                                Security.getProperty(\n-                                    KEY_PROTECTION_ALGORITHM[0]);\n-                            if (prop == null) {\n-                                prop = Security.getProperty(\n-                                    KEY_PROTECTION_ALGORITHM[1]);\n-                            }\n-                            return prop;\n-                        }\n-                    });\n-                if (algorithm == null || algorithm.isEmpty()) {\n-                    algorithm = \"PBEWithSHA1AndDESede\";\n-                }\n-                algParams = getPBEAlgorithmParameters(algorithm);\n+                algorithm = defaultKeyProtectionAlgorithm();\n+                algParams = getPBEAlgorithmParameters(algorithm,\n+                        defaultKeyPbeIterationCount());\n@@ -967,1 +947,1 @@\n-        return algorithm.toString();\n+        return new AlgorithmId(algorithm).getName();\n@@ -1192,4 +1172,0 @@\n-        \/\/ password is mandatory when storing\n-        if (password == null) {\n-           throw new IllegalArgumentException(\"password can't be null\");\n-        }\n@@ -1228,0 +1204,7 @@\n+            if (certProtectionAlgorithm == null) {\n+                certProtectionAlgorithm = defaultCertProtectionAlgorithm();\n+            }\n+            if (certPbeIterationCount < 0) {\n+                certPbeIterationCount = defaultCertPbeIterationCount();\n+            }\n+\n@@ -1234,2 +1217,3 @@\n-            ContentInfo encrContentInfo =\n-                new ContentInfo(ContentInfo.ENCRYPTED_DATA_OID,\n+            if (!certProtectionAlgorithm.equalsIgnoreCase(\"NONE\")) {\n+                ContentInfo encrContentInfo =\n+                        new ContentInfo(ContentInfo.ENCRYPTED_DATA_OID,\n@@ -1237,1 +1221,5 @@\n-            encrContentInfo.encode(authSafeContentInfo);\n+                encrContentInfo.encode(authSafeContentInfo);\n+            } else {\n+                ContentInfo dataContentInfo = new ContentInfo(encrData);\n+                dataContentInfo.encode(authSafeContentInfo);\n+            }\n@@ -1252,3 +1240,10 @@\n-        byte[] macData = calculateMac(password, authenticatedSafe);\n-        pfx.write(macData);\n-\n+        if (macAlgorithm == null) {\n+            macAlgorithm = defaultMacAlgorithm();\n+        }\n+        if (macIterationCount < 0) {\n+            macIterationCount = defaultMacIterationCount();\n+        }\n+        if (!macAlgorithm.equalsIgnoreCase(\"NONE\")) {\n+            byte[] macData = calculateMac(password, authenticatedSafe);\n+            pfx.write(macData);\n+        }\n@@ -1464,18 +1459,0 @@\n-    \/*\n-     * Generate Hash.\n-     *\/\n-    private byte[] generateHash(byte[] data) throws IOException\n-    {\n-        byte[] digest = null;\n-\n-        try {\n-            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n-            md.update(data);\n-            digest = md.digest();\n-        } catch (Exception e) {\n-            throw new IOException(\"generateHash failed: \" + e, e);\n-        }\n-        return digest;\n-    }\n-\n-\n@@ -1492,1 +1469,1 @@\n-        String algName = \"SHA1\";\n+        String algName = macAlgorithm.substring(7);\n@@ -1499,1 +1476,1 @@\n-            Mac m = Mac.getInstance(\"HmacPBESHA1\");\n+            Mac m = Mac.getInstance(macAlgorithm);\n@@ -1501,1 +1478,1 @@\n-                        new PBEParameterSpec(salt, MAC_ITERATION_COUNT);\n+                        new PBEParameterSpec(salt, macIterationCount);\n@@ -1509,1 +1486,1 @@\n-                                                MAC_ITERATION_COUNT);\n+                    macIterationCount);\n@@ -1767,9 +1744,13 @@\n-        byte[] encrContentInfo = encryptContent(safeBagData, password);\n-\n-        \/\/ -- SEQUENCE of EncryptedData\n-        DerOutputStream encrData = new DerOutputStream();\n-        DerOutputStream encrDataContent = new DerOutputStream();\n-        encrData.putInteger(0);\n-        encrData.write(encrContentInfo);\n-        encrDataContent.write(DerValue.tag_Sequence, encrData);\n-        return encrDataContent.toByteArray();\n+        if (!certProtectionAlgorithm.equalsIgnoreCase(\"NONE\")) {\n+            byte[] encrContentInfo = encryptContent(safeBagData, password);\n+\n+            \/\/ -- SEQUENCE of EncryptedData\n+            DerOutputStream encrData = new DerOutputStream();\n+            DerOutputStream encrDataContent = new DerOutputStream();\n+            encrData.putInteger(0);\n+            encrData.write(encrContentInfo);\n+            encrDataContent.write(DerValue.tag_Sequence, encrData);\n+            return encrDataContent.toByteArray();\n+        } else {\n+            return safeBagData;\n+        }\n@@ -1884,8 +1865,0 @@\n-        \/\/ create AlgorithmParameters\n-        AlgorithmParameters algParams =\n-                getPBEAlgorithmParameters(\"PBEWithSHA1AndRC2_40\");\n-        DerOutputStream bytes = new DerOutputStream();\n-        AlgorithmId algId =\n-                new AlgorithmId(pbeWithSHAAnd40BitRC2CBC_OID, algParams);\n-        algId.encode(bytes);\n-        byte[] encodedAlgId = bytes.toByteArray();\n@@ -1894,0 +1867,5 @@\n+            \/\/ create AlgorithmParameters\n+            AlgorithmParameters algParams = getPBEAlgorithmParameters(\n+                    certProtectionAlgorithm, certPbeIterationCount);\n+            DerOutputStream bytes = new DerOutputStream();\n+\n@@ -1896,1 +1874,1 @@\n-            Cipher cipher = Cipher.getInstance(\"PBEWithSHA1AndRC2_40\");\n+            Cipher cipher = Cipher.getInstance(certProtectionAlgorithm);\n@@ -1900,0 +1878,7 @@\n+            AlgorithmId algId = new AlgorithmId(\n+                    mapPBEAlgorithmToOID(certProtectionAlgorithm),\n+                    cipher.getParameters());\n+                    \/\/ cipher.getParameters() now has IV\n+            algId.encode(bytes);\n+            byte[] encodedAlgId = bytes.toByteArray();\n+\n@@ -1902,1 +1887,1 @@\n-                    \")\");\n+                        \")\");\n@@ -1905,0 +1890,17 @@\n+            \/\/ create EncryptedContentInfo\n+            DerOutputStream bytes2 = new DerOutputStream();\n+            bytes2.putOID(ContentInfo.DATA_OID);\n+            bytes2.write(encodedAlgId);\n+\n+            \/\/ Wrap encrypted data in a context-specific tag.\n+            DerOutputStream tmpout2 = new DerOutputStream();\n+            tmpout2.putOctetString(encryptedData);\n+            bytes2.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,\n+                    false, (byte) 0), tmpout2);\n+\n+            \/\/ wrap EncryptedContentInfo in a Sequence\n+            DerOutputStream out = new DerOutputStream();\n+            out.write(DerValue.tag_Sequence, bytes2);\n+            return out.toByteArray();\n+        } catch (IOException ioe) {\n+            throw ioe;\n@@ -1909,16 +1911,0 @@\n-\n-        \/\/ create EncryptedContentInfo\n-        DerOutputStream bytes2 = new DerOutputStream();\n-        bytes2.putOID(ContentInfo.DATA_OID);\n-        bytes2.write(encodedAlgId);\n-\n-        \/\/ Wrap encrypted data in a context-specific tag.\n-        DerOutputStream tmpout2 = new DerOutputStream();\n-        tmpout2.putOctetString(encryptedData);\n-        bytes2.writeImplicit(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                        false, (byte)0), tmpout2);\n-\n-        \/\/ wrap EncryptedContentInfo in a Sequence\n-        DerOutputStream out = new DerOutputStream();\n-        out.write(DerValue.tag_Sequence, bytes2);\n-        return out.toByteArray();\n@@ -1947,4 +1933,6 @@\n-        DataInputStream dis;\n-        CertificateFactory cf = null;\n-        ByteArrayInputStream bais = null;\n-        byte[] encoded = null;\n+\n+        \/\/ Reset config when loading a different keystore.\n+        certProtectionAlgorithm = null;\n+        certPbeIterationCount = -1;\n+        macAlgorithm = null;\n+        macIterationCount = -1;\n@@ -1990,0 +1978,2 @@\n+        boolean seeEncBag = false;\n+\n@@ -2015,0 +2005,15 @@\n+                    \/\/ No password to decrypt ENCRYPTED_DATA_OID. *Skip it*.\n+                    \/\/ This means user will see a PrivateKeyEntry without\n+                    \/\/ certificates and a whole TrustedCertificateEntry will\n+                    \/\/ be lost. This is not a perfect solution but alternative\n+                    \/\/ solutions are more disruptive:\n+                    \/\/\n+                    \/\/ We cannot just fail, since KeyStore.load(is, null)\n+                    \/\/ has been known to never fail because of a null password.\n+                    \/\/\n+                    \/\/ We cannot just throw away the whole PrivateKeyEntry,\n+                    \/\/ this is too silent and no one will notice anything.\n+                    \/\/\n+                    \/\/ We also cannot fail when getCertificate() on such a\n+                    \/\/ PrivateKeyEntry is called, since the method has not\n+                    \/\/ specified this behavior.\n@@ -2058,1 +2063,1 @@\n-                        throw new IOException(\"PBE iteration count too large\");\n+                        throw new IOException(\"cert PBE iteration count too large\");\n@@ -2060,0 +2065,5 @@\n+\n+                    certProtectionAlgorithm\n+                            = mapPBEParamsToAlgorithm(algOid, algParams);\n+                    certPbeIterationCount = ic;\n+                    seeEncBag = true;\n@@ -2064,1 +2074,1 @@\n-                        \"(\" + new AlgorithmId(algOid).getName() +\n+                        \"(\" + mapPBEParamsToAlgorithm(algOid, algParams) +\n@@ -2089,0 +2099,5 @@\n+        \/\/ No ENCRYPTED_DATA_OID but see certificate. Must be passwordless.\n+        if (!seeEncBag && certificateCount > 0) {\n+            certProtectionAlgorithm = \"NONE\";\n+        }\n+\n@@ -2090,3 +2105,6 @@\n-        if (password != null && s.available() > 0) {\n-            MacData macData = new MacData(s);\n-            int ic = macData.getIterations();\n+        if (s.available() > 0) {\n+            \/\/ If there is no password, we cannot fail. KeyStore.load(is, null)\n+            \/\/ has been known to never fail because of a null password.\n+            if (password != null) {\n+                MacData macData = new MacData(s);\n+                int ic = macData.getIterations();\n@@ -2094,5 +2112,5 @@\n-            try {\n-                if (ic > MAX_ITERATION_COUNT) {\n-                    throw new InvalidAlgorithmParameterException(\n-                        \"MAC iteration count too large: \" + ic);\n-                }\n+                try {\n+                    if (ic > MAX_ITERATION_COUNT) {\n+                        throw new InvalidAlgorithmParameterException(\n+                                \"MAC iteration count too large: \" + ic);\n+                    }\n@@ -2100,2 +2118,2 @@\n-                String algName =\n-                        macData.getDigestAlgName().toUpperCase(Locale.ENGLISH);\n+                    String algName =\n+                            macData.getDigestAlgName().toUpperCase(Locale.ENGLISH);\n@@ -2103,2 +2121,2 @@\n-                \/\/ Change SHA-1 to SHA1\n-                algName = algName.replace(\"-\", \"\");\n+                    \/\/ Change SHA-1 to SHA1\n+                    algName = algName.replace(\"-\", \"\");\n@@ -2106,4 +2124,2 @@\n-                \/\/ generate MAC (MAC key is created within JCE)\n-                Mac m = Mac.getInstance(\"HmacPBE\" + algName);\n-                PBEParameterSpec params =\n-                        new PBEParameterSpec(macData.getSalt(), ic);\n+                    macAlgorithm = \"HmacPBE\" + algName;\n+                    macIterationCount = ic;\n@@ -2111,5 +2127,4 @@\n-                RetryWithZero.run(pass -> {\n-                    SecretKey key = getPBEKey(pass);\n-                    m.init(key, params);\n-                    m.update(authSafeData);\n-                    byte[] macResult = m.doFinal();\n+                    \/\/ generate MAC (MAC key is created within JCE)\n+                    Mac m = Mac.getInstance(macAlgorithm);\n+                    PBEParameterSpec params =\n+                            new PBEParameterSpec(macData.getSalt(), ic);\n@@ -2117,4 +2132,10 @@\n-                    if (debug != null) {\n-                        debug.println(\"Checking keystore integrity \" +\n-                                \"(\" + m.getAlgorithm() + \" iterations: \" + ic + \")\");\n-                    }\n+                    RetryWithZero.run(pass -> {\n+                        SecretKey key = getPBEKey(pass);\n+                        m.init(key, params);\n+                        m.update(authSafeData);\n+                        byte[] macResult = m.doFinal();\n+\n+                        if (debug != null) {\n+                            debug.println(\"Checking keystore integrity \" +\n+                                    \"(\" + m.getAlgorithm() + \" iterations: \" + ic + \")\");\n+                        }\n@@ -2122,8 +2143,9 @@\n-                    if (!MessageDigest.isEqual(macData.getDigest(), macResult)) {\n-                        throw new UnrecoverableKeyException(\"Failed PKCS12\" +\n-                                \" integrity checking\");\n-                    }\n-                    return (Void)null;\n-                }, password);\n-            } catch (Exception e) {\n-                throw new IOException(\"Integrity check failed: \" + e, e);\n+                        if (!MessageDigest.isEqual(macData.getDigest(), macResult)) {\n+                            throw new UnrecoverableKeyException(\"Failed PKCS12\" +\n+                                    \" integrity checking\");\n+                        }\n+                        return (Void) null;\n+                    }, password);\n+                } catch (Exception e) {\n+                    throw new IOException(\"Integrity check failed: \" + e, e);\n+                }\n@@ -2131,0 +2153,2 @@\n+        } else {\n+            macAlgorithm = \"NONE\";\n@@ -2170,1 +2194,1 @@\n-                if (chain.size() > 0)\n+                if (chain.size() > 0) {\n@@ -2172,0 +2196,6 @@\n+                } else {\n+                    \/\/ Remove private key entries where there is no associated\n+                    \/\/ certs. Most likely the keystore is loaded with a null\n+                    \/\/ password.\n+                    entries.remove(entry);\n+                }\n@@ -2186,0 +2216,40 @@\n+    \/**\n+     * Returns if a pkcs12 file is password-less. This means no cert is\n+     * encrypted and there is no Mac. Please note that the private key\n+     * can be encrypted.\n+     *\n+     * This is a simplified version of {@link #engineLoad} that only looks\n+     * at the ContentInfo types.\n+     *\n+     * @param f the pkcs12 file\n+     * @return if it's password-less\n+     * @throws IOException\n+     *\/\n+    public static boolean isPasswordless(File f) throws IOException {\n+\n+        try (FileInputStream stream = new FileInputStream(f)) {\n+            DerValue val = new DerValue(stream);\n+            DerInputStream s = val.toDerInputStream();\n+\n+            s.getInteger(); \/\/ skip version\n+\n+            ContentInfo authSafe = new ContentInfo(s);\n+            DerInputStream as = new DerInputStream(authSafe.getData());\n+            for (DerValue seq : as.getSequence(2)) {\n+                DerInputStream sci = new DerInputStream(seq.toByteArray());\n+                ContentInfo safeContents = new ContentInfo(sci);\n+                if (safeContents.getContentType()\n+                        .equals(ContentInfo.ENCRYPTED_DATA_OID)) {\n+                    \/\/ Certificate encrypted\n+                    return false;\n+                }\n+            }\n+\n+            if (s.available() > 0) {\n+                \/\/ The MacData exists.\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n@@ -2342,2 +2412,2 @@\n-                if (bagItem instanceof PrivateKeyEntry) {\n-                    if (keyId == null) {\n+                if (keyId == null) {\n+                    if (bagItem instanceof PrivateKeyEntry) {\n@@ -2353,0 +2423,3 @@\n+                    } else {\n+                        \/\/ keyId in a SecretKeyEntry is not significant\n+                        keyId = \"00\".getBytes(\"UTF8\");\n@@ -2423,0 +2496,79 @@\n+\n+    \/\/ 8076190: Customizing the generation of a PKCS12 keystore\n+\n+    private static String defaultCertProtectionAlgorithm() {\n+        String result = SecurityProperties.privilegedGetOverridable(\n+                \"keystore.pkcs12.certProtectionAlgorithm\");\n+        return (result != null && !result.isEmpty())\n+                ? result : \"PBEWithSHA1AndRC2_40\";\n+    }\n+\n+    private static int defaultCertPbeIterationCount() {\n+        String result = SecurityProperties.privilegedGetOverridable(\n+                \"keystore.pkcs12.certPbeIterationCount\");\n+        return (result != null && !result.isEmpty())\n+                ? string2IC(\"certPbeIterationCount\", result) : 50000;\n+    }\n+\n+    \/\/ Read both \"keystore.pkcs12.keyProtectionAlgorithm\" and\n+    \/\/ \"keystore.PKCS12.keyProtectionAlgorithm\" for compatibility.\n+    private static String defaultKeyProtectionAlgorithm() {\n+        String result = AccessController.doPrivileged(new PrivilegedAction<String>() {\n+            public String run() {\n+                String result;\n+                String name1 = \"keystore.pkcs12.keyProtectionAlgorithm\";\n+                String name2 = \"keystore.PKCS12.keyProtectionAlgorithm\";\n+                result = System.getProperty(name1);\n+                if (result != null) {\n+                    return result;\n+                }\n+                result = System.getProperty(name2);\n+                if (result != null) {\n+                    return result;\n+                }\n+                result = Security.getProperty(name1);\n+                if (result != null) {\n+                    return result;\n+                }\n+                return Security.getProperty(name2);\n+            }\n+        });\n+        return (result != null && !result.isEmpty())\n+                ? result : \"PBEWithSHA1AndDESede\";\n+    }\n+\n+    private static int defaultKeyPbeIterationCount() {\n+        String result = SecurityProperties.privilegedGetOverridable(\n+                \"keystore.pkcs12.keyPbeIterationCount\");\n+        return (result != null && !result.isEmpty())\n+                ? string2IC(\"keyPbeIterationCount\", result) : 50000;\n+    }\n+\n+    private static String defaultMacAlgorithm() {\n+        String result = SecurityProperties.privilegedGetOverridable(\n+                \"keystore.pkcs12.macAlgorithm\");\n+        return (result != null && !result.isEmpty())\n+                ? result : \"HmacPBESHA1\";\n+    }\n+\n+    private static int defaultMacIterationCount() {\n+        String result = SecurityProperties.privilegedGetOverridable(\n+                \"keystore.pkcs12.macIterationCount\");\n+        return (result != null && !result.isEmpty())\n+                ? string2IC(\"macIterationCount\", result) : 100000;\n+    }\n+\n+    private static int string2IC(String type, String value) {\n+        int number;\n+        try {\n+            number = Integer.parseInt(value);\n+        } catch (NumberFormatException e) {\n+            throw new IllegalArgumentException(\"keystore.pkcs12.\" + type\n+                    + \" is not a number: \" + value);\n+        }\n+        if (number <= 0 || number > MAX_ITERATION_COUNT) {\n+            throw new IllegalArgumentException(\"Invalid keystore.pkcs12.\"\n+                    + type + \": \" + value);\n+        }\n+        return number;\n+    }\n","filename":"jdk\/src\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":324,"deletions":172,"binary":false,"changes":496,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+import sun.security.pkcs12.PKCS12KeyStore;\n@@ -83,0 +84,1 @@\n+import sun.security.util.SecurityProperties;\n@@ -193,0 +195,1 @@\n+    private boolean isPasswordlessKeyStore = false;\n@@ -838,0 +841,18 @@\n+        if (keyStore.getProvider().getName().equals(\"SunJSSE\") &&\n+                storetype.equalsIgnoreCase(P12KEYSTORE)) {\n+            if (ksfile != null && ksStream != null) {\n+                try {\n+                    isPasswordlessKeyStore = PKCS12KeyStore.isPasswordless(ksfile);\n+                } catch(IOException ioe) {\n+                    \/\/ This must be a JKS keystore that's opened as a PKCS12\n+                }\n+            } else {\n+                \/\/ When creating a new pkcs12 file, Do not prompt for storepass\n+                \/\/ if certProtectionAlgorithm and macAlgorithm are both NONE.\n+                isPasswordlessKeyStore =\n+                        \"NONE\".equals(SecurityProperties.privilegedGetOverridable(\n+                                \"keystore.pkcs12.certProtectionAlgorithm\"))\n+                                && \"NONE\".equals(SecurityProperties.privilegedGetOverridable(\n+                                \"keystore.pkcs12.macAlgorithm\"));\n+            }\n+        }\n@@ -857,5 +878,4 @@\n-\n-            \/\/ only prompt if (protectedPath == false)\n-\n-            if (!protectedPath && !KeyStoreUtil.isWindowsKeyStore(storetype) &&\n-                (command == CERTREQ ||\n+            if (!protectedPath && !KeyStoreUtil.isWindowsKeyStore(storetype)\n+                    && isKeyStoreRelated(command)\n+                    && !isPasswordlessKeyStore) {\n+                if (command == CERTREQ ||\n@@ -873,31 +893,19 @@\n-                        command == IDENTITYDB)) {\n-                int count = 0;\n-                do {\n-                    if (command == IMPORTKEYSTORE) {\n-                        System.err.print\n-                                (rb.getString(\"Enter.destination.keystore.password.\"));\n-                    } else {\n-                        System.err.print\n-                                (rb.getString(\"Enter.keystore.password.\"));\n-                    }\n-                    System.err.flush();\n-                    storePass = Password.readPassword(System.in);\n-                    passwords.add(storePass);\n-\n-                    \/\/ If we are creating a new non nullStream-based keystore,\n-                    \/\/ insist that the password be at least 6 characters\n-                    if (!nullStream && (storePass == null || storePass.length < 6)) {\n-                        System.err.println(rb.getString\n-                                (\"Keystore.password.is.too.short.must.be.at.least.6.characters\"));\n-                        storePass = null;\n-                    }\n-\n-                    \/\/ If the keystore file does not exist and needs to be\n-                    \/\/ created, the storepass should be prompted twice.\n-                    if (storePass != null && !nullStream && ksStream == null) {\n-                        System.err.print(rb.getString(\"Re.enter.new.password.\"));\n-                        char[] storePassAgain = Password.readPassword(System.in);\n-                        passwords.add(storePassAgain);\n-                        if (!Arrays.equals(storePass, storePassAgain)) {\n-                            System.err.println\n-                                (rb.getString(\"They.don.t.match.Try.again\"));\n+                        command == IDENTITYDB) {\n+                    int count = 0;\n+                    do {\n+                        if (command == IMPORTKEYSTORE) {\n+                            System.err.print\n+                                    (rb.getString(\"Enter.destination.keystore.password.\"));\n+                        } else {\n+                            System.err.print\n+                                    (rb.getString(\"Enter.keystore.password.\"));\n+                        }\n+                        System.err.flush();\n+                        storePass = Password.readPassword(System.in);\n+                        passwords.add(storePass);\n+\n+                        \/\/ If we are creating a new non nullStream-based keystore,\n+                        \/\/ insist that the password be at least 6 characters\n+                        if (!nullStream && (storePass == null || storePass.length < 6)) {\n+                            System.err.println(rb.getString\n+                                    (\"Keystore.password.is.too.short.must.be.at.least.6.characters\"));\n@@ -906,1 +914,0 @@\n-                    }\n@@ -908,2 +915,12 @@\n-                    count++;\n-                } while ((storePass == null) && count < 3);\n+                        \/\/ If the keystore file does not exist and needs to be\n+                        \/\/ created, the storepass should be prompted twice.\n+                        if (storePass != null && !nullStream && ksStream == null) {\n+                            System.err.print(rb.getString(\"Re.enter.new.password.\"));\n+                            char[] storePassAgain = Password.readPassword(System.in);\n+                            passwords.add(storePassAgain);\n+                            if (!Arrays.equals(storePass, storePassAgain)) {\n+                                System.err.println\n+                                        (rb.getString(\"They.don.t.match.Try.again\"));\n+                                storePass = null;\n+                            }\n+                        }\n@@ -911,0 +928,2 @@\n+                        count++;\n+                    } while ((storePass == null) && count < 3);\n@@ -912,14 +931,14 @@\n-                if (storePass == null) {\n-                    System.err.println\n-                        (rb.getString(\"Too.many.failures.try.later\"));\n-                    return;\n-                }\n-            } else if (!protectedPath\n-                    && !KeyStoreUtil.isWindowsKeyStore(storetype)\n-                    && isKeyStoreRelated(command)) {\n-                \/\/ here we have EXPORTCERT and LIST (info valid until STOREPASSWD)\n-                if (command != PRINTCRL) {\n-                    System.err.print(rb.getString(\"Enter.keystore.password.\"));\n-                    System.err.flush();\n-                    storePass = Password.readPassword(System.in);\n-                    passwords.add(storePass);\n+\n+                    if (storePass == null) {\n+                        System.err.println\n+                                (rb.getString(\"Too.many.failures.try.later\"));\n+                        return;\n+                    }\n+                } else {\n+                    \/\/ here we have EXPORTCERT and LIST (info valid until STOREPASSWD)\n+                    if (command != PRINTCRL) {\n+                        System.err.print(rb.getString(\"Enter.keystore.password.\"));\n+                        System.err.flush();\n+                        storePass = Password.readPassword(System.in);\n+                        passwords.add(storePass);\n+                    }\n@@ -1118,1 +1137,2 @@\n-                    && !KeyStoreUtil.isWindowsKeyStore(storetype)) {\n+                    && !KeyStoreUtil.isWindowsKeyStore(storetype)\n+                    && !isPasswordlessKeyStore) {\n@@ -1496,1 +1516,2 @@\n-                && !KeyStoreUtil.isWindowsKeyStore(storetype)) {\n+                && !KeyStoreUtil.isWindowsKeyStore(storetype)\n+                && !isPasswordlessKeyStore) {\n@@ -1527,1 +1548,1 @@\n-        if (P12KEYSTORE.equalsIgnoreCase(storetype)) {\n+        if (origPass != null && P12KEYSTORE.equalsIgnoreCase(storetype)) {\n@@ -1536,9 +1557,12 @@\n-                System.err.println(form.format(source));\n-                if (orig == null) {\n-                    System.err.print(rb.getString\n-                            (\".RETURN.if.same.as.keystore.password.\"));\n-                } else {\n-                    form = new MessageFormat(rb.getString\n-                            (\".RETURN.if.same.as.for.otherAlias.\"));\n-                    Object[] src = {orig};\n-                    System.err.print(form.format(src));\n+                System.err.print(form.format(source));\n+                if (origPass != null) {\n+                    System.err.println();\n+                    if (orig == null) {\n+                        System.err.print(rb.getString\n+                                (\".RETURN.if.same.as.keystore.password.\"));\n+                    } else {\n+                        form = new MessageFormat(rb.getString\n+                                (\".RETURN.if.same.as.for.otherAlias.\"));\n+                        Object[] src = {orig};\n+                        System.err.print(form.format(src));\n+                    }\n@@ -1549,1 +1573,1 @@\n-                if (entered == null) {\n+                if (entered == null && origPass != null) {\n@@ -1551,1 +1575,1 @@\n-                } else if (entered.length >= 6) {\n+                } else if (entered != null && entered.length >= 6) {\n@@ -1944,0 +1968,3 @@\n+            } else {\n+                out.println(rb.getString\n+                        (\"Certificate.chain.length.\") + 0);\n@@ -2008,0 +2035,1 @@\n+        boolean srcIsPasswordless = false;\n@@ -2032,0 +2060,9 @@\n+            if (store.getProvider().getName().equals(\"SunJSSE\") &&\n+                    srcstoretype.equalsIgnoreCase(P12KEYSTORE) &&\n+                    srcksfile != null && is != null) {\n+                try {\n+                    srcIsPasswordless = PKCS12KeyStore.isPasswordless(srcksfile);\n+                } catch(IOException ioe) {\n+                    \/\/ This must be a JKS keystore that's opened as a PKCS12\n+                }\n+            }\n@@ -2035,1 +2072,2 @@\n-                    && !KeyStoreUtil.isWindowsKeyStore(srcstoretype)) {\n+                    && !KeyStoreUtil.isWindowsKeyStore(srcstoretype)\n+                    && !srcIsPasswordless) {\n@@ -2062,0 +2100,1 @@\n+                && !srcIsPasswordless\n@@ -3375,12 +3414,9 @@\n-            try {\n-                key = keyStore.getKey(alias, storePass);\n-\n-                keyPass = storePass;\n-                passwords.add(keyPass);\n-            } catch (UnrecoverableKeyException e) {\n-                \/\/ Did not work out, so prompt user for key password\n-                if (!token) {\n-                    keyPass = getKeyPasswd(alias, null, null);\n-                    key = keyStore.getKey(alias, keyPass);\n-                } else {\n-                    throw e;\n+            if (storePass != null) {\n+                try {\n+                    key = keyStore.getKey(alias, storePass);\n+                    passwords.add(storePass);\n+                    return Pair.of(key, storePass);\n+                } catch (UnrecoverableKeyException e) {\n+                    if (token) {\n+                        throw e;\n+                    }\n@@ -3389,0 +3425,4 @@\n+            \/\/ prompt user for key password\n+            keyPass = getKeyPasswd(alias, null, null);\n+            key = keyStore.getKey(alias, keyPass);\n+            return Pair.of(key, keyPass);\n@@ -3391,0 +3431,1 @@\n+            return Pair.of(key, keyPass);\n@@ -3392,2 +3433,0 @@\n-\n-        return Pair.of(key, keyPass);\n@@ -3407,4 +3446,3 @@\n-\n-        if (ks.containsAlias(alias) == false) {\n-            MessageFormat form = new MessageFormat\n-                (rb.getString(\"Alias.alias.does.not.exist\"));\n+        if (!ks.containsAlias(alias)) {\n+            MessageFormat form = new MessageFormat(\n+                    rb.getString(\"Alias.alias.does.not.exist\"));\n@@ -3415,3 +3453,3 @@\n-        PasswordProtection pp = null;\n-        Entry entry;\n-\n+        \/\/ Step 1: First attempt to access entry without key password\n+        \/\/ (PKCS11 entry or trusted certificate entry, for example).\n+        \/\/ If fail, go next.\n@@ -3419,5 +3457,2 @@\n-            \/\/ First attempt to access entry without key password\n-            \/\/ (PKCS11 entry or trusted certificate entry, for example)\n-\n-            entry = ks.getEntry(alias, pp);\n-            pkey = null;\n+            Entry entry = ks.getEntry(alias, null);\n+            return Pair.of(entry, null);\n@@ -3425,1 +3460,0 @@\n-\n@@ -3427,1 +3461,1 @@\n-                KeyStoreUtil.isWindowsKeyStore(ks.getType())) {\n+                    KeyStoreUtil.isWindowsKeyStore(ks.getType())) {\n@@ -3431,0 +3465,1 @@\n+        }\n@@ -3432,27 +3467,7 @@\n-            \/\/ entry is protected\n-\n-            if (pkey != null) {\n-\n-                \/\/ try provided key password\n-\n-                pp = new PasswordProtection(pkey);\n-                entry = ks.getEntry(alias, pp);\n-\n-            } else {\n-\n-                \/\/ try store pass\n-\n-                try {\n-                    pp = new PasswordProtection(pstore);\n-                    entry = ks.getEntry(alias, pp);\n-                    pkey = pstore;\n-                } catch (UnrecoverableEntryException une2) {\n-                    if (P12KEYSTORE.equalsIgnoreCase(ks.getType())) {\n-\n-                        \/\/ P12 keystore currently does not support separate\n-                        \/\/ store and entry passwords\n-\n-                        throw une2;\n-                    } else {\n-\n-                        \/\/ prompt for entry password\n+        \/\/ entry is protected\n+        \/\/ Step 2: try pkey if not null. If fail, fail.\n+        if (pkey != null) {\n+            PasswordProtection pp = new PasswordProtection(pkey);\n+            Entry entry = ks.getEntry(alias, pp);\n+            return Pair.of(entry, pkey);\n+        }\n@@ -3460,4 +3475,12 @@\n-                        pkey = getKeyPasswd(alias, null, null);\n-                        pp = new PasswordProtection(pkey);\n-                        entry = ks.getEntry(alias, pp);\n-                    }\n+        \/\/ Step 3: try pstore if not null. If fail, go next.\n+        if (pstore != null) {\n+            try {\n+                PasswordProtection pp = new PasswordProtection(pstore);\n+                Entry entry = ks.getEntry(alias, pp);\n+                return Pair.of(entry, pstore);\n+            } catch (UnrecoverableEntryException une) {\n+                if (P12KEYSTORE.equalsIgnoreCase(ks.getType())) {\n+                    \/\/ P12 keystore currently does not support separate\n+                    \/\/ store and entry passwords. We will not prompt for\n+                    \/\/ entry password.\n+                    throw une;\n@@ -3468,0 +3491,4 @@\n+        \/\/ Step 4: prompt for entry password\n+        pkey = getKeyPasswd(alias, null, null);\n+        PasswordProtection pp = new PasswordProtection(pkey);\n+        Entry entry = ks.getEntry(alias, pp);\n@@ -3470,0 +3497,1 @@\n+\n","filename":"jdk\/src\/share\/classes\/sun\/security\/tools\/keytool\/Main.java","additions":155,"deletions":127,"binary":false,"changes":282,"status":"modified"},{"patch":"@@ -824,0 +824,4 @@\n+    public static ObjectIdentifier pbeWithSHA1AndRC4_128_oid =\n+        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 1});\n+    public static ObjectIdentifier pbeWithSHA1AndRC4_40_oid =\n+        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 2});\n@@ -826,0 +830,2 @@\n+    public static ObjectIdentifier pbeWithSHA1AndRC2_128_oid =\n+        ObjectIdentifier.newInternal(new int[] {1, 2, 840, 113549, 1, 12, 1, 5});\n@@ -1014,0 +1020,2 @@\n+        nameTable.put(pbeWithSHA1AndRC4_128_oid, \"PBEWithSHA1AndRC4_128\");\n+        nameTable.put(pbeWithSHA1AndRC4_40_oid, \"PBEWithSHA1AndRC4_40\");\n@@ -1015,0 +1023,1 @@\n+        nameTable.put(pbeWithSHA1AndRC2_128_oid, \"PBEWithSHA1AndRC2_128\");\n","filename":"jdk\/src\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1095,0 +1095,71 @@\n+#\n+# PKCS12 KeyStore properties\n+#\n+# The following properties, if configured, are used by the PKCS12 KeyStore\n+# implementation during the creation of a new keystore. Several of the\n+# properties may also be used when modifying an existing keystore. The\n+# properties can be overridden by a KeyStore API that specifies its own\n+# algorithms and parameters.\n+#\n+# If an existing PKCS12 keystore is loaded and then stored, the algorithm and\n+# parameter used to generate the existing Mac will be reused. If the existing\n+# keystore does not have a Mac, no Mac will be created while storing. If there\n+# is at least one certificate in the existing keystore, the algorithm and\n+# parameters used to encrypt the last certificate in the existing keystore will\n+# be reused to encrypt all certificates while storing. If the last certificate\n+# in the existing keystore is not encrypted, all certificates will be stored\n+# unencrypted. If there is no certificate in the existing keystore, any newly\n+# added certificate will be encrypted (or stored unencrypted if algorithm\n+# value is \"NONE\") using the \"keystore.pkcs12.certProtectionAlgorithm\" and\n+# \"keystore.pkcs12.certPbeIterationCount\" values defined here. Existing private\n+# and secret key(s) are not changed. Newly set private and secret key(s) will\n+# be encrypted using the \"keystore.pkcs12.keyProtectionAlgorithm\" and\n+# \"keystore.pkcs12.keyPbeIterationCount\" values defined here.\n+#\n+# In order to apply new algorithms and parameters to all entries in an\n+# existing keystore, one can create a new keystore and add entries in the\n+# existing keystore into the new keystore. This can be achieved by calling the\n+# \"keytool -importkeystore\" command.\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# If the property is set to an illegal value,\n+# an iteration count that is not a positive integer, or an unknown algorithm\n+# name, an exception will be thrown when the property is used.\n+# If the property is not set or empty, a default value will be used.\n+#\n+# Note: These properties are currently used by the JDK Reference implementation.\n+# They are not guaranteed to be examined and used by other implementations.\n+\n+# The algorithm used to encrypt a certificate. This can be any non-Hmac PBE\n+# algorithm defined in the Cipher section of the Java Security Standard\n+# Algorithm Names Specification. When set to \"NONE\", the certificate\n+# is not encrypted. The default value is \"PBEWithSHA1AndRC2_40\".\n+#keystore.pkcs12.certProtectionAlgorithm = PBEWithSHA1AndRC2_40\n+\n+# The iteration count used by the PBE algorithm when encrypting a certificate.\n+# This value must be a positive integer. The default value is 50000.\n+#keystore.pkcs12.certPbeIterationCount = 50000\n+\n+# The algorithm used to encrypt a private key or secret key. This can be\n+# any non-Hmac PBE algorithm defined in the Cipher section of the Java\n+# Security Standard Algorithm Names Specification. The value must not be \"NONE\".\n+# The default value is \"PBEWithSHA1AndDESede\".\n+#keystore.pkcs12.keyProtectionAlgorithm = PBEWithSHA1AndDESede\n+\n+# The iteration count used by the PBE algorithm when encrypting a private key\n+# or a secret key. This value must be a positive integer. The default value\n+# is 50000.\n+#keystore.pkcs12.keyPbeIterationCount = 50000\n+\n+# The algorithm used to calculate the optional MacData at the end of a PKCS12\n+# file. This can be any HmacPBE algorithm defined in the Mac section of the\n+# Java Security Standard Algorithm Names Specification. When set to \"NONE\",\n+# no Mac is generated. The default value is \"HmacPBESHA1\".\n+#keystore.pkcs12.macAlgorithm = HmacPBESHA1\n+\n+# The iteration count used by the MacData algorithm. This value must be a\n+# positive integer. The default value is 100000.\n+#keystore.pkcs12.macIterationCount = 100000\n+\n","filename":"jdk\/src\/share\/lib\/security\/java.security-aix","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1101,0 +1101,71 @@\n+#\n+# PKCS12 KeyStore properties\n+#\n+# The following properties, if configured, are used by the PKCS12 KeyStore\n+# implementation during the creation of a new keystore. Several of the\n+# properties may also be used when modifying an existing keystore. The\n+# properties can be overridden by a KeyStore API that specifies its own\n+# algorithms and parameters.\n+#\n+# If an existing PKCS12 keystore is loaded and then stored, the algorithm and\n+# parameter used to generate the existing Mac will be reused. If the existing\n+# keystore does not have a Mac, no Mac will be created while storing. If there\n+# is at least one certificate in the existing keystore, the algorithm and\n+# parameters used to encrypt the last certificate in the existing keystore will\n+# be reused to encrypt all certificates while storing. If the last certificate\n+# in the existing keystore is not encrypted, all certificates will be stored\n+# unencrypted. If there is no certificate in the existing keystore, any newly\n+# added certificate will be encrypted (or stored unencrypted if algorithm\n+# value is \"NONE\") using the \"keystore.pkcs12.certProtectionAlgorithm\" and\n+# \"keystore.pkcs12.certPbeIterationCount\" values defined here. Existing private\n+# and secret key(s) are not changed. Newly set private and secret key(s) will\n+# be encrypted using the \"keystore.pkcs12.keyProtectionAlgorithm\" and\n+# \"keystore.pkcs12.keyPbeIterationCount\" values defined here.\n+#\n+# In order to apply new algorithms and parameters to all entries in an\n+# existing keystore, one can create a new keystore and add entries in the\n+# existing keystore into the new keystore. This can be achieved by calling the\n+# \"keytool -importkeystore\" command.\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# If the property is set to an illegal value,\n+# an iteration count that is not a positive integer, or an unknown algorithm\n+# name, an exception will be thrown when the property is used.\n+# If the property is not set or empty, a default value will be used.\n+#\n+# Note: These properties are currently used by the JDK Reference implementation.\n+# They are not guaranteed to be examined and used by other implementations.\n+\n+# The algorithm used to encrypt a certificate. This can be any non-Hmac PBE\n+# algorithm defined in the Cipher section of the Java Security Standard\n+# Algorithm Names Specification. When set to \"NONE\", the certificate\n+# is not encrypted. The default value is \"PBEWithSHA1AndRC2_40\".\n+#keystore.pkcs12.certProtectionAlgorithm = PBEWithSHA1AndRC2_40\n+\n+# The iteration count used by the PBE algorithm when encrypting a certificate.\n+# This value must be a positive integer. The default value is 50000.\n+#keystore.pkcs12.certPbeIterationCount = 50000\n+\n+# The algorithm used to encrypt a private key or secret key. This can be\n+# any non-Hmac PBE algorithm defined in the Cipher section of the Java\n+# Security Standard Algorithm Names Specification. The value must not be \"NONE\".\n+# The default value is \"PBEWithSHA1AndDESede\".\n+#keystore.pkcs12.keyProtectionAlgorithm = PBEWithSHA1AndDESede\n+\n+# The iteration count used by the PBE algorithm when encrypting a private key\n+# or a secret key. This value must be a positive integer. The default value\n+# is 50000.\n+#keystore.pkcs12.keyPbeIterationCount = 50000\n+\n+# The algorithm used to calculate the optional MacData at the end of a PKCS12\n+# file. This can be any HmacPBE algorithm defined in the Mac section of the\n+# Java Security Standard Algorithm Names Specification. When set to \"NONE\",\n+# no Mac is generated. The default value is \"HmacPBESHA1\".\n+#keystore.pkcs12.macAlgorithm = HmacPBESHA1\n+\n+# The iteration count used by the MacData algorithm. This value must be a\n+# positive integer. The default value is 100000.\n+#keystore.pkcs12.macIterationCount = 100000\n+\n","filename":"jdk\/src\/share\/lib\/security\/java.security-linux","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1099,0 +1099,71 @@\n+#\n+# PKCS12 KeyStore properties\n+#\n+# The following properties, if configured, are used by the PKCS12 KeyStore\n+# implementation during the creation of a new keystore. Several of the\n+# properties may also be used when modifying an existing keystore. The\n+# properties can be overridden by a KeyStore API that specifies its own\n+# algorithms and parameters.\n+#\n+# If an existing PKCS12 keystore is loaded and then stored, the algorithm and\n+# parameter used to generate the existing Mac will be reused. If the existing\n+# keystore does not have a Mac, no Mac will be created while storing. If there\n+# is at least one certificate in the existing keystore, the algorithm and\n+# parameters used to encrypt the last certificate in the existing keystore will\n+# be reused to encrypt all certificates while storing. If the last certificate\n+# in the existing keystore is not encrypted, all certificates will be stored\n+# unencrypted. If there is no certificate in the existing keystore, any newly\n+# added certificate will be encrypted (or stored unencrypted if algorithm\n+# value is \"NONE\") using the \"keystore.pkcs12.certProtectionAlgorithm\" and\n+# \"keystore.pkcs12.certPbeIterationCount\" values defined here. Existing private\n+# and secret key(s) are not changed. Newly set private and secret key(s) will\n+# be encrypted using the \"keystore.pkcs12.keyProtectionAlgorithm\" and\n+# \"keystore.pkcs12.keyPbeIterationCount\" values defined here.\n+#\n+# In order to apply new algorithms and parameters to all entries in an\n+# existing keystore, one can create a new keystore and add entries in the\n+# existing keystore into the new keystore. This can be achieved by calling the\n+# \"keytool -importkeystore\" command.\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# If the property is set to an illegal value,\n+# an iteration count that is not a positive integer, or an unknown algorithm\n+# name, an exception will be thrown when the property is used.\n+# If the property is not set or empty, a default value will be used.\n+#\n+# Note: These properties are currently used by the JDK Reference implementation.\n+# They are not guaranteed to be examined and used by other implementations.\n+\n+# The algorithm used to encrypt a certificate. This can be any non-Hmac PBE\n+# algorithm defined in the Cipher section of the Java Security Standard\n+# Algorithm Names Specification. When set to \"NONE\", the certificate\n+# is not encrypted. The default value is \"PBEWithSHA1AndRC2_40\".\n+#keystore.pkcs12.certProtectionAlgorithm = PBEWithSHA1AndRC2_40\n+\n+# The iteration count used by the PBE algorithm when encrypting a certificate.\n+# This value must be a positive integer. The default value is 50000.\n+#keystore.pkcs12.certPbeIterationCount = 50000\n+\n+# The algorithm used to encrypt a private key or secret key. This can be\n+# any non-Hmac PBE algorithm defined in the Cipher section of the Java\n+# Security Standard Algorithm Names Specification. The value must not be \"NONE\".\n+# The default value is \"PBEWithSHA1AndDESede\".\n+#keystore.pkcs12.keyProtectionAlgorithm = PBEWithSHA1AndDESede\n+\n+# The iteration count used by the PBE algorithm when encrypting a private key\n+# or a secret key. This value must be a positive integer. The default value\n+# is 50000.\n+#keystore.pkcs12.keyPbeIterationCount = 50000\n+\n+# The algorithm used to calculate the optional MacData at the end of a PKCS12\n+# file. This can be any HmacPBE algorithm defined in the Mac section of the\n+# Java Security Standard Algorithm Names Specification. When set to \"NONE\",\n+# no Mac is generated. The default value is \"HmacPBESHA1\".\n+#keystore.pkcs12.macAlgorithm = HmacPBESHA1\n+\n+# The iteration count used by the MacData algorithm. This value must be a\n+# positive integer. The default value is 100000.\n+#keystore.pkcs12.macIterationCount = 100000\n+\n","filename":"jdk\/src\/share\/lib\/security\/java.security-macosx","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1097,0 +1097,71 @@\n+#\n+# PKCS12 KeyStore properties\n+#\n+# The following properties, if configured, are used by the PKCS12 KeyStore\n+# implementation during the creation of a new keystore. Several of the\n+# properties may also be used when modifying an existing keystore. The\n+# properties can be overridden by a KeyStore API that specifies its own\n+# algorithms and parameters.\n+#\n+# If an existing PKCS12 keystore is loaded and then stored, the algorithm and\n+# parameter used to generate the existing Mac will be reused. If the existing\n+# keystore does not have a Mac, no Mac will be created while storing. If there\n+# is at least one certificate in the existing keystore, the algorithm and\n+# parameters used to encrypt the last certificate in the existing keystore will\n+# be reused to encrypt all certificates while storing. If the last certificate\n+# in the existing keystore is not encrypted, all certificates will be stored\n+# unencrypted. If there is no certificate in the existing keystore, any newly\n+# added certificate will be encrypted (or stored unencrypted if algorithm\n+# value is \"NONE\") using the \"keystore.pkcs12.certProtectionAlgorithm\" and\n+# \"keystore.pkcs12.certPbeIterationCount\" values defined here. Existing private\n+# and secret key(s) are not changed. Newly set private and secret key(s) will\n+# be encrypted using the \"keystore.pkcs12.keyProtectionAlgorithm\" and\n+# \"keystore.pkcs12.keyPbeIterationCount\" values defined here.\n+#\n+# In order to apply new algorithms and parameters to all entries in an\n+# existing keystore, one can create a new keystore and add entries in the\n+# existing keystore into the new keystore. This can be achieved by calling the\n+# \"keytool -importkeystore\" command.\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# If the property is set to an illegal value,\n+# an iteration count that is not a positive integer, or an unknown algorithm\n+# name, an exception will be thrown when the property is used.\n+# If the property is not set or empty, a default value will be used.\n+#\n+# Note: These properties are currently used by the JDK Reference implementation.\n+# They are not guaranteed to be examined and used by other implementations.\n+\n+# The algorithm used to encrypt a certificate. This can be any non-Hmac PBE\n+# algorithm defined in the Cipher section of the Java Security Standard\n+# Algorithm Names Specification. When set to \"NONE\", the certificate\n+# is not encrypted. The default value is \"PBEWithSHA1AndRC2_40\".\n+#keystore.pkcs12.certProtectionAlgorithm = PBEWithSHA1AndRC2_40\n+\n+# The iteration count used by the PBE algorithm when encrypting a certificate.\n+# This value must be a positive integer. The default value is 50000.\n+#keystore.pkcs12.certPbeIterationCount = 50000\n+\n+# The algorithm used to encrypt a private key or secret key. This can be\n+# any non-Hmac PBE algorithm defined in the Cipher section of the Java\n+# Security Standard Algorithm Names Specification. The value must not be \"NONE\".\n+# The default value is \"PBEWithSHA1AndDESede\".\n+#keystore.pkcs12.keyProtectionAlgorithm = PBEWithSHA1AndDESede\n+\n+# The iteration count used by the PBE algorithm when encrypting a private key\n+# or a secret key. This value must be a positive integer. The default value\n+# is 50000.\n+#keystore.pkcs12.keyPbeIterationCount = 50000\n+\n+# The algorithm used to calculate the optional MacData at the end of a PKCS12\n+# file. This can be any HmacPBE algorithm defined in the Mac section of the\n+# Java Security Standard Algorithm Names Specification. When set to \"NONE\",\n+# no Mac is generated. The default value is \"HmacPBESHA1\".\n+#keystore.pkcs12.macAlgorithm = HmacPBESHA1\n+\n+# The iteration count used by the MacData algorithm. This value must be a\n+# positive integer. The default value is 100000.\n+#keystore.pkcs12.macIterationCount = 100000\n+\n","filename":"jdk\/src\/share\/lib\/security\/java.security-solaris","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -1099,0 +1099,71 @@\n+#\n+# PKCS12 KeyStore properties\n+#\n+# The following properties, if configured, are used by the PKCS12 KeyStore\n+# implementation during the creation of a new keystore. Several of the\n+# properties may also be used when modifying an existing keystore. The\n+# properties can be overridden by a KeyStore API that specifies its own\n+# algorithms and parameters.\n+#\n+# If an existing PKCS12 keystore is loaded and then stored, the algorithm and\n+# parameter used to generate the existing Mac will be reused. If the existing\n+# keystore does not have a Mac, no Mac will be created while storing. If there\n+# is at least one certificate in the existing keystore, the algorithm and\n+# parameters used to encrypt the last certificate in the existing keystore will\n+# be reused to encrypt all certificates while storing. If the last certificate\n+# in the existing keystore is not encrypted, all certificates will be stored\n+# unencrypted. If there is no certificate in the existing keystore, any newly\n+# added certificate will be encrypted (or stored unencrypted if algorithm\n+# value is \"NONE\") using the \"keystore.pkcs12.certProtectionAlgorithm\" and\n+# \"keystore.pkcs12.certPbeIterationCount\" values defined here. Existing private\n+# and secret key(s) are not changed. Newly set private and secret key(s) will\n+# be encrypted using the \"keystore.pkcs12.keyProtectionAlgorithm\" and\n+# \"keystore.pkcs12.keyPbeIterationCount\" values defined here.\n+#\n+# In order to apply new algorithms and parameters to all entries in an\n+# existing keystore, one can create a new keystore and add entries in the\n+# existing keystore into the new keystore. This can be achieved by calling the\n+# \"keytool -importkeystore\" command.\n+#\n+# If a system property of the same name is also specified, it supersedes the\n+# security property value defined here.\n+#\n+# If the property is set to an illegal value,\n+# an iteration count that is not a positive integer, or an unknown algorithm\n+# name, an exception will be thrown when the property is used.\n+# If the property is not set or empty, a default value will be used.\n+#\n+# Note: These properties are currently used by the JDK Reference implementation.\n+# They are not guaranteed to be examined and used by other implementations.\n+\n+# The algorithm used to encrypt a certificate. This can be any non-Hmac PBE\n+# algorithm defined in the Cipher section of the Java Security Standard\n+# Algorithm Names Specification. When set to \"NONE\", the certificate\n+# is not encrypted. The default value is \"PBEWithSHA1AndRC2_40\".\n+#keystore.pkcs12.certProtectionAlgorithm = PBEWithSHA1AndRC2_40\n+\n+# The iteration count used by the PBE algorithm when encrypting a certificate.\n+# This value must be a positive integer. The default value is 50000.\n+#keystore.pkcs12.certPbeIterationCount = 50000\n+\n+# The algorithm used to encrypt a private key or secret key. This can be\n+# any non-Hmac PBE algorithm defined in the Cipher section of the Java\n+# Security Standard Algorithm Names Specification. The value must not be \"NONE\".\n+# The default value is \"PBEWithSHA1AndDESede\".\n+#keystore.pkcs12.keyProtectionAlgorithm = PBEWithSHA1AndDESede\n+\n+# The iteration count used by the PBE algorithm when encrypting a private key\n+# or a secret key. This value must be a positive integer. The default value\n+# is 50000.\n+#keystore.pkcs12.keyPbeIterationCount = 50000\n+\n+# The algorithm used to calculate the optional MacData at the end of a PKCS12\n+# file. This can be any HmacPBE algorithm defined in the Mac section of the\n+# Java Security Standard Algorithm Names Specification. When set to \"NONE\",\n+# no Mac is generated. The default value is \"HmacPBESHA1\".\n+#keystore.pkcs12.macAlgorithm = HmacPBESHA1\n+\n+# The iteration count used by the MacData algorithm. This value must be a\n+# positive integer. The default value is 100000.\n+#keystore.pkcs12.macIterationCount = 100000\n+\n","filename":"jdk\/src\/share\/lib\/security\/java.security-windows","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.testlibrary.SecurityTools;\n+import sun.security.util.ObjectIdentifier;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static jdk.testlibrary.security.DerUtils.*;\n+import static sun.security.pkcs.ContentInfo.DATA_OID;\n+import static sun.security.pkcs.ContentInfo.ENCRYPTED_DATA_OID;\n+import static sun.security.x509.AlgorithmId.*;\n+\n+\/*\n+ * @test\n+ * @bug 8076190\n+ * @library \/lib\/testlibrary \/lib\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @summary Checks the preferences order of pkcs12 params\n+ *\/\n+public class ParamsPreferences {\n+\n+    public static final void main(String[] args) throws Exception {\n+        int c = 0;\n+\n+        \/\/ with storepass\n+        test(c++, \"-\", \"-\",\n+                pbeWithSHA1AndRC2_40_oid, 50000,\n+                pbeWithSHA1AndDESede_oid, 50000,\n+                SHA_oid, 100000);\n+\n+        \/\/ password-less with system property\n+        test(c++, \"keystore.pkcs12.certProtectionAlgorithm\", \"NONE\",\n+                \"keystore.pkcs12.macAlgorithm\", \"NONE\",\n+                \"-\", \"-\",\n+                null, 0,\n+                pbeWithSHA1AndDESede_oid, 50000,\n+                null, 0);\n+\n+        \/\/ password-less with security property\n+        test(c++, \"-\",\n+                \"keystore.pkcs12.certProtectionAlgorithm\", \"NONE\",\n+                \"keystore.pkcs12.macAlgorithm\", \"NONE\",\n+                \"-\",\n+                null, 0,\n+                pbeWithSHA1AndDESede_oid, 50000,\n+                null, 0);\n+\n+        \/\/ back to with storepass by overriding security property with system property\n+        test(c++, \"keystore.pkcs12.certProtectionAlgorithm\", \"PBEWithSHA1AndDESede\",\n+                \"keystore.pkcs12.macAlgorithm\", \"HmacPBESHA256\",\n+                \"-\",\n+                \"keystore.pkcs12.certProtectionAlgorithm\", \"NONE\",\n+                \"keystore.pkcs12.macAlgorithm\", \"NONE\",\n+                \"-\",\n+                pbeWithSHA1AndDESede_oid, 50000,\n+                pbeWithSHA1AndDESede_oid, 50000,\n+                SHA256_oid, 100000);\n+\n+        \/\/ back to with storepass by using \"\" to force hardcoded default\n+        test(c++, \"keystore.pkcs12.certProtectionAlgorithm\", \"\",\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"\",\n+                \"keystore.pkcs12.macAlgorithm\", \"\",\n+                \"-\",\n+                \"keystore.pkcs12.certProtectionAlgorithm\", \"NONE\",\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_40\",\n+                \"keystore.pkcs12.macAlgorithm\", \"NONE\",\n+                \"-\",\n+                pbeWithSHA1AndRC2_40_oid, 50000,\n+                pbeWithSHA1AndDESede_oid, 50000,\n+                SHA_oid, 100000);\n+\n+        \/\/ change everything with system property\n+        test(c++, \"keystore.pkcs12.certProtectionAlgorithm\", \"PBEWithSHA1AndDESede\",\n+                \"keystore.pkcs12.certPbeIterationCount\", 3000,\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_40\",\n+                \"keystore.pkcs12.keyPbeIterationCount\", 4000,\n+                \"keystore.pkcs12.macAlgorithm\", \"HmacPBESHA256\",\n+                \"keystore.pkcs12.macIterationCount\", 2000,\n+                \"-\", \"-\",\n+                pbeWithSHA1AndDESede_oid, 3000,\n+                pbeWithSHA1AndRC2_40_oid, 4000,\n+                SHA256_oid, 2000);\n+\n+        \/\/ change everything with security property\n+        test(c++, \"-\",\n+                \"keystore.pkcs12.certProtectionAlgorithm\", \"PBEWithSHA1AndDESede\",\n+                \"keystore.pkcs12.certPbeIterationCount\", 3000,\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_40\",\n+                \"keystore.pkcs12.keyPbeIterationCount\", 4000,\n+                \"keystore.pkcs12.macAlgorithm\", \"HmacPBESHA256\",\n+                \"keystore.pkcs12.macIterationCount\", 2000,\n+                \"-\",\n+                pbeWithSHA1AndDESede_oid, 3000,\n+                pbeWithSHA1AndRC2_40_oid, 4000,\n+                SHA256_oid, 2000);\n+\n+        \/\/ override security property with system property\n+        test(c++, \"keystore.pkcs12.certProtectionAlgorithm\", \"PBEWithSHA1AndDESede\",\n+                \"keystore.pkcs12.certPbeIterationCount\", 13000,\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_40\",\n+                \"keystore.pkcs12.keyPbeIterationCount\", 14000,\n+                \"keystore.pkcs12.macAlgorithm\", \"HmacPBESHA256\",\n+                \"keystore.pkcs12.macIterationCount\", 12000,\n+                \"-\",\n+                \"keystore.pkcs12.certProtectionAlgorithm\", \"PBEWithSHA1AndRC2_40\",\n+                \"keystore.pkcs12.certPbeIterationCount\", 3000,\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"PBEWithSHA1AndDESede\",\n+                \"keystore.pkcs12.keyPbeIterationCount\", 4000,\n+                \"keystore.pkcs12.macAlgorithm\", \"HmacPBESHA1\",\n+                \"keystore.pkcs12.macIterationCount\", 2000,\n+                \"-\",\n+                pbeWithSHA1AndDESede_oid, 13000,\n+                pbeWithSHA1AndRC2_40_oid, 14000,\n+                SHA256_oid, 12000);\n+\n+        \/\/ check keyProtectionAlgorithm old behavior. Preferences of\n+        \/\/ 4 different settings.\n+\n+        test(c++, \"-\",\n+                \"keystore.PKCS12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_128\",\n+                \"-\",\n+                pbeWithSHA1AndRC2_40_oid, 50000,\n+                pbeWithSHA1AndRC2_128_oid, 50000,\n+                SHA_oid, 100000);\n+        test(c++, \"-\",\n+                \"keystore.PKCS12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_128\",\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_40\",\n+                \"-\",\n+                pbeWithSHA1AndRC2_40_oid, 50000,\n+                pbeWithSHA1AndRC2_40_oid, 50000,\n+                SHA_oid, 100000);\n+        test(c++,\n+                \"keystore.PKCS12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC4_128\",\n+                \"-\",\n+                \"keystore.PKCS12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_128\",\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_40\",\n+                \"-\",\n+                pbeWithSHA1AndRC2_40_oid, 50000,\n+                pbeWithSHA1AndRC4_128_oid, 50000,\n+                SHA_oid, 100000);\n+        test(c++,\n+                \"keystore.PKCS12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC4_128\",\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC4_40\",\n+                \"-\",\n+                \"keystore.PKCS12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_128\",\n+                \"keystore.pkcs12.keyProtectionAlgorithm\", \"PBEWithSHA1AndRC2_40\",\n+                \"-\",\n+                pbeWithSHA1AndRC2_40_oid, 50000,\n+                pbeWithSHA1AndRC4_40_oid, 50000,\n+                SHA_oid, 100000);\n+    }\n+\n+    \/**\n+     * Run once.\n+     *\n+     * @param args an array containing system properties and values, \"-\",\n+     *             security properties and values, \"-\", expected certPbeAlg,\n+     *             certPbeIC, keyPbeAlg, keyPbeIc, macAlg, macIC.\n+     *\/\n+    static void test(int n, Object... args) throws Exception {\n+        boolean isSysProp = true;\n+        String cmd = \"-keystore ks\" + n + \" -storetype PKCS12 -genkeypair -keyalg EC \"\n+                + \"-alias a -dname CN=A -storepass changeit \"\n+                + \"-J-Djava.security.properties=\" + n + \".conf\";\n+        List<String> jsConf = new ArrayList<>();\n+        for (int i = 0; i < args.length; i++) {\n+            if (isSysProp) {\n+                if (args[i].equals(\"-\")) {\n+                    isSysProp = false;\n+                } else {\n+                    cmd += \" -J-D\" + args[i] + \"=\" + args[++i];\n+                }\n+            } else {\n+                if (args[i] == \"-\") {\n+                    Files.write(Paths.get(n + \".conf\"), jsConf);\n+                    System.out.println(\"--------- test starts ----------\");\n+                    System.out.println(jsConf);\n+                    SecurityTools.keytool(cmd).shouldHaveExitValue(0);\n+\n+                    byte[] data = Files.readAllBytes(Paths.get(\"ks\" + n));\n+\n+                    \/\/ cert pbe alg + ic\n+                    if (args[i+1] == null) {\n+                        checkAlg(data, \"110c10\", DATA_OID);\n+                    } else {\n+                        checkAlg(data, \"110c10\", ENCRYPTED_DATA_OID);\n+                        checkAlg(data, \"110c110110\", (ObjectIdentifier)args[i+1]);\n+                        checkInt(data, \"110c1101111\", (int)args[i+2]);\n+                    }\n+\n+                    \/\/ key pbe alg + ic\n+                    checkAlg(data, \"110c010c01000\", (ObjectIdentifier)args[i+3]);\n+                    checkInt(data, \"110c010c010011\", (int)args[i+4]);\n+\n+                    \/\/ mac alg + ic\n+                    if (args[i+5] == null) {\n+                        shouldNotExist(data, \"2\");\n+                    } else {\n+                        checkAlg(data, \"2000\", (ObjectIdentifier)args[i+5]);\n+                        checkInt(data, \"22\", (int)args[i+6]);\n+                    }\n+                } else {\n+                    jsConf.add(args[i] + \"=\" + args[++i]);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/pkcs12\/ParamsPreferences.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,442 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8076190\n+ * @library \/lib\/testlibrary \/lib\n+ * @modules java.base\/sun.security.pkcs\n+ *          java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @summary Customizing the generation of a PKCS12 keystore\n+ *\/\n+\n+import jdk.testlibrary.Asserts;\n+import jdk.testlibrary.SecurityTools;\n+import jdk.testlibrary.OutputAnalyzer;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.security.KeyStore;\n+import java.util.Base64;\n+import java.util.Objects;\n+\n+import static jdk.testlibrary.security.DerUtils.*;\n+import static sun.security.x509.AlgorithmId.*;\n+import static sun.security.pkcs.ContentInfo.*;\n+\n+public class ParamsTest  {\n+\n+    public static void main(String[] args) throws Throwable {\n+\n+        \/\/ De-BASE64 textual files in .\/params to `pwd`\n+        Files.newDirectoryStream(Paths.get(System.getProperty(\"test.src\"), \"params\"))\n+                .forEach(p -> {\n+                    try (InputStream is = Base64.getMimeDecoder().wrap(Files.newInputStream(p));\n+                         OutputStream os = Files.newOutputStream(p.getFileName())){\n+                            byte[] buffer = new byte[2048];\n+                            int read;\n+                            while ((read = is.read(buffer, 0, 2048)) >= 0) {\n+                                os.write(buffer, 0, read);\n+                            }\n+                    } catch (IOException e) {\n+                        throw new UncheckedIOException(e);\n+                    }\n+                });\n+\n+        byte[] data;\n+\n+        \/\/ openssl -> keytool interop check\n+\n+        \/\/ os2. no cert pbe, no mac.\n+        check(\"os2\", \"a\", null, \"changeit\", true, true, true);\n+        check(\"os2\", \"a\", \"changeit\", \"changeit\", true, true, true);\n+        \/\/ You can even load it with a wrong storepass, controversial\n+        check(\"os2\", \"a\", \"wrongpass\", \"changeit\", true, true, true);\n+\n+        \/\/ os3. no cert pbe, has mac. just like JKS\n+        check(\"os3\", \"a\", null, \"changeit\", true, true, true);\n+        check(\"os3\", \"a\", \"changeit\", \"changeit\", true, true, true);\n+        \/\/ Cannot load with a wrong storepass, same as JKS\n+        check(\"os3\", \"a\", \"wrongpass\", \"-\", IOException.class, \"-\", \"-\");\n+\n+        \/\/ os4. non default algs\n+        check(\"os4\", \"a\", \"changeit\", \"changeit\", true, true, true);\n+        check(\"os4\", \"a\", \"wrongpass\", \"-\", IOException.class, \"-\", \"-\");\n+        \/\/ no storepass no cert\n+        check(\"os4\", \"a\", null, \"changeit\", true, false, true);\n+\n+        \/\/ os5. strong non default algs\n+        check(\"os5\", \"a\", \"changeit\", \"changeit\", true, true, true);\n+        check(\"os5\", \"a\", \"wrongpass\", \"-\", IOException.class, \"-\", \"-\");\n+        \/\/ no storepass no cert\n+        check(\"os5\", \"a\", null, \"changeit\", true, false, true);\n+\n+        \/\/ keytool\n+\n+        \/\/ Current default pkcs12 setting\n+        keytool(\"-importkeystore -srckeystore ks -srcstorepass changeit \"\n+                + \"-deststoretype PKCS12 -destkeystore ksnormal -deststorepass changeit\");\n+        data = Files.readAllBytes(Paths.get(\"ksnormal\"));\n+        checkInt(data, \"22\", 100000); \/\/ Mac ic\n+        checkAlg(data, \"2000\", SHA_oid); \/\/ Mac alg\n+        checkAlg(data, \"110c010c01000\", pbeWithSHA1AndDESede_oid); \/\/ key alg\n+        checkInt(data, \"110c010c010011\", 50000); \/\/ key ic\n+        checkAlg(data, \"110c10\", ENCRYPTED_DATA_OID);\n+        checkAlg(data, \"110c110110\", pbeWithSHA1AndRC2_40_oid); \/\/ cert alg\n+        checkInt(data, \"110c1101111\", 50000); \/\/ cert ic\n+\n+        check(\"ksnormal\", \"a\", \"changeit\", \"changeit\", true, true, true);\n+        check(\"ksnormal\", \"a\", null, \"changeit\", true, false, true);\n+        check(\"ksnormal\", \"a\", \"wrongpass\", \"-\", IOException.class, \"-\", \"-\");\n+\n+        \/\/ Add a new entry with password-less settings, still has a storepass\n+        keytool(\"-keystore ksnormal -genkeypair -storepass changeit -alias b -dname CN=b \"\n+                + \"-J-Dkeystore.pkcs12.certProtectionAlgorithm=NONE \"\n+                + \"-J-Dkeystore.pkcs12.macAlgorithm=NONE\");\n+        data = Files.readAllBytes(Paths.get(\"ksnormal\"));\n+        checkInt(data, \"22\", 100000); \/\/ Mac ic\n+        checkAlg(data, \"2000\", SHA_oid); \/\/ Mac alg\n+        checkAlg(data, \"110c010c01000\", pbeWithSHA1AndDESede_oid); \/\/ key alg\n+        checkInt(data, \"110c010c010011\", 50000); \/\/ key ic\n+        checkAlg(data, \"110c010c11000\", pbeWithSHA1AndDESede_oid); \/\/ new key alg\n+        checkInt(data, \"110c010c110011\", 50000); \/\/ new key ic\n+        checkAlg(data, \"110c10\", ENCRYPTED_DATA_OID);\n+        checkAlg(data, \"110c110110\", pbeWithSHA1AndRC2_40_oid); \/\/ cert alg\n+        checkInt(data, \"110c1101111\", 50000); \/\/ cert ic\n+        check(\"ksnormal\", \"b\", null, \"changeit\", true, false, true);\n+        check(\"ksnormal\", \"b\", \"changeit\", \"changeit\", true, true, true);\n+\n+        \/\/ Different keypbe alg, no cert pbe and no mac\n+        keytool(\"-importkeystore -srckeystore ks -srcstorepass changeit \"\n+                + \"-deststoretype PKCS12 -destkeystore ksnopass -deststorepass changeit \"\n+                + \"-J-Dkeystore.pkcs12.keyProtectionAlgorithm=PBEWithSHA1AndRC4_128 \"\n+                + \"-J-Dkeystore.pkcs12.certProtectionAlgorithm=NONE \"\n+                + \"-J-Dkeystore.pkcs12.macAlgorithm=NONE\");\n+        data = Files.readAllBytes(Paths.get(\"ksnopass\"));\n+        shouldNotExist(data, \"2\"); \/\/ no Mac\n+        checkAlg(data, \"110c010c01000\", pbeWithSHA1AndRC4_128_oid);\n+        checkInt(data, \"110c010c010011\", 50000);\n+        checkAlg(data, \"110c10\", DATA_OID);\n+        check(\"ksnopass\", \"a\", null, \"changeit\", true, true, true);\n+        check(\"ksnopass\", \"a\", \"changeit\", \"changeit\", true, true, true);\n+        check(\"ksnopass\", \"a\", \"wrongpass\", \"changeit\", true, true, true);\n+\n+        \/\/ Add a new entry with normal settings, still password-less\n+        keytool(\"-keystore ksnopass -genkeypair -storepass changeit -alias b -dname CN=B\");\n+        data = Files.readAllBytes(Paths.get(\"ksnopass\"));\n+        shouldNotExist(data, \"2\"); \/\/ no Mac\n+        checkAlg(data, \"110c010c01000\", pbeWithSHA1AndRC4_128_oid);\n+        checkInt(data, \"110c010c010011\", 50000);\n+        checkAlg(data, \"110c010c11000\", pbeWithSHA1AndDESede_oid);\n+        checkInt(data, \"110c010c110011\", 50000);\n+        checkAlg(data, \"110c10\", DATA_OID);\n+        check(\"ksnopass\", \"a\", null, \"changeit\", true, true, true);\n+        check(\"ksnopass\", \"b\", null, \"changeit\", true, true, true);\n+\n+        keytool(\"-importkeystore -srckeystore ks -srcstorepass changeit \"\n+                + \"-deststoretype PKCS12 -destkeystore ksnewic -deststorepass changeit \"\n+                + \"-J-Dkeystore.pkcs12.macIterationCount=5555 \"\n+                + \"-J-Dkeystore.pkcs12.certPbeIterationCount=6666 \"\n+                + \"-J-Dkeystore.pkcs12.keyPbeIterationCount=7777\");\n+        data = Files.readAllBytes(Paths.get(\"ksnewic\"));\n+        checkInt(data, \"22\", 5555); \/\/ Mac ic\n+        checkAlg(data, \"2000\", SHA_oid); \/\/ Mac alg\n+        checkAlg(data, \"110c010c01000\", pbeWithSHA1AndDESede_oid); \/\/ key alg\n+        checkInt(data, \"110c010c010011\", 7777); \/\/ key ic\n+        checkAlg(data, \"110c110110\", pbeWithSHA1AndRC2_40_oid); \/\/ cert alg\n+        checkInt(data, \"110c1101111\", 6666); \/\/ cert ic\n+\n+        \/\/ keypbe alg cannot be NONE\n+        keytool(\"-keystore ksnewic -genkeypair -storepass changeit -alias b -dname CN=B \"\n+                + \"-J-Dkeystore.pkcs12.keyProtectionAlgorithm=NONE\")\n+                .shouldContain(\"NONE AlgorithmParameters not available\")\n+                .shouldHaveExitValue(1);\n+\n+        \/\/ new entry new keypbe alg (and default ic), else unchanged\n+        keytool(\"-keystore ksnewic -genkeypair -storepass changeit -alias b -dname CN=B \"\n+                + \"-J-Dkeystore.pkcs12.keyProtectionAlgorithm=PBEWithSHA1AndRC4_128\");\n+        data = Files.readAllBytes(Paths.get(\"ksnewic\"));\n+        checkInt(data, \"22\", 5555); \/\/ Mac ic\n+        checkAlg(data, \"2000\", SHA_oid); \/\/ Mac alg\n+        checkAlg(data, \"110c010c01000\", pbeWithSHA1AndDESede_oid); \/\/ key alg\n+        checkInt(data, \"110c010c010011\", 7777); \/\/ key ic\n+        checkAlg(data, \"110c010c11000\", pbeWithSHA1AndRC4_128_oid); \/\/ new key alg\n+        checkInt(data, \"110c010c110011\", 50000); \/\/ new key ic\n+        checkAlg(data, \"110c110110\", pbeWithSHA1AndRC2_40_oid); \/\/ cert alg\n+        checkInt(data, \"110c1101111\", 6666); \/\/ cert ic\n+\n+        \/\/ Check KeyStore loading multiple keystores\n+        KeyStore ks = KeyStore.getInstance(\"pkcs12\");\n+        try (FileInputStream fis = new FileInputStream(\"ksnormal\");\n+                FileOutputStream fos = new FileOutputStream(\"ksnormaldup\")) {\n+            ks.load(fis, \"changeit\".toCharArray());\n+            ks.store(fos, \"changeit\".toCharArray());\n+        }\n+        data = Files.readAllBytes(Paths.get(\"ksnormaldup\"));\n+        checkInt(data, \"22\", 100000); \/\/ Mac ic\n+        checkAlg(data, \"2000\", SHA_oid); \/\/ Mac alg\n+        checkAlg(data, \"110c010c01000\", pbeWithSHA1AndDESede_oid); \/\/ key alg\n+        checkInt(data, \"110c010c010011\", 50000); \/\/ key ic\n+        checkAlg(data, \"110c010c11000\", pbeWithSHA1AndDESede_oid); \/\/ new key alg\n+        checkInt(data, \"110c010c110011\", 50000); \/\/ new key ic\n+        checkAlg(data, \"110c10\", ENCRYPTED_DATA_OID);\n+        checkAlg(data, \"110c110110\", pbeWithSHA1AndRC2_40_oid); \/\/ cert alg\n+        checkInt(data, \"110c1101111\", 50000); \/\/ cert ic\n+\n+        try (FileInputStream fis = new FileInputStream(\"ksnopass\");\n+             FileOutputStream fos = new FileOutputStream(\"ksnopassdup\")) {\n+            ks.load(fis, \"changeit\".toCharArray());\n+            ks.store(fos, \"changeit\".toCharArray());\n+        }\n+        data = Files.readAllBytes(Paths.get(\"ksnopassdup\"));\n+        shouldNotExist(data, \"2\"); \/\/ no Mac\n+        checkAlg(data, \"110c010c01000\", pbeWithSHA1AndRC4_128_oid);\n+        checkInt(data, \"110c010c010011\", 50000);\n+        checkAlg(data, \"110c010c11000\", pbeWithSHA1AndDESede_oid);\n+        checkInt(data, \"110c010c110011\", 50000);\n+        checkAlg(data, \"110c10\", DATA_OID);\n+\n+        try (FileInputStream fis = new FileInputStream(\"ksnewic\");\n+             FileOutputStream fos = new FileOutputStream(\"ksnewicdup\")) {\n+            ks.load(fis, \"changeit\".toCharArray());\n+            ks.store(fos, \"changeit\".toCharArray());\n+        }\n+        data = Files.readAllBytes(Paths.get(\"ksnewicdup\"));\n+        checkInt(data, \"22\", 5555); \/\/ Mac ic\n+        checkAlg(data, \"2000\", SHA_oid); \/\/ Mac alg\n+        checkAlg(data, \"110c010c01000\", pbeWithSHA1AndDESede_oid); \/\/ key alg\n+        checkInt(data, \"110c010c010011\", 7777); \/\/ key ic\n+        checkAlg(data, \"110c010c11000\", pbeWithSHA1AndRC4_128_oid); \/\/ new key alg\n+        checkInt(data, \"110c010c110011\", 50000); \/\/ new key ic\n+        checkAlg(data, \"110c110110\", pbeWithSHA1AndRC2_40_oid); \/\/ cert alg\n+        checkInt(data, \"110c1101111\", 6666); \/\/ cert ic\n+\n+        \/\/ Check keytool behavior\n+\n+        \/\/ ksnormal has password\n+\n+        keytool(\"-list -keystore ksnormal\")\n+                .shouldContain(\"WARNING WARNING WARNING\")\n+                .shouldContain(\"Certificate chain length: 0\");\n+\n+        SecurityTools.setResponse(\"changeit\");\n+        keytool(\"-list -keystore ksnormal\")\n+                .shouldNotContain(\"WARNING WARNING WARNING\")\n+                .shouldContain(\"Certificate fingerprint\");\n+\n+        \/\/ ksnopass is password-less\n+\n+        keytool(\"-list -storetype PKCS12 -keystore ksnopass\")\n+                .shouldNotContain(\"WARNING WARNING WARNING\")\n+                .shouldContain(\"Certificate fingerprint\");\n+\n+        \/\/ -certreq prompts for keypass\n+        SecurityTools.setResponse(\"changeit\");\n+        keytool(\"-certreq -alias a -storetype PKCS12 -keystore ksnopass\")\n+                .shouldContain(\"Enter key password for <a>\")\n+                .shouldContain(\"-----BEGIN NEW CERTIFICATE REQUEST-----\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ -certreq -storepass works fine\n+        keytool(\"-certreq -alias a -keystore ksnopass -storepass changeit\")\n+                .shouldNotContain(\"Enter key password for <a>\")\n+                .shouldContain(\"-----BEGIN NEW CERTIFICATE REQUEST-----\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ -certreq -keypass also works fine\n+        keytool(\"-certreq -alias a -storetype PKCS12 -keystore ksnopass -keypass changeit\")\n+                .shouldNotContain(\"Enter key password for <a>\")\n+                .shouldContain(\"-----BEGIN NEW CERTIFICATE REQUEST-----\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ -importkeystore prompts for srckeypass\n+        SecurityTools.setResponse(\"changeit\", \"changeit\");\n+        keytool(\"-importkeystore -srcstoretype PKCS12 -srckeystore ksnopass \"\n+                + \"-destkeystore jks3 -deststoretype PKCS12 -deststorepass changeit\")\n+                .shouldContain(\"Enter key password for <a>\")\n+                .shouldContain(\"Enter key password for <b>\")\n+                .shouldContain(\"2 entries successfully imported\");\n+\n+        \/\/ ksnopass2 is ksnopass + 2 cert entries\n+        ks = KeyStore.getInstance(\"pkcs12\");\n+        try (FileInputStream fis = new FileInputStream(\"ksnopass\")) {\n+            ks.load(fis, (char[])null);\n+        }\n+        ks.setCertificateEntry(\"aa\", ks.getCertificate(\"a\"));\n+        ks.setCertificateEntry(\"bb\", ks.getCertificate(\"b\"));\n+        try (FileOutputStream fos = new FileOutputStream(\"ksnopass2\")) {\n+            ks.store(fos, null);\n+        }\n+\n+        \/\/ -importkeystore prompts for srckeypass for private keys\n+        \/\/ and no prompt for certs\n+        SecurityTools.setResponse(\"changeit\", \"changeit\");\n+        keytool(\"-importkeystore -srcstoretype PKCS12 -srckeystore ksnopass2 \"\n+                + \"-destkeystore jks5 -deststorepass changeit\")\n+                .shouldContain(\"Enter key password for <a>\")\n+                .shouldContain(\"Enter key password for <b>\")\n+                .shouldNotContain(\"Enter key password for <aa>\")\n+                .shouldNotContain(\"Enter key password for <bb>\")\n+                .shouldContain(\"4 entries successfully imported\");\n+\n+        \/\/ ksonlycert has only cert entries\n+\n+        ks.deleteEntry(\"a\");\n+        ks.deleteEntry(\"b\");\n+        try (FileOutputStream fos = new FileOutputStream(\"ksonlycert\")) {\n+            ks.store(fos, null);\n+        }\n+\n+        \/\/ -importkeystore does not prompt at all\n+        keytool(\"-importkeystore -srckeystore ksonlycert \"\n+                + \"-destkeystore jks6 -deststorepass changeit\")\n+                .shouldNotContain(\"Enter key password for <aa>\")\n+                .shouldNotContain(\"Enter key password for <bb>\")\n+                .shouldContain(\"2 entries successfully imported\");\n+\n+        \/\/ create a new password-less keystore\n+        keytool(\"-keystore ksnopass -exportcert -alias a -file a.cert -rfc\");\n+\n+        \/\/ Normally storepass is prompted for\n+        keytool(\"-keystore kscert1 -storetype PKCS12 -importcert -alias a -file a.cert -noprompt\")\n+                .shouldContain(\"Enter keystore password:\");\n+        keytool(\"-keystore kscert2 -storetype PKCS12 -importcert -alias a -file a.cert -noprompt \"\n+                + \"-J-Dkeystore.pkcs12.certProtectionAlgorithm=NONE\")\n+                .shouldContain(\"Enter keystore password:\");\n+        keytool(\"-keystore kscert3 -storetype PKCS12 -importcert -alias a -file a.cert -noprompt \"\n+                + \"-J-Dkeystore.pkcs12.macAlgorithm=NONE\")\n+                .shouldContain(\"Enter keystore password:\");\n+        \/\/ ... but not if it's password-less\n+        keytool(\"-keystore kscert4 -storetype PKCS12 -importcert -alias a -file a.cert -noprompt \"\n+                + \"-J-Dkeystore.pkcs12.certProtectionAlgorithm=NONE \"\n+                + \"-J-Dkeystore.pkcs12.macAlgorithm=NONE\")\n+                .shouldNotContain(\"Enter keystore password:\");\n+\n+        \/\/ still prompt for keypass for genkeypair and certreq\n+        SecurityTools.setResponse(\"changeit\", \"changeit\");\n+        keytool(\"-keystore ksnopassnew -storetype PKCS12 -genkeypair -alias a -dname CN=A \"\n+                + \"-J-Dkeystore.pkcs12.certProtectionAlgorithm=NONE \"\n+                + \"-J-Dkeystore.pkcs12.macAlgorithm=NONE\")\n+                .shouldNotContain(\"Enter keystore password:\")\n+                .shouldContain(\"Enter key password for <a>\");\n+        keytool(\"-keystore ksnopassnew -storetype PKCS12 -certreq -alias a\")\n+                .shouldNotContain(\"Enter keystore password:\")\n+                .shouldContain(\"Enter key password for <a>\");\n+        keytool(\"-keystore ksnopassnew -storetype PKCS12 -list -v -alias a\")\n+                .shouldNotContain(\"Enter keystore password:\")\n+                .shouldNotContain(\"Enter key password for <a>\");\n+\n+        \/\/ params only read on demand\n+\n+        \/\/ keyPbeIterationCount is used by -genkeypair\n+        keytool(\"-keystore ksgenbadkeyic -storetype PKCS12 -genkeypair -alias a -dname CN=A \"\n+                + \"-storepass changeit \"\n+                + \"-J-Dkeystore.pkcs12.keyPbeIterationCount=abc\")\n+                .shouldContain(\"keyPbeIterationCount is not a number: abc\")\n+                .shouldHaveExitValue(1);\n+\n+        keytool(\"-keystore ksnopassnew -exportcert -alias a -file a.cert\");\n+\n+        \/\/ but not used by -importcert\n+        keytool(\"-keystore ksimpbadkeyic -importcert -alias a -file a.cert \"\n+                + \"-noprompt -storepass changeit \"\n+                + \"-J-Dkeystore.pkcs12.keyPbeIterationCount=abc\")\n+                .shouldHaveExitValue(0);\n+\n+        \/\/ None is used by -list\n+        keytool(\"-keystore ksnormal -storepass changeit -list \"\n+                + \"-J-Dkeystore.pkcs12.keyPbeIterationCount=abc \"\n+                + \"-J-Dkeystore.pkcs12.certPbeIterationCount=abc \"\n+                + \"-J-Dkeystore.pkcs12.macIterationCount=abc\")\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    \/**\n+     * Check keystore loading and key\/cert reading.\n+     *\n+     * @param keystore the file name of keystore\n+     * @param alias the key\/cert to read\n+     * @param storePass store pass to try out, can be null\n+     * @param keypass key pass to try, can not be null\n+     * @param expectedLoad expected result of keystore loading, true if non\n+     *                     null, false if null, exception class if exception\n+     * @param expectedCert expected result of cert reading\n+     * @param expectedKey expected result of key reading\n+     *\/\n+    private static void check(\n+            String keystore,\n+            String alias,\n+            String storePass,\n+            String keypass,\n+            Object expectedLoad,\n+            Object expectedCert,\n+            Object expectedKey) {\n+        KeyStore ks = null;\n+        Object actualLoad, actualCert, actualKey;\n+        String label = keystore + \"-\" + alias + \"-\" + storePass + \"-\" + keypass;\n+        try {\n+            ks = KeyStore.getInstance(\"pkcs12\");\n+            try (FileInputStream fis = new FileInputStream(keystore)) {\n+                ks.load(fis, storePass == null ? null : storePass.toCharArray());\n+            }\n+            actualLoad = ks != null;\n+        } catch (Exception e) {\n+            e.printStackTrace(System.out);\n+            actualLoad = e.getClass();\n+        }\n+        Asserts.assertEQ(expectedLoad, actualLoad, label + \"-load\");\n+\n+        \/\/ If not loaded correctly, skip cert\/key reading\n+        if (!Objects.equals(actualLoad, true)) {\n+            return;\n+        }\n+\n+        try {\n+            actualCert = (ks.getCertificate(alias) != null);\n+        } catch (Exception e) {\n+            e.printStackTrace(System.out);\n+            actualCert = e.getClass();\n+        }\n+        Asserts.assertEQ(expectedCert, actualCert, label + \"-cert\");\n+\n+        try {\n+            actualKey = (ks.getKey(alias, keypass.toCharArray()) != null);\n+        } catch (Exception e) {\n+            e.printStackTrace(System.out);\n+            actualKey = e.getClass();\n+        }\n+        Asserts.assertEQ(expectedKey, actualKey, label + \"-key\");\n+    }\n+\n+    static OutputAnalyzer keytool(String s) throws Throwable {\n+        return SecurityTools.keytool(s);\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/pkcs12\/ParamsTest.java","additions":442,"deletions":0,"binary":false,"changes":442,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+1. Preparing data in this directory\n+\n+mkdir tmp\n+cd tmp\n+keytool -keystore ks -genkeypair -storepass changeit -alias a -dname CN=A\n+openssl pkcs12 -in ks -nodes -out kandc -passin pass:changeit\n+openssl pkcs12 -export -in kandc -out os2 -name a -passout pass:changeit \\\n+        -certpbe NONE -nomac\n+openssl pkcs12 -export -in kandc -out os3 -name a -passout pass:changeit \\\n+        -certpbe NONE\n+openssl pkcs12 -export -in kandc -out os4 -name a -passout pass:changeit \\\n+        -certpbe PBE-SHA1-RC4-128 -keypbe PBE-SHA1-RC4-128 -macalg SHA224\n+openssl pkcs12 -export -in kandc -out os5 -name a -passout pass:changeit \\\n+        -certpbe AES-256-CBC -keypbe AES-256-CBC -macalg SHA512\n+for a in *; do\n+    openssl base64 -in $a -out ..\/$a\n+done\n+cd ..\n+rm -rf tmp\n+\n+2. After running the test, we can go to the scratch directory and run the\n+following commands to check keytool -> openssl interoperability.\n+OpenSSL 1.1.0i is used here. Earlier versions might generate different info.\n+\n+(\n+openssl pkcs12 -in ks2 -passin pass:changeit -info -nokeys -nocerts 2> t2 || exit 20\n+grep \"MAC:sha1 Iteration 100000\" t2 || exit 21\n+grep \"Shrouded Keybag: pbeWithSHA1And3-KeyTripleDES-CBC, Iteration 50000\" t2 || exit 23\n+grep \"PKCS7 Encrypted data: pbeWithSHA1And40BitRC2-CBC, Iteration 50000\" t2 || exit 24\n+\n+openssl pkcs12 -in ks22 -passin pass:changeit -info -nokeys -nocerts 2> t22 || exit 25\n+diff t2 t22 || exit 26\n+\n+openssl pkcs12 -in ks3 -passin pass:changeit -info -nokeys -nocerts && exit 30\n+\n+openssl pkcs12 -in ks3 -passin pass:changeit -info -nokeys -nocerts -nomacver 2> t3 || exit 31\n+grep \"PKCS7 Encrypted data:\" t3 && exit 33\n+grep \"Shrouded Keybag: pbeWithSHA1And3-KeyTripleDES-CBC, Iteration 50000\" t3 || exit 34\n+grep \"Shrouded Keybag: pbeWithSHA1And128BitRC4, Iteration 50000\" t3 || exit 35\n+\n+openssl pkcs12 -in ks33 -passin pass:changeit -info -nokeys -nocerts -nomacver 2> t33 || exit 36\n+diff t3 t33 || exit 37\n+\n+openssl pkcs12 -in ks4 -passin pass:changeit -info -nokeys -nocerts 2> t4 || exit 40\n+grep \"MAC:sha1 Iteration 5555\" t4 || exit 41\n+grep \"Shrouded Keybag: pbeWithSHA1And3-KeyTripleDES-CBC, Iteration 7777\" t4 || exit 43\n+grep \"Shrouded Keybag: pbeWithSHA1And128BitRC4, Iteration 50000\" t4 || exit 44\n+grep \"PKCS7 Encrypted data: pbeWithSHA1And40BitRC2-CBC, Iteration 6666\" t4 || exit 45\n+\n+openssl pkcs12 -in ks44 -passin pass:changeit -info -nokeys -nocerts 2> t44 || exit 46\n+diff t4 t44 || exit 47\n+\n+echo Succeed\n+)\n","filename":"jdk\/test\/sun\/security\/pkcs12\/params\/README","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+QmFnIEF0dHJpYnV0ZXMKICAgIGZyaWVuZGx5TmFtZTogYQogICAgbG9jYWxLZXlJ\n+RDogNTQgNjkgNkQgNjUgMjAgMzEgMzUgMzMgMzggMzEgMzMgMzQgMzAgMzUgMzkg\n+MzQgMzMgMzUgCktleSBBdHRyaWJ1dGVzOiA8Tm8gQXR0cmlidXRlcz4KLS0tLS1C\n+RUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUNYUUlCQURDQ0FqVUdCeXFHU000NEJB\n+RXdnZ0lvQW9JQkFRQ1BlVFhadWFycHY2dnRpSHJQU1ZHMjh5N0YKbmp1dk54am82\n+c1NXSHo3OU5nYm5RMUdweEJnek9iZ0o1OEt1SEZPYnAwZGJoZEFScmJpMGVZZDFT\n+WVJwWEt3TwpqeFN6Tmdnb29pLzZKeEVLUFdLcGswVTBDYUQrYVd4R1dQaEwzU0NC\n+bkRjSm9CQlhzWld0elFBalBicFVoTFlwCkg1MWtqdmlEUklaM2w1enNCTFEwcHF3\n+dWRlbVlYZUk5c0NrdndSR01uL3FkZ1lIbk00MjNrcmN3MTdualNWa3YKYUFtWWNo\n+VTVGZW85YTR0R1U4WXpSWStBT3pLa3d1RHljcEFsYms0L2lqc0lPS0hFVU9UaGpC\n+b3BvMzNmWHFGRAoza3RtL3dTUVB0WFBGaVBoV05TSHhnanBmeUVjMkIzS0k4dHVP\n+QWRsK0NMalFyNUlUQVYyT1RsZ0hOWm5BaDBBCnV2YVdwb1Y0OTkvZTUvcG55WGZI\n+aGU4eXNqTzY1WURBdk5WcFhRS0NBUUFXcGx4WUlFaFFjRTUxQXFPWFZ3UU4KTk5v\n+Nk5IakJWTlRrcGNBdEpDN2dUNWJtSGt2UWtFcTlySTgzN3JIZ256R0MwanlRUTh0\n+a0w0Z0FRV0R0K2NvSgpzeUIycDV3eXBpZnlSejZSaDV1aXhPZEV2U0NCVkV5MVc0\n+QXNObzBmcUQ3VWllbE9ENkJvampKQ2lseDR4SGpHCmpRVW50eHlhT3JzTEMrRXNS\n+R2lXT2VmVHpuVGJFQnBscWl1SDlreG9KdHMreHk5TFZabURTN1R0c0M5OGtPbWsK\n+bHRPbFhWTmI2L3hGMVBZWjlqODk3YnVIT1NYQzhpVGdkekVwYmFpSDdCNUhTUGgr\n+KzEvZXQxU0VNV3NpTXQ3bApVOTJ2QWhFckRSOEMyakNYTWlUK0o2N2FpNTFMS1NM\n+WnVvdmpudG5oQTZZOFVvRUx4b2kzNHUxREZ1SHZGOXZlCkJCOENIUUMzU0hOSm5u\n+cjF0TG00aDdKR1RETU02cUJQc2N3cmdMcGZHOW9tCi0tLS0tRU5EIFBSSVZBVEUg\n+S0VZLS0tLS0KQmFnIEF0dHJpYnV0ZXMKICAgIGZyaWVuZGx5TmFtZTogYQogICAg\n+bG9jYWxLZXlJRDogNTQgNjkgNkQgNjUgMjAgMzEgMzUgMzMgMzggMzEgMzMgMzQg\n+MzAgMzUgMzkgMzQgMzMgMzUgCnN1YmplY3Q9L0NOPUEKaXNzdWVyPS9DTj1BCi0t\n+LS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQpNSUlFRXpDQ0E3K2dBd0lCQWdJRWJ1\n+OFlOREFOQmdsZ2hrZ0JaUU1FQXdJRkFEQU1NUW93Q0FZRFZRUURFd0ZCCk1CNFhE\n+VEU0TURreU9ERXhNamN6T1ZvWERURTRNVEl5TnpFeE1qY3pPVm93RERFS01BZ0dB\n+MVVFQXhNQlFUQ0MKQTBJd2dnSTFCZ2NxaGtqT09BUUJNSUlDS0FLQ0FRRUFqM2sx\n+MmJtcTZiK3I3WWg2ejBsUnR2TXV4WjQ3cnpjWQo2T3JFbGg4Ky9UWUc1ME5ScWNR\n+WU16bTRDZWZDcmh4VG02ZEhXNFhRRWEyNHRIbUhkVW1FYVZ5c0RvOFVzellJCktL\n+SXYraWNSQ2oxaXFaTkZOQW1nL21sc1JsajRTOTBnZ1p3M0NhQVFWN0dWcmMwQUl6\n+MjZWSVMyS1IrZFpJNzQKZzBTR2Q1ZWM3QVMwTkthc0xuWHBtRjNpUGJBcEw4RVJq\n+Si82bllHQjV6T050NUszTU5lNTQwbFpMMmdKbUhJVgpPUlhxUFd1TFJsUEdNMFdQ\n+Z0RzeXBNTGc4bktRSlc1T1A0bzdDRGloeEZEazRZd2FLYU45MzE2aFE5NUxadjhF\n+CmtEN1Z6eFlqNFZqVWg4WUk2WDhoSE5nZHlpUExiamdIWmZnaTQwSytTRXdGZGpr\n+NVlCeldad0lkQUxyMmxxYUYKZVBmZjN1ZjZaOGwzeDRYdk1ySXp1dVdBd0x6VmFW\n+MENnZ0VBRnFaY1dDQklVSEJPZFFLamwxY0VEVFRhT2pSNAp3VlRVNUtYQUxTUXU0\n+RStXNWg1TDBKQkt2YXlQTis2eDRKOHhndEk4a0VQTFpDK0lBRUZnN2ZuS0NiTWdk\n+cWVjCk1xWW44a2Mra1llYm9zVG5STDBnZ1ZSTXRWdUFMRGFOSDZnKzFJbnBUZytn\n+YUk0eVFvcGNlTVI0eG8wRko3Y2MKbWpxN0N3dmhMRVJvbGpubjA4NTAyeEFhWmFv\n+cmgvWk1hQ2JiUHNjdlMxV1pnMHUwN2JBdmZKRHBwSmJUcFYxVApXK3Y4UmRUMkdm\n+WS9QZTI3aHprbHd2SWs0SGN4S1cyb2grd2VSMGo0ZnZ0ZjNyZFVoREZySWpMZTVW\n+UGRyd0lSCkt3MGZBdG93bHpJay9pZXUyb3VkU3lraTJicUw0NTdaNFFPbVBGS0JD\n+OGFJdCtMdFF4Ymg3eGZiM2dPQ0FRVUEKQW9JQkFEK0syd1RoV3VyRGpZTUNYeGZy\n+dXJOK0drZFNFeXk5cCtkdkhJUDFrTWhybTcrRXV6LzExUVlGcGI4Vgpic0NhWWUx\n+ME9qWkF1WjRXSmdTbkl5R0swb2JzbjlKWkZubUdDbGlxRkVoWGJwbnhyOGxhS3Iw\n+dDRERytPMTF2CjVQRGh4aHd2b1VZb2ZwWTFEYjN0SHlxdytWM3RRWVA3K3RaNDRB\n+eW1SdTNtbktZTVZzRHd2M0x1UEdaLzJmQ0MKY2lYVEJIU3VFbzdCUDdBbjdFYkZO\n+K0JaQldlTlgvcjNOZm1nL0tmQjQ1OFNZMmhFYlplRW5kZUh4d204VFRORwpQaXdi\n+Nkx5ZE5RS0VFS003cmVFTjkwTXVsUVJMZkhVVFBWZXB5dU9QK1ZySEI3WS9lVWhI\n+K2RNeHp6d3pLOHJ6CjRYaEwxRFBhT1ZMdmxCSUR5VE5QZU4wV2V4bWpJVEFmTUIw\n+R0ExVWREZ1FXQkJUQThWK01SSXRNU3Yyb283YjgKYzVlQ0tybzdxREFOQmdsZ2hr\n+Z0JaUU1FQXdJRkFBTS9BREE4QWh3a0dVK2VVR0kvTFFVejMzTUk3cC9BVXd1WAo0\n+SnZOVGUrUGhQZFZBaHdvUzdNMFIzbjRnSkkxU2FRdnoyTWhuR3Z1T3Q5UzZMdkRR\n+NWRFCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0K\n","filename":"jdk\/test\/sun\/security\/pkcs12\/params\/kandc","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+MIIIQQIBAzCCB\/oGCSqGSIb3DQEHAaCCB+sEggfnMIIH4zCCAv8GCSqGSIb3DQEH\n+AaCCAvAEggLsMIIC6DCCAuQGCyqGSIb3DQEMCgECoIICmzCCApcwKQYKKoZIhvcN\n+AQwBAzAbBBSZfQZ+F5Za9YLcGbyXsafOUX50XwIDAMNQBIICaBh7FmOBnDoFngWz\n+pnK5+SzD16E8TNFxZneou1n2Nxq8MXMgfLjlVb9PSlARDU+Pj9FhRdjWqTEncKwn\n+5owDYujiOSGmAHih64nFHoICs34o5LAKv9l8UhfE1qUgA4iA1VdakD31N8ZGR29O\n+2tglXKrHE9n6f5k47mzqcPiNIgHH1KSWu143AInYTOjpEJD2YpBTzL0YxvnLbaY1\n+v+PRokbHak8siO\/MCNwwQBD5lJX7kVld4iMjeJvBX9pUwqfD4EDuvJo9QkHmy+GB\n+UBAMRBsMHwV9E832dHxh+JYveg0TI8FACnLHpmbYpCs+K69A6yOAUqfUIseLUJR4\n+XSd2HZODXyLHAimJK9AQGRpGWORiRu2E\/XimLo2qhPKEOl2hbi+R95hb2h2wGgr1\n+RhCsAFHac7cW4r\/s1HacU0JCzWJKyV76LbNHDexlGj09B47VAAAfE7zlHmUIShEN\n+zwQ6EUDxrK+h7wY2GS2fqcseqDvPXtxvbGjkAyfYE+6aT2g6vtd6PTrBSRt6Lzp6\n+rUC0IrHXXpBb8qanvuAd+OPC4skp\/hI\/q7qCsKOUzRc5Xmm1FMUfJr6UeadSvpfw\n+V9C28zEMPcW+KdS2W7f0uvebIgUU7xj8dg27XC+C7oPhLz\/pIFQ4n449GQNUo57K\n+WPmGeT\/coO3jVk+E7uzXeFkwp2rGXQNWin44UUGGG0\/S04YMRJknpRzw8sILD4d1\n+N\/iEazUOl35pua9+0OTFqNJzSemqO3kevgVXrsSzQCLeoB1dn4mpvqkPV87B5JOC\n+t3fpDVSBrcFF43qeveQ65lpbcbOoucO\/h16s8w8xNjARBgkqhkiG9w0BCRQxBB4C\n+AGEwIQYJKoZIhvcNAQkVMRQEElRpbWUgMTUzODEzNDA1OTQzNTCCBNwGCSqGSIb3\n+DQEHBqCCBM0wggTJAgEAMIIEwgYJKoZIhvcNAQcBMCkGCiqGSIb3DQEMAQYwGwQU\n+tPIqPBD1WiaRd01W1t6\/znB2PmkCAwDDUICCBIhvxfWroewV\/5cO8r24YQkMVjvs\n+2kgkLusWbreMScR\/LE5lcLXHYAS3KMJJWfwBBKa3nvyuMiYPnuzTReSd7SxtCZtG\n++EIyyf6mTUdqBTPkDduqDHqugzokHKFycsTi2YBam1ohyTOUoUOFnJeOyJ4FOVQ5\n+TQOPUXgBW8s2jMm181+w0E3NXiEC+c+cPZUm2aQPLUxEYqTuJsMY6Uz+jv94hOIH\n+eeZHwVBy8D\/3pUB56L89JBRARpIsCP+BQIaTFyopXQ8i50gdT3a6KL8O9Zzjjij8\n+VLjCpLdC9wR5yY4Js\/cZyER\/uxl8zBroheiye5U77rw4WQrSQhn\/cBoTDR0llwlU\n+K3IL4J22UjtTmIQlFAV8XWz7GZAVJkuJLEtuO6JjHSgO8NTnfN2T4oWaNAwdAK3S\n+UrJVpk4yx0+B2UokxyY0Y3FErLzM7BMq\/X9Rvhs9Zwwr+ZftqXEaiYHHSEPGNGZI\n+Gh3P8F8EThCcyVe7yFK+0DCj3Y8jrZZLXh8e1M1wPWVay52JL1QApTfs0ucwlMLz\n+19KUSm13ztuCBo47OrMU1ur6a1eQZkOvRmdMxKNLLrET3sBh7ZE6SbjijCtDfYdf\n+k4+Q9VrO+04atyXg8Gy4vRZB\/koe8oXCDgPYTTqLHNywTuhJq30Ev71D0GdiwPy7\n+9urLh2ocm7neRIGsaYRXxa0U6IpT47wOYbUOz3y6Yf5yjoI3E0gWYZtuQVGRkatF\n+p97mJExQ9aBy1l4hqmgU4bcqBepq2fdxhVueiZD84QZqfZ5H9pRzVPjHoqzIH8wm\n+kmM78mlMqu8IPqny0I3zF6z+wapd0vpjpeaLItlUAJ2Eiz7d4BHKBeAPsZtPUQzr\n+hPtM\/ao5QjLHddLqh2lauJk0Og+4Uj1UftelM6ERZPN0JXEyh+DU9hs2czTnJKlZ\n+BEB07\/1WFPCrdj\/eNe7K02Xs2kpJKiXjAWNxFNWtqDQY3U5\/lAY8oY\/dc6LG+iuO\n+yDLXD4TSJZSNrOOHKmp4TXpuMRM2tbw9m0vrweegSB6GIzUIA1MOvgsjbSgWwmhy\n+LoG6QriLhTXZQd+Uh6uqlCBrgXQ2K+RuIsZCZaZE64pUtK3Tl6ZwBe3POfxMCkjm\n+YQ\/ZJ7k0IOk9lQfA6InlfSDkS7B5WHev7Fqh96GI9sUSox13El9VvbNfFDZy5lem\n+Ml8GTDLrlop5TRDeplHknettKqMQmpj2nopGvTn4EFSNFz8AZmEtOaptzkP5l3ar\n+DRgPqhxclb\/4QX7c67s1l\/pcR16BbiH05rxVUTclg8rB0FCo14Hi5CQF0turk5QK\n+ptM9kvz\/VtDUpHArRz7NaFZdJuVC1IRq8dgmSi7MN7LaQ0mVIfeQ1ssHjLhIQMbA\n+aE8Xwij9Q5OAoNcA8Ucctqgl12\/9uKfZ5lKeZnVR4DyVhjnTJ9Ounv1unagBj\/Jq\n+6o4ibStuqfHhKhBtQkr4RXsrocJhgMhfhbUqgQRx0pWuODrpqQMuG6yTnw7ePPMt\n+w29mceyPdU8EoYUUPCDZdpv3giurH5E22tnRDyU0Mm1Spbe\/rDA+MCEwCQYFKw4D\n+AhoFAAQUtavY6pX+J6lZHeGkx3Rlt6Hc8iEEFOUlujwYOLAzDd2fQcGdyL8MrGvo\n+AgMBhqA=\n","filename":"jdk\/test\/sun\/security\/pkcs12\/params\/ks","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+MIIHrwIBAzCCB6gGCSqGSIb3DQEHAaCCB5kEggeVMIIHkTCCBJUGCSqGSIb3DQEH\n+AaCCBIYEggSCMIIEfjCCBHoGCyqGSIb3DQEMCgEDoIIELzCCBCsGCiqGSIb3DQEJ\n+FgGgggQbBIIEFzCCBBMwggO\/oAMCAQICBG7vGDQwDQYJYIZIAWUDBAMCBQAwDDEK\n+MAgGA1UEAxMBQTAeFw0xODA5MjgxMTI3MzlaFw0xODEyMjcxMTI3MzlaMAwxCjAI\n+BgNVBAMTAUEwggNCMIICNQYHKoZIzjgEATCCAigCggEBAI95Ndm5qum\/q+2Ies9J\n+UbbzLsWeO683GOjqxJYfPv02BudDUanEGDM5uAnnwq4cU5unR1uF0BGtuLR5h3VJ\n+hGlcrA6PFLM2CCiiL\/onEQo9YqmTRTQJoP5pbEZY+EvdIIGcNwmgEFexla3NACM9\n+ulSEtikfnWSO+INEhneXnOwEtDSmrC516Zhd4j2wKS\/BEYyf+p2BgeczjbeStzDX\n+ueNJWS9oCZhyFTkV6j1ri0ZTxjNFj4A7MqTC4PJykCVuTj+KOwg4ocRQ5OGMGimj\n+fd9eoUPeS2b\/BJA+1c8WI+FY1IfGCOl\/IRzYHcojy244B2X4IuNCvkhMBXY5OWAc\n+1mcCHQC69pamhXj3397n+mfJd8eF7zKyM7rlgMC81WldAoIBABamXFggSFBwTnUC\n+o5dXBA002jo0eMFU1OSlwC0kLuBPluYeS9CQSr2sjzfuseCfMYLSPJBDy2QviABB\n+YO35ygmzIHannDKmJ\/JHPpGHm6LE50S9IIFUTLVbgCw2jR+oPtSJ6U4PoGiOMkKK\n+XHjEeMaNBSe3HJo6uwsL4SxEaJY559POdNsQGmWqK4f2TGgm2z7HL0tVmYNLtO2w\n+L3yQ6aSW06VdU1vr\/EXU9hn2Pz3tu4c5JcLyJOB3MSltqIfsHkdI+H77X963VIQx\n+ayIy3uVT3a8CESsNHwLaMJcyJP4nrtqLnUspItm6i+Oe2eEDpjxSgQvGiLfi7UMW\n+4e8X294DggEFAAKCAQA\/itsE4Vrqw42DAl8X67qzfhpHUhMsvafnbxyD9ZDIa5u\/\n+hLs\/9dUGBaW\/FW7AmmHtdDo2QLmeFiYEpyMhitKG7J\/SWRZ5hgpYqhRIV26Z8a\/J\n+Wiq9LeAxvjtdb+Tw4cYcL6FGKH6WNQ297R8qsPld7UGD+\/rWeOAMpkbt5pymDFbA\n+8L9y7jxmf9nwgnIl0wR0rhKOwT+wJ+xGxTfgWQVnjV\/69zX5oPynweOfEmNoRG2X\n+hJ3Xh8cJvE0zRj4sG+i8nTUChBCjO63hDfdDLpUES3x1Ez1Xqcrjj\/laxwe2P3lI\n+R\/nTMc88MyvK8+F4S9Qz2jlS75QSA8kzT3jdFnsZoyEwHzAdBgNVHQ4EFgQUwPFf\n+jESLTEr9qKO2\/HOXgiq6O6gwDQYJYIZIAWUDBAMCBQADPwAwPAIcJBlPnlBiPy0F\n+M99zCO6fwFMLl+CbzU3vj4T3VQIcKEuzNEd5+ICSNUmkL89jIZxr7jrfUui7w0OX\n+RDE4MBEGCSqGSIb3DQEJFDEEHgIAYTAjBgkqhkiG9w0BCRUxFgQU0essNYYOWMdT\n+\/A\/ozvhbEmwKv2YwggL0BgkqhkiG9w0BBwGgggLlBIIC4TCCAt0wggLZBgsqhkiG\n+9w0BDAoBAqCCAo4wggKKMBwGCiqGSIb3DQEMAQMwDgQI8K+MRZ3EoKQCAggABIIC\n+aGUbReB6byOtQd7BAAym6y+S1O6URFnEjYs+aFVTmwRuRDE6d3xToxZUkOaVsUc5\n+kR5P6ixifkd\/S4yRl+t0Eqvn1yhTwR\/ptTm\/EL8a7RygPG3\/wsSsXUCVEBvtTO3q\n+G+iXUmLk5FjeiOpCbccOUNTZmPXgnSfw0YYrenjr5Z0MOk4BESe+\/V8rvEG71fJ7\n+KRE6m1b3E8ad3mz09BnccBFdJyY0xEjwD8KJLnUDVyaopYPnvi2Z7OunsyMWUgx8\n+gftqGpk5IhskIEnvgQ9NNjL2JpytbG0nVkpgtBULcKCXtPEqqweY\/6m5VFAhkikX\n+urUiJr+svjRFqkXuv+oPJ+6o\/Y4QTJSqHbavsXWEwAo+3IxyMhQwLMf\/6iXfBiGL\n+RIrLON3s6c0AcboGCtn1nfEcaXzNrTXkFpzJSFYGBHZVlXdyptDmsMXZbJlZAPFb\n+2dIzx9yJHqS3AV560p30399VWSko7HmY7t+EbZH\/vrdVD+Vzy2zPXFDtbu70j8C\/\n+RT21LAjjjrliIop\/2Akhz3eOTZcEAoQNBLcNBXoIdo7HiX6KzpKvdW51lWWEcAWf\n+zl878rJpmIdmvCc4HDkuzcpdvxk+q6pTn5Wh5K+X1ImTwWL+C+s4xHhiNAMzc4dK\n+eMsmukiAW301uZkjU30vpJ2BjBwrRo+ej9s18ePviy65E9UYeforrPIkaM9lpwID\n+AB17QgeVuciHiw\/g7HmbAacWwoqZc41eipIxqPWHlqEGYeARm0x4zb47qWwcowSO\n+AwlDuvRorpin25ZhiPesY1SJzFll5fAD0bxoQcry7S+2CetF7c8st3AxODARBgkq\n+hkiG9w0BCRQxBB4CAGEwIwYJKoZIhvcNAQkVMRYEFNHrLDWGDljHU\/wP6M74WxJs\n+Cr9m\n","filename":"jdk\/test\/sun\/security\/pkcs12\/params\/os2","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+MIIH4gIBAzCCB6gGCSqGSIb3DQEHAaCCB5kEggeVMIIHkTCCBJUGCSqGSIb3DQEH\n+AaCCBIYEggSCMIIEfjCCBHoGCyqGSIb3DQEMCgEDoIIELzCCBCsGCiqGSIb3DQEJ\n+FgGgggQbBIIEFzCCBBMwggO\/oAMCAQICBG7vGDQwDQYJYIZIAWUDBAMCBQAwDDEK\n+MAgGA1UEAxMBQTAeFw0xODA5MjgxMTI3MzlaFw0xODEyMjcxMTI3MzlaMAwxCjAI\n+BgNVBAMTAUEwggNCMIICNQYHKoZIzjgEATCCAigCggEBAI95Ndm5qum\/q+2Ies9J\n+UbbzLsWeO683GOjqxJYfPv02BudDUanEGDM5uAnnwq4cU5unR1uF0BGtuLR5h3VJ\n+hGlcrA6PFLM2CCiiL\/onEQo9YqmTRTQJoP5pbEZY+EvdIIGcNwmgEFexla3NACM9\n+ulSEtikfnWSO+INEhneXnOwEtDSmrC516Zhd4j2wKS\/BEYyf+p2BgeczjbeStzDX\n+ueNJWS9oCZhyFTkV6j1ri0ZTxjNFj4A7MqTC4PJykCVuTj+KOwg4ocRQ5OGMGimj\n+fd9eoUPeS2b\/BJA+1c8WI+FY1IfGCOl\/IRzYHcojy244B2X4IuNCvkhMBXY5OWAc\n+1mcCHQC69pamhXj3397n+mfJd8eF7zKyM7rlgMC81WldAoIBABamXFggSFBwTnUC\n+o5dXBA002jo0eMFU1OSlwC0kLuBPluYeS9CQSr2sjzfuseCfMYLSPJBDy2QviABB\n+YO35ygmzIHannDKmJ\/JHPpGHm6LE50S9IIFUTLVbgCw2jR+oPtSJ6U4PoGiOMkKK\n+XHjEeMaNBSe3HJo6uwsL4SxEaJY559POdNsQGmWqK4f2TGgm2z7HL0tVmYNLtO2w\n+L3yQ6aSW06VdU1vr\/EXU9hn2Pz3tu4c5JcLyJOB3MSltqIfsHkdI+H77X963VIQx\n+ayIy3uVT3a8CESsNHwLaMJcyJP4nrtqLnUspItm6i+Oe2eEDpjxSgQvGiLfi7UMW\n+4e8X294DggEFAAKCAQA\/itsE4Vrqw42DAl8X67qzfhpHUhMsvafnbxyD9ZDIa5u\/\n+hLs\/9dUGBaW\/FW7AmmHtdDo2QLmeFiYEpyMhitKG7J\/SWRZ5hgpYqhRIV26Z8a\/J\n+Wiq9LeAxvjtdb+Tw4cYcL6FGKH6WNQ297R8qsPld7UGD+\/rWeOAMpkbt5pymDFbA\n+8L9y7jxmf9nwgnIl0wR0rhKOwT+wJ+xGxTfgWQVnjV\/69zX5oPynweOfEmNoRG2X\n+hJ3Xh8cJvE0zRj4sG+i8nTUChBCjO63hDfdDLpUES3x1Ez1Xqcrjj\/laxwe2P3lI\n+R\/nTMc88MyvK8+F4S9Qz2jlS75QSA8kzT3jdFnsZoyEwHzAdBgNVHQ4EFgQUwPFf\n+jESLTEr9qKO2\/HOXgiq6O6gwDQYJYIZIAWUDBAMCBQADPwAwPAIcJBlPnlBiPy0F\n+M99zCO6fwFMLl+CbzU3vj4T3VQIcKEuzNEd5+ICSNUmkL89jIZxr7jrfUui7w0OX\n+RDE4MBEGCSqGSIb3DQEJFDEEHgIAYTAjBgkqhkiG9w0BCRUxFgQU0essNYYOWMdT\n+\/A\/ozvhbEmwKv2YwggL0BgkqhkiG9w0BBwGgggLlBIIC4TCCAt0wggLZBgsqhkiG\n+9w0BDAoBAqCCAo4wggKKMBwGCiqGSIb3DQEMAQMwDgQIFvtCm+ogILcCAggABIIC\n+aLbDb3DKmULPLHfwvcVdp3cbM1Bcj3T\/keIzwnOzdMluj8wisUEQA\/U1onSgp1eZ\n+Hfk0TPcgd339Uevuh059GL5yFknH2VHhU6nO8Pz+OVpjab9nSBpWjv+PnlSAKWr6\n+5ODx9t5TGPO5V7PBqtxDiU4YeBI6akUlroJz3lSH3dD8t3KBdi3GjnG0S4iBadrW\n+BGV5izRPIbaDpISAscwDInXZ4HJhWbD14\/mEOyKHwAmD+NwxMhAS97SRC7N\/rAJD\n+ACj0dQYb3MW4QqVgF2QBQmOYXq6CsrQvc8faQWpqgH2JYzquTu4vx7xFGuKlXSLU\n++9hAo99NID6xYryebjMFe7sJFLXyMYLt9pWn5f72xR0PrH71EpTRQkZVIYUfnxkL\n+iCFwNgWyPF7NYwieUKQ+JyPq3cllK+kuViiNwEvYO4TJp4XjYMXefXFlarX2llQz\n+J\/tu9LJu9eA9A528i7hvJ0ZFpYtZA40CWaJRlCKZqT9P\/YQGiNOt31JxJtFyiEpl\n+i\/dh49clBpibQouRKSc\/uTNePJ1IyaWkgE1SwmmEz+ZSFSlhxS4Ba0+2MsRKoirC\n+8M6V0A16W4V2af9jVgRpIyRcRfYZBBij2Cu2k\/UB\/hrqxlYp3nehOC6PAVT40EwC\n+HO5613cu2LSJDgxEtaNMcj5Zy6KkJ3vB2BxxfdHL6Dz3uLa+8BuEpfLUidccgCgm\n+MQpxplgLVztIkq6HZy\/koMGgv2ywV7LGLlVpKBHmKDO2yvYhr6J2rbNMsh5Bbq9i\n+YiZVz7TdmqY4L8rEtEuwJA2SgHUV0FhpoD56WTfPZvfYgoHhHu1hBcQxODARBgkq\n+hkiG9w0BCRQxBB4CAGEwIwYJKoZIhvcNAQkVMRYEFNHrLDWGDljHU\/wP6M74WxJs\n+Cr9mMDEwITAJBgUrDgMCGgUABBRQNcC69+RQUJu5I4ode2JYzXe2KAQI1mkwkuSh\n+sUUCAggA\n","filename":"jdk\/test\/sun\/security\/pkcs12\/params\/os3","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+MIIIGwIBAzCCB9UGCSqGSIb3DQEHAaCCB8YEggfCMIIHvjCCBMkGCSqGSIb3DQEH\n+BqCCBLowggS2AgEAMIIErwYJKoZIhvcNAQcBMBwGCiqGSIb3DQEMAQEwDgQIkluN\n+Qu+v+1gCAggAgIIEgr9xMS47pyB8kvlbU+\/Uwh4pfbjeLm4h4FjR1GxKU0ouoct7\n+cg\/4S1AZfa2vjVCRxkdWLvf88eAtp96E1YVIdDT\/3ZSY953eNA\/xvNF2HWVJT18H\n+jEOuNhmVHbuMIbfmG8sm6rwN2e3xnxuCDkYWvLNTiWOcoQTmLfJIqp5J2FLj2zwN\n+0jApAepDE2NtEaq+edMU+3c3d7b0+n9BB32b5w1LaXzShuN2cpHOYJvkw+h32eyJ\n+XrjlRB8J9\/4XAzyz269UM9QWdxECqBeTfd1m8PhV\/9xR9QOIcur0Flv\/Cw0j3sos\n+oMBibypXsV7GzGZKrUAIVAnhYsDB\/yxxL\/vPjZ8nCzl7iKc+wBNJiXIO04XNg00U\n+bUBOSeoGs4ns909u09+qtwQf6fCiV8VwP\/h5vIGB++Kv06O9CWt20lOv9KZPqZOR\n+5H0ndbx60LoTsPT5FzOysOWqUNFx6wiggV9Txl38zax\/VwOLA01Uq1jPDHEHQWIY\n+M139MTL+5P43hDBy9TOyO8uzD3eUj3\/+pvoyZb2wfV7NmN5WBgP\/MDnm6Jk+eFMw\n+6v4mXwKycIX6qsBNdTc4QAEgcHwv544eqxPiBuxerr5bySSodWjoziEtyzvgNx1f\n+jGqQDn7VlZlDrn6rlJ0\/iX0xv4M\/PVngMUezfmW+zo4998NXlurXKbA2FG\/U0mqt\n+Ys0QGYkfoTFwHixYK4Mf7B4pwlHo3FCO+kjv+t1VZxZF\/Pr8B1qflgeBJaiqH6oJ\n+oh1L1vdOh93VowZFUvgmx27Fb3rIUhvGh1rzfhp5OmMaoXP97TwaHLsK2c\/BDwJp\n+cwmfaJByDcrlTAeBsNlzffD0o61ZAhYMZuGFEoyuIpm8qOcIW1dVrYe8tYP7ZTDA\n+FUmmoymB+6cK8wW5V5BeRmSxU2DnkBDGriEzQTtepQLgzy7LtLU8rs1mIszwTiNj\n+60MI6gX22taT0C8kpsH\/xwKeKw+7tsyL8bk4N8zQ8h\/osMdxtO0QVpxikQ3KAinj\n+nurVqvcqq3n0EqHwRJ+NQMwuERbbDXcRDowQSWJc2HLn8odxL18dvOpu2IQlH2DA\n+NtZpLqP7EZ36ebA6txlPdH2GUH7V9ZQwF+3t+NbMXrZLx93DAwdpzVDY9a96AFsE\n+YHd3f3ReT8TzIwB1dOrvIOPO82cIy5\/OIaDa9XelY2\/dRVfU4cHpNhRZSLmsQfsQ\n+yorPQi1baNT0GjoCDgynUvP2DWBdIyjZ442ysfNmO5MjmjYEA17ofBapc4xhsU5B\n++XgyfVyfeDHNO+zMZvrdMPnXwu+A3ggaQorvQbAfV8JfVSZoyleKjTxNgx61KI3j\n+dQsEtLQgvAbLsI+Ku7z86HVZ7PH69i3qHtJo8s8Nw4a9QvCCgpiMqw04EQawlZY1\n+aCrOsHvElFB0klIlGpMPugJ1YVgSvXtMwLgLMlAr8mQW+10uKMtrVU5Iq6SAkRDe\n+ff57iqXoKpNJVGsV9ZxrMT7Y5oECJvHLUWtqapsu7Xpp0\/DUPcRxAfCj7ZBxEfVW\n+sBBDmUia+TTVYT7TJPTzMIIC7QYJKoZIhvcNAQcBoIIC3gSCAtowggLWMIIC0gYL\n+KoZIhvcNAQwKAQKgggKHMIICgzAcBgoqhkiG9w0BDAEBMA4ECLpLJ5EtNx41AgII\n+AASCAmEutLb3vdtinkV4hEXRDnRPd19WXSTOFI5g3ZLc2liyiQ3fA\/gvXQihmZjp\n+spYf6kWBkI6+hx3AwM1Vg0FerAJAe9MnMZqZtu\/pdqaxiPnbdm5lpB2FiLyrCvY+\n+8cyISOPi9LRWZCsf24dUBVHJu4W+BULiZSwoakwLy7UxNclcBKrrIz3brm5UF2Xl\n+CMqI3N+afaHDst2n1BjwX4InnU9p2FY5Em227hdoWWni+IR8fn0yUMz2ma\/kgQ2\/\n+ntr3ursuq27kC3haWW47kitxK2fZIyjs03gQp2sH0u0ReDIt3EswvPWgjT+EkpjW\n+NgXK7GyWVdjcJDciTnIBs\/vvhkcZVuTgflYpFTbzRK1I1M2eXSjxmEKQ8vmA2wRr\n+IFzrEcMOo5pTFnUxeOfpucV2j5uD8g8Uk9rxkOwaM1q9yipf5qd5MjJBKrqBuqaW\n+3v9tKwCoJRTRWR+Y7SMjy2aB\/Y2pRGMtmPOuUs4q81ket97Vp4R9ruIkIsEvVMg6\n+hXWIhP7Or13f7Qr2Xh71Px7VJmMmfhBaXLEfJtD7kVmRAFzPK0QHYDCpLoka\/7aZ\n+AsrRP54XCkDTeTwhFkKLJW68a4s7+bLaHjaGgjb+62\/J2CulVG6KDvlo3I2\/yB8P\n+0lWzWJdLJuRnPDPVZTB2HXKb\/XJtw1MdcdvxvtzEbSM4naZ1YfYVXzT+zowq7kKk\n+N0sgLv357q0HsylKT2Rvs94J0ackaiVaBQCHVReSfNPRwQ2IvjvEq3AML+vt06x7\n+4lXiPtNsuAnkMA7whVWTdSZTvSPGxesWIS+3kTAybMPkum7KIL8xODARBgkqhkiG\n+9w0BCRQxBB4CAGEwIwYJKoZIhvcNAQkVMRYEFNHrLDWGDljHU\/wP6M74WxJsCr9m\n+MD0wLTANBglghkgBZQMEAgQFAAQcG2U041U943EvoFbDQVXR7ZMuU8LZJ4EiaB6O\n+owQIAiAhw9ZbovsCAggA\n","filename":"jdk\/test\/sun\/security\/pkcs12\/params\/os4","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+MIII0gIBAzCCCGgGCSqGSIb3DQEHAaCCCFkEgghVMIIIUTCCBRIGCSqGSIb3DQEH\n+BqCCBQMwggT\/AgEAMIIE+AYJKoZIhvcNAQcBMFcGCSqGSIb3DQEFDTBKMCkGCSqG\n+SIb3DQEFDDAcBAgb15a0ITFWEQICCAAwDAYIKoZIhvcNAgkFADAdBglghkgBZQME\n+ASoEEC7w7N9MK45XaZg4OAPhmtWAggSQ2OAIm4D\/rCA94AbcuQCpYxG8Td7v6cbY\n+bnP9twj3Cvt5muXvMV32lMj\/ucXPuICt5lXdBMhHVJ8jxJq3t8GBbJbIpmG\/CzXv\n+ImZa\/Zt4TLBwKKibvaT6LHocCJAh3eRoHiXdje71KeVmu80d+ygl7w5\/fnqc+FO6\n+ypDx2OzcVTDMVnBdT9pD9eLCQQBxA8uvZFuY3C5GTONgE8WpvtqLHhjHLAff0T9N\n+B6eNiFxqP3WVzobcNmOV0H\/6Vn5YUcVk7kk5YtYBbeHo5mq7hkoMKtniQiGMd8Qh\n+GYw6d+OPYBr+CDA\/TsGApUxdqMNsdtyn83BEx\/6y9BA4veWz54DU5o4PqnvV332V\n+ZUa3cD+4r5yfRcM5AFCEOppvK5i\/3aJllCsKn4yVzHpWn6vmL\/qQCZU1epgONmzJ\n+eCAOTPiDKkc5mJc4qj+ILIVuY+m+n\/wNdWgrhr5zGzSGwHgaQMmnhCjF2BlAZL7m\n+neIPDSqBImCVuA3MWPerkhW9SHbIiAXmIUN\/DBI\/fiPlryCSN\/oMujLJgogADtks\n+J4ml2zByChWcepayfpi+YVdIc+eNTjAqrW3iD26mnEqyWPjey+lFfvKmUffNnL46\n+IMeN33WPjMLi0rmxqsPGLpK8rw81TE6qe8d4SXqgZfzV5uQFEOV\/tGZ0QOuXgkc6\n+YAsZlYz7QNdh9I7JhwTup\/j4nPcgM5NJXvRCVq765MCzV\/gdLeO2msuR\/VlvIZon\n+P9HTzqzOkCakT0nV\/bdPAMGAhZt7iprgn1Gb\/XiA9GK+ejeaZfRW4YJ6oqGI\/5gS\n+RNxdf9I5ThC9efFdPM+3WxKun4bSBjJZCBjAkRlse2nQt\/ET51qAt8T1Uw0ON5ch\n+NoHe\/ZE9MNX5\/9bt6T9w86Gh\/Wfzq8K\/93ywlbd7fNOJm\/T8HH9yY1Lm3Hg4PgES\n+feA3VL0JeTWnZu\/ngLQ8JWRKKYjNg0BwejoKRZ3PEpnS1ZUxmjcJlgXGn2SWW99+\n+j\/dQgl80Tn\/IJnAUBwxvDjmoWVvAGLglnNbruCWX\/bjTg4cJyYVeSQ5fEHyi2pU\/\n++bcvVTK9HuWE7cT9rDP4rWPRaAi4UAB9AShx3jgh\/g2Va8Tqpow1hqS2eSjm+JfQ\n+Bk3Nh6dYDgqLW4OjCTVfRa4hzbNck5zcybY3JtC7jKjok31V87W1jPRveWgXYE0z\n+AZlSRwgnzMujycpXplZ9JMz9QMB7toISVs+ArjN2CZRjLCWRAwLcoKQ7D1A5S8LU\n+PYXk\/y7ovmaSfyN1PYkaelnAuo2zI4YWDM\/LL55het4Y8eCo0zFwLSxDrPz5jW8p\n+A4S1Du5JJ7n52RYmI9+QxwymCUOkWScpIgI\/aM6p4s3xfnqGMZUQy+O0qMsczSw0\n+i9IVx\/C8akDjK\/gMlJePYqil\/WPfEUl5qAkGn9eu2\/kC4XNITiM9xNBDy1d+NvSO\n+8CjBfDd3pOPqjqeM\/dLO660ZZrsvt7LnevJQ+9pq9LeXIrcHpLJp2Oqq5o85lCn7\n+\/eoykT+ghu6L0OhYaIcDNMvxUAXJfVQQ0rMd+q\/72VKdb2HGrB88CjCCAzcGCSqG\n+SIb3DQEHAaCCAygEggMkMIIDIDCCAxwGCyqGSIb3DQEMCgECoIIC0TCCAs0wVwYJ\n+KoZIhvcNAQUNMEowKQYJKoZIhvcNAQUMMBwECOnimmypiWZ5AgIIADAMBggqhkiG\n+9w0CCQUAMB0GCWCGSAFlAwQBKgQQLT9O9V8VM45JpgROXv51VgSCAnAbjtRsnqGS\n+hwCR6JP8T3ZpY1LUjZM7P\/X0VcQ+Fq3cxHtY5Bf55+Ha8cQRGwnptlwnfgxILGIn\n+1yseJSkKUTDTIlMpoFfDtLCU0lNWzwhYfbajUxIesYsgFYCYn94MgJ+Vb7MWbbW+\n+KxhqSGWPDicCZ6dY2zNFUt4dnxJ1NYZGS4ZpfDmdh\/bW29vT++Yi1H6Be1Qd+aMj\n+a9+8Yb69AjnglujqOKTlzaXPb1DfnuteZKUZxqt\/6TR1fh28KYxBJ6YvyDzkwhx\/\n+0ksy\/+ItokRWZ9Bb2nmIiss352UtGEi2JOIN+QyOcvSCQCvPucW1DXg53dOhVvEZ\n+Q1NNKvV9w8s8ao0GotqCK6lfu1fHo2yrp5dV3p03Xxzu1jeuZL27oSaHvW6on90s\n+oV0djJUHHtYJOp1YWEOJOSqQsHsvPA4G9YMKx00Rl9P0aVSWTNqN96VjEzHOHyCX\n+lzH5asHLbsTbnvhQHmq1J7Jm3RjncZ+oJOdcvkBoKUnYbqCHJiUOM7McRIEI0VkI\n+0Endzm+U0z8jZxcpvAowgOf\/sWC\/ddr\/1rNRE\/BzVhmqvLfYOkIsvBwm6LpbiOgg\n+fV0VUHZxTSk6uwYLfNQkJ7i\/NQOCAo8MGIHAMi0e5\/FAAE7mN2V2HfWCQOiXjsnD\n+Twb9xztwa6u8tjCXLfW5sws958sxMMM23F61Q6aZcx0k+lc9VaiHgRUjiwKesZjn\n+E3b\/mKSFEIy\/9dqC5SpmIctEmoQWcxNNntSzD6WkA0EP5pw0CoAzMSW2Mzp5D6kD\n+\/0pH6xjs9oaMmoq6SoTphNF9hsJJ\/uXUSVtO8ZrKB0upHGl+Q5lwLeMxODARBgkq\n+hkiG9w0BCRQxBB4CAGEwIwYJKoZIhvcNAQkVMRYEFNHrLDWGDljHU\/wP6M74WxJs\n+Cr9mMGEwUTANBglghkgBZQMEAgMFAARAjFxC6pnq5Gh874xeaWuQ+C9mmRbiqBaL\n+MgfxIfJj3AFVFXGlm7xigHtZGFIrkXNC5croycYgTPMOczulADAOdgQIOFtoK+zm\n+YOMCAggA\n","filename":"jdk\/test\/sun\/security\/pkcs12\/params\/os5","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"}]}