{"files":[{"patch":"@@ -1,190 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2010, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStream;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-\n-import java.lang.reflect.Method;\n-import java.net.URI;\n-import java.util.Arrays;\n-import java.util.Vector;\n-\n-import javax.tools.Diagnostic;\n-import javax.tools.DiagnosticCollector;\n-import javax.tools.FileObject;\n-import javax.tools.ForwardingJavaFileManager;\n-import javax.tools.JavaCompiler;\n-import javax.tools.JavaCompiler.CompilationTask;\n-import javax.tools.JavaFileManager;\n-import javax.tools.JavaFileObject;\n-import javax.tools.JavaFileObject.Kind;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.StandardJavaFileManager;\n-import javax.tools.ToolProvider;\n-\n-\/*\n- * @test SortMethodsTest\n- * @bug 6925573\n- * @summary verify that class loading does not need quadratic time with regard to the number of class\n-methods.\n- * @run main SortMethodsTest\n- * @author volker.simonis@gmail.com\n-*\/\n-\n-public class SortMethodsTest {\n-\n-  static String createClass(String name, int nrOfMethods) {\n-    StringWriter sw = new StringWriter();\n-    PrintWriter pw = new PrintWriter(sw);\n-    pw.println(\"public class \" + name + \"{\");\n-    for (int i = 0; i < nrOfMethods; i++) {\n-      pw.println(\"  public void m\" + i + \"() {}\");\n-    }\n-    pw.println(\"  public static String sayHello() {\");\n-    pw.println(\"    return \\\"Hello from class \\\" + \" + name +\n-               \".class.getName() + \\\" with \\\" + \" + name +\n-               \".class.getDeclaredMethods().length + \\\" methods\\\";\");\n-    pw.println(\"  }\");\n-    pw.println(\"}\");\n-    pw.close();\n-    return sw.toString();\n-  }\n-\n-  public static void main(String args[]) {\n-\n-    JavaCompiler comp = ToolProvider.getSystemJavaCompiler();\n-    DiagnosticCollector<JavaFileObject> diags = new DiagnosticCollector<JavaFileObject>();\n-    final String cName = new String(\"ManyMethodsClass\");\n-    Vector<Long> results = new Vector<Long>();\n-\n-    for (int i = 6; i < 600000; i*=10) {\n-      String klass =  createClass(cName, i);\n-      JavaMemoryFileObject file = new JavaMemoryFileObject(cName, klass);\n-      MemoryFileManager mfm = new MemoryFileManager(comp.getStandardFileManager(diags, null, null), file);\n-      CompilationTask task = comp.getTask(null, mfm, diags, null, null, Arrays.asList(file));\n-\n-      if (task.call()) {\n-        try {\n-          MemoryClassLoader mcl = new MemoryClassLoader(file);\n-          long start = System.nanoTime();\n-          Class<? extends Object> c = Class.forName(cName, true, mcl);\n-          long end = System.nanoTime();\n-          results.add(end - start);\n-          Method m = c.getDeclaredMethod(\"sayHello\", new Class[0]);\n-          String ret = (String)m.invoke(null, new Object[0]);\n-          System.out.println(ret + \" (loaded and resloved in \" + (end - start) + \"ns)\");\n-        } catch (Exception e) {\n-          System.err.println(e);\n-        }\n-      }\n-      else {\n-        System.out.println(klass);\n-        System.out.println();\n-        for (Diagnostic diag : diags.getDiagnostics()) {\n-          System.out.println(diag.getCode() + \"\\n\" + diag.getKind() + \"\\n\" + diag.getPosition());\n-          System.out.println(diag.getSource() + \"\\n\" + diag.getMessage(null));\n-        }\n-      }\n-    }\n-\n-    long lastRatio = 0;\n-    for (int i = 2; i < results.size(); i++) {\n-      long normalized1 = Math.max(results.get(i-1) - results.get(0), 1);\n-      long normalized2 = Math.max(results.get(i) - results.get(0), 1);\n-      long ratio = normalized2\/normalized1;\n-      lastRatio = ratio;\n-      System.out.println(\"10 x more methods requires \" + ratio + \" x more time\");\n-    }\n-    \/\/ The following is just vague estimation but seems to work on current x86_64 and sparcv9 machines\n-    if (lastRatio > 80) {\n-      throw new RuntimeException(\"ATTENTION: it seems that class loading needs quadratic time with regard to the number of class methods!!!\");\n-    }\n-  }\n-}\n-\n-class JavaMemoryFileObject extends SimpleJavaFileObject {\n-\n-  private final String code;\n-  private ByteArrayOutputStream byteCode;\n-\n-  JavaMemoryFileObject(String name, String code) {\n-    super(URI.create(\"string:\/\/\/\" + name.replace('.','\/') + Kind.SOURCE.extension), Kind.SOURCE);\n-    this.code = code;\n-  }\n-\n-  @Override\n-  public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n-    return code;\n-  }\n-\n-  @Override\n-  public OutputStream openOutputStream() {\n-    byteCode = new ByteArrayOutputStream();\n-    return byteCode;\n-  }\n-\n-  byte[] getByteCode() {\n-    return byteCode.toByteArray();\n-   }\n-}\n-\n-class MemoryClassLoader extends ClassLoader {\n-\n-  private final JavaMemoryFileObject jfo;\n-\n-  public MemoryClassLoader(JavaMemoryFileObject jfo) {\n-    this.jfo = jfo;\n-  }\n-\n-  public Class findClass(String name) {\n-    byte[] b = jfo.getByteCode();\n-    return defineClass(name, b, 0, b.length);\n-  }\n-}\n-\n-class MemoryFileManager extends ForwardingJavaFileManager<JavaFileManager> {\n-\n-  private final JavaFileObject jfo;\n-\n-  public MemoryFileManager(StandardJavaFileManager jfm, JavaFileObject jfo) {\n-    super(jfm);\n-    this.jfo = jfo;\n-  }\n-\n-  @Override\n-  public FileObject getFileForInput(Location location, String packageName,\n-                                    String relativeName) throws IOException {\n-    return jfo;\n-  }\n-\n-  @Override\n-  public JavaFileObject getJavaFileForOutput(Location location, String qualifiedName,\n-                                             Kind kind, FileObject outputFile) throws IOException {\n-    return jfo;\n-  }\n-\n-}\n","filename":"hotspot\/test\/runtime\/6925573\/SortMethodsTest.java","additions":0,"deletions":190,"binary":false,"changes":190,"status":"deleted"}]}