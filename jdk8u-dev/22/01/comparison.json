{"files":[{"patch":"@@ -223,3 +223,0 @@\n-  diagnostic(bool, LoopLimitCheck, true,                                    \\\n-          \"Generate a loop limits check for overflow\")                      \\\n-                                                                            \\\n@@ -229,3 +226,0 @@\n-  diagnostic(bool, RangeLimitCheck, true,                                   \\\n-          \"Additional overflow checks during range check elimination\")      \\\n-                                                                            \\\n@@ -235,3 +229,0 @@\n-  diagnostic(bool, UnrollLimitCheck, true,                                  \\\n-          \"Additional overflow checks during loop unroll\")                  \\\n-                                                                            \\\n","filename":"hotspot\/src\/share\/vm\/opto\/c2_globals.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3762,3 +3762,1 @@\n-  if (LoopLimitCheck) {\n-    add_predicate_impl(Deoptimization::Reason_loop_limit_check, nargs);\n-  }\n+  add_predicate_impl(Deoptimization::Reason_loop_limit_check, nargs);\n","filename":"hotspot\/src\/share\/vm\/opto\/graphKit.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -299,5 +299,3 @@\n-  if (LoopLimitCheck) {\n-    limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-    if (limit_check_proj != NULL) {\n-      entry = entry->in(0)->in(0);\n-    }\n+  limit_check_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n+  if (limit_check_proj != NULL) {\n+    entry = entry->in(0)->in(0);\n@@ -339,5 +337,3 @@\n-  if (LoopLimitCheck) {\n-    predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-    if (predicate != NULL) {\n-      entry = entry->in(0)->in(0);\n-    }\n+  predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n+  if (predicate != NULL) {\n+    entry = entry->in(0)->in(0);\n@@ -379,5 +375,3 @@\n-  if (LoopLimitCheck) {\n-    predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-    if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n-      return entry;\n-    }\n+  predicate = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n+  if (predicate != NULL) { \/\/ right pattern that can be used by loop predication\n+    return entry;\n@@ -808,5 +802,3 @@\n-  if (LoopLimitCheck) {\n-    predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-    if (predicate_proj != NULL)\n-      entry = predicate_proj->in(0)->in(0);\n-  }\n+  predicate_proj = find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n+  if (predicate_proj != NULL)\n+    entry = predicate_proj->in(0)->in(0);\n","filename":"hotspot\/src\/share\/vm\/opto\/loopPredicate.cpp","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1241,33 +1241,32 @@\n-  if (UnrollLimitCheck) {\n-    int stride_con = stride->get_int();\n-    int stride_p = (stride_con > 0) ? stride_con : -stride_con;\n-    uint old_trip_count = loop_head->trip_count();\n-    \/\/ Verify that unroll policy result is still valid.\n-    assert(old_trip_count > 1 &&\n-           (!adjust_min_trip || stride_p <= (1<<3)*loop_head->unrolled_count()), \"sanity\");\n-\n-    \/\/ Adjust loop limit to keep valid iterations number after unroll.\n-    \/\/ Use (limit - stride) instead of (((limit - init)\/stride) & (-2))*stride\n-    \/\/ which may overflow.\n-    if (!adjust_min_trip) {\n-      assert(old_trip_count > 1 && (old_trip_count & 1) == 0,\n-             \"odd trip count for maximally unroll\");\n-      \/\/ Don't need to adjust limit for maximally unroll since trip count is even.\n-    } else if (loop_head->has_exact_trip_count() && init->is_Con()) {\n-      \/\/ Loop's limit is constant. Loop's init could be constant when pre-loop\n-      \/\/ become peeled iteration.\n-      jlong init_con = init->get_int();\n-      \/\/ We can keep old loop limit if iterations count stays the same:\n-      \/\/   old_trip_count == new_trip_count * 2\n-      \/\/ Note: since old_trip_count >= 2 then new_trip_count >= 1\n-      \/\/ so we also don't need to adjust zero trip test.\n-      jlong limit_con  = limit->get_int();\n-      \/\/ (stride_con*2) not overflow since stride_con <= 8.\n-      int new_stride_con = stride_con * 2;\n-      int stride_m    = new_stride_con - (stride_con > 0 ? 1 : -1);\n-      jlong trip_count = (limit_con - init_con + stride_m)\/new_stride_con;\n-      \/\/ New trip count should satisfy next conditions.\n-      assert(trip_count > 0 && (julong)trip_count < (julong)max_juint\/2, \"sanity\");\n-      uint new_trip_count = (uint)trip_count;\n-      adjust_min_trip = (old_trip_count != new_trip_count*2);\n-    }\n+  int stride_con = stride->get_int();\n+  int stride_p = (stride_con > 0) ? stride_con : -stride_con;\n+  uint old_trip_count = loop_head->trip_count();\n+  \/\/ Verify that unroll policy result is still valid.\n+  assert(old_trip_count > 1 &&\n+          (!adjust_min_trip || stride_p <= (1<<3)*loop_head->unrolled_count()), \"sanity\");\n+\n+  \/\/ Adjust loop limit to keep valid iterations number after unroll.\n+  \/\/ Use (limit - stride) instead of (((limit - init)\/stride) & (-2))*stride\n+  \/\/ which may overflow.\n+  if (!adjust_min_trip) {\n+    assert(old_trip_count > 1 && (old_trip_count & 1) == 0,\n+            \"odd trip count for maximally unroll\");\n+    \/\/ Don't need to adjust limit for maximally unroll since trip count is even.\n+  } else if (loop_head->has_exact_trip_count() && init->is_Con()) {\n+    \/\/ Loop's limit is constant. Loop's init could be constant when pre-loop\n+    \/\/ become peeled iteration.\n+    jlong init_con = init->get_int();\n+    \/\/ We can keep old loop limit if iterations count stays the same:\n+    \/\/   old_trip_count == new_trip_count * 2\n+    \/\/ Note: since old_trip_count >= 2 then new_trip_count >= 1\n+    \/\/ so we also don't need to adjust zero trip test.\n+    jlong limit_con  = limit->get_int();\n+    \/\/ (stride_con*2) not overflow since stride_con <= 8.\n+    int new_stride_con = stride_con * 2;\n+    int stride_m    = new_stride_con - (stride_con > 0 ? 1 : -1);\n+    jlong trip_count = (limit_con - init_con + stride_m)\/new_stride_con;\n+    \/\/ New trip count should satisfy next conditions.\n+    assert(trip_count > 0 && (julong)trip_count < (julong)max_juint\/2, \"sanity\");\n+    uint new_trip_count = (uint)trip_count;\n+    adjust_min_trip = (old_trip_count != new_trip_count*2);\n+  }\n@@ -1275,18 +1274,36 @@\n-    if (adjust_min_trip) {\n-      \/\/ Step 2: Adjust the trip limit if it is called for.\n-      \/\/ The adjustment amount is -stride. Need to make sure if the\n-      \/\/ adjustment underflows or overflows, then the main loop is skipped.\n-      Node* cmp = loop_end->cmp_node();\n-      assert(cmp->in(2) == limit, \"sanity\");\n-      assert(opaq != NULL && opaq->in(1) == limit, \"sanity\");\n-\n-      \/\/ Verify that policy_unroll result is still valid.\n-      const TypeInt* limit_type = _igvn.type(limit)->is_int();\n-      assert(stride_con > 0 && ((limit_type->_hi - stride_con) < limit_type->_hi) ||\n-             stride_con < 0 && ((limit_type->_lo - stride_con) > limit_type->_lo), \"sanity\");\n-\n-      if (limit->is_Con()) {\n-        \/\/ The check in policy_unroll and the assert above guarantee\n-        \/\/ no underflow if limit is constant.\n-        new_limit = _igvn.intcon(limit->get_int() - stride_con);\n-        set_ctrl(new_limit, C->root());\n+  if (adjust_min_trip) {\n+    \/\/ Step 2: Adjust the trip limit if it is called for.\n+    \/\/ The adjustment amount is -stride. Need to make sure if the\n+    \/\/ adjustment underflows or overflows, then the main loop is skipped.\n+    Node* cmp = loop_end->cmp_node();\n+    assert(cmp->in(2) == limit, \"sanity\");\n+    assert(opaq != NULL && opaq->in(1) == limit, \"sanity\");\n+\n+    \/\/ Verify that policy_unroll result is still valid.\n+    const TypeInt* limit_type = _igvn.type(limit)->is_int();\n+    assert(stride_con > 0 && ((limit_type->_hi - stride_con) < limit_type->_hi) ||\n+            stride_con < 0 && ((limit_type->_lo - stride_con) > limit_type->_lo), \"sanity\");\n+\n+    if (limit->is_Con()) {\n+      \/\/ The check in policy_unroll and the assert above guarantee\n+      \/\/ no underflow if limit is constant.\n+      new_limit = _igvn.intcon(limit->get_int() - stride_con);\n+      set_ctrl(new_limit, C->root());\n+    } else {\n+      \/\/ Limit is not constant.\n+      if (loop_head->unrolled_count() == 1) { \/\/ only for first unroll\n+        \/\/ Separate limit by Opaque node in case it is an incremented\n+        \/\/ variable from previous loop to avoid using pre-incremented\n+        \/\/ value which could increase register pressure.\n+        \/\/ Otherwise reorg_offsets() optimization will create a separate\n+        \/\/ Opaque node for each use of trip-counter and as result\n+        \/\/ zero trip guard limit will be different from loop limit.\n+        assert(has_ctrl(opaq), \"should have it\");\n+        Node* opaq_ctrl = get_ctrl(opaq);\n+        limit = new (C) Opaque2Node( C, limit );\n+        register_new_node( limit, opaq_ctrl );\n+      }\n+      if (stride_con > 0 && (java_subtract(limit_type->_lo, stride_con) < limit_type->_lo) ||\n+          stride_con < 0 && (java_subtract(limit_type->_hi, stride_con) > limit_type->_hi)) {\n+        \/\/ No underflow.\n+        new_limit = new (C) SubINode(limit, stride);\n@@ -1294,17 +1311,29 @@\n-        \/\/ Limit is not constant.\n-        if (loop_head->unrolled_count() == 1) { \/\/ only for first unroll\n-          \/\/ Separate limit by Opaque node in case it is an incremented\n-          \/\/ variable from previous loop to avoid using pre-incremented\n-          \/\/ value which could increase register pressure.\n-          \/\/ Otherwise reorg_offsets() optimization will create a separate\n-          \/\/ Opaque node for each use of trip-counter and as result\n-          \/\/ zero trip guard limit will be different from loop limit.\n-          assert(has_ctrl(opaq), \"should have it\");\n-          Node* opaq_ctrl = get_ctrl(opaq);\n-          limit = new (C) Opaque2Node( C, limit );\n-          register_new_node( limit, opaq_ctrl );\n-        }\n-        if (stride_con > 0 && (java_subtract(limit_type->_lo, stride_con) < limit_type->_lo) ||\n-            stride_con < 0 && (java_subtract(limit_type->_hi, stride_con) > limit_type->_hi)) {\n-          \/\/ No underflow.\n-          new_limit = new (C) SubINode(limit, stride);\n+        \/\/ (limit - stride) may underflow.\n+        \/\/ Clamp the adjustment value with MININT or MAXINT:\n+        \/\/\n+        \/\/   new_limit = limit-stride\n+        \/\/   if (stride > 0)\n+        \/\/     new_limit = (limit < new_limit) ? MININT : new_limit;\n+        \/\/   else\n+        \/\/     new_limit = (limit > new_limit) ? MAXINT : new_limit;\n+        \/\/\n+        BoolTest::mask bt = loop_end->test_trip();\n+        assert(bt == BoolTest::lt || bt == BoolTest::gt, \"canonical test is expected\");\n+        Node* adj_max = _igvn.intcon((stride_con > 0) ? min_jint : max_jint);\n+        set_ctrl(adj_max, C->root());\n+        Node* old_limit = NULL;\n+        Node* adj_limit = NULL;\n+        Node* bol = limit->is_CMove() ? limit->in(CMoveNode::Condition) : NULL;\n+        if (loop_head->unrolled_count() > 1 &&\n+            limit->is_CMove() && limit->Opcode() == Op_CMoveI &&\n+            limit->in(CMoveNode::IfTrue) == adj_max &&\n+            bol->as_Bool()->_test._test == bt &&\n+            bol->in(1)->Opcode() == Op_CmpI &&\n+            bol->in(1)->in(2) == limit->in(CMoveNode::IfFalse)) {\n+          \/\/ Loop was unrolled before.\n+          \/\/ Optimize the limit to avoid nested CMove:\n+          \/\/ use original limit as old limit.\n+          old_limit = bol->in(1)->in(1);\n+          \/\/ Adjust previous adjusted limit.\n+          adj_limit = limit->in(CMoveNode::IfFalse);\n+          adj_limit = new (C) SubINode(adj_limit, stride);\n@@ -1312,40 +1341,2 @@\n-          \/\/ (limit - stride) may underflow.\n-          \/\/ Clamp the adjustment value with MININT or MAXINT:\n-          \/\/\n-          \/\/   new_limit = limit-stride\n-          \/\/   if (stride > 0)\n-          \/\/     new_limit = (limit < new_limit) ? MININT : new_limit;\n-          \/\/   else\n-          \/\/     new_limit = (limit > new_limit) ? MAXINT : new_limit;\n-          \/\/\n-          BoolTest::mask bt = loop_end->test_trip();\n-          assert(bt == BoolTest::lt || bt == BoolTest::gt, \"canonical test is expected\");\n-          Node* adj_max = _igvn.intcon((stride_con > 0) ? min_jint : max_jint);\n-          set_ctrl(adj_max, C->root());\n-          Node* old_limit = NULL;\n-          Node* adj_limit = NULL;\n-          Node* bol = limit->is_CMove() ? limit->in(CMoveNode::Condition) : NULL;\n-          if (loop_head->unrolled_count() > 1 &&\n-              limit->is_CMove() && limit->Opcode() == Op_CMoveI &&\n-              limit->in(CMoveNode::IfTrue) == adj_max &&\n-              bol->as_Bool()->_test._test == bt &&\n-              bol->in(1)->Opcode() == Op_CmpI &&\n-              bol->in(1)->in(2) == limit->in(CMoveNode::IfFalse)) {\n-            \/\/ Loop was unrolled before.\n-            \/\/ Optimize the limit to avoid nested CMove:\n-            \/\/ use original limit as old limit.\n-            old_limit = bol->in(1)->in(1);\n-            \/\/ Adjust previous adjusted limit.\n-            adj_limit = limit->in(CMoveNode::IfFalse);\n-            adj_limit = new (C) SubINode(adj_limit, stride);\n-          } else {\n-            old_limit = limit;\n-            adj_limit = new (C) SubINode(limit, stride);\n-          }\n-          assert(old_limit != NULL && adj_limit != NULL, \"\");\n-          register_new_node( adj_limit, ctrl ); \/\/ adjust amount\n-          Node* adj_cmp = new (C) CmpINode(old_limit, adj_limit);\n-          register_new_node( adj_cmp, ctrl );\n-          Node* adj_bool = new (C) BoolNode(adj_cmp, bt);\n-          register_new_node( adj_bool, ctrl );\n-          new_limit = new (C) CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);\n+          old_limit = limit;\n+          adj_limit = new (C) SubINode(limit, stride);\n@@ -1353,20 +1344,7 @@\n-        register_new_node(new_limit, ctrl);\n-      }\n-      assert(new_limit != NULL, \"\");\n-      \/\/ Replace in loop test.\n-      assert(loop_end->in(1)->in(1) == cmp, \"sanity\");\n-      if (cmp->outcnt() == 1 && loop_end->in(1)->outcnt() == 1) {\n-        \/\/ Don't need to create new test since only one user.\n-        _igvn.hash_delete(cmp);\n-        cmp->set_req(2, new_limit);\n-      } else {\n-        \/\/ Create new test since it is shared.\n-        Node* ctrl2 = loop_end->in(0);\n-        Node* cmp2  = cmp->clone();\n-        cmp2->set_req(2, new_limit);\n-        register_new_node(cmp2, ctrl2);\n-        Node* bol2 = loop_end->in(1)->clone();\n-        bol2->set_req(1, cmp2);\n-        register_new_node(bol2, ctrl2);\n-        _igvn.hash_delete(loop_end);\n-        loop_end->set_req(1, bol2);\n+        assert(old_limit != NULL && adj_limit != NULL, \"\");\n+        register_new_node( adj_limit, ctrl ); \/\/ adjust amount\n+        Node* adj_cmp = new (C) CmpINode(old_limit, adj_limit);\n+        register_new_node( adj_cmp, ctrl );\n+        Node* adj_bool = new (C) BoolNode(adj_cmp, bt);\n+        register_new_node( adj_bool, ctrl );\n+        new_limit = new (C) CMoveINode(adj_bool, adj_limit, adj_max, TypeInt::INT);\n@@ -1374,9 +1352,20 @@\n-      \/\/ Step 3: Find the min-trip test guaranteed before a 'main' loop.\n-      \/\/ Make it a 1-trip test (means at least 2 trips).\n-\n-      \/\/ Guard test uses an 'opaque' node which is not shared.  Hence I\n-      \/\/ can edit it's inputs directly.  Hammer in the new limit for the\n-      \/\/ minimum-trip guard.\n-      assert(opaq->outcnt() == 1, \"\");\n-      _igvn.hash_delete(opaq);\n-      opaq->set_req(1, new_limit);\n+      register_new_node(new_limit, ctrl);\n+    }\n+    assert(new_limit != NULL, \"\");\n+    \/\/ Replace in loop test.\n+    assert(loop_end->in(1)->in(1) == cmp, \"sanity\");\n+    if (cmp->outcnt() == 1 && loop_end->in(1)->outcnt() == 1) {\n+      \/\/ Don't need to create new test since only one user.\n+      _igvn.hash_delete(cmp);\n+      cmp->set_req(2, new_limit);\n+    } else {\n+      \/\/ Create new test since it is shared.\n+      Node* ctrl2 = loop_end->in(0);\n+      Node* cmp2  = cmp->clone();\n+      cmp2->set_req(2, new_limit);\n+      register_new_node(cmp2, ctrl2);\n+      Node* bol2 = loop_end->in(1)->clone();\n+      bol2->set_req(1, cmp2);\n+      register_new_node(bol2, ctrl2);\n+      _igvn.hash_delete(loop_end);\n+      loop_end->set_req(1, bol2);\n@@ -1384,51 +1373,0 @@\n-\n-    \/\/ Adjust max trip count. The trip count is intentionally rounded\n-    \/\/ down here (e.g. 15-> 7-> 3-> 1) because if we unwittingly over-unroll,\n-    \/\/ the main, unrolled, part of the loop will never execute as it is protected\n-    \/\/ by the min-trip test.  See bug 4834191 for a case where we over-unrolled\n-    \/\/ and later determined that part of the unrolled loop was dead.\n-    loop_head->set_trip_count(old_trip_count \/ 2);\n-\n-    \/\/ Double the count of original iterations in the unrolled loop body.\n-    loop_head->double_unrolled_count();\n-\n-  } else { \/\/ LoopLimitCheck\n-\n-    \/\/ Adjust max trip count. The trip count is intentionally rounded\n-    \/\/ down here (e.g. 15-> 7-> 3-> 1) because if we unwittingly over-unroll,\n-    \/\/ the main, unrolled, part of the loop will never execute as it is protected\n-    \/\/ by the min-trip test.  See bug 4834191 for a case where we over-unrolled\n-    \/\/ and later determined that part of the unrolled loop was dead.\n-    loop_head->set_trip_count(loop_head->trip_count() \/ 2);\n-\n-    \/\/ Double the count of original iterations in the unrolled loop body.\n-    loop_head->double_unrolled_count();\n-\n-    \/\/ -----------\n-    \/\/ Step 2: Cut back the trip counter for an unroll amount of 2.\n-    \/\/ Loop will normally trip (limit - init)\/stride_con.  Since it's a\n-    \/\/ CountedLoop this is exact (stride divides limit-init exactly).\n-    \/\/ We are going to double the loop body, so we want to knock off any\n-    \/\/ odd iteration: (trip_cnt & ~1).  Then back compute a new limit.\n-    Node *span = new (C) SubINode( limit, init );\n-    register_new_node( span, ctrl );\n-    Node *trip = new (C) DivINode( 0, span, stride );\n-    register_new_node( trip, ctrl );\n-    Node *mtwo = _igvn.intcon(-2);\n-    set_ctrl(mtwo, C->root());\n-    Node *rond = new (C) AndINode( trip, mtwo );\n-    register_new_node( rond, ctrl );\n-    Node *spn2 = new (C) MulINode( rond, stride );\n-    register_new_node( spn2, ctrl );\n-    new_limit = new (C) AddINode( spn2, init );\n-    register_new_node( new_limit, ctrl );\n-\n-    \/\/ Hammer in the new limit\n-    Node *ctrl2 = loop_end->in(0);\n-    Node *cmp2 = new (C) CmpINode( loop_head->incr(), new_limit );\n-    register_new_node( cmp2, ctrl2 );\n-    Node *bol2 = new (C) BoolNode( cmp2, loop_end->test_trip() );\n-    register_new_node( bol2, ctrl2 );\n-    _igvn.hash_delete(loop_end);\n-    loop_end->set_req(CountedLoopEndNode::TestValue, bol2);\n-\n@@ -1437,10 +1375,18 @@\n-    if( adjust_min_trip ) {\n-      assert( new_limit != NULL, \"\" );\n-      \/\/ Guard test uses an 'opaque' node which is not shared.  Hence I\n-      \/\/ can edit it's inputs directly.  Hammer in the new limit for the\n-      \/\/ minimum-trip guard.\n-      assert( opaq->outcnt() == 1, \"\" );\n-      _igvn.hash_delete(opaq);\n-      opaq->set_req(1, new_limit);\n-    }\n-  } \/\/ LoopLimitCheck\n+\n+    \/\/ Guard test uses an 'opaque' node which is not shared.  Hence I\n+    \/\/ can edit it's inputs directly.  Hammer in the new limit for the\n+    \/\/ minimum-trip guard.\n+    assert(opaq->outcnt() == 1, \"\");\n+    _igvn.hash_delete(opaq);\n+    opaq->set_req(1, new_limit);\n+  }\n+\n+  \/\/ Adjust max trip count. The trip count is intentionally rounded\n+  \/\/ down here (e.g. 15-> 7-> 3-> 1) because if we unwittingly over-unroll,\n+  \/\/ the main, unrolled, part of the loop will never execute as it is protected\n+  \/\/ by the min-trip test.  See bug 4834191 for a case where we over-unrolled\n+  \/\/ and later determined that part of the unrolled loop was dead.\n+  loop_head->set_trip_count(old_trip_count \/ 2);\n+\n+  \/\/ Double the count of original iterations in the unrolled loop body.\n+  loop_head->double_unrolled_count();\n@@ -1987,19 +1933,0 @@\n-  if (!LoopLimitCheck && stride_con != 1 && stride_con != -1) { \/\/ Cutout for common case\n-    \/\/ \"Standard\" round-up logic:  ([main_limit-init+(y-1)]\/y)*y+init\n-    \/\/ Hopefully, compiler will optimize for powers of 2.\n-    Node *ctrl = get_ctrl(main_limit);\n-    Node *stride = cl->stride();\n-    Node *init = cl->init_trip();\n-    Node *span = new (C) SubINode(main_limit,init);\n-    register_new_node(span,ctrl);\n-    Node *rndup = _igvn.intcon(stride_con + ((stride_con>0)?-1:1));\n-    Node *add = new (C) AddINode(span,rndup);\n-    register_new_node(add,ctrl);\n-    Node *div = new (C) DivINode(0,add,stride);\n-    register_new_node(div,ctrl);\n-    Node *mul = new (C) MulINode(div,stride);\n-    register_new_node(mul,ctrl);\n-    Node *newlim = new (C) AddINode(mul,init);\n-    register_new_node(newlim,ctrl);\n-    main_limit = newlim;\n-  }\n","filename":"hotspot\/src\/share\/vm\/opto\/loopTransform.cpp","additions":144,"deletions":217,"binary":false,"changes":361,"status":"modified"},{"patch":"@@ -133,1 +133,1 @@\n-  if (predicate != NULL && LoopLimitCheck && UseLoopPredicate) {\n+  if (predicate != NULL && UseLoopPredicate) {\n","filename":"hotspot\/src\/share\/vm\/opto\/loopUnswitch.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -468,1 +468,0 @@\n-  if (LoopLimitCheck) {\n@@ -599,96 +598,0 @@\n-  } else { \/\/ LoopLimitCheck\n-\n-  \/\/ If compare points to incr, we are ok.  Otherwise the compare\n-  \/\/ can directly point to the phi; in this case adjust the compare so that\n-  \/\/ it points to the incr by adjusting the limit.\n-  if (cmp->in(1) == phi || cmp->in(2) == phi)\n-    limit = gvn->transform(new (C) AddINode(limit,stride));\n-\n-  \/\/ trip-count for +-tive stride should be: (limit - init_trip + stride - 1)\/stride.\n-  \/\/ Final value for iterator should be: trip_count * stride + init_trip.\n-  Node *one_p = gvn->intcon( 1);\n-  Node *one_m = gvn->intcon(-1);\n-\n-  Node *trip_count = NULL;\n-  switch( bt ) {\n-  case BoolTest::eq:\n-    ShouldNotReachHere();\n-  case BoolTest::ne:            \/\/ Ahh, the case we desire\n-    if (stride_con == 1)\n-      trip_count = gvn->transform(new (C) SubINode(limit,init_trip));\n-    else if (stride_con == -1)\n-      trip_count = gvn->transform(new (C) SubINode(init_trip,limit));\n-    else\n-      ShouldNotReachHere();\n-    set_subtree_ctrl(trip_count);\n-    \/\/_loop.map(trip_count->_idx,loop(limit));\n-    break;\n-  case BoolTest::le:            \/\/ Maybe convert to '<' case\n-    limit = gvn->transform(new (C) AddINode(limit,one_p));\n-    set_subtree_ctrl( limit );\n-    hook->init_req(4, limit);\n-\n-    bt = BoolTest::lt;\n-    \/\/ Make the new limit be in the same loop nest as the old limit\n-    \/\/_loop.map(limit->_idx,limit_loop);\n-    \/\/ Fall into next case\n-  case BoolTest::lt: {          \/\/ Maybe convert to '!=' case\n-    if (stride_con < 0) \/\/ Count down loop rolls through MAXINT\n-      ShouldNotReachHere();\n-    Node *range = gvn->transform(new (C) SubINode(limit,init_trip));\n-    set_subtree_ctrl( range );\n-    hook->init_req(0, range);\n-\n-    Node *bias  = gvn->transform(new (C) AddINode(range,stride));\n-    set_subtree_ctrl( bias );\n-    hook->init_req(1, bias);\n-\n-    Node *bias1 = gvn->transform(new (C) AddINode(bias,one_m));\n-    set_subtree_ctrl( bias1 );\n-    hook->init_req(2, bias1);\n-\n-    trip_count  = gvn->transform(new (C) DivINode(0,bias1,stride));\n-    set_subtree_ctrl( trip_count );\n-    hook->init_req(3, trip_count);\n-    break;\n-  }\n-\n-  case BoolTest::ge:            \/\/ Maybe convert to '>' case\n-    limit = gvn->transform(new (C) AddINode(limit,one_m));\n-    set_subtree_ctrl( limit );\n-    hook->init_req(4 ,limit);\n-\n-    bt = BoolTest::gt;\n-    \/\/ Make the new limit be in the same loop nest as the old limit\n-    \/\/_loop.map(limit->_idx,limit_loop);\n-    \/\/ Fall into next case\n-  case BoolTest::gt: {          \/\/ Maybe convert to '!=' case\n-    if (stride_con > 0) \/\/ count up loop rolls through MININT\n-      ShouldNotReachHere();\n-    Node *range = gvn->transform(new (C) SubINode(limit,init_trip));\n-    set_subtree_ctrl( range );\n-    hook->init_req(0, range);\n-\n-    Node *bias  = gvn->transform(new (C) AddINode(range,stride));\n-    set_subtree_ctrl( bias );\n-    hook->init_req(1, bias);\n-\n-    Node *bias1 = gvn->transform(new (C) AddINode(bias,one_p));\n-    set_subtree_ctrl( bias1 );\n-    hook->init_req(2, bias1);\n-\n-    trip_count  = gvn->transform(new (C) DivINode(0,bias1,stride));\n-    set_subtree_ctrl( trip_count );\n-    hook->init_req(3, trip_count);\n-    break;\n-  }\n-  } \/\/ switch( bt )\n-\n-  Node *span = gvn->transform(new (C) MulINode(trip_count,stride));\n-  set_subtree_ctrl( span );\n-  hook->init_req(5, span);\n-\n-  limit = gvn->transform(new (C) AddINode(span,init_trip));\n-  set_subtree_ctrl( limit );\n-\n-  } \/\/ LoopLimitCheck\n@@ -830,1 +733,1 @@\n-  if (!LoopLimitCheck || ABS(cl->stride_con()) == 1 ||\n+  if (ABS(cl->stride_con()) == 1 ||\n@@ -1911,6 +1814,4 @@\n-  if (LoopLimitCheck) {\n-    Node* predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n-    if (predicate != NULL ) {\n-      tty->print(\" limit_check\");\n-      entry = entry->in(0)->in(0);\n-    }\n+  Node* predicate = PhaseIdealLoop::find_predicate_insertion_point(entry, Deoptimization::Reason_loop_limit_check);\n+  if (predicate != NULL ) {\n+    tty->print(\" limit_check\");\n+    entry = entry->in(0)->in(0);\n@@ -2336,1 +2237,1 @@\n-  if (UseLoopPredicate || LoopLimitCheck) {\n+  if (UseLoopPredicate) {\n","filename":"hotspot\/src\/share\/vm\/opto\/loopnode.cpp","additions":6,"deletions":105,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -652,2 +652,1 @@\n-        if (block->is_SEL_head() &&\n-            (UseLoopPredicate || LoopLimitCheck)) {\n+        if (block->is_SEL_head() && UseLoopPredicate) {\n","filename":"hotspot\/src\/share\/vm\/opto\/parse1.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}