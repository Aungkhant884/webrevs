{"files":[{"patch":"@@ -466,1 +466,1 @@\n-      ciType* t = c->value()->as_instance()->java_mirror_type();\n+      ciType* t = c->value()->java_mirror_type();\n@@ -482,0 +482,11 @@\n+  case vmIntrinsics::_isPrimitive        : {\n+    assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+    \/\/ Class.isPrimitive is known on constant classes:\n+    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n+    if (c != NULL && !c->value()->is_null_object()) {\n+      ciType* t = c->value()->java_mirror_type();\n+      set_constant(t->is_primitive_type());\n+    }\n+    break;\n+  }\n","filename":"hotspot\/src\/share\/vm\/c1\/c1_Canonicalizer.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3517,0 +3517,1 @@\n+    case vmIntrinsics::_isPrimitive   :\n","filename":"hotspot\/src\/share\/vm\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1293,0 +1293,18 @@\n+\/\/ java.lang.Class::isPrimitive()\n+void LIRGenerator::do_isPrimitive(Intrinsic* x) {\n+  assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+  LIRItem rcvr(x->argument_at(0), this);\n+  rcvr.load_item();\n+  LIR_Opr temp = new_register(T_METADATA);\n+  LIR_Opr result = rlock_result(x);\n+\n+  CodeEmitInfo* info = NULL;\n+  if (x->needs_null_check()) {\n+    info = state_for(x);\n+  }\n+\n+  __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), temp, info);\n+  __ cmp(lir_cond_notEqual, temp, LIR_OprFact::intConst(0));\n+  __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);\n+}\n@@ -3190,0 +3208,1 @@\n+  case vmIntrinsics::_isPrimitive:    do_isPrimitive(x);   break;\n","filename":"hotspot\/src\/share\/vm\/c1\/c1_LIRGenerator.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -245,0 +245,1 @@\n+  void do_isPrimitive(Intrinsic* x);\n","filename":"hotspot\/src\/share\/vm\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8150669\n+ * @summary C1 intrinsic for Class.isPrimitive\n+ *\n+ * @run main\/othervm -ea -Diters=200   -Xint                   TestIsPrimitive\n+ * @run main\/othervm -ea -Diters=30000 -XX:TieredStopAtLevel=1 TestIsPrimitive\n+ * @run main\/othervm -ea -Diters=30000 -XX:TieredStopAtLevel=4 TestIsPrimitive\n+ *\/\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Array;\n+import java.util.concurrent.Callable;\n+\n+public class TestIsPrimitive {\n+    static final int ITERS = Integer.getInteger(\"iters\", 1);\n+\n+    public static void main(String... args) throws Exception {\n+        testOK(true,  InlineConstants::testBoolean);\n+        testOK(true,  InlineConstants::testByte);\n+        testOK(true,  InlineConstants::testShort);\n+        testOK(true,  InlineConstants::testChar);\n+        testOK(true,  InlineConstants::testInt);\n+        testOK(true,  InlineConstants::testFloat);\n+        testOK(true,  InlineConstants::testLong);\n+        testOK(true,  InlineConstants::testDouble);\n+        testOK(false, InlineConstants::testObject);\n+        testOK(false, InlineConstants::testArray);\n+\n+        testOK(true,  StaticConstants::testBoolean);\n+        testOK(true,  StaticConstants::testByte);\n+        testOK(true,  StaticConstants::testShort);\n+        testOK(true,  StaticConstants::testChar);\n+        testOK(true,  StaticConstants::testInt);\n+        testOK(true,  StaticConstants::testFloat);\n+        testOK(true,  StaticConstants::testLong);\n+        testOK(true,  StaticConstants::testDouble);\n+        testOK(false, StaticConstants::testObject);\n+        testOK(false, StaticConstants::testArray);\n+        testNPE(      StaticConstants::testNull);\n+\n+        testOK(true,  NoConstants::testBoolean);\n+        testOK(true,  NoConstants::testByte);\n+        testOK(true,  NoConstants::testShort);\n+        testOK(true,  NoConstants::testChar);\n+        testOK(true,  NoConstants::testInt);\n+        testOK(true,  NoConstants::testFloat);\n+        testOK(true,  NoConstants::testLong);\n+        testOK(true,  NoConstants::testDouble);\n+        testOK(false, NoConstants::testObject);\n+        testOK(false, NoConstants::testArray);\n+        testNPE(      NoConstants::testNull);\n+    }\n+\n+    public static void testOK(boolean expected, Callable<Object> test) throws Exception {\n+        for (int c = 0; c < ITERS; c++) {\n+            Object res = test.call();\n+            if (!res.equals(expected)) {\n+                throw new IllegalStateException(\"Wrong result: expected = \" + expected + \", but got \" + res);\n+            }\n+        }\n+    }\n+\n+    static volatile Object sink;\n+\n+    public static void testNPE(Callable<Object> test) throws Exception {\n+        for (int c = 0; c < ITERS; c++) {\n+            try {\n+               sink = test.call();\n+               throw new IllegalStateException(\"Expected NPE\");\n+            } catch (NullPointerException iae) {\n+               \/\/ expected\n+            }\n+        }\n+    }\n+\n+    static volatile Class<?> classBoolean = boolean.class;\n+    static volatile Class<?> classByte    = byte.class;\n+    static volatile Class<?> classShort   = short.class;\n+    static volatile Class<?> classChar    = char.class;\n+    static volatile Class<?> classInt     = int.class;\n+    static volatile Class<?> classFloat   = float.class;\n+    static volatile Class<?> classLong    = long.class;\n+    static volatile Class<?> classDouble  = double.class;\n+    static volatile Class<?> classObject  = Object.class;\n+    static volatile Class<?> classArray   = Object[].class;\n+    static volatile Class<?> classNull    = null;\n+\n+    static final Class<?> staticClassBoolean = boolean.class;\n+    static final Class<?> staticClassByte    = byte.class;\n+    static final Class<?> staticClassShort   = short.class;\n+    static final Class<?> staticClassChar    = char.class;\n+    static final Class<?> staticClassInt     = int.class;\n+    static final Class<?> staticClassFloat   = float.class;\n+    static final Class<?> staticClassLong    = long.class;\n+    static final Class<?> staticClassDouble  = double.class;\n+    static final Class<?> staticClassObject  = Object.class;\n+    static final Class<?> staticClassArray   = Object[].class;\n+    static final Class<?> staticClassNull    = null;\n+\n+    static class InlineConstants {\n+        static boolean testBoolean() { return boolean.class.isPrimitive();  }\n+        static boolean testByte()    { return byte.class.isPrimitive();     }\n+        static boolean testShort()   { return short.class.isPrimitive();    }\n+        static boolean testChar()    { return char.class.isPrimitive();     }\n+        static boolean testInt()     { return int.class.isPrimitive();      }\n+        static boolean testFloat()   { return float.class.isPrimitive();    }\n+        static boolean testLong()    { return long.class.isPrimitive();     }\n+        static boolean testDouble()  { return double.class.isPrimitive();   }\n+        static boolean testObject()  { return Object.class.isPrimitive();   }\n+        static boolean testArray()   { return Object[].class.isPrimitive(); }\n+    }\n+\n+    static class StaticConstants {\n+        static boolean testBoolean() { return staticClassBoolean.isPrimitive(); }\n+        static boolean testByte()    { return staticClassByte.isPrimitive();    }\n+        static boolean testShort()   { return staticClassShort.isPrimitive();   }\n+        static boolean testChar()    { return staticClassChar.isPrimitive();    }\n+        static boolean testInt()     { return staticClassInt.isPrimitive();     }\n+        static boolean testFloat()   { return staticClassFloat.isPrimitive();   }\n+        static boolean testLong()    { return staticClassLong.isPrimitive();    }\n+        static boolean testDouble()  { return staticClassDouble.isPrimitive();  }\n+        static boolean testObject()  { return staticClassObject.isPrimitive();  }\n+        static boolean testArray()   { return staticClassArray.isPrimitive();   }\n+        static boolean testNull()    { return staticClassNull.isPrimitive();    }\n+    }\n+\n+    static class NoConstants {\n+        static boolean testBoolean() { return classBoolean.isPrimitive(); }\n+        static boolean testByte()    { return classByte.isPrimitive();    }\n+        static boolean testShort()   { return classShort.isPrimitive();   }\n+        static boolean testChar()    { return classChar.isPrimitive();    }\n+        static boolean testInt()     { return classInt.isPrimitive();     }\n+        static boolean testFloat()   { return classFloat.isPrimitive();   }\n+        static boolean testLong()    { return classLong.isPrimitive();    }\n+        static boolean testDouble()  { return classDouble.isPrimitive();  }\n+        static boolean testObject()  { return classObject.isPrimitive();  }\n+        static boolean testArray()   { return classArray.isPrimitive();   }\n+        static boolean testNull()    { return classNull.isPrimitive();    }\n+    }\n+\n+}\n+\n","filename":"hotspot\/test\/compiler\/intrinsics\/klass\/TestIsPrimitive.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"}]}