{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import com.sun.org.apache.xml.internal.serializer.ToStream;\n@@ -47,1 +48,0 @@\n-import java.util.Vector;\n@@ -78,1 +78,1 @@\n-    public Vector _cdata = null;\n+    public ArrayList<String> _cdata = null;\n@@ -652,1 +652,1 @@\n-            _cdata = new Vector();\n+            _cdata = new ArrayList<>();\n@@ -660,2 +660,2 @@\n-            _cdata.addElement(uri);\n-            _cdata.addElement(localName);\n+            _cdata.add(uri);\n+            _cdata.add(localName);\n@@ -663,2 +663,2 @@\n-            _cdata.addElement(null);\n-            _cdata.addElement(name);\n+            _cdata.add(null);\n+            _cdata.add(name);\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/runtime\/AbstractTranslet.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+import java.util.ArrayList;\n@@ -61,1 +62,0 @@\n-import java.util.Vector;\n@@ -1049,1 +1049,1 @@\n-                    Vector uriAndLocalNames = null;\n+                    ArrayList<String> uriAndLocalNames = null;\n@@ -1069,1 +1069,1 @@\n-                            uriAndLocalNames = new Vector();\n+                            uriAndLocalNames = new ArrayList<>();\n@@ -1072,2 +1072,2 @@\n-                        uriAndLocalNames.addElement(uri);\n-                        uriAndLocalNames.addElement(localName);\n+                        uriAndLocalNames.add(uri);\n+                        uriAndLocalNames.add(localName);\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xalan\/internal\/xsltc\/trax\/TransformerImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -560,2 +560,4 @@\n-            if (!fTokenNames.containsValue(tokenStr)) {\n-                Integer tokenInt = new Integer(fTokenNames.size());\n+            String str = fTokenNames.get(tokenStr);\n+            Integer tokenInt = str == null ? null : Integer.parseInt(str);\n+            if (tokenInt == null) {\n+                tokenInt = new Integer(fTokenNames.size());\n@@ -563,1 +565,0 @@\n-                addToken(tokenInt.intValue());\n@@ -565,0 +566,1 @@\n+            addToken(tokenInt.intValue());\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xerces\/internal\/xpointer\/ElementSchemePointer.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -527,2 +527,4 @@\n-            if (!fTokenNames.containsValue(tokenStr)) {\n-                Integer tokenInt = new Integer(fTokenNames.size());\n+            String str = fTokenNames.get(tokenStr);\n+            Integer tokenInt = str == null ? null : Integer.parseInt(str);\n+            if (tokenInt == null) {\n+                tokenInt = new Integer(fTokenNames.size());\n@@ -530,1 +532,0 @@\n-                addToken(tokenInt.intValue());\n@@ -532,0 +533,1 @@\n+            addToken(tokenInt.intValue());\n@@ -1254,1 +1256,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xerces\/internal\/xpointer\/XPointerHandler.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.ArrayList;\n@@ -29,1 +30,0 @@\n-import java.util.Vector;\n@@ -146,1 +146,1 @@\n-     * @see SerializationHandler#setCdataSectionElements(java.util.Vector)\n+     * @see SerializationHandler#setCdataSectionElements(java.util.ArrayList<String>)\n@@ -148,1 +148,1 @@\n-    public void setCdataSectionElements(Vector URI_and_localNames)\n+    public void setCdataSectionElements(ArrayList<String> URI_and_localNames)\n@@ -752,0 +752,21 @@\n+\n+\n+    public String getOutputProperty(String name) {\n+        aMethodIsCalled();\n+        return null;\n+    }\n+\n+    public String getOutputPropertyDefault(String name) {\n+        aMethodIsCalled();\n+        return null;\n+    }\n+\n+    public void setOutputProperty(String name, String val) {\n+        aMethodIsCalled();\n+\n+    }\n+\n+    public void setOutputPropertyDefault(String name, String val) {\n+        aMethodIsCalled();\n+\n+    }\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/EmptySerializer.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2001-2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -26,1 +28,3 @@\n-import java.util.Vector;\n+import java.util.HashMap;\n+import java.util.Set;\n+import java.util.ArrayList;\n@@ -28,0 +32,1 @@\n+import javax.xml.transform.OutputKeys;\n@@ -111,1 +116,1 @@\n-    private String m_doctypeSystem;\n+    protected String m_doctypeSystem;\n@@ -116,1 +121,1 @@\n-    private String m_doctypePublic;\n+    protected String m_doctypePublic;\n@@ -124,6 +129,0 @@\n-    \/**\n-     * The character encoding.  Must match the encoding used for the\n-     * printWriter.\n-     *\/\n-    private String m_encoding = null;\n-\n@@ -133,1 +132,1 @@\n-    private boolean m_shouldNotWriteXMLHeader = false;\n+    protected boolean m_shouldNotWriteXMLHeader = false;\n@@ -162,1 +161,1 @@\n-    private String m_version = null;\n+    protected String m_version = null;\n@@ -167,1 +166,1 @@\n-    private String m_mediatype;\n+    protected String m_mediatype;\n@@ -175,7 +174,0 @@\n-    \/**\n-     * Pairs of local names and corresponding URIs of CDATA sections. This list\n-     * comes from the cdata-section-elements attribute. Every second one is a\n-     * local name, and every other second one is the URI for the local name.\n-     *\/\n-    protected Vector m_cdataSectionElements = null;\n-\n@@ -541,1 +533,1 @@\n-        return m_encoding;\n+        return getOutputProperty(OutputKeys.ENCODING);\n@@ -548,1 +540,1 @@\n-    public void setEncoding(String m_encoding)\n+    public void setEncoding(String encoding)\n@@ -550,1 +542,1 @@\n-        this.m_encoding = m_encoding;\n+        setOutputProperty(OutputKeys.ENCODING,encoding);\n@@ -560,1 +552,2 @@\n-        this.m_shouldNotWriteXMLHeader = b;\n+        String val = b ? \"yes\":\"no\";\n+        setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,val);\n@@ -591,1 +584,1 @@\n-        this.m_doctypePublic = doctypePublic;\n+        setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n@@ -613,1 +606,1 @@\n-        this.m_doctypeSystem = doctypeSystem;\n+        setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n@@ -624,2 +617,2 @@\n-        this.m_doctypeSystem = doctypeSystem;\n-        this.m_doctypePublic = doctypePublic;\n+        setOutputProperty(OutputKeys.DOCTYPE_SYSTEM, doctypeSystem);\n+        setOutputProperty(OutputKeys.DOCTYPE_PUBLIC, doctypePublic);\n@@ -637,5 +630,1 @@\n-        if (standalone != null)\n-        {\n-            m_standaloneWasSpecified = true;\n-            setStandaloneInternal(standalone);\n-        }\n+        setOutputProperty(OutputKeys.STANDALONE, standalone);\n@@ -643,0 +632,1 @@\n+\n@@ -703,1 +693,1 @@\n-        m_version = version;\n+        setOutputProperty(OutputKeys.VERSION, version);\n@@ -715,1 +705,1 @@\n-        m_mediatype = mediaType;\n+        setOutputProperty(OutputKeys.MEDIA_TYPE,mediaType);\n@@ -744,1 +734,2 @@\n-        m_doIndent = doIndent;\n+        String val = doIndent ? \"yes\":\"no\";\n+        setOutputProperty(OutputKeys.INDENT,val);\n@@ -789,53 +780,0 @@\n-    \/**\n-     * Push a boolean state based on if the name of the current element\n-     * is found in the list of qnames.  A state is only pushed if\n-     * there were some cdata-section-names were specified.\n-     * <p>\n-     * Hidden parameters are the vector of qualified elements specified in\n-     * cdata-section-names attribute, and the m_cdataSectionStates stack\n-     * onto which whether the current element is in the list is pushed (true or\n-     * false). Other hidden parameters are the current elements namespaceURI,\n-     * localName and qName\n-     *\/\n-    protected boolean isCdataSection()\n-    {\n-\n-        boolean b = false;\n-\n-        if (null != m_cdataSectionElements)\n-        {\n-            if (m_elemContext.m_elementLocalName == null)\n-                m_elemContext.m_elementLocalName =\n-                    getLocalName(m_elemContext.m_elementName);\n-            if (m_elemContext.m_elementURI == null)\n-            {\n-                String prefix = getPrefixPart(m_elemContext.m_elementName);\n-                if (prefix != null)\n-                    m_elemContext.m_elementURI =\n-                        m_prefixMap.lookupNamespace(prefix);\n-\n-            }\n-\n-            if ((null != m_elemContext.m_elementURI)\n-                && m_elemContext.m_elementURI.length() == 0)\n-                m_elemContext.m_elementURI = null;\n-\n-            int nElems = m_cdataSectionElements.size();\n-\n-            \/\/ loop through 2 at a time, as these are pairs of URI and localName\n-            for (int i = 0; i < nElems; i += 2)\n-            {\n-                String uri = (String) m_cdataSectionElements.elementAt(i);\n-                String loc = (String) m_cdataSectionElements.elementAt(i + 1);\n-                if (loc.equals(m_elemContext.m_elementLocalName)\n-                    && subPartMatch(m_elemContext.m_elementURI, uri))\n-                {\n-                    b = true;\n-\n-                    break;\n-                }\n-            }\n-        }\n-        return b;\n-    }\n-\n@@ -1315,1 +1253,1 @@\n-        this.m_cdataSectionElements = null;\n+        this.m_StringOfCDATASections = null;\n@@ -1320,1 +1258,0 @@\n-        this.m_encoding = null;\n@@ -1402,0 +1339,329 @@\n+\n+    \/**\n+     * The CDATA section names stored in a whitespace separateed list with\n+     * each element being a word of the form \"{uri}localName\" This list\n+     * comes from the cdata-section-elements attribute.\n+     *\n+     * This field replaces m_cdataSectionElements Vector.\n+     *\/\n+    protected String m_StringOfCDATASections = null;\n+\n+    boolean m_docIsEmpty = true;\n+    void initCdataElems(String s)\n+    {\n+        if (s != null)\n+        {\n+            int max = s.length();\n+\n+            \/\/ true if we are in the middle of a pair of curly braces that delimit a URI\n+            boolean inCurly = false;\n+\n+            \/\/ true if we found a URI but haven't yet processed the local name\n+            boolean foundURI = false;\n+\n+            StringBuilder buf = new StringBuilder();\n+            String uri = null;\n+            String localName = null;\n+\n+            \/\/ parse through string, breaking on whitespaces.  I do this instead\n+            \/\/ of a tokenizer so I can track whitespace inside of curly brackets,\n+            \/\/ which theoretically shouldn't happen if they contain legal URLs.\n+            for (int i = 0; i < max; i++)\n+            {\n+                char c = s.charAt(i);\n+\n+                if (Character.isWhitespace(c))\n+                {\n+                    if (!inCurly)\n+                    {\n+                        if (buf.length() > 0)\n+                        {\n+                            localName = buf.toString();\n+                            if (!foundURI)\n+                                uri = \"\";\n+                            addCDATAElement(uri,localName);\n+                            buf.setLength(0);\n+                            foundURI = false;\n+                        }\n+                        continue;\n+                    }\n+                    else\n+                        buf.append(c); \/\/ add whitespace to the URI\n+                }\n+                else if ('{' == c) \/\/ starting a URI\n+                    inCurly = true;\n+                else if ('}' == c)\n+                {\n+                    \/\/ we just ended a URI\n+                    foundURI = true;\n+                    uri = buf.toString();\n+                    buf.setLength(0);\n+                    inCurly = false;\n+                }\n+                else\n+                {\n+                    \/\/ append non-whitespace, non-curly to current URI or localName being gathered.\n+                    buf.append(c);\n+                }\n+\n+            }\n+\n+            if (buf.length() > 0)\n+            {\n+                \/\/ We have one last localName to process.\n+                localName = buf.toString();\n+                if (!foundURI)\n+                    uri = \"\";\n+                addCDATAElement(uri,localName);\n+            }\n+        }\n+    }\n+\n+    protected java.util.HashMap<String, HashMap<String, String>> m_CdataElems = null;\n+    private void addCDATAElement(String uri, String localName)\n+    {\n+        if (m_CdataElems == null) {\n+            m_CdataElems = new java.util.HashMap<>();\n+        }\n+\n+        HashMap<String,String> h = m_CdataElems.get(localName);\n+        if (h == null) {\n+            h = new HashMap<>();\n+            m_CdataElems.put(localName,h);\n+        }\n+        h.put(uri,uri);\n+\n+    }\n+\n+\n+    \/**\n+     * Return true if nothing has been sent to this result tree yet.\n+     * <p>\n+     * This is not a public API.\n+     *\n+     * @xsl.usage internal\n+     *\/\n+    public boolean documentIsEmpty() {\n+        \/\/ If we haven't called startDocument() yet, then this document is empty\n+        return m_docIsEmpty && (m_elemContext.m_currentElemDepth == 0);\n+    }\n+\n+    \/**\n+     * Return true if the current element in m_elemContext\n+     * is a CDATA section.\n+     * CDATA sections are specified in the <xsl:output> attribute\n+     * cdata-section-names or in the JAXP equivalent property.\n+     * In any case the format of the value of such a property is:\n+     * <pre>\n+     * \"{uri1}localName1 {uri2}localName2 . . . \"\n+     * <\/pre>\n+     *\n+     * <p>\n+     * This method is not a public API, but is only used internally by the serializer.\n+     *\/\n+    protected boolean isCdataSection() {\n+        boolean b = false;\n+\n+        if (null != m_StringOfCDATASections) {\n+            if (m_elemContext.m_elementLocalName == null) {\n+                String localName =  getLocalName(m_elemContext.m_elementName);\n+                m_elemContext.m_elementLocalName = localName;\n+            }\n+\n+            if ( m_elemContext.m_elementURI == null) {\n+\n+                m_elemContext.m_elementURI = getElementURI();\n+            }\n+            else if ( m_elemContext.m_elementURI.length() == 0) {\n+                if ( m_elemContext.m_elementName == null) {\n+                    m_elemContext.m_elementName = m_elemContext.m_elementLocalName;\n+                    \/\/ leave URI as \"\", meaning in no namespace\n+                }\n+                else if (m_elemContext.m_elementLocalName.length() < m_elemContext.m_elementName.length()){\n+                    \/\/ We were told the URI was \"\", yet the name has a prefix since the name is longer than the localname.\n+                    \/\/ So we will fix that incorrect information here.\n+                    m_elemContext.m_elementURI = getElementURI();\n+                }\n+            }\n+\n+            HashMap<String, String> h = null;\n+            if (m_CdataElems != null) {\n+                h = m_CdataElems.get(m_elemContext.m_elementLocalName);\n+            }\n+            if (h != null) {\n+                Object obj = h.get(m_elemContext.m_elementURI);\n+                if (obj != null)\n+                    b = true;\n+            }\n+\n+        }\n+        return b;\n+    }\n+\n+    \/**\n+     * Before this call m_elementContext.m_elementURI is null,\n+     * which means it is not yet known. After this call it\n+     * is non-null, but possibly \"\" meaning that it is in the\n+     * default namespace.\n+     *\n+     * @return The URI of the element, never null, but possibly \"\".\n+     *\/\n+    private String getElementURI() {\n+        String uri = null;\n+        \/\/ At this point in processing we have received all the\n+        \/\/ namespace mappings\n+        \/\/ As we still don't know the elements namespace,\n+        \/\/ we now figure it out.\n+\n+        String prefix = getPrefixPart(m_elemContext.m_elementName);\n+\n+        if (prefix == null) {\n+            \/\/ no prefix so lookup the URI of the default namespace\n+            uri = m_prefixMap.lookupNamespace(\"\");\n+        } else {\n+            uri = m_prefixMap.lookupNamespace(prefix);\n+        }\n+        if (uri == null) {\n+            \/\/ We didn't find the namespace for the\n+            \/\/ prefix ... ouch, that shouldn't happen.\n+            \/\/ This is a hack, we really don't know\n+            \/\/ the namespace\n+            uri = EMPTYSTRING;\n+        }\n+\n+        return uri;\n+    }\n+\n+\n+    \/**\n+     * Get the value of an output property,\n+     * the explicit value, if any, otherwise the\n+     * default value, if any, otherwise null.\n+     *\/\n+    public String getOutputProperty(String name) {\n+        String val = getOutputPropertyNonDefault(name);\n+        \/\/ If no explicit value, try to get the default value\n+        if (val == null)\n+            val = getOutputPropertyDefault(name);\n+        return val;\n+\n+    }\n+    \/**\n+     * Get the value of an output property,\n+     * not the default value. If there is a default\n+     * value, but no non-default value this method\n+     * will return null.\n+     * <p>\n+     *\n+     *\/\n+    public String getOutputPropertyNonDefault(String name) {\n+        return getProp(name,false);\n+    }\n+\n+    \/**\n+     * Get the default value of an xsl:output property,\n+     * which would be null only if no default value exists\n+     * for the property.\n+     *\/\n+    public String getOutputPropertyDefault(String name) {\n+        return getProp(name, true);\n+    }\n+\n+    \/**\n+     * Set the value for the output property, typically from\n+     * an xsl:output element, but this does not change what\n+     * the default value is.\n+     *\/\n+    public void setOutputProperty(String name, String val) {\n+        setProp(name,val,false);\n+    }\n+\n+    \/**\n+     * Set the default value for an output property, but this does\n+     * not impact any explicitly set value.\n+     *\/\n+    public void setOutputPropertyDefault(String name, String val) {\n+        setProp(name,val,true);\n+\n+    }\n+\n+    \/**\n+     * A mapping of keys to explicitly set values, for example if\n+     * and <xsl:output\/> has an \"encoding\" attribute, this\n+     * map will have what that attribute maps to.\n+     *\/\n+    private HashMap<String, String> m_OutputProps;\n+    \/**\n+     * A mapping of keys to default values, for example if\n+     * the default value of the encoding is \"UTF-8\" then this\n+     * map will have that \"encoding\" maps to \"UTF-8\".\n+     *\/\n+    private HashMap<String, String> m_OutputPropsDefault;\n+\n+    Set<String> getOutputPropDefaultKeys() {\n+        return m_OutputPropsDefault.keySet();\n+    }\n+    Set<String> getOutputPropKeys() {\n+        return m_OutputProps.keySet();\n+    }\n+\n+    private String getProp(String name, boolean defaultVal) {\n+        if (m_OutputProps == null) {\n+            m_OutputProps = new HashMap<>();\n+            m_OutputPropsDefault = new HashMap<>();\n+        }\n+\n+        String val;\n+        if (defaultVal)\n+            val = m_OutputPropsDefault.get(name);\n+        else\n+            val = m_OutputProps.get(name);\n+\n+        return val;\n+    }\n+    \/**\n+     *\n+     * @param name The name of the property, e.g. \"{http:\/\/myprop}indent-tabs\" or \"indent\".\n+     * @param val The value of the property, e.g. \"4\"\n+     * @param defaultVal true if this is a default value being set for the property as\n+     * opposed to a user define on, set say explicitly in the stylesheet or via JAXP\n+     *\/\n+    void setProp(String name, String val, boolean defaultVal) {\n+        if (m_OutputProps == null) {\n+            m_OutputProps = new HashMap<>();\n+            m_OutputPropsDefault = new HashMap<>();\n+        }\n+\n+        if (defaultVal)\n+            m_OutputPropsDefault.put(name,val);\n+        else {\n+            if (OutputKeys.CDATA_SECTION_ELEMENTS.equals(name) && val != null) {\n+                initCdataElems(val);\n+                String oldVal = m_OutputProps.get(name);\n+                String newVal;\n+                if (oldVal == null)\n+                    newVal = oldVal + ' ' + val;\n+                else\n+                    newVal = val;\n+                m_OutputProps.put(name,newVal);\n+            }\n+            else {\n+                m_OutputProps.put(name,val);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Get the first char of the local name\n+     * @param name Either a local name, or a local name\n+     * preceeded by a uri enclosed in curly braces.\n+     *\/\n+    static char getFirstCharLocName(String name) {\n+        final char first;\n+        int i = name.indexOf('}');\n+        if (i < 0)\n+            first = name.charAt(0);\n+        else\n+            first = name.charAt(i+1);\n+        return first;\n+    }\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/SerializerBase.java","additions":359,"deletions":93,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -5,3 +5,5 @@\n- * Copyright 2001-2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -352,1 +354,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"A\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"a\");\n@@ -357,1 +359,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"AREA\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"area\");\n@@ -362,1 +364,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"BASE\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"base\");\n@@ -366,1 +368,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"BUTTON\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"button\");\n@@ -370,1 +372,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"BLOCKQUOTE\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"blockquote\");\n@@ -374,1 +376,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"DEL\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"del\");\n@@ -378,1 +380,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"DIR\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"dir\");\n@@ -383,1 +385,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"DIV\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"div\");\n@@ -388,1 +390,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"DL\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"dl\");\n@@ -392,1 +394,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"FORM\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"form\");\n@@ -397,1 +399,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"FRAME\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"frame\");\n@@ -403,1 +405,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"HEAD\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"head\");\n@@ -407,1 +409,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"HR\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"hr\");\n@@ -412,1 +414,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"IFRAME\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"iframe\");\n@@ -418,1 +420,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"ILAYER\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"ilayer\");\n@@ -422,1 +424,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"IMG\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"img\");\n@@ -429,1 +431,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"INPUT\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"input\");\n@@ -438,1 +440,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"INS\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"ins\");\n@@ -443,1 +445,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"LAYER\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"layer\");\n@@ -447,1 +449,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"LINK\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"link\");\n@@ -451,1 +453,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"MENU\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"menu\");\n@@ -455,1 +457,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"OBJECT\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"object\");\n@@ -464,1 +466,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"OL\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"ol\");\n@@ -468,1 +470,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"OPTGROUP\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"optgroup\");\n@@ -472,1 +474,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"OPTION\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"option\");\n@@ -477,1 +479,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"Q\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"q\");\n@@ -481,1 +483,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"SCRIPT\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"script\");\n@@ -487,1 +489,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"SELECT\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"select\");\n@@ -492,1 +494,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"TABLE\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"table\");\n@@ -496,1 +498,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"TD\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"td\");\n@@ -500,1 +502,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"TEXTAREA\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"textarea\");\n@@ -505,1 +507,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"TH\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"th\");\n@@ -511,1 +513,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"TR\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"tr\");\n@@ -515,1 +517,1 @@\n-        elemDesc = (ElemDesc) m_elementFlags.get(\"UL\");\n+        elemDesc = (ElemDesc) m_elementFlags.get(\"ul\");\n@@ -1768,1 +1770,1 @@\n-            if (m_cdataSectionElements != null)\n+            if (m_StringOfCDATASections != null)\n@@ -1782,44 +1784,0 @@\n-    \/**\n-     * Initialize the serializer with the specified output stream and output\n-     * format. Must be called before calling any of the serialize methods.\n-     *\n-     * @param output The output stream to use\n-     * @param format The output format\n-     * @throws UnsupportedEncodingException The encoding specified   in the\n-     * output format is not supported\n-     *\/\n-    protected synchronized void init(OutputStream output, Properties format)\n-        throws UnsupportedEncodingException\n-    {\n-        if (null == format)\n-        {\n-            format = OutputPropertiesFactory.getDefaultMethodProperties(Method.HTML);\n-         }\n-        super.init(output,format, false);\n-    }\n-\n-        \/**\n-         * Specifies an output stream to which the document should be\n-         * serialized. This method should not be called while the\n-         * serializer is in the process of serializing a document.\n-         * <p>\n-         * The encoding specified in the output properties is used, or\n-         * if no encoding was specified, the default for the selected\n-         * output method.\n-         *\n-         * @param output The output stream\n-         *\/\n-        public void setOutputStream(OutputStream output)\n-        {\n-\n-            try\n-            {\n-                Properties format;\n-                if (null == m_format)\n-                    format = OutputPropertiesFactory.getDefaultMethodProperties(Method.HTML);\n-                else\n-                    format = m_format;\n-                init(output, format, true);\n-            }\n-            catch (UnsupportedEncodingException uee)\n-            {\n@@ -1827,3 +1785,0 @@\n-                \/\/ Should have been warned in init, I guess...\n-            }\n-        }\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/ToHTMLStream.java","additions":40,"deletions":85,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import java.util.Vector;\n+import java.util.ArrayList;\n@@ -237,1 +237,1 @@\n-     * @see SerializationHandler#setCdataSectionElements(java.util.Vector)\n+     * @see SerializationHandler#setCdataSectionElements(java.util.ArrayList<String>)\n@@ -239,1 +239,1 @@\n-    public void setCdataSectionElements(Vector URI_and_localNames)\n+    public void setCdataSectionElements(ArrayList<String> URI_and_localNames)\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/ToSAXHandler.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5,3 +5,5 @@\n- * Copyright 2001-2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -27,0 +29,1 @@\n+import java.io.OutputStreamWriter;\n@@ -29,0 +32,2 @@\n+import java.util.Enumeration;\n+import java.util.Iterator;\n@@ -30,0 +35,1 @@\n+import java.util.Set;\n@@ -31,1 +37,1 @@\n-import java.util.Vector;\n+import java.util.ArrayList;\n@@ -190,3 +196,0 @@\n-    \/** The xsl:output properties. *\/\n-    protected Properties m_format;\n-\n@@ -311,0 +314,1 @@\n+    OutputStream m_outputStream;\n@@ -319,7 +323,1 @@\n-\n-        if (m_writer instanceof WriterToUTF8Buffered)\n-            return ((WriterToUTF8Buffered) m_writer).getOutputStream();\n-        if (m_writer instanceof WriterToASCI)\n-            return ((WriterToASCI) m_writer).getOutputStream();\n-        else\n-            return null;\n+        return m_outputStream;\n@@ -424,1 +422,0 @@\n-\n@@ -428,0 +425,165 @@\n+    void setProp(String name, String val, boolean defaultVal) {\n+        if (val != null) {\n+\n+            char first = getFirstCharLocName(name);\n+            switch (first) {\n+            case 'c':\n+                if (OutputKeys.CDATA_SECTION_ELEMENTS.equals(name)) {\n+                    addCdataSectionElements(val); \/\/ val is cdataSectionNames\n+                }\n+                break;\n+            case 'd':\n+                if (OutputKeys.DOCTYPE_SYSTEM.equals(name)) {\n+                    this.m_doctypeSystem = val;\n+                } else if (OutputKeys.DOCTYPE_PUBLIC.equals(name)) {\n+                    this.m_doctypePublic = val;\n+                    if (val.startsWith(\"-\/\/W3C\/\/DTD XHTML\"))\n+                        m_spaceBeforeClose = true;\n+                }\n+                break;\n+            case 'e':\n+                String newEncoding = val;\n+                if (OutputKeys.ENCODING.equals(name)) {\n+                    String possible_encoding = Encodings.getMimeEncoding(val);\n+                    if (possible_encoding != null) {\n+                        \/\/ if the encoding is being set, try to get the\n+                        \/\/ preferred\n+                        \/\/ mime-name and set it too.\n+                        super.setProp(\"mime-name\", possible_encoding,\n+                                defaultVal);\n+                    }\n+                    final String oldExplicitEncoding = getOutputPropertyNonDefault(OutputKeys.ENCODING);\n+                    final String oldDefaultEncoding  = getOutputPropertyDefault(OutputKeys.ENCODING);\n+                    if ( (defaultVal && ( oldDefaultEncoding == null || !oldDefaultEncoding.equalsIgnoreCase(newEncoding)))\n+                            || ( !defaultVal && (oldExplicitEncoding == null || !oldExplicitEncoding.equalsIgnoreCase(newEncoding) ))) {\n+                       \/\/ We are trying to change the default or the non-default setting of the encoding to a different value\n+                       \/\/ from what it was\n+\n+                       EncodingInfo encodingInfo = Encodings.getEncodingInfo(newEncoding);\n+                       if (newEncoding != null && encodingInfo.name == null) {\n+                        \/\/ We tried to get an EncodingInfo for Object for the given\n+                        \/\/ encoding, but it came back with an internall null name\n+                        \/\/ so the encoding is not supported by the JDK, issue a message.\n+                        final String msg = Utils.messages.createMessage(\n+                                MsgKey.ER_ENCODING_NOT_SUPPORTED,new Object[]{ newEncoding });\n+\n+                        final String msg2 =\n+                            \"Warning: encoding \\\"\" + newEncoding + \"\\\" not supported, using \"\n+                                   + Encodings.DEFAULT_MIME_ENCODING;\n+                        try {\n+                                \/\/ Prepare to issue the warning message\n+                                final Transformer tran = super.getTransformer();\n+                                if (tran != null) {\n+                                    final ErrorListener errHandler = tran\n+                                            .getErrorListener();\n+                                    \/\/ Issue the warning message\n+                                    if (null != errHandler\n+                                            && m_sourceLocator != null) {\n+                                        errHandler\n+                                                .warning(new TransformerException(\n+                                                        msg, m_sourceLocator));\n+                                        errHandler\n+                                                .warning(new TransformerException(\n+                                                        msg2, m_sourceLocator));\n+                                    } else {\n+                                        System.out.println(msg);\n+                                        System.out.println(msg2);\n+                                    }\n+                                } else {\n+                                    System.out.println(msg);\n+                                    System.out.println(msg2);\n+                                }\n+                            } catch (Exception e) {\n+                            }\n+\n+                            \/\/ We said we are using UTF-8, so use it\n+                            newEncoding = Encodings.DEFAULT_MIME_ENCODING;\n+                            val = Encodings.DEFAULT_MIME_ENCODING; \/\/ to store the modified value into the properties a little later\n+                            encodingInfo = Encodings.getEncodingInfo(newEncoding);\n+                        }\n+                       \/\/ The encoding was good, or was forced to UTF-8 above\n+\n+\n+                       \/\/ If there is already a non-default set encoding and we\n+                       \/\/ are trying to set the default encoding, skip the this block\n+                       \/\/ as the non-default value is already the one to use.\n+                       if (defaultVal == false || oldExplicitEncoding == null) {\n+                           m_encodingInfo = encodingInfo;\n+                           if (newEncoding != null)\n+                               m_isUTF8 = newEncoding.equals(Encodings.DEFAULT_MIME_ENCODING);\n+\n+                           \/\/ if there was a previously set OutputStream\n+                           OutputStream os = getOutputStream();\n+                           if (os != null) {\n+                               Writer w = getWriter();\n+\n+                               \/\/ If the writer was previously set, but\n+                               \/\/ set by the user, or if the new encoding is the same\n+                               \/\/ as the old encoding, skip this block\n+                               String oldEncoding = getOutputProperty(OutputKeys.ENCODING);\n+                               if ((w == null || !m_writer_set_by_user)\n+                                       && !newEncoding.equalsIgnoreCase(oldEncoding)) {\n+                                   \/\/ Make the change of encoding in our internal\n+                                   \/\/ table, then call setOutputStreamInternal\n+                                   \/\/ which will stomp on the old Writer (if any)\n+                                   \/\/ with a new Writer with the new encoding.\n+                                   super.setProp(name, val, defaultVal);\n+                                   setOutputStreamInternal(os,false);\n+                               }\n+                           }\n+                       }\n+                    }\n+                }\n+                break;\n+            case 'i':\n+                if (OutputPropertiesFactory.S_KEY_INDENT_AMOUNT.equals(name)) {\n+                    setIndentAmount(Integer.parseInt(val));\n+                } else if (OutputKeys.INDENT.equals(name)) {\n+                    boolean b = \"yes\".equals(val) ? true : false;\n+                    m_doIndent = b;\n+                }\n+\n+                break;\n+            case 'l':\n+                if (OutputPropertiesFactory.S_KEY_LINE_SEPARATOR.equals(name)) {\n+                    m_lineSep = val.toCharArray();\n+                    m_lineSepLen = m_lineSep.length;\n+                }\n+\n+                break;\n+            case 'm':\n+                if (OutputKeys.MEDIA_TYPE.equals(name)) {\n+                    m_mediatype = val;\n+                }\n+                break;\n+            case 'o':\n+                if (OutputKeys.OMIT_XML_DECLARATION.equals(name)) {\n+                    boolean b = \"yes\".equals(val) ? true : false;\n+                    this.m_shouldNotWriteXMLHeader = b;\n+                }\n+                break;\n+            case 's':\n+                \/\/ if standalone was explicitly specified\n+                if (OutputKeys.STANDALONE.equals(name)) {\n+                    if (defaultVal) {\n+                        setStandaloneInternal(val);\n+                    } else {\n+                        m_standaloneWasSpecified = true;\n+                        setStandaloneInternal(val);\n+                    }\n+                }\n+\n+                break;\n+            case 'v':\n+                if (OutputKeys.VERSION.equals(name)) {\n+                    m_version = val;\n+                }\n+                break;\n+            default:\n+                break;\n+\n+            }\n+            super.setProp(name, val, defaultVal);\n+        }\n+    }\n+\n@@ -439,1 +601,0 @@\n-\n@@ -442,48 +603,1 @@\n-        init(m_writer, format, false, false);\n-\n-        m_shouldFlush = shouldFlush;\n-    }\n-\n-    \/**\n-     * Initialize the serializer with the specified writer and output format.\n-     * Must be called before calling any of the serialize methods.\n-     * This method can be called multiple times and the xsl:output properties\n-     * passed in the 'format' parameter are accumulated across calls.\n-     *\n-     * @param writer The writer to use\n-     * @param format The output format\n-     * @param shouldFlush True if the writer should be flushed at EndDocument.\n-     *\/\n-    private synchronized void init(\n-        Writer writer,\n-        Properties format,\n-        boolean defaultProperties,\n-        boolean shouldFlush)\n-    {\n-\n-        m_shouldFlush = shouldFlush;\n-\n-\n-        \/\/ if we are tracing events we need to trace what\n-        \/\/ characters are written to the output writer.\n-        if (m_tracer != null\n-         && !(writer instanceof SerializerTraceWriter)  )\n-            m_writer = new SerializerTraceWriter(writer, m_tracer);\n-        else\n-            m_writer = writer;\n-\n-\n-        m_format = format;\n-        \/\/        m_cdataSectionNames =\n-        \/\/            OutputProperties.getQNameProperties(\n-        \/\/                OutputKeys.CDATA_SECTION_ELEMENTS,\n-        \/\/                format);\n-        setCdataSectionElements(OutputKeys.CDATA_SECTION_ELEMENTS, format);\n-\n-        setIndentAmount(\n-            OutputPropertyUtils.getIntProperty(\n-                OutputPropertiesFactory.S_KEY_INDENT_AMOUNT,\n-                format));\n-        setIndent(\n-            OutputPropertyUtils.getBooleanProperty(OutputKeys.INDENT, format));\n-\n+        if (format != null)\n@@ -491,5 +605,21 @@\n-            String sep =\n-                    format.getProperty(OutputPropertiesFactory.S_KEY_LINE_SEPARATOR);\n-            if (sep != null) {\n-                m_lineSep = sep.toCharArray();\n-                m_lineSepLen = sep.length();\n+            \/\/ Set the default values first,\n+            \/\/ and the non-default values after that,\n+            \/\/ just in case there is some unexpected\n+            \/\/ residual values left over from over-ridden default values\n+            Enumeration propNames;\n+            propNames = format.propertyNames();\n+            while (propNames.hasMoreElements())\n+            {\n+                String key = (String) propNames.nextElement();\n+                \/\/ Get the value, possibly a default value\n+                String value = format.getProperty(key);\n+                \/\/ Get the non-default value (if any).\n+                String explicitValue = (String) format.get(key);\n+                if (explicitValue == null && value != null) {\n+                    \/\/ This is a default value\n+                    this.setOutputPropertyDefault(key,value);\n+                }\n+                if (explicitValue != null) {\n+                    \/\/ This is an explicit non-default value\n+                    this.setOutputProperty(key,explicitValue);\n+                }\n@@ -499,49 +629,0 @@\n-        boolean shouldNotWriteXMLHeader =\n-            OutputPropertyUtils.getBooleanProperty(\n-                OutputKeys.OMIT_XML_DECLARATION,\n-                format);\n-        setOmitXMLDeclaration(shouldNotWriteXMLHeader);\n-        setDoctypeSystem(format.getProperty(OutputKeys.DOCTYPE_SYSTEM));\n-        String doctypePublic = format.getProperty(OutputKeys.DOCTYPE_PUBLIC);\n-        setDoctypePublic(doctypePublic);\n-\n-        \/\/ if standalone was explicitly specified\n-        if (format.get(OutputKeys.STANDALONE) != null)\n-        {\n-            String val = format.getProperty(OutputKeys.STANDALONE);\n-            if (defaultProperties)\n-                setStandaloneInternal(val);\n-            else\n-                setStandalone(val);\n-        }\n-\n-        setMediaType(format.getProperty(OutputKeys.MEDIA_TYPE));\n-\n-        if (null != doctypePublic)\n-        {\n-            if (doctypePublic.startsWith(\"-\/\/W3C\/\/DTD XHTML\"))\n-                m_spaceBeforeClose = true;\n-        }\n-\n-        \/*\n-         * This code is added for XML 1.1 Version output.\n-         *\/\n-        String version = getVersion();\n-        if (null == version)\n-        {\n-            version = format.getProperty(OutputKeys.VERSION);\n-            setVersion(version);\n-        }\n-\n-        \/\/ initCharsMap();\n-        String encoding = getEncoding();\n-        if (null == encoding)\n-        {\n-            encoding =\n-                Encodings.getMimeEncoding(\n-                    format.getProperty(OutputKeys.ENCODING));\n-            setEncoding(encoding);\n-        }\n-\n-        m_isUTF8 = encoding.equals(Encodings.DEFAULT_MIME_ENCODING);\n-\n@@ -562,1 +643,0 @@\n-    }\n@@ -564,10 +644,3 @@\n-    \/**\n-     * Initialize the serializer with the specified writer and output format.\n-     * Must be called before calling any of the serialize methods.\n-     *\n-     * @param writer The writer to use\n-     * @param format The output format\n-     *\/\n-    private synchronized void init(Writer writer, Properties format)\n-    {\n-        init(writer, format, false, false);\n+\n+\n+        m_shouldFlush = shouldFlush;\n@@ -575,0 +648,1 @@\n+\n@@ -576,7 +650,1 @@\n-     * Initialize the serializer with the specified output stream and output\n-     * format. Must be called before calling any of the serialize methods.\n-     *\n-     * @param output The output stream to use\n-     * @param format The output format\n-     * @param defaultProperties true if the properties are the default\n-     * properties\n+     * Returns the output format for this serializer.\n@@ -584,2 +652,1 @@\n-     * @throws UnsupportedEncodingException The encoding specified   in the\n-     * output format is not supported\n+     * @return The output format in use\n@@ -587,9 +654,2 @@\n-    protected synchronized void init(\n-        OutputStream output,\n-        Properties format,\n-        boolean defaultProperties)\n-        throws UnsupportedEncodingException\n-    {\n-\n-        String encoding = getEncoding();\n-        if (encoding == null)\n+    public Properties getOutputFormat() {\n+        Properties def = new Properties();\n@@ -597,5 +657,5 @@\n-            \/\/ if not already set then get it from the properties\n-            encoding =\n-                Encodings.getMimeEncoding(\n-                    format.getProperty(OutputKeys.ENCODING));\n-            setEncoding(encoding);\n+            Set<String> s = getOutputPropDefaultKeys();\n+            for (String key : s) {\n+                String val = getOutputPropertyDefault(key);\n+                def.put(key, val);\n+            }\n@@ -604,31 +664,1 @@\n-        if (encoding.equalsIgnoreCase(\"UTF-8\"))\n-        {\n-            m_isUTF8 = true;\n-            \/\/            if (output instanceof java.io.BufferedOutputStream)\n-            \/\/            {\n-            \/\/                init(new WriterToUTF8(output), format, defaultProperties, true);\n-            \/\/            }\n-            \/\/            else if (output instanceof java.io.FileOutputStream)\n-            \/\/            {\n-            \/\/                init(new WriterToUTF8Buffered(output), format, defaultProperties, true);\n-            \/\/            }\n-            \/\/            else\n-            \/\/            {\n-            \/\/                \/\/ Not sure what to do in this case.  I'm going to be conservative\n-            \/\/                \/\/ and not buffer.\n-            \/\/                init(new WriterToUTF8(output), format, defaultProperties, true);\n-            \/\/            }\n-\n-\n-                init(\n-                    new WriterToUTF8Buffered(output),\n-                    format,\n-                    defaultProperties,\n-                    true);\n-\n-\n-        }\n-        else if (\n-            encoding.equals(\"WINDOWS-1250\")\n-                || encoding.equals(\"US-ASCII\")\n-                || encoding.equals(\"ASCII\"))\n+        Properties props = new Properties(def);\n@@ -636,22 +666,5 @@\n-            init(new WriterToASCI(output), format, defaultProperties, true);\n-        }\n-        else\n-        {\n-            Writer osw;\n-\n-            try\n-            {\n-                osw = Encodings.getWriter(output, encoding);\n-            }\n-            catch (UnsupportedEncodingException uee)\n-            {\n-                System.out.println(\n-                    \"Warning: encoding \\\"\"\n-                        + encoding\n-                        + \"\\\" not supported\"\n-                        + \", using \"\n-                        + Encodings.DEFAULT_MIME_ENCODING);\n-\n-                encoding = Encodings.DEFAULT_MIME_ENCODING;\n-                setEncoding(encoding);\n-                osw = Encodings.getWriter(output, encoding);\n+            Set<String> s = getOutputPropKeys();\n+            for (String key : s) {\n+                String val = getOutputPropertyNonDefault(key);\n+                if (val != null)\n+                    props.put(key, val);\n@@ -659,2 +672,0 @@\n-\n-            init(osw, format, defaultProperties, true);\n@@ -662,11 +673,1 @@\n-\n-    }\n-\n-    \/**\n-     * Returns the output format for this serializer.\n-     *\n-     * @return The output format in use\n-     *\/\n-    public Properties getOutputFormat()\n-    {\n-        return m_format;\n+        return props;\n@@ -684,0 +685,7 @@\n+        setWriterInternal(writer, true);\n+    }\n+\n+    private boolean m_writer_set_by_user;\n+    private void setWriterInternal(Writer writer, boolean setByUser) {\n+        m_writer_set_by_user = setByUser;\n+        m_writer = writer;\n@@ -686,5 +694,13 @@\n-        if (m_tracer != null\n-         && !(writer instanceof SerializerTraceWriter)  )\n-            m_writer = new SerializerTraceWriter(writer, m_tracer);\n-        else\n-            m_writer = writer;\n+        if (m_tracer != null) {\n+            boolean noTracerYet = true;\n+            Writer w2 = m_writer;\n+            while (w2 instanceof WriterChain) {\n+                if (w2 instanceof SerializerTraceWriter) {\n+                    noTracerYet = false;\n+                    break;\n+                }\n+                w2 = ((WriterChain)w2).getWriter();\n+            }\n+            if (noTracerYet)\n+                m_writer = new SerializerTraceWriter(m_writer, m_tracer);\n+        }\n@@ -725,0 +741,2 @@\n+        setOutputStreamInternal(output, true);\n+    }\n@@ -726,1 +744,5 @@\n-        try\n+    private void setOutputStreamInternal(OutputStream output, boolean setByUser)\n+    {\n+        m_outputStream = output;\n+        String encoding = getOutputProperty(OutputKeys.ENCODING);\n+        if (Encodings.DEFAULT_MIME_ENCODING.equalsIgnoreCase(encoding))\n@@ -728,10 +750,11 @@\n-            Properties format;\n-            if (null == m_format)\n-                format =\n-                    OutputPropertiesFactory.getDefaultMethodProperties(\n-                        Method.XML);\n-            else\n-                format = m_format;\n-            init(output, format, true);\n-        }\n-        catch (UnsupportedEncodingException uee)\n+            \/\/ We wrap the OutputStream with a writer, but\n+            \/\/ not one set by the user\n+            try {\n+                setWriterInternal(new WriterToUTF8Buffered(output), false);\n+            } catch (UnsupportedEncodingException e) {\n+                e.printStackTrace();\n+            }\n+        } else if (\n+                \"WINDOWS-1250\".equals(encoding)\n+                || \"US-ASCII\".equals(encoding)\n+                || \"ASCII\".equals(encoding))\n@@ -739,0 +762,20 @@\n+            setWriterInternal(new WriterToASCI(output), false);\n+        } else if (encoding != null) {\n+            Writer osw = null;\n+                try\n+                {\n+                    osw = Encodings.getWriter(output, encoding);\n+                }\n+                catch (UnsupportedEncodingException uee)\n+                {\n+                    osw = null;\n+                }\n+\n+\n+            if (osw == null) {\n+                System.out.println(\n+                    \"Warning: encoding \\\"\"\n+                        + encoding\n+                        + \"\\\" not supported\"\n+                        + \", using \"\n+                        + Encodings.DEFAULT_MIME_ENCODING);\n@@ -740,1 +783,16 @@\n-            \/\/ Should have been warned in init, I guess...\n+                encoding = Encodings.DEFAULT_MIME_ENCODING;\n+                setEncoding(encoding);\n+                try {\n+                    osw = Encodings.getWriter(output, encoding);\n+                } catch (UnsupportedEncodingException e) {\n+                    \/\/ We can't really get here, UTF-8 is always supported\n+                    \/\/ This try-catch exists to make the compiler happy\n+                    e.printStackTrace();\n+                }\n+            }\n+            setWriterInternal(osw,false);\n+        }\n+        else {\n+            \/\/ don't have any encoding, but we have an OutputStream\n+            Writer osw = new OutputStreamWriter(output);\n+            setWriterInternal(osw,false);\n@@ -744,0 +802,1 @@\n+\n@@ -2465,1 +2524,1 @@\n-            if (m_cdataSectionElements != null)\n+            if (m_StringOfCDATASections != null)\n@@ -2542,1 +2601,1 @@\n-     * Sets the vector of local-name\/URI pairs of the cdata section elements\n+     * Sets the ArrayList of local-name\/URI pairs of the cdata section elements\n@@ -2547,1 +2606,1 @@\n-     * to setCdataSectionElements(Vector v) should be made directly.\n+     * to setCdataSectionElements(ArrayList<String> v) should be made directly.\n@@ -2556,2 +2615,2 @@\n-            \/\/ Vector of URI\/LocalName pairs\n-            Vector v = new Vector();\n+            \/\/ ArrayList<String> of URI\/LocalName pairs\n+            ArrayList<String> v = new ArrayList<>();\n@@ -2560,1 +2619,1 @@\n-            StringBuffer buf = new StringBuffer();\n+            StringBuilder buf = new StringBuilder();\n@@ -2607,1 +2666,1 @@\n-    private void addCdataSectionElement(String URI_and_localName, Vector v)\n+    private void addCdataSectionElement(String URI_and_localName, ArrayList<String> v)\n@@ -2618,2 +2677,2 @@\n-            v.addElement(null);\n-            v.addElement(s1);\n+            v.add(null);\n+            v.add(s1);\n@@ -2624,2 +2683,2 @@\n-            v.addElement(s1);\n-            v.addElement(s2);\n+            v.add(s1);\n+            v.add(s2);\n@@ -2634,1 +2693,1 @@\n-     * @param URI_and_localNames a vector of pairs of Strings (URI\/local)\n+     * @param URI_and_localNames an ArrayList of pairs of Strings (URI\/local)\n@@ -2636,1 +2695,1 @@\n-    public void setCdataSectionElements(Vector URI_and_localNames)\n+    public void setCdataSectionElements(ArrayList<String> URI_and_localNames)\n@@ -2638,1 +2697,28 @@\n-        m_cdataSectionElements = URI_and_localNames;\n+        \/\/ convert to the new way.\n+        if (URI_and_localNames != null)\n+        {\n+            final int len = URI_and_localNames.size() - 1;\n+            if (len > 0)\n+            {\n+                final StringBuilder sb = new StringBuilder();\n+                for (int i = 0; i < len; i += 2)\n+                {\n+                    \/\/ whitspace separated \"{uri1}local1 {uri2}local2 ...\"\n+                    if (i != 0)\n+                        sb.append(' ');\n+                    final String uri = (String) URI_and_localNames.get(i);\n+                    final String localName =\n+                        (String) URI_and_localNames.get(i + 1);\n+                    if (uri != null)\n+                    {\n+                        \/\/ If there is no URI don't put this in, just the localName then.\n+                        sb.append('{');\n+                        sb.append(uri);\n+                        sb.append('}');\n+                    }\n+                    sb.append(localName);\n+                }\n+                m_StringOfCDATASections = sb.toString();\n+            }\n+        }\n+        initCdataElems(m_StringOfCDATASections);\n@@ -3094,31 +3180,1 @@\n-         String old = getEncoding();\n-         super.setEncoding(encoding);\n-         if (old == null || !old.equals(encoding)) {\n-            \/\/ If we have changed the setting of the\n-            m_encodingInfo = Encodings.getEncodingInfo(encoding);\n-\n-            if (encoding != null && m_encodingInfo.name == null) {\n-                \/\/ We tried to get an EncodingInfo for Object for the given\n-                \/\/ encoding, but it came back with an internall null name\n-                \/\/ so the encoding is not supported by the JDK, issue a message.\n-                String msg = Utils.messages.createMessage(\n-                                MsgKey.ER_ENCODING_NOT_SUPPORTED,new Object[]{ encoding });\n-                try\n-                {\n-                        \/\/ Prepare to issue the warning message\n-                        Transformer tran = super.getTransformer();\n-                        if (tran != null) {\n-                                ErrorListener errHandler = tran.getErrorListener();\n-                                \/\/ Issue the warning message\n-                                if (null != errHandler && m_sourceLocator != null)\n-                                        errHandler.warning(new TransformerException(msg, m_sourceLocator));\n-                                else\n-                                        System.out.println(msg);\n-                    }\n-                        else\n-                                System.out.println(msg);\n-                }\n-                catch (Exception e){}\n-            }\n-         }\n-         return;\n+         setOutputProperty(OutputKeys.ENCODING,encoding);\n@@ -3396,0 +3452,20 @@\n+\n+    \/**\n+     * Remembers the cdata sections specified in the cdata-section-elements by appending the given\n+     * cdata section elements to the list. This method can be called multiple times, but once an\n+     * element is put in the list of cdata section elements it can not be removed.\n+     * This method should be used by both Xalan and XSLTC.\n+     *\n+     * @param URI_and_localNames a whitespace separated list of element names, each element\n+     * is a URI in curly braces (optional) and a local name. An example of such a parameter is:\n+     * \"{http:\/\/company.com}price {myURI2}book chapter\"\n+     *\/\n+    public void addCdataSectionElements(String URI_and_localNames)\n+    {\n+        if (URI_and_localNames != null)\n+            initCdataElems(URI_and_localNames);\n+        if (m_StringOfCDATASections == null)\n+            m_StringOfCDATASections = URI_and_localNames;\n+        else\n+            m_StringOfCDATASections += (\" \" + URI_and_localNames);\n+    }\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/ToStream.java","additions":356,"deletions":280,"binary":false,"changes":636,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.util.Vector;\n+import java.util.ArrayList;\n@@ -103,1 +103,1 @@\n-    private Vector m_namespaceURI = null;\n+    private ArrayList<String> m_namespaceURI = null;\n@@ -108,1 +108,1 @@\n-    private Vector m_namespacePrefix = null;\n+    private ArrayList<String> m_namespacePrefix = null;\n@@ -424,2 +424,2 @@\n-                    m_namespacePrefix = new Vector();\n-                    m_namespaceURI = new Vector();\n+                    m_namespacePrefix = new ArrayList<>();\n+                    m_namespaceURI = new ArrayList<>();\n@@ -427,2 +427,2 @@\n-                m_namespacePrefix.addElement(prefix);\n-                m_namespaceURI.addElement(uri);\n+                m_namespacePrefix.add(prefix);\n+                m_namespaceURI.add(uri);\n@@ -1095,2 +1095,2 @@\n-                        (String) m_namespacePrefix.elementAt(i);\n-                    final String uri = (String) m_namespaceURI.elementAt(i);\n+                        (String) m_namespacePrefix.get(i);\n+                    final String uri = (String) m_namespaceURI.get(i);\n@@ -1168,2 +1168,2 @@\n-                final String prefix = (String) m_namespacePrefix.elementAt(i);\n-                final String uri = (String) m_namespaceURI.elementAt(i);\n+                final String prefix = m_namespacePrefix.get(i);\n+                final String uri = m_namespaceURI.get(i);\n@@ -1197,1 +1197,1 @@\n-    public void setCdataSectionElements(Vector URI_and_localNames)\n+    public void setCdataSectionElements(ArrayList<String> URI_and_localNames)\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/ToUnknownStream.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 1999-2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/WriterToUTF8Buffered.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -6,3 +6,5 @@\n- * Copyright 2003-2004 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the  \"License\");\n@@ -25,1 +27,1 @@\n-import java.util.Vector;\n+import java.util.ArrayList;\n@@ -108,5 +110,0 @@\n-\n-\n-\n-\n-\n@@ -127,1 +124,1 @@\n-    public void setCdataSectionElements(Vector URI_and_localNames);\n+    public void setCdataSectionElements(ArrayList<String> URI_and_localNames);\n@@ -184,0 +181,54 @@\n+    \/**\n+     * Get the value for a property that affects seraialization,\n+     * if a property was set return that value, otherwise return\n+     * the default value, otherwise return null.\n+     * @param name The name of the property, which is just the local name\n+     * if it is in no namespace, but is the URI in curly braces followed by\n+     * the local name if it is in a namespace, for example:\n+     * <ul>\n+     * <li> \"encoding\"\n+     * <li> \"method\"\n+     * <li> \"{http:\/\/xml.apache.org\/xalan}indent-amount\"\n+     * <li> \"{http:\/\/xml.apache.org\/xalan}line-separator\"\n+     * <\/ul>\n+     * @return The value of the parameter\n+     *\/\n+    public String getOutputProperty(String name);\n+    \/**\n+     * Get the default value for a property that affects seraialization,\n+     * or null if there is none. It is possible that a non-default value\n+     * was set for the property, however the value returned by this method\n+     * is unaffected by any non-default settings.\n+     * @param name The name of the property.\n+     * @return The default value of the parameter, or null if there is no default value.\n+     *\/\n+    public String getOutputPropertyDefault(String name);\n+    \/**\n+     * Set the non-default value for a property that affects seraialization.\n+     * @param name The name of the property, which is just the local name\n+     * if it is in no namespace, but is the URI in curly braces followed by\n+     * the local name if it is in a namespace, for example:\n+     * <ul>\n+     * <li> \"encoding\"\n+     * <li> \"method\"\n+     * <li> \"{http:\/\/xml.apache.org\/xalan}indent-amount\"\n+     * <li> \"{http:\/\/xml.apache.org\/xalan}line-separator\"\n+     * <\/ul>\n+     * @val The non-default value of the parameter\n+     *\/\n+    public void   setOutputProperty(String name, String val);\n+\n+    \/**\n+     * Set the default value for a property that affects seraialization.\n+     * @param name The name of the property, which is just the local name\n+     * if it is in no namespace, but is the URI in curly braces followed by\n+     * the local name if it is in a namespace, for example:\n+     * <ul>\n+     * <li> \"encoding\"\n+     * <li> \"method\"\n+     * <li> \"{http:\/\/xml.apache.org\/xalan}indent-amount\"\n+     * <li> \"{http:\/\/xml.apache.org\/xalan}line-separator\"\n+     * <\/ul>\n+     * @val The default value of the parameter\n+     *\/\n+    public void   setOutputPropertyDefault(String name, String val);\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xml\/internal\/serializer\/XSLOutputAttributes.java","additions":61,"deletions":10,"binary":false,"changes":71,"status":"modified"}]}