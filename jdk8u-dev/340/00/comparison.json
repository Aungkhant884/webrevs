{"files":[{"patch":"@@ -115,0 +115,18 @@\n+ifeq ($(OPENJDK_TARGET_OS), windows)\n+  $(eval $(call SetupNativeCompilation,BUILD_LIBSSPI_BRIDGE, \\\n+    LIBRARY := sspi_bridge, \\\n+    OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \\\n+    SRC := $(JDK_TOPDIR)\/src\/windows\/native\/sun\/security\/jgss\/sspi_bridge, \\\n+    LANG := C, \\\n+    OPTIMIZATION := LOW, \\\n+    CFLAGS := $(CFLAGS_JDKLIB) \\\n+        -I$(JDK_TOPDIR)\/src\/share\/native\/sun\/security\/jgss\/wrapper, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+        $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LDFLAGS_SUFFIX := $(LIBDL), \\\n+    OBJECT_DIR := $(JDK_OUTPUTDIR)\/objs\/libsspi_bridge, \\\n+    DEBUG_SYMBOLS := $(DEBUG_ALL_BINARIES)))\n+\n+  BUILD_LIBRARIES += $(BUILD_LIBSSPI_BRIDGE)\n+endif\n+\n","filename":"jdk\/make\/lib\/SecurityLibraries.gmk","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.*;\n@@ -116,12 +115,0 @@\n-            } else if (GSSUtil.useMSInterop()) {\n-                \/\/ required for MS-interoperability\n-                if (responseToken != null) {\n-                    if (DEBUG) {\n-                        System.out.println(\"SpNegoToken NegTokenTarg: \" +\n-                                \"sending additional token for MS Interop\");\n-                    }\n-                    DerOutputStream rspToken = new DerOutputStream();\n-                    rspToken.putOctetString(responseToken);\n-                    targToken.write(DerValue.createTag(DerValue.TAG_CONTEXT,\n-                                                true, (byte) 0x03), rspToken);\n-                }\n","filename":"jdk\/src\/share\/classes\/sun\/security\/jgss\/spnego\/NegTokenTarg.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,1 @@\n-                        String gssLibs[] = new String[0];\n+                        String gssLibs[];\n@@ -98,0 +98,6 @@\n+                            } else if (osname.contains(\"Windows\")) {\n+                                \/\/ Full path needed, DLL is in jre\/bin\n+                                gssLibs = new String[]{ System.getProperty(\"java.home\")\n+                                        + \"\\\\bin\\\\sspi_bridge.dll\" };\n+                            } else {\n+                                gssLibs = new String[0];\n@@ -106,2 +112,1 @@\n-                                HashMap<String, String> map =\n-                                            new HashMap<String, String>();\n+                                HashMap<String,String> map = new HashMap<>();\n","filename":"jdk\/src\/share\/classes\/sun\/security\/jgss\/wrapper\/SunNativeProvider.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -981,1 +981,1 @@\n-  jobject jsrcName=GSS_C_NO_NAME;\n+  jobject jsrcName = NULL;\n","filename":"jdk\/src\/share\/native\/sun\/security\/jgss\/wrapper\/GSSLibStub.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n-                                gss_buffer_t input_name_buffer,\n-                                gss_OID input_name_type,\n+                                const gss_buffer_t input_name_buffer,\n+                                const gss_OID input_name_type,\n@@ -66,2 +66,2 @@\n-                                gss_name_t name1,\n-                                gss_name_t name2,\n+                                gss_const_name_t name1,\n+                                gss_const_name_t name2,\n@@ -72,2 +72,2 @@\n-                                gss_name_t input_name,\n-                                gss_OID mech_type,\n+                                gss_const_name_t input_name,\n+                                const gss_OID mech_type,\n@@ -78,1 +78,1 @@\n-                                gss_name_t input_name,\n+                                gss_const_name_t input_name,\n@@ -83,1 +83,1 @@\n-                                gss_name_t input_name,\n+                                gss_const_name_t input_name,\n@@ -89,1 +89,1 @@\n-                                gss_name_t desired_name,\n+                                gss_const_name_t desired_name,\n@@ -91,1 +91,1 @@\n-                                gss_OID_set desired_mech,\n+                                const gss_OID_set desired_mech,\n@@ -103,1 +103,1 @@\n-                                gss_cred_id_t cred_handle,\n+                                gss_const_cred_id_t cred_handle,\n@@ -111,1 +111,1 @@\n-                                gss_buffer_t interprocess_token,\n+                                const gss_buffer_t interprocess_token,\n@@ -116,1 +116,1 @@\n-                                gss_cred_id_t initiator_cred_handle,\n+                                gss_const_cred_id_t initiator_cred_handle,\n@@ -118,2 +118,2 @@\n-                                gss_name_t *target_name,\n-                                gss_OID mech_type,\n+                                gss_const_name_t target_name,\n+                                const gss_OID mech_type,\n@@ -122,2 +122,2 @@\n-                                gss_channel_bindings_t input_chan_bindings,\n-                                gss_buffer_t input_token,\n+                                const gss_channel_bindings_t input_chan_bindings,\n+                                const gss_buffer_t input_token,\n@@ -132,3 +132,3 @@\n-                                gss_cred_id_t acceptor_cred_handle,\n-                                gss_buffer_t input_token,\n-                                gss_channel_bindings_t input_chan_bindings,\n+                                gss_const_cred_id_t acceptor_cred_handle,\n+                                const gss_buffer_t input_token,\n+                                const gss_channel_bindings_t input_chan_bindings,\n@@ -144,1 +144,1 @@\n-                                gss_ctx_id_t context_handle,\n+                                gss_const_ctx_id_t context_handle,\n@@ -160,1 +160,1 @@\n-                                gss_ctx_id_t *context_handle,\n+                                gss_const_ctx_id_t context_handle,\n@@ -165,1 +165,1 @@\n-                                gss_ctx_id_t context_handle,\n+                                gss_const_ctx_id_t context_handle,\n@@ -178,1 +178,1 @@\n-                                gss_ctx_id_t context_handle,\n+                                gss_const_ctx_id_t context_handle,\n@@ -180,1 +180,1 @@\n-                                gss_buffer_t message_buffer,\n+                                const gss_buffer_t message_buffer,\n@@ -185,3 +185,3 @@\n-                                gss_ctx_id_t context_handle,\n-                                gss_buffer_t message_buffer,\n-                                gss_buffer_t token_buffer,\n+                                gss_const_ctx_id_t context_handle,\n+                                const gss_buffer_t message_buffer,\n+                                const gss_buffer_t token_buffer,\n@@ -192,1 +192,1 @@\n-                                gss_ctx_id_t context_handle,\n+                                gss_const_ctx_id_t context_handle,\n@@ -195,1 +195,1 @@\n-                                gss_buffer_t input_message_buffer,\n+                                const gss_buffer_t input_message_buffer,\n@@ -201,2 +201,2 @@\n-                                gss_ctx_id_t context_handle,\n-                                gss_buffer_t input_message_buffer,\n+                                gss_const_ctx_id_t context_handle,\n+                                const gss_buffer_t input_message_buffer,\n@@ -218,1 +218,1 @@\n-                                gss_OID member_oid,\n+                                const gss_OID member_oid,\n@@ -225,1 +225,1 @@\n-                                gss_OID mech_type,\n+                                const gss_OID mech_type,\n","filename":"jdk\/src\/share\/native\/sun\/security\/jgss\/wrapper\/NativeFunc.h","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,4 +91,4 @@\n-  #define TRACE0(s) { if (JGSS_DEBUG) { puts(s); fflush(stdout); }}\n-  #define TRACE1(s, p1) { if (JGSS_DEBUG) { printf(s\"\\n\", p1); fflush(stdout); }}\n-  #define TRACE2(s, p1, p2) { if (JGSS_DEBUG) { printf(s\"\\n\", p1, p2); fflush(stdout); }}\n-  #define TRACE3(s, p1, p2, p3) { if (JGSS_DEBUG) { printf(s\"\\n\", p1, p2, p3); fflush(stdout); }}\n+  #define TRACE0(s) { if (JGSS_DEBUG) { printf(\"[GSSLibStub:%d] %s\\n\", __LINE__, s); fflush(stdout); }}\n+  #define TRACE1(s, p1) { if (JGSS_DEBUG) { printf(\"[GSSLibStub:%d] \"s\"\\n\", __LINE__, p1); fflush(stdout); }}\n+  #define TRACE2(s, p1, p2) { if (JGSS_DEBUG) { printf(\"[GSSLibStub:%d] \"s\"\\n\", __LINE__, p1, p2); fflush(stdout); }}\n+  #define TRACE3(s, p1, p2, p3) { if (JGSS_DEBUG) { printf(\"[GSSLibStub:%d] \"s\"\\n\", __LINE__, p1, p2, p3); fflush(stdout); }}\n","filename":"jdk\/src\/share\/native\/sun\/security\/jgss\/wrapper\/NativeUtil.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,3 +60,11 @@\n-typedef void * gss_name_t;\n-typedef void * gss_cred_id_t;\n-typedef void * gss_ctx_id_t;\n+struct gss_name_struct;\n+typedef struct gss_name_struct * gss_name_t;\n+typedef const struct gss_name_struct *gss_const_name_t;\n+\n+struct gss_cred_id_struct;\n+typedef struct gss_cred_id_struct * gss_cred_id_t;\n+typedef const struct gss_cred_id_struct *gss_const_cred_id_t;\n+\n+struct gss_ctx_id_struct;\n+typedef struct gss_ctx_id_struct * gss_ctx_id_t;\n+typedef const struct gss_ctx_id_struct *gss_const_ctx_id_t;\n@@ -85,0 +93,1 @@\n+typedef const gss_OID_desc * gss_const_OID;\n@@ -90,0 +99,1 @@\n+typedef const gss_OID_set_desc * gss_const_OID_set;\n@@ -95,0 +105,1 @@\n+typedef const gss_buffer_desc * gss_const_buffer_t;\n@@ -103,0 +114,1 @@\n+typedef const struct gss_channel_bindings_struct *gss_const_channel_bindings_t;\n@@ -122,0 +134,1 @@\n+#define GSS_C_DELEG_POLICY_FLAG 32768\n@@ -392,1 +405,1 @@\n-        gss_name_t,             \/* desired_name *\/\n+        gss_const_name_t,       \/* desired_name *\/\n@@ -394,1 +407,1 @@\n-        gss_OID_set,            \/* desired_mechs *\/\n+        const gss_OID_set,      \/* desired_mechs *\/\n@@ -408,1 +421,1 @@\n-        gss_cred_id_t,          \/* claimant_cred_handle *\/\n+        gss_const_cred_id_t,    \/* claimant_cred_handle *\/\n@@ -410,2 +423,2 @@\n-        gss_name_t,             \/* target_name *\/\n-        gss_OID,                \/* mech_type (used to be const) *\/\n+        gss_const_name_t,       \/* target_name *\/\n+        const gss_OID,          \/* mech_type *\/\n@@ -414,2 +427,2 @@\n-        gss_channel_bindings_t, \/* input_chan_bindings *\/\n-        gss_buffer_t,           \/* input_token *\/\n+        const gss_channel_bindings_t, \/* input_chan_bindings *\/\n+        const gss_buffer_t,     \/* input_token *\/\n@@ -425,3 +438,3 @@\n-        gss_cred_id_t,          \/* acceptor_cred_handle *\/\n-        gss_buffer_t,           \/* input_token_buffer *\/\n-        gss_channel_bindings_t, \/* input_chan_bindings *\/\n+        gss_const_cred_id_t,    \/* acceptor_cred_handle *\/\n+        const gss_buffer_t,     \/* input_token_buffer *\/\n+        const gss_channel_bindings_t, \/* input_chan_bindings *\/\n@@ -438,2 +451,2 @@\n-        gss_ctx_id_t,           \/* context_handle *\/\n-        gss_buffer_t            \/* token_buffer *\/\n+        gss_const_ctx_id_t,     \/* context_handle *\/\n+        const gss_buffer_t      \/* token_buffer *\/\n@@ -450,1 +463,1 @@\n-        gss_ctx_id_t,           \/* context_handle *\/\n+        gss_const_ctx_id_t,     \/* context_handle *\/\n@@ -457,1 +470,1 @@\n-        gss_ctx_id_t,           \/* context_handle *\/\n+        gss_const_ctx_id_t,     \/* context_handle *\/\n@@ -459,1 +472,1 @@\n-        gss_buffer_t,           \/* message_buffer *\/\n+        const gss_buffer_t,     \/* message_buffer *\/\n@@ -466,3 +479,3 @@\n-        gss_ctx_id_t,           \/* context_handle *\/\n-        gss_buffer_t,           \/* message_buffer *\/\n-        gss_buffer_t,           \/* message_token *\/\n+        gss_const_ctx_id_t,     \/* context_handle *\/\n+        const gss_buffer_t,     \/* message_buffer *\/\n+        const gss_buffer_t,     \/* message_token *\/\n@@ -475,1 +488,1 @@\n-        gss_ctx_id_t,           \/* context_handle *\/\n+        gss_const_ctx_id_t,     \/* context_handle *\/\n@@ -478,1 +491,1 @@\n-        gss_buffer_t,           \/* input_message_buffer *\/\n+        const gss_buffer_t,     \/* input_message_buffer *\/\n@@ -486,2 +499,2 @@\n-        gss_ctx_id_t,           \/* context_handle *\/\n-        gss_buffer_t,           \/* input_message_buffer *\/\n+        gss_const_ctx_id_t,     \/* context_handle *\/\n+        const gss_buffer_t,     \/* input_message_buffer *\/\n@@ -497,1 +510,1 @@\n-        gss_OID,                \/* mech_type (used to be const) *\/\n+        const gss_OID,          \/* mech_type (used to be const) *\/\n@@ -509,2 +522,2 @@\n-        gss_name_t,             \/* name1 *\/\n-        gss_name_t,             \/* name2 *\/\n+        gss_const_name_t,       \/* name1 *\/\n+        gss_const_name_t,       \/* name2 *\/\n@@ -516,1 +529,1 @@\n-        gss_name_t,             \/* input_name *\/\n+        gss_const_name_t,       \/* input_name *\/\n@@ -523,2 +536,2 @@\n-        gss_buffer_t,           \/* input_name_buffer *\/\n-        gss_OID,                \/* input_name_type(used to be const) *\/\n+        const gss_buffer_t,     \/* input_name_buffer *\/\n+        const gss_OID,          \/* input_name_type(used to be const) *\/\n@@ -545,1 +558,1 @@\n-        gss_cred_id_t,          \/* cred_handle *\/\n+        gss_const_cred_id_t,    \/* cred_handle *\/\n@@ -555,1 +568,1 @@\n-        gss_ctx_id_t,           \/* context_handle *\/\n+        gss_const_ctx_id_t,     \/* context_handle *\/\n@@ -568,1 +581,1 @@\n-        gss_ctx_id_t,           \/* context_handle *\/\n+        gss_const_ctx_id_t,     \/* context_handle *\/\n@@ -578,3 +591,3 @@\n-        gss_cred_id_t,          \/* input_cred_handle *\/\n-        gss_name_t,             \/* desired_name *\/\n-        gss_OID,                \/* desired_mech *\/\n+        gss_const_cred_id_t,    \/* input_cred_handle *\/\n+        gss_const_name_t,       \/* desired_name *\/\n+        const gss_OID,          \/* desired_mech *\/\n@@ -593,2 +606,2 @@\n-        gss_cred_id_t,          \/* cred_handle *\/\n-        gss_OID,                \/* mech_type *\/\n+        gss_const_cred_id_t,    \/* cred_handle *\/\n+        const gss_OID,          \/* mech_type *\/\n@@ -611,1 +624,1 @@\n-        gss_buffer_t,           \/* interprocess_token *\/\n+        const gss_buffer_t,     \/* interprocess_token *\/\n@@ -630,1 +643,1 @@\n-        gss_OID,                \/* member_oid *\/\n+        const gss_OID,          \/* member_oid *\/\n@@ -637,2 +650,2 @@\n-        gss_OID,                \/* member *\/\n-        gss_OID_set,            \/* set *\/\n+        const gss_OID,          \/* member *\/\n+        const gss_OID_set,      \/* set *\/\n@@ -645,1 +658,1 @@\n-        gss_buffer_t,           \/* oid_str *\/\n+        const gss_buffer_t,     \/* oid_str *\/\n@@ -659,1 +672,1 @@\n-        gss_OID,                \/* mechanism *\/\n+        const gss_OID,          \/* mechanism *\/\n@@ -666,1 +679,1 @@\n-        const gss_name_t,       \/* input_name *\/\n+        gss_const_name_t,       \/* input_name *\/\n@@ -673,1 +686,1 @@\n-        const gss_name_t,       \/* input_name *\/\n+        gss_const_name_t,       \/* input_name *\/\n@@ -680,1 +693,1 @@\n-        const gss_name_t,       \/* input_name *\/\n+        gss_const_name_t,       \/* input_name *\/\n","filename":"jdk\/src\/share\/native\/sun\/security\/jgss\/wrapper\/gssapi.h","additions":62,"deletions":49,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -0,0 +1,1575 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ This library is client-side only, and only supports the default credentials.\n+\/\/ It speaks krb5 and SPNEGO. NTLM is excluded from SPNEGO negotiation.\n+\/\/\n+\/\/ This library can be built directly with the following command:\n+\/\/   cl -I %OPENJDK%\\src\\java.security.jgss\\share\\native\\libj2gss\\ sspi.cpp \\\n+\/\/      -link -dll -out:sspi_bridge.dll\n+\n+#define UNICODE\n+#define _UNICODE\n+\n+#include <windows.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <Strsafe.h>\n+#include <ntsecapi.h>\n+#include <new>\n+\n+#define GSS_DLL_FILE\n+#include <gssapi.h>\n+\n+#define SECURITY_WIN32\n+#include <sspi.h>\n+\n+#pragma comment(lib, \"secur32.lib\")\n+\n+\/\/ Otherwise an exception will be thrown\n+#define new new (std::nothrow)\n+\n+\/\/ A debugging macro\n+#define PP(fmt, ...) \\\n+        if (trace) { \\\n+            fprintf(stderr, \"[SSPI:%ld] \"fmt\"\\n\", __LINE__, ##__VA_ARGS__); \\\n+            fflush(stderr); \\\n+        }\n+#define SEC_SUCCESS(status) ((*minor_status = (status)), (status) >= SEC_E_OK)\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif \/* __cplusplus *\/\n+\n+\/\/ When SSPI_BRIDGE_TRACE is set, debug info goes to stderr. The value is ignored.\n+char* trace = getenv(\"SSPI_BRIDGE_TRACE\");\n+\n+void\n+dump(const char* title, PBYTE data, size_t len)\n+{\n+    if (trace) {\n+        fprintf(stderr, \"==== %s ====\\n\", title);\n+        for (size_t i = 0; i < len; i++) {\n+            if (i != 0 && i % 16 == 0) {\n+                fprintf(stderr, \"\\n\");\n+            }\n+            fprintf(stderr, \"%02X \", *(data + i) & 0xff);\n+        }\n+        fprintf(stderr, \"\\n\");\n+    }\n+}\n+\n+gss_OID_desc KRB5_OID = {9, (void*)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\"};\n+gss_OID_desc SPNEGO_OID = {6, (void*)\"\\x2b\\x06\\x01\\x05\\x05\\x02\"};\n+gss_OID_desc USER_NAME_OID = {10, (void*)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x01\\x01\"};\n+gss_OID_desc KRB5_NAME_OID = {10, (void*)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x02\\x01\"};\n+gss_OID_desc HOST_SERVICE_NAME_OID = {10, (void*)\"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x01\\x04\"};\n+gss_OID_desc EXPORT_NAME_OID = {6, (void*)\"\\x2b\\x06\\x01\\x05\\x06\\x04\"};\n+\n+struct gss_name_struct {\n+    SEC_WCHAR* name;\n+};\n+\n+struct gss_ctx_id_struct {\n+    CredHandle* phCred;\n+    CtxtHandle hCtxt;\n+    SecPkgContext_Sizes SecPkgContextSizes;\n+    SecPkgContext_NativeNames nnames;\n+    BOOLEAN established;\n+    BOOLEAN isSPNEGO;\n+    BOOLEAN isLocalCred;\n+    OM_uint32 flags;\n+};\n+\n+struct gss_cred_id_struct {\n+    CredHandle* phCredK;\n+    CredHandle* phCredS;\n+    long time;\n+};\n+\n+\/* This section holds supporting functions that are not exported *\/\n+\n+static OM_uint32\n+seconds_until(int inputIsUTC, TimeStamp *time)\n+{\n+    \/\/ time is local time\n+    LARGE_INTEGER uiLocal;\n+    FILETIME now;\n+    GetSystemTimeAsFileTime(&now);\n+    if (!inputIsUTC) {\n+        FILETIME nowLocal;\n+        if (FileTimeToLocalFileTime(&now, &nowLocal) == 0) {\n+            return -1;\n+        }\n+        now = nowLocal;\n+    }\n+    uiLocal.HighPart = now.dwHighDateTime;\n+    uiLocal.LowPart = now.dwLowDateTime;\n+    if (time->QuadPart < uiLocal.QuadPart) {\n+        return 0;\n+    }\n+    ULONGLONG diff = (time->QuadPart - uiLocal.QuadPart) \/ 10000000;\n+    if (diff > (ULONGLONG)~(OM_uint32)0)\n+        return GSS_C_INDEFINITE;\n+    return (OM_uint32)diff;\n+}\n+\n+static void\n+show_time(char* label, TimeStamp* ts)\n+{\n+    if (trace) {\n+        SYSTEMTIME stLocal;\n+        FileTimeToSystemTime((FILETIME*)ts, &stLocal);\n+\n+        \/\/ Build a string showing the date and time.\n+        PP(\"%s: %02d\/%02d\/%d  %02d:%02d %uld\", label,\n+            stLocal.wMonth, stLocal.wDay, stLocal.wYear,\n+            stLocal.wHour, stLocal.wMinute,\n+            seconds_until(1, ts));\n+    }\n+}\n+\n+\/\/ isSPNEGO: true, SPNEGO. false, Kerberos.\n+static gss_ctx_id_t\n+new_context(BOOLEAN isSPNEGO)\n+{\n+    gss_ctx_id_t out = new gss_ctx_id_struct;\n+    if (out == NULL) {\n+        return NULL;\n+    }\n+    out->phCred = NULL;\n+    out->hCtxt.dwLower = out->hCtxt.dwUpper = NULL;\n+    out->established = FALSE;\n+    out->SecPkgContextSizes.cbMaxSignature\n+            = out->SecPkgContextSizes.cbBlockSize\n+            = out->SecPkgContextSizes.cbSecurityTrailer\n+            = 0;\n+    out->nnames.sClientName = out->nnames.sServerName = NULL;\n+    out->isSPNEGO = isSPNEGO;\n+    out->isLocalCred = FALSE;\n+    return out;\n+}\n+\n+static gss_cred_id_t\n+new_cred()\n+{\n+    gss_cred_id_t out = new gss_cred_id_struct;\n+    out->phCredK = out->phCredS = NULL;\n+    out->time = 0L;\n+    return out;\n+}\n+\n+static int\n+flag_sspi_to_gss(int fin)\n+{\n+    int fout = 0;\n+    if (fin & ISC_REQ_MUTUAL_AUTH) fout |= GSS_C_MUTUAL_FLAG;\n+    if (fin & ISC_REQ_CONFIDENTIALITY) fout |= GSS_C_CONF_FLAG;\n+    if (fin & ISC_REQ_DELEGATE) fout |= GSS_C_DELEG_FLAG;\n+    if (fin & ISC_REQ_INTEGRITY) fout |= GSS_C_INTEG_FLAG;\n+    if (fin & ISC_REQ_REPLAY_DETECT) fout |= GSS_C_REPLAY_FLAG;\n+    if (fin & ISC_REQ_SEQUENCE_DETECT) fout |= GSS_C_SEQUENCE_FLAG;\n+    return fout;\n+}\n+\n+static int\n+flag_gss_to_sspi(int fin)\n+{\n+    int fout = 0;\n+    if (fin & GSS_C_MUTUAL_FLAG) fout |= ISC_RET_MUTUAL_AUTH;\n+    if (fin & GSS_C_CONF_FLAG) fout |= ISC_RET_CONFIDENTIALITY;\n+    if (fin & GSS_C_DELEG_FLAG) fout |= ISC_RET_DELEGATE;\n+    if (fin & GSS_C_INTEG_FLAG) fout |= ISC_RET_INTEGRITY;\n+    if (fin & GSS_C_REPLAY_FLAG) fout |= ISC_RET_REPLAY_DETECT;\n+    if (fin & GSS_C_SEQUENCE_FLAG) fout |= ISC_RET_SEQUENCE_DETECT;\n+    return fout;\n+}\n+\n+static BOOLEAN\n+is_same_oid(gss_OID o2, gss_OID o1)\n+{\n+    return o1 && o2 && o1->length == o2->length\n+            && !memcmp(o1->elements, o2->elements, o2->length);\n+}\n+\n+static BOOLEAN\n+has_oid(gss_OID_set set, gss_OID oid)\n+{\n+    for (int i = 0; i < set->count; i++) {\n+        if (is_same_oid(&set->elements[i], oid)) {\n+            return TRUE;\n+        }\n+    }\n+    return FALSE;\n+}\n+\n+static void\n+get_oid_desc(gss_OID mech)\n+{\n+    if (trace) {\n+        if (is_same_oid(mech, &KRB5_OID)) {\n+            PP(\"Kerberos mech\");\n+        } else if (is_same_oid(mech, &SPNEGO_OID)) {\n+            PP(\"SPNEGO mech\");\n+        } else if (is_same_oid(mech, &USER_NAME_OID)) {\n+            PP(\"NT_USER_NAME name-type\");\n+        } else if (is_same_oid(mech, &KRB5_NAME_OID)) {\n+            PP(\"KRB5_NAME name-type\");\n+        } else if (is_same_oid(mech, &HOST_SERVICE_NAME_OID)) {\n+            PP(\"NT_HOSTBASED_SERVICE name-type\");\n+        } else if (is_same_oid(mech, &EXPORT_NAME_OID)) {\n+            PP(\"NT_EXPORT_NAME name-type\");\n+        } else {\n+            dump(\"UNKNOWN OID\", (PBYTE)mech->elements, mech->length);\n+        }\n+    }\n+}\n+\n+static void\n+get_oid_set_desc(gss_OID_set mechs)\n+{\n+    if (trace) {\n+        if (mechs == NULL) {\n+            PP(\"OID set is NULL\");\n+            return;\n+        }\n+        PP(\"gss_OID_set.count is %d\", (int)mechs->count);\n+        for (int i = 0; i < mechs->count; i++) {\n+            get_oid_desc(&mechs->elements[i]);\n+        }\n+    }\n+}\n+\n+\/\/ Add realm to a name if there was none.\n+\/\/ Returns a newly allocated name.\n+static WCHAR*\n+get_full_name(WCHAR* input)\n+{\n+    \/\/ input has realm, no need to add one\n+    for (int i = 0;; i++) {\n+        if (!input[i]) { \/\/ the end\n+            break;\n+        }\n+        if (input[i] == L'\\\\') { \/\/ escaped\n+            i++;\n+            continue;\n+        }\n+        if (input[i] == L'@') {\n+            return _wcsdup(input);\n+        }\n+    }\n+\n+    \/\/ Always use the default domain\n+    WCHAR* realm = _wgetenv(L\"USERDNSDOMAIN\");\n+    if (realm == NULL) {\n+        realm = L\"\";\n+    }\n+\n+    size_t oldlen = wcslen(input);\n+    size_t newlen = oldlen + 1 + wcslen(realm) + 1;\n+\n+    WCHAR* fullname = new WCHAR[newlen];\n+    if (!fullname) {\n+        return NULL;\n+    }\n+    wcscpy_s(fullname, newlen, input);\n+    wcscat_s(fullname, newlen, L\"@\");\n+    wcscat_s(fullname, newlen, realm);\n+\n+    PP(\"get_full_name returns %ls\", fullname);\n+    return fullname;\n+}\n+\n+\/* End support section *\/\n+\n+\/* This section holds GSS-API exported functions *\/\n+\n+#define CHECK_OUTPUT(x)  if (!x) return GSS_S_CALL_INACCESSIBLE_WRITE;\n+#define CHECK_BUFFER(b)  if (!b || !b->value) return GSS_S_CALL_INACCESSIBLE_READ;\n+#define CHECK_OID(o)     if (!o || !o->elements) return GSS_S_CALL_INACCESSIBLE_READ;\n+#define CHECK_NAME(n)    if (!n || !(n->name)) return GSS_S_BAD_NAME;\n+#define CHECK_CONTEXT(c) if (!c) return GSS_S_NO_CONTEXT;\n+#define CHECK_CRED(c)    if (!c || (!(cred_handle->phCredK) && !(cred_handle->phCredS))) \\\n+                                return GSS_S_NO_CRED;\n+\n+__declspec(dllexport) OM_uint32\n+gss_release_name(OM_uint32 *minor_status,\n+                 gss_name_t *name)\n+{\n+    PP(\">>>> Calling gss_release_name %p...\", *name);\n+    if (name != NULL && *name != GSS_C_NO_NAME) {\n+        if ((*name)->name != NULL) {\n+            delete[] (*name)->name;\n+        }\n+        delete *name;\n+        *name = GSS_C_NO_NAME;\n+    }\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_import_name(OM_uint32 *minor_status,\n+                const gss_buffer_t input_name_buffer,\n+                const gss_OID input_name_type,\n+                gss_name_t *output_name)\n+{\n+    PP(\">>>> Calling gss_import_name...\");\n+    CHECK_BUFFER(input_name_buffer)\n+    CHECK_OUTPUT(output_name)\n+\n+    int len = (int)input_name_buffer->length;\n+    LPSTR input = (LPSTR)input_name_buffer->value;\n+    if (input_name_type != NULL\n+            && is_same_oid(input_name_type, &EXPORT_NAME_OID)) {\n+        int mechLen = (int)input[3]; \/* including 06 len *\/\n+        len -= mechLen + 8; \/* 4 header bytes, and an int32 length after OID *\/\n+        if (len <= 0) {\n+            return GSS_S_FAILURE;\n+        }\n+        \/\/ Reject if mech is not krb5\n+        if (mechLen - 2!= KRB5_OID.length ||\n+                memcmp(input + 6, KRB5_OID.elements, mechLen - 2)) {\n+            return GSS_S_FAILURE;;\n+        }\n+        input = input + mechLen + 8;\n+    }\n+\n+    SEC_WCHAR* value = new SEC_WCHAR[len + 1];\n+    if (value == NULL) {\n+        goto err;\n+    }\n+\n+    len = MultiByteToWideChar(CP_UTF8, 0, input, len, value, len+1);\n+    if (len == 0) {\n+        goto err;\n+    }\n+    value[len] = 0;\n+\n+    PP(\"import_name from %ls\", value);\n+\n+    if (len > 33 && !wcscmp(value+len-33, L\"@WELLKNOWN:ORG.H5L.REFERALS-REALM\")) {\n+        \/\/ Remove the wellknown referrals realms\n+        value[len-33] = 0;\n+        len -= 33;\n+    } else if (value[len-1] == L'@') {\n+        \/\/ Remove the empty realm. It might come from an NT_EXPORT_NAME.\n+        value[len-1] = 0;\n+        len--;\n+    }\n+    if (len == 0) {\n+        goto err;\n+    }\n+\n+    if (input_name_type != NULL\n+            && is_same_oid(input_name_type, &HOST_SERVICE_NAME_OID)) {\n+        \/\/ HOST_SERVICE_NAME_OID takes the form of service@host.\n+        for (int i = 0; i < len; i++) {\n+            if (value[i] == L'\\\\') {\n+                i++;\n+                continue;\n+            }\n+            if (value[i] == L'@') {\n+                value[i] = L'\/';\n+                break;\n+            }\n+        }\n+        PP(\"Host-based service now %ls\", value);\n+    }\n+    PP(\"import_name to %ls\", value);\n+    gss_name_struct* name = new gss_name_struct;\n+    if (name == NULL) {\n+        goto err;\n+    }\n+    name->name = value;\n+    *output_name = (gss_name_t) name;\n+    return GSS_S_COMPLETE;\n+err:\n+    if (value != NULL) {\n+        delete[] value;\n+    }\n+    return GSS_S_FAILURE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_compare_name(OM_uint32 *minor_status,\n+                 gss_const_name_t name1,\n+                 gss_const_name_t name2,\n+                 int *name_equal)\n+{\n+    PP(\">>>> Calling gss_compare_name...\");\n+    CHECK_NAME(name1)\n+    CHECK_NAME(name2)\n+    CHECK_OUTPUT(name_equal)\n+\n+    *name_equal = 0;\n+\n+    SEC_WCHAR* n1 = name1->name;\n+    SEC_WCHAR* n2 = name2->name;\n+    PP(\"Comparing %ls and %ls\", n1, n2);\n+    int l1 = lstrlen(n1);\n+    int l2 = lstrlen(n2);\n+    if (l1 < l2 && n2[l1] != L'@'\n+            || l2 < l1 && n1[l2] != L'@') {\n+        return GSS_S_COMPLETE; \/\/ different\n+    }\n+    if (l1 > l2) {\n+        l1 = l2; \/\/ choose the smaller one. longer=smaller @ ...\n+    }\n+    if (CompareStringEx(LOCALE_NAME_SYSTEM_DEFAULT, NORM_IGNORECASE,\n+            n1, l1, n2, l1, NULL, NULL, 0) == CSTR_EQUAL) {\n+        *name_equal = 1;\n+    }\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_canonicalize_name(OM_uint32 *minor_status,\n+                      gss_const_name_t input_name,\n+                      const gss_OID mech_type,\n+                      gss_name_t *output_name)\n+{\n+    PP(\">>>> Calling gss_canonicalize_name...\");\n+    CHECK_NAME(input_name)\n+    CHECK_OID(mech_type)\n+    CHECK_OUTPUT(output_name)\n+\n+    gss_name_t names2 = new gss_name_struct;\n+    if (names2 == NULL) {\n+        return GSS_S_FAILURE;\n+    }\n+    names2->name = get_full_name(input_name->name);\n+    if (names2->name == NULL) {\n+        delete names2;\n+        return GSS_S_FAILURE;\n+    }\n+    *output_name = names2;\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_export_name(OM_uint32 *minor_status,\n+                gss_const_name_t input_name,\n+                gss_buffer_t exported_name)\n+{\n+    PP(\">>>> Calling gss_export_name...\");\n+    CHECK_NAME(input_name)\n+    CHECK_OUTPUT(exported_name)\n+\n+    OM_uint32 result = GSS_S_FAILURE;\n+    SEC_WCHAR* name = input_name->name;\n+    SEC_WCHAR* fullname = get_full_name(name);\n+    if (!fullname) {\n+        goto err;\n+    }\n+    PP(\"Make fullname: %ls -> %ls\", name, fullname);\n+    int len;\n+    size_t namelen = wcslen(fullname);\n+    if (namelen > 255) {\n+        goto err;\n+    }\n+    len = (int)namelen;\n+    \/\/ We only deal with not-so-long names.\n+    \/\/ 04 01 00 ** 06 ** OID len:int32 name\n+    int mechLen = KRB5_OID.length;\n+    char* buffer = new char[10 + mechLen + len];\n+    if (buffer == NULL) {\n+        goto err;\n+    }\n+    buffer[0] = 4;\n+    buffer[1] = 1;\n+    buffer[2] = 0;\n+    buffer[3] = 2 + mechLen;\n+    buffer[4] = 6;\n+    buffer[5] = mechLen;\n+    memcpy_s(buffer + 6, mechLen, KRB5_OID.elements, mechLen);\n+    buffer[6 + mechLen] = buffer[7 + mechLen] = buffer[8 + mechLen] = 0;\n+    buffer[9 + mechLen] = (char)len;\n+    len = WideCharToMultiByte(CP_UTF8, 0, fullname, len,\n+                buffer+10+mechLen, len, NULL, NULL);\n+    if (len == 0) {\n+        delete[] buffer;\n+        goto err;\n+    }\n+    exported_name->length = 10 + mechLen + len;\n+    exported_name->value = buffer;\n+    result = GSS_S_COMPLETE;\n+err:\n+    if (fullname != name) {\n+        delete[] fullname;\n+    }\n+    return result;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_display_name(OM_uint32 *minor_status,\n+                 gss_const_name_t input_name,\n+                 gss_buffer_t output_name_buffer,\n+                 gss_OID *output_name_type)\n+{\n+    PP(\">>>> Calling gss_display_name...\");\n+    CHECK_NAME(input_name)\n+    CHECK_OUTPUT(output_name_buffer)\n+\n+    SEC_WCHAR* names = input_name->name;\n+    int len = (int)wcslen(names);\n+    char* buffer = new char[4*len+1];\n+    if (buffer == NULL) {\n+        return GSS_S_FAILURE;\n+    }\n+    len = WideCharToMultiByte(CP_UTF8, 0, names, len, buffer, 4*len, NULL, NULL);\n+    if (len == 0) {\n+        delete[] buffer;\n+        return GSS_S_FAILURE;\n+    }\n+    buffer[len] = 0;\n+    output_name_buffer->length = len;\n+    output_name_buffer->value = buffer;\n+    PP(\"Name found: %ls -> %d [%s]\", names, len, buffer);\n+    if (output_name_type != NULL) {\n+        *output_name_type = &KRB5_NAME_OID;\n+    }\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_acquire_cred(OM_uint32 *minor_status,\n+                 gss_const_name_t desired_name,\n+                 OM_uint32 time_req,\n+                 const gss_OID_set desired_mechs,\n+                 gss_cred_usage_t cred_usage,\n+                 gss_cred_id_t *output_cred_handle,\n+                 gss_OID_set *actual_mechs,\n+                 OM_uint32 *time_rec)\n+{\n+    PP(\">>>> Calling gss_acquire_cred...\");\n+    CHECK_OUTPUT(output_cred_handle)\n+\n+    SECURITY_STATUS ss;\n+    TimeStamp ts;\n+    ts.QuadPart = 0;\n+    cred_usage = 0;\n+    PP(\"AcquireCredentialsHandle with %d %p\", cred_usage, desired_mechs);\n+    get_oid_set_desc(desired_mechs);\n+\n+    BOOLEAN reqKerberos, reqSPNEGO;\n+\n+    if (!desired_mechs) {\n+        reqKerberos = reqSPNEGO = TRUE;\n+    } else {\n+        if (has_oid(desired_mechs, &KRB5_OID)) {\n+            PP(\"reqKerberos\");\n+            reqKerberos = TRUE;\n+        }\n+        if (has_oid(desired_mechs, &SPNEGO_OID)) {\n+            PP(\"reqSPNEGO\");\n+            reqSPNEGO = TRUE;\n+        }\n+        if (!reqSPNEGO && !reqKerberos) {\n+            return GSS_S_BAD_MECH;\n+        }\n+    }\n+\n+    if (actual_mechs) {\n+        *actual_mechs = GSS_C_NO_OID_SET;\n+    }\n+\n+    gss_cred_id_t cred = new_cred();\n+    if (cred == NULL) {\n+        goto err;\n+    }\n+\n+    if (reqKerberos) {\n+        cred->phCredK = new CredHandle;\n+        if (cred->phCredK == NULL) {\n+            goto err;\n+        }\n+        ss = AcquireCredentialsHandle(\n+                NULL,\n+                L\"Kerberos\",\n+                cred_usage == 0 ? SECPKG_CRED_BOTH :\n+                    (cred_usage == 1 ? SECPKG_CRED_OUTBOUND : SECPKG_CRED_INBOUND),\n+                NULL,\n+                NULL,\n+                NULL,\n+                NULL,\n+                cred->phCredK,\n+                &ts);\n+        if (!(SEC_SUCCESS(ss))) {\n+            delete cred->phCredK;\n+            cred->phCredK = NULL;\n+            goto err;\n+        }\n+    }\n+\n+    if (reqSPNEGO) {\n+        cred->phCredS = new CredHandle;\n+        if (cred->phCredS == NULL) {\n+            goto err;\n+        }\n+        SEC_WINNT_AUTH_IDENTITY_EX auth;\n+        ZeroMemory(&auth, sizeof(auth));\n+        auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;\n+        auth.Length = sizeof(auth);\n+        auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n+        auth.PackageList = (unsigned short*)L\"Kerberos\";\n+        auth.PackageListLength = 8;\n+        ss = AcquireCredentialsHandle(\n+                NULL,\n+                L\"Negotiate\",\n+                cred_usage == 0 ? SECPKG_CRED_BOTH :\n+                    (cred_usage == 1 ? SECPKG_CRED_OUTBOUND : SECPKG_CRED_INBOUND),\n+                NULL,\n+                &auth,\n+                NULL,\n+                NULL,\n+                cred->phCredS,\n+                &ts);\n+        if (!(SEC_SUCCESS(ss))) {\n+            delete cred->phCredS;\n+            cred->phCredS = NULL;\n+            goto err;\n+        }\n+    }\n+\n+    if (actual_mechs) {\n+        if (gss_create_empty_oid_set(minor_status, actual_mechs)) {\n+            goto err;\n+        }\n+        if (reqKerberos) {\n+            if (gss_add_oid_set_member(minor_status, &KRB5_OID, actual_mechs)) {\n+                goto err;\n+            }\n+        }\n+        if (reqSPNEGO) {\n+            if (gss_add_oid_set_member(minor_status, &SPNEGO_OID, actual_mechs)) {\n+                goto err;\n+            }\n+        }\n+    }\n+\n+    *output_cred_handle = (gss_cred_id_t)cred;\n+\n+    \/\/ Note: ts here is weirdly huge, maybe because LSA retains the\n+    \/\/ password and can re-acquire a TGT at anytime. It will be\n+    \/\/ GSSCredential.INDEFINITE_LIFETIME.\n+    show_time(\"cred expiration\", &ts);\n+    cred->time = seconds_until(1, &ts);\n+    if (time_rec != NULL) {\n+        *time_rec = cred->time;\n+    }\n+\n+    \/\/ Since only default cred is supported, if there is a desired_name,\n+    \/\/ we must make sure it is the same as the realname of the default cred.\n+    if (desired_name != NULL) {\n+        PP(\"Acquiring cred with a name. Check if it's me.\");\n+        gss_name_t realname;\n+        if (gss_inquire_cred(minor_status, *output_cred_handle, &realname,\n+                NULL, NULL, NULL) != GSS_S_COMPLETE) {\n+            PP(\"Cannot get owner name of default creds\");\n+            goto err;\n+        }\n+        SEC_WCHAR* rnames = realname->name;\n+        SEC_WCHAR* dnames = desired_name->name;\n+        int equals = 0;\n+        gss_compare_name(minor_status, realname, desired_name, &equals);\n+        gss_release_name(minor_status, &realname);\n+        PP(\"Comparing result: %d\", equals);\n+        if (!equals) {\n+            goto err;\n+        }\n+    }\n+\n+    return GSS_S_COMPLETE;\n+err:\n+    if (cred) {\n+        OM_uint32 dummy;\n+        gss_release_cred(&dummy, &cred);\n+    }\n+    if (actual_mechs) {\n+        OM_uint32 dummy;\n+        gss_release_oid_set(&dummy, actual_mechs);\n+    }\n+    return GSS_S_FAILURE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_release_cred(OM_uint32 *minor_status,\n+                 gss_cred_id_t *cred_handle)\n+{\n+    PP(\">>>> Calling gss_release_cred...\");\n+    if (cred_handle && *cred_handle) {\n+        if ((*cred_handle)->phCredK) {\n+            FreeCredentialsHandle((*cred_handle)->phCredK);\n+            delete (*cred_handle)->phCredK;\n+        }\n+        if ((*cred_handle)->phCredS) {\n+            FreeCredentialsHandle((*cred_handle)->phCredS);\n+            delete (*cred_handle)->phCredS;\n+        }\n+        delete *cred_handle;\n+        *cred_handle = GSS_C_NO_CREDENTIAL;\n+    }\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_inquire_cred(OM_uint32 *minor_status,\n+                 gss_const_cred_id_t cred_handle,\n+                 gss_name_t *name,\n+                 OM_uint32 *lifetime,\n+                 gss_cred_usage_t *cred_usage,\n+                 gss_OID_set *mechanisms)\n+{\n+    PP(\">>>> Calling gss_inquire_cred...\");\n+    CHECK_CRED(cred_handle)\n+\n+    CredHandle* cred = cred_handle->phCredK\n+            ? cred_handle->phCredK\n+            : cred_handle->phCredS;\n+    SECURITY_STATUS ss;\n+    if (name) {\n+        *name = GSS_C_NO_NAME;\n+        SecPkgCredentials_Names snames;\n+        ss = QueryCredentialsAttributes(cred, SECPKG_CRED_ATTR_NAMES, &snames);\n+        if (!SEC_SUCCESS(ss)) {\n+            return GSS_S_FAILURE;\n+        }\n+        SEC_WCHAR* names = new SEC_WCHAR[lstrlen(snames.sUserName) + 1];\n+        if (names == NULL) {\n+            return GSS_S_FAILURE;\n+        }\n+        StringCchCopy(names, lstrlen(snames.sUserName) + 1, snames.sUserName);\n+        FreeContextBuffer(snames.sUserName);\n+        PP(\"Allocate new name at %p\", names);\n+        gss_name_t name1 = new gss_name_struct;\n+        if (name1 == NULL) {\n+            delete[] names;\n+            return GSS_S_FAILURE;\n+        }\n+        name1->name = names;\n+        *name = (gss_name_t) name1;\n+    }\n+    if (lifetime) {\n+        *lifetime = cred_handle->time;\n+    }\n+    if (cred_usage) {\n+        *cred_usage = 1; \/\/ We only support INITIATE_ONLY now\n+    }\n+    if (mechanisms) {\n+        \/\/ Useless for Java\n+    }\n+    \/\/ Others inquiries not supported yet\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_import_sec_context(OM_uint32 *minor_status,\n+                       const gss_buffer_t interprocess_token,\n+                       gss_ctx_id_t *context_handle)\n+{\n+    \/\/ Not transferable, return FAILURE\n+    PP(\">>>> Calling UNIMPLEMENTED gss_import_sec_context...\");\n+    *minor_status = 0;\n+    return GSS_S_FAILURE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_init_sec_context(OM_uint32 *minor_status,\n+                     gss_const_cred_id_t initiator_cred_handle,\n+                     gss_ctx_id_t *context_handle,\n+                     gss_const_name_t target_name,\n+                     const gss_OID mech_type,\n+                     OM_uint32 req_flags,\n+                     OM_uint32 time_req,\n+                     const gss_channel_bindings_t input_chan_bindings,\n+                     const gss_buffer_t input_token,\n+                     gss_OID *actual_mech_type,\n+                     gss_buffer_t output_token,\n+                     OM_uint32 *ret_flags,\n+                     OM_uint32 *time_rec)\n+{\n+    PP(\">>>> Calling gss_init_sec_context...\");\n+    CHECK_NAME(target_name)\n+    CHECK_OUTPUT(output_token)\n+\n+    SECURITY_STATUS ss;\n+    TimeStamp lifeTime;\n+    SecBufferDesc inBuffDesc;\n+    SecBuffer inSecBuff;\n+    SecBufferDesc outBuffDesc;\n+    SecBuffer outSecBuff;\n+    BOOLEAN isSPNEGO = is_same_oid(mech_type, &SPNEGO_OID);\n+\n+    gss_ctx_id_t pc;\n+\n+    output_token->length = 0;\n+    output_token->value = NULL;\n+\n+    BOOLEAN firstTime = (*context_handle == GSS_C_NO_CONTEXT);\n+    PP(\"First time? %d\", firstTime);\n+    if (firstTime) {\n+        pc = new_context(isSPNEGO);\n+        if (pc == NULL) {\n+            return GSS_S_FAILURE;\n+        }\n+        *context_handle = (gss_ctx_id_t) pc;\n+    } else {\n+        pc = *context_handle;\n+    }\n+\n+    if (pc == NULL) {\n+        return GSS_S_NO_CONTEXT;\n+    }\n+\n+    DWORD outFlag;\n+    TCHAR outName[100];\n+\n+    OM_uint32 minor;\n+    gss_buffer_desc tn;\n+    gss_display_name(&minor, target_name, &tn, NULL);\n+    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCCH)tn.value, (int)tn.length,\n+            outName, sizeof(outName) - 1);\n+    if (len == 0) {\n+        goto err;\n+    }\n+    outName[len] = 0;\n+\n+    int flag = flag_gss_to_sspi(req_flags) | ISC_REQ_ALLOCATE_MEMORY;\n+\n+    outBuffDesc.ulVersion = SECBUFFER_VERSION;\n+    outBuffDesc.cBuffers = 1;\n+    outBuffDesc.pBuffers = &outSecBuff;\n+\n+    outSecBuff.BufferType = SECBUFFER_TOKEN;\n+\n+    if (!firstTime) {\n+        inBuffDesc.ulVersion = SECBUFFER_VERSION;\n+        inBuffDesc.cBuffers = 1;\n+        inBuffDesc.pBuffers = &inSecBuff;\n+\n+        inSecBuff.BufferType = SECBUFFER_TOKEN;\n+        inSecBuff.cbBuffer = (ULONG)input_token->length;\n+        inSecBuff.pvBuffer = input_token->value;\n+    } else if (!pc->phCred) {\n+        if (isSPNEGO && initiator_cred_handle\n+                && initiator_cred_handle->phCredS) {\n+            PP(\"Find SPNEGO credentials\");\n+            pc->phCred = initiator_cred_handle->phCredS;\n+            pc->isLocalCred = FALSE;\n+        } else if (!isSPNEGO && initiator_cred_handle\n+                && initiator_cred_handle->phCredK) {\n+            PP(\"Find Kerberos credentials\");\n+            pc->phCred = initiator_cred_handle->phCredK;\n+            pc->isLocalCred = FALSE;\n+        } else {\n+            PP(\"No credentials provided, acquire myself\");\n+            CredHandle* newCred = new CredHandle;\n+            SEC_WINNT_AUTH_IDENTITY_EX auth;\n+            ZeroMemory(&auth, sizeof(auth));\n+            auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;\n+            auth.Length = sizeof(auth);\n+            auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n+            auth.PackageList = (unsigned short*)L\"Kerberos\";\n+            auth.PackageListLength = 8;\n+            ss = AcquireCredentialsHandle(\n+                    NULL,\n+                    isSPNEGO ? L\"Negotiate\" : L\"Kerberos\",\n+                    SECPKG_CRED_OUTBOUND,\n+                    NULL,\n+                    isSPNEGO ? &auth : NULL,\n+                    NULL,\n+                    NULL,\n+                    newCred,\n+                    &lifeTime);\n+            if (!(SEC_SUCCESS(ss))) {\n+                delete newCred;\n+                goto err;\n+            }\n+            pc->phCred = newCred;\n+            pc->isLocalCred = TRUE;\n+        }\n+    }\n+    ss = InitializeSecurityContext(\n+            pc->phCred,\n+            firstTime ? NULL : &pc->hCtxt,\n+            outName,\n+            flag,\n+            0,\n+            SECURITY_NATIVE_DREP,\n+            firstTime ? NULL : &inBuffDesc,\n+            0,\n+            &pc->hCtxt,\n+            &outBuffDesc,\n+            &outFlag,\n+            &lifeTime);\n+\n+    if (!SEC_SUCCESS(ss)) {\n+        \/\/ TODO: seems NativeGSSContext has not failed here.\n+        PP(\"InitializeSecurityContext failed\");\n+        goto err;\n+    }\n+\n+    pc->flags = *ret_flags = flag_sspi_to_gss(outFlag);\n+\n+    \/\/ Ignore the result of the next call. Might fail before context established.\n+    QueryContextAttributes(\n+            &pc->hCtxt, SECPKG_ATTR_SIZES, &pc->SecPkgContextSizes);\n+    PP(\"cbMaxSignature: %ld. cbBlockSize: %ld. cbSecurityTrailer: %ld\",\n+            pc->SecPkgContextSizes.cbMaxSignature,\n+            pc->SecPkgContextSizes.cbBlockSize,\n+            pc->SecPkgContextSizes.cbSecurityTrailer);\n+\n+    output_token->length = outSecBuff.cbBuffer;\n+    if (outSecBuff.cbBuffer) {\n+        \/\/ No idea how user would free the data. Let's duplicate one.\n+        output_token->value = new char[outSecBuff.cbBuffer];\n+        if (!output_token->value) {\n+            FreeContextBuffer(outSecBuff.pvBuffer);\n+            output_token->length = 0;\n+            goto err;\n+        }\n+        memcpy(output_token->value, outSecBuff.pvBuffer, outSecBuff.cbBuffer);\n+        FreeContextBuffer(outSecBuff.pvBuffer);\n+    }\n+\n+    if (ss == SEC_I_CONTINUE_NEEDED) {\n+        return GSS_S_CONTINUE_NEEDED;\n+    } else {\n+        pc->established = true;\n+        ss = QueryContextAttributes(&pc->hCtxt, SECPKG_ATTR_NATIVE_NAMES, &pc->nnames);\n+        if (!SEC_SUCCESS(ss)) {\n+            goto err;\n+        }\n+        PP(\"Names. %ls %ls\", pc->nnames.sClientName, pc->nnames.sServerName);\n+        *ret_flags |= GSS_C_PROT_READY_FLAG;\n+        return GSS_S_COMPLETE;\n+    }\n+err:\n+    if (firstTime) {\n+        OM_uint32 dummy;\n+        gss_delete_sec_context(&dummy, context_handle, GSS_C_NO_BUFFER);\n+    }\n+    if (output_token->value) {\n+        gss_release_buffer(NULL, output_token);\n+        output_token = GSS_C_NO_BUFFER;\n+    }\n+    return GSS_S_FAILURE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_accept_sec_context(OM_uint32 *minor_status,\n+                       gss_ctx_id_t *context_handle,\n+                       gss_const_cred_id_t acceptor_cred_handle,\n+                       const gss_buffer_t input_token,\n+                       const gss_channel_bindings_t input_chan_bindings,\n+                       gss_name_t *src_name,\n+                       gss_OID *mech_type,\n+                       gss_buffer_t output_token,\n+                       OM_uint32 *ret_flags,\n+                       OM_uint32 *time_rec,\n+                       gss_cred_id_t *delegated_cred_handle)\n+{\n+    PP(\">>>> Calling UNIMPLEMENTED gss_accept_sec_context...\");\n+    PP(\"gss_accept_sec_context is not supported in this initiator-only library\");\n+    return GSS_S_FAILURE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_inquire_context(OM_uint32 *minor_status,\n+                    gss_const_ctx_id_t context_handle,\n+                    gss_name_t *src_name,\n+                    gss_name_t *targ_name,\n+                    OM_uint32 *lifetime_rec,\n+                    gss_OID *mech_type,\n+                    OM_uint32 *ctx_flags,\n+                    int *locally_initiated,\n+                    int *open)\n+{\n+    PP(\">>>> Calling gss_inquire_context...\");\n+    CHECK_CONTEXT(context_handle)\n+\n+    gss_name_t n1 = NULL;\n+    gss_name_t n2 = NULL;\n+    if (!context_handle->established) {\n+        return GSS_S_NO_CONTEXT;\n+    }\n+    if (src_name != NULL) {\n+        n1 = new gss_name_struct;\n+        if (n1 == NULL) {\n+            goto err;\n+        }\n+        n1->name = new SEC_WCHAR[lstrlen(context_handle->nnames.sClientName) + 1];\n+        if (n1->name == NULL) {\n+            goto err;\n+        }\n+        PP(\"Allocate new name at %p\", n1->name);\n+        StringCchCopy(n1->name, lstrlen(context_handle->nnames.sClientName) + 1,\n+                context_handle->nnames.sClientName);\n+        *src_name = (gss_name_t) n1;\n+    }\n+    if (targ_name != NULL) {\n+        n2 = new gss_name_struct;\n+        if (n2 == NULL) {\n+            goto err;\n+        }\n+        n2->name = new SEC_WCHAR[lstrlen(context_handle->nnames.sServerName) + 1];\n+        if (n2->name == NULL) {\n+            goto err;\n+        }\n+        PP(\"Allocate new name at %p\", n2->name);\n+        StringCchCopy(n2->name, lstrlen(context_handle->nnames.sServerName) + 1,\n+                context_handle->nnames.sServerName);\n+        *targ_name = (gss_name_t) n2;\n+    }\n+    if (lifetime_rec != NULL) {\n+        SecPkgContext_Lifespan ls;\n+        SECURITY_STATUS ss;\n+        ss = QueryContextAttributes(\n+                (PCtxtHandle)&context_handle->hCtxt,\n+                SECPKG_ATTR_LIFESPAN,\n+                &ls);\n+        if (!SEC_SUCCESS(ss)) {\n+            goto err;\n+        }\n+        *lifetime_rec = seconds_until(0, &ls.tsExpiry);\n+    }\n+    if (mech_type != NULL) {\n+        *mech_type = context_handle->isSPNEGO\n+                ? &SPNEGO_OID : &KRB5_OID;\n+    }\n+    if (ctx_flags != NULL) {\n+        *ctx_flags = context_handle->flags;\n+    }\n+    if (locally_initiated != NULL) {\n+        \/\/ We are always initiator\n+        *locally_initiated = 1;\n+    }\n+    return GSS_S_COMPLETE;\n+err:\n+    if (n1 != NULL) {\n+        if (n1->name != NULL) {\n+            delete[] n1->name;\n+        }\n+        delete n1;\n+        n1 = NULL;\n+    }\n+    if (n2 != NULL) {\n+        if (n2->name != NULL) {\n+            delete[] n2->name;\n+        }\n+        delete n2;\n+        n2 = NULL;\n+    }\n+    return GSS_S_FAILURE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_delete_sec_context(OM_uint32 *minor_status,\n+                       gss_ctx_id_t *context_handle,\n+                       gss_buffer_t output_token)\n+{\n+    PP(\">>>> Calling gss_delete_sec_context...\");\n+    CHECK_CONTEXT(context_handle)\n+\n+    DeleteSecurityContext(&(*context_handle)->hCtxt);\n+    if ((*context_handle)->isLocalCred && (*context_handle)->phCred != NULL) {\n+        FreeCredentialsHandle((*context_handle)->phCred);\n+        (*context_handle)->phCred = NULL;\n+    }\n+    if ((*context_handle)->nnames.sClientName != NULL) {\n+        FreeContextBuffer((*context_handle)->nnames.sClientName);\n+        (*context_handle)->nnames.sClientName = NULL;\n+    }\n+    if ((*context_handle)->nnames.sServerName != NULL) {\n+        FreeContextBuffer((*context_handle)->nnames.sServerName);\n+        (*context_handle)->nnames.sServerName = NULL;\n+    }\n+    delete (*context_handle);\n+    *context_handle = GSS_C_NO_CONTEXT;\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_context_time(OM_uint32 *minor_status,\n+                 gss_const_ctx_id_t context_handle,\n+                 OM_uint32 *time_rec)\n+{\n+    PP(\">>>> Calling IMPLEMENTED gss_context_time...\");\n+    CHECK_CONTEXT(context_handle)\n+    CHECK_OUTPUT(time_rec)\n+\n+    SECURITY_STATUS ss;\n+    SecPkgContext_Lifespan ls;\n+    ss = QueryContextAttributes(\n+            (PCtxtHandle)&context_handle->hCtxt,\n+            SECPKG_ATTR_LIFESPAN,\n+            &ls);\n+    if (ss == SEC_E_OK) {\n+        *time_rec = seconds_until(0, &ls.tsExpiry);\n+        show_time(\"context start\", &ls.tsStart);\n+        show_time(\"context expiry\", &ls.tsExpiry);\n+        return *time_rec == 0 ? GSS_S_CONTEXT_EXPIRED : GSS_S_COMPLETE;\n+    } else {\n+        return GSS_S_FAILURE;\n+    }\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_wrap_size_limit(OM_uint32 *minor_status,\n+                    gss_const_ctx_id_t context_handle,\n+                    int conf_req_flag,\n+                    gss_qop_t qop_req,\n+                    OM_uint32 req_output_size,\n+                    OM_uint32 *max_input_size)\n+{\n+    PP(\">>>> Calling gss_wrap_size_limit...\");\n+    CHECK_CONTEXT(context_handle)\n+    CHECK_OUTPUT(max_input_size)\n+\n+    *max_input_size = req_output_size\n+            - context_handle->SecPkgContextSizes.cbSecurityTrailer\n+            - context_handle->SecPkgContextSizes.cbBlockSize;\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_export_sec_context(OM_uint32 *minor_status,\n+                       gss_ctx_id_t *context_handle,\n+                       gss_buffer_t interprocess_token)\n+{\n+    PP(\">>>> Calling UNIMPLEMENTED gss_export_sec_context...\");\n+    return GSS_S_FAILURE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_get_mic(OM_uint32 *minor_status,\n+            gss_const_ctx_id_t context_handle,\n+            gss_qop_t qop_req,\n+            const gss_buffer_t message_buffer,\n+            gss_buffer_t msg_token)\n+{\n+    PP(\">>>> Calling gss_get_mic...\");\n+    CHECK_CONTEXT(context_handle);\n+    CHECK_BUFFER(message_buffer);\n+    CHECK_OUTPUT(msg_token);\n+\n+    SECURITY_STATUS ss;\n+    SecBufferDesc buffDesc;\n+    SecBuffer secBuff[2];\n+\n+    buffDesc.cBuffers = 2;\n+    buffDesc.pBuffers = secBuff;\n+    buffDesc.ulVersion = SECBUFFER_VERSION;\n+\n+    secBuff[0].BufferType = SECBUFFER_DATA;\n+    secBuff[0].cbBuffer = (ULONG)message_buffer->length;\n+    secBuff[0].pvBuffer = message_buffer->value;\n+\n+    secBuff[1].BufferType = SECBUFFER_TOKEN;\n+    secBuff[1].cbBuffer = context_handle->SecPkgContextSizes.cbMaxSignature;\n+    secBuff[1].pvBuffer = msg_token->value = new char[secBuff[1].cbBuffer];\n+\n+    ss = MakeSignature((PCtxtHandle)&context_handle->hCtxt, 0, &buffDesc, 0);\n+\n+    if (!SEC_SUCCESS(ss)) {\n+        msg_token->length = 0;\n+        msg_token->value = NULL;\n+        delete[] secBuff[1].pvBuffer;\n+        return GSS_S_FAILURE;\n+    }\n+\n+    msg_token->length = secBuff[1].cbBuffer;\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_verify_mic(OM_uint32 *minor_status,\n+               gss_const_ctx_id_t context_handle,\n+               const gss_buffer_t message_buffer,\n+               const gss_buffer_t token_buffer,\n+               gss_qop_t *qop_state)\n+{\n+    PP(\">>>> Calling gss_verify_mic...\");\n+    CHECK_CONTEXT(context_handle);\n+    CHECK_BUFFER(message_buffer);\n+    CHECK_BUFFER(token_buffer);\n+\n+    SECURITY_STATUS ss;\n+    SecBufferDesc buffDesc;\n+    SecBuffer secBuff[2];\n+    ULONG qop;\n+\n+    buffDesc.ulVersion = SECBUFFER_VERSION;\n+    buffDesc.cBuffers = 2;\n+    buffDesc.pBuffers = secBuff;\n+\n+    secBuff[0].BufferType = SECBUFFER_TOKEN;\n+    secBuff[0].cbBuffer = (ULONG)token_buffer->length;\n+    secBuff[0].pvBuffer = token_buffer->value;\n+\n+    secBuff[1].BufferType = SECBUFFER_DATA;\n+    secBuff[1].cbBuffer = (ULONG)message_buffer->length;\n+    secBuff[1].pvBuffer = message_buffer->value;\n+\n+    ss = VerifySignature((PCtxtHandle)&context_handle->hCtxt, &buffDesc, 0, &qop);\n+    if (qop_state) {\n+        *qop_state = qop;\n+    }\n+\n+    if (ss == SEC_E_OK) {\n+        return GSS_S_COMPLETE;\n+    } else if (ss == SEC_E_OUT_OF_SEQUENCE) {\n+        return GSS_S_UNSEQ_TOKEN;\n+    } else {\n+        return GSS_S_BAD_SIG;\n+    }\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_wrap(OM_uint32 *minor_status,\n+         gss_const_ctx_id_t context_handle,\n+         int conf_req_flag,\n+         gss_qop_t qop_req,\n+         const gss_buffer_t input_message_buffer,\n+         int *conf_state,\n+         gss_buffer_t output_message_buffer)\n+{\n+    PP(\">>>> Calling gss_wrap...\");\n+    CHECK_CONTEXT(context_handle);\n+    CHECK_BUFFER(input_message_buffer);\n+    CHECK_OUTPUT(output_message_buffer);\n+\n+    SECURITY_STATUS ss;\n+    SecBufferDesc buffDesc;\n+    SecBuffer secBuff[3];\n+\n+    buffDesc.ulVersion = SECBUFFER_VERSION;\n+    buffDesc.cBuffers = 3;\n+    buffDesc.pBuffers = secBuff;\n+\n+    secBuff[0].BufferType = SECBUFFER_TOKEN;\n+    secBuff[0].cbBuffer = context_handle->SecPkgContextSizes.cbSecurityTrailer;\n+    output_message_buffer->value = secBuff[0].pvBuffer = malloc(\n+            context_handle->SecPkgContextSizes.cbSecurityTrailer\n+                    + input_message_buffer->length\n+                    + context_handle->SecPkgContextSizes.cbBlockSize);;\n+\n+    secBuff[1].BufferType = SECBUFFER_DATA;\n+    secBuff[1].cbBuffer = (ULONG)input_message_buffer->length;\n+    secBuff[1].pvBuffer = malloc(secBuff[1].cbBuffer);\n+    memcpy_s(secBuff[1].pvBuffer, secBuff[1].cbBuffer,\n+            input_message_buffer->value, input_message_buffer->length);\n+\n+    secBuff[2].BufferType = SECBUFFER_PADDING;\n+    secBuff[2].cbBuffer = context_handle->SecPkgContextSizes.cbBlockSize;\n+    secBuff[2].pvBuffer = malloc(secBuff[2].cbBuffer);\n+\n+    ss = EncryptMessage((PCtxtHandle)&context_handle->hCtxt,\n+            conf_req_flag ? 0 : SECQOP_WRAP_NO_ENCRYPT,\n+            &buffDesc, 0);\n+    if (conf_state) {\n+        *conf_state = conf_req_flag;\n+    }\n+\n+    if (!SEC_SUCCESS(ss)) {\n+        free(secBuff[0].pvBuffer);\n+        free(secBuff[1].pvBuffer);\n+        free(secBuff[2].pvBuffer);\n+        output_message_buffer->length = 0;\n+        output_message_buffer->value = NULL;\n+        return GSS_S_FAILURE;\n+    }\n+\n+    memcpy_s((PBYTE)secBuff[0].pvBuffer + secBuff[0].cbBuffer,\n+            input_message_buffer->length + context_handle->SecPkgContextSizes.cbBlockSize,\n+            secBuff[1].pvBuffer,\n+            secBuff[1].cbBuffer);\n+    memcpy_s((PBYTE)secBuff[0].pvBuffer + secBuff[0].cbBuffer + secBuff[1].cbBuffer,\n+            context_handle->SecPkgContextSizes.cbBlockSize,\n+            secBuff[2].pvBuffer,\n+            secBuff[2].cbBuffer);\n+\n+    output_message_buffer->length = secBuff[0].cbBuffer + secBuff[1].cbBuffer\n+            + secBuff[2].cbBuffer;\n+    free(secBuff[1].pvBuffer);\n+    free(secBuff[2].pvBuffer);\n+\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_unwrap(OM_uint32 *minor_status,\n+           gss_const_ctx_id_t context_handle,\n+           const gss_buffer_t input_message_buffer,\n+           gss_buffer_t output_message_buffer,\n+           int *conf_state,\n+           gss_qop_t *qop_state)\n+{\n+    PP(\">>>> Calling gss_unwrap...\");\n+    CHECK_CONTEXT(context_handle);\n+    CHECK_BUFFER(input_message_buffer);\n+    CHECK_OUTPUT(output_message_buffer);\n+\n+    SECURITY_STATUS ss;\n+    SecBufferDesc buffDesc;\n+    SecBuffer secBuff[2];\n+    ULONG ulQop = 0;\n+\n+    buffDesc.cBuffers = 2;\n+    buffDesc.pBuffers = secBuff;\n+    buffDesc.ulVersion = SECBUFFER_VERSION;\n+\n+    secBuff[0].BufferType = SECBUFFER_STREAM;\n+    secBuff[0].cbBuffer = (ULONG)input_message_buffer->length;\n+    secBuff[0].pvBuffer = malloc(input_message_buffer->length);\n+    memcpy_s(secBuff[0].pvBuffer, input_message_buffer->length,\n+            input_message_buffer->value, input_message_buffer->length);\n+\n+    secBuff[1].BufferType = SECBUFFER_DATA;\n+    secBuff[1].cbBuffer = 0;\n+    secBuff[1].pvBuffer = NULL;\n+\n+    ss = DecryptMessage((PCtxtHandle)&context_handle->hCtxt, &buffDesc, 0, &ulQop);\n+    if (qop_state) {\n+        *qop_state = ulQop;\n+    }\n+    if (!SEC_SUCCESS(ss)) {\n+        free(secBuff[0].pvBuffer);\n+        output_message_buffer->length = 0;\n+        output_message_buffer->value = NULL;\n+        return GSS_S_FAILURE;\n+    }\n+\n+    \/\/ Must allocate a new memory block so client can release it correctly\n+    output_message_buffer->length = secBuff[1].cbBuffer;\n+    output_message_buffer->value = new char[secBuff[1].cbBuffer];\n+    memcpy_s(output_message_buffer->value, secBuff[1].cbBuffer,\n+            secBuff[1].pvBuffer, secBuff[1].cbBuffer);\n+    *conf_state = ulQop == SECQOP_WRAP_NO_ENCRYPT ? 0 : 1;\n+\n+    free(secBuff[0].pvBuffer);\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_indicate_mechs(OM_uint32 *minor_status,\n+                   gss_OID_set *mech_set)\n+{\n+    PP(\">>>> Calling gss_indicate_mechs...\");\n+    OM_uint32 major = GSS_S_COMPLETE;\n+\n+    ULONG ccPackages;\n+    PSecPkgInfo packages;\n+    EnumerateSecurityPackages(&ccPackages, &packages);\n+    PP(\"EnumerateSecurityPackages returns %ld\", ccPackages);\n+    for (unsigned int i = 0; i < ccPackages; i++) {\n+        PP(\"#%d: %ls, %ls\\n\", i, packages[i].Name, packages[i].Comment);\n+    }\n+    FreeContextBuffer(packages);\n+\n+    \/\/ Hardcode kerberos and SPNEGO support\n+    major = gss_create_empty_oid_set(minor_status, mech_set);\n+    if (major != GSS_S_COMPLETE) {\n+        goto done;\n+    }\n+\n+    major = gss_add_oid_set_member(minor_status, &KRB5_OID, mech_set);\n+    if (major != GSS_S_COMPLETE) {\n+        goto done;\n+    }\n+\n+    major = gss_add_oid_set_member(minor_status, &SPNEGO_OID, mech_set);\n+    if (major != GSS_S_COMPLETE) {\n+        goto done;\n+    }\n+\n+done:\n+\n+    if (major != GSS_S_COMPLETE) {\n+        gss_release_oid_set(minor_status, mech_set);\n+    }\n+\n+    return major;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_inquire_names_for_mech(OM_uint32 *minor_status,\n+                           const gss_OID mechanism,\n+                           gss_OID_set *name_types)\n+{\n+    PP(\">>>> Calling gss_inquire_names_for_mech...\");\n+    CHECK_OID(mechanism);\n+\n+    if (gss_create_empty_oid_set(minor_status, name_types)) {\n+        return GSS_S_FAILURE;\n+    }\n+    if (gss_add_oid_set_member(minor_status, &USER_NAME_OID, name_types)) {\n+        goto err;\n+    }\n+    if (gss_add_oid_set_member(minor_status, &HOST_SERVICE_NAME_OID, name_types)) {\n+        goto err;\n+    }\n+    if (!is_same_oid(mechanism, &SPNEGO_OID)) {\n+        if (gss_add_oid_set_member(minor_status, &EXPORT_NAME_OID, name_types)) {\n+            goto err;\n+        }\n+    }\n+    return GSS_S_COMPLETE;\n+err:\n+    gss_release_oid_set(minor_status, name_types);\n+    return GSS_S_FAILURE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_add_oid_set_member(OM_uint32 *minor_status,\n+                       const gss_OID member_oid,\n+                       gss_OID_set *oid_set)\n+{\n+    PP(\">>>> Calling gss_add_oid_set_member...\");\n+    CHECK_OID(member_oid);\n+    CHECK_OUTPUT(oid_set);\n+\n+\n+    int count = (int)(*oid_set)->count;\n+    for (int i = 0; i < count; i++) {\n+        if (is_same_oid(&(*oid_set)->elements[i], member_oid)) {\n+            \/\/ already there\n+            return GSS_S_COMPLETE;\n+        }\n+    }\n+    gss_OID existing = (*oid_set)->elements;\n+    gss_OID newcopy = new gss_OID_desc[count + 1];\n+    if (newcopy == NULL) {\n+        return GSS_S_FAILURE;\n+    }\n+    if (existing) {\n+        memcpy_s(newcopy, (count + 1) * sizeof(gss_OID_desc),\n+                existing, count * sizeof(gss_OID_desc));\n+    }\n+    newcopy[count].length = member_oid->length;\n+    newcopy[count].elements = new char[member_oid->length];\n+    if (newcopy[count].elements == NULL) {\n+        delete[] newcopy;\n+        return GSS_S_FAILURE;\n+    }\n+    memcpy_s(newcopy[count].elements, member_oid->length,\n+            member_oid->elements, member_oid->length);\n+    (*oid_set)->elements = newcopy;\n+    (*oid_set)->count++;\n+    if (existing) {\n+        delete[] existing;\n+    }\n+\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_display_status(OM_uint32 *minor_status,\n+                   OM_uint32 status_value,\n+                   int status_type,\n+                   const gss_OID mech_type,\n+                   OM_uint32 *message_context,\n+                   gss_buffer_t status_string)\n+{\n+    PP(\">>>> Calling gss_display_status...\");\n+    TCHAR msg[256];\n+    int len = FormatMessage(\n+            FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n+            0, status_value,\n+            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n+            msg, 256, 0);\n+    if (len > 0) {\n+        status_string->value = new char[len + 20];\n+        status_string->length = sprintf_s(\n+                (LPSTR)status_string->value, len + 19,\n+                \"(%lx) %ls\", status_value, msg);\n+    } else {\n+        status_string->value = new char[33];\n+        status_string->length = sprintf_s(\n+                (LPSTR)status_string->value, 32,\n+                \"status is %lx\", status_value);\n+    }\n+    if (status_string->length <= 0) {\n+        gss_release_buffer(NULL, status_string);\n+        status_string = GSS_C_NO_BUFFER;\n+        return GSS_S_FAILURE;\n+    } else {\n+        return GSS_S_COMPLETE;\n+    }\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_create_empty_oid_set(OM_uint32 *minor_status,\n+                         gss_OID_set *oid_set)\n+{\n+    PP(\">>>> Calling gss_create_empty_oid_set...\");\n+    CHECK_OUTPUT(oid_set);\n+\n+    if (*oid_set = new gss_OID_set_desc) {\n+        memset(*oid_set, 0, sizeof(gss_OID_set_desc));\n+        return GSS_S_COMPLETE;\n+    }\n+    return GSS_S_FAILURE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_release_oid_set(OM_uint32 *minor_status,\n+                    gss_OID_set *set)\n+{\n+    PP(\">>>> Calling gss_release_oid_set...\");\n+    if (set == NULL || *set == GSS_C_NO_OID_SET) {\n+        return GSS_S_COMPLETE;\n+    }\n+    for (int i = 0; i < (*set)->count; i++) {\n+        delete[] (*set)->elements[i].elements;\n+    }\n+    delete[] (*set)->elements;\n+    delete *set;\n+    *set = GSS_C_NO_OID_SET;\n+    return GSS_S_COMPLETE;\n+}\n+\n+__declspec(dllexport) OM_uint32\n+gss_release_buffer(OM_uint32 *minor_status,\n+                   gss_buffer_t buffer)\n+{\n+    PP(\">>>> Calling gss_release_buffer...\");\n+    if (buffer == NULL || buffer == GSS_C_NO_BUFFER) {\n+        return GSS_S_COMPLETE;\n+    }\n+    if (buffer->value) {\n+        delete[] buffer->value;\n+        buffer->value = NULL;\n+    }\n+    buffer->length = 0;\n+    return GSS_S_COMPLETE;\n+}\n+\n+\/* End implemented section *\/\n+\n+#ifdef __cplusplus\n+}\n+#endif\n","filename":"jdk\/src\/windows\/native\/sun\/security\/jgss\/sspi_bridge\/sspi.cpp","additions":1575,"deletions":0,"binary":false,"changes":1575,"status":"added"}]}