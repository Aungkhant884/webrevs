{"files":[{"patch":"@@ -1659,1 +1659,5 @@\n-  Method* moop = method();\n+  \/\/ This is a bad time for a safepoint.  We don't want\n+  \/\/ this nmethod to get unloaded while we're queueing the event.\n+  No_Safepoint_Verifier nsv;\n+\n+  Method* m = method();\n@@ -1662,6 +1666,6 @@\n-      moop->klass_name()->bytes(),\n-      moop->klass_name()->utf8_length(),\n-      moop->name()->bytes(),\n-      moop->name()->utf8_length(),\n-      moop->signature()->bytes(),\n-      moop->signature()->utf8_length(),\n+      m->klass_name()->bytes(),\n+      m->klass_name()->utf8_length(),\n+      m->name()->bytes(),\n+      m->name()->utf8_length(),\n+      m->signature()->bytes(),\n+      m->signature()->utf8_length(),\n@@ -1671,6 +1675,6 @@\n-      (char *) moop->klass_name()->bytes(),\n-      moop->klass_name()->utf8_length(),\n-      (char *) moop->name()->bytes(),\n-      moop->name()->utf8_length(),\n-      (char *) moop->signature()->bytes(),\n-      moop->signature()->utf8_length(),\n+      (char *) m->klass_name()->bytes(),\n+      m->klass_name()->utf8_length(),\n+      (char *) m->name()->bytes(),\n+      m->name()->utf8_length(),\n+      (char *) m->signature()->bytes(),\n+      m->signature()->utf8_length(),\n","filename":"hotspot\/src\/share\/vm\/code\/nmethod.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1789,1 +1789,1 @@\n-        MutexLocker ml(JmethodIdCreation_lock);\n+        MutexLockerEx ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n@@ -1839,1 +1839,1 @@\n-      MutexLocker ml(JmethodIdCreation_lock);\n+      MutexLockerEx ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n","filename":"hotspot\/src\/share\/vm\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1757,1 +1757,1 @@\n-      assert(sd->method() != NULL, \"sd->method() cannot be null.\");\n+      guarantee(sd->method() != NULL, \"sd->method() cannot be null.\");\n","filename":"hotspot\/src\/share\/vm\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -900,3 +900,0 @@\n-  \/\/ Keep the nmethod alive until the ServiceThread can process\n-  \/\/ this deferred event.\n-  nmethodLocker::lock_nmethod(nm);\n@@ -935,1 +932,1 @@\n-  assert(ServiceThread::is_service_thread(Thread::current()),\n+  assert(Thread::current()->is_service_thread(),\n@@ -941,2 +938,0 @@\n-      \/\/ done with the deferred event so unlock the nmethod\n-      nmethodLocker::unlock_nmethod(nm);\n@@ -972,0 +967,15 @@\n+\/\/ Keep the nmethod for compiled_method_load from being unloaded.\n+void JvmtiDeferredEvent::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+  if (cf != NULL && _type == TYPE_COMPILED_METHOD_LOAD) {\n+    cf->do_code_blob(_event_data.compiled_method_load);\n+  }\n+}\n+\n+\/\/ The sweeper calls this and marks the nmethods here on the stack so that\n+\/\/ they cannot be turned into zombies while in the queue.\n+void JvmtiDeferredEvent::nmethods_do(CodeBlobClosure* cf) {\n+  if (cf != NULL && _type == TYPE_COMPILED_METHOD_LOAD) {\n+    cf->do_code_blob(_event_data.compiled_method_load);\n+  }  \/\/ May add UNLOAD event but it doesn't work yet.\n+}\n+\n@@ -1087,0 +1097,12 @@\n+\n+void JvmtiDeferredEventQueue::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+     node->event().oops_do(f, cf);\n+  }\n+}\n+\n+void JvmtiDeferredEventQueue::nmethods_do(CodeBlobClosure* cf) {\n+  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+     node->event().nmethods_do(cf);\n+  }\n+}\n","filename":"hotspot\/src\/share\/vm\/prims\/jvmtiImpl.cpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -495,0 +495,4 @@\n+  \/\/ Sweeper support to keep nmethods from being zombied while in the queue.\n+  void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  \/\/ GC support to keep nmethod from being unloaded while in the queue.\n+  void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n@@ -514,1 +518,1 @@\n-    const JvmtiDeferredEvent& event() const { return _event; }\n+    JvmtiDeferredEvent& event() { return _event; }\n@@ -532,0 +536,4 @@\n+  \/\/ Sweeper support to keep nmethods from being zombied while in the queue.\n+  static void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  \/\/ GC support to keep nmethod from being unloaded while in the queue.\n+  static void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n","filename":"hotspot\/src\/share\/vm\/prims\/jvmtiImpl.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+JvmtiDeferredEvent* ServiceThread::_jvmti_event = NULL;\n@@ -115,0 +116,1 @@\n+        \/\/ Get the event under the Service_lock\n@@ -116,0 +118,1 @@\n+        _jvmti_event = &jvmti_event;\n@@ -120,1 +123,2 @@\n-      jvmti_event.post();\n+      _jvmti_event->post();\n+      _jvmti_event = NULL;  \/\/ reset\n@@ -141,2 +145,22 @@\n-bool ServiceThread::is_service_thread(Thread* thread) {\n-  return thread == _instance;\n+void ServiceThread::oops_do(OopClosure* f, CLDClosure* cld_f, CodeBlobClosure* cf) {\n+  JavaThread::oops_do(f, cld_f, cf);\n+  \/\/ The ServiceThread \"owns\" the JVMTI Deferred events, scan them here\n+  \/\/ to keep them alive until they are processed.\n+  if (cf != NULL) {\n+    if (_jvmti_event != NULL) {\n+      _jvmti_event->oops_do(f, cf);\n+    }\n+    MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    JvmtiDeferredEventQueue::oops_do(f, cf);\n+  }\n+}\n+\n+void ServiceThread::nmethods_do(CodeBlobClosure* cf) {\n+  JavaThread::nmethods_do(cf);\n+  if (cf != NULL) {\n+    if (_jvmti_event != NULL) {\n+      _jvmti_event->nmethods_do(cf);\n+    }\n+    MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    JvmtiDeferredEventQueue::nmethods_do(cf);\n+  }\n","filename":"hotspot\/src\/share\/vm\/runtime\/serviceThread.cpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+class JvmtiDeferredEvent;\n+\n@@ -35,1 +37,0 @@\n-\n@@ -37,0 +38,1 @@\n+  static JvmtiDeferredEvent* _jvmti_event;\n@@ -46,0 +48,1 @@\n+  bool is_service_thread() const                 { return true; }\n@@ -47,2 +50,3 @@\n-  \/\/ Returns true if the passed thread is the service thread.\n-  static bool is_service_thread(Thread* thread);\n+  \/\/ GC support\n+  void oops_do(OopClosure* f, CLDClosure* cld_f, CodeBlobClosure* cf);\n+  void nmethods_do(CodeBlobClosure* cf);\n","filename":"hotspot\/src\/share\/vm\/runtime\/serviceThread.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+  virtual bool is_service_thread() const             { return false; }\n","filename":"hotspot\/src\/share\/vm\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}