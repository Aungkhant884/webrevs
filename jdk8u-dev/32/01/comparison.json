{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-  static bool _shutdown;\n+  static volatile bool _shutdown;\n@@ -71,1 +71,1 @@\n-  static int _listener;\n+  static volatile int _listener;\n@@ -134,1 +134,1 @@\n-int AixAttachListener::_listener = -1;\n+volatile int AixAttachListener::_listener = -1;\n@@ -137,1 +137,1 @@\n-bool AixAttachListener::_shutdown = false;\n+volatile bool AixAttachListener::_shutdown = false;\n@@ -182,1 +182,0 @@\n-      AixAttachListener::set_listener(-1);\n@@ -366,0 +365,2 @@\n+      ::close(listener());\n+      set_listener(-1);\n@@ -368,1 +369,1 @@\n-    s=::accept(listener(), &addr, &len);\n+    s = ::accept(listener(), &addr, &len);\n@@ -370,0 +371,2 @@\n+      ::close(listener());\n+      set_listener(-1);\n@@ -532,3 +535,7 @@\n-    while (AttachListener::transit_state(AL_INITIALIZING,\n-                                         AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n-      os::yield();\n+    {\n+      \/\/ avoid deadlock if AttachListener thread is blocked at safepoint\n+      ThreadBlockInVM tbivm(JavaThread::current());\n+      while (AttachListener::transit_state(AL_INITIALIZING,\n+                                           AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n+        os::yield();\n+      }\n","filename":"hotspot\/src\/os\/aix\/vm\/attachListener_aix.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-  static int _listener;\n+  static volatile int _listener;\n@@ -128,1 +128,1 @@\n-int BsdAttachListener::_listener = -1;\n+volatile int BsdAttachListener::_listener = -1;\n@@ -497,5 +497,7 @@\n-\n-    while (AttachListener::transit_state(AL_INITIALIZING,\n-\n-                                         AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n-      os::yield();\n+    {\n+      \/\/ avoid deadlock if AttachListener thread is blocked at safepoint\n+      ThreadBlockInVM tbivm(JavaThread::current());\n+      while (AttachListener::transit_state(AL_INITIALIZING,\n+                                           AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n+        os::yield();\n+      }\n","filename":"hotspot\/src\/os\/bsd\/vm\/attachListener_bsd.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-  static int _listener;\n+  static volatile int _listener;\n@@ -128,1 +128,1 @@\n-int LinuxAttachListener::_listener = -1;\n+volatile int LinuxAttachListener::_listener = -1;\n@@ -492,3 +492,7 @@\n-    while (AttachListener::transit_state(AL_INITIALIZING,\n-                                         AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n-      os::yield();\n+    {\n+      \/\/ avoid deadlock if AttachListener thread is blocked at safepoint\n+      ThreadBlockInVM tbivm(JavaThread::current());\n+      while (AttachListener::transit_state(AL_INITIALIZING,\n+                                           AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n+        os::yield();\n+      }\n","filename":"hotspot\/src\/os\/linux\/vm\/attachListener_linux.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.io.File;\n@@ -33,0 +34,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -37,0 +39,1 @@\n+import jdk.test.lib.process.ProcessTools;\n@@ -40,0 +43,3 @@\n+    \/\/ timeout (in seconds)\n+    private static final long timeout = Utils.adjustTimeout(60);\n+\n@@ -45,2 +51,1 @@\n-        ProcessBuilder pb = new ProcessBuilder(jcmd.getCommand());\n-        Process jcmdProc = pb.start();\n+        Process jcmdProc = ProcessTools.startProcess(\"jcmd\", new ProcessBuilder(jcmd.getCommand()));\n@@ -50,1 +55,5 @@\n-        jcmdProc.waitFor();\n+        if (!jcmdProc.waitFor(timeout, TimeUnit.SECONDS)) {\n+            log(\"jcmd is still running after \" + timeout + \" seconds, terminating...\");\n+            jcmdProc.destroy();\n+            jcmdProc.waitFor();\n+        }\n@@ -52,2 +61,3 @@\n-        System.out.println(out.getStdout());\n-        System.err.println(out.getStderr());\n+        log(\"jcmd stdout: [\" + out.getStdout() + \"];\\n\" +\n+            \"jcmd  stderr: [\" + out.getStderr() + \"]\\n\" +\n+            \"jcmd  exitValue = \" + out.getExitValue());\n@@ -55,1 +65,2 @@\n-        out.stderrShouldBeEmpty();\n+        out.shouldHaveExitValue(0)\n+           .stderrShouldBeEmptyIgnoreVMWarnings();\n@@ -67,1 +78,1 @@\n-            var sockFile = Path.of(System.getProperty(\"java.io.tmpdir\"),\n+            File sockFile = Path.of(System.getProperty(\"java.io.tmpdir\"),\n@@ -70,1 +81,1 @@\n-            System.out.println(\"Remove \" + sockFile.toString());\n+            log(\"Remove \" + sockFile.toString());\n@@ -80,0 +91,3 @@\n+    static void log(Object s) {\n+        System.out.println(String.valueOf(s));\n+    }\n","filename":"hotspot\/test\/serviceability\/attach\/RemovingUnixDomainSocketTest.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -233,1 +234,5 @@\n-            appProcess.waitFor();\n+            \/\/ If the app hangs, we don't want to wait for the to test timeout.\n+            if (!appProcess.waitFor(Utils.adjustTimeout(appWaitTime), TimeUnit.SECONDS)) {\n+                appProcess.destroy();\n+                appProcess.waitFor();\n+            }\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/apps\/LingeredApp.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}