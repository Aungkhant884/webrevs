{"files":[{"patch":"@@ -4,1 +4,1 @@\n-version=openjdk8u345\n+version=openjdk8u352\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-JDK_UPDATE_VERSION=345\n+JDK_UPDATE_VERSION=352\n","filename":"common\/autoconf\/version-numbers","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,3 +2,2 @@\n-\/\/ Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2014, 2019, Red Hat Inc.\n-\/\/ All rights reserved.\n+\/\/ Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2014, 2022, Red Hat, Inc. All rights reserved.\n@@ -2239,0 +2238,40 @@\n+  static void loadStore(MacroAssembler masm, mem_insn insn,\n+                         Register reg, int opcode,\n+                         Register base, int index, int size, int disp,\n+                         int size_in_memory)\n+  {\n+    Address::extend scale;\n+\n+    \/\/ Hooboy, this is fugly.  We need a way to communicate to the\n+    \/\/ encoder that the index needs to be sign extended, so we have to\n+    \/\/ enumerate all the cases.\n+    switch (opcode) {\n+    case INDINDEXSCALEDOFFSETI2L:\n+    case INDINDEXSCALEDI2L:\n+    case INDINDEXSCALEDOFFSETI2LN:\n+    case INDINDEXSCALEDI2LN:\n+    case INDINDEXOFFSETI2L:\n+    case INDINDEXOFFSETI2LN:\n+      scale = Address::sxtw(size);\n+      break;\n+    default:\n+      scale = Address::lsl(size);\n+    }\n+\n+    if (index == -1) {\n+      Address addr(base, disp);\n+      \/* Fix up any out-of-range offsets. *\/\n+      assert_different_registers(rscratch1, base);\n+      assert_different_registers(rscratch1, reg);\n+      addr = masm.legitimize_address(addr, size_in_memory, rscratch1);\n+      (masm.*insn)(reg, addr);\n+    } else {\n+      if (disp == 0) {\n+        (masm.*insn)(reg, Address(base, as_Register(index), scale));\n+      } else {\n+        masm.lea(rscratch1, Address(base, disp));\n+        (masm.*insn)(reg, Address(rscratch1, as_Register(index), scale));\n+      }\n+    }\n+  }\n+\n@@ -2327,0 +2366,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2333,0 +2374,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2339,0 +2382,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2345,0 +2390,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2351,0 +2398,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2357,0 +2406,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2363,0 +2414,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2369,0 +2422,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2375,0 +2430,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2381,0 +2438,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2387,0 +2446,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2393,0 +2454,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2399,0 +2462,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2405,0 +2470,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2411,0 +2478,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2417,0 +2486,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2423,0 +2494,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2429,0 +2502,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2435,0 +2510,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2441,0 +2518,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2448,0 +2527,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2451,1 +2532,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2454,0 +2535,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2457,1 +2540,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 2);\n@@ -2460,0 +2543,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2463,1 +2548,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2466,0 +2551,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2469,1 +2556,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 4);\n@@ -2472,0 +2559,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2483,1 +2572,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);\n@@ -2486,0 +2575,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2489,1 +2580,1 @@\n-               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, 8);\n@@ -2492,0 +2583,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2498,0 +2591,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2504,0 +2599,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2510,0 +2607,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2516,0 +2615,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -2521,1 +2622,1 @@\n-\n+ \n","filename":"hotspot\/src\/cpu\/aarch64\/vm\/aarch64.ad","additions":111,"deletions":10,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1,3 +1,45 @@\n-define(choose, `loadStore($1, &MacroAssembler::$3, $2, $4,\n-               $5, $6, $7, $8);dnl\n-\n+dnl Copyright (c) 2014, 2022 Red Hat Inc. All rights reserved.\n+dnl DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+dnl\n+dnl This code is free software; you can redistribute it and\/or modify it\n+dnl under the terms of the GNU General Public License version 2 only, as\n+dnl published by the Free Software Foundation.\n+dnl\n+dnl This code is distributed in the hope that it will be useful, but WITHOUT\n+dnl ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+dnl FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+dnl version 2 for more details (a copy is included in the LICENSE file that\n+dnl accompanied this code).\n+dnl\n+dnl You should have received a copy of the GNU General Public License version\n+dnl 2 along with this work; if not, write to the Free Software Foundation,\n+dnl Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+dnl\n+dnl Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+dnl or visit www.oracle.com if you need additional information or have any\n+dnl questions.\n+dnl\n+dnl \n+dnl Process this file with m4 ad_encode.m4 to generate the load\/store\n+dnl patterns used in aarch64.ad.\n+dnl\n+dnl\n+dnl\n+define(LOAD,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{\n+    $3Register dst_reg = as_$3Register($dst$$reg);\n+    loadStore(MacroAssembler(&cbuf), &MacroAssembler::$2, dst_reg, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+define(LOADV,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{\n+    FloatRegister dst_reg = as_FloatRegister($dst$$reg);\n+    loadStore(MacroAssembler(&cbuf), &MacroAssembler::ldr, dst_reg, MacroAssembler::$3,\n+       $mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n@@ -5,21 +47,3 @@\n-define(access, `\n-    $3Register $1_reg = as_$3Register($$1$$reg);\n-    $4choose(MacroAssembler(&cbuf), $1_reg,$2,$mem->opcode(),\n-        as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)')dnl\n-define(load,`\n-  enc_class aarch64_enc_$2($1 dst, memory mem) %{dnl\n-access(dst,$2,$3)')dnl\n-load(iRegI,ldrsbw)\n-load(iRegI,ldrsb)\n-load(iRegI,ldrb)\n-load(iRegL,ldrb)\n-load(iRegI,ldrshw)\n-load(iRegI,ldrsh)\n-load(iRegI,ldrh)\n-load(iRegL,ldrh)\n-load(iRegI,ldrw)\n-load(iRegL,ldrw)\n-load(iRegL,ldrsw)\n-load(iRegL,ldr)\n-load(vRegF,ldrs,Float)\n-load(vRegD,ldrd,Float)\n+dnl\n+dnl\n+dnl\n@@ -27,2 +51,10 @@\n-  enc_class aarch64_enc_$2($1 src, memory mem) %{dnl\n-access(src,$2,$3,$4)')dnl\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{\n+    $3Register src_reg = as_$3Register($src$$reg);\n+    $4loadStore(MacroAssembler(&cbuf), &MacroAssembler::$2, src_reg, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n@@ -30,0 +62,2 @@\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n@@ -32,2 +66,56 @@\n-    choose(_masm,zr,$2,$mem->opcode(),\n-        as_$3Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)')dnl\n+    $4loadStore(_masm, &MacroAssembler::$2, zr, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+define(STOREL,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{\n+    $3Register src_reg = as_$3Register($src$$reg);\n+    $4loadStore(MacroAssembler(&cbuf), &MacroAssembler::$2, src_reg, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, $5);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+define(STOREL0,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2`'0(memory mem) %{\n+    MacroAssembler _masm(&cbuf);\n+    $4loadStore(_masm, &MacroAssembler::$2, zr, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp, $5);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+define(STOREV,`\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{\n+    FloatRegister src_reg = as_FloatRegister($src$$reg);\n+    loadStore(MacroAssembler(&cbuf), &MacroAssembler::str, src_reg, MacroAssembler::$3,\n+       $mem->opcode(), as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}')dnl\n+dnl\n+dnl\n+dnl\n+LOAD(iRegI,ldrsbw)\n+LOAD(iRegI,ldrsb)\n+LOAD(iRegI,ldrb)\n+LOAD(iRegL,ldrb)\n+LOAD(iRegI,ldrshw)\n+LOAD(iRegI,ldrsh)\n+LOAD(iRegI,ldrh)\n+LOAD(iRegL,ldrh)\n+LOAD(iRegI,ldrw)\n+LOAD(iRegL,ldrw)\n+LOAD(iRegL,ldrsw)\n+LOAD(iRegL,ldr)\n+LOAD(vRegF,ldrs,Float)\n+LOAD(vRegD,ldrd,Float)\n+LOADV(vecD,ldrvS,S)\n+LOADV(vecD,ldrvD,D)\n+LOADV(vecX,ldrvQ,Q)\n@@ -36,5 +124,15 @@\n-STORE(iRegI,strh)\n-STORE0(iRegI,strh)\n-STORE(iRegI,strw)\n-STORE0(iRegI,strw)\n-STORE(iRegL,str,,\n+\n+  \/\/ This encoding class is generated automatically from ad_encode.m4.\n+  \/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n+    MacroAssembler _masm(&cbuf);\n+    __ membar(Assembler::StoreStore);\n+    loadStore(_masm, &MacroAssembler::strb, zr, $mem->opcode(),\n+               as_Register($mem$$base), $mem$$index, $mem$$scale, $mem$$disp);\n+  %}dnl\n+\n+STOREL(iRegI,strh,,,2)\n+STOREL0(iRegI,strh,,,2)\n+STOREL(iRegI,strw,,,4)\n+STOREL0(iRegI,strw,,,4)\n+STOREL(iRegL,str,,\n@@ -49,2 +147,2 @@\n-    ')\n-STORE0(iRegL,str)\n+    ',8)\n+STOREL0(iRegL,str,,,8)\n@@ -53,21 +151,3 @@\n-\n-  enc_class aarch64_enc_strw_immn(immN src, memory mem) %{\n-    MacroAssembler _masm(&cbuf);\n-    address con = (address)$src$$constant;\n-    \/\/ need to do this the hard way until we can manage relocs\n-    \/\/ for 32 bit constants\n-    __ movoop(rscratch2, (jobject)con);\n-    if (con) __ encode_heap_oop_not_null(rscratch2);\n-    choose(_masm,rscratch2,strw,$mem->opcode(),\n-        as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)\n-\n-  enc_class aarch64_enc_strw_immnk(immN src, memory mem) %{\n-    MacroAssembler _masm(&cbuf);\n-    address con = (address)$src$$constant;\n-    \/\/ need to do this the hard way until we can manage relocs\n-    \/\/ for 32 bit constants\n-    __ movoop(rscratch2, (jobject)con);\n-    __ encode_klass_not_null(rscratch2);\n-    choose(_masm,rscratch2,strw,$mem->opcode(),\n-        as_Register($mem$$base),$mem$$index,$mem$$scale,$mem$$disp)\n-\n+STOREV(vecD,strvS,S)\n+STOREV(vecD,strvD,D)\n+STOREV(vecX,strvQ,Q)\n","filename":"hotspot\/src\/cpu\/aarch64\/vm\/ad_encode.m4","additions":136,"deletions":56,"binary":false,"changes":192,"status":"modified"},{"patch":"@@ -1983,0 +1983,3 @@\n+      case T_METADATA:\n+        imm = (intptr_t)(opr2->as_constant_ptr()->as_metadata());\n+        break;\n","filename":"hotspot\/src\/cpu\/aarch64\/vm\/c1_LIRAssembler_aarch64.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1684,0 +1684,12 @@\n+        case T_METADATA:\n+          \/\/ We only need, for now, comparison with NULL for metadata.\n+          { assert(condition == lir_cond_equal || condition == lir_cond_notEqual, \"oops\");\n+            Metadata* m = opr2->as_constant_ptr()->as_metadata();\n+            if (m == NULL) {\n+              __ cmp(opr1->as_register(), 0);\n+            } else {\n+              ShouldNotReachHere();\n+            }\n+          }\n+          break;\n+\n","filename":"hotspot\/src\/cpu\/sparc\/vm\/c1_LIRAssembler_sparc.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2721,0 +2721,9 @@\n+      } else if (c->type() == T_METADATA) {\n+        \/\/ All we need for now is a comparison with NULL for equality.\n+        assert(condition == lir_cond_equal || condition == lir_cond_notEqual, \"oops\");\n+        Metadata* m = c->as_metadata();\n+        if (m == NULL) {\n+          __ cmpptr(reg1, (int32_t)0);\n+        } else {\n+          ShouldNotReachHere();\n+        }\n","filename":"hotspot\/src\/cpu\/x86\/vm\/c1_LIRAssembler_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -466,1 +466,1 @@\n-      ciType* t = c->value()->as_instance()->java_mirror_type();\n+      ciType* t = c->value()->java_mirror_type();\n@@ -482,0 +482,11 @@\n+  case vmIntrinsics::_isPrimitive        : {\n+    assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+    \/\/ Class.isPrimitive is known on constant classes:\n+    InstanceConstant* c = x->argument_at(0)->type()->as_InstanceConstant();\n+    if (c != NULL && !c->value()->is_null_object()) {\n+      ciType* t = c->value()->java_mirror_type();\n+      set_constant(t->is_primitive_type());\n+    }\n+    break;\n+  }\n","filename":"hotspot\/src\/share\/vm\/c1\/c1_Canonicalizer.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3517,0 +3517,1 @@\n+    case vmIntrinsics::_isPrimitive   :\n","filename":"hotspot\/src\/share\/vm\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1293,0 +1293,18 @@\n+\/\/ java.lang.Class::isPrimitive()\n+void LIRGenerator::do_isPrimitive(Intrinsic* x) {\n+  assert(x->number_of_arguments() == 1, \"wrong type\");\n+\n+  LIRItem rcvr(x->argument_at(0), this);\n+  rcvr.load_item();\n+  LIR_Opr temp = new_register(T_METADATA);\n+  LIR_Opr result = rlock_result(x);\n+\n+  CodeEmitInfo* info = NULL;\n+  if (x->needs_null_check()) {\n+    info = state_for(x);\n+  }\n+\n+  __ move(new LIR_Address(rcvr.result(), java_lang_Class::klass_offset_in_bytes(), T_ADDRESS), temp, info);\n+  __ cmp(lir_cond_notEqual, temp, LIR_OprFact::metadataConst(0));\n+  __ cmove(lir_cond_notEqual, LIR_OprFact::intConst(0), LIR_OprFact::intConst(1), result, T_BOOLEAN);\n+}\n@@ -3190,0 +3208,1 @@\n+  case vmIntrinsics::_isPrimitive:    do_isPrimitive(x);   break;\n","filename":"hotspot\/src\/share\/vm\/c1\/c1_LIRGenerator.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -245,0 +245,1 @@\n+  void do_isPrimitive(Intrinsic* x);\n","filename":"hotspot\/src\/share\/vm\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -273,0 +273,4 @@\n+static bool is_in_asgct() {\n+  Thread* current_thread = Thread::current_or_null();\n+  return current_thread != NULL && current_thread->is_Java_thread() && ((JavaThread*)current_thread)->in_asgct();\n+}\n@@ -281,2 +285,6 @@\n-  guarantee(!result->is_zombie() || result->is_locked_by_vm() || is_error_reported(), \"unsafe access to zombie method\");\n-  return result;\n+  bool is_zombie = result != NULL && result->is_zombie();\n+  bool is_result_safe = !is_zombie || result->is_locked_by_vm() || is_error_reported();\n+  guarantee(is_result_safe || is_in_asgct(), \"unsafe access to zombie method\");\n+  \/\/ When in ASGCT the previous gurantee will pass for a zombie method but we still don't want that code blob returned in order\n+  \/\/ to minimize the chance of accessing dead memory\n+  return is_result_safe ? result : NULL;\n","filename":"hotspot\/src\/share\/vm\/code\/codeCache.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1659,1 +1659,5 @@\n-  Method* moop = method();\n+  \/\/ This is a bad time for a safepoint.  We don't want\n+  \/\/ this nmethod to get unloaded while we're queueing the event.\n+  No_Safepoint_Verifier nsv;\n+\n+  Method* m = method();\n@@ -1662,6 +1666,6 @@\n-      moop->klass_name()->bytes(),\n-      moop->klass_name()->utf8_length(),\n-      moop->name()->bytes(),\n-      moop->name()->utf8_length(),\n-      moop->signature()->bytes(),\n-      moop->signature()->utf8_length(),\n+      m->klass_name()->bytes(),\n+      m->klass_name()->utf8_length(),\n+      m->name()->bytes(),\n+      m->name()->utf8_length(),\n+      m->signature()->bytes(),\n+      m->signature()->utf8_length(),\n@@ -1671,6 +1675,6 @@\n-      (char *) moop->klass_name()->bytes(),\n-      moop->klass_name()->utf8_length(),\n-      (char *) moop->name()->bytes(),\n-      moop->name()->utf8_length(),\n-      (char *) moop->signature()->bytes(),\n-      moop->signature()->utf8_length(),\n+      (char *) m->klass_name()->bytes(),\n+      m->klass_name()->utf8_length(),\n+      (char *) m->name()->bytes(),\n+      m->name()->utf8_length(),\n+      (char *) m->signature()->bytes(),\n+      m->signature()->utf8_length(),\n","filename":"hotspot\/src\/share\/vm\/code\/nmethod.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -50,0 +51,2 @@\n+static JfrCheckpointWriter* _writer = NULL;\n+static int primitives_count = 9;\n@@ -63,0 +66,41 @@\n+static traceid create_symbol_id(traceid artifact_id) {\n+  return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;\n+}\n+\n+static bool is_initial_typeset_for_chunk(bool class_unload) {\n+  return !class_unload;\n+}\n+\n+static traceid mark_symbol(Symbol* symbol, JfrArtifactSet* artifacts) {\n+  return symbol != NULL ? create_symbol_id(artifacts->mark(symbol)) : 0;\n+}\n+\n+static const char* primitive_name(KlassPtr type_array_klass) {\n+  switch (type_array_klass->name()->base()[1]) {\n+    case JVM_SIGNATURE_BOOLEAN: return \"boolean\";\n+    case JVM_SIGNATURE_BYTE: return \"byte\";\n+    case JVM_SIGNATURE_CHAR: return \"char\";\n+    case JVM_SIGNATURE_SHORT: return \"short\";\n+    case JVM_SIGNATURE_INT: return \"int\";\n+    case JVM_SIGNATURE_LONG: return \"long\";\n+    case JVM_SIGNATURE_FLOAT: return \"float\";\n+    case JVM_SIGNATURE_DOUBLE: return \"double\";\n+  }\n+  assert(false, \"invalid type array klass\");\n+  return NULL;\n+}\n+\n+static Symbol* primitive_symbol(KlassPtr type_array_klass) {\n+  if (type_array_klass == NULL) {\n+    \/\/ void.class\n+    static Symbol* const void_class_name = SymbolTable::probe(\"void\", 4);\n+    assert(void_class_name != NULL, \"invariant\");\n+    return void_class_name;\n+  }\n+  const char* const primitive_type_str = primitive_name(type_array_klass);\n+  assert(primitive_type_str != NULL, \"invariant\");\n+  Symbol* const primitive_type_sym = SymbolTable::probe(primitive_type_str, (int)strlen(primitive_type_str));\n+  assert(primitive_type_sym != NULL, \"invariant\");\n+  return primitive_type_sym;\n+}\n+\n@@ -86,0 +130,4 @@\n+static u4 get_primitive_flags() {\n+  return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n+}\n+\n@@ -468,1 +516,15 @@\n-    return;\n+  } else {\n+    TagLeakpKlassArtifact tagging(_class_unload);\n+    LeakKlassWriter lkw(leakp_writer, _artifacts, _class_unload);\n+    LeakpKlassArtifactTagging lpkat(&tagging, &lkw);\n+    CompositeKlassWriter ckw(&lpkat, &kw);\n+    CompositeKlassWriterRegistration ckwr(&ckw, &reg);\n+    CompositeKlassCallback callback(&ckwr);\n+    _subsystem_callback = &callback;\n+    do_klasses();\n+  }\n+\n+  if (is_initial_typeset_for_chunk(_class_unload)) {\n+    \/\/ Because the set of primitives is written outside the callback,\n+    \/\/ their count is not automatically incremented.\n+    kw.add(primitives_count);\n@@ -470,8 +532,0 @@\n-  TagLeakpKlassArtifact tagging(_class_unload);\n-  LeakKlassWriter lkw(leakp_writer, _artifacts, _class_unload);\n-  LeakpKlassArtifactTagging lpkat(&tagging, &lkw);\n-  CompositeKlassWriter ckw(&lpkat, &kw);\n-  CompositeKlassWriterRegistration ckwr(&ckw, &reg);\n-  CompositeKlassCallback callback(&ckwr);\n-  _subsystem_callback = &callback;\n-  do_klasses();\n@@ -656,0 +710,39 @@\n+static traceid primitive_id(KlassPtr array_klass) {\n+  if (array_klass == NULL) {\n+    \/\/ The first klass id is reserved for the void.class.\n+    return MaxJfrEventId + 101;\n+  }\n+  \/\/ Derive the traceid for a primitive mirror from its associated array klass (+1).\n+  return JfrTraceId::get(array_klass) + 1;\n+}\n+\n+static void write_primitive(JfrCheckpointWriter* writer, Klass* type_array_klass, JfrArtifactSet* artifacts) {\n+  assert(writer != NULL, \"invariant\");\n+  assert(artifacts != NULL, \"invariant\");\n+  writer->write(primitive_id(type_array_klass));\n+  writer->write(cld_id(Universe::boolArrayKlassObj()->class_loader_data()));\n+  writer->write(mark_symbol(primitive_symbol(type_array_klass), artifacts));\n+  writer->write(package_id(Universe::boolArrayKlassObj(), artifacts));\n+  writer->write(get_primitive_flags());\n+}\n+\n+\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n+\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n+\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n+\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n+\/\/ It will use a reserved constant.\n+static void do_primitives(JfrArtifactSet* artifacts, bool class_unload) {\n+  \/\/ Only write the primitive classes once per chunk.\n+  if (is_initial_typeset_for_chunk(class_unload)) {\n+    write_primitive(_writer, Universe::boolArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::byteArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::charArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::shortArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::intArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::longArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::singleArrayKlassObj(), artifacts);\n+    write_primitive(_writer, Universe::doubleArrayKlassObj(), artifacts);\n+    write_primitive(_writer, NULL, artifacts); \/\/ void.class\n+  }\n+}\n+\n@@ -662,0 +755,1 @@\n+  do_primitives(_artifacts, _class_unload);\n@@ -723,0 +817,1 @@\n+  _writer = writer;\n@@ -748,0 +843,1 @@\n+\n","filename":"hotspot\/src\/share\/vm\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":105,"deletions":9,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-  static volatile traceid class_id_counter = MaxJfrEventId + 100;\n+  static volatile traceid class_id_counter = MaxJfrEventId + 101; \/\/ + 101 is for the void.class primitive;\n@@ -110,0 +110,4 @@\n+traceid JfrTraceId::assign_primitive_klass_id() {\n+  return next_class_id();\n+}\n+\n@@ -133,0 +137,22 @@\n+  if (k->oop_is_typeArray()) {\n+    \/\/ the next id is reserved for the corresponding primitive class\n+    next_class_id();\n+  }\n+}\n+\n+\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n+\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n+\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n+\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n+\/\/ It will use a reserved constant.\n+static traceid load_primitive(const oop mirror) {\n+  assert(java_lang_Class::is_primitive(mirror), \"invariant\");\n+  const Klass* const tak = java_lang_Class::array_klass(mirror);\n+  traceid id;\n+  if (tak == NULL) {\n+    \/\/ The first klass id is reserved for the void.class\n+    id = MaxJfrEventId + 101;\n+  } else {\n+    id = JfrTraceId::get(tak) + 1;\n+  }\n+  return id;\n@@ -148,1 +174,2 @@\n-  return use(java_lang_Class::as_Klass(my_oop), leakp);\n+  const Klass* const k = java_lang_Class::as_Klass(my_oop);\n+  return k != NULL ? use(k, leakp) : load_primitive(my_oop);\n","filename":"hotspot\/src\/share\/vm\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  static traceid assign_primitive_klass_id();\n","filename":"hotspot\/src\/share\/vm\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#define ASSIGN_PRIMITIVE_CLASS_ID(data) JfrTraceId::assign_primitive_klass_id()\n","filename":"hotspot\/src\/share\/vm\/jfr\/support\/jfrTraceIdExtension.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1789,1 +1789,1 @@\n-        MutexLocker ml(JmethodIdCreation_lock);\n+        MutexLockerEx ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n@@ -1839,1 +1839,1 @@\n-      MutexLocker ml(JmethodIdCreation_lock);\n+      MutexLockerEx ml(JmethodIdCreation_lock, Mutex::_no_safepoint_check_flag);\n","filename":"hotspot\/src\/share\/vm\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  JFR_ONLY(ASSIGN_PRIMITIVE_CLASS_ID(ak);)\n","filename":"hotspot\/src\/share\/vm\/oops\/typeArrayKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -556,0 +556,3 @@\n+  \/\/ !important! make sure all to call thread->set_in_asgct(false) before every return\n+  thread->set_in_asgct(true);\n+\n@@ -613,0 +616,1 @@\n+  thread->set_in_asgct(false);\n","filename":"hotspot\/src\/share\/vm\/prims\/forte.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1757,1 +1757,1 @@\n-      assert(sd->method() != NULL, \"sd->method() cannot be null.\");\n+      guarantee(sd->method() != NULL, \"sd->method() cannot be null.\");\n","filename":"hotspot\/src\/share\/vm\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -900,3 +900,0 @@\n-  \/\/ Keep the nmethod alive until the ServiceThread can process\n-  \/\/ this deferred event.\n-  nmethodLocker::lock_nmethod(nm);\n@@ -935,1 +932,1 @@\n-  assert(ServiceThread::is_service_thread(Thread::current()),\n+  assert(Thread::current()->is_service_thread(),\n@@ -941,2 +938,0 @@\n-      \/\/ done with the deferred event so unlock the nmethod\n-      nmethodLocker::unlock_nmethod(nm);\n@@ -972,0 +967,15 @@\n+\/\/ Keep the nmethod for compiled_method_load from being unloaded.\n+void JvmtiDeferredEvent::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+  if (cf != NULL && _type == TYPE_COMPILED_METHOD_LOAD) {\n+    cf->do_code_blob(_event_data.compiled_method_load);\n+  }\n+}\n+\n+\/\/ The sweeper calls this and marks the nmethods here on the stack so that\n+\/\/ they cannot be turned into zombies while in the queue.\n+void JvmtiDeferredEvent::nmethods_do(CodeBlobClosure* cf) {\n+  if (cf != NULL && _type == TYPE_COMPILED_METHOD_LOAD) {\n+    cf->do_code_blob(_event_data.compiled_method_load);\n+  }  \/\/ May add UNLOAD event but it doesn't work yet.\n+}\n+\n@@ -1087,0 +1097,12 @@\n+\n+void JvmtiDeferredEventQueue::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+     node->event().oops_do(f, cf);\n+  }\n+}\n+\n+void JvmtiDeferredEventQueue::nmethods_do(CodeBlobClosure* cf) {\n+  for(QueueNode* node = _queue_head; node != NULL; node = node->next()) {\n+     node->event().nmethods_do(cf);\n+  }\n+}\n","filename":"hotspot\/src\/share\/vm\/prims\/jvmtiImpl.cpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -495,0 +495,4 @@\n+  \/\/ Sweeper support to keep nmethods from being zombied while in the queue.\n+  void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  \/\/ GC support to keep nmethod from being unloaded while in the queue.\n+  void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n@@ -514,1 +518,1 @@\n-    const JvmtiDeferredEvent& event() const { return _event; }\n+    JvmtiDeferredEvent& event() { return _event; }\n@@ -532,0 +536,4 @@\n+  \/\/ Sweeper support to keep nmethods from being zombied while in the queue.\n+  static void nmethods_do(CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n+  \/\/ GC support to keep nmethod from being unloaded while in the queue.\n+  static void oops_do(OopClosure* f, CodeBlobClosure* cf) NOT_JVMTI_RETURN;\n","filename":"hotspot\/src\/share\/vm\/prims\/jvmtiImpl.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-    st->print(\"%-16ld\", get_intx());\n+    st->print(INTX_FORMAT_W(-16), get_intx());\n@@ -309,1 +309,1 @@\n-    st->print(\"%-16lu\", get_uintx());\n+    st->print(UINTX_FORMAT_W(-16), get_uintx());\n@@ -312,1 +312,1 @@\n-    st->print(\"%-16lu\", get_uint64_t());\n+    st->print(UINT64_FORMAT_W(-16), get_uint64_t());\n","filename":"hotspot\/src\/share\/vm\/runtime\/globals.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+JvmtiDeferredEvent* ServiceThread::_jvmti_event = NULL;\n@@ -115,0 +116,1 @@\n+        \/\/ Get the event under the Service_lock\n@@ -116,0 +118,1 @@\n+        _jvmti_event = &jvmti_event;\n@@ -120,1 +123,2 @@\n-      jvmti_event.post();\n+      _jvmti_event->post();\n+      _jvmti_event = NULL;  \/\/ reset\n@@ -141,2 +145,22 @@\n-bool ServiceThread::is_service_thread(Thread* thread) {\n-  return thread == _instance;\n+void ServiceThread::oops_do(OopClosure* f, CLDClosure* cld_f, CodeBlobClosure* cf) {\n+  JavaThread::oops_do(f, cld_f, cf);\n+  \/\/ The ServiceThread \"owns\" the JVMTI Deferred events, scan them here\n+  \/\/ to keep them alive until they are processed.\n+  if (cf != NULL) {\n+    if (_jvmti_event != NULL) {\n+      _jvmti_event->oops_do(f, cf);\n+    }\n+    MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    JvmtiDeferredEventQueue::oops_do(f, cf);\n+  }\n+}\n+\n+void ServiceThread::nmethods_do(CodeBlobClosure* cf) {\n+  JavaThread::nmethods_do(cf);\n+  if (cf != NULL) {\n+    if (_jvmti_event != NULL) {\n+      _jvmti_event->nmethods_do(cf);\n+    }\n+    MutexLockerEx ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    JvmtiDeferredEventQueue::nmethods_do(cf);\n+  }\n","filename":"hotspot\/src\/share\/vm\/runtime\/serviceThread.cpp","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+class JvmtiDeferredEvent;\n+\n@@ -35,1 +37,0 @@\n-\n@@ -37,0 +38,1 @@\n+  static JvmtiDeferredEvent* _jvmti_event;\n@@ -46,0 +48,1 @@\n+  bool is_service_thread() const                 { return true; }\n@@ -47,2 +50,3 @@\n-  \/\/ Returns true if the passed thread is the service thread.\n-  static bool is_service_thread(Thread* thread);\n+  \/\/ GC support\n+  void oops_do(OopClosure* f, CLDClosure* cld_f, CodeBlobClosure* cf);\n+  void nmethods_do(CodeBlobClosure* cf);\n","filename":"hotspot\/src\/share\/vm\/runtime\/serviceThread.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1451,0 +1451,1 @@\n+  _in_asgct = false;\n","filename":"hotspot\/src\/share\/vm\/runtime\/thread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -316,0 +316,1 @@\n+  virtual bool is_service_thread() const             { return false; }\n@@ -783,0 +784,1 @@\n+  bool           _in_asgct;                      \/\/ Is set when this JavaThread is handling ASGCT call\n@@ -1784,0 +1786,4 @@\n+\n+  \/\/ AsyncGetCallTrace support\n+  inline bool in_asgct(void) {return _in_asgct;}\n+  inline void set_in_asgct(bool value) {_in_asgct = value;}\n","filename":"hotspot\/src\/share\/vm\/runtime\/thread.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -254,0 +254,10 @@\n+      #elif _MSC_VER == 1924\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 16.4 (VS2019)\"\n+      #elif _MSC_VER == 1925\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 16.5 (VS2019)\"\n+      #elif _MSC_VER == 1926\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 16.6 (VS2019)\"\n+      #elif _MSC_VER == 1927\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 16.7 (VS2019)\"\n+      #elif _MSC_VER == 1928\n+        #define HOTSPOT_BUILD_COMPILER \"MS VC++ 16.8 (VS2019)\"\n","filename":"hotspot\/src\/share\/vm\/runtime\/vm_version.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,410 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import sun.misc.Unsafe;\n+import java.util.Random;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import static java.lang.Math.abs;\n+import static java.lang.Math.pow;\n+import static java.lang.Math.round;\n+import static java.math.BigInteger.TEN;\n+import java.lang.reflect.Field;\n+import java.math.BigInteger;\n+import java.nio.ByteOrder;\n+import static java.lang.String.format;\n+import static java.lang.System.arraycopy;\n+\n+\/* @test\n+ * @bug 8235385\n+ * @summary Verifies non-volatile memory access with long offset\n+ * @requires os.arch == \"aarch64\"\n+ *\/\n+public class NonVolatileMemoryAccessWithLongOffset {\n+    private static final Unsafe unsafe;\n+    static Random random = new Random();\n+\n+    static {\n+        Field f = null;\n+        try {\n+            f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+            f.setAccessible(true);\n+            unsafe = (Unsafe) f.get(null);\n+        } catch (ReflectiveOperationException e) {\n+            throw new Error(e);\n+        }\n+    }\n+    private static final int MAX_LENGTH = 10000;\n+\n+    private static byte[] input0 = new byte[MAX_LENGTH];\n+    private static byte[] input1 = new byte[MAX_LENGTH];\n+    private static final int MAX_VALUE_LENGTH = random.nextInt(200) + 20;\n+    private static final byte[] maxValue = new byte[MAX_VALUE_LENGTH];\n+    private static final byte[] minValue = new byte[MAX_VALUE_LENGTH];\n+    private static final int DECIMAL_MAX_VALUE_LENGTH = MAX_VALUE_LENGTH - 15;\n+    private static byte[] byteArray;\n+\n+    private static final    int valueType = random.nextInt(100);\n+    private static final    int numNulls = random.nextInt(100);\n+    private static final    int numRows = random.nextInt(100);\n+    private static final    int countDistinct = random.nextInt(100);\n+    private static final    long rawDataSize = (long)random.nextInt(100);\n+    private static final    long sum = (long)random.nextInt(1000);\n+    private static final    int version = random.nextInt(100);\n+\n+\n+    private static final    int dictOffset = random.nextInt(100);\n+    private static final    int dictLength = random.nextInt(100);\n+    private static final    int histOffset = random.nextInt(100);\n+    private static final    int histLength = random.nextInt(100);\n+    private static final    int dpnOffset = random.nextInt(100);\n+    private static final    int dpnCount = random.nextInt(100);\n+\n+    private static final    long maxRowCount = (long)random.nextInt(1000);\n+    private static final    long minRowCount = (long)random.nextInt(1000);\n+    private static final    long totalRowCount = (long)random.nextInt(100);\n+    private static final    long maxMemSize = (long)random.nextInt(1000);\n+    private static final    long minMemSize = (long)random.nextInt(100);\n+    private static final    long totalMemSize = (long)random.nextInt(1000);\n+\n+    private static final    long toastOffset = (long)random.nextInt(1000);\n+    private static final    boolean hasToast = random.nextInt(100) > 50;\n+\n+\n+    private static final int MAX_STRING_LENGTH = random.nextInt(300) + 20;\n+    private static final byte[] maxString = new byte[MAX_STRING_LENGTH];\n+    private static final byte[] minString = new byte[MAX_STRING_LENGTH];\n+    private static int maxStringLength = random.nextInt(100);\n+    private static int minStringLength = random.nextInt(100);\n+    private static final boolean maxStringIsNull = random.nextInt(100) > 20;\n+    private static final boolean minStringIsNull = random.nextInt(100) > 60;\n+\n+    private static final short precision = (short)random.nextInt(100);\n+    private static final short scale = (short)random.nextInt(100);\n+    private static final boolean    useShortCompressFloat = random.nextInt(100) > 60;\n+    private static final int SHORT_SIZE = 2;\n+    private static final int CHAR_SIZE = 2;\n+    private static final int INT_SIZE = 4;\n+    private static final int LONG_SIZE = 8;\n+    private static final int FLOAT_SIZE = 4;\n+    private static final int DOUBLE_SIZE = 8;\n+    private static final int    BOOLEAN_SIZE = 1;\n+\n+    private static void premitiveAssert(boolean flag) {\n+        if (flag == false) {\n+            throw new RuntimeException(\"overflow!\");\n+        }\n+    }\n+\n+    private static long BYTE_ARRAY_OFFSET = unsafe.ARRAY_BYTE_BASE_OFFSET;\n+\n+\n+    public static final void toBytes(short obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         SHORT_SIZE));\n+        unsafe.putShort(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(int obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         INT_SIZE));\n+        unsafe.putInt(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(long obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         LONG_SIZE));\n+        unsafe.putLong(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(float obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         FLOAT_SIZE));\n+        unsafe.putFloat(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(double obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         DOUBLE_SIZE));\n+        unsafe.putDouble(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(char obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         CHAR_SIZE));\n+        unsafe.putChar(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(boolean obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         1));\n+        unsafe.putBoolean(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    private static int bytesSize() {\n+        return MAX_LENGTH;\n+    }\n+    static byte[] toBytesDup() {\n+        byte[] rawBytes = input1;\n+\n+        int offset = 0;\n+\n+        toBytes(valueType, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numNulls, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numRows, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(countDistinct, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(rawDataSize, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        toBytes(sum, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+        if (version > 50) {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+        } else {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+        }\n+\n+        toBytes(dictOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dictLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnCount, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+        if (version >= 60) {\n+            toBytes(maxRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(maxMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+        }\n+\n+       if (version >= 65) {\n+           toBytes(toastOffset, rawBytes, offset);\n+           offset +=         LONG_SIZE;\n+           toBytes(hasToast, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+       if (version >= 70) {\n+          System.arraycopy(maxString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          System.arraycopy(minString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          toBytes(maxStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(minStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(maxStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+\n+          toBytes(minStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 75) {\n+           toBytes(precision, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+\n+           toBytes(scale, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+       }\n+\n+       if (version >= 80) {\n+           toBytes(useShortCompressFloat, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+        return rawBytes;\n+    }\n+\n+\n+    static byte[] toBytes() {\n+        byte[] rawBytes = input0;\n+\n+        int offset = 0;\n+\n+        toBytes(valueType, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numNulls, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numRows, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(countDistinct, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(rawDataSize, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        toBytes(sum, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        \/\/if (version.getVersion() < DetailColumn.VERSION_EIGHT) {\n+        if (version > 50) {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+        } else {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+        }\n+\n+        toBytes(dictOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dictLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnCount, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        if (version >= 60) {\n+            toBytes(maxRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(maxMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+        }\n+\n+       if (version >= 65) {\n+           toBytes(toastOffset, rawBytes, offset);\n+           offset +=         LONG_SIZE;\n+           toBytes(hasToast, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 70) {\n+          System.arraycopy(maxString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          System.arraycopy(minString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          toBytes(maxStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(minStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(maxStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+\n+          toBytes(minStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 75) {\n+           toBytes(precision, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+\n+           toBytes(scale, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+       }\n+\n+       if (version >= 80) {\n+           toBytes(useShortCompressFloat, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+        return rawBytes;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        long s = 0, s1 = 0;\n+        for (int i = 0; i < input0.length; i++) {\n+            input0[i] = 0;\n+            input1[i] = 0;\n+        }\n+        for (int i = 0; i < 100000; i++) {\n+            s += toBytes()[0];\n+            s1 += toBytesDup()[0];\n+            for (int j = 0; j < input0.length; j++) {\n+                if (input0[j] != input1[j]) {\n+                    throw new RuntimeException(\"not match!\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/compiler\/8235385\/NonVolatileMemoryAccessWithLongOffset.java","additions":410,"deletions":0,"binary":false,"changes":410,"status":"added"},{"patch":"@@ -0,0 +1,175 @@\n+\/*\n+ * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8150669\n+ * @bug 8233019\n+ * @summary C1 intrinsic for Class.isPrimitive\n+ *\n+ * @run main\/othervm -ea -Diters=200   -Xint                   TestIsPrimitive\n+ * @run main\/othervm -ea -Diters=30000 -XX:-UseSharedSpaces\n+                                       -XX:TieredStopAtLevel=1 TestIsPrimitive\n+ * @run main\/othervm -ea -Diters=30000 -XX:TieredStopAtLevel=4 TestIsPrimitive\n+ *\/\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Array;\n+import java.util.concurrent.Callable;\n+\n+public class TestIsPrimitive {\n+    static final int ITERS = Integer.getInteger(\"iters\", 1);\n+\n+    public static void main(String... args) throws Exception {\n+        testOK(true,  InlineConstants::testBoolean);\n+        testOK(true,  InlineConstants::testByte);\n+        testOK(true,  InlineConstants::testShort);\n+        testOK(true,  InlineConstants::testChar);\n+        testOK(true,  InlineConstants::testInt);\n+        testOK(true,  InlineConstants::testFloat);\n+        testOK(true,  InlineConstants::testLong);\n+        testOK(true,  InlineConstants::testDouble);\n+        testOK(false, InlineConstants::testObject);\n+        testOK(false, InlineConstants::testArray);\n+        testOK(false, InlineConstants::testBooleanArray);\n+\n+        testOK(true,  StaticConstants::testBoolean);\n+        testOK(true,  StaticConstants::testByte);\n+        testOK(true,  StaticConstants::testShort);\n+        testOK(true,  StaticConstants::testChar);\n+        testOK(true,  StaticConstants::testInt);\n+        testOK(true,  StaticConstants::testFloat);\n+        testOK(true,  StaticConstants::testLong);\n+        testOK(true,  StaticConstants::testDouble);\n+        testOK(false, StaticConstants::testObject);\n+        testOK(false, StaticConstants::testArray);\n+        testOK(false, StaticConstants::testBooleanArray);\n+        testNPE(      StaticConstants::testNull);\n+\n+        testOK(true,  NoConstants::testBoolean);\n+        testOK(true,  NoConstants::testByte);\n+        testOK(true,  NoConstants::testShort);\n+        testOK(true,  NoConstants::testChar);\n+        testOK(true,  NoConstants::testInt);\n+        testOK(true,  NoConstants::testFloat);\n+        testOK(true,  NoConstants::testLong);\n+        testOK(true,  NoConstants::testDouble);\n+        testOK(false, NoConstants::testObject);\n+        testOK(false, NoConstants::testArray);\n+        testOK(false, NoConstants::testBooleanArray);\n+        testNPE(      NoConstants::testNull);\n+    }\n+\n+    public static void testOK(boolean expected, Callable<Object> test) throws Exception {\n+        for (int c = 0; c < ITERS; c++) {\n+            Object res = test.call();\n+            if (!res.equals(expected)) {\n+                throw new IllegalStateException(\"Wrong result: expected = \" + expected + \", but got \" + res);\n+            }\n+        }\n+    }\n+\n+    static volatile Object sink;\n+\n+    public static void testNPE(Callable<Object> test) throws Exception {\n+        for (int c = 0; c < ITERS; c++) {\n+            try {\n+               sink = test.call();\n+               throw new IllegalStateException(\"Expected NPE\");\n+            } catch (NullPointerException iae) {\n+               \/\/ expected\n+            }\n+        }\n+    }\n+\n+    static volatile Class<?> classBoolean = boolean.class;\n+    static volatile Class<?> classByte    = byte.class;\n+    static volatile Class<?> classShort   = short.class;\n+    static volatile Class<?> classChar    = char.class;\n+    static volatile Class<?> classInt     = int.class;\n+    static volatile Class<?> classFloat   = float.class;\n+    static volatile Class<?> classLong    = long.class;\n+    static volatile Class<?> classDouble  = double.class;\n+    static volatile Class<?> classObject  = Object.class;\n+    static volatile Class<?> classArray   = Object[].class;\n+    static volatile Class<?> classNull    = null;\n+    static volatile Class<?> classBooleanArray = boolean[].class;\n+\n+    static final Class<?> staticClassBoolean = boolean.class;\n+    static final Class<?> staticClassByte    = byte.class;\n+    static final Class<?> staticClassShort   = short.class;\n+    static final Class<?> staticClassChar    = char.class;\n+    static final Class<?> staticClassInt     = int.class;\n+    static final Class<?> staticClassFloat   = float.class;\n+    static final Class<?> staticClassLong    = long.class;\n+    static final Class<?> staticClassDouble  = double.class;\n+    static final Class<?> staticClassObject  = Object.class;\n+    static final Class<?> staticClassArray   = Object[].class;\n+    static final Class<?> staticClassNull    = null;\n+    static final Class<?> staticClassBooleanArray = boolean[].class;\n+\n+    static class InlineConstants {\n+        static boolean testBoolean() { return boolean.class.isPrimitive();  }\n+        static boolean testByte()    { return byte.class.isPrimitive();     }\n+        static boolean testShort()   { return short.class.isPrimitive();    }\n+        static boolean testChar()    { return char.class.isPrimitive();     }\n+        static boolean testInt()     { return int.class.isPrimitive();      }\n+        static boolean testFloat()   { return float.class.isPrimitive();    }\n+        static boolean testLong()    { return long.class.isPrimitive();     }\n+        static boolean testDouble()  { return double.class.isPrimitive();   }\n+        static boolean testObject()  { return Object.class.isPrimitive();   }\n+        static boolean testArray()   { return Object[].class.isPrimitive(); }\n+        static boolean testBooleanArray() { return boolean[].class.isPrimitive(); }\n+    }\n+\n+    static class StaticConstants {\n+        static boolean testBoolean() { return staticClassBoolean.isPrimitive(); }\n+        static boolean testByte()    { return staticClassByte.isPrimitive();    }\n+        static boolean testShort()   { return staticClassShort.isPrimitive();   }\n+        static boolean testChar()    { return staticClassChar.isPrimitive();    }\n+        static boolean testInt()     { return staticClassInt.isPrimitive();     }\n+        static boolean testFloat()   { return staticClassFloat.isPrimitive();   }\n+        static boolean testLong()    { return staticClassLong.isPrimitive();    }\n+        static boolean testDouble()  { return staticClassDouble.isPrimitive();  }\n+        static boolean testObject()  { return staticClassObject.isPrimitive();  }\n+        static boolean testArray()   { return staticClassArray.isPrimitive();   }\n+        static boolean testNull()    { return staticClassNull.isPrimitive();    }\n+        static boolean testBooleanArray() { return staticClassBooleanArray.isPrimitive(); }\n+    }\n+\n+    static class NoConstants {\n+        static boolean testBoolean() { return classBoolean.isPrimitive(); }\n+        static boolean testByte()    { return classByte.isPrimitive();    }\n+        static boolean testShort()   { return classShort.isPrimitive();   }\n+        static boolean testChar()    { return classChar.isPrimitive();    }\n+        static boolean testInt()     { return classInt.isPrimitive();     }\n+        static boolean testFloat()   { return classFloat.isPrimitive();   }\n+        static boolean testLong()    { return classLong.isPrimitive();    }\n+        static boolean testDouble()  { return classDouble.isPrimitive();  }\n+        static boolean testObject()  { return classObject.isPrimitive();  }\n+        static boolean testArray()   { return classArray.isPrimitive();   }\n+        static boolean testNull()    { return classNull.isPrimitive();    }\n+        static boolean testBooleanArray() { return classBooleanArray.isPrimitive(); }\n+    }\n+\n+}\n+\n","filename":"hotspot\/test\/compiler\/intrinsics\/klass\/TestIsPrimitive.java","additions":175,"deletions":0,"binary":false,"changes":175,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280963\n+ * @summary \"%-16lu\" formatting string is used to format uintx (uintptr_t)\n+ *          flag values for output. uintx is 64-bit on win64, and \"lu\" format\n+ *          is intended to be used with unsigned long that is 32-bit on win64.\n+ *          Thus flag values that are exact multiple of 4 GiB will be formatted\n+ *          into 0 in PrintFlags output.\n+ * @library \/testlibrary\n+ *\/\n+\n+import com.oracle.java.testlibrary.*;\n+\n+public class PrintFlagsUintxTest {\n+    public static void main(String[] args) throws Exception {\n+        if (!Platform.is64bit()) {\n+            System.out.println(\"Test needs a 4GB heap and can only be run as a 64bit process, skipping.\");\n+            return;\n+        }\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-Xmx4g\", \"-XX:+PrintFlagsFinal\", \"-version\");\n+\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.stdoutShouldMatch(\".*MaxHeapSize\\\\s+:= 4294967296\\\\s+.*\");\n+    }\n+}\n","filename":"hotspot\/test\/runtime\/CommandLine\/PrintFlagsUintxTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -5,6 +4,8 @@\n-\/*\n- * Copyright 1999-2005 The Apache Software Foundation.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\");\n- * you may not use this file except in compliance with the License.\n- * You may obtain a copy of the License at\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n@@ -12,1 +13,1 @@\n- *     http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n@@ -14,5 +15,6 @@\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n@@ -138,0 +140,3 @@\n+  \/** The 'here()' id (XML Signature). *\/\n+  public static final int FUNC_HERE = 37;\n+\n@@ -165,1 +170,1 @@\n-  private static final int NUM_BUILT_IN_FUNCS = 37;\n+  private static final int NUM_BUILT_IN_FUNCS = 38;\n@@ -232,0 +237,2 @@\n+    m_functions[FUNC_HERE] =\n+      com.sun.org.apache.xpath.internal.functions.FuncHere.class;\n@@ -305,0 +312,2 @@\n+          m_functionID.put(Keywords.FUNC_HERE_STRING,\n+                          new Integer(FunctionTable.FUNC_HERE));\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xpath\/internal\/compiler\/FunctionTable.java","additions":24,"deletions":15,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -4,7 +4,8 @@\n-\/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n@@ -12,1 +13,1 @@\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n@@ -14,5 +15,6 @@\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n@@ -329,0 +331,5 @@\n+    \/**\n+     * here function string (XML Signature).\n+     *\/\n+    public static final String FUNC_HERE_STRING = \"here\";\n+\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xpath\/internal\/compiler\/Keywords.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ *\/\n+\/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements. See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership. The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at\n+ *\n+ * http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ *\/\n+package com.sun.org.apache.xpath.internal.functions;\n+\n+import javax.xml.transform.TransformerException;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import com.sun.org.apache.xml.internal.dtm.DTM;\n+import com.sun.org.apache.xpath.internal.NodeSetDTM;\n+import com.sun.org.apache.xpath.internal.XPathContext;\n+import com.sun.org.apache.xpath.internal.objects.XNodeSet;\n+import com.sun.org.apache.xpath.internal.objects.XObject;\n+import com.sun.org.apache.xpath.internal.res.XPATHErrorResources;\n+\n+\/**\n+ * Execute the XML Signature here() function.\n+ *\/\n+public final class FuncHere extends Function {\n+\n+    private static final long serialVersionUID = 4328660760070034592L;\n+\n+    @Override\n+    public XObject execute(XPathContext xctxt) throws TransformerException {\n+        Node xpathOwnerNode = (Node)xctxt.getOwnerObject();\n+        if (xpathOwnerNode == null) {\n+            return null;\n+        }\n+\n+        int xpathOwnerNodeDTM = xctxt.getDTMHandleFromNode(xpathOwnerNode);\n+        int currentNode = xctxt.getCurrentNode();\n+        DTM dtm = xctxt.getDTM(currentNode);\n+        int docContext = dtm.getDocument();\n+\n+        if (docContext == DTM.NULL) {\n+            error(xctxt, XPATHErrorResources.ER_CONTEXT_HAS_NO_OWNERDOC, null);\n+        }\n+\n+        \/\/ check whether currentNode and the node containing the XPath\n+        \/\/ expression are in the same document\n+        Document currentDoc = getOwnerDocument(dtm.getNode(currentNode));\n+        Document xpathOwnerDoc = getOwnerDocument(xpathOwnerNode);\n+\n+        if (currentDoc != xpathOwnerDoc) {\n+            throw new TransformerException(\"Owner documents differ\");\n+        }\n+\n+        XNodeSet nodes = new XNodeSet(xctxt.getDTMManager());\n+        NodeSetDTM nodeSet = nodes.mutableNodeset();\n+\n+        int hereNode = DTM.NULL;\n+\n+        switch (dtm.getNodeType(xpathOwnerNodeDTM)) {\n+\n+            case Node.ATTRIBUTE_NODE:\n+            case Node.PROCESSING_INSTRUCTION_NODE: {\n+                \/\/ returns a node-set containing the attribute \/  processing\n+                \/\/ instruction node\n+                hereNode = xpathOwnerNodeDTM;\n+                nodeSet.addNode(hereNode);\n+                break;\n+            }\n+            case Node.TEXT_NODE : {\n+                \/\/ returns a node-set containing the parent element of the\n+                \/\/ text node that directly bears the XPath expression\n+                hereNode = dtm.getParent(xpathOwnerNodeDTM);\n+                nodeSet.addNode(hereNode);\n+                break;\n+            }\n+            default :\n+                break;\n+        }\n+\n+        \/** $todo$ Do I have to do this detach() call? *\/\n+        nodeSet.detach();\n+\n+        return nodes;\n+    }\n+\n+    private static Document getOwnerDocument(Node node) {\n+        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n+            return (Document)node;\n+        }\n+        return node.getOwnerDocument();\n+    }\n+\n+    @Override\n+    public void fixupVariables(java.util.Vector vars, int globalsSize) { }\n+}\n","filename":"jaxp\/src\/com\/sun\/org\/apache\/xpath\/internal\/functions\/FuncHere.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -634,2 +634,3 @@\n-                SwingUtilities2.getSystemMnemonicKeyMask(),\n-                KeyEvent.META_MASK\n+                SwingUtilities2.getSystemMnemonicKeyMask(), KeyEvent.META_MASK,\n+                SwingUtilities2.setAltGraphMask(\n+                        SwingUtilities2.getSystemMnemonicKeyMask())\n","filename":"jdk\/src\/share\/classes\/com\/sun\/java\/swing\/plaf\/motif\/MotifLookAndFeel.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -168,0 +168,5 @@\n+        if (new FunctionTable().functionAvailable(\"here\")) {\n+            LOG.debug(\"Here function already registered\");\n+            installed = true;\n+            return;\n+        }\n","filename":"jdk\/src\/share\/classes\/com\/sun\/org\/apache\/xml\/internal\/security\/utils\/XalanXPathAPI.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -327,17 +327,0 @@\n-    \/**\n-     * The default strokes for initializing the default focus traversal keys.\n-     *\/\n-    private static final AWTKeyStroke[][] defaultFocusTraversalKeyStrokes = {\n-        {\n-            AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB, 0, false),\n-            AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB, InputEvent.CTRL_DOWN_MASK | InputEvent.CTRL_MASK, false),\n-        },\n-        {\n-            AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB, InputEvent.SHIFT_DOWN_MASK | InputEvent.SHIFT_MASK, false),\n-            AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB,\n-                                         InputEvent.SHIFT_DOWN_MASK | InputEvent.SHIFT_MASK | InputEvent.CTRL_DOWN_MASK | InputEvent.CTRL_MASK,\n-                                         false),\n-        },\n-        {},\n-        {},\n-      };\n@@ -433,0 +416,21 @@\n+        AWTKeyStroke[][] defaultFocusTraversalKeyStrokes = {\n+                {\n+                        AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB, 0, false),\n+                        AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB,\n+                                InputEvent.CTRL_DOWN_MASK |\n+                                        InputEvent.CTRL_MASK, false),\n+                },\n+                {\n+                        AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB,\n+                                InputEvent.SHIFT_DOWN_MASK |\n+                                        InputEvent.SHIFT_MASK, false),\n+                        AWTKeyStroke.getAWTKeyStroke(KeyEvent.VK_TAB,\n+                                InputEvent.SHIFT_DOWN_MASK |\n+                                        InputEvent.SHIFT_MASK |\n+                                        InputEvent.CTRL_DOWN_MASK |\n+                                        InputEvent.CTRL_MASK,\n+                                false),\n+                },\n+                {},\n+                {},\n+        };\n","filename":"jdk\/src\/share\/classes\/java\/awt\/KeyboardFocusManager.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.swing.SwingUtilities2;\n@@ -144,0 +145,5 @@\n+            map.put(KeyStroke.getKeyStroke(m, SwingUtilities2.setAltGraphMask\n+                            (BasicLookAndFeel.getFocusAcceleratorKeyMask()),\n+                    false),\n+                    \"pressed\");\n+\n@@ -146,0 +152,4 @@\n+            map.put(KeyStroke.getKeyStroke(m,\n+                    SwingUtilities2.setAltGraphMask\n+                            (BasicLookAndFeel.getFocusAcceleratorKeyMask()), true),\n+                    \"released\");\n","filename":"jdk\/src\/share\/classes\/javax\/swing\/plaf\/basic\/BasicButtonListener.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.awt.event.InputEvent;\n@@ -405,0 +406,4 @@\n+            inputMap.put(KeyStroke.getKeyStroke(dka,\n+                    SwingUtilities2.setAltGraphMask (\n+                            BasicLookAndFeel.getFocusAcceleratorKeyMask()),\n+                    false), \"press\");\n@@ -522,0 +527,2 @@\n+                putOnRelease(inputMap, dka, SwingUtilities2.setAltGraphMask (\n+                        BasicLookAndFeel.getFocusAcceleratorKeyMask()));\n@@ -541,0 +548,3 @@\n+                        removeOnRelease(inputMap, dka,\n+                                SwingUtilities2.setAltGraphMask (\n+                                BasicLookAndFeel.getFocusAcceleratorKeyMask()));\n@@ -557,0 +567,3 @@\n+                        putOnRelease(inputMap, dka,\n+                                SwingUtilities2.setAltGraphMask (\n+                                BasicLookAndFeel.getFocusAcceleratorKeyMask()));\n@@ -574,0 +587,3 @@\n+                            removeOnRelease(inputMap, dka,\n+                                    SwingUtilities2.setAltGraphMask (\n+                                    BasicLookAndFeel.getFocusAcceleratorKeyMask()));\n","filename":"jdk\/src\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLabelUI.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1158,1 +1158,3 @@\n-                SwingUtilities2.getSystemMnemonicKeyMask()\n+                SwingUtilities2.getSystemMnemonicKeyMask(),\n+                SwingUtilities2.setAltGraphMask(\n+                        SwingUtilities2.getSystemMnemonicKeyMask())\n","filename":"jdk\/src\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLookAndFeel.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -346,0 +346,1 @@\n+    @SuppressWarnings(\"deprecation\")\n@@ -362,0 +363,39 @@\n+\n+            int modifiers = accelerator.getModifiers();\n+            if (((modifiers & InputEvent.ALT_DOWN_MASK) != 0) &&\n+                    ((modifiers & InputEvent.ALT_GRAPH_DOWN_MASK) != 0)) {\n+                \/\/When both ALT and ALT_GRAPH are set, add the ALT only\n+                \/\/ modifier keystroke which is used for left ALT key.\n+                \/\/ Unsetting the ALT_GRAPH will do that as ALT is already set\n+                modifiers &= ~InputEvent.ALT_GRAPH_DOWN_MASK;\n+                modifiers &= ~InputEvent.ALT_GRAPH_MASK;\n+                KeyStroke keyStroke = KeyStroke.getKeyStroke(accelerator.getKeyCode(),\n+                        modifiers, accelerator.isOnKeyRelease());\n+                windowInputMap.put(keyStroke, \"doClick\");\n+            } else if (((modifiers & InputEvent.ALT_DOWN_MASK) != 0) && (\n+                    (modifiers & InputEvent.ALT_GRAPH_DOWN_MASK) == 0)) {\n+                \/\/When only ALT modifier is set, add the ALT + ALT_GRAPH\n+                \/\/ modifier keystroke which is used for right ALT key\n+                modifiers |= InputEvent.ALT_GRAPH_DOWN_MASK;\n+                KeyStroke keyStroke = KeyStroke.getKeyStroke(accelerator.getKeyCode(),\n+                        modifiers, accelerator.isOnKeyRelease());\n+                windowInputMap.put(keyStroke, \"doClick\");\n+            } else if ((modifiers & InputEvent.ALT_GRAPH_DOWN_MASK) != 0) {\n+                \/\/When only ALT_GRAPH is set, remove the ALT_GRAPH only\n+                \/\/ modifier and add the ALT and ALT+ALT_GRAPH modifiers\n+                \/\/ keystroke which are used for left ALT key and right ALT\n+                \/\/ respectively\n+                modifiers &= ~InputEvent.ALT_GRAPH_DOWN_MASK;\n+                modifiers &= ~InputEvent.ALT_GRAPH_MASK;\n+\n+                modifiers |= InputEvent.ALT_DOWN_MASK;\n+                KeyStroke keyStroke = KeyStroke.getKeyStroke(accelerator.getKeyCode(),\n+                        modifiers, accelerator.isOnKeyRelease());\n+                windowInputMap.put(keyStroke, \"doClick\");\n+\n+                \/\/Add ALT+ALT_GRAPH modifier which is used for right ALT key\n+                modifiers |= InputEvent.ALT_GRAPH_DOWN_MASK;\n+                keyStroke = KeyStroke.getKeyStroke(accelerator.getKeyCode(),\n+                        modifiers, accelerator.isOnKeyRelease());\n+                windowInputMap.put(keyStroke, \"doClick\");\n+            }\n","filename":"jdk\/src\/share\/classes\/javax\/swing\/plaf\/basic\/BasicMenuItemUI.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-            shortcutKeys = new int[] {KeyEvent.ALT_MASK};\n+            shortcutKeys = new int[] {KeyEvent.ALT_MASK,\n+                    KeyEvent.ALT_MASK | KeyEvent.ALT_GRAPH_MASK};\n","filename":"jdk\/src\/share\/classes\/javax\/swing\/plaf\/basic\/BasicMenuUI.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -550,0 +550,4 @@\n+        mnemonicInputMap.put(KeyStroke.getKeyStroke(mnemonic,\n+                SwingUtilities2.setAltGraphMask(\n+                        BasicLookAndFeel.getFocusAcceleratorKeyMask())),\n+                \"setSelectedIndex\");\n","filename":"jdk\/src\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTabbedPaneUI.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,0 +43,2 @@\n+import sun.swing.SwingUtilities2;\n+\n@@ -501,0 +503,4 @@\n+                    km.put(KeyStroke.getKeyStroke(accelerator,\n+                            SwingUtilities2.setAltGraphMask(\n+                            BasicLookAndFeel.getFocusAcceleratorKeyMask())),\n+                            \"requestFocus\");\n","filename":"jdk\/src\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTextUI.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,2 +48,4 @@\n-    private static AWTAccessor.KeyboardFocusManagerAccessor kfmAccessor =\n-        AWTAccessor.getKeyboardFocusManagerAccessor();\n+    private static class KfmAccessor {\n+        private static AWTAccessor.KeyboardFocusManagerAccessor instance =\n+                AWTAccessor.getKeyboardFocusManagerAccessor();\n+    }\n@@ -159,2 +161,3 @@\n-        return kfmAccessor.shouldNativelyFocusHeavyweight(\n-            heavyweight, descendant, temporary, focusedWindowChangeAllowed, time, cause);\n+        return KfmAccessor.instance.shouldNativelyFocusHeavyweight(\n+            heavyweight, descendant, temporary, focusedWindowChangeAllowed,\n+                time, cause);\n@@ -164,1 +167,1 @@\n-        kfmAccessor.removeLastFocusRequest(heavyweight);\n+        KfmAccessor.instance.removeLastFocusRequest(heavyweight);\n@@ -174,2 +177,3 @@\n-        return kfmAccessor.processSynchronousLightweightTransfer(\n-            heavyweight, descendant, temporary, focusedWindowChangeAllowed, time);\n+        return KfmAccessor.instance.processSynchronousLightweightTransfer(\n+            heavyweight, descendant, temporary, focusedWindowChangeAllowed,\n+                time);\n","filename":"jdk\/src\/share\/classes\/sun\/awt\/KeyboardFocusManagerPeerImpl.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2031,0 +2031,9 @@\n+    \/**\n+     * Sets the InputEvent.ALT_GRAPH mask on any modifier passed to the function\n+     * @param modifier the modifier passed\n+     * @return the modifier retiurned with ALT_GRAPH flag set\n+     *\/\n+    public static int setAltGraphMask(int modifier) {\n+        return (modifier | InputEvent.ALT_GRAPH_DOWN_MASK);\n+    }\n+\n","filename":"jdk\/src\/share\/classes\/sun\/swing\/SwingUtilities2.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2775,0 +2775,1 @@\n+    {java_awt_event_KeyEvent_VK_ALT_GRAPH,        VK_RMENU},\n@@ -3502,1 +3503,2 @@\n-        BOOL altIsDown = modifiers & java_awt_event_InputEvent_ALT_DOWN_MASK;\n+        BOOL altIsDown = ((modifiers & java_awt_event_InputEvent_ALT_DOWN_MASK) ||\n+                            (modifiers & java_awt_event_InputEvent_ALT_GRAPH_DOWN_MASK));\n@@ -3505,6 +3507,0 @@\n-        \/\/ Windows treats AltGr as Ctrl+Alt\n-        if (modifiers & java_awt_event_InputEvent_ALT_GRAPH_DOWN_MASK) {\n-            altIsDown = TRUE;\n-            ctrlIsDown = TRUE;\n-        }\n-\n","filename":"jdk\/src\/windows\/native\/sun\/windows\/awt_Component.cpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -318,0 +318,3 @@\n+        if (vkey == VK_RMENU) {\n+            dwFlags |= KEYEVENTF_EXTENDEDKEY;\n+        }\n","filename":"jdk\/src\/windows\/native\/sun\/windows\/awt_Robot.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,3 +24,10 @@\n-\n-import java.awt.*;\n-import java.awt.event.*;\n+import java.awt.BorderLayout;\n+import java.awt.Canvas;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n@@ -31,1 +38,1 @@\n- * @test\n+ * @test 8155742\n@@ -33,2 +40,1 @@\n- * some key with one or more modifiers.\n- *\n+ *          some key with one or more modifiers.\n@@ -63,1 +69,1 @@\n-        modifierKeys =  new int[3];\n+        modifierKeys =  new int[4];\n@@ -67,0 +73,1 @@\n+        modifierKeys[3] = KeyEvent.VK_ALT_GRAPH;\n@@ -68,1 +75,1 @@\n-        inputMasks = new int[3];\n+        inputMasks = new int[4];\n@@ -72,0 +79,1 @@\n+        inputMasks[3] =  InputEvent.ALT_GRAPH_MASK;\n","filename":"jdk\/test\/java\/awt\/Robot\/ModifierRobotKey\/ModifierRobotKeyTest.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,7 +47,3 @@\n-                    \"1. Please check if Alt-Gr key is present on keyboard.\",\n-                    \"2. If present, press the Alt-Gr key and perform\",\n-                    \"   mouse click on the TestWindow.\",\n-                    \"3. If Alt-Gr key is not present, press Ctrl+Alt keys &\",\n-                    \"   perform mouse click on the TestWindow.\",\n-                    \"4. Test will exit by itself with appropriate result.\",\n-                    \"\",\n+                    \"1. Click Pass.\",\n+                    \"2. Alt-Gr modifier is tested under Robot tests.\",\n+                    \" \",\n","filename":"jdk\/test\/java\/awt\/event\/MouseEvent\/AltGraphModifierTest\/AltGraphModifierTest.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * @bug 8080287\n- * @run RescaleAlphaTest\n+ * @bug 8080287 8136354\n+ * @run main RescaleAlphaTest\n","filename":"jdk\/test\/java\/awt\/image\/RescaleOp\/RescaleAlphaTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8194873\n+ * @requires (os.family == \"Windows\")\n+ * @summary Checks that right ALT (ALT_GRAPH) key works on Swing components\n+ * @run main RightAltKeyTest\n+ *\/\n+\n+import javax.swing.JFrame;\n+import javax.swing.JMenu;\n+import javax.swing.JMenuBar;\n+import javax.swing.JMenuItem;\n+import javax.swing.JOptionPane;\n+import javax.swing.JPanel;\n+import javax.swing.JTabbedPane;\n+import javax.swing.JTextField;\n+import javax.swing.JLabel;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.KeyStroke;\n+import javax.swing.event.MenuEvent;\n+import javax.swing.event.MenuListener;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.FocusListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.GridLayout;\n+import java.awt.Robot;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class RightAltKeyTest {\n+\n+    boolean action = false;\n+    JFrame frame;\n+\n+    void testJMenu() {\n+        frame = new JFrame(\"Menu Frame\");\n+        JMenuBar mb = new JMenuBar();\n+        JMenu m1 = new JMenu(\"File\");\n+        JMenuItem i1 = new JMenuItem(\"Save\");\n+        JMenuItem i2 = new JMenuItem(\"Load\");\n+\n+        m1.setMnemonic(KeyEvent.VK_F);\n+\n+        m1.addMenuListener(new MenuListener() {\n+            @Override\n+            public void menuSelected(MenuEvent e) {\n+                action = true;\n+                disposeUI();\n+            }\n+\n+            @Override\n+            public void menuDeselected(MenuEvent e) {\n+            }\n+\n+            @Override\n+            public void menuCanceled(MenuEvent e) {\n+            }\n+        });\n+\n+        frame.setJMenuBar(mb);\n+        mb.add(m1);\n+        m1.add(i1);\n+        m1.add(i2);\n+\n+        frame.setSize(200, 200);\n+        frame.setVisible(true);\n+    }\n+\n+    void testJMenuItem() {\n+        frame = new JFrame(\"Menu Frame\");\n+        JMenuBar mb = new JMenuBar();\n+        JMenu m1 = new JMenu(\"File\");\n+        JMenuItem i1 = new JMenuItem(\"Save\");\n+        i1.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S,\n+                InputEvent.ALT_GRAPH_DOWN_MASK));\n+        i1.addActionListener((e) -> {\n+            action = true;\n+            disposeUI();\n+        });\n+\n+        frame.setJMenuBar(mb);\n+        mb.add(m1);\n+        m1.add(i1);\n+\n+        frame.setSize(200, 200);\n+        frame.setVisible(true);\n+    }\n+\n+    void testJOptionPane() {\n+        int selection =  JOptionPane.showConfirmDialog(null, \"Do you wish \" +\n+                \"to save file?\",\"Confirm\", JOptionPane.YES_NO_CANCEL_OPTION);\n+        \/\/Pressed Yes\n+        if (selection == 0) {\n+            action = true;\n+        }\n+    }\n+\n+    void testJTabbedPane() {\n+        frame =new JFrame();\n+        JPanel p1=new JPanel();\n+        JPanel p2=new JPanel();\n+        JTabbedPane tp=new JTabbedPane();\n+        tp.add(\"Main\",p1);\n+        tp.add(\"Visit\",p2);\n+        tp.setMnemonicAt(0, KeyEvent.VK_M);\n+        tp.setMnemonicAt(1, KeyEvent.VK_V);\n+\n+        tp.addChangeListener((e) -> {\n+            if (tp.getSelectedIndex() == 1)\n+                action = true;\n+            disposeUI();\n+        });\n+\n+        frame.add(tp);\n+        frame.setSize(200,200);\n+        frame.setVisible(true);\n+    }\n+\n+    void testJTextArea() {\n+        JTextField firstField = new JTextField(10);\n+        JTextField lastField = new JTextField(10);\n+\n+        JLabel firstLabel = new JLabel(\"First Name\", JLabel.RIGHT);\n+        firstLabel.setDisplayedMnemonic('F');\n+        firstLabel.setLabelFor(firstField);\n+\n+        JLabel lastLabel = new JLabel(\"Last Name\", JLabel.RIGHT);\n+        lastLabel.setDisplayedMnemonic('L');\n+        lastLabel.setLabelFor(lastField);\n+\n+        JPanel p = new JPanel();\n+        p.setLayout(new GridLayout(2, 2, 5, 5));\n+        p.add(firstLabel);\n+        p.add(firstField);\n+        p.add(lastLabel);\n+        p.add(lastField);\n+\n+        frame = new JFrame(\"MnemonicLabels\");\n+        lastField.addFocusListener(new FocusListener() {\n+            @Override\n+            public void focusGained(FocusEvent e) {\n+                action = true;\n+                disposeUI();\n+            }\n+\n+            @Override\n+            public void focusLost(FocusEvent e) {\n+\n+            }\n+        });\n+\n+        frame.add(p);\n+        frame.setSize(200,200);\n+        frame.setVisible(true);\n+    }\n+\n+    void test() throws Exception {\n+        UIManager.LookAndFeelInfo[] lookAndFeels = UIManager\n+                .getInstalledLookAndFeels();\n+        for (UIManager.LookAndFeelInfo lookAndFeel : lookAndFeels) {\n+            UIManager.setLookAndFeel(lookAndFeel.getClassName());\n+\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            robot.waitForIdle();\n+\n+            action = false;\n+            SwingUtilities.invokeLater(this::testJMenu);\n+            robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_ALT_GRAPH);\n+            robot.keyPress(KeyEvent.VK_F);\n+            robot.keyRelease(KeyEvent.VK_F);\n+            robot.keyRelease(KeyEvent.VK_ALT_GRAPH);\n+            robot.waitForIdle();\n+            if (!action)\n+                errLog(\"JMenu\", lookAndFeel.getClassName());\n+\n+            action = false;\n+            SwingUtilities.invokeLater(this::testJMenuItem);\n+            robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_ALT_GRAPH);\n+            robot.keyPress(KeyEvent.VK_S);\n+            robot.keyRelease(KeyEvent.VK_S);\n+            robot.keyRelease(KeyEvent.VK_ALT_GRAPH);\n+            robot.waitForIdle();\n+            if (!action)\n+                errLog(\"JMenuItem\", lookAndFeel.getClassName());\n+\n+            action = false;\n+            SwingUtilities.invokeLater(this::testJOptionPane);\n+            robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_ALT_GRAPH);\n+            robot.keyPress(KeyEvent.VK_Y);\n+            robot.keyRelease(KeyEvent.VK_Y);\n+            robot.keyRelease(KeyEvent.VK_ALT_GRAPH);\n+            robot.waitForIdle();\n+            if (!action)\n+                errLog(\"JOptionPane\", lookAndFeel.getClassName());\n+\n+            action = false;\n+            SwingUtilities.invokeLater(this::testJTabbedPane);\n+            robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_ALT_GRAPH);\n+            robot.keyPress(KeyEvent.VK_V);\n+            robot.keyRelease(KeyEvent.VK_V);\n+            robot.keyRelease(KeyEvent.VK_ALT_GRAPH);\n+            robot.waitForIdle();\n+            if (!action)\n+                errLog(\"JTabbedPane\", lookAndFeel.getClassName());\n+\n+            action = false;\n+            SwingUtilities.invokeLater(this::testJTextArea);\n+            robot.waitForIdle();\n+            robot.keyPress(KeyEvent.VK_ALT_GRAPH);\n+            robot.keyPress(KeyEvent.VK_L);\n+            robot.keyRelease(KeyEvent.VK_L);\n+            robot.keyRelease(KeyEvent.VK_ALT_GRAPH);\n+            robot.waitForIdle();\n+            if (!action)\n+                errLog(\"JTextArea\", lookAndFeel.getClassName());\n+        }\n+        System.out.println(\"Passed.\");\n+    }\n+\n+    void disposeUI() {\n+        frame.setVisible(false);\n+        frame.dispose();\n+    }\n+\n+    void errLog(String componentName, String lookAndFeel)\n+            throws InvocationTargetException, InterruptedException\n+    {\n+        SwingUtilities.invokeAndWait(this::disposeUI);\n+        throw new RuntimeException(\"Actions are not performed for \"+\n+                componentName + \" with \" + lookAndFeel + \" look and feel.\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        RightAltKeyTest t = new RightAltKeyTest();\n+        t.test();\n+    }\n+}\n","filename":"jdk\/test\/javax\/swing\/event\/RightAltKeyTest.java","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test TestPrimitiveClasses\n+ * @key jfr\n+ * @library \/lib \/\n+ * @run main\/othervm jdk.jfr.jvm.TestPrimitiveClasses\n+ *\/\n+public class TestPrimitiveClasses {\n+\n+    private static class MyEvent extends Event {\n+        Class<?> booleanClass = boolean.class;\n+        Class<?> charClass = char.class;\n+        Class<?> floatClass = float.class;\n+        Class<?> doubleClass = double.class;\n+        Class<?> byteClass = byte.class;\n+        Class<?> shortClass = short.class;\n+        Class<?> intClass = int.class;\n+        Class<?> longClass = long.class;\n+        Class<?> voidClass = void.class;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(MyEvent.class);\n+            r.start();\n+            MyEvent myEvent = new MyEvent();\n+            myEvent.commit();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            RecordedEvent event = events.get(0);\n+            System.out.println(event);\n+            testField(event, \"booleanClass\", boolean.class);\n+            testField(event, \"charClass\", char.class);\n+            testField(event, \"floatClass\", float.class);\n+            testField(event, \"doubleClass\", double.class);\n+            testField(event, \"byteClass\", byte.class);\n+            testField(event, \"shortClass\", short.class);\n+            testField(event, \"intClass\", int.class);\n+            testField(event, \"longClass\", long.class);\n+            testField(event, \"voidClass\", void.class);\n+        }\n+    }\n+\n+    private static void testField(RecordedEvent event, String fieldName, Class<?> expected) {\n+        Asserts.assertTrue(event.hasField(fieldName));\n+        RecordedClass classField = event.getValue(fieldName);\n+        Asserts.assertEquals(classField.getName(), expected.getName());\n+        Asserts.assertEquals(classField.getClassLoader().getName(), \"<bootloader>\");\n+        Asserts.assertEquals(classField.getModifiers(), expected.getModifiers());\n+    }\n+}\n","filename":"jdk\/test\/jdk\/jfr\/jvm\/TestPrimitiveClasses.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"","filename":"jdk\/test\/sun\/security\/pkcs11\/nss\/db\/cert9.db","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/pkcs11\/Secmod\/cert9.db","status":"copied"},{"patch":"","filename":"jdk\/test\/sun\/security\/pkcs11\/nss\/db\/key4.db","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"jdk\/test\/sun\/security\/pkcs11\/Secmod\/key4.db","status":"copied"}]}