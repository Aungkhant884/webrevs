{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,1 @@\n-\/*\n+\/**\n@@ -28,2 +28,3 @@\n- * @library \/lib\/testlibrary\n- * @build jdk.testlibrary.NetworkConfiguration\n+ * @library \/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n@@ -31,0 +32,1 @@\n+ * @run main\/othervm -Djava.net.preferIPv4Stack=true JoinLeave\n@@ -38,1 +40,1 @@\n-import jdk.testlibrary.NetworkConfiguration;\n+import jdk.test.lib.NetworkConfiguration;\n@@ -42,1 +44,1 @@\n-    public static void main(String args[]) throws IOException  {\n+    public static void main(String args[]) throws IOException {\n@@ -51,2 +53,1 @@\n-    static void joinLeave(InetAddress group, NetworkInterface nif)\n-    {\n+    static void joinLeave(InetAddress group, NetworkInterface nif) {\n","filename":"jdk\/test\/java\/net\/MulticastSocket\/JoinLeave.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,8 +24,0 @@\n-\n-\/*\n- * @test\n- * @bug 6458027\n- * @summary Disabling IPv6 on a specific network interface causes problems.\n- *\n- *\/\n-\n@@ -33,1 +25,1 @@\n-import java.net.InetAddress;\n+import java.io.UncheckedIOException;\n@@ -36,3 +28,0 @@\n-import java.net.SocketException;\n-import java.util.Arrays;\n-import java.util.Enumeration;\n@@ -40,0 +29,1 @@\n+import jdk.test.lib.NetworkConfiguration;\n@@ -41,1 +31,11 @@\n-public class SetGetNetworkInterfaceTest  {\n+\/**\n+ * @test\n+ * @bug 6458027\n+ * @summary Disabling IPv6 on a specific network interface causes problems.\n+ * @library \/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n+ * @run main SetGetNetworkInterfaceTest\n+ * @run main\/othervm -Djava.net.preferIPv4Stack=true SetGetNetworkInterfaceTest\n+*\/\n+public class SetGetNetworkInterfaceTest {\n@@ -44,22 +44,3 @@\n-\n-        boolean passed = true;\n-        try {\n-            MulticastSocket ms = new MulticastSocket();\n-            Enumeration<NetworkInterface> networkInterfaces = NetworkInterface\n-                    .getNetworkInterfaces();\n-            while (networkInterfaces.hasMoreElements()) {\n-                NetworkInterface netIf = networkInterfaces.nextElement();\n-                if (isNetworkInterfaceTestable(netIf)) {\n-                    printNetIfDetails(netIf);\n-                    ms.setNetworkInterface(netIf);\n-                    NetworkInterface msNetIf = ms.getNetworkInterface();\n-                    if (netIf.equals(msNetIf)) {\n-                        System.out.println(\" OK\");\n-                    } else {\n-                        System.out.println(\"FAILED!!!\");\n-                        printNetIfDetails(msNetIf);\n-                        passed = false;\n-                    }\n-                    System.out.println(\"------------------\");\n-                }\n-            }\n+        NetworkConfiguration nc = NetworkConfiguration.probe();\n+        try (MulticastSocket ms = new MulticastSocket()) {\n+            nc.multicastInterfaces(true).forEach(nif -> setGetNetworkInterface(ms, nif));\n@@ -68,1 +49,0 @@\n-            passed = false;\n@@ -70,9 +50,1 @@\n-        if (!passed) {\n-            throw new RuntimeException(\"Test Fail\");\n-        }\n-        System.out.println(\"Test passed \");\n-    }\n-\n-    private static boolean isNetworkInterfaceTestable(NetworkInterface netIf) throws Exception {\n-        System.out.println(\"checking netif == \" + netIf.getName());\n-        return  (netIf.isUp() && netIf.supportsMulticast() && isIpAddrAvailable(netIf));\n+        System.out.println(\"Test passed.\");\n@@ -81,12 +53,7 @@\n-    private static boolean isIpAddrAvailable (NetworkInterface netIf) {\n-        boolean ipAddrAvailable = false;\n-        byte[] nullIpAddr = {'0', '0', '0', '0'};\n-        byte[] testIpAddr = null;\n-\n-        Enumeration<InetAddress> ipAddresses = netIf.getInetAddresses();\n-        while (ipAddresses.hasMoreElements()) {\n-            InetAddress testAddr = ipAddresses.nextElement();\n-            testIpAddr = testAddr.getAddress();\n-            if ((testIpAddr != null) && (!Arrays.equals(testIpAddr, nullIpAddr))) {\n-                ipAddrAvailable = true;\n-                break;\n+    static void setGetNetworkInterface(MulticastSocket ms, NetworkInterface nif) {\n+        try {\n+            System.out.println(NetworkConfiguration.interfaceInformation(nif));\n+            ms.setNetworkInterface(nif);\n+            NetworkInterface msNetIf = ms.getNetworkInterface();\n+            if (nif.equals(msNetIf)) {\n+                System.out.println(\" OK\");\n@@ -94,27 +61,3 @@\n-                System.out.println(\"ignore netif \" + netIf.getName());\n-            }\n-        }\n-        return ipAddrAvailable;\n-    }\n-\n-    private static void printNetIfDetails(NetworkInterface ni)\n-            throws SocketException {\n-        System.out.println(\"Name \" + ni.getName() + \" index \" + ni.getIndex());\n-        Enumeration<InetAddress> en = ni.getInetAddresses();\n-        while (en.hasMoreElements()) {\n-            System.out.println(\" InetAdress: \" + en.nextElement());\n-        }\n-        System.out.println(\"HardwareAddress: \" + createMacAddrString(ni));\n-        System.out.println(\"loopback: \" + ni.isLoopback() + \"; pointToPoint: \"\n-                + ni.isPointToPoint() + \"; virtual: \" + ni.isVirtual()\n-                + \"; MTU: \" + ni.getMTU());\n-    }\n-\n-    private static String createMacAddrString(NetworkInterface netIf)\n-            throws SocketException {\n-        byte[] macAddr = netIf.getHardwareAddress();\n-        StringBuilder sb = new StringBuilder();\n-        if (macAddr != null) {\n-            for (int i = 0; i < macAddr.length; i++) {\n-                sb.append(String.format(\"%02X%s\", macAddr[i],\n-                        (i < macAddr.length - 1) ? \"-\" : \"\"));\n+                System.out.println(\"FAILED!!!\");\n+                System.out.println(NetworkConfiguration.interfaceInformation(msNetIf));\n+                throw new RuntimeException(\"Test Fail\");\n@@ -122,0 +65,3 @@\n+            System.out.println(\"------------------\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n@@ -123,1 +69,0 @@\n-        return sb.toString();\n","filename":"jdk\/test\/java\/net\/MulticastSocket\/SetGetNetworkInterfaceTest.java","additions":31,"deletions":86,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +24,10 @@\n-\/*\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.net.SocketTimeoutException;\n+\n+import jdk.test.lib.NetworkConfiguration;\n+\n+\/**\n@@ -28,0 +37,5 @@\n+ * @library \/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n+ * @run main Test\n+ * @run main\/othervm -Djava.net.preferIPv4Stack=true Test\n@@ -29,4 +43,0 @@\n-import java.net.*;\n-import java.io.IOException;\n-import java.util.Enumeration;\n-\n@@ -38,1 +48,1 @@\n-    void doTest(String address) throws Exception {\n+    void doTest(String address) throws IOException {\n@@ -64,1 +74,1 @@\n-                for (int j=0; j<2; j++) {\n+                for (int j = 0; j < 2; j++) {\n@@ -126,1 +136,2 @@\n-    void allTests() throws Exception {\n+    void allTests() throws IOException {\n+        NetworkConfiguration nc = NetworkConfiguration.probe();\n@@ -128,3 +139,1 @@\n-        \/*\n-         * Assume machine has IPv4 address\n-         *\/\n+        \/\/ unconditionally test IPv4 address\n@@ -133,34 +142,2 @@\n-        \/*\n-         * Check if IPv6 is enabled and the scope of the addresses\n-         *\/\n-        boolean has_ipv6 = false;\n-        boolean has_siteaddress = false;\n-        boolean has_linklocaladdress = false;\n-        boolean has_globaladdress = false;\n-\n-        Enumeration nifs = NetworkInterface.getNetworkInterfaces();\n-        while (nifs.hasMoreElements()) {\n-            NetworkInterface ni = (NetworkInterface)nifs.nextElement();\n-            Enumeration addrs = ni.getInetAddresses();\n-\n-            while (addrs.hasMoreElements()) {\n-                InetAddress ia = (InetAddress)addrs.nextElement();\n-\n-                if (ia instanceof Inet6Address) {\n-                    has_ipv6 = true;\n-                    if (ia.isLinkLocalAddress()) has_linklocaladdress = true;\n-                    if (ia.isSiteLocalAddress()) has_siteaddress = true;\n-\n-                    if (!ia.isLinkLocalAddress() &&\n-                        !ia.isSiteLocalAddress() &&\n-                        !ia.isLoopbackAddress()) {\n-                        has_globaladdress = true;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * If IPv6 is enabled perform multicast tests with various scopes\n-         *\/\n-        if (has_ipv6) {\n+        \/\/ If IPv6 is enabled perform multicast tests with various scopes\n+        if (nc.hasTestableIPv6Address()) {\n@@ -170,1 +147,1 @@\n-        if (has_linklocaladdress) {\n+        if (nc.hasLinkLocalAddress()) {\n@@ -174,1 +151,1 @@\n-        if (has_siteaddress) {\n+        if (nc.hasSiteLocalAddress()) {\n@@ -178,1 +155,1 @@\n-        if (has_globaladdress) {\n+        if (nc.has_globaladdress()) {\n@@ -189,1 +166,1 @@\n-            for (int i=0; i<args.length; i++) {\n+            for (int i = 0; i < args.length; i++) {\n","filename":"jdk\/test\/java\/net\/MulticastSocket\/Test.java","additions":27,"deletions":50,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.io.IOException;\n@@ -28,1 +29,0 @@\n-import java.io.IOException;\n@@ -38,1 +38,0 @@\n-import java.util.function.Predicate;\n@@ -41,0 +40,1 @@\n+\n@@ -52,0 +52,5 @@\n+    private final boolean isIPv6Available;\n+    private boolean has_testableipv6address = false;\n+    private boolean has_sitelocaladdress = false;\n+    private boolean has_linklocaladdress = false;\n+    private boolean has_globaladdress = false;\n@@ -58,0 +63,123 @@\n+\n+        \/\/ initialize properties that can be queried\n+        isIPv6Available = !ip6Interfaces().collect(Collectors.toList()).isEmpty();\n+        ip6Interfaces().forEach(nif -> {\n+            ip6Addresses(nif)\n+                \/\/ On Solaris or AIX, a configuration with only local or loopback\n+                \/\/ addresses does not fully enable IPv6 operations.\n+                \/\/ E.g. IPv6 multicasting does not work.\n+                \/\/ So, don't set has_testableipv6address if we only find these.\n+                .filter(addr -> Platform.isSolaris() || Platform.isAix() ?\n+                    !(addr.isAnyLocalAddress() || addr.isLoopbackAddress()) : true)\n+                .forEach(ia -> {\n+                    has_testableipv6address = true;\n+                    if (ia.isLinkLocalAddress()) has_linklocaladdress = true;\n+                    if (ia.isSiteLocalAddress()) has_sitelocaladdress = true;\n+\n+                    if (!ia.isLinkLocalAddress() &&\n+                        !ia.isSiteLocalAddress() &&\n+                        !ia.isLoopbackAddress()) {\n+                        has_globaladdress = true;\n+                    }\n+                });\n+        });\n+    }\n+\n+    private static boolean isNotExcludedInterface(NetworkInterface nif) {\n+        if (Platform.isOSX() && nif.getName().contains(\"awdl\")) {\n+            return false;\n+        }\n+        if (Platform.isWindows()) {\n+            String dName = nif.getDisplayName();\n+            if (dName != null && dName.contains(\"Teredo\")) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private static boolean isNotLoopback(NetworkInterface nif) {\n+        try {\n+            return !nif.isLoopback();\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private boolean hasIp4Addresses(NetworkInterface nif) {\n+        return ip4Interfaces.get(nif).stream().anyMatch(a -> !a.isAnyLocalAddress());\n+    }\n+\n+    private boolean hasIp6Addresses(NetworkInterface nif) {\n+        return ip6Interfaces.get(nif).stream().anyMatch(a -> !a.isAnyLocalAddress());\n+    }\n+\n+    private boolean supportsIp4Multicast(NetworkInterface nif) {\n+        try {\n+            if (!nif.supportsMulticast()) {\n+                return false;\n+            }\n+\n+            \/\/ On AIX there is a bug:\n+            \/\/ When IPv6 is enabled on the system, the JDK opens sockets as AF_INET6.\n+            \/\/ If there's an interface configured with IPv4 addresses only, it should\n+            \/\/ be able to become the network interface for a multicast socket (that\n+            \/\/ could be in both, IPv4 or IPv6 space). But both possible setsockopt\n+            \/\/ calls for either IPV6_MULTICAST_IF or IP_MULTICAST_IF return\n+            \/\/ EADDRNOTAVAIL. So we must skip such interfaces here.\n+            if (Platform.isAix() && isIPv6Available() && !hasIp6Addresses(nif)) {\n+                return false;\n+            }\n+\n+            return hasIp4Addresses(nif);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    private boolean supportsIp6Multicast(NetworkInterface nif) {\n+        try {\n+            if (!nif.supportsMulticast()) {\n+                return false;\n+            }\n+\n+            return hasIp6Addresses(nif);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    \/**\n+     * Returns whether IPv6 is available at all.\n+     * This should resemble the result of native ipv6_available() in net_util.c\n+     *\/\n+    public boolean isIPv6Available() {\n+        return isIPv6Available;\n+    }\n+\n+    \/**\n+     * Does any (usable) IPv6 address exist in the network configuration?\n+     *\/\n+    public boolean hasTestableIPv6Address() {\n+        return has_testableipv6address;\n+    }\n+\n+    \/**\n+     * Does any site local address exist?\n+     *\/\n+    public boolean hasSiteLocalAddress() {\n+        return has_sitelocaladdress;\n+    }\n+\n+    \/**\n+     * Does any link local address exist?\n+     *\/\n+    public boolean hasLinkLocalAddress() {\n+        return has_linklocaladdress;\n+    }\n+\n+    \/**\n+     * Does any global IPv6 address exist?\n+     *\/\n+    public boolean has_globaladdress() {\n+        return has_globaladdress;\n@@ -75,1 +203,1 @@\n-                            .filter(hasIp4Addresses);\n+                            .filter(this::hasIp4Addresses);\n@@ -85,1 +213,1 @@\n-                            .filter(hasIp6Addresses);\n+                            .filter(this::hasIp6Addresses);\n@@ -88,9 +216,8 @@\n-    private static boolean isNotExcludedInterface(NetworkInterface nif) {\n-        if (Platform.isOSX() && nif.getName().contains(\"awdl\")) {\n-            return false;\n-        }\n-        String dName = nif.getDisplayName();\n-        if (Platform.isWindows() && dName != null && dName.contains(\"Teredo\")) {\n-            return false;\n-        }\n-        return true;\n+    \/**\n+     * Returns a stream of interfaces suitable for functional tests.\n+     *\/\n+    public Stream<NetworkInterface> multicastInterfaces(boolean includeLoopback) {\n+        return Stream\n+            .concat(ip4MulticastInterfaces(includeLoopback),\n+                    ip6MulticastInterfaces(includeLoopback))\n+            .distinct();\n@@ -99,7 +226,0 @@\n-    private final Predicate<NetworkInterface> hasIp4Addresses = nif ->\n-            ip4Interfaces.get(nif).stream().anyMatch(a -> !a.isAnyLocalAddress());\n-\n-    private final Predicate<NetworkInterface> hasIp6Addresses = nif ->\n-            ip6Interfaces.get(nif).stream().anyMatch(a -> !a.isAnyLocalAddress());\n-\n-\n@@ -108,0 +228,2 @@\n+     *\n+     * The loopback interface will not be included.\n@@ -110,1 +232,11 @@\n-        return ip4Interfaces().filter(supportsIp4Multicast);\n+        return ip4MulticastInterfaces(false);\n+    }\n+\n+    \/**\n+     * Returns a stream of interfaces suitable for IPv4 multicast tests.\n+     *\/\n+    public Stream<NetworkInterface> ip4MulticastInterfaces(boolean includeLoopback) {\n+        return (includeLoopback) ?\n+            ip4Interfaces().filter(this::supportsIp4Multicast) :\n+            ip4Interfaces().filter(this::supportsIp4Multicast)\n+                .filter(NetworkConfiguration::isNotLoopback);\n@@ -115,0 +247,2 @@\n+     *\n+     * The loopback interface will not be included.\n@@ -117,1 +251,1 @@\n-        return ip6Interfaces().filter(supportsIp6Multicast);\n+        return ip6MulticastInterfaces(false);\n@@ -120,22 +254,9 @@\n-    private final Predicate<NetworkInterface> supportsIp4Multicast = nif -> {\n-        try {\n-            if (!nif.supportsMulticast() || nif.isLoopback()) {\n-                return false;\n-            }\n-            return hasIp4Addresses.test(nif);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    };\n-\n-    private final Predicate<NetworkInterface> supportsIp6Multicast = nif -> {\n-        try {\n-            if (!nif.supportsMulticast() || nif.isLoopback()) {\n-                return false;\n-            }\n-\n-            return hasIp6Addresses.test(nif);\n-        } catch (IOException e) {\n-            throw new UncheckedIOException(e);\n-        }\n-    };\n+    \/**\n+     * Returns a stream of interfaces suitable for IPv6 multicast tests.\n+     *\/\n+    public Stream<NetworkInterface> ip6MulticastInterfaces(boolean includeLoopback) {\n+        return (includeLoopback) ?\n+            ip6Interfaces().filter(this::supportsIp6Multicast) :\n+            ip6Interfaces().filter(this::supportsIp6Multicast)\n+                .filter(NetworkConfiguration::isNotLoopback);\n+    }\n@@ -179,0 +300,6 @@\n+    @Override\n+    public String toString() {\n+        return interfaces().map(NetworkConfiguration::interfaceInformation)\n+                           .collect(Collectors.joining());\n+    }\n+\n@@ -208,6 +335,0 @@\n-    @Override\n-    public String toString() {\n-        return interfaces().map(NetworkConfiguration::interfaceInformation)\n-                           .collect(Collectors.joining());\n-    }\n-\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/NetworkConfiguration.java","additions":172,"deletions":51,"binary":false,"changes":223,"status":"modified"}]}