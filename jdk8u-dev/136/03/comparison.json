{"files":[{"patch":"@@ -181,0 +181,4 @@\n+      - name: Pack artifacts\n+        run: |\n+          tar -cf jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}.tar.gz -C jdk\/build\/linux-x64\/images j2sdk-image\n+\n@@ -186,2 +190,1 @@\n-            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/linux-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}.tar.gz\n@@ -192,1 +195,0 @@\n-    if: false\n@@ -201,9 +203,3 @@\n-          - jdk\/tier1 part 1\n-          - jdk\/tier1 part 2\n-          - jdk\/tier1 part 3\n-          - langtools\/tier1\n-          - hs\/tier1 common\n-          - hs\/tier1 compiler\n-          - hs\/tier1 gc\n-          - hs\/tier1 runtime\n-          - hs\/tier1 serviceability\n+          - jdk\/tier1\n+#          - langtools\/tier1\n+#          - hotspot\/tier1\n@@ -211,23 +207,6 @@\n-          - test: jdk\/tier1 part 1\n-            suites: test\/jdk\/:tier1_part1\n-          - test: jdk\/tier1 part 2\n-            suites: test\/jdk\/:tier1_part2\n-          - test: jdk\/tier1 part 3\n-            suites: test\/jdk\/:tier1_part3\n-          - test: langtools\/tier1\n-            suites: test\/langtools\/:tier1\n-          - test: hs\/tier1 common\n-            suites: test\/hotspot\/jtreg\/:tier1_common\n-            artifact: -debug\n-          - test: hs\/tier1 compiler\n-            suites: test\/hotspot\/jtreg\/:tier1_compiler\n-            artifact: -debug\n-          - test: hs\/tier1 gc\n-            suites: test\/hotspot\/jtreg\/:tier1_gc\n-            artifact: -debug\n-          - test: hs\/tier1 runtime\n-            suites: test\/hotspot\/jtreg\/:tier1_runtime\n-            artifact: -debug\n-          - test: hs\/tier1 serviceability\n-            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n-            artifact: -debug\n+          - test: jdk\/tier1\n+            suites: jdk_tier1\n+#          - test: langtools\/tier1\n+#            suites: langtools_tier1\n+#          - test: hotspot\/tier1\n+#            suites: hotspot_tier1\n@@ -283,10 +262,0 @@\n-      - name: Unpack tests\n-        run: |\n-          mkdir -p \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}\"\n-\n-      - name: Find root of jdk image dir\n-        run: |\n-          imageroot=`find ${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }} -name release -type f`\n-          echo \"imageroot=`dirname ${imageroot}`\" >> $GITHUB_ENV\n-\n@@ -295,12 +264,10 @@\n-          JDK_IMAGE_DIR=${{ env.imageroot }}\n-          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin-tests${{ matrix.artifact }}\n-          BOOT_JDK=${BOOT_JDK}\n-          JT_HOME=${HOME}\/jtreg\n-          make run-test-prebuilt\n-          CONF_NAME=run-test-prebuilt\n-          LOG_CMDLINES=true\n-          JTREG_VERBOSE=fail,error,time\n-          TEST=\"${{ matrix.suites }}\"\n-          TEST_OPTS_JAVA_OPTIONS=\n-          JTREG_KEYWORDS=\"!headful\"\n-          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+          chmod +x \"${HOME}\/jtreg\/bin\/jtreg\" &&\n+          mkdir test-results &&\n+          cd test &&\n+          PRODUCT_HOME=\"${HOME}\/jdk-linux-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x64_bin${{ matrix.artifact }}\/j2sdk-image\"\n+          JT_HOME=\"${HOME}\/jtreg\"\n+          ALT_OUTPUTDIR=\"${GITHUB_WORKSPACE}\/test-results\"\n+          JAVA_ARGS=\"-Djdk.test.docker.image.name=ubuntu -Djdk.test.docker.image.version=latest\"\n+          JTREG_TIMEOUT_FACTOR=\"4\"\n+          make\n+          \"${{ matrix.suites }}\"\n@@ -311,2 +278,3 @@\n-          if ! grep --include=test-summary.txt -lqr build\/*\/test-results -e \"TEST SUCCESS\" ; then\n-            cat build\/*\/test-results\/*\/text\/newfailures.txt ;\n+          if cat test-results\/testoutput\/*\/exitcode.txt | grep -q -v '^0$'\n+          || ! cat test-results\/testoutput\/*\/Stats.txt | grep -q 'fail=0' ; then\n+            cat test-results\/testoutput\/*\/JTreport\/text\/newfailures.txt ;\n@@ -322,1 +290,1 @@\n-        working-directory: build\/run-test-prebuilt\/test-results\/\n+        working-directory: test-results\n@@ -327,12 +295,1 @@\n-        continue-on-error: true\n-\n-      - name: Package test support\n-        if: always()\n-        working-directory: build\/run-test-prebuilt\/test-support\/\n-        run: >\n-          zip -r9\n-          \"$HOME\/linux-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n-          .\n-          -i *.jtr\n-          -i *\/hs_err*.log\n-          -i *\/replay*.log\n+          -x \"*ARCHIVE_BUNDLE.zip\"\n@@ -348,7 +305,0 @@\n-      - name: Persist test outputs\n-        if: always()\n-        uses: actions\/upload-artifact@v2\n-        with:\n-          path: ~\/linux-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n-        continue-on-error: true\n-\n@@ -587,0 +537,4 @@\n+      - name: Pack artifacts\n+        run: |\n+          tar -cf jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}.tar.gz -C jdk\/build\/linux-x86\/images j2sdk-image\n+\n@@ -592,2 +546,1 @@\n-            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/linux-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}.tar.gz\n@@ -598,1 +551,0 @@\n-    if: false\n@@ -607,9 +559,3 @@\n-          - jdk\/tier1 part 1\n-          - jdk\/tier1 part 2\n-          - jdk\/tier1 part 3\n-          - langtools\/tier1\n-          - hs\/tier1 common\n-          - hs\/tier1 compiler\n-          - hs\/tier1 gc\n-          - hs\/tier1 runtime\n-          - hs\/tier1 serviceability\n+          - jdk\/tier1\n+#          - langtools\/tier1\n+#          - hotspot\/tier1\n@@ -617,23 +563,6 @@\n-          - test: jdk\/tier1 part 1\n-            suites: test\/jdk\/:tier1_part1\n-          - test: jdk\/tier1 part 2\n-            suites: test\/jdk\/:tier1_part2\n-          - test: jdk\/tier1 part 3\n-            suites: test\/jdk\/:tier1_part3\n-          - test: langtools\/tier1\n-            suites: test\/langtools\/:tier1\n-          - test: hs\/tier1 common\n-            suites: test\/hotspot\/jtreg\/:tier1_common\n-            artifact: -debug\n-          - test: hs\/tier1 compiler\n-            suites: test\/hotspot\/jtreg\/:tier1_compiler\n-            artifact: -debug\n-          - test: hs\/tier1 gc\n-            suites: test\/hotspot\/jtreg\/:tier1_gc\n-            artifact: -debug\n-          - test: hs\/tier1 runtime\n-            suites: test\/hotspot\/jtreg\/:tier1_runtime\n-            artifact: -debug\n-          - test: hs\/tier1 serviceability\n-            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n-            artifact: -debug\n+          - test: jdk\/tier1\n+            suites: jdk_tier1\n+#          - test: langtools\/tier1\n+#            suites: langtools_tier1\n+#          - test: hotspot\/tier1\n+#            suites: hotspot_tier1\n@@ -690,10 +619,0 @@\n-      - name: Unpack tests\n-        run: |\n-          mkdir -p \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\"\n-\n-      - name: Find root of jdk image dir\n-        run: |\n-          imageroot=`find ${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }} -name release -type f`\n-          echo \"imageroot=`dirname ${imageroot}`\" >> $GITHUB_ENV\n-\n@@ -702,12 +621,10 @@\n-          JDK_IMAGE_DIR=${{ env.imageroot }}\n-          TEST_IMAGE_DIR=${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin-tests${{ matrix.artifact }}\n-          BOOT_JDK=${BOOT_JDK}\n-          JT_HOME=${HOME}\/jtreg\n-          make run-test-prebuilt\n-          CONF_NAME=run-test-prebuilt\n-          LOG_CMDLINES=true\n-          JTREG_VERBOSE=fail,error,time\n-          TEST=\"${{ matrix.suites }}\"\n-          TEST_OPTS_JAVA_OPTIONS=\n-          JTREG_KEYWORDS=\"!headful\"\n-          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+          chmod +x \"${HOME}\/jtreg\/bin\/jtreg\" &&\n+          mkdir test-results &&\n+          cd test &&\n+          PRODUCT_HOME=\"${HOME}\/jdk-linux-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_linux-x86_bin${{ matrix.artifact }}\/j2sdk-image\"\n+          JT_HOME=\"${HOME}\/jtreg\"\n+          ALT_OUTPUTDIR=\"${GITHUB_WORKSPACE}\/test-results\"\n+          JAVA_ARGS=\"-Djdk.test.docker.image.name=ubuntu -Djdk.test.docker.image.version=latest\"\n+          JTREG_TIMEOUT_FACTOR=\"4\"\n+          make\n+          \"${{ matrix.suites }}\"\n@@ -718,2 +635,3 @@\n-          if ! grep --include=test-summary.txt -lqr build\/*\/test-results -e \"TEST SUCCESS\" ; then\n-            cat build\/*\/test-results\/*\/text\/newfailures.txt ;\n+          if cat test-results\/testoutput\/*\/exitcode.txt | grep -q -v '^0$'\n+          || ! cat test-results\/testoutput\/*\/Stats.txt | grep -q 'fail=0' ; then\n+            cat test-results\/testoutput\/*\/JTreport\/text\/newfailures.txt ;\n@@ -729,1 +647,1 @@\n-        working-directory: build\/run-test-prebuilt\/test-results\/\n+        working-directory: test-results\n@@ -734,12 +652,1 @@\n-        continue-on-error: true\n-\n-      - name: Package test support\n-        if: always()\n-        working-directory: build\/run-test-prebuilt\/test-support\/\n-        run: >\n-          zip -r9\n-          \"$HOME\/linux-x86${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n-          .\n-          -i *.jtr\n-          -i *\/hs_err*.log\n-          -i *\/replay*.log\n+          -x \"*ARCHIVE_BUNDLE.zip\"\n@@ -755,7 +662,0 @@\n-      - name: Persist test outputs\n-        if: always()\n-        uses: actions\/upload-artifact@v2\n-        with:\n-          path: ~\/linux-x86${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n-        continue-on-error: true\n-\n@@ -913,0 +813,9 @@\n+      - name: Pack artifacts\n+        run: >\n+          dir ;\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          zip -r9\n+          \"${{ github.workspace }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}.zip\"\n+          j2sdk-image\n+        working-directory: jdk\/build\/windows-x64\/images\n+\n@@ -918,3 +827,1 @@\n-            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}.zip\n-            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/windows-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\n+            jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}.zip\n@@ -1066,0 +973,9 @@\n+      - name: Pack artifacts\n+        run: >\n+          dir ;\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          zip -r9\n+          \"${{ github.workspace }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x86_bin${{ matrix.artifact }}.zip\"\n+          j2sdk-image\n+        working-directory: jdk\/build\/windows-x86\/images\n+\n@@ -1071,3 +987,1 @@\n-            jdk\/build\/windows-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x86_bin${{ matrix.artifact }}.zip\n-            jdk\/build\/windows-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x86_bin-tests${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/windows-x86\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x86_bin${{ matrix.artifact }}-symbols.tar.gz\n+            jdk-${{ env.JDK_VERSION }}-internal+0_windows-x86_bin${{ matrix.artifact }}.zip\n@@ -1078,1 +992,0 @@\n-    if: false\n@@ -1087,9 +1000,3 @@\n-          - jdk\/tier1 part 1\n-          - jdk\/tier1 part 2\n-          - jdk\/tier1 part 3\n-          - langtools\/tier1\n-          - hs\/tier1 common\n-          - hs\/tier1 compiler\n-          - hs\/tier1 gc\n-          - hs\/tier1 runtime\n-          - hs\/tier1 serviceability\n+          - jdk\/tier1\n+#          - langtools\/tier1\n+#          - hotspot\/tier1\n@@ -1097,23 +1004,6 @@\n-          - test: jdk\/tier1 part 1\n-            suites: test\/jdk\/:tier1_part1\n-          - test: jdk\/tier1 part 2\n-            suites: test\/jdk\/:tier1_part2\n-          - test: jdk\/tier1 part 3\n-            suites: test\/jdk\/:tier1_part3\n-          - test: langtools\/tier1\n-            suites: test\/langtools\/:tier1\n-          - test: hs\/tier1 common\n-            suites: test\/hotspot\/jtreg\/:tier1_common\n-            artifact: -debug\n-          - test: hs\/tier1 compiler\n-            suites: test\/hotspot\/jtreg\/:tier1_compiler\n-            artifact: -debug\n-          - test: hs\/tier1 gc\n-            suites: test\/hotspot\/jtreg\/:tier1_gc\n-            artifact: -debug\n-          - test: hs\/tier1 runtime\n-            suites: test\/hotspot\/jtreg\/:tier1_runtime\n-            artifact: -debug\n-          - test: hs\/tier1 serviceability\n-            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n-            artifact: -debug\n+          - test: jdk\/tier1\n+            suites: jdk_tier1\n+#          - test: langtools\/tier1\n+#            suites: langtools_tier1\n+#          - test: hotspot\/tier1\n+#            suites: hotspot_tier1\n@@ -1197,1 +1087,1 @@\n-      - name: Unpack symbols\n+      - name: Create results dir\n@@ -1199,10 +1089,1 @@\n-          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols\"\n-          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}-symbols\"\n-\n-      - name: Unpack tests\n-        run: |\n-          mkdir -p \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}\"\n-\n-      - name: Find root of jdk image dir\n-        run: echo (\"imageroot=\" + (Get-ChildItem -Path $HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }} -Filter release -Recurse -ErrorAction SilentlyContinue -Force).DirectoryName) | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8\n+          mkdir test-results\n@@ -1211,0 +1092,1 @@\n+        working-directory: test\n@@ -1214,4 +1096,1 @@\n-          $env:JDK_IMAGE_DIR = cygpath \"${{ env.imageroot }}\" ;\n-          $env:SYMBOLS_IMAGE_DIR = cygpath \"${{ env.imageroot }}\" ;\n-          $env:TEST_IMAGE_DIR = cygpath \"$HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin-tests${{ matrix.artifact }}\" ;\n-          $env:BOOT_JDK = cygpath \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\" ;\n+          $env:PRODUCT_HOME = cygpath \"$HOME\/jdk-windows-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x64_bin${{ matrix.artifact }}\/j2sdk-image\" ;\n@@ -1219,8 +1098,5 @@\n-          & make run-test-prebuilt\n-          CONF_NAME=run-test-prebuilt\n-          LOG_CMDLINES=true\n-          JTREG_VERBOSE=fail,error,time\n-          TEST=${{ matrix.suites }}\n-          TEST_OPTS_JAVA_OPTIONS=\n-          JTREG_KEYWORDS=\"!headful\"\n-          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+          $env:ALT_OUTPUTDIR = cygpath \"$env:GITHUB_WORKSPACE\/test-results\" ;\n+          $env:JAVA_ARGS = \"-XX:-CreateMinidumpOnCrash -Djdk.test.container.command=skipcontianer\" ;\n+          $env:JTREG_TIMEOUT_FACTOR = \"4\" ;\n+          & make\n+          \"${{ matrix.suites }}\"\n@@ -1231,2 +1107,2 @@\n-          if ((Get-ChildItem -Path build\\*\\test-results\\test-summary.txt -Recurse | Select-String -Pattern \"TEST SUCCESS\" ).Count -eq 0) {\n-            Get-Content -Path build\\*\\test-results\\*\\*\\newfailures.txt ;\n+          if ((Get-ChildItem -Path test-results\\testoutput\\*\\exitcode.txt -Recurse | Select-String -Pattern '^0$' -NotMatch ).Count -gt 0) {\n+            Get-Content -Path test-results\\testoutput\\*\\JTreport\\text\\newfailures.txt ;\n@@ -1242,1 +1118,1 @@\n-        working-directory: build\/run-test-prebuilt\/test-results\/\n+        working-directory: test-results\n@@ -1248,0 +1124,79 @@\n+          -x \"*ARCHIVE_BUNDLE.zip\"\n+        continue-on-error: true\n+\n+      - name: Persist test results\n+        if: always()\n+        uses: actions\/upload-artifact@v2\n+        with:\n+          path: ~\/windows-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n+        continue-on-error: true\n+\n+  windows_x86_test:\n+    name: Windows x86\n+    runs-on: \"windows-2019\"\n+    needs:\n+      - prerequisites\n+      - windows_x86_build\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        test:\n+          - jdk\/tier1\n+#          - langtools\/tier1\n+#          - hotspot\/tier1\n+        include:\n+          - test: jdk\/tier1\n+            suites: jdk_tier1\n+#          - test: langtools\/tier1\n+#            suites: langtools_tier1\n+#          - test: hotspot\/tier1\n+#            suites: hotspot_tier1\n+\n+    env:\n+      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).JDK_MAJOR_VERSION }}.${{ fromJson(needs.prerequisites.outputs.dependencies).JDK_MINOR_VERSION }}.${{ fromJson(needs.prerequisites.outputs.dependencies).JDK_MICRO_VERSION }}\"\n+      BOOT_JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).BOOT_JDK_VERSION }}\"\n+      BOOT_JDK_FILENAME: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X86_BOOT_JDK_FILENAME }}\"\n+      BOOT_JDK_URL: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X86_BOOT_JDK_URL }}\"\n+      BOOT_JDK_SHA256: \"${{ fromJson(needs.prerequisites.outputs.dependencies).WINDOWS_X86_BOOT_JDK_SHA256 }}\"\n+\n+    steps:\n+      - name: Checkout the source\n+        uses: actions\/checkout@v2\n+\n+      - name: Restore boot JDK from cache\n+        id: bootjdk\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/bootjdk\/${{ env.BOOT_JDK_VERSION }}\n+          key: bootjdk-${{ runner.os }}-${{ env.BOOT_JDK_VERSION }}-${{ env.BOOT_JDK_SHA256 }}-v1\n+\n+      - name: Download boot JDK\n+        run: |\n+          mkdir -p \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+          & curl -L \"$env:BOOT_JDK_URL\" -o \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash = Get-FileHash -Algorithm SHA256 \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\"\n+          $FileHash.Hash -eq $env:BOOT_JDK_SHA256\n+          & tar -xf \"$HOME\/bootjdk\/$env:BOOT_JDK_FILENAME\" -C \"$HOME\/bootjdk\/$env:BOOT_JDK_VERSION\"\n+          Get-ChildItem \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\\*\\*\" | Move-Item -Destination \"$HOME\\bootjdk\\$env:BOOT_JDK_VERSION\"\n+        if: steps.bootjdk.outputs.cache-hit != 'true'\n+\n+      - name: Restore cygwin packages from cache\n+        id: cygwin\n+        uses: actions\/cache@v2\n+        with:\n+          path: ~\/cygwin\/packages\n+          key: cygwin-packages-${{ runner.os }}-v1\n+\n+      - name: Install cygwin\n+        run: |\n+          New-Item -Force -ItemType directory -Path \"$HOME\\cygwin\"\n+          & curl -L \"https:\/\/www.cygwin.com\/setup-x86_64.exe\" -o \"$HOME\/cygwin\/setup-x86_64.exe\"\n+          Start-Process -FilePath \"$HOME\\cygwin\\setup-x86_64.exe\" -ArgumentList \"--quiet-mode --packages autoconf,make,zip,unzip --root $HOME\\cygwin\\cygwin64 --local-package-dir $HOME\\cygwin\\packages --site http:\/\/mirrors.kernel.org\/sourceware\/cygwin --no-desktop --no-shortcuts --no-startmenu --no-admin\" -Wait -NoNewWindow\n+\n+      - name: Restore jtreg artifact\n+        id: jtreg_restore\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n@@ -1250,1 +1205,45 @@\n-      - name: Package test support\n+      - name: Restore jtreg artifact (retry)\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jtreg_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jtreg\/\n+        if: steps.jtreg_restore.outcome == 'failure'\n+\n+      - name: Restore build artifacts\n+        id: build_restore\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jdk-windows-x86${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-windows-x86${{ matrix.artifact }}\n+        continue-on-error: true\n+\n+      - name: Restore build artifacts (retry)\n+        uses: actions\/download-artifact@v2\n+        with:\n+          name: transient_jdk-windows-x86${{ matrix.artifact }}_${{ needs.prerequisites.outputs.bundle_id }}\n+          path: ~\/jdk-windows-x86${{ matrix.artifact }}\n+        if: steps.build_restore.outcome == 'failure'\n+\n+      - name: Unpack jdk\n+        run: |\n+          mkdir -p \"${HOME}\/jdk-windows-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x86_bin${{ matrix.artifact }}\"\n+          tar -xf \"${HOME}\/jdk-windows-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x86_bin${{ matrix.artifact }}.zip\" -C \"${HOME}\/jdk-windows-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x86_bin${{ matrix.artifact }}\"\n+\n+      - name: Create results dir\n+        run: |\n+          mkdir test-results\n+\n+      - name: Run tests\n+        working-directory: test\n+        run: >\n+          $env:Path = \"$HOME\\cygwin\\cygwin64\\bin;$HOME\\cygwin\\cygwin64\\bin;$env:Path\" ;\n+          $env:Path = $env:Path -split \";\" -match \"C:\\\\Windows|PowerShell|cygwin\" -join \";\" ;\n+          $env:PRODUCT_HOME = cygpath \"$HOME\/jdk-windows-x86${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_windows-x86_bin${{ matrix.artifact }}\/j2sdk-image\" ;\n+          $env:JT_HOME = cygpath \"$HOME\/jtreg\" ;\n+          $env:ALT_OUTPUTDIR = cygpath \"$env:GITHUB_WORKSPACE\/test-results\" ;\n+          $env:JAVA_ARGS = \"-XX:-CreateMinidumpOnCrash -Djdk.test.container.command=skipcontianer\" ;\n+          $env:JTREG_TIMEOUT_FACTOR = \"4\" ;\n+          & make\n+          \"${{ matrix.suites }}\"\n+\n+      - name: Check that all tests executed successfully\n@@ -1252,1 +1251,13 @@\n-        working-directory: build\/run-test-prebuilt\/test-support\/\n+        run: >\n+          if ((Get-ChildItem -Path test-results\\testoutput\\*\\exitcode.txt -Recurse | Select-String -Pattern '^0$' -NotMatch ).Count -gt 0) {\n+            Get-Content -Path test-results\\testoutput\\*\\JTreport\\text\\newfailures.txt ;\n+            exit 1\n+          }\n+\n+      - name: Create suitable test log artifact name\n+        if: always()\n+        run: echo (\"logsuffix=\" + (\"${{ matrix.test }}\" -replace \"\/\", \"_\" -replace \" \", \"_\")) | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8\n+\n+      - name: Package test results\n+        if: always()\n+        working-directory: test-results\n@@ -1256,1 +1267,1 @@\n-          \"$HOME\/windows-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n+          \"$HOME\/windows-x86${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\"\n@@ -1258,3 +1269,1 @@\n-          -i *.jtr\n-          -i *\/hs_err*.log\n-          -i *\/replay*.log\n+          -x \"*ARCHIVE_BUNDLE.zip\"\n@@ -1267,8 +1276,1 @@\n-          path: ~\/windows-x64${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n-        continue-on-error: true\n-\n-      - name: Persist test outputs\n-        if: always()\n-        uses: actions\/upload-artifact@v2\n-        with:\n-          path: ~\/windows-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n+          path: ~\/windows-x86${{ matrix.artifact }}_testresults_${{ env.logsuffix }}.zip\n@@ -1364,0 +1366,4 @@\n+      - name: Pack artifacts\n+        run: |\n+          tar -cf jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin${{ matrix.artifact }}.tar.gz -C jdk\/build\/macos-x64\/images j2sdk-image\n+\n@@ -1369,2 +1375,1 @@\n-            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin${{ matrix.artifact }}.tar.gz\n-            jdk\/build\/macos-x64\/bundles\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin-tests${{ matrix.artifact }}.tar.gz\n+            jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin${{ matrix.artifact }}.tar.gz\n@@ -1375,1 +1380,0 @@\n-    if: false\n@@ -1384,9 +1388,3 @@\n-          - jdk\/tier1 part 1\n-          - jdk\/tier1 part 2\n-          - jdk\/tier1 part 3\n-          - langtools\/tier1\n-          - hs\/tier1 common\n-          - hs\/tier1 compiler\n-          - hs\/tier1 gc\n-          - hs\/tier1 runtime\n-          - hs\/tier1 serviceability\n+          - jdk\/tier1\n+#          - langtools\/tier1\n+#          - hotspot\/tier1\n@@ -1394,23 +1392,6 @@\n-          - test: jdk\/tier1 part 1\n-            suites: test\/jdk\/:tier1_part1\n-          - test: jdk\/tier1 part 2\n-            suites: test\/jdk\/:tier1_part2\n-          - test: jdk\/tier1 part 3\n-            suites: test\/jdk\/:tier1_part3\n-          - test: langtools\/tier1\n-            suites: test\/langtools\/:tier1\n-          - test: hs\/tier1 common\n-            suites: test\/hotspot\/jtreg\/:tier1_common\n-            artifact: -debug\n-          - test: hs\/tier1 compiler\n-            suites: test\/hotspot\/jtreg\/:tier1_compiler\n-            artifact: -debug\n-          - test: hs\/tier1 gc\n-            suites: test\/hotspot\/jtreg\/:tier1_gc\n-            artifact: -debug\n-          - test: hs\/tier1 runtime\n-            suites: test\/hotspot\/jtreg\/:tier1_runtime\n-            artifact: -debug\n-          - test: hs\/tier1 serviceability\n-            suites: test\/hotspot\/jtreg\/:tier1_serviceability\n-            artifact: -debug\n+          - test: jdk\/tier1\n+            suites: jdk_tier1\n+#          - test: langtools\/tier1\n+#            suites: langtools_tier1\n+#          - test: hotspot\/tier1\n+#            suites: hotspot_tier1\n@@ -1480,5 +1461,0 @@\n-      - name: Unpack tests\n-        run: |\n-          mkdir -p \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin-tests${{ matrix.artifact }}\"\n-          tar -xf \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin-tests${{ matrix.artifact }}.tar.gz\" -C \"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin-tests${{ matrix.artifact }}\"\n-\n@@ -1491,5 +1467,0 @@\n-      - name: Find root of jdk image dir\n-        run: |\n-          imageroot=`find ${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin${{ matrix.artifact }} -name release -type f`\n-          echo \"imageroot=`dirname ${imageroot}`\" >> $GITHUB_ENV\n-\n@@ -1498,12 +1469,9 @@\n-          JDK_IMAGE_DIR=${{ env.imageroot }}\n-          TEST_IMAGE_DIR=${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin-tests${{ matrix.artifact }}\n-          BOOT_JDK=${HOME}\/bootjdk\/${BOOT_JDK_VERSION}\/Contents\/Home\n-          JT_HOME=${HOME}\/jtreg\n-          gmake run-test-prebuilt\n-          CONF_NAME=run-test-prebuilt\n-          LOG_CMDLINES=true\n-          JTREG_VERBOSE=fail,error,time\n-          TEST=${{ matrix.suites }}\n-          TEST_OPTS_JAVA_OPTIONS=\n-          JTREG_KEYWORDS=\"!headful\"\n-          JTREG=\"JAVA_OPTIONS=-XX:-CreateCoredumpOnCrash\"\n+          chmod +x \"${HOME}\/jtreg\/bin\/jtreg\" &&\n+          mkdir test-results &&\n+          cd test &&\n+          PRODUCT_HOME=\"${HOME}\/jdk-macos-x64${{ matrix.artifact }}\/jdk-${{ env.JDK_VERSION }}-internal+0_osx-x64_bin${{ matrix.artifact }}\/j2sdk-image\"\n+          JT_HOME=\"${HOME}\/jtreg\"\n+          ALT_OUTPUTDIR=\"${GITHUB_WORKSPACE}\/test-results\"\n+          JTREG_TIMEOUT_FACTOR=\"4\"\n+          gmake\n+          \"${{ matrix.suites }}\"\n@@ -1514,2 +1482,3 @@\n-          if ! grep --include=test-summary.txt -lqr build\/*\/test-results -e \"TEST SUCCESS\" ; then\n-            cat build\/*\/test-results\/*\/text\/newfailures.txt ;\n+          if cat test-results\/testoutput\/*\/exitcode.txt | grep -q -v '^0$'\n+          || ! cat test-results\/testoutput\/*\/Stats.txt | grep -q 'fail=0' ; then\n+            cat test-results\/testoutput\/*\/JTreport\/text\/newfailures.txt ;\n@@ -1525,1 +1494,1 @@\n-        working-directory: build\/run-test-prebuilt\/test-results\/\n+        working-directory: test-results\n@@ -1530,12 +1499,1 @@\n-        continue-on-error: true\n-\n-      - name: Package test support\n-        if: always()\n-        working-directory: build\/run-test-prebuilt\/test-support\/\n-        run: >\n-          zip -r9\n-          \"$HOME\/macos-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\"\n-          .\n-          -i *.jtr\n-          -i *\/hs_err*.log\n-          -i *\/replay*.log\n+          -x \"*ARCHIVE_BUNDLE.zip\"\n@@ -1551,7 +1509,0 @@\n-      - name: Persist test outputs\n-        if: always()\n-        uses: actions\/upload-artifact@v2\n-        with:\n-          path: ~\/macos-x64${{ matrix.artifact }}_testsupport_${{ env.logsuffix }}.zip\n-        continue-on-error: true\n-\n@@ -1565,5 +1516,5 @@\n-      - linux_x64_build\n-      - linux_x86_build\n-      - windows_x64_build\n-      - windows_x86_build\n-      - macos_x64_build\n+      - linux_x64_test\n+      - linux_x86_test\n+      - windows_x64_test\n+      - windows_x86_test\n+      - macos_x64_test\n","filename":".github\/workflows\/submit.yml","additions":272,"deletions":321,"binary":false,"changes":593,"status":"modified"},{"patch":"@@ -0,0 +1,529 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <string.h>\n+#include <math.h>\n+#include <errno.h>\n+#include \"cgroupSubsystem_linux.hpp\"\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+CgroupSubsystem* CgroupSubsystemFactory::create() {\n+  CgroupV1MemoryController* memory = NULL;\n+  CgroupV1Controller* cpuset = NULL;\n+  CgroupV1Controller* cpu = NULL;\n+  CgroupV1Controller* cpuacct = NULL;\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n+  u1 cg_type_flags = INVALID_CGROUPS_GENERIC;\n+  const char* proc_cgroups = \"\/proc\/cgroups\";\n+  const char* proc_self_cgroup = \"\/proc\/self\/cgroup\";\n+  const char* proc_self_mountinfo = \"\/proc\/self\/mountinfo\";\n+\n+  bool valid_cgroup = determine_type(cg_infos, proc_cgroups, proc_self_cgroup, proc_self_mountinfo, &cg_type_flags);\n+\n+  if (!valid_cgroup) {\n+    \/\/ Could not detect cgroup type\n+    return NULL;\n+  }\n+  assert(is_valid_cgroup(&cg_type_flags), \"Expected valid cgroup type\");\n+\n+  if (is_cgroup_v2(&cg_type_flags)) {\n+    \/\/ Cgroups v2 case, we have all the info we need.\n+    \/\/ Construct the subsystem, free resources and return\n+    \/\/ Note: any index in cg_infos will do as the path is the same for\n+    \/\/       all controllers.\n+    CgroupController* unified = new CgroupV2Controller(cg_infos[MEMORY_IDX]._mount_path, cg_infos[MEMORY_IDX]._cgroup_path);\n+    if(PrintContainerInfo)\n+      tty->print_cr(\"Detected cgroups v2 unified hierarchy\");\n+    cleanup(cg_infos);\n+    return new CgroupV2Subsystem(unified);\n+  }\n+\n+  \/*\n+   * Cgroup v1 case:\n+   *\n+   * Use info gathered previously from \/proc\/self\/cgroup\n+   * and map host mount point to\n+   * local one via \/proc\/self\/mountinfo content above\n+   *\n+   * Docker example:\n+   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+   *\n+   * Host example:\n+   * 5:memory:\/user.slice\n+   *\n+   * Construct a path to the process specific memory and cpuset\n+   * cgroup directory.\n+   *\n+   * For a container running under Docker from memory example above\n+   * the paths would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\n+   *\n+   * For a Host from memory example above the path would be:\n+   *\n+   * \/sys\/fs\/cgroup\/memory\/user.slice\n+   *\n+   *\/\n+  assert(is_cgroup_v1(&cg_type_flags), \"Cgroup v1 expected\");\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    CgroupInfo info = cg_infos[i];\n+    if (strcmp(info._name, \"memory\") == 0) {\n+      memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+      memory->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuset\") == 0) {\n+      cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuset->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpu\") == 0) {\n+      cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpu->set_subsystem_path(info._cgroup_path);\n+    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n+      cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+      cpuacct->set_subsystem_path(info._cgroup_path);\n+    }\n+  }\n+  cleanup(cg_infos);\n+  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n+}\n+\n+bool CgroupSubsystemFactory::determine_type(CgroupInfo* cg_infos,\n+                                            const char* proc_cgroups,\n+                                            const char* proc_self_cgroup,\n+                                            const char* proc_self_mountinfo,\n+                                            u1* flags) {\n+  FILE *mntinfo = NULL;\n+  FILE *cgroups = NULL;\n+  FILE *cgroup = NULL;\n+  char buf[MAXPATHLEN+1];\n+  char *p;\n+  bool is_cgroupsV2;\n+  \/\/ true iff all controllers, memory, cpu, cpuset, cpuacct are enabled\n+  \/\/ at the kernel level.\n+  bool all_controllers_enabled;\n+\n+  \/*\n+   * Read \/proc\/cgroups so as to be able to distinguish cgroups v2 vs cgroups v1.\n+   *\n+   * For cgroups v1 hierarchy (hybrid or legacy), cpu, cpuacct, cpuset, memory controllers\n+   * must have non-zero for the hierarchy ID field and relevant controllers mounted.\n+   * Conversely, for cgroups v2 (unified hierarchy), cpu, cpuacct, cpuset, memory\n+   * controllers must have hierarchy ID 0 and the unified controller mounted.\n+   *\/\n+  cgroups = fopen(proc_cgroups, \"r\");\n+  if (cgroups == NULL) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Can't open %s, %s\",\n+                      proc_cgroups, strerror(errno));\n+      }\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n+  }\n+\n+  while ((p = fgets(buf, MAXPATHLEN, cgroups)) != NULL) {\n+    char name[MAXPATHLEN+1];\n+    int  hierarchy_id;\n+    int  enabled;\n+\n+    \/\/ Format of \/proc\/cgroups documented via man 7 cgroups\n+    if (sscanf(p, \"%s %d %*d %d\", name, &hierarchy_id, &enabled) != 3) {\n+      continue;\n+    }\n+    if (strcmp(name, \"memory\") == 0) {\n+      cg_infos[MEMORY_IDX]._name = os::strdup(name);\n+      cg_infos[MEMORY_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[MEMORY_IDX]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpuset\") == 0) {\n+      cg_infos[CPUSET_IDX]._name = os::strdup(name);\n+      cg_infos[CPUSET_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUSET_IDX]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpu\") == 0) {\n+      cg_infos[CPU_IDX]._name = os::strdup(name);\n+      cg_infos[CPU_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPU_IDX]._enabled = (enabled == 1);\n+    } else if (strcmp(name, \"cpuacct\") == 0) {\n+      cg_infos[CPUACCT_IDX]._name = os::strdup(name);\n+      cg_infos[CPUACCT_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[CPUACCT_IDX]._enabled = (enabled == 1);\n+    }\n+  }\n+  fclose(cgroups);\n+\n+  is_cgroupsV2 = true;\n+  all_controllers_enabled = true;\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n+    all_controllers_enabled = all_controllers_enabled && cg_infos[i]._enabled;\n+  }\n+\n+  if (!all_controllers_enabled) {\n+    \/\/ one or more controllers disabled, disable container support\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"One or more required controllers disabled at kernel level.\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n+  }\n+\n+  \/*\n+   * Read \/proc\/self\/cgroup and determine:\n+   *  - the cgroup path for cgroups v2 or\n+   *  - on a cgroups v1 system, collect info for mapping\n+   *    the host mount point to the local one via \/proc\/self\/mountinfo below.\n+   *\/\n+  cgroup = fopen(proc_self_cgroup, \"r\");\n+  if (cgroup == NULL) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Can't open %s, %s\",\n+                    proc_self_cgroup, strerror(errno));\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n+  }\n+\n+  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {\n+    char *controllers;\n+    char *token;\n+    char *hierarchy_id_str;\n+    int  hierarchy_id;\n+    char *cgroup_path;\n+\n+    hierarchy_id_str = strsep(&p, \":\");\n+    hierarchy_id = atoi(hierarchy_id_str);\n+    \/* Get controllers and base *\/\n+    controllers = strsep(&p, \":\");\n+    cgroup_path = strsep(&p, \"\\n\");\n+\n+    if (controllers == NULL) {\n+      continue;\n+    }\n+\n+    while (!is_cgroupsV2 && (token = strsep(&controllers, \",\")) != NULL) {\n+      if (strcmp(token, \"memory\") == 0) {\n+        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[MEMORY_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpuset\") == 0) {\n+        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUSET_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpu\") == 0) {\n+        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPU_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      } else if (strcmp(token, \"cpuacct\") == 0) {\n+        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        cg_infos[CPUACCT_IDX]._cgroup_path = os::strdup(cgroup_path);\n+      }\n+    }\n+    if (is_cgroupsV2) {\n+      for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+        cg_infos[i]._cgroup_path = os::strdup(cgroup_path);\n+      }\n+    }\n+  }\n+  fclose(cgroup);\n+\n+  \/\/ Find various mount points by reading \/proc\/self\/mountinfo\n+  \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+  mntinfo = fopen(proc_self_mountinfo, \"r\");\n+  if (mntinfo == NULL) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Can't open %s, %s\",\n+                      proc_self_mountinfo, strerror(errno));\n+      }\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_GENERIC;\n+      return false;\n+  }\n+\n+  bool cgroupv2_mount_point_found = false;\n+  bool any_cgroup_mounts_found = false;\n+  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n+    char tmp_mount_point[MAXPATHLEN+1];\n+    char tmp_fs_type[MAXPATHLEN+1];\n+    char tmproot[MAXPATHLEN+1];\n+    char tmpmount[MAXPATHLEN+1];\n+    char tmpcgroups[MAXPATHLEN+1];\n+    char *cptr = tmpcgroups;\n+    char *token;\n+\n+    \/\/ Cgroup v2 relevant info. We only look for the _mount_path iff is_cgroupsV2 so\n+    \/\/ as to avoid memory stomping of the _mount_path pointer later on in the cgroup v1\n+    \/\/ block in the hybrid case.\n+    \/\/\n+    if (is_cgroupsV2 && sscanf(p, \"%*d %*d %*d:%*d %*s %s %*[^-]- %s cgroup2 %*s\", tmp_mount_point, tmp_fs_type) == 2) {\n+      \/\/ we likely have an early match return (e.g. cgroup fs match), be sure we have cgroup2 as fstype\n+      if (!cgroupv2_mount_point_found && strcmp(\"cgroup2\", tmp_fs_type) == 0) {\n+        cgroupv2_mount_point_found = true;\n+        any_cgroup_mounts_found = true;\n+        for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+          assert(cg_infos[i]._mount_path == NULL, \"_mount_path memory stomping\");\n+          cg_infos[i]._mount_path = os::strdup(tmp_mount_point);\n+        }\n+      }\n+    }\n+\n+    \/* Cgroup v1 relevant info\n+     *\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct\n+     *\n+     * Example for docker:\n+     * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n+     *\n+     * Example for host:\n+     * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n+     *\/\n+    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- %s cgroup %s\", tmproot, tmpmount, tmp_fs_type, tmpcgroups) == 4) {\n+      if (strcmp(\"cgroup\", tmp_fs_type) != 0) {\n+        \/\/ Skip cgroup2 fs lines on hybrid or unified hierarchy.\n+        continue;\n+      }\n+      any_cgroup_mounts_found = true;\n+      while ((token = strsep(&cptr, \",\")) != NULL) {\n+        if (strcmp(token, \"memory\") == 0) {\n+          assert(cg_infos[MEMORY_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[MEMORY_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[MEMORY_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[MEMORY_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuset\") == 0) {\n+          assert(cg_infos[CPUSET_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPUSET_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPUSET_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUSET_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpu\") == 0) {\n+          assert(cg_infos[CPU_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPU_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPU_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPU_IDX]._data_complete = true;\n+        } else if (strcmp(token, \"cpuacct\") == 0) {\n+          assert(cg_infos[CPUACCT_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[CPUACCT_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[CPUACCT_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[CPUACCT_IDX]._data_complete = true;\n+        }\n+      }\n+    }\n+  }\n+  fclose(mntinfo);\n+\n+  \/\/ Neither cgroup2 nor cgroup filesystems mounted via \/proc\/self\/mountinfo\n+  \/\/ No point in continuing.\n+  if (!any_cgroup_mounts_found) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"No cgroup controllers mounted.\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_NO_MOUNT;\n+    return false;\n+  }\n+\n+  if (is_cgroupsV2) {\n+    if (!cgroupv2_mount_point_found) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Mount point for cgroupv2 not found in \/proc\/self\/mountinfo\");\n+      }\n+      cleanup(cg_infos);\n+      *flags = INVALID_CGROUPS_V2;\n+      return false;\n+    }\n+    \/\/ Cgroups v2 case, we have all the info we need.\n+    *flags = CGROUPS_V2;\n+    return true;\n+  }\n+\n+  \/\/ What follows is cgroups v1\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Detected cgroups hybrid or legacy hierarchy, using cgroups v1 controllers\");\n+  }\n+\n+  if (!cg_infos[MEMORY_IDX]._data_complete) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Required cgroup v1 memory subsystem not found\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  if (!cg_infos[CPUSET_IDX]._data_complete) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Required cgroup v1 cpuset subsystem not found\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  if (!cg_infos[CPU_IDX]._data_complete) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Required cgroup v1 cpu subsystem not found\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  if (!cg_infos[CPUACCT_IDX]._data_complete) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Required cgroup v1 cpuacct subsystem not found\");\n+    }\n+    cleanup(cg_infos);\n+    *flags = INVALID_CGROUPS_V1;\n+    return false;\n+  }\n+  \/\/ Cgroups v1 case, we have all the info we need.\n+  *flags = CGROUPS_V1;\n+  return true;\n+\n+};\n+\n+void CgroupSubsystemFactory::cleanup(CgroupInfo* cg_infos) {\n+  assert(cg_infos != NULL, \"Invariant\");\n+  for (int i = 0; i < CG_INFO_LENGTH; i++) {\n+    os::free(cg_infos[i]._name);\n+    os::free(cg_infos[i]._cgroup_path);\n+    os::free(cg_infos[i]._root_mount_path);\n+    os::free(cg_infos[i]._mount_path);\n+  }\n+}\n+\n+\/* active_processor_count\n+ *\n+ * Calculate an appropriate number of active processors for the\n+ * VM to use based on these three inputs.\n+ *\n+ * cpu affinity\n+ * cgroup cpu quota & cpu period\n+ * cgroup cpu shares\n+ *\n+ * Algorithm:\n+ *\n+ * Determine the number of available CPUs from sched_getaffinity\n+ *\n+ * If user specified a quota (quota != -1), calculate the number of\n+ * required CPUs by dividing quota by period.\n+ *\n+ * If shares are in effect (shares != -1), calculate the number\n+ * of CPUs required for the shares by dividing the share value\n+ * by PER_CPU_SHARES.\n+ *\n+ * All results of division are rounded up to the next whole number.\n+ *\n+ * If neither shares or quotas have been specified, return the\n+ * number of active processors in the system.\n+ *\n+ * If both shares and quotas have been specified, the results are\n+ * based on the flag PreferContainerQuotaForCPUCount.  If true,\n+ * return the quota value.  If false return the smallest value\n+ * between shares or quotas.\n+ *\n+ * If shares and\/or quotas have been specified, the resulting number\n+ * returned will never exceed the number of active processors.\n+ *\n+ * return:\n+ *    number of CPUs\n+ *\/\n+int CgroupSubsystem::active_processor_count() {\n+  int quota_count = 0, share_count = 0;\n+  int cpu_count, limit_count;\n+  int result;\n+\n+  \/\/ We use a cache with a timeout to avoid performing expensive\n+  \/\/ computations in the event this function is called frequently.\n+  \/\/ [See 8227006].\n+  CachingCgroupController* contrl = cpu_controller();\n+  CachedMetric* cpu_limit = contrl->metrics_cache();\n+  if (!cpu_limit->should_check_metric()) {\n+    int val = (int)cpu_limit->value();\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"CgroupSubsystem::active_processor_count (cached): %d\", val);\n+    }\n+    return val;\n+  }\n+\n+  cpu_count = limit_count = os::Linux::active_processor_count();\n+  int quota  = cpu_quota();\n+  int period = cpu_period();\n+  int share  = cpu_shares();\n+\n+  if (quota > -1 && period > 0) {\n+    quota_count = ceilf((float)quota \/ (float)period);\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"CPU Quota count based on quota\/period: %d\", quota_count);\n+    }\n+  }\n+  if (share > -1) {\n+    share_count = ceilf((float)share \/ (float)PER_CPU_SHARES);\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"CPU Share count based on shares: %d\", share_count);\n+    }\n+  }\n+\n+  \/\/ If both shares and quotas are setup results depend\n+  \/\/ on flag PreferContainerQuotaForCPUCount.\n+  \/\/ If true, limit CPU count to quota\n+  \/\/ If false, use minimum of shares and quotas\n+  if (quota_count !=0 && share_count != 0) {\n+    if (PreferContainerQuotaForCPUCount) {\n+      limit_count = quota_count;\n+    } else {\n+      limit_count = MIN2(quota_count, share_count);\n+    }\n+  } else if (quota_count != 0) {\n+    limit_count = quota_count;\n+  } else if (share_count != 0) {\n+    limit_count = share_count;\n+  }\n+\n+  result = MIN2(cpu_count, limit_count);\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"OSContainer::active_processor_count: %d\", result);\n+  }\n+\n+  \/\/ Update cached metric to avoid re-reading container settings too often\n+  cpu_limit->set_value(result, OSCONTAINER_CACHE_TIMEOUT);\n+\n+  return result;\n+}\n+\n+\/* memory_limit_in_bytes\n+ *\n+ * Return the limit of available memory for this process.\n+ *\n+ * return:\n+ *    memory limit in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupSubsystem::memory_limit_in_bytes() {\n+  CachingCgroupController* contrl = memory_controller();\n+  CachedMetric* memory_limit = contrl->metrics_cache();\n+  if (!memory_limit->should_check_metric()) {\n+    return memory_limit->value();\n+  }\n+  jlong mem_limit = read_memory_limit_in_bytes();\n+  \/\/ Update cached metric to avoid re-reading container settings too often\n+  memory_limit->set_value(mem_limit, OSCONTAINER_CACHE_TIMEOUT);\n+  return mem_limit;\n+}\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.cpp","additions":529,"deletions":0,"binary":false,"changes":529,"status":"added"},{"patch":"@@ -0,0 +1,334 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_SUBSYSTEM_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"osContainer_linux.hpp\"\n+\n+\/\/ Shared cgroups code (used by cgroup version 1 and version 2)\n+\n+\/*\n+ * PER_CPU_SHARES has been set to 1024 because CPU shares' quota\n+ * is commonly used in cloud frameworks like Kubernetes[1],\n+ * AWS[2] and Mesos[3] in a similar way. They spawn containers with\n+ * --cpu-shares option values scaled by PER_CPU_SHARES. Thus, we do\n+ * the inverse for determining the number of possible available\n+ * CPUs to the JVM inside a container. See JDK-8216366.\n+ *\n+ * [1] https:\/\/kubernetes.io\/docs\/concepts\/configuration\/manage-compute-resources-container\/#meaning-of-cpu\n+ *     In particular:\n+ *        When using Docker:\n+ *          The spec.containers[].resources.requests.cpu is converted to its core value, which is potentially\n+ *          fractional, and multiplied by 1024. The greater of this number or 2 is used as the value of the\n+ *          --cpu-shares flag in the docker run command.\n+ * [2] https:\/\/docs.aws.amazon.com\/AmazonECS\/latest\/APIReference\/API_ContainerDefinition.html\n+ * [3] https:\/\/github.com\/apache\/mesos\/blob\/3478e344fb77d931f6122980c6e94cd3913c441d\/src\/docker\/docker.cpp#L648\n+ *     https:\/\/github.com\/apache\/mesos\/blob\/3478e344fb77d931f6122980c6e94cd3913c441d\/src\/slave\/containerizer\/mesos\/isolators\/cgroups\/constants.hpp#L30\n+ *\/\n+#define PER_CPU_SHARES 1024\n+\n+#define CGROUPS_V1               1\n+#define CGROUPS_V2               2\n+#define INVALID_CGROUPS_V2       3\n+#define INVALID_CGROUPS_V1       4\n+#define INVALID_CGROUPS_NO_MOUNT 5\n+#define INVALID_CGROUPS_GENERIC  6\n+\n+\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n+#define CG_INFO_LENGTH 4\n+#define CPUSET_IDX     0\n+#define CPU_IDX        1\n+#define CPUACCT_IDX    2\n+#define MEMORY_IDX     3\n+\n+typedef char * cptr;\n+\n+class CgroupController: public CHeapObj<mtInternal> {\n+  public:\n+    virtual char *subsystem_path() = 0;\n+};\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_FORMAT_NONLITERAL_IGNORED\n+template <typename T> int subsystem_file_line_contents(CgroupController* c,\n+                                              const char *filename,\n+                                              const char *matchline,\n+                                              const char *scan_fmt,\n+                                              T returnval) {\n+  FILE *fp = NULL;\n+  char *p;\n+  char file[MAXPATHLEN+1];\n+  char buf[MAXPATHLEN+1];\n+  char discard[MAXPATHLEN+1];\n+  bool found_match = false;\n+\n+  if (c == NULL) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"subsystem_file_line_contents: CgroupController* is NULL\");\n+    }\n+    return OSCONTAINER_ERROR;\n+  }\n+  if (c->subsystem_path() == NULL) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"subsystem_file_line_contents: subsystem path is NULL\");\n+    }\n+    return OSCONTAINER_ERROR;\n+  }\n+\n+  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n+  file[MAXPATHLEN-1] = '\\0';\n+  int filelen = strlen(file);\n+  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"File path too long %s, %s\", file, filename);\n+    }\n+    return OSCONTAINER_ERROR;\n+  }\n+  strncat(file, filename, MAXPATHLEN-filelen);\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Path to %s is %s\", filename, file);\n+  }\n+  fp = fopen(file, \"r\");\n+  if (fp != NULL) {\n+    int err = 0;\n+    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n+      found_match = false;\n+      if (matchline == NULL) {\n+        \/\/ single-line file case\n+        int matched = sscanf(p, scan_fmt, returnval);\n+        found_match = (matched == 1);\n+      } else {\n+        \/\/ multi-line file case\n+        if (strstr(p, matchline) != NULL) {\n+          \/\/ discard matchline string prefix\n+          int matched = sscanf(p, scan_fmt, discard, returnval);\n+          found_match = (matched == 2);\n+        } else {\n+          continue; \/\/ substring not found\n+        }\n+      }\n+      if (found_match) {\n+        fclose(fp);\n+        return 0;\n+      } else {\n+        err = 1;\n+        if (PrintContainerInfo) {\n+          tty->print_cr(\"Type %s not found in file %s\", scan_fmt, file);\n+        }\n+      }\n+    }\n+    if (err == 0) {\n+      if (PrintContainerInfo) {\n+        tty->print_cr(\"Empty file %s\", file);\n+      }\n+    }\n+  } else {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Open of file %s failed, %s\", file, strerror(errno));\n+    }\n+  }\n+  if (fp != NULL)\n+    fclose(fp);\n+  return OSCONTAINER_ERROR;\n+}\n+PRAGMA_DIAG_POP\n+\n+#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n+                           logstring, scan_fmt, variable)                 \\\n+  return_type variable;                                                   \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(subsystem,                           \\\n+                                     filename,                            \\\n+                                     NULL,                                \\\n+                                     scan_fmt,                            \\\n+                                     &variable);                          \\\n+  if (err != 0)                                                           \\\n+    return (return_type) OSCONTAINER_ERROR;                               \\\n+                                                                          \\\n+  if (PrintContainerInfo) {                                               \\\n+    tty->print_cr(logstring, variable);                                   \\\n+  }                                                                       \\\n+}\n+\n+#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n+                               logstring, scan_fmt, variable, bufsize)    \\\n+  char variable[bufsize];                                                 \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(subsystem,                           \\\n+                                     filename,                            \\\n+                                     NULL,                                \\\n+                                     scan_fmt,                            \\\n+                                     variable);                           \\\n+  if (err != 0)                                                           \\\n+    return (return_type) NULL;                                            \\\n+                                                                          \\\n+  if (PrintContainerInfo) {                                               \\\n+    tty->print_cr(logstring, variable);                                   \\\n+  }                                                                       \\\n+}\n+\n+#define GET_CONTAINER_INFO_LINE(return_type, controller, filename,        \\\n+                           matchline, logstring, scan_fmt, variable)      \\\n+  return_type variable;                                                   \\\n+{                                                                         \\\n+  int err;                                                                \\\n+  err = subsystem_file_line_contents(controller,                          \\\n+                                filename,                                 \\\n+                                matchline,                                \\\n+                                scan_fmt,                                 \\\n+                                &variable);                               \\\n+  if (err != 0)                                                           \\\n+    return (return_type) OSCONTAINER_ERROR;                               \\\n+                                                                          \\\n+  if (PrintContainerInfo) {                                               \\\n+    tty->print_cr(logstring, variable);                                   \\\n+  }                                                                       \\\n+}\n+\n+\n+class CachedMetric : public CHeapObj<mtInternal>{\n+  private:\n+    volatile jlong _metric;\n+    volatile jlong _next_check_counter;\n+  public:\n+    CachedMetric() {\n+      _metric = -1;\n+      _next_check_counter = min_jlong;\n+    }\n+    bool should_check_metric() {\n+      return os::elapsed_counter() > _next_check_counter;\n+    }\n+    jlong value() { return _metric; }\n+    void set_value(jlong value, jlong timeout) {\n+      _metric = value;\n+      \/\/ Metric is unlikely to change, but we want to remain\n+      \/\/ responsive to configuration changes. A very short grace time\n+      \/\/ between re-read avoids excessive overhead during startup without\n+      \/\/ significantly reducing the VMs ability to promptly react to changed\n+      \/\/ metric config\n+      _next_check_counter = os::elapsed_counter() + timeout;\n+    }\n+};\n+\n+class CachingCgroupController : public CHeapObj<mtInternal> {\n+  private:\n+    CgroupController* _controller;\n+    CachedMetric* _metrics_cache;\n+\n+  public:\n+    CachingCgroupController(CgroupController* cont) {\n+      _controller = cont;\n+      _metrics_cache = new CachedMetric();\n+    }\n+\n+    CachedMetric* metrics_cache() { return _metrics_cache; }\n+    CgroupController* controller() { return _controller; }\n+};\n+\n+class CgroupSubsystem: public CHeapObj<mtInternal> {\n+  public:\n+    jlong memory_limit_in_bytes();\n+    int active_processor_count();\n+\n+    virtual int cpu_quota() = 0;\n+    virtual int cpu_period() = 0;\n+    virtual int cpu_shares() = 0;\n+    virtual jlong memory_usage_in_bytes() = 0;\n+    virtual jlong memory_and_swap_limit_in_bytes() = 0;\n+    virtual jlong memory_soft_limit_in_bytes() = 0;\n+    virtual jlong memory_max_usage_in_bytes() = 0;\n+    virtual char * cpu_cpuset_cpus() = 0;\n+    virtual char * cpu_cpuset_memory_nodes() = 0;\n+    virtual jlong read_memory_limit_in_bytes() = 0;\n+    virtual const char * container_type() = 0;\n+    virtual CachingCgroupController* memory_controller() = 0;\n+    virtual CachingCgroupController* cpu_controller() = 0;\n+};\n+\n+\/\/ Utility class for storing info retrieved from \/proc\/cgroups,\n+\/\/ \/proc\/self\/cgroup and \/proc\/self\/mountinfo\n+\/\/ For reference see man 7 cgroups and CgroupSubsystemFactory\n+class CgroupInfo : public StackObj {\n+  friend class CgroupSubsystemFactory;\n+  friend class WhiteBox;\n+\n+  private:\n+    char* _name;\n+    int _hierarchy_id;\n+    bool _enabled;\n+    bool _data_complete;    \/\/ indicating cgroup v1 data is complete for this controller\n+    char* _cgroup_path;     \/\/ cgroup controller path from \/proc\/self\/cgroup\n+    char* _root_mount_path; \/\/ root mount path from \/proc\/self\/mountinfo. Unused for cgroup v2\n+    char* _mount_path;      \/\/ mount path from \/proc\/self\/mountinfo.\n+\n+  public:\n+    CgroupInfo() {\n+      _name = NULL;\n+      _hierarchy_id = -1;\n+      _enabled = false;\n+      _data_complete = false;\n+      _cgroup_path = NULL;\n+      _root_mount_path = NULL;\n+      _mount_path = NULL;\n+    }\n+\n+};\n+\n+class CgroupSubsystemFactory: AllStatic {\n+  friend class WhiteBox;\n+\n+  public:\n+    static CgroupSubsystem* create();\n+  private:\n+    static inline bool is_cgroup_v2(u1* flags) {\n+       return *flags == CGROUPS_V2;\n+    }\n+\n+#ifdef ASSERT\n+    static inline bool is_valid_cgroup(u1* flags) {\n+       return *flags == CGROUPS_V1 || *flags == CGROUPS_V2;\n+    }\n+    static inline bool is_cgroup_v1(u1* flags) {\n+       return *flags == CGROUPS_V1;\n+    }\n+#endif\n+\n+    \/\/ Determine the cgroup type (version 1 or version 2), given\n+    \/\/ relevant paths to files. Sets 'flags' accordingly.\n+    static bool determine_type(CgroupInfo* cg_infos,\n+                               const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* flags);\n+    static void cleanup(CgroupInfo* cg_infos);\n+};\n+\n+#endif \/\/ CGROUP_SUBSYSTEM_LINUX_HPP\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupSubsystem_linux.hpp","additions":334,"deletions":0,"binary":false,"changes":334,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include <string.h>\n+#include <math.h>\n+#include <errno.h>\n+#include \"cgroupV1Subsystem_linux.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/*\n+ * Set directory to subsystem specific files based\n+ * on the contents of the mountinfo and cgroup files.\n+ *\/\n+void CgroupV1Controller::set_subsystem_path(char *cgroup_path) {\n+  char buf[MAXPATHLEN+1];\n+  if (_root != NULL && cgroup_path != NULL) {\n+    if (strcmp(_root, \"\/\") == 0) {\n+      int buflen;\n+      strncpy(buf, _mount_point, MAXPATHLEN);\n+      buf[MAXPATHLEN-1] = '\\0';\n+      if (strcmp(cgroup_path,\"\/\") != 0) {\n+        buflen = strlen(buf);\n+        if ((buflen + strlen(cgroup_path)) > (MAXPATHLEN-1)) {\n+          return;\n+        }\n+        strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n+        buf[MAXPATHLEN-1] = '\\0';\n+      }\n+      _path = os::strdup(buf);\n+    } else {\n+      if (strcmp(_root, cgroup_path) == 0) {\n+        strncpy(buf, _mount_point, MAXPATHLEN);\n+        buf[MAXPATHLEN-1] = '\\0';\n+        _path = os::strdup(buf);\n+      } else {\n+        char *p = strstr(cgroup_path, _root);\n+        if (p != NULL && p == _root) {\n+          if (strlen(cgroup_path) > strlen(_root)) {\n+            int buflen;\n+            strncpy(buf, _mount_point, MAXPATHLEN);\n+            buf[MAXPATHLEN-1] = '\\0';\n+            buflen = strlen(buf);\n+            if ((buflen + strlen(cgroup_path) - strlen(_root)) > (MAXPATHLEN-1)) {\n+              return;\n+            }\n+            strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);\n+            buf[MAXPATHLEN-1] = '\\0';\n+            _path = os::strdup(buf);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\/* uses_mem_hierarchy\n+ *\n+ * Return whether or not hierarchical cgroup accounting is being\n+ * done.\n+ *\n+ * return:\n+ *    A number > 0 if true, or\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1MemoryController::uses_mem_hierarchy() {\n+  GET_CONTAINER_INFO(jlong, this, \"\/memory.use_hierarchy\",\n+                    \"Use Hierarchy is: \" JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n+  return use_hierarchy;\n+}\n+\n+void CgroupV1MemoryController::set_subsystem_path(char *cgroup_path) {\n+  CgroupV1Controller::set_subsystem_path(cgroup_path);\n+  jlong hierarchy = uses_mem_hierarchy();\n+  if (hierarchy > 0) {\n+    set_hierarchical(true);\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::read_memory_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.limit_in_bytes\",\n+                     \"Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memlimit);\n+\n+  if (memlimit >= _unlimited_memory) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Non-Hierarchical Memory Limit is: Unlimited\");\n+    }\n+    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+    if (mem_controller->is_hierarchical()) {\n+      const char* matchline = \"hierarchical_memory_limit\";\n+      const char* format = \"%s \" JULONG_FORMAT;\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n+                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n+      if (hier_memlimit >= _unlimited_memory) {\n+        if (PrintContainerInfo) {\n+          tty->print_cr(\"Hierarchical Memory Limit is: Unlimited\");\n+        }\n+      } else {\n+        return (jlong)hier_memlimit;\n+      }\n+    }\n+    return (jlong)-1;\n+  }\n+  else {\n+    return (jlong)memlimit;\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::memory_and_swap_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.memsw.limit_in_bytes\",\n+                     \"Memory and Swap Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n+  if (memswlimit >= _unlimited_memory) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n+    }\n+    CgroupV1MemoryController* mem_controller = reinterpret_cast<CgroupV1MemoryController*>(_memory->controller());\n+    if (mem_controller->is_hierarchical()) {\n+      const char* matchline = \"hierarchical_memsw_limit\";\n+      const char* format = \"%s \" JULONG_FORMAT;\n+      GET_CONTAINER_INFO_LINE(julong, _memory->controller(), \"\/memory.stat\", matchline,\n+                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n+      if (hier_memlimit >= _unlimited_memory) {\n+        if (PrintContainerInfo) {\n+          tty->print_cr(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n+        }\n+      } else {\n+        return (jlong)hier_memlimit;\n+      }\n+    }\n+    return (jlong)-1;\n+  } else {\n+    return (jlong)memswlimit;\n+  }\n+}\n+\n+jlong CgroupV1Subsystem::memory_soft_limit_in_bytes() {\n+  GET_CONTAINER_INFO(julong, _memory->controller(), \"\/memory.soft_limit_in_bytes\",\n+                     \"Memory Soft Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n+  if (memsoftlimit >= _unlimited_memory) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"Memory Soft Limit is: Unlimited\");\n+    }\n+    return (jlong)-1;\n+  } else {\n+    return (jlong)memsoftlimit;\n+  }\n+}\n+\n+\/* memory_usage_in_bytes\n+ *\n+ * Return the amount of used memory for this process.\n+ *\n+ * return:\n+ *    memory usage in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::memory_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.usage_in_bytes\",\n+                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  return memusage;\n+}\n+\n+\/* memory_max_usage_in_bytes\n+ *\n+ * Return the maximum amount of used memory for this process.\n+ *\n+ * return:\n+ *    max memory usage in bytes or\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::memory_max_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _memory->controller(), \"\/memory.max_usage_in_bytes\",\n+                     \"Maximum Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n+  return memmaxusage;\n+}\n+\n+char * CgroupV1Subsystem::cpu_cpuset_cpus() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.cpus\",\n+                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  return os::strdup(cpus);\n+}\n+\n+char * CgroupV1Subsystem::cpu_cpuset_memory_nodes() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _cpuset, \"\/cpuset.mems\",\n+                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  return os::strdup(mems);\n+}\n+\n+\/* cpu_quota\n+ *\n+ * Return the number of milliseconds per period\n+ * process is guaranteed to run.\n+ *\n+ * return:\n+ *    quota time in milliseconds\n+ *    -1 for no quota\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV1Subsystem::cpu_quota() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_quota_us\",\n+                     \"CPU Quota is: %d\", \"%d\", quota);\n+  return quota;\n+}\n+\n+int CgroupV1Subsystem::cpu_period() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.cfs_period_us\",\n+                     \"CPU Period is: %d\", \"%d\", period);\n+  return period;\n+}\n+\n+\/* cpu_shares\n+ *\n+ * Return the amount of cpu shares available to the process\n+ *\n+ * return:\n+ *    Share number (typically a number relative to 1024)\n+ *                 (2048 typically expresses 2 CPUs worth of processing)\n+ *    -1 for no share setup\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV1Subsystem::cpu_shares() {\n+  GET_CONTAINER_INFO(int, _cpu->controller(), \"\/cpu.shares\",\n+                     \"CPU Shares is: %d\", \"%d\", shares);\n+  \/\/ Convert 1024 to no shares setup\n+  if (shares == 1024) return -1;\n+\n+  return shares;\n+}\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV1Subsystem_linux.cpp","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_V1_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_V1_SUBSYSTEM_LINUX_HPP\n+\n+#include \"runtime\/os.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+\/\/ Cgroups version 1 specific implementation\n+\n+class CgroupV1Controller: public CgroupController {\n+  private:\n+    \/* mountinfo contents *\/\n+    char *_root;\n+    char *_mount_point;\n+\n+    \/* Constructed subsystem directory *\/\n+    char *_path;\n+\n+  public:\n+    CgroupV1Controller(char *root, char *mountpoint) {\n+      _root = os::strdup(root);\n+      _mount_point = os::strdup(mountpoint);\n+      _path = NULL;\n+    }\n+\n+    virtual void set_subsystem_path(char *cgroup_path);\n+    char *subsystem_path() { return _path; }\n+};\n+\n+class CgroupV1MemoryController: public CgroupV1Controller {\n+\n+  public:\n+    bool is_hierarchical() { return _uses_mem_hierarchy; }\n+    void set_subsystem_path(char *cgroup_path);\n+  private:\n+    \/* Some container runtimes set limits via cgroup\n+     * hierarchy. If set to true consider also memory.stat\n+     * file if everything else seems unlimited *\/\n+    bool _uses_mem_hierarchy;\n+    jlong uses_mem_hierarchy();\n+    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n+\n+  public:\n+    CgroupV1MemoryController(char *root, char *mountpoint) : CgroupV1Controller(root, mountpoint) {\n+      _uses_mem_hierarchy = false;\n+    }\n+\n+};\n+\n+class CgroupV1Subsystem: public CgroupSubsystem {\n+\n+  public:\n+    jlong read_memory_limit_in_bytes();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    char * cpu_cpuset_cpus();\n+    char * cpu_cpuset_memory_nodes();\n+\n+    int cpu_quota();\n+    int cpu_period();\n+\n+    int cpu_shares();\n+\n+    const char * container_type() {\n+      return \"cgroupv1\";\n+    }\n+    CachingCgroupController * memory_controller() { return _memory; }\n+    CachingCgroupController * cpu_controller() { return _cpu; }\n+\n+  private:\n+    julong _unlimited_memory;\n+\n+    \/* controllers *\/\n+    CachingCgroupController* _memory;\n+    CgroupV1Controller* _cpuset;\n+    CachingCgroupController* _cpu;\n+    CgroupV1Controller* _cpuacct;\n+\n+  public:\n+    CgroupV1Subsystem(CgroupV1Controller* cpuset,\n+                      CgroupV1Controller* cpu,\n+                      CgroupV1Controller* cpuacct,\n+                      CgroupV1MemoryController* memory) {\n+      _cpuset = cpuset;\n+      _cpu = new CachingCgroupController(cpu);\n+      _cpuacct = cpuacct;\n+      _memory = new CachingCgroupController(memory);\n+      _unlimited_memory = (LONG_MAX \/ os::vm_page_size()) * os::vm_page_size();\n+    }\n+};\n+\n+#endif \/\/ CGROUP_V1_SUBSYSTEM_LINUX_HPP\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV1Subsystem_linux.hpp","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,247 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cgroupV2Subsystem_linux.hpp\"\n+\n+\/* cpu_shares\n+ *\n+ * Return the amount of cpu shares available to the process\n+ *\n+ * return:\n+ *    Share number (typically a number relative to 1024)\n+ *                 (2048 typically expresses 2 CPUs worth of processing)\n+ *    -1 for no share setup\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV2Subsystem::cpu_shares() {\n+  GET_CONTAINER_INFO(int, _unified, \"\/cpu.weight\",\n+                     \"Raw value for CPU shares is: %d\", \"%d\", shares);\n+  \/\/ Convert default value of 100 to no shares setup\n+  if (shares == 100) {\n+    if (PrintContainerInfo) {\n+      tty->print_cr(\"CPU Shares is: %d\", -1);\n+    }\n+    return -1;\n+  }\n+\n+  \/\/ CPU shares (OCI) value needs to get translated into\n+  \/\/ a proper Cgroups v2 value. See:\n+  \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+  \/\/\n+  \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+  \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+  \/\/\n+  int x = 262142 * shares - 1;\n+  double frac = x\/9999.0;\n+  x = ((int)frac) + 2;\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Scaled CPU shares value is: %d\", x);\n+  }\n+  \/\/ Since the scaled value is not precise, return the closest\n+  \/\/ multiple of PER_CPU_SHARES for a more conservative mapping\n+  if ( x <= PER_CPU_SHARES ) {\n+     \/\/ will always map to 1 CPU\n+     if (PrintContainerInfo) {\n+        tty->print_cr(\"CPU Shares is: %d\", x);\n+     }\n+     return x;\n+  }\n+  int f = x\/PER_CPU_SHARES;\n+  int lower_multiple = f * PER_CPU_SHARES;\n+  int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+  int distance_lower = MAX2(lower_multiple, x) - MIN2(lower_multiple, x);\n+  int distance_upper = MAX2(upper_multiple, x) - MIN2(upper_multiple, x);\n+  x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Closest multiple of %d of the CPU Shares value is: %d\", PER_CPU_SHARES, x);\n+    tty->print_cr(\"CPU Shares is: %d\", x);\n+  }\n+  return x;\n+}\n+\n+\/* cpu_quota\n+ *\n+ * Return the number of milliseconds per period\n+ * process is guaranteed to run.\n+ *\n+ * return:\n+ *    quota time in milliseconds\n+ *    -1 for no quota\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+int CgroupV2Subsystem::cpu_quota() {\n+  char * cpu_quota_str = cpu_quota_val();\n+  int limit = (int)limit_from_str(cpu_quota_str);\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"CPU Quota is: %d\", limit);\n+  }\n+  return limit;\n+}\n+\n+char * CgroupV2Subsystem::cpu_cpuset_cpus() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.cpus\",\n+                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n+  if (cpus == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(cpus);\n+}\n+\n+char* CgroupV2Subsystem::cpu_quota_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpu.max\",\n+                     \"Raw value for CPU quota is: %s\", \"%s %*d\", quota, 1024);\n+  if (quota == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(quota);\n+}\n+\n+char * CgroupV2Subsystem::cpu_cpuset_memory_nodes() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/cpuset.mems\",\n+                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n+  if (mems == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mems);\n+}\n+\n+int CgroupV2Subsystem::cpu_period() {\n+  GET_CONTAINER_INFO(int, _unified, \"\/cpu.max\",\n+                     \"CPU Period is: %d\", \"%*s %d\", period);\n+  return period;\n+}\n+\n+\/* memory_usage_in_bytes\n+ *\n+ * Return the amount of used memory used by this cgroup and decendents\n+ *\n+ * return:\n+ *    memory usage in bytes or\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV2Subsystem::memory_usage_in_bytes() {\n+  GET_CONTAINER_INFO(jlong, _unified, \"\/memory.current\",\n+                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n+  return memusage;\n+}\n+\n+jlong CgroupV2Subsystem::memory_soft_limit_in_bytes() {\n+  char* mem_soft_limit_str = mem_soft_limit_val();\n+  return limit_from_str(mem_soft_limit_str);\n+}\n+\n+jlong CgroupV2Subsystem::memory_max_usage_in_bytes() {\n+  \/\/ Log this string at trace level so as to make tests happy.\n+  if (PrintContainerInfo) {\n+    tty->print_cr(\"Maximum Memory Usage is not supported.\");\n+  }\n+  return OSCONTAINER_ERROR; \/\/ not supported\n+}\n+\n+char* CgroupV2Subsystem::mem_soft_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.low\",\n+                         \"Memory Soft Limit is: %s\", \"%s\", mem_soft_limit_str, 1024);\n+  if (mem_soft_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_soft_limit_str);\n+}\n+\n+jlong CgroupV2Subsystem::memory_and_swap_limit_in_bytes() {\n+  char* mem_swp_limit_str = mem_swp_limit_val();\n+  return limit_from_str(mem_swp_limit_str);\n+}\n+\n+char* CgroupV2Subsystem::mem_swp_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.swap.max\",\n+                         \"Memory and Swap Limit is: %s\", \"%s\", mem_swp_limit_str, 1024);\n+  if (mem_swp_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_swp_limit_str);\n+}\n+\n+\/* memory_limit_in_bytes\n+ *\n+ * Return the limit of available memory for this process.\n+ *\n+ * return:\n+ *    memory limit in bytes or\n+ *    -1 for unlimited, OSCONTAINER_ERROR for an error\n+ *\/\n+jlong CgroupV2Subsystem::read_memory_limit_in_bytes() {\n+  char * mem_limit_str = mem_limit_val();\n+  jlong limit = limit_from_str(mem_limit_str);\n+  if (PrintContainerInfo) {\n+    if (limit == -1) {\n+      tty->print_cr(\"Memory Limit is: Unlimited\");\n+    } else {\n+      tty->print_cr(\"Memory Limit is: \" JLONG_FORMAT, limit);\n+    }\n+  }\n+  return limit;\n+}\n+\n+jlong CgroupV2Subsystem::limit_from_str(char* limit_str) {\n+  if (limit_str == NULL) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in Cgroups V2 is the literal string 'max'\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n+\n+char* CgroupV2Subsystem::mem_limit_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/memory.max\",\n+                         \"Raw value for memory limit is: %s\", \"%s\", mem_limit_str, 1024);\n+  if (mem_limit_str == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(mem_limit_str);\n+}\n+\n+char* CgroupV2Controller::construct_path(char* mount_path, char *cgroup_path) {\n+  char buf[MAXPATHLEN+1];\n+  int buflen;\n+  strncpy(buf, mount_path, MAXPATHLEN);\n+  buf[MAXPATHLEN] = '\\0';\n+  buflen = strlen(buf);\n+  if ((buflen + strlen(cgroup_path)) > MAXPATHLEN) {\n+    return NULL;\n+  }\n+  strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n+  buf[MAXPATHLEN] = '\\0';\n+  return os::strdup(buf);\n+}\n+\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV2Subsystem_linux.cpp","additions":247,"deletions":0,"binary":false,"changes":247,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef CGROUP_V2_SUBSYSTEM_LINUX_HPP\n+#define CGROUP_V2_SUBSYSTEM_LINUX_HPP\n+\n+#include \"cgroupSubsystem_linux.hpp\"\n+\n+class CgroupV2Controller: public CgroupController {\n+  private:\n+    \/* the mount path of the cgroup v2 hierarchy *\/\n+    char *_mount_path;\n+    \/* The cgroup path for the controller *\/\n+    char *_cgroup_path;\n+\n+    \/* Constructed full path to the subsystem directory *\/\n+    char *_path;\n+    static char* construct_path(char* mount_path, char *cgroup_path);\n+\n+  public:\n+    CgroupV2Controller(char * mount_path, char *cgroup_path) {\n+      _mount_path = mount_path;\n+      _cgroup_path = os::strdup(cgroup_path);\n+      _path = construct_path(mount_path, cgroup_path);\n+    }\n+\n+    char *subsystem_path() { return _path; }\n+};\n+\n+class CgroupV2Subsystem: public CgroupSubsystem {\n+  private:\n+    \/* One unified controller *\/\n+    CgroupController* _unified;\n+    \/* Caching wrappers for cpu\/memory metrics *\/\n+    CachingCgroupController* _memory;\n+    CachingCgroupController* _cpu;\n+\n+    char *mem_limit_val();\n+    char *mem_swp_limit_val();\n+    char *mem_soft_limit_val();\n+    char *cpu_quota_val();\n+    jlong limit_from_str(char* limit_str);\n+\n+  public:\n+    CgroupV2Subsystem(CgroupController * unified) {\n+      _unified = unified;\n+      _memory = new CachingCgroupController(unified);\n+      _cpu = new CachingCgroupController(unified);\n+    }\n+\n+    jlong read_memory_limit_in_bytes();\n+    int cpu_quota();\n+    int cpu_period();\n+    int cpu_shares();\n+    jlong memory_and_swap_limit_in_bytes();\n+    jlong memory_soft_limit_in_bytes();\n+    jlong memory_usage_in_bytes();\n+    jlong memory_max_usage_in_bytes();\n+    char * cpu_cpuset_cpus();\n+    char * cpu_cpuset_memory_nodes();\n+    const char * container_type() {\n+      return \"cgroupv2\";\n+    }\n+    CachingCgroupController * memory_controller() { return _memory; }\n+    CachingCgroupController * cpu_controller() { return _cpu; }\n+};\n+\n+#endif \/\/ CGROUP_V2_SUBSYSTEM_LINUX_HPP\n","filename":"hotspot\/src\/os\/linux\/vm\/cgroupV2Subsystem_linux.hpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"memory\/allocation.hpp\"\n+#include \"runtime\/globals.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"cgroupSubsystem_linux.hpp\"\n@@ -33,1 +33,0 @@\n-#define PER_CPU_SHARES 1024\n@@ -37,239 +36,0 @@\n-int   OSContainer::_active_processor_count = 1;\n-julong _unlimited_memory;\n-\n-class CgroupSubsystem: CHeapObj<mtInternal> {\n- friend class OSContainer;\n-\n- private:\n-    volatile jlong _next_check_counter;\n-\n-    \/* mountinfo contents *\/\n-    char *_root;\n-    char *_mount_point;\n-\n-    \/* Constructed subsystem directory *\/\n-    char *_path;\n-\n- public:\n-    CgroupSubsystem(char *root, char *mountpoint) {\n-      _root = os::strdup(root);\n-      _mount_point = os::strdup(mountpoint);\n-      _path = NULL;\n-      _next_check_counter = min_jlong;\n-    }\n-\n-    \/*\n-     * Set directory to subsystem specific files based\n-     * on the contents of the mountinfo and cgroup files.\n-     *\/\n-    void set_subsystem_path(char *cgroup_path) {\n-      char buf[MAXPATHLEN+1];\n-      if (_root != NULL && cgroup_path != NULL) {\n-        if (strcmp(_root, \"\/\") == 0) {\n-          int buflen;\n-          strncpy(buf, _mount_point, MAXPATHLEN);\n-          buf[MAXPATHLEN-1] = '\\0';\n-          if (strcmp(cgroup_path,\"\/\") != 0) {\n-            buflen = strlen(buf);\n-            if ((buflen + strlen(cgroup_path)) > (MAXPATHLEN-1)) {\n-              return;\n-            }\n-            strncat(buf, cgroup_path, MAXPATHLEN-buflen);\n-            buf[MAXPATHLEN-1] = '\\0';\n-          }\n-          _path = os::strdup(buf);\n-        } else {\n-          if (strcmp(_root, cgroup_path) == 0) {\n-            strncpy(buf, _mount_point, MAXPATHLEN);\n-            buf[MAXPATHLEN-1] = '\\0';\n-            _path = os::strdup(buf);\n-          } else {\n-            char *p = strstr(cgroup_path, _root);\n-            if (p != NULL && p == _root) {\n-              if (strlen(cgroup_path) > strlen(_root)) {\n-                int buflen;\n-                strncpy(buf, _mount_point, MAXPATHLEN);\n-                buf[MAXPATHLEN-1] = '\\0';\n-                buflen = strlen(buf);\n-                if ((buflen + strlen(cgroup_path) - strlen(_root)) > (MAXPATHLEN-1)) {\n-                  return;\n-                }\n-                strncat(buf, cgroup_path + strlen(_root), MAXPATHLEN-buflen);\n-                buf[MAXPATHLEN-1] = '\\0';\n-                _path = os::strdup(buf);\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-\n-    char *subsystem_path() { return _path; }\n-\n-    bool cache_has_expired() {\n-      return os::elapsed_counter() > _next_check_counter;\n-    }\n-\n-    void set_cache_expiry_time(jlong timeout) {\n-      _next_check_counter = os::elapsed_counter() + timeout;\n-    }\n-};\n-\n-class CgroupMemorySubsystem: CgroupSubsystem {\n- friend class OSContainer;\n-\n- private:\n-    \/* Some container runtimes set limits via cgroup\n-     * hierarchy. If set to true consider also memory.stat\n-     * file if everything else seems unlimited *\/\n-    bool _uses_mem_hierarchy;\n-\n- public:\n-    CgroupMemorySubsystem(char *root, char *mountpoint) : CgroupSubsystem::CgroupSubsystem(root, mountpoint) {\n-      _uses_mem_hierarchy = false;\n-    }\n-\n-    bool is_hierarchical() { return _uses_mem_hierarchy; }\n-    void set_hierarchical(bool value) { _uses_mem_hierarchy = value; }\n-};\n-\n-CgroupMemorySubsystem* memory = NULL;\n-CgroupSubsystem* cpuset = NULL;\n-CgroupSubsystem* cpu = NULL;\n-CgroupSubsystem* cpuacct = NULL;\n-\n-typedef char * cptr;\n-\n-PRAGMA_DIAG_PUSH\n-PRAGMA_FORMAT_NONLITERAL_IGNORED\n-template <typename T> int subsystem_file_line_contents(CgroupSubsystem* c,\n-                                              const char *filename,\n-                                              const char *matchline,\n-                                              const char *scan_fmt,\n-                                              T returnval) {\n-  FILE *fp = NULL;\n-  char *p;\n-  char file[MAXPATHLEN+1];\n-  char buf[MAXPATHLEN+1];\n-  char discard[MAXPATHLEN+1];\n-  bool found_match = false;\n-\n-  if (c == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"subsystem_file_line_contents: CgroupSubsytem* is NULL\");\n-    }\n-    return OSCONTAINER_ERROR;\n-  }\n-  if (c->subsystem_path() == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"subsystem_file_line_contents: subsystem path is NULL\");\n-    }\n-    return OSCONTAINER_ERROR;\n-  }\n-\n-  strncpy(file, c->subsystem_path(), MAXPATHLEN);\n-  file[MAXPATHLEN-1] = '\\0';\n-  int filelen = strlen(file);\n-  if ((filelen + strlen(filename)) > (MAXPATHLEN-1)) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"File path too long %s, %s\", file, filename);\n-    }\n-    return OSCONTAINER_ERROR;\n-  }\n-  strncat(file, filename, MAXPATHLEN-filelen);\n-  if (PrintContainerInfo) {\n-    tty->print_cr(\"Path to %s is %s\", filename, file);\n-  }\n-  fp = fopen(file, \"r\");\n-  if (fp != NULL) {\n-    int err = 0;\n-    while ((p = fgets(buf, MAXPATHLEN, fp)) != NULL) {\n-      found_match = false;\n-      if (matchline == NULL) {\n-        \/\/ single-line file case\n-        int matched = sscanf(p, scan_fmt, returnval);\n-        found_match = (matched == 1);\n-      } else {\n-        \/\/ multi-line file case\n-        if (strstr(p, matchline) != NULL) {\n-          \/\/ discard matchline string prefix\n-          int matched = sscanf(p, scan_fmt, discard, returnval);\n-          found_match = (matched == 2);\n-        } else {\n-          continue; \/\/ substring not found\n-        }\n-      }\n-      if (found_match) {\n-        fclose(fp);\n-        return 0;\n-      } else {\n-        err = 1;\n-        if (PrintContainerInfo) {\n-          tty->print_cr(\"Type %s not found in file %s\", scan_fmt, file);\n-        }\n-      }\n-      if (err == 0 && PrintContainerInfo) {\n-        tty->print_cr(\"Empty file %s\", file);\n-      }\n-    }\n-  } else {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Open of file %s failed, %s\", file, strerror(errno));\n-    }\n-  }\n-  if (fp != NULL)\n-    fclose(fp);\n-  return OSCONTAINER_ERROR;\n-}\n-PRAGMA_DIAG_POP\n-\n-#define GET_CONTAINER_INFO(return_type, subsystem, filename,              \\\n-                           logstring, scan_fmt, variable)                 \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     NULL,                                \\\n-                                     scan_fmt,                            \\\n-                                     &variable);                          \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  if (PrintContainerInfo)                                                 \\\n-    tty->print_cr(logstring, variable);                                   \\\n-}\n-\n-#define GET_CONTAINER_INFO_CPTR(return_type, subsystem, filename,         \\\n-                               logstring, scan_fmt, variable, bufsize)    \\\n-  char variable[bufsize];                                                 \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                     filename,                            \\\n-                                     NULL,                                \\\n-                                     scan_fmt,                            \\\n-                                     variable);                           \\\n-  if (err != 0)                                                           \\\n-    return (return_type) NULL;                                            \\\n-                                                                          \\\n-  if (PrintContainerInfo)                                                 \\\n-    tty->print_cr(logstring, variable);                                   \\\n-}\n-\n-#define GET_CONTAINER_INFO_LINE(return_type, subsystem, filename,         \\\n-                           matchline, logstring, scan_fmt, variable)      \\\n-  return_type variable;                                                   \\\n-{                                                                         \\\n-  int err;                                                                \\\n-  err = subsystem_file_line_contents(subsystem,                           \\\n-                                filename,                                 \\\n-                                matchline,                                \\\n-                                scan_fmt,                                 \\\n-                                &variable);                               \\\n-  if (err != 0)                                                           \\\n-    return (return_type) OSCONTAINER_ERROR;                               \\\n-                                                                          \\\n-  if (PrintContainerInfo)                                                 \\\n-    tty->print_cr(logstring, variable);                                   \\\n-}\n@@ -277,0 +37,1 @@\n+CgroupSubsystem* cgroup_subsystem;\n@@ -284,6 +45,0 @@\n-  FILE *mntinfo = NULL;\n-  FILE *cgroup = NULL;\n-  char buf[MAXPATHLEN+1];\n-  char tmproot[MAXPATHLEN+1];\n-  char tmpmount[MAXPATHLEN+1];\n-  char *p;\n@@ -297,2 +52,0 @@\n-  _unlimited_memory = (LONG_MAX \/ os::vm_page_size()) * os::vm_page_size();\n-\n@@ -309,17 +62,3 @@\n-  \/*\n-   * Find the cgroup mount point for memory and cpuset\n-   * by reading \/proc\/self\/mountinfo\n-   *\n-   * Example for docker:\n-   * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/memory ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,memory\n-   *\n-   * Example for host:\n-   * 34 28 0:29 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,memory\n-   *\/\n-  mntinfo = fopen(\"\/proc\/self\/mountinfo\", \"r\");\n-  if (mntinfo == NULL) {\n-      if (PrintContainerInfo) {\n-        tty->print_cr(\"Can't open \/proc\/self\/mountinfo, %s\",\n-                       strerror(errno));\n-      }\n-      return;\n+  cgroup_subsystem = CgroupSubsystemFactory::create();\n+  if (cgroup_subsystem == NULL) {\n+    return; \/\/ Required subsystem files not found or other error\n@@ -327,115 +66,0 @@\n-\n-  while ((p = fgets(buf, MAXPATHLEN, mntinfo)) != NULL) {\n-    char tmpcgroups[MAXPATHLEN+1];\n-    char *cptr = tmpcgroups;\n-    char *token;\n-\n-    \/\/ mountinfo format is documented at https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n-    if (sscanf(p, \"%*d %*d %*d:%*d %s %s %*[^-]- cgroup %*s %s\", tmproot, tmpmount, tmpcgroups) != 3) {\n-      continue;\n-    }\n-    while ((token = strsep(&cptr, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory = new CgroupMemorySubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset = new CgroupSubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu = new CgroupSubsystem(tmproot, tmpmount);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct= new CgroupSubsystem(tmproot, tmpmount);\n-      }\n-    }\n-  }\n-  fclose(mntinfo);\n-\n-  if (memory == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Required cgroup memory subsystem not found\");\n-    }\n-    return;\n-  }\n-  if (cpuset == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Required cgroup cpuset subsystem not found\");\n-    }\n-    return;\n-  }\n-  if (cpu == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Required cgroup cpu subsystem not found\");\n-    }\n-    return;\n-  }\n-  if (cpuacct == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Required cgroup cpuacct subsystem not found\");\n-    }\n-    return;\n-  }\n-\n-  \/*\n-   * Read \/proc\/self\/cgroup and map host mount point to\n-   * local one via \/proc\/self\/mountinfo content above\n-   *\n-   * Docker example:\n-   * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-   *\n-   * Host example:\n-   * 5:memory:\/user.slice\n-   *\n-   * Construct a path to the process specific memory and cpuset\n-   * cgroup directory.\n-   *\n-   * For a container running under Docker from memory example above\n-   * the paths would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\n-   *\n-   * For a Host from memory example above the path would be:\n-   *\n-   * \/sys\/fs\/cgroup\/memory\/user.slice\n-   *\n-   *\/\n-  cgroup = fopen(\"\/proc\/self\/cgroup\", \"r\");\n-  if (cgroup == NULL) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Can't open \/proc\/self\/cgroup, %s\",\n-                     strerror(errno));\n-      }\n-    return;\n-  }\n-\n-  while ((p = fgets(buf, MAXPATHLEN, cgroup)) != NULL) {\n-    char *controllers;\n-    char *token;\n-    char *base;\n-\n-    \/* Skip cgroup number *\/\n-    strsep(&p, \":\");\n-    \/* Get controllers and base *\/\n-    controllers = strsep(&p, \":\");\n-    base = strsep(&p, \"\\n\");\n-\n-    if (controllers == NULL) {\n-      continue;\n-    }\n-\n-    while ((token = strsep(&controllers, \",\")) != NULL) {\n-      if (strcmp(token, \"memory\") == 0) {\n-        memory->set_subsystem_path(base);\n-        jlong hierarchy = uses_mem_hierarchy();\n-        if (hierarchy > 0) {\n-          memory->set_hierarchical(true);\n-        }\n-      } else if (strcmp(token, \"cpuset\") == 0) {\n-        cpuset->set_subsystem_path(base);\n-      } else if (strcmp(token, \"cpu\") == 0) {\n-        cpu->set_subsystem_path(base);\n-      } else if (strcmp(token, \"cpuacct\") == 0) {\n-        cpuacct->set_subsystem_path(base);\n-      }\n-    }\n-  }\n-\n-  fclose(cgroup);\n-\n@@ -443,2 +67,2 @@\n-  \/\/ command line arguments have been processed.\n-  if ((mem_limit = memory_limit_in_bytes()) > 0) {\n+  \/\/ cgroup subsystem files have been processed.\n+  if ((mem_limit = cgroup_subsystem->memory_limit_in_bytes()) > 0) {\n@@ -456,20 +80,2 @@\n-  if (is_containerized()) {\n-    return \"cgroupv1\";\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/* uses_mem_hierarchy\n- *\n- * Return whether or not hierarchical cgroup accounting is being\n- * done.\n- *\n- * return:\n- *    A number > 0 if true, or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n-jlong OSContainer::uses_mem_hierarchy() {\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.use_hierarchy\",\n-                    \"Use Hierarchy is: \" JLONG_FORMAT, JLONG_FORMAT, use_hierarchy);\n-  return use_hierarchy;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->container_type();\n@@ -478,10 +84,0 @@\n-\n-\/* memory_limit_in_bytes\n- *\n- * Return the limit of available memory for this process.\n- *\n- * return:\n- *    memory limit in bytes or\n- *    -1 for unlimited\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -489,25 +85,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.limit_in_bytes\",\n-                     \"Memory Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memlimit);\n-\n-  if (memlimit >= _unlimited_memory) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Non-Hierarchical Memory Limit is: Unlimited\");\n-    }\n-    if (memory->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memory_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, memory, \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory Limit is: \" JULONG_FORMAT, format, hier_memlimit)\n-      if (hier_memlimit >= _unlimited_memory) {\n-        if (PrintContainerInfo) {\n-          tty->print_cr(\"Hierarchical Memory Limit is: Unlimited\");\n-        }\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n-    return (jlong)-1;\n-  }\n-  else {\n-    return (jlong)memlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_limit_in_bytes();\n@@ -517,23 +90,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.memsw.limit_in_bytes\",\n-                     \"Memory and Swap Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memswlimit);\n-  if (memswlimit >= _unlimited_memory) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Non-Hierarchical Memory and Swap Limit is: Unlimited\");\n-    }\n-    if (memory->is_hierarchical()) {\n-      const char* matchline = \"hierarchical_memsw_limit\";\n-      const char* format = \"%s \" JULONG_FORMAT;\n-      GET_CONTAINER_INFO_LINE(julong, memory, \"\/memory.stat\", matchline,\n-                             \"Hierarchical Memory and Swap Limit is : \" JULONG_FORMAT, format, hier_memlimit)\n-      if (hier_memlimit >= _unlimited_memory) {\n-        if (PrintContainerInfo) {\n-          tty->print_cr(\"Hierarchical Memory and Swap Limit is: Unlimited\");\n-        }\n-      } else {\n-        return (jlong)hier_memlimit;\n-      }\n-    }\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memswlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_and_swap_limit_in_bytes();\n@@ -543,10 +95,2 @@\n-  GET_CONTAINER_INFO(julong, memory, \"\/memory.soft_limit_in_bytes\",\n-                     \"Memory Soft Limit is: \" JULONG_FORMAT, JULONG_FORMAT, memsoftlimit);\n-  if (memsoftlimit >= _unlimited_memory) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"Memory Soft Limit is: Unlimited\");\n-    }\n-    return (jlong)-1;\n-  } else {\n-    return (jlong)memsoftlimit;\n-  }\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_soft_limit_in_bytes();\n@@ -565,3 +109,2 @@\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.usage_in_bytes\",\n-                     \"Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memusage);\n-  return memusage;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_usage_in_bytes();\n@@ -570,8 +113,0 @@\n-\/* memory_max_usage_in_bytes\n- *\n- * Return the maximum amount of used memory for this process.\n- *\n- * return:\n- *    max memory usage in bytes or\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -579,101 +114,2 @@\n-  GET_CONTAINER_INFO(jlong, memory, \"\/memory.max_usage_in_bytes\",\n-                     \"Maximum Memory Usage is: \" JLONG_FORMAT, JLONG_FORMAT, memmaxusage);\n-  return memmaxusage;\n-}\n-\n-\/* active_processor_count\n- *\n- * Calculate an appropriate number of active processors for the\n- * VM to use based on these three inputs.\n- *\n- * cpu affinity\n- * cgroup cpu quota & cpu period\n- * cgroup cpu shares\n- *\n- * Algorithm:\n- *\n- * Determine the number of available CPUs from sched_getaffinity\n- *\n- * If user specified a quota (quota != -1), calculate the number of\n- * required CPUs by dividing quota by period.\n- *\n- * If shares are in effect (shares != -1), calculate the number\n- * of CPUs required for the shares by dividing the share value\n- * by PER_CPU_SHARES.\n- *\n- * All results of division are rounded up to the next whole number.\n- *\n- * If neither shares or quotas have been specified, return the\n- * number of active processors in the system.\n- *\n- * If both shares and quotas have been specified, the results are\n- * based on the flag PreferContainerQuotaForCPUCount.  If true,\n- * return the quota value.  If false return the smallest value\n- * between shares or quotas.\n- *\n- * If shares and\/or quotas have been specified, the resulting number\n- * returned will never exceed the number of active processors.\n- *\n- * return:\n- *    number of CPUs\n- *\/\n-int OSContainer::active_processor_count() {\n-  int quota_count = 0, share_count = 0;\n-  int cpu_count, limit_count;\n-  int result;\n-\n-  \/\/ We use a cache with a timeout to avoid performing expensive\n-  \/\/ computations in the event this function is called frequently.\n-  \/\/ [See 8227006].\n-  if (!cpu->cache_has_expired()) {\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"OSContainer::active_processor_count (cached): %d\", OSContainer::_active_processor_count);\n-    }\n-\n-    return OSContainer::_active_processor_count;\n-  }\n-\n-  cpu_count = limit_count = os::Linux::active_processor_count();\n-  int quota  = cpu_quota();\n-  int period = cpu_period();\n-  int share  = cpu_shares();\n-\n-  if (quota > -1 && period > 0) {\n-    quota_count = ceilf((float)quota \/ (float)period);\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"CPU Quota count based on quota\/period: %d\", quota_count);\n-    }\n-  }\n-  if (share > -1) {\n-    share_count = ceilf((float)share \/ (float)PER_CPU_SHARES);\n-    if (PrintContainerInfo) {\n-      tty->print_cr(\"CPU Share count based on shares: %d\", share_count);\n-    }\n-  }\n-\n-  \/\/ If both shares and quotas are setup results depend\n-  \/\/ on flag PreferContainerQuotaForCPUCount.\n-  \/\/ If true, limit CPU count to quota\n-  \/\/ If false, use minimum of shares and quotas\n-  if (quota_count !=0 && share_count != 0) {\n-    if (PreferContainerQuotaForCPUCount) {\n-      limit_count = quota_count;\n-    } else {\n-      limit_count = MIN2(quota_count, share_count);\n-    }\n-  } else if (quota_count != 0) {\n-    limit_count = quota_count;\n-  } else if (share_count != 0) {\n-    limit_count = share_count;\n-  }\n-\n-  result = MIN2(cpu_count, limit_count);\n-  if (PrintContainerInfo) {\n-    tty->print_cr(\"OSContainer::active_processor_count: %d\", result);\n-  }\n-\n-  \/\/ Update the value and reset the cache timeout\n-  OSContainer::_active_processor_count = result;\n-  cpu->set_cache_expiry_time(OSCONTAINER_CACHE_TIMEOUT);\n-\n-  return result;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->memory_max_usage_in_bytes();\n@@ -683,3 +119,2 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, cpuset, \"\/cpuset.cpus\",\n-                     \"cpuset.cpus is: %s\", \"%1023s\", cpus, 1024);\n-  return os::strdup(cpus);\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_cpuset_cpus();\n@@ -689,3 +124,7 @@\n-  GET_CONTAINER_INFO_CPTR(cptr, cpuset, \"\/cpuset.mems\",\n-                     \"cpuset.mems is: %s\", \"%1023s\", mems, 1024);\n-  return os::strdup(mems);\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_cpuset_memory_nodes();\n+}\n+\n+int OSContainer::active_processor_count() {\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->active_processor_count();\n@@ -694,10 +133,0 @@\n-\/* cpu_quota\n- *\n- * Return the number of milliseconds per period\n- * process is guaranteed to run.\n- *\n- * return:\n- *    quota time in milliseconds\n- *    -1 for no quota\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -705,3 +134,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.cfs_quota_us\",\n-                     \"CPU Quota is: %d\", \"%d\", quota);\n-  return quota;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_quota();\n@@ -711,3 +139,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.cfs_period_us\",\n-                     \"CPU Period is: %d\", \"%d\", period);\n-  return period;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_period();\n@@ -716,10 +143,0 @@\n-\/* cpu_shares\n- *\n- * Return the amount of cpu shares available to the process\n- *\n- * return:\n- *    Share number (typically a number relative to 1024)\n- *                 (2048 typically expresses 2 CPUs worth of processing)\n- *    -1 for no share setup\n- *    OSCONTAINER_ERROR for not supported\n- *\/\n@@ -727,6 +144,2 @@\n-  GET_CONTAINER_INFO(int, cpu, \"\/cpu.shares\",\n-                     \"CPU Shares is: %d\", \"%d\", shares);\n-  \/\/ Convert 1024 to no shares setup\n-  if (shares == 1024) return -1;\n-\n-  return shares;\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->cpu_shares();\n@@ -734,1 +147,0 @@\n-\n","filename":"hotspot\/src\/os\/linux\/vm\/osContainer_linux.cpp","additions":36,"deletions":624,"binary":false,"changes":660,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,0 @@\n-  static jlong uses_mem_hierarchy();\n@@ -69,1 +68,0 @@\n-  assert(_is_initialized, \"OSContainer not initialized\");\n@@ -73,1 +71,1 @@\n-#endif \/\/ OS_LINUX_VM_OSCONTAINER_LINUX_HPP\n+#endif \/\/ OS_LINUX_OSCONTAINER_LINUX_HPP\n","filename":"hotspot\/src\/os\/linux\/vm\/osContainer_linux.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+  friend class CgroupSubsystem;\n","filename":"hotspot\/src\/os\/linux\/vm\/os_linux.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -64,1 +64,2 @@\n-    StringNullCheckMode\n+    StringNullCheckMode,\n+    NegativeIntCheckMode\n@@ -121,0 +122,1 @@\n+\n@@ -124,0 +126,5 @@\n+\n+  void push_negative_int_check(Node* value) {\n+    push(value, NegativeIntCheckMode);\n+  }\n+\n@@ -127,0 +134,1 @@\n+\n@@ -487,1 +495,2 @@\n-                  alloc->jvms()->dump_spec(tty); tty->cr();\n+                  alloc->jvms()->dump_spec(tty);\n+                  tty->cr();\n@@ -494,0 +503,21 @@\n+            } else if (sig == ciSymbol::int_void_signature()) {\n+              \/\/ StringBuilder(int) case.\n+              Node* parm = use->in(TypeFunc::Parms + 1);\n+              assert(parm != NULL, \"must exist\");\n+              const TypeInt* type = _gvn->type(parm)->is_int();\n+              if (type->_hi < 0) {\n+                \/\/ Initial capacity argument is always negative in which case StringBuilder(int) throws\n+                \/\/ a NegativeArraySizeException. Bail out from string opts.\n+#ifndef PRODUCT\n+                if (PrintOptimizeStringConcat) {\n+                  tty->print(\"giving up because a negative argument is passed to StringBuilder(int) which \"\n+                             \"throws a NegativeArraySizeException\");\n+                  alloc->jvms()->dump_spec(tty);\n+                  tty->cr();\n+                }\n+#endif\n+                return NULL;\n+              } else if (type->_lo < 0) {\n+                \/\/ Argument could be negative: We need a runtime check to throw NegativeArraySizeException in that case.\n+                sc->push_negative_int_check(parm);\n+              }\n@@ -1480,0 +1510,17 @@\n+      case StringConcat::NegativeIntCheckMode: {\n+        \/\/ Initial capacity argument might be negative in which case StringBuilder(int) throws\n+        \/\/ a NegativeArraySizeException. Insert a runtime check with an uncommon trap.\n+        const TypeInt* type = kit.gvn().type(arg)->is_int();\n+        assert(type->_hi >= 0 && type->_lo < 0, \"no runtime int check needed\");\n+        Node* p = __ Bool(__ CmpI(arg, kit.intcon(0)), BoolTest::ge);\n+        IfNode* iff = kit.create_and_map_if(kit.control(), p, PROB_MIN, COUNT_UNKNOWN);\n+        {\n+          \/\/ Negative int -> uncommon trap.\n+          PreserveJVMState pjvms(&kit);\n+          kit.set_control(__ IfFalse(iff));\n+          kit.uncommon_trap(Deoptimization::Reason_intrinsic,\n+                            Deoptimization::Action_maybe_recompile);\n+        }\n+        kit.set_control(__ IfTrue(iff));\n+        break;\n+      }\n@@ -1604,0 +1651,2 @@\n+          case StringConcat::NegativeIntCheckMode:\n+            break; \/\/ Nothing to do, was only needed to add a runtime check earlier.\n","filename":"hotspot\/src\/share\/vm\/opto\/stringopts.cpp","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -66,0 +66,5 @@\n+#ifdef LINUX\n+#include \"osContainer_linux.hpp\"\n+#include \"cgroupSubsystem_linux.hpp\"\n+#endif\n+\n@@ -165,1 +170,0 @@\n-#include \"osContainer_linux.hpp\"\n@@ -587,0 +591,12 @@\n+#ifdef LINUX\n+bool WhiteBox::validate_cgroup(const char* proc_cgroups,\n+                               const char* proc_self_cgroup,\n+                               const char* proc_self_mountinfo,\n+                               u1* cg_flags) {\n+  CgroupInfo cg_infos[4];\n+  return CgroupSubsystemFactory::determine_type(cg_infos, proc_cgroups,\n+                                                    proc_self_cgroup,\n+                                                    proc_self_mountinfo, cg_flags);\n+}\n+#endif\n+\n@@ -1205,0 +1221,25 @@\n+WB_ENTRY(jint, WB_ValidateCgroup(JNIEnv* env,\n+                                    jobject o,\n+                                    jstring proc_cgroups,\n+                                    jstring proc_self_cgroup,\n+                                    jstring proc_self_mountinfo))\n+  jint ret = 0;\n+#ifdef LINUX\n+  ThreadToNativeFromVM ttnfv(thread);\n+  const char* p_cgroups = env->GetStringUTFChars(proc_cgroups, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_cgroup = env->GetStringUTFChars(proc_self_cgroup, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  const char* p_s_mountinfo = env->GetStringUTFChars(proc_self_mountinfo, NULL);\n+  CHECK_JNI_EXCEPTION_(env, 0);\n+  u1 cg_type_flags = 0;\n+  \/\/ This sets cg_type_flags\n+  WhiteBox::validate_cgroup(p_cgroups, p_s_cgroup, p_s_mountinfo, &cg_type_flags);\n+  ret = (jint)cg_type_flags;\n+  env->ReleaseStringUTFChars(proc_cgroups, p_cgroups);\n+  env->ReleaseStringUTFChars(proc_self_cgroup, p_s_cgroup);\n+  env->ReleaseStringUTFChars(proc_self_mountinfo, p_s_mountinfo);\n+#endif\n+  return ret;\n+WB_END\n+\n@@ -1335,0 +1376,3 @@\n+  {CC\"validateCgroup\",\n+      CC\"(Ljava\/lang\/String;Ljava\/lang\/String;Ljava\/lang\/String;)I\",\n+                                                      (void*)&WB_ValidateCgroup },\n","filename":"hotspot\/src\/share\/vm\/prims\/whitebox.cpp","additions":45,"deletions":1,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,3 @@\n+#ifdef LINUX\n+  static bool validate_cgroup(const char* proc_cgroups, const char* proc_self_cgroup, const char* proc_self_mountinfo, u1* cg_flags);\n+#endif\n","filename":"hotspot\/src\/share\/vm\/prims\/whitebox.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -635,0 +635,5 @@\n+  \/\/ Check for overflow.\n+  if (size + nmt_header_size < size) {\n+    return NULL;\n+  }\n+\n","filename":"hotspot\/src\/share\/vm\/runtime\/os.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -388,1 +388,1 @@\n-  while (i-- >= 0) {\n+  while (--i >= 0) {\n","filename":"hotspot\/src\/share\/vm\/utilities\/ostream.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test CgroupSubsystemFactory\n+ * @requires os.family == \"linux\"\n+ * @library \/testlibrary \/test\/lib\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ *                              sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI CgroupSubsystemFactory\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.util.FileUtils;\n+import sun.hotspot.WhiteBox;\n+\n+\/*\n+ * Verify hotspot's detection heuristics of CgroupSubsystemFactory::create()\n+ *\/\n+public class CgroupSubsystemFactory {\n+\n+    \/\/ Mirrored from src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp\n+    private static final int CGROUPS_V1 = 1;\n+    private static final int CGROUPS_V2 = 2;\n+    private static final int INVALID_CGROUPS_V2 = 3;\n+    private static final int INVALID_CGROUPS_V1 = 4;\n+    private static final int INVALID_CGROUPS_NO_MOUNT = 5;\n+    private Path existingDirectory;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchyOtherOrder;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private String mntInfoEmpty = \"\";\n+    private Path cgroupV1SelfCgroup;\n+    private Path cgroupV2SelfCgroup;\n+    private Path cgroupV2MntInfoMissingCgroupv2;\n+    private Path cgroupv1MntInfoMissingMemoryController;\n+    private String procSelfCgroupHybridContent = \"11:hugetlb:\/\\n\" +\n+            \"10:devices:\/user.slice\\n\" +\n+            \"9:pids:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"8:cpu,cpuacct:\/\\n\" +\n+            \"7:perf_event:\/\\n\" +\n+            \"6:freezer:\/\\n\" +\n+            \"5:blkio:\/\\n\" +\n+            \"4:net_cls,net_prio:\/\\n\" +\n+            \"3:cpuset:\/\\n\" +\n+            \"2:memory:\/user.slice\/user-15263.slice\/user@15263.service\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\\n\" +\n+            \"0::\/user.slice\/user-15263.slice\/user@15263.service\/gnome-terminal-server.service\";\n+    private String procSelfCgroupV2UnifiedContent = \"0::\/user.slice\/user-1000.slice\/session-3.scope\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String cgroupV2LineHybrid = \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\";\n+    private String cgroupv1MountInfoLineMemory = \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\";\n+    private String mntInfoHybridStub =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n+    private String mntInfoHybridRest = cgroupv1MountInfoLineMemory + mntInfoHybridStub;\n+    private String mntInfoHybridMissingMemory = mntInfoHybridStub;\n+    private String mntInfoHybrid = cgroupV2LineHybrid + mntInfoHybridRest;\n+    private String mntInfoHybridFlippedOrder = mntInfoHybridRest + cgroupV2LineHybrid;\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  3   1   1\\n\" +\n+            \"cpu 8   1   1\\n\" +\n+            \"cpuacct 8   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n+\n+    private void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(CgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.writeString(cgroupsZero, cgroupsZeroHierarchy, StandardCharsets.UTF_8);\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.writeString(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty);\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.writeString(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only);\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.writeString(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy);\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.writeString(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid);\n+\n+            cgroupv1MntInfoNonZeroHierarchyOtherOrder = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero_cgroupv2_last\");\n+            Files.writeString(cgroupv1MntInfoNonZeroHierarchyOtherOrder, mntInfoHybridFlippedOrder);\n+\n+            cgroupV1SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_hybrid\");\n+            Files.writeString(cgroupV1SelfCgroup, procSelfCgroupHybridContent);\n+\n+            cgroupV2SelfCgroup = Paths.get(existingDirectory.toString(), \"cgroup_self_v2\");\n+            Files.writeString(cgroupV2SelfCgroup, procSelfCgroupV2UnifiedContent);\n+\n+            cgroupv1MntInfoMissingMemoryController = Paths.get(existingDirectory.toString(), \"mnt_info_missing_memory\");\n+            Files.writeString(cgroupv1MntInfoMissingMemoryController, mntInfoHybridMissingMemory);\n+\n+            cgroupV2MntInfoMissingCgroupv2 = Paths.get(existingDirectory.toString(), \"mnt_info_missing_cgroup2\");\n+            Files.writeString(cgroupV2MntInfoMissingCgroupv2, mntInfoHybridStub);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    private boolean isValidCgroup(int value) {\n+        return value == CGROUPS_V1 || value == CGROUPS_V2;\n+    }\n+\n+    public void testCgroupv1NoMounts(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_NO_MOUNT, retval, \"No cgroups mounted in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1NoMounts PASSED!\");\n+    }\n+\n+    public void testCgroupv2NoCgroup2Fs(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupV2MntInfoMissingCgroupv2.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V2, retval, \"No cgroup2 filesystem in \/proc\/self\/mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2NoCgroup2Fs PASSED!\");\n+    }\n+\n+    public void testCgroupv1MissingMemoryController(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoMissingMemoryController.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_V1, retval, \"Required memory controller path missing in mountinfo. Invalid.\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1MissingMemoryController PASSED!\");\n+    }\n+\n+    public void testCgroupv2(WhiteBox wb) {\n+        String procCgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV2SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V2, retval, \"Expected\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv2 PASSED!\");\n+    }\n+\n+    public void testCgroupV1Hybrid(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1Hybrid PASSED!\");\n+    }\n+\n+    public void testCgroupV1HybridMntInfoOrder(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoNonZeroHierarchyOtherOrder.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(CGROUPS_V1, retval, \"Hybrid cgroups expected as cgroups v1\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1HybridMntInfoOrder PASSED!\");\n+    }\n+\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        CgroupSubsystemFactory test = new CgroupSubsystemFactory();\n+        test.setup();\n+        try {\n+            test.testCgroupv1NoMounts(wb);\n+            test.testCgroupv2(wb);\n+            test.testCgroupV1Hybrid(wb);\n+            test.testCgroupV1HybridMntInfoOrder(wb);\n+            test.testCgroupv1MissingMemoryController(wb);\n+            test.testCgroupv2NoCgroup2Fs(wb);\n+        } finally {\n+            test.teardown();\n+        }\n+    }\n+}\n","filename":"hotspot\/test\/runtime\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -32,0 +33,8 @@\n+        Metrics metrics = jdk.internal.platform.Container.metrics();\n+        System.out.println(\"Metrics instance: \" + (metrics == null ? \"null\" : \"non-null\"));\n+        if (metrics != null) {\n+            System.out.println(\"Metrics.getMemoryAndSwapLimit() == \" + metrics.getMemoryAndSwapLimit());\n+            System.out.println(\"Metrics.getMemoryLimit() == \" + metrics.getMemoryLimit());\n+            System.out.println(\"Metrics.getMemoryAndSwapUsage() == \" + metrics.getMemoryAndSwapUsage());\n+            System.out.println(\"Metrics.getMemoryUsage() == \" + metrics.getMemoryUsage());\n+        }\n","filename":"hotspot\/test\/runtime\/containers\/docker\/CheckOperatingSystemMXBean.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import com.oracle.java.testlibrary.OutputAnalyzer;\n@@ -211,3 +212,15 @@\n-        Common.run(opts)\n-            .shouldMatch(\"CPU Shares is.*\" + shares)\n-            .shouldMatch(\"active_processor_count.*\" + expectedAPC);\n+        OutputAnalyzer out = Common.run(opts);\n+        \/\/ Cgroups v2 needs to do some scaling of raw shares values. Hence,\n+        \/\/ 256 CPU shares come back as 264. Raw value written to cpu.weight\n+        \/\/ is 10. The reason this works for >= 1024 shares value is because\n+        \/\/ post-scaling the closest multiple of 1024 is found and returned.\n+        \/\/\n+        \/\/ For values < 1024, this doesn't happen so loosen the match to a\n+        \/\/ 3-digit number and ensure the active_processor_count is as\n+        \/\/ expected.\n+        if (shares < 1024) {\n+            out.shouldMatch(\"CPU Shares is.*\\\\d{3}\");\n+        } else {\n+            out.shouldMatch(\"CPU Shares is.*\" + shares);\n+        }\n+        out.shouldMatch(\"active_processor_count.*\" + expectedAPC);\n","filename":"hotspot\/test\/runtime\/containers\/docker\/TestCPUAwareness.java","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2022a\n+tzdata2022c\n","filename":"jdk\/make\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+Link Africa\/Abidjan Atlantic\/Reykjavik\t# Iceland\n@@ -195,1 +196,1 @@\n-# observatory; round to nearest.  Milne also says that the official time for\n+# observatory.  Milne also says that the official time for\n@@ -380,0 +381,1 @@\n+\t\t#STDOFF\t2:05:08.9\n@@ -433,1 +435,1 @@\n-# [Ordinance No. 11 of 1928, The Offical Gazette, 1928-06-26, p 813]\n+# [Ordinance No. 11 of 1928, The Official Gazette, 1928-06-26, p 813]\n@@ -1143,2 +1145,1 @@\n-\t\t\t 0:00\tMorocco\t+00\/+01\t2087 May 11  2:00\n-\t\t\t 1:00\t-\t+01\n+\t\t\t 0:00\tMorocco\t+00\/+01\n@@ -1160,2 +1161,1 @@\n-\t\t\t 0:00\tMorocco\t+00\/+01\t2087 May 11  2:00\n-\t\t\t 1:00\t-\t+01\n+\t\t\t 0:00\tMorocco\t+00\/+01\n@@ -1338,9 +1338,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tIndian\/Reunion\t3:41:52 -\tLMT\t1911 Jun # Saint-Denis\n-\t\t\t4:00\t-\t+04\n-#\n-# Scattered Islands (Îles Éparses) administered from Réunion are as follows.\n-# The following information about them is taken from\n-# Îles Éparses (<http:\/\/www.outre-mer.gouv.fr\/domtom\/ile.htm>, 1997-07-22,\n-# in French; no longer available as of 1999-08-17).\n-# We have no info about their time zone histories.\n+# See Asia\/Dubai.\n@@ -1348,5 +1340,1 @@\n-# Bassas da India - uninhabited\n-# Europa Island - inhabited from 1905 to 1910 by two families\n-# Glorioso Is - inhabited until at least 1958\n-# Juan de Nova - uninhabited\n-# Tromelin - inhabited until at least 1958\n+# The Crozet Islands also observe Réunion time; see the 'antarctica' file.\n@@ -1384,1 +1372,1 @@\n-# coordinated time, will be restituted at 2 o'clock on day 1 of January, 2019.]\n+# coordinated time, will be reinstituted at 2 o'clock on day 1 of January, 2019.]\n@@ -1387,0 +1375,1 @@\n+\t\t#STDOFF\t-0:36:44.68\n@@ -1396,22 +1385,1 @@\n-\n-# From P Chan (2020-11-27):\n-# Standard Time was adopted on 1907-01-01.\n-#\n-# Standard Time Ordinance (Chapter 237)\n-# The Laws of Seychelles in Force on the 31st December, 1971, Vol. 6, p 571\n-# https:\/\/books.google.com\/books?id=efE-AQAAIAAJ&pg=PA571\n-#\n-# From Tim Parenti (2020-12-05):\n-# A footnote on https:\/\/books.google.com\/books?id=DYdDAQAAMAAJ&pg=PA1689\n-# confirms that Ordinance No. 9 of 1906 \"was brought into force on the 1st\n-# January, 1907.\"\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tIndian\/Mahe\t3:41:48 -\tLMT\t1907 Jan  1 # Victoria\n-\t\t\t4:00\t-\t+04\n-# From Paul Eggert (2001-05-30):\n-# Aldabra, Farquhar, and Desroches, originally dependencies of the\n-# Seychelles, were transferred to the British Indian Ocean Territory\n-# in 1965 and returned to Seychelles control in 1976.  We don't know\n-# whether this affected their time zone, so omit this for now.\n-# Possibly the islands were uninhabited.\n+# See Asia\/Dubai.\n","filename":"jdk\/make\/data\/tzdata\/africa","additions":11,"deletions":43,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -183,3 +183,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Indian\/Kerguelen\t0\t-\t-00\t1950 # Port-aux-Français\n-\t\t\t5:00\t-\t+05\n+# Kerguelen - see Indian\/Maldives.\n@@ -268,25 +266,1 @@\n-# From Craig Mundell (1994-12-15):\n-# http:\/\/quest.arc.nasa.gov\/antarctica\/QA\/computers\/Directions,Time,ZIP\n-# Vostok, which is one of the Russian stations, is set on the same\n-# time as Moscow, Russia.\n-#\n-# From Lee Hotz (2001-03-08):\n-# I queried the folks at Columbia who spent the summer at Vostok and this is\n-# what they had to say about time there:\n-# \"in the US Camp (East Camp) we have been on New Zealand (McMurdo)\n-# time, which is 12 hours ahead of GMT. The Russian Station Vostok was\n-# 6 hours behind that (although only 2 miles away, i.e. 6 hours ahead\n-# of GMT). This is a time zone I think two hours east of Moscow. The\n-# natural time zone is in between the two: 8 hours ahead of GMT.\"\n-#\n-# From Paul Eggert (2001-05-04):\n-# This seems to be hopelessly confusing, so I asked Lee Hotz about it\n-# in person.  He said that some Antarctic locations set their local\n-# time so that noon is the warmest part of the day, and that this\n-# changes during the year and does not necessarily correspond to mean\n-# solar noon.  So the Vostok time might have been whatever the clocks\n-# happened to be during their visit.  So we still don't really know what time\n-# it is at Vostok.  But we'll guess +06.\n-#\n-Zone Antarctica\/Vostok\t0\t-\t-00\t1957 Dec 16\n-\t\t\t6:00\t-\t+06\n+# See Asia\/Urumqi.\n","filename":"jdk\/make\/data\/tzdata\/antarctica","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -281,4 +281,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Brunei\t7:39:40 -\tLMT\t1926 Mar # Bandar Seri Begawan\n-\t\t\t7:30\t-\t+0730\t1933\n-\t\t\t8:00\t-\t+08\n+# See Asia\/Kuching.\n@@ -302,0 +299,1 @@\n+Link Asia\/Yangon Indian\/Cocos\n@@ -370,6 +368,3 @@\n-# a. For the 1940 May 31 spring forward, the essay claim that it was\n-# coordinared between the international settlement authority and the French\n-# concession authority and have gathered support from Hong Kong and Xiamen,\n-# that it would spring forward an hour from May 31 \"midnight\", and the essay\n-# claim \"Hong Kong government implemented the spring forward in the same time\n-# on the same date as Shanghai\".\n+# a. For the 1940 May 31 spring forward, the essay [says] ... \"Hong\n+# Kong government implemented the spring forward in the same time on\n+# the same date as Shanghai\".\n@@ -571,1 +566,1 @@\n-# Milne gives 8:05:43.2 for Xujiahui Observatory time; round to nearest.\n+# Milne gives 8:05:43.2 for Xujiahui Observatory time....\n@@ -690,0 +685,1 @@\n+\t\t#STDOFF\t8:05:43.2\n@@ -697,0 +693,1 @@\n+Link Asia\/Urumqi Antarctica\/Vostok\n@@ -701,1 +698,1 @@\n-# Milne gives 7:36:41.7; round this.\n+# Milne gives 7:36:41.7.\n@@ -885,1 +882,2 @@\n-Zone\tAsia\/Hong_Kong\t7:36:42 -\tLMT\t1904 Oct 30  0:36:42\n+\t\t#STDOFF\t7:36:41.7\n+Zone\tAsia\/Hong_Kong\t7:36:42 -\tLMT\t1904 Oct 29 17:00u\n@@ -1360,1 +1358,1 @@\n-# civil time was 7:07:12.5; round to even for Jakarta.\n+# civil time was 7:07:12.5.\n@@ -1396,0 +1394,1 @@\n+\t\t#STDOFF\t7:07:12.5\n@@ -1399,1 +1398,1 @@\n-\t\t\t7:07:12\t-\tBMT\t1923 Dec 31 23:47:12 # Batavia\n+\t\t\t7:07:12\t-\tBMT\t1923 Dec 31 16:40u # Batavia\n@@ -1431,0 +1430,105 @@\n+# From Roozbeh Pournader (2022-05-30):\n+# Here's an order from the Cabinet to the rest of the government to switch to\n+# Tehran time, which is mentioned to be already at +03:30:\n+# https:\/\/qavanin.ir\/Law\/TreeText\/180138\n+# Just in case that goes away, I also saved a copy at archive.org:\n+# https:\/\/web.archive.org\/web\/20220530111940\/https:\/\/qavanin.ir\/Law\/TreeText\/180138\n+# Here's my translation:\n+#\n+# \"Circular on Matching the Hours of Governmental and Official Circles\n+# in Provinces\n+# Approved 1314\/03\/22 [=1935-06-13]\n+# According to the ruling of the Honorable Cabinet, it is ordered that from\n+# now on in all internal provinces of the country, governmental and official\n+# circles set their time to match Tehran time (three hours and half before\n+# Greenwich)....\n+#\n+# I still haven't found out when Tehran itself switched to +03:30....\n+#\n+# From Paul Eggert (2022-06-05):\n+# Although the above says Tehran was at +03:30 before 1935-06-13, we don't\n+# know when it switched to +03:30.  For now, use 1935-06-13 as the switch date.\n+# Although most likely wrong, we have no better info.\n+\n+# From Roozbeh Pournader (2022-06-01):\n+# This is from Kayhan newspaper, one of the major Iranian newspapers, from\n+# March 20, 1978, page 2:\n+#\n+# \"Pull the clocks 60 minutes forward\n+# As we informed before, from the fourth day of the month Farvardin of the\n+# new year [=1978-03-24], clocks will be pulled forward, and people's daily\n+# work and life program will start one hour earlier than the current program.\n+# On the 1st day of the month Farvardin of this year [=1977-03-21], they had\n+# pulled the clocks forward by one hour, but in the month of Mehr\n+# [=1977-09-23], the clocks were pulled back by 30 minutes.\n+# In this way, from the 4th day of the month Farvardin, clocks will be ahead\n+# of the previous years by one hour and a half.\n+# According to the new program, during the night of 4th of Farvardin, when\n+# the midnight, meaning 24 o'clock is announced, the hands of the clock must\n+# be pulled forward by one hour and thus consider midnight 1 o'clock in the\n+# forenoon.\"\n+#\n+# This implies that in September 1977, when the daylight savings time was\n+# done with, Iran didn't go back to +03:30, but immediately to +04:00.\n+#\n+#\n+# This is from the major Iranian newspaper Ettela'at, dated [1978-08-03]...,\n+# page 32. It looks like they decided to get the clocks back to +4:00\n+# just in time for Ramadan that year:\n+#\n+# \"Tomorrow Night, Pull the Clocks Back by One Hour\n+# At 1 o'clock in the forenoon of Saturday 14 Mordad [=1978-08-05], the\n+# clocks will be pulled one hour back and instead of 1 o'clock in the\n+# forenoon, Radio Iran will announce 24 o'clock.\n+# This decision was made in the Cabinet of Ministers meeting of 25 Tir\n+# [=1978-07-16], [...]\n+# At the beginning of the year 2537 [=March 1978: Iran was using a different\n+# year number for a few years then, based on the Coronation of Cyrus the\n+# Great], the country's official time was pulled forward by one hour and now\n+# the official time is one hour and a half ahead compared to last year,\n+# because in Farvardin of last year [=March 1977], the official time was\n+# pulled forward one hour and this continued until the second half of last\n+# year [=September 1977] until in the second half of last year the official\n+# time was pulled back half an hour and that half hour still remains.\"\n+#\n+# This matches the time of the true noon published in the newspapers, as they\n+# clearly go from +05:00 to +04:00 after that date (which happened during a\n+# long weekend in Iran).\n+\n+# From Roozbeh Pournader (2022-05-31):\n+# [Movahedi S. Cultural preconceptions of time: Can we use operational time\n+# to meddle in God's Time? Comp Stud Soc Hist. 1985;27(3):385-400]\n+# https:\/\/www.jstor.org\/stable\/178704\n+# Here's the quotes from the paper:\n+# 1. '\"Iran's official time keeper moved the clock one hour forward as from\n+# March 22, 1977 (Farvardin 2, 2536) to make maximum use of daylight and save\n+# in energy consumption. Thus Iran joined such other countries as Britain in\n+# observing what is known as 'daylight saving.' The proposal was originally\n+# put forward by the Ministry of Energy, in no way having any influence on\n+# observing religious ceremonies. Moving time one hour forward in summer\n+# means that at 11:00 o'clock on March 21, the official time was set as\n+# midnight March 22. Then September 24 will actually begin one hour later\n+# than the end of September 23 [...].\" Iran's time base thus continued to be\n+# Greenwich Mean Time plus three and one-half hours (plus four and one-half\n+# hours in summer).'\n+#\n+# The article sources this from Iran Almanac and Book of Facts, 1977, Tehran:\n+# Echo of Iran, which is on Google Books at\n+# https:\/\/www.google.com\/books\/edition\/Iran_Almanac_and_Book_of_Facts\/9ybVAAAAMAAJ.\n+# (I confirmed it by searching for snippets.)\n+#\n+# 2. \"After the fall of the shah, the revolutionary government returned to\n+# daylight-saving time (DST) on 26 May 1979.\"\n+#\n+# This seems to have been announced just one day in advance, on 25 May 1979.\n+#\n+# The change in 1977 clearly seems to be the first daylight savings effort in\n+# Iran. But the article doesn't mention what happened in 1978 (which was\n+# still during the shah's government), or how things continued in 1979\n+# onwards (which was during the Islamic Republic).\n+\n+# From Francis Santoni (2022-06-01):\n+# for Iran and 1977 the effective change is only 20 October\n+# (UIT No. 143 17.XI.1977) and not 23 September (UIT No. 141 13.IX.1977).\n+# UIT is the Operational Bulletin of International Telecommunication Union.\n+\n@@ -1465,59 +1569,6 @@\n-# From Paul Eggert (2018-11-30):\n-# Go with Shanks & Pottenger before Sept. 1991, and with Pournader thereafter.\n-# I used the following code in GNU Emacs 26.1 to generate the \"Rule Iran\"\n-# lines from 2008 through 2087.  Emacs 26.1 uses Ed Reingold's\n-# cal-persia implementation of Birashk's approximation, which in the\n-# 2008-2087 range disagrees with the astronomical Persian calendar\n-# for Persian years 1404 (Gregorian 2025) and 1437 (Gregorian 2058), so\n-# the following code special-cases those years.  See Table 15.1, page 264, of:\n-# Edward M. Reingold and Nachum Dershowitz, Calendrical Calculations:\n-# The Ultimate Edition, Cambridge University Press (2018).\n-# https:\/\/www.cambridge.org\/fr\/academic\/subjects\/computer-science\/computing-general-interest\/calendrical-calculations-ultimate-edition-4th-edition\n-# Page 258, footnote 2, of this book says there is some dispute over what will\n-# happen in 2091 (and some other years after that), so this code\n-# stops in 2087, as 2088 and 2089 agree with the \"max\" rule below.\n-# (cl-loop\n-#  initially (require 'cal-persia)\n-#  with first-persian-year = 1387\n-#  with last-persian-year = 1466\n-#  ;; Exceptional years in the above range,\n-#  ;; from Reingold & Dershowitz Table 15.1, page 264:\n-#  with exceptional-persian-years = '(1404 1437)\n-#  with range-start = nil\n-#  for persian-year from first-persian-year to last-persian-year\n-#  do\n-#  (let*\n-#      ((exceptional-year-offset\n-#        (if (member persian-year exceptional-persian-years) 1 0))\n-#       (beg-dst-absolute\n-#        (+ (calendar-persian-to-absolute (list 1 1 persian-year))\n-#           exceptional-year-offset))\n-#       (end-dst-absolute\n-#        (+ (calendar-persian-to-absolute (list 6 30 persian-year))\n-#           exceptional-year-offset))\n-#       (next-year-beg-dst-absolute\n-#        (+ (calendar-persian-to-absolute (list 1 1 (1+ persian-year)))\n-#           (if (member (1+ persian-year) exceptional-persian-years) 1 0)))\n-#       (beg-dst (calendar-gregorian-from-absolute beg-dst-absolute))\n-#       (end-dst (calendar-gregorian-from-absolute end-dst-absolute))\n-#       (next-year-beg-dst (calendar-gregorian-from-absolute\n-#                           next-year-beg-dst-absolute))\n-#       (year (calendar-extract-year beg-dst))\n-#       (range-end (if range-start year \"only\")))\n-#    (setq range-start (or range-start year))\n-#    (when (or (\/= (calendar-extract-day beg-dst)\n-#                  (calendar-extract-day next-year-beg-dst))\n-#              (= persian-year last-persian-year))\n-#      (insert\n-#       (format\n-#        \"Rule\\tIran\\t%d\\t%s\\t-\\t%s\\t%2d\\t24:00\\t1:00\\t-\\n\"\n-#        range-start range-end\n-#        (calendar-month-name (calendar-extract-month beg-dst) t)\n-#        (calendar-extract-day beg-dst)))\n-#      (insert\n-#       (format\n-#        \"Rule\\tIran\\t%d\\t%s\\t-\\t%s\\t%2d\\t24:00\\t0\\t-\\n\"\n-#        range-start range-end\n-#        (calendar-month-name (calendar-extract-month end-dst) t)\n-#        (calendar-extract-day end-dst)))\n-#      (setq range-start nil))))\n+# From Paul Eggert (2022-06-30):\n+# Go with Pournader for 1935 through spring 1979, and for timestamps\n+# after August 1991; go with with Shanks & Pottenger for other timestamps.\n+# Go with Santoni's citation of the UIT for fall 1977, as 20 October 1977\n+# is 28 Mehr 1356, consistent with the \"Mehr\" in Pournader's source.\n+# Assume that the UIT's \"1930\" is UTC, i.e., 24:00 local time.\n@@ -1557,0 +1608,6 @@\n+# From Ali Mirjamali (2022-05-10):\n+# Official IR News Agency announcement: irna.ir\/xjJ3TT\n+# ...\n+# Highlights: DST will be cancelled for the next Iranian year 1402\n+# (i.e 2023-March-21) and forthcoming years.\n+#\n@@ -1558,2 +1615,8 @@\n-Rule\tIran\t1978\t1980\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t1978\tonly\t-\tOct\t20\t24:00\t0\t-\n+# Work around a bug in zic 2022a and earlier.\n+Rule\tIran\t1910\tonly\t-\tJan\t 1\t00:00\t0\t-\n+#\n+Rule\tIran\t1977\tonly\t-\tMar\t21\t23:00\t1:00\t-\n+Rule\tIran\t1977\tonly\t-\tOct\t20\t24:00\t0\t-\n+Rule\tIran\t1978\tonly\t-\tMar\t24\t24:00\t1:00\t-\n+Rule\tIran\t1978\tonly\t-\tAug\t 5\t01:00\t0\t-\n+Rule\tIran\t1979\tonly\t-\tMay\t26\t24:00\t1:00\t-\n@@ -1561,0 +1624,1 @@\n+Rule\tIran\t1980\tonly\t-\tMar\t20\t24:00\t1:00\t-\n@@ -1591,74 +1655,2 @@\n-Rule\tIran\t2021\t2023\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2021\t2023\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2024\tonly\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2024\tonly\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2025\t2027\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2025\t2027\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2028\t2029\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2028\t2029\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2030\t2031\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2030\t2031\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2032\t2033\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2032\t2033\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2034\t2035\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2034\t2035\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2036\t2037\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2036\t2037\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2038\t2039\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2038\t2039\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2040\t2041\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2040\t2041\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2042\t2043\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2042\t2043\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2044\t2045\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2044\t2045\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2046\t2047\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2046\t2047\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2048\t2049\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2048\t2049\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2050\t2051\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2050\t2051\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2052\t2053\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2052\t2053\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2054\t2055\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2054\t2055\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2056\t2057\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2056\t2057\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2058\t2059\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2058\t2059\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2060\t2062\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2060\t2062\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2063\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2063\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2064\t2066\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2064\t2066\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2067\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2067\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2068\t2070\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2068\t2070\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2071\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2071\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2072\t2074\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2072\t2074\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2075\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2075\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2076\t2078\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2076\t2078\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2079\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2079\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2080\t2082\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2080\t2082\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2083\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2083\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2084\t2086\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2084\t2086\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2087\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2087\tonly\t-\tSep\t21\t24:00\t0\t-\n-#\n-# The following rules are approximations starting in the year 2088.\n-# These are the best post-2088 approximations available, given the\n-# restrictions of a single rule using ordinary Gregorian dates.\n-# At some point this table will need to be extended, though quite\n-# possibly Iran will change the rules first.\n-Rule\tIran\t2088\tmax\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2088\tmax\t-\tSep\t20\t24:00\t0\t-\n+Rule\tIran\t2021\t2022\t-\tMar\t21\t24:00\t1:00\t-\n+Rule\tIran\t2021\t2022\t-\tSep\t21\t24:00\t0\t-\n@@ -1668,2 +1660,2 @@\n-\t\t\t3:25:44\t-\tTMT\t1946     # Tehran Mean Time\n-\t\t\t3:30\t-\t+0330\t1977 Nov\n+\t\t\t3:25:44\t-\tTMT\t1935 Jun 13 # Tehran Mean Time\n+\t\t\t3:30\tIran\t+0330\/+0430 1977 Oct 20 24:00\n@@ -2491,3 +2483,3 @@\n-# Qyzyolrda Region (Asia\/Qyzylorda) is changing its time zone from\n-# UTC+6 to UTC+5 effective December 21st, 2018. The legal document is\n-# located here: http:\/\/adilet.zan.kz\/rus\/docs\/P1800000817 (russian language).\n+# (Asia\/Qyzylorda) is changing its time zone from UTC+6 to UTC+5\n+# effective December 21st, 2018....\n+# http:\/\/adilet.zan.kz\/rus\/docs\/P1800000817 (russian language).\n@@ -2770,14 +2762,2 @@\n-# peninsular Malaysia\n-# taken from Mok Ly Yng (2003-10-30)\n-# https:\/\/web.archive.org\/web\/20190822231045\/http:\/\/www.math.nus.edu.sg\/~mathelmr\/teaching\/timezone.html\n-# This agrees with Singapore since 1905-06-01.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Asia\/Kuala_Lumpur\t6:46:46 -\tLMT\t1901 Jan  1\n-\t\t\t6:55:25\t-\tSMT\t1905 Jun  1 # Singapore M.T.\n-\t\t\t7:00\t-\t+07\t1933 Jan  1\n-\t\t\t7:00\t0:20\t+0720\t1936 Jan  1\n-\t\t\t7:20\t-\t+0720\t1941 Sep  1\n-\t\t\t7:30\t-\t+0730\t1942 Feb 16\n-\t\t\t9:00\t-\t+09\t1945 Sep 12\n-\t\t\t7:30\t-\t+0730\t1982 Jan  1\n-\t\t\t8:00\t-\t+08\n+# For peninsular Malaysia see Asia\/Singapore.\n+#\n@@ -2794,0 +2774,1 @@\n+Link Asia\/Kuching Asia\/Brunei\n@@ -2800,0 +2781,1 @@\n+Link Indian\/Maldives Indian\/Kerguelen\n@@ -3634,0 +3616,1 @@\n+Link Asia\/Singapore Asia\/Kuala_Lumpur\n@@ -3868,1 +3851,1 @@\n-\t\t\t5:00\t1:00\t+05\/+06\t1991 Sep  9  2:00s\n+\t\t\t5:00\t1:00\t+06\t1991 Sep  9  2:00s\n@@ -3878,0 +3861,1 @@\n+Link Asia\/Bangkok Indian\/Christmas\n@@ -3893,0 +3877,2 @@\n+Link Asia\/Dubai Indian\/Mahe\n+Link Asia\/Dubai Indian\/Reunion\n@@ -3904,1 +3890,2 @@\n-# Milne says Tashkent was 4:37:10.8; round to nearest.\n+# Milne says Tashkent was 4:37:10.8.\n+\t\t#STDOFF\t4:37:10.8\n@@ -3923,1 +3910,1 @@\n-# From Paul Eggert (2014-10-21) after a heads-up from Trần Ngọc Quân:\n+# From Paul Eggert (2022-07-27) after a 2014 heads-up from Trần Ngọc Quân:\n@@ -3935,2 +3922,2 @@\n-# the Paris Meridian (2° 20' 14.03\" E); the former yields 07:06:30.1333...\n-# and the latter 07:06:29.333... so either way it rounds to 07:06:30,\n+# the Paris Meridian; for now guess the former and round the exact\n+# 07:06:30.1333... to 07:06:30.13 as the legal spec used 66 2\/3 ms precision.\n@@ -3963,1 +3950,2 @@\n-Zone Asia\/Ho_Chi_Minh\t7:06:40 -\tLMT\t1906 Jul  1\n+\t\t#STDOFF\t7:06:30.13\n+Zone Asia\/Ho_Chi_Minh\t7:06:30 -\tLMT\t1906 Jul  1\n","filename":"jdk\/make\/data\/tzdata\/asia","additions":163,"deletions":175,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -278,3 +278,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Indian\/Christmas\t7:02:52 -\tLMT\t1895 Feb\n-\t\t\t7:00\t-\t+07\n+# See Asia\/Bangkok.\n@@ -283,5 +281,1 @@\n-# These islands were ruled by the Ross family from about 1830 to 1978.\n-# We don't know when standard time was introduced; for now, we guess 1900.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tIndian\/Cocos\t6:27:40\t-\tLMT\t1900\n-\t\t\t6:30\t-\t+0630\n+# See Asia\/Yangon.\n@@ -504,0 +498,5 @@\n+Link Pacific\/Tarawa Pacific\/Funafuti\n+Link Pacific\/Tarawa Pacific\/Majuro\n+Link Pacific\/Tarawa Pacific\/Wake\n+Link Pacific\/Tarawa Pacific\/Wallis\n+\n@@ -517,0 +516,1 @@\n+# See Pacific\/Tarawa for most locations.\n@@ -518,8 +518,0 @@\n-Zone Pacific\/Majuro\t 11:24:48 -\tLMT\t1901\n-\t\t\t 11:00\t-\t+11\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 11:00\t-\t+11\t1937\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1944 Jan 30\n-\t\t\t 11:00\t-\t+11\t1969 Oct\n-\t\t\t 12:00\t-\t+12\n@@ -535,0 +527,2 @@\n+# For Chuuk and Yap see Pacific\/Port_Moresby.\n+# For Pohnpei see Pacific\/Guadalcanal.\n@@ -536,15 +530,0 @@\n-Zone Pacific\/Chuuk\t-13:52:52 -\tLMT\t1844 Dec 31\n-\t\t\t 10:07:08 -\tLMT\t1901\n-\t\t\t 10:00\t-\t+10\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1945 Aug\n-\t\t\t 10:00\t-\t+10\n-Zone Pacific\/Pohnpei\t-13:27:08 -\tLMT\t1844 Dec 31\t# Kolonia\n-\t\t\t 10:32:52 -\tLMT\t1901\n-\t\t\t 11:00\t-\t+11\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 11:00\t-\t+11\t1937\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1945 Aug\n-\t\t\t 11:00\t-\t+11\n@@ -620,0 +599,2 @@\n+Link Pacific\/Auckland Antarctica\/McMurdo\n+\n@@ -624,2 +605,0 @@\n-Link Pacific\/Auckland Antarctica\/McMurdo\n-\n@@ -684,1 +663,1 @@\n-# See Pacific\/Raratonga comments for 1952 transition.\n+# See Pacific\/Rarotonga comments for 1952 transition.\n@@ -720,0 +699,1 @@\n+Link Pacific\/Port_Moresby Pacific\/Chuuk\n@@ -847,0 +827,1 @@\n+Link Pacific\/Guadalcanal Pacific\/Pohnpei\n@@ -887,3 +868,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Pacific\/Funafuti\t11:56:52 -\tLMT\t1901\n-\t\t\t12:00\t-\t+12\n+# See Pacific\/Tarawa.\n@@ -948,3 +927,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tPacific\/Wake\t11:06:28 -\tLMT\t1901\n-\t\t\t12:00\t-\t+12\n+# See Pacific\/Tarawa.\n@@ -989,3 +966,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tPacific\/Wallis\t12:15:20 -\tLMT\t1901\n-\t\t\t12:00\t-\t+12\n+# See Pacific\/Tarawa.\n@@ -1309,0 +1284,1 @@\n+# [The article ends with \"Today's date is April 1.\"]\n@@ -1852,10 +1828,6 @@\n-# From Phake Nick (2018-10-27):\n-# <https:\/\/wiki.suikawiki.org\/n\/南洋群島の標準時> ... pointed out that\n-# currently tzdata say Pacific\/Kwajalein switched from GMT+11 to GMT-12 in\n-# 1969 October without explanation, however an 1993 article from NYT say it\n-# synchorized its day with US mainland about 40 years ago and thus the switch\n-# should occur at around 1950s instead.\n-#\n-# From Paul Eggert (2018-11-18):\n-# The NYT (actually, AP) article is vague and possibly wrong about this.\n-# The article says the earlier switch was \"40 years ago when the United States\n+# From Paul Eggert (2022-03-31):\n+# Phake Nick (2018-10-27) noted <https:\/\/wiki.suikawiki.org\/n\/南洋群島の標準時>'s\n+# citation of a 1993 AP article published in the New York Times saying\n+# Kwajalein synchronized its day with the US mainland about 40 years earlier.\n+# However the AP article is vague and possibly wrong about this.  The article\n+# says the earlier switch was \"about 40 years ago when the United States\n@@ -1908,7 +1880,0 @@\n-# Alan Eugene Davis writes (1996-03-16),\n-# \"I am certain, having lived there for the past decade, that 'Truk'\n-# (now properly known as Chuuk) ... is in the time zone GMT+10.\"\n-#\n-# Shanks & Pottenger write that Truk switched from UT +10 to +11\n-# on 1978-10-01; ignore this for now.\n-\n@@ -2245,1 +2210,1 @@\n-# In August government was disolved by the King.  The current prime minister\n+# In August government was dissolved by the King.  The current prime minister\n@@ -2253,20 +2218,0 @@\n-# Wake\n-\n-# From Vernice Anderson, Personal Secretary to Philip Jessup,\n-# US Ambassador At Large (oral history interview, 1971-02-02):\n-#\n-# Saturday, the 14th [of October, 1950] - ...  The time was all the\n-# more confusing at that point, because we had crossed the\n-# International Date Line, thus getting two Sundays.  Furthermore, we\n-# discovered that Wake Island had two hours of daylight saving time\n-# making calculation of time in Washington difficult if not almost\n-# impossible.\n-#\n-# https:\/\/www.trumanlibrary.org\/oralhist\/andrsonv.htm\n-\n-# From Paul Eggert (2003-03-23):\n-# We have no other report of DST in Wake Island, so omit this info for now.\n-\n-# See also the commentary for Micronesia.\n-\n-\n","filename":"jdk\/make\/data\/tzdata\/australasia","additions":26,"deletions":81,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-# Many names changed in late 1993.  Several of these names are\n+# Many names changed in late 1993, and many merged names moved here\n+# in the period from 2013 through 2022.  Several of these names are\n@@ -34,0 +35,4 @@\n+# Although this file is optional and tzdb will work if you omit it by\n+# building with 'make BACKWARD=', in practice downstream users\n+# typically use this file for backward compatibility.\n+\n@@ -74,1 +79,1 @@\n-Link\tEurope\/Oslo\t\tAtlantic\/Jan_Mayen\n+Link\tEurope\/Berlin\t\tAtlantic\/Jan_Mayen\n@@ -109,0 +114,1 @@\n+Link\tEurope\/Kyiv\t\tEurope\/Kiev\n@@ -117,1 +123,1 @@\n-Link\tAtlantic\/Reykjavik\tIceland\n+Link\tAfrica\/Abidjan\t\tIceland\n@@ -133,1 +139,1 @@\n-Link\tPacific\/Pohnpei\t\tPacific\/Ponape\n+Link\tPacific\/Guadalcanal\tPacific\/Ponape\n@@ -135,2 +141,2 @@\n-Link\tPacific\/Chuuk\t\tPacific\/Truk\n-Link\tPacific\/Chuuk\t\tPacific\/Yap\n+Link\tPacific\/Port_Moresby\tPacific\/Truk\n+Link\tPacific\/Port_Moresby\tPacific\/Yap\n","filename":"jdk\/make\/data\/tzdata\/backward","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+\n+# The following zone is used by tzcode functions like gmtime,\n+# which load the \"UTC\" file to handle seconds properly.\n@@ -47,2 +50,3 @@\n-# as functions like gmtime load the \"GMT\" file to handle leap seconds properly.\n-# We want this to work even on installations that omit the other older names.\n+# as it is needed for tzcode releases through 2022a,\n+# where functions like gmtime load \"GMT\" instead of the \"Etc\/UTC\".\n+# We want this to work even on installations that omit 'backward'.\n","filename":"jdk\/make\/data\/tzdata\/etcetera","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -329,2 +329,1 @@\n-# transition for now and just use the latter value, omitting its\n-# fraction since our format cannot represent fractions.\n+# transition for now and just use the latter value.\n@@ -526,1 +525,1 @@\n-Zone\tEurope\/London\t-0:01:15 -\tLMT\t1847 Dec  1  0:00s\n+Zone\tEurope\/London\t-0:01:15 -\tLMT\t1847 Dec  1\n@@ -564,1 +563,2 @@\n-Zone\tEurope\/Dublin\t-0:25:00 -\tLMT\t1880 Aug  2\n+\t\t#STDOFF\t-0:25:21.1\n+Zone\tEurope\/Dublin\t-0:25:21 -\tLMT\t1880 Aug  2\n@@ -987,0 +987,2 @@\n+Link Europe\/Brussels Europe\/Amsterdam\n+Link Europe\/Brussels Europe\/Luxembourg\n@@ -1049,1 +1051,1 @@\n-# Use Europe\/Prague also for Slovakia.\n+Link Europe\/Prague Europe\/Bratislava\n@@ -1051,1 +1053,0 @@\n-# Denmark, Faroe Islands, and Greenland\n@@ -1053,31 +1054,2 @@\n-# From Jesper Nørgaard Welen (2005-04-26):\n-# the law [introducing standard time] was in effect from 1894-01-01....\n-# The page https:\/\/www.retsinformation.dk\/eli\/lta\/1893\/83\n-# confirms this, and states that the law was put forth 1893-03-29.\n-#\n-# The EU [actually, EEC and Euratom] treaty with effect from 1973:\n-# https:\/\/www.retsinformation.dk\/eli\/lta\/1972\/21100\n-#\n-# This provoked a new law from 1974 to make possible summer time changes\n-# in subsequent decrees with the law\n-# https:\/\/www.retsinformation.dk\/eli\/lta\/1974\/223\n-#\n-# It seems however that no decree was set forward until 1980.  I have\n-# not found any decree, but in another related law, the effecting DST\n-# changes are stated explicitly to be from 1980-04-06 at 02:00 to\n-# 1980-09-28 at 02:00.  If this is true, this differs slightly from\n-# the EU rule in that DST runs to 02:00, not 03:00.  We don't know\n-# when Denmark began using the EU rule correctly, but we have only\n-# confirmation of the 1980-time, so I presume it was correct in 1981:\n-# The law is about the management of the extra hour, concerning\n-# working hours reported and effect on obligatory-rest rules (which\n-# was suspended on that night):\n-# https:\/\/web.archive.org\/web\/20140104053304\/https:\/\/www.retsinformation.dk\/Forms\/R0710.aspx?id=60267\n-\n-# From Jesper Nørgaard Welen (2005-06-11):\n-# The Herning Folkeblad (1980-09-26) reported that the night between\n-# Saturday and Sunday the clock is set back from three to two.\n-\n-# From Paul Eggert (2005-06-11):\n-# Hence the \"02:00\" of the 1980 law refers to standard time, not\n-# wall-clock time, and so the EU rules were in effect in 1980.\n+# Denmark, Faroe Islands, and Greenland\n+# For Denmark see Europe\/Berlin.\n@@ -1085,20 +1057,0 @@\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tDenmark\t1916\tonly\t-\tMay\t14\t23:00\t1:00\tS\n-Rule\tDenmark\t1916\tonly\t-\tSep\t30\t23:00\t0\t-\n-Rule\tDenmark\t1940\tonly\t-\tMay\t15\t 0:00\t1:00\tS\n-Rule\tDenmark\t1945\tonly\t-\tApr\t 2\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1945\tonly\t-\tAug\t15\t 2:00s\t0\t-\n-Rule\tDenmark\t1946\tonly\t-\tMay\t 1\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1946\tonly\t-\tSep\t 1\t 2:00s\t0\t-\n-Rule\tDenmark\t1947\tonly\t-\tMay\t 4\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1947\tonly\t-\tAug\t10\t 2:00s\t0\t-\n-Rule\tDenmark\t1948\tonly\t-\tMay\t 9\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1948\tonly\t-\tAug\t 8\t 2:00s\t0\t-\n-#\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Copenhagen\t 0:50:20 -\tLMT\t1890\n-\t\t\t 0:50:20 -\tCMT\t1894 Jan  1 # Copenhagen MT\n-\t\t\t 1:00\tDenmark\tCE%sT\t1942 Nov  2  2:00s\n-\t\t\t 1:00\tC-Eur\tCE%sT\t1945 Apr  2  2:00\n-\t\t\t 1:00\tDenmark\tCE%sT\t1980\n-\t\t\t 1:00\tEU\tCE%sT\n@@ -1324,2 +1276,1 @@\n-# Milne says Helsinki (Helsingfors) time was 1:39:49.2 (official document);\n-# round to nearest.\n+# Milne says Helsinki (Helsingfors) time was 1:39:49.2 (official document).\n@@ -1328,0 +1279,1 @@\n+\t\t#STDOFF\t1:39:49.2\n@@ -1474,0 +1426,1 @@\n+Link Europe\/Paris Europe\/Monaco\n@@ -1517,0 +1470,4 @@\n+Link Europe\/Berlin Arctic\/Longyearbyen\n+Link Europe\/Berlin Europe\/Copenhagen\n+Link Europe\/Berlin Europe\/Oslo\n+Link Europe\/Berlin Europe\/Stockholm\n@@ -1518,14 +1475,0 @@\n-# From Tobias Conradi (2011-09-12):\n-# Büsingen <http:\/\/www.buesingen.de>, surrounded by the Swiss canton\n-# Schaffhausen, did not start observing DST in 1980 as the rest of DE\n-# (West Germany at that time) and DD (East Germany at that time) did.\n-# DD merged into DE, the area is currently covered by code DE in ISO 3166-1,\n-# which in turn is covered by the zone Europe\/Berlin.\n-#\n-# Source for the time in Büsingen 1980:\n-# http:\/\/www.srf.ch\/player\/video?id=c012c029-03b7-4c2b-9164-aa5902cd58d3\n-\n-# From Arthur David Olson (2012-03-03):\n-# Büsingen and Zurich have shared clocks since 1970.\n-\n-Link\tEurope\/Zurich\tEurope\/Busingen\n@@ -1540,1 +1483,1 @@\n-Zone Europe\/Gibraltar\t-0:21:24 -\tLMT\t1880 Aug  2  0:00s\n+Zone Europe\/Gibraltar\t-0:21:24 -\tLMT\t1880 Aug  2\n@@ -1651,56 +1594,1 @@\n-#\n-# From Adam David (1993-11-06):\n-# The name of the timezone in Iceland for system \/ mail \/ news purposes is GMT.\n-#\n-# (1993-12-05):\n-# This material is paraphrased from the 1988 edition of the University of\n-# Iceland Almanak.\n-#\n-# From January 1st, 1908 the whole of Iceland was standardised at 1 hour\n-# behind GMT. Previously, local mean solar time was used in different parts\n-# of Iceland, the almanak had been based on Reykjavík mean solar time which\n-# was 1 hour and 28 minutes behind GMT.\n-#\n-# \"first day of winter\" referred to [below] means the first day of the 26 weeks\n-# of winter, according to the old icelandic calendar that dates back to the\n-# time the norsemen first settled Iceland.  The first day of winter is always\n-# Saturday, but is not dependent on the Julian or Gregorian calendars.\n-#\n-# (1993-12-10):\n-# I have a reference from the Oxford Icelandic-English dictionary for the\n-# beginning of winter, which ties it to the ecclesiastical calendar (and thus\n-# to the julian\/gregorian calendar) over the period in question.\n-#\tthe winter begins on the Saturday next before St. Luke's day\n-#\t(old style), or on St. Luke's day, if a Saturday.\n-# St. Luke's day ought to be traceable from ecclesiastical sources. \"old style\"\n-# might be a reference to the Julian calendar as opposed to Gregorian, or it\n-# might mean something else (???).\n-#\n-# From Paul Eggert (2014-11-22):\n-# The information below is taken from the 1988 Almanak; see\n-# http:\/\/www.almanak.hi.is\/klukkan.html\n-#\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tIceland\t1917\t1919\t-\tFeb\t19\t23:00\t1:00\t-\n-Rule\tIceland\t1917\tonly\t-\tOct\t21\t 1:00\t0\t-\n-Rule\tIceland\t1918\t1919\t-\tNov\t16\t 1:00\t0\t-\n-Rule\tIceland\t1921\tonly\t-\tMar\t19\t23:00\t1:00\t-\n-Rule\tIceland\t1921\tonly\t-\tJun\t23\t 1:00\t0\t-\n-Rule\tIceland\t1939\tonly\t-\tApr\t29\t23:00\t1:00\t-\n-Rule\tIceland\t1939\tonly\t-\tOct\t29\t 2:00\t0\t-\n-Rule\tIceland\t1940\tonly\t-\tFeb\t25\t 2:00\t1:00\t-\n-Rule\tIceland\t1940\t1941\t-\tNov\tSun>=2\t 1:00s\t0\t-\n-Rule\tIceland\t1941\t1942\t-\tMar\tSun>=2\t 1:00s\t1:00\t-\n-# 1943-1946 - first Sunday in March until first Sunday in winter\n-Rule\tIceland\t1943\t1946\t-\tMar\tSun>=1\t 1:00s\t1:00\t-\n-Rule\tIceland\t1942\t1948\t-\tOct\tSun>=22\t 1:00s\t0\t-\n-# 1947-1967 - first Sunday in April until first Sunday in winter\n-Rule\tIceland\t1947\t1967\t-\tApr\tSun>=1\t 1:00s\t1:00\t-\n-# 1949 and 1967 Oct transitions delayed by 1 week\n-Rule\tIceland\t1949\tonly\t-\tOct\t30\t 1:00s\t0\t-\n-Rule\tIceland\t1950\t1966\t-\tOct\tSun>=22\t 1:00s\t0\t-\n-Rule\tIceland\t1967\tonly\t-\tOct\t29\t 1:00s\t0\t-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Atlantic\/Reykjavik\t-1:28\t-\tLMT\t1908\n-\t\t\t-1:00\tIceland\t-01\/+00\t1968 Apr  7  1:00s\n-\t\t\t 0:00\t-\tGMT\n+# See Africa\/Abidjan.\n@@ -1822,1 +1710,1 @@\n-\t\t\t0:49:56\t-\tRMT\t1893 Oct 31 23:49:56 # Rome Mean\n+\t\t\t0:49:56\t-\tRMT\t1893 Oct 31 23:00u # Rome Mean\n@@ -1827,0 +1715,3 @@\n+Link Europe\/Rome Europe\/Vatican\n+Link Europe\/Rome Europe\/San_Marino\n+\n@@ -1832,3 +1723,0 @@\n-Link\tEurope\/Rome\tEurope\/Vatican\n-Link\tEurope\/Rome\tEurope\/San_Marino\n-\n@@ -1918,10 +1806,1 @@\n-\n-# From Paul Eggert (2013-09-09):\n-# Shanks & Pottenger say Vaduz is like Zurich.\n-\n-# From Alois Treindl (2019-07-04):\n-# I was able to access the online archive of the Vaduz paper Vaterland ...\n-# I could confirm from the paper that Liechtenstein did in fact follow\n-# the same DST in 1941 and 1942 as Switzerland did.\n-\n-Link Europe\/Zurich Europe\/Vaduz\n+# See Europe\/Zurich.\n@@ -1983,34 +1862,1 @@\n-# Whitman disagrees with most of these dates in minor ways;\n-# go with Shanks & Pottenger.\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tLux\t1916\tonly\t-\tMay\t14\t23:00\t1:00\tS\n-Rule\tLux\t1916\tonly\t-\tOct\t 1\t 1:00\t0\t-\n-Rule\tLux\t1917\tonly\t-\tApr\t28\t23:00\t1:00\tS\n-Rule\tLux\t1917\tonly\t-\tSep\t17\t 1:00\t0\t-\n-Rule\tLux\t1918\tonly\t-\tApr\tMon>=15\t 2:00s\t1:00\tS\n-Rule\tLux\t1918\tonly\t-\tSep\tMon>=15\t 2:00s\t0\t-\n-Rule\tLux\t1919\tonly\t-\tMar\t 1\t23:00\t1:00\tS\n-Rule\tLux\t1919\tonly\t-\tOct\t 5\t 3:00\t0\t-\n-Rule\tLux\t1920\tonly\t-\tFeb\t14\t23:00\t1:00\tS\n-Rule\tLux\t1920\tonly\t-\tOct\t24\t 2:00\t0\t-\n-Rule\tLux\t1921\tonly\t-\tMar\t14\t23:00\t1:00\tS\n-Rule\tLux\t1921\tonly\t-\tOct\t26\t 2:00\t0\t-\n-Rule\tLux\t1922\tonly\t-\tMar\t25\t23:00\t1:00\tS\n-Rule\tLux\t1922\tonly\t-\tOct\tSun>=2\t 1:00\t0\t-\n-Rule\tLux\t1923\tonly\t-\tApr\t21\t23:00\t1:00\tS\n-Rule\tLux\t1923\tonly\t-\tOct\tSun>=2\t 2:00\t0\t-\n-Rule\tLux\t1924\tonly\t-\tMar\t29\t23:00\t1:00\tS\n-Rule\tLux\t1924\t1928\t-\tOct\tSun>=2\t 1:00\t0\t-\n-Rule\tLux\t1925\tonly\t-\tApr\t 5\t23:00\t1:00\tS\n-Rule\tLux\t1926\tonly\t-\tApr\t17\t23:00\t1:00\tS\n-Rule\tLux\t1927\tonly\t-\tApr\t 9\t23:00\t1:00\tS\n-Rule\tLux\t1928\tonly\t-\tApr\t14\t23:00\t1:00\tS\n-Rule\tLux\t1929\tonly\t-\tApr\t20\t23:00\t1:00\tS\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Luxembourg\t0:24:36 -\tLMT\t1904 Jun\n-\t\t\t1:00\tLux\tCE%sT\t1918 Nov 25\n-\t\t\t0:00\tLux\tWE%sT\t1929 Oct  6  2:00s\n-\t\t\t0:00\tBelgium\tWE%sT\t1940 May 14  3:00\n-\t\t\t1:00\tC-Eur\tWE%sT\t1944 Sep 18  3:00\n-\t\t\t1:00\tBelgium\tCE%sT\t1977\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Brussels.\n@@ -2035,1 +1881,1 @@\n-Zone\tEurope\/Malta\t0:58:04 -\tLMT\t1893 Nov  2  0:00s # Valletta\n+Zone\tEurope\/Malta\t0:58:04 -\tLMT\t1893 Nov  2 # Valletta\n@@ -2117,21 +1963,1 @@\n-#\n-# From Michael Deckers (2020-06-12):\n-# In the \"Journal de Monaco\" of 1892-05-24, online at\n-# https:\/\/journaldemonaco.gouv.mc\/var\/jdm\/storage\/original\/application\/b1c67c12c5af11b41ea888fb048e4fe8.pdf\n-# we read: ...\n-#  [In virtue of a Sovereign Ordinance of the May 13 of the current [year],\n-#   legal time in the Principality will be set to, from the date of June 1,\n-#   1892 onwards, to the meridian of Paris, as in France.]\n-# In the \"Journal de Monaco\" of 1911-03-28, online at\n-# https:\/\/journaldemonaco.gouv.mc\/var\/jdm\/storage\/original\/application\/de74ffb7db53d4f599059fe8f0ed482a.pdf\n-# we read an ordinance of 1911-03-16: ...\n-#  [Legal time in the Principality will be set, from the date of promulgation\n-#   of the present ordinance, to legal time in France....  Consequently, legal\n-#   time will be retarded by 9 minutes and 21 seconds.]\n-#\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tEurope\/Monaco\t0:29:32 -\tLMT\t1892 Jun  1\n-\t\t\t0:09:21\t-\tPMT\t1911 Mar 29 # Paris Mean Time\n-\t\t\t0:00\tFrance\tWE%sT\t1945 Sep 16  3:00\n-\t\t\t1:00\tFrance\tCE%sT\t1977\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Paris.\n@@ -2143,76 +1969,1 @@\n-\n-# Howse writes that the Netherlands' railways used GMT between 1892 and 1940,\n-# but for other purposes the Netherlands used Amsterdam mean time.\n-\n-# However, Robert H. van Gent writes (2001-04-01):\n-# Howse's statement is only correct up to 1909. From 1909-05-01 (00:00:00\n-# Amsterdam mean time) onwards, the whole of the Netherlands (including\n-# the Dutch railways) was required by law to observe Amsterdam mean time\n-# (19 minutes 32.13 seconds ahead of GMT). This had already been the\n-# common practice (except for the railways) for many decades but it was\n-# not until 1909 when the Dutch government finally defined this by law.\n-# On 1937-07-01 this was changed to 20 minutes (exactly) ahead of GMT and\n-# was generally known as Dutch Time (\"Nederlandse Tijd\").\n-#\n-# (2001-04-08):\n-# 1892-05-01 was the date when the Dutch railways were by law required to\n-# observe GMT while the remainder of the Netherlands adhered to the common\n-# practice of following Amsterdam mean time.\n-#\n-# (2001-04-09):\n-# In 1835 the authorities of the province of North Holland requested the\n-# municipal authorities of the towns and cities in the province to observe\n-# Amsterdam mean time but I do not know in how many cases this request was\n-# actually followed.\n-#\n-# From 1852 onwards the Dutch telegraph offices were by law required to\n-# observe Amsterdam mean time. As the time signals from the observatory of\n-# Leiden were also distributed by the telegraph system, I assume that most\n-# places linked up with the telegraph (and railway) system automatically\n-# adopted Amsterdam mean time.\n-#\n-# Although the early Dutch railway companies initially observed a variety\n-# of times, most of them had adopted Amsterdam mean time by 1858 but it\n-# was not until 1866 when they were all required by law to observe\n-# Amsterdam mean time.\n-\n-# The data entries before 1945 are taken from\n-# https:\/\/www.staff.science.uu.nl\/~gent0113\/wettijd\/wettijd.htm\n-\n-# From Paul Eggert (2021-05-09):\n-# I invented the abbreviations AMT for Amsterdam Mean Time and NST for\n-# Netherlands Summer Time, used in the Netherlands from 1835 to 1937.\n-\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tNeth\t1916\tonly\t-\tMay\t 1\t0:00\t1:00\tNST\t# Netherlands Summer Time\n-Rule\tNeth\t1916\tonly\t-\tOct\t 1\t0:00\t0\tAMT\t# Amsterdam Mean Time\n-Rule\tNeth\t1917\tonly\t-\tApr\t16\t2:00s\t1:00\tNST\n-Rule\tNeth\t1917\tonly\t-\tSep\t17\t2:00s\t0\tAMT\n-Rule\tNeth\t1918\t1921\t-\tApr\tMon>=1\t2:00s\t1:00\tNST\n-Rule\tNeth\t1918\t1921\t-\tSep\tlastMon\t2:00s\t0\tAMT\n-Rule\tNeth\t1922\tonly\t-\tMar\tlastSun\t2:00s\t1:00\tNST\n-Rule\tNeth\t1922\t1936\t-\tOct\tSun>=2\t2:00s\t0\tAMT\n-Rule\tNeth\t1923\tonly\t-\tJun\tFri>=1\t2:00s\t1:00\tNST\n-Rule\tNeth\t1924\tonly\t-\tMar\tlastSun\t2:00s\t1:00\tNST\n-Rule\tNeth\t1925\tonly\t-\tJun\tFri>=1\t2:00s\t1:00\tNST\n-# From 1926 through 1939 DST began 05-15, except that it was delayed by a week\n-# in years when 05-15 fell in the Pentecost weekend.\n-Rule\tNeth\t1926\t1931\t-\tMay\t15\t2:00s\t1:00\tNST\n-Rule\tNeth\t1932\tonly\t-\tMay\t22\t2:00s\t1:00\tNST\n-Rule\tNeth\t1933\t1936\t-\tMay\t15\t2:00s\t1:00\tNST\n-Rule\tNeth\t1937\tonly\t-\tMay\t22\t2:00s\t1:00\tNST\n-Rule\tNeth\t1937\tonly\t-\tJul\t 1\t0:00\t1:00\tS\n-Rule\tNeth\t1937\t1939\t-\tOct\tSun>=2\t2:00s\t0\t-\n-Rule\tNeth\t1938\t1939\t-\tMay\t15\t2:00s\t1:00\tS\n-Rule\tNeth\t1945\tonly\t-\tApr\t 2\t2:00s\t1:00\tS\n-Rule\tNeth\t1945\tonly\t-\tSep\t16\t2:00s\t0\t-\n-#\n-# Amsterdam Mean Time was +00:19:32.13, but the .13 is omitted\n-# below because the current format requires STDOFF to be an integer.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Amsterdam\t0:19:32 -\tLMT\t1835\n-\t\t\t0:19:32\tNeth\t%s\t1937 Jul  1\n-\t\t\t0:20\tNeth +0020\/+0120 1940 May 16  0:00\n-\t\t\t1:00\tC-Eur\tCE%sT\t1945 Apr  2  2:00\n-\t\t\t1:00\tNeth\tCE%sT\t1977\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Brussels.\n@@ -2221,16 +1972,1 @@\n-# http:\/\/met.no\/met\/met_lex\/q_u\/sommertid.html (2004-01) agrees with Shanks &\n-# Pottenger.\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tNorway\t1916\tonly\t-\tMay\t22\t1:00\t1:00\tS\n-Rule\tNorway\t1916\tonly\t-\tSep\t30\t0:00\t0\t-\n-Rule\tNorway\t1945\tonly\t-\tApr\t 2\t2:00s\t1:00\tS\n-Rule\tNorway\t1945\tonly\t-\tOct\t 1\t2:00s\t0\t-\n-Rule\tNorway\t1959\t1964\t-\tMar\tSun>=15\t2:00s\t1:00\tS\n-Rule\tNorway\t1959\t1965\t-\tSep\tSun>=15\t2:00s\t0\t-\n-Rule\tNorway\t1965\tonly\t-\tApr\t25\t2:00s\t1:00\tS\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tEurope\/Oslo\t0:43:00 -\tLMT\t1895 Jan  1\n-\t\t\t1:00\tNorway\tCE%sT\t1940 Aug 10 23:00\n-\t\t\t1:00\tC-Eur\tCE%sT\t1945 Apr  2  2:00\n-\t\t\t1:00\tNorway\tCE%sT\t1980\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Berlin.\n@@ -2283,1 +2019,1 @@\n-# All these events predate our cutoff date of 1970, so use Europe\/Oslo\n+# All these events predate our cutoff date of 1970, so use Europe\/Berlin\n@@ -2285,1 +2021,1 @@\n-Link\tEurope\/Oslo\tArctic\/Longyearbyen\n+\n@@ -2339,1 +2075,0 @@\n-# Round the old offset to -0:36:45.  This agrees with Willett....\n@@ -2426,0 +2161,1 @@\n+\t\t#STDOFF\t-0:36:44.68\n@@ -2434,1 +2170,0 @@\n-# This Zone can be simplified once we assume zic %z.\n@@ -2437,0 +2172,5 @@\n+# Vanguard section, for zic and other parsers that support %z.\n+#\t\t\t-2:00\tPort\t%z\t1966 Apr  3  2:00\n+#\t\t\t-1:00\tPort\t%z\t1983 Sep 25  1:00s\n+#\t\t\t-1:00\tW-Eur\t%z\t1992 Sep 27  1:00s\n+# Rearguard section, for parsers lacking %z; see ziguard.awk.\n@@ -2448,0 +2188,1 @@\n+# End of rearguard section.\n@@ -2450,1 +2191,0 @@\n-# This Zone can be simplified once we assume zic %z.\n@@ -2453,0 +2193,3 @@\n+# Vanguard section, for zic and other parsers that support %z.\n+#\t\t\t-1:00\tPort\t%z\t1966 Apr  3  2:00\n+# Rearguard section, for parsers lacking %z; see ziguard.awk.\n@@ -2462,0 +2205,1 @@\n+# End of rearguard section.\n@@ -2880,3 +2624,3 @@\n-# From Paul Eggert (2006-03-22):\n-# The _Economist_ (1994-05-28, p 45) reports that central Crimea switched\n-# from Kiev to Moscow time sometime after the January 1994 elections.\n+# From Paul Eggert (2022-07-21):\n+# The _Economist_ (1994-05-28, p 45) reported that central Crimea switched\n+# from Kyiv to Moscow time sometime after the January 1994 elections.\n@@ -2886,1 +2630,1 @@\n-# changed in May.\n+# changed in May.  This change evidently didn't last long; see below.\n@@ -2888,2 +2632,2 @@\n-# From IATA SSIM (1994\/1997), which also says that Kerch is still like Kiev.\n-\t\t\t 3:00\tE-Eur\tMSK\/MSD\t1996 Mar 31  0:00s\n+# From IATA SSIM (1994\/1997), which also said that Kerch is still like Kyiv.\n+\t\t\t 3:00\tC-Eur\tMSK\/MSD\t1996 Mar 31  0:00s\n@@ -2891,1 +2635,1 @@\n-# IATA SSIM (1997-09) says Crimea switched to EET\/EEST.\n+# IATA SSIM (1997-09) said Crimea switched to EET\/EEST.\n@@ -2893,1 +2637,0 @@\n-\t\t\t 3:00\tRussia\tMSK\/MSD\t1997\n@@ -3062,1 +2805,1 @@\n-# Milne says Yekaterinburg was 4:02:32.9; round to nearest.\n+# Milne says Yekaterinburg was 4:02:32.9.\n@@ -3067,0 +2810,1 @@\n+\t\t#STDOFF\t 4:02:32.9\n@@ -3378,2 +3122,2 @@\n-# From Arthur David Olson (2012-05-09):\n-# Tomponskij and Ust'-Majskij switched from Vladivostok time to Yakutsk time\n+# From Arthur David Olson (2022-03-21):\n+# Tomponsky and Ust-Maysky switched from Vladivostok time to Yakutsk time\n@@ -3504,2 +3248,2 @@\n-# From Arthur David Olson (2012-05-09):\n-# Ojmyakonskij [and the Kuril Islands] switched from\n+# From Arthur David Olson (2022-03-21):\n+# Oymyakonsky and the Kuril Islands switched from\n@@ -3579,1 +3323,1 @@\n-Link Europe\/Prague Europe\/Bratislava\n+# See Europe\/Prague.\n@@ -3668,1 +3412,1 @@\n-Zone\tEurope\/Madrid\t-0:14:44 -\tLMT\t1900 Dec 31 23:45:16\n+Zone\tEurope\/Madrid\t-0:14:44 -\tLMT\t1901 Jan  1  0:00u\n@@ -3690,55 +3434,1 @@\n-\n-# From Ivan Nilsson (2001-04-13), superseding Shanks & Pottenger:\n-#\n-# The law \"Svensk författningssamling 1878, no 14\" about standard time in 1879:\n-# From the beginning of 1879 (that is 01-01 00:00) the time for all\n-# places in the country is \"the mean solar time for the meridian at\n-# three degrees, or twelve minutes of time, to the west of the\n-# meridian of the Observatory of Stockholm\".  The law is dated 1878-05-31.\n-#\n-# The observatory at that time had the meridian 18° 03' 30\"\n-# eastern longitude = 01:12:14 in time.  Less 12 minutes gives the\n-# national standard time as 01:00:14 ahead of GMT....\n-#\n-# About the beginning of CET in Sweden. The lawtext (\"Svensk\n-# författningssamling 1899, no 44\") states, that \"from the beginning\n-# of 1900... ... the same as the mean solar time for the meridian at\n-# the distance of one hour of time from the meridian of the English\n-# observatory at Greenwich, or at 12 minutes 14 seconds to the west\n-# from the meridian of the Observatory of Stockholm\". The law is dated\n-# 1899-06-16.  In short: At 1900-01-01 00:00:00 the new standard time\n-# in Sweden is 01:00:00 ahead of GMT.\n-#\n-# 1916: The lawtext (\"Svensk författningssamling 1916, no 124\") states\n-# that \"1916-05-15 is considered to begin one hour earlier\". It is\n-# pretty obvious that at 05-14 23:00 the clocks are set to 05-15 00:00....\n-# Further the law says, that \"1916-09-30 is considered to end one hour later\".\n-#\n-# The laws regulating [DST] are available on the site of the Swedish\n-# Parliament beginning with 1985 - the laws regulating 1980\/1984 are\n-# not available on the site (to my knowledge they are only available\n-# in Swedish): <http:\/\/www.riksdagen.se\/english\/work\/sfst.asp> (type\n-# \"sommartid\" without the quotes in the field \"Fritext\" and then click\n-# the Sök-button).\n-#\n-# (2001-05-13):\n-#\n-# I have now found a newspaper stating that at 1916-10-01 01:00\n-# summertime the church-clocks etc were set back one hour to show\n-# 1916-10-01 00:00 standard time.  The article also reports that some\n-# people thought the switch to standard time would take place already\n-# at 1916-10-01 00:00 summer time, but they had to wait for another\n-# hour before the event took place.\n-#\n-# Source: The newspaper \"Dagens Nyheter\", 1916-10-01, page 7 upper left.\n-\n-# An extra-special abbreviation style is SET for Swedish Time (svensk\n-# normaltid) 1879-1899, 3° west of the Stockholm Observatory.\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Stockholm\t1:12:12 -\tLMT\t1879 Jan  1\n-\t\t\t1:00:14\t-\tSET\t1900 Jan  1 # Swedish Time\n-\t\t\t1:00\t-\tCET\t1916 May 14 23:00\n-\t\t\t1:00\t1:00\tCEST\t1916 Oct  1  1:00\n-\t\t\t1:00\t-\tCET\t1980\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Berlin.\n@@ -3838,0 +3528,13 @@\n+# From Tobias Conradi (2011-09-12):\n+# Büsingen <http:\/\/www.buesingen.de>, surrounded by the Swiss canton\n+# Schaffhausen, did not start observing DST in 1980 as the rest of DE\n+# (West Germany at that time) and DD (East Germany at that time) did.\n+# DD merged into DE, the area is currently covered by code DE in ISO 3166-1,\n+# which in turn is covered by the zone Europe\/Berlin.\n+#\n+# Source for the time in Büsingen 1980:\n+# http:\/\/www.srf.ch\/player\/video?id=c012c029-03b7-4c2b-9164-aa5902cd58d3\n+#\n+# From Arthur David Olson (2012-03-03):\n+# Büsingen and Zurich have shared clocks since 1970.\n+\n@@ -3846,0 +3549,3 @@\n+Link Europe\/Zurich Europe\/Busingen\n+Link Europe\/Zurich Europe\/Vaduz\n+\n@@ -4054,1 +3760,1 @@\n-# From Alois Triendl (2014-03-01):\n+# From Alois Treindl (2014-03-01):\n@@ -4114,1 +3820,1 @@\n-# From Vladimir in Moscow via Alois Treindl re Kiev time 1991\/2 (2014-02-28):\n+# From Vladimir in Moscow via Alois Treindl re Kyiv time 1991\/2 (2014-02-28):\n@@ -4142,1 +3848,1 @@\n-# From Paul Eggert (2018-10-03):\n+# From Paul Eggert (2022-04-12):\n@@ -4144,10 +3850,10 @@\n-# For example, tzdb uses Europe\/Kiev, as \"Kiev\" is the most common spelling in\n-# English for Ukraine's capital, even though it is certainly wrong as a\n-# transliteration of the Ukrainian \"Київ\".  This is similar to tzdb's use of\n-# Europe\/Prague, which is certainly wrong as a transliteration of the Czech\n-# \"Praha\".  (\"Kiev\" came from old Slavic via Russian to English, and \"Prague\"\n-# came from old Slavic via French to English, so the two cases have something\n-# in common.)  Admittedly English-language spelling of Ukrainian names is\n-# controversial, and some day \"Kyiv\" may become substantially more popular in\n-# English; in the meantime, stick with the traditional English \"Kiev\" as that\n-# means less disruption for our users.\n+# In particular, tzdb's name Europe\/Kyiv uses the most common spelling in\n+# English for Ukraine's capital.  Although tzdb's former name was Europe\/Kiev,\n+# \"Kyiv\" is now more common due to widespread reporting of the current conflict.\n+# Conversely, tzdb continues to use the names Europe\/Uzhgorod and\n+# Europe\/Zaporozhye; this is similar to tzdb's use of Europe\/Prague, which is\n+# certainly wrong as a transliteration of the Czech \"Praha\".\n+# English-language spelling of Ukrainian names is in flux, and\n+# some day \"Uzhhorod\" or \"Zaporizhzhia\" may become substantially more\n+# common in English; in the meantime, do not change these\n+# English spellings as that means less disruption for our users.\n@@ -4156,3 +3862,3 @@\n-# This represents most of Ukraine.  See above for the spelling of \"Kiev\".\n-Zone Europe\/Kiev\t2:02:04 -\tLMT\t1880\n-\t\t\t2:02:04\t-\tKMT\t1924 May  2 # Kiev Mean Time\n+# This represents most of Ukraine.  See above for the spelling of \"Kyiv\".\n+Zone Europe\/Kyiv\t2:02:04 -\tLMT\t1880\n+\t\t\t2:02:04\t-\tKMT\t1924 May  2 # Kyiv Mean Time\n@@ -4181,1 +3887,1 @@\n-# \"Zaporizhia\" is the transliteration of the Ukrainian name, but\n+# \"Zaporizhzhia\" is the transliteration of the Ukrainian name, but\n","filename":"jdk\/make\/data\/tzdata\/europe","additions":90,"deletions":384,"binary":false,"changes":474,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-#Expires 2022\tDec\t28\t00:00:00\n+#Expires 2023\tJun\t28\t00:00:00\n@@ -102,1 +102,1 @@\n-#expires 1672185600 (2022-12-28 00:00:00 UTC)\n+#expires 1687910400 (2023-06-28 00:00:00 UTC)\n@@ -104,2 +104,2 @@\n-#\tUpdated through IERS Bulletin C63\n-#\tFile expires on:  28 December 2022\n+#\tUpdated through IERS Bulletin C64\n+#\tFile expires on:  28 June 2023\n","filename":"jdk\/make\/data\/tzdata\/leapseconds","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -370,2 +370,1 @@\n-# Eastern time (i.e., -4:56:01.6) just before the 1883 switch.  Round to the\n-# nearest second.\n+# Eastern time (i.e., -4:56:01.6) just before the 1883 switch.\n@@ -380,1 +379,2 @@\n-Zone America\/New_York\t-4:56:02 -\tLMT\t1883 Nov 18 12:03:58\n+\t\t#STDOFF\t-4:56:01.6\n+Zone America\/New_York\t-4:56:02 -\tLMT\t1883 Nov 18 17:00u\n@@ -2844,1 +2844,1 @@\n-# For 1899 Milne gives -3:58:29.2; round that.\n+# For 1899 Milne gives -3:58:29.2.\n@@ -2888,0 +2888,1 @@\n+\t\t#STDOFF\t-3:58:29.2\n@@ -2948,1 +2949,1 @@\n-# From Paul Eggert (2020-11-24):\n+# From Paul Eggert (2022-07-27):\n@@ -2951,1 +2952,1 @@\n-# Daylight Saving Act, 1917 cited below.  Round that to the nearest second.\n+# Daylight Saving Act, 1917 cited below.\n@@ -3046,0 +3047,1 @@\n+\t\t#STDOFF\t-4:19:18.3\n@@ -3060,1 +3062,1 @@\n-# Milne gives -5:36:13.3 as San José mean time; round to nearest.\n+# Milne gives -5:36:13.3 as San José mean time.\n@@ -3072,0 +3074,1 @@\n+\t\t#STDOFF\t-5:36:13.3\n@@ -3494,1 +3497,1 @@\n-# island\".  Go with Milne.  Round to the nearest second as required by zic.\n+# island\".  Go with Milne.\n@@ -3507,0 +3510,1 @@\n+\t\t#STDOFF\t-5:07:10.41\n@@ -3704,0 +3708,1 @@\n+\t\t#STDOFF\t-5:07:10.41\n","filename":"jdk\/make\/data\/tzdata\/northamerica","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -443,0 +444,1 @@\n+\t\t#STDOFF\t       -4:16:48.25\n@@ -455,0 +457,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -467,0 +470,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -480,0 +484,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -494,0 +499,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -508,0 +514,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -523,0 +530,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -537,0 +545,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -559,0 +568,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -577,0 +587,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -589,0 +600,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -671,1 +683,1 @@\n-# modern Brazilian eletronic voting machines which, apparently, can't deal\n+# modern Brazilian ... voting machines which, apparently, can't deal\n@@ -1167,1 +1179,1 @@\n-# From Tim Parenti (2022-03-15):\n+# From Tim Parenti (2022-07-06):\n@@ -1185,1 +1197,8 @@\n-# seconds\".\n+# seconds\".  Although this law specified the new Summer Time to start on 1\n+# September each year, a special \"transitional article\" started it a few days\n+# early, as soon as the law took effect.  As the law was to take force \"from\n+# the date of its publication in the 'Diario Oficial', which happened the\n+# following day, presume the change took place in Santiago and its environs\n+# from 24:00 -03 to 23:00 -04 on Wednesday 1946-08-28.  Although this was a\n+# no-op for wall clocks in the north and south of the country, put their formal\n+# start to DST an hour later when they reached 24:00 -04.\n@@ -1305,5 +1324,13 @@\n-# From Paul Eggert (2019-09-01):\n-# The above says the Magallanes exception expires 2022-04-02 at 24:00,\n-# so in theory, they will revert to -04\/-03 after that.\n-# For now, assume that they will not revert,\n-# since they have extended the expiration date once already.\n+\n+# From Juan Correa (2022-04-02):\n+# I found there was a decree published last Thursday that will keep\n+# Magallanes region to UTC -3 \"indefinitely\". The decree is available at\n+# https:\/\/www.diariooficial.interior.gob.cl\/publicaciones\/2022\/03\/31\/43217-B\/01\/2108910.pdf\n+\n+# From Juan Correa (2022-08-09):\n+# the Internal Affairs Ministry (Ministerio del Interior) informed DST\n+# for America\/Santiago will start on midnight of September 11th;\n+# and will end on April 1st, 2023. Magallanes region (America\/Punta_Arenas)\n+# will keep UTC -3 \"indefinitely\"...  This is because on September 4th\n+# we will have a voting whether to approve a new Constitution....\n+# https:\/\/www.interior.gob.cl\/noticias\/2022\/08\/09\/comunicado-el-proximo-sabado-10-de-septiembre-los-relojes-se-deben-adelantar-una-hora\/\n@@ -1347,1 +1374,3 @@\n-Rule\tChile\t2019\tmax\t-\tSep\tSun>=2\t4:00u\t1:00\t-\n+Rule\tChile\t2019\t2021\t-\tSep\tSun>=2\t4:00u\t1:00\t-\n+Rule\tChile\t2022\tonly\t-\tSep\tSun>=9\t4:00u\t1:00\t-\n+Rule\tChile\t2023\tmax\t-\tSep\tSun>=2\t4:00u\t1:00\t-\n@@ -1360,3 +1389,3 @@\n-\t\t\t-4:00\t-\t-04\t1946 Jul 15\n-\t\t\t-4:00\t1:00\t-03\t1946 Sep  1 # central Chile\n-\t\t\t-4:00\t-\t-04\t1947 Apr  1\n+\t\t\t-4:00\t-\t-04\t1946 Jul 14 24:00\n+\t\t\t-4:00\t1:00\t-03\t1946 Aug 28 24:00 # central CL\n+\t\t\t-5:00\t1:00\t-04\t1947 Mar 31 24:00\n@@ -1374,1 +1403,2 @@\n-\t\t\t-4:00\t-\t-04\t1947 Apr  1\n+\t\t\t-4:00\t-\t-04\t1946 Aug 28 24:00\n+\t\t\t-5:00\t1:00\t-04\t1947 Mar 31 24:00\n@@ -1408,1 +1438,1 @@\n-# Milne gives 4:56:16.4 for Bogotá time in 1899; round to nearest.  He writes,\n+# Milne gives 4:56:16.4 for Bogotá time in 1899.  He writes,\n@@ -1415,0 +1445,1 @@\n+\t\t#STDOFF\t-4:56:16.4\n","filename":"jdk\/make\/data\/tzdata\/southamerica","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-CA\t+5946-12014\tAmerica\/Dawson_Creek\tMST - BC (Dawson Cr, Ft St John)\n+CA\t+5546-12014\tAmerica\/Dawson_Creek\tMST - BC (Dawson Cr, Ft St John)\n@@ -426,1 +426,1 @@\n-UA\t+5026+03031\tEurope\/Kiev\tUkraine (most areas)\n+UA\t+5026+03031\tEurope\/Kyiv\tUkraine (most areas)\n","filename":"jdk\/make\/data\/tzdata\/zone.tab","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-  # Linux-only symbol Java_jdk_internal_platform_cgroupv1_Metrics_isUseContainerSupport\n+  # Linux-only symbol Java_jdk_internal_platform_CgroupMetrics_isUseContainerSupport\n","filename":"jdk\/make\/lib\/CoreLibraries.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -281,1 +281,1 @@\n-\t\tJava_jdk_internal_platform_cgroupv1_Metrics_isUseContainerSupport;\n+\t\tJava_jdk_internal_platform_CgroupMetrics_isUseContainerSupport;\n","filename":"jdk\/make\/mapfiles\/libjava\/mapfile-linux","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Data structure to hold info from \/proc\/self\/cgroup\n+ *\n+ * man 7 cgroups\n+ *\n+ * @see CgroupSubsystemFactory\n+ *\/\n+class CgroupInfo {\n+\n+    private final String name;\n+    private final int hierarchyId;\n+    private final boolean enabled;\n+\n+    private CgroupInfo(String name, int hierarchyId, boolean enabled) {\n+        this.name = name;\n+        this.hierarchyId = hierarchyId;\n+        this.enabled = enabled;\n+    }\n+\n+    String getName() {\n+        return name;\n+    }\n+\n+    int getHierarchyId() {\n+        return hierarchyId;\n+    }\n+\n+    boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    static CgroupInfo fromCgroupsLine(String line) {\n+        String[] tokens = line.split(\"\\\\s+\");\n+        if (tokens.length != 4) {\n+            return null;\n+        }\n+        \/\/ discard 3'rd field, num_cgroups\n+        return new CgroupInfo(tokens[0] \/* name *\/,\n+                              Integer.parseInt(tokens[1]) \/* hierarchyId *\/,\n+                              (Integer.parseInt(tokens[3]) == 1) \/* enabled *\/);\n+    }\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupInfo.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.util.Objects;\n+\n+public class CgroupMetrics implements Metrics {\n+\n+    private final CgroupSubsystem subsystem;\n+\n+    CgroupMetrics(CgroupSubsystem subsystem) {\n+        this.subsystem = Objects.requireNonNull(subsystem);\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return subsystem.getProvider();\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        return subsystem.getCpuUsage();\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return subsystem.getPerCpuUsage();\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        return subsystem.getCpuUserUsage();\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        return subsystem.getCpuSystemUsage();\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return subsystem.getCpuPeriod();\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return subsystem.getCpuQuota();\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        return subsystem.getCpuShares();\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return subsystem.getCpuNumPeriods();\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return subsystem.getCpuNumThrottled();\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        return subsystem.getCpuThrottledTime();\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return subsystem.getEffectiveCpuCount();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        return subsystem.getCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        return subsystem.getEffectiveCpuSetCpus();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        return subsystem.getCpuSetMems();\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        return subsystem.getEffectiveCpuSetMems();\n+    }\n+\n+    public long getMemoryFailCount() {\n+        return subsystem.getMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        return subsystem.getMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return subsystem.getMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return subsystem.getTcpMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        return subsystem.getMemoryAndSwapLimit();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return subsystem.getMemoryAndSwapUsage();\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        return subsystem.getMemorySoftLimit();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return subsystem.getBlkIOServiceCount();\n+    }\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return subsystem.getBlkIOServiced();\n+    }\n+\n+    public static Metrics getInstance() {\n+        if (!isUseContainerSupport()) {\n+            \/\/ Return null on -XX:-UseContainerSupport\n+            return null;\n+        }\n+        return CgroupSubsystemFactory.create();\n+    }\n+\n+    private static native boolean isUseContainerSupport();\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Marker interface for cgroup-based metrics\n+ *\n+ *\/\n+public interface CgroupSubsystem extends Metrics {\n+\n+    \/**\n+     * Returned for metrics of type long if the underlying implementation\n+     * has determined that no limit is being imposed.\n+     *\/\n+    public static final long LONG_RETVAL_UNLIMITED = -1;\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,255 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.math.BigInteger;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Cgroup version agnostic controller logic\n+ *\n+ *\/\n+public interface CgroupSubsystemController {\n+\n+    public static final String EMPTY_STR = \"\";\n+\n+    public String path();\n+\n+    \/**\n+     * getStringValue\n+     *\n+     * Return the first line of the file \"param\" argument from the controller.\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @return Returns the contents of the file specified by param or null if\n+     *         an error occurs.\n+     *\/\n+    public static String getStringValue(CgroupSubsystemController controller, String param) {\n+        if (controller == null) return null;\n+\n+        try {\n+            return CgroupUtil.readStringValue(controller, param);\n+        }\n+        catch (IOException e) {\n+            return null;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Get an entry from file \"param\" within the \"controller\" directory path\n+     * which matches string \"match\". Applies \"conversion\" to the matching line.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param match\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The long value as derived by applying \"conversion\" to the matching\n+     *         line or \"defaultRetval\" if there was an error or no match found.\n+     *\/\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                     String param,\n+                                                     String match,\n+                                                     Function<String, Long> conversion,\n+                                                     long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (controller == null) {\n+            return retval;\n+        }\n+        try {\n+            Path filePath = Paths.get(controller.path(), param);\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(filePath);\n+            for (String line : lines) {\n+                if (line.startsWith(match)) {\n+                    retval = conversion.apply(line);\n+                    break;\n+                }\n+            }\n+        } catch (IOException e) {\n+            \/\/ Ignore. Default is unlimited.\n+        }\n+        return retval;\n+    }\n+\n+    \/**\n+     * Get a long value from directory \"controller\" and file \"param\", by\n+     * applying \"conversion\" to the string value within the file.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param conversion\n+     * @param defaultRetval\n+     * @return The converted long value or \"defaultRetval\" if there was an\n+     *         error.\n+     *\/\n+    public static long getLongValue(CgroupSubsystemController controller,\n+                                    String param,\n+                                    Function<String, Long> conversion,\n+                                    long defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+        if (strval == null) return defaultRetval;\n+        return conversion.apply(strval);\n+    }\n+\n+    \/**\n+     * Get a double value from file \"param\" within \"controller\".\n+     *\n+     * @param controller\n+     * @param param\n+     * @param defaultRetval\n+     * @return The double value or \"defaultRetval\" if there was an error.\n+     *\/\n+    public static double getDoubleValue(CgroupSubsystemController controller, String param, double defaultRetval) {\n+        String strval = getStringValue(controller, param);\n+\n+        if (strval == null) return defaultRetval;\n+\n+        double retval = Double.parseDouble(strval);\n+\n+        return retval;\n+    }\n+\n+    \/**\n+     * getLongEntry\n+     *\n+     * Return the long value from the line containing the string \"entryname\"\n+     * within file \"param\" in the \"controller\".\n+     *\n+     * TODO:  Consider using weak references for caching BufferedReader object.\n+     *\n+     * @param controller\n+     * @param param\n+     * @param entryname\n+     * @return long value or \"defaultRetval\" if there was an error or no match\n+     *         was found.\n+     *\/\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname, long defaultRetval) {\n+        if (controller == null) return defaultRetval;\n+\n+        try (Stream<String> lines = CgroupUtil.readFilePrivileged(Paths.get(controller.path(), param))) {\n+\n+            Optional<String> result = lines.map(line -> line.split(\" \"))\n+                                           .filter(line -> (line.length == 2 &&\n+                                                   line[0].equals(entryname)))\n+                                           .map(line -> line[1])\n+                                           .findFirst();\n+\n+            return result.isPresent() ? Long.parseLong(result.get()) : defaultRetval;\n+        } catch (UncheckedIOException e) {\n+            return defaultRetval;\n+        } catch (IOException e) {\n+            return defaultRetval;\n+        }\n+    }\n+\n+    \/**\n+     * stringRangeToIntArray\n+     *\n+     * Convert a string in the form of  1,3-4,6 to an array of\n+     * integers containing all the numbers in the range.\n+     *\n+     * @param range\n+     * @return int[] containing a sorted list of numbers as represented by\n+     *         the string range. Returns null if there was an error or the input\n+     *         was an empty string.\n+     *\/\n+    public static int[] stringRangeToIntArray(String range) {\n+        if (range == null || EMPTY_STR.equals(range)) return null;\n+\n+        ArrayList<Integer> results = new ArrayList<>();\n+        String strs[] = range.split(\",\");\n+        for (String str : strs) {\n+            if (str.contains(\"-\")) {\n+                String lohi[] = str.split(\"-\");\n+                \/\/ validate format\n+                if (lohi.length != 2) {\n+                    continue;\n+                }\n+                int lo = Integer.parseInt(lohi[0]);\n+                int hi = Integer.parseInt(lohi[1]);\n+                for (int i = lo; i <= hi; i++) {\n+                    results.add(i);\n+                }\n+            }\n+            else {\n+                results.add(Integer.parseInt(str));\n+            }\n+        }\n+\n+        \/\/ sort results\n+        results.sort(null);\n+\n+        \/\/ convert ArrayList to primitive int array\n+        int[] ints = new int[results.size()];\n+        int i = 0;\n+        for (Integer n : results) {\n+            ints[i++] = n;\n+        }\n+\n+        return ints;\n+    }\n+\n+    \/**\n+     * Convert a number from its string representation to a long.\n+     *\n+     * @param strval\n+     * @param overflowRetval\n+     * @param defaultRetval\n+     * @return The converted long value. \"overflowRetval\" is returned if the\n+     *         string representation exceeds the range of type long.\n+     *         \"defaultRetval\" is returned if another type of error occurred\n+     *         during conversion.\n+     *\/\n+    public static long convertStringToLong(String strval, long overflowRetval, long defaultRetval) {\n+        long retval = defaultRetval;\n+        if (strval == null) return retval;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes, cgroups v1) we may overflow\n+            \/\/ the range of signed long. In this case, return overflowRetval\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemController.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.IOException;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.cgroupv1.CgroupV1Subsystem;\n+import jdk.internal.platform.cgroupv2.CgroupV2Subsystem;\n+\n+public class CgroupSubsystemFactory {\n+\n+    private static final String CPU_CTRL = \"cpu\";\n+    private static final String CPUACCT_CTRL = \"cpuacct\";\n+    private static final String CPUSET_CTRL = \"cpuset\";\n+    private static final String BLKIO_CTRL = \"blkio\";\n+    private static final String MEMORY_CTRL = \"memory\";\n+\n+    static CgroupMetrics create() {\n+        Optional<CgroupTypeResult> optResult = null;\n+        try {\n+            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\");\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        if (optResult.equals(Optional.empty())) {\n+            return null;\n+        }\n+        CgroupTypeResult result = optResult.get();\n+\n+        \/\/ If no controller is enabled, return no metrics.\n+        if (!result.isAnyControllersEnabled()) {\n+            return null;\n+        }\n+        \/\/ The code is not ready to deal with mixed cgroups v1 and cgroups v2\n+        \/\/ controllers on a per-controller basis. Return no metrics in that\n+        \/\/ case\n+        if (result.isAnyCgroupV1Controllers() && result.isAnyCgroupV2Controllers()) {\n+            return null;\n+        }\n+\n+        if (result.isCgroupV2()) {\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance();\n+            return subsystem != null ? new CgroupMetrics(subsystem) : null;\n+        } else {\n+            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance();\n+            return subsystem != null ? new CgroupV1MetricsImpl(subsystem) : null;\n+        }\n+    }\n+\n+    public static Optional<CgroupTypeResult> determineType(String mountInfo, String cgroups) throws IOException {\n+        Map<String, CgroupInfo> infos = new HashMap<>();\n+        List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(cgroups));\n+        for (String line : lines) {\n+            if (line.startsWith(\"#\")) {\n+                continue;\n+            }\n+            CgroupInfo info = CgroupInfo.fromCgroupsLine(line);\n+            switch (info.getName()) {\n+            case CPU_CTRL:      infos.put(CPU_CTRL, info); break;\n+            case CPUACCT_CTRL:  infos.put(CPUACCT_CTRL, info); break;\n+            case CPUSET_CTRL:   infos.put(CPUSET_CTRL, info); break;\n+            case MEMORY_CTRL:   infos.put(MEMORY_CTRL, info); break;\n+            case BLKIO_CTRL:    infos.put(BLKIO_CTRL, info); break;\n+            }\n+        }\n+\n+        \/\/ For cgroups v2 all controllers need to have zero hierarchy id\n+        \/\/ and \/proc\/self\/mountinfo needs to have at least one cgroup filesystem\n+        \/\/ mounted. Note that hybrid hierarchy has controllers mounted via\n+        \/\/ cgroup v1. In that case hierarchy id's will be non-zero.\n+        boolean isCgroupsV2 = true;\n+        boolean anyControllersEnabled = false;\n+        boolean anyCgroupsV2Controller = false;\n+        boolean anyCgroupsV1Controller = false;\n+        for (CgroupInfo info: infos.values()) {\n+            anyCgroupsV1Controller = anyCgroupsV1Controller || info.getHierarchyId() != 0;\n+            anyCgroupsV2Controller = anyCgroupsV2Controller || info.getHierarchyId() == 0;\n+            isCgroupsV2 = isCgroupsV2 && info.getHierarchyId() == 0;\n+            anyControllersEnabled = anyControllersEnabled || info.isEnabled();\n+        }\n+\n+        \/\/ If there are no mounted controllers in mountinfo, but we've only\n+        \/\/ seen 0 hierarchy IDs in \/proc\/cgroups, we are on a cgroups v1 system.\n+        \/\/ However, continuing in that case does not make sense as we'd need\n+        \/\/ information from mountinfo for the mounted controller paths anyway.\n+        try (Stream<String> mntInfo = CgroupUtil.readFilePrivileged(Paths.get(mountInfo))) {\n+            boolean anyCgroupMounted = mntInfo.anyMatch(line -> line.contains(\"cgroup\"));\n+            if (!anyCgroupMounted && isCgroupsV2) {\n+                return Optional.empty();\n+            }\n+        }\n+        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2, anyControllersEnabled, anyCgroupsV2Controller, anyCgroupsV1Controller);\n+        return Optional.of(result);\n+    }\n+\n+    public static final class CgroupTypeResult {\n+        private final boolean isCgroupV2;\n+        private final boolean anyControllersEnabled;\n+        private final boolean anyCgroupV2Controllers;\n+        private final boolean anyCgroupV1Controllers;\n+\n+        private CgroupTypeResult(boolean isCgroupV2,\n+                                 boolean anyControllersEnabled,\n+                                 boolean anyCgroupV2Controllers,\n+                                 boolean anyCgroupV1Controllers) {\n+            this.isCgroupV2 = isCgroupV2;\n+            this.anyControllersEnabled = anyControllersEnabled;\n+            this.anyCgroupV1Controllers = anyCgroupV1Controllers;\n+            this.anyCgroupV2Controllers = anyCgroupV2Controllers;\n+        }\n+\n+        public boolean isCgroupV2() {\n+            return isCgroupV2;\n+        }\n+\n+        public boolean isAnyControllersEnabled() {\n+            return anyControllersEnabled;\n+        }\n+\n+        public boolean isAnyCgroupV2Controllers() {\n+            return anyCgroupV2Controllers;\n+        }\n+\n+        public boolean isAnyCgroupV1Controllers() {\n+            return anyCgroupV1Controllers;\n+        }\n+    }\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.AccessController;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public final class CgroupUtil {\n+\n+    public static Stream<String> readFilePrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n+        Throwable x = pae.getCause();\n+        if (x instanceof IOException)\n+            throw (IOException) x;\n+        if (x instanceof RuntimeException)\n+            throw (RuntimeException) x;\n+        if (x instanceof Error)\n+            throw (Error) x;\n+    }\n+\n+    static String readStringValue(CgroupSubsystemController controller, String param) throws IOException {\n+        PrivilegedExceptionAction<BufferedReader> pea = () ->\n+                Files.newBufferedReader(Paths.get(controller.path(), param));\n+        try (BufferedReader bufferedReader =\n+                     AccessController.doPrivileged(pea)) {\n+            String line = bufferedReader.readLine();\n+            return line;\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+\n+    public static List<String> readAllLinesPrivileged(Path path) throws IOException {\n+        try {\n+            PrivilegedExceptionAction<List<String>> pea = () -> Files.readAllLines(path);\n+            return AccessController.doPrivileged(pea);\n+        } catch (PrivilegedActionException e) {\n+            unwrapIOExceptionAndRethrow(e);\n+            throw new InternalError(e.getCause());\n+        } catch (UncheckedIOException e) {\n+            throw e.getCause();\n+        }\n+    }\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupUtil.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ *\n+ * Cgroup v1 extensions to the Metrics interface. Linux, only.\n+ *\n+ *\/\n+public interface CgroupV1Metrics extends Metrics {\n+\n+    \/**\n+     * Returns the largest amount of physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available. Returns -2 if this metric is not\n+     *         supported.\n+     *\n+     *\/\n+    public long getMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that kernel memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of kernel physical memory, in bytes, that\n+     * can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set.\n+     *\n+     *\/\n+    public long getKernelMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of kernel physical memory, in bytes, that\n+     * have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the amount of kernel physical memory, in bytes, that\n+     * is currently allocated in the current Isolation Group.\n+     *\n+     * @return The amount of memory in bytes allocated or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getKernelMemoryUsage();\n+\n+    \/**\n+     * Returns the number of times that networking memory requests in the\n+     * Isolation Group have exceeded the kernel memory limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryFailCount();\n+\n+    \/**\n+     * Returns the maximum amount of networking physical memory, in bytes,\n+     * that can be allocated in the Isolation Group.\n+     *\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit.\n+     *\n+     *\/\n+    public long getTcpMemoryLimit();\n+\n+    \/**\n+     * Returns the largest amount of networking physical memory, in bytes,\n+     * that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getTcpMemoryMaxUsage();\n+\n+    \/**\n+     * Returns the number of times that user memory requests in the\n+     * Isolation Group have exceeded the memory + swap limit.\n+     *\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapFailCount();\n+\n+    \/**\n+     * Returns the largest amount of physical memory and swap space,\n+     * in bytes, that have been allocated in the Isolation Group.\n+     *\n+     * @return The largest amount of memory in bytes or -1 if this\n+     *         metric is not available.\n+     *\n+     *\/\n+    public long getMemoryAndSwapMaxUsage();\n+\n+    \/**\n+     * Returns the state of the Operating System Out of Memory termination\n+     * policy.\n+     *\n+     * @return Returns true if operating system will terminate processes\n+     *         in the Isolation Group that exceed the amount of available\n+     *         memory, otherwise false. null will be returned if this\n+     *         capability is not available on the current operating system.\n+     *\n+     *\/\n+    public Boolean isMemoryOOMKillEnabled();\n+\n+    \/**\n+     * Returns the (attempts per second * 1000), if enabled, that the\n+     * operating system tries to satisfy a memory request for any\n+     * process in the current Isolation Group when no free memory is\n+     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n+     * determine if this support is enabled.\n+     *\n+     * @return Memory pressure or 0 if not enabled or -1 if metric is not\n+     *         available.\n+     *\n+     *\/\n+    public double getCpuSetMemoryPressure();\n+\n+    \/**\n+     * Returns the state of the memory pressure detection support.\n+     *\n+     * @return true if support is available and enabled. false otherwise.\n+     *\n+     *\/\n+    public Boolean isCpuSetMemoryPressureEnabled();\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupV1Metrics.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform;\n+\n+\/**\n+ * Cgroup v1 Metrics extensions\n+ *\n+ *\/\n+public class CgroupV1MetricsImpl extends CgroupMetrics implements CgroupV1Metrics {\n+\n+    private final CgroupV1Metrics metrics;\n+\n+    CgroupV1MetricsImpl(CgroupV1Metrics metrics) {\n+        super((CgroupSubsystem)metrics);\n+        this.metrics = metrics;\n+    }\n+\n+    @Override\n+    public long getMemoryMaxUsage() {\n+        return metrics.getMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryFailCount() {\n+        return metrics.getKernelMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryLimit() {\n+        return metrics.getKernelMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryMaxUsage() {\n+        return metrics.getKernelMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getKernelMemoryUsage() {\n+        return metrics.getKernelMemoryUsage();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryFailCount() {\n+        return metrics.getTcpMemoryFailCount();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryLimit() {\n+        return metrics.getTcpMemoryLimit();\n+    }\n+\n+    @Override\n+    public long getTcpMemoryMaxUsage() {\n+        return metrics.getTcpMemoryMaxUsage();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapFailCount() {\n+        return metrics.getMemoryAndSwapFailCount();\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapMaxUsage() {\n+        return metrics.getMemoryAndSwapMaxUsage();\n+    }\n+\n+    @Override\n+    public Boolean isMemoryOOMKillEnabled() {\n+        return metrics.isMemoryOOMKillEnabled();\n+    }\n+\n+    @Override\n+    public double getCpuSetMemoryPressure() {\n+        return metrics.getCpuSetMemoryPressure();\n+    }\n+\n+    @Override\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        return metrics.isCpuSetMemoryPressureEnabled();\n+    }\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/CgroupV1MetricsImpl.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+public class CgroupV1MemorySubSystemController extends CgroupV1SubsystemController {\n+\n+    private boolean hierarchical;\n+    private boolean swapenabled;\n+\n+    public CgroupV1MemorySubSystemController(String root, String mountPoint) {\n+        super(root, mountPoint);\n+    }\n+\n+    boolean isHierarchical() {\n+        return hierarchical;\n+    }\n+\n+    void setHierarchical(boolean hierarchical) {\n+        this.hierarchical = hierarchical;\n+    }\n+\n+    boolean isSwapEnabled() {\n+        return swapenabled;\n+    }\n+\n+    void setSwapEnabled(boolean swapenabled) {\n+        this.swapenabled = swapenabled;\n+    }\n+}\n\\ No newline at end of file\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1MemorySubSystemController.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,511 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupUtil;\n+import jdk.internal.platform.CgroupV1Metrics;\n+\n+public class CgroupV1Subsystem implements CgroupSubsystem, CgroupV1Metrics {\n+    private CgroupV1MemorySubSystemController memory;\n+    private CgroupV1SubsystemController cpu;\n+    private CgroupV1SubsystemController cpuacct;\n+    private CgroupV1SubsystemController cpuset;\n+    private CgroupV1SubsystemController blkio;\n+    private boolean activeSubSystems;\n+\n+    private static final CgroupV1Subsystem INSTANCE = initSubSystem();\n+\n+    private static final String PROVIDER_NAME = \"cgroupv1\";\n+\n+    private CgroupV1Subsystem() {\n+        activeSubSystems = false;\n+    }\n+\n+    public static CgroupV1Subsystem getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    private static CgroupV1Subsystem initSubSystem() {\n+        CgroupV1Subsystem subsystem = new CgroupV1Subsystem();\n+\n+        \/**\n+         * Find the cgroup mount points for subsystems\n+         * by reading \/proc\/self\/mountinfo\n+         *\n+         * Example for docker MemorySubSystem subsystem:\n+         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n+         *\n+         * Example for host:\n+         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n+         *\/\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            lines.filter(line -> line.contains(\" - cgroup \"))\n+                 .map(line -> line.split(\" \"))\n+                 .forEach(entry -> createSubSystemController(subsystem, entry));\n+\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/**\n+         * Read \/proc\/self\/cgroup and map host mount point to\n+         * local one via \/proc\/self\/mountinfo content above\n+         *\n+         * Docker example:\n+         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+         *\n+         * Host example:\n+         * 5:memory:\/user.slice\n+         *\n+         * Construct a path to the process specific memory and cpuset\n+         * cgroup directory.\n+         *\n+         * For a container running under Docker from memory example above\n+         * the paths would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\n+         *\n+         * For a Host from memory example above the path would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\/user.slice\n+         *\n+         *\/\n+        try (Stream<String> lines =\n+            CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n+\n+            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n+            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n+            \/\/ contain a ':'.\n+            lines.map(line -> line.split(\":\", 3))\n+                 .filter(line -> (line.length >= 3))\n+                 .forEach(line -> setSubSystemControllerPath(subsystem, line));\n+\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/\/ Return Metrics object if we found any subsystems.\n+        if (subsystem.activeSubSystems()) {\n+            return subsystem;\n+        }\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * createSubSystem objects and initialize mount points\n+     *\/\n+    private static void createSubSystemController(CgroupV1Subsystem subsystem, String[] mountentry) {\n+        if (mountentry.length < 5) return;\n+\n+        Path p = Paths.get(mountentry[4]);\n+        String[] subsystemNames = p.getFileName().toString().split(\",\");\n+\n+        for (String subsystemName: subsystemNames) {\n+            switch (subsystemName) {\n+                case \"memory\":\n+                    subsystem.setMemorySubSystem(new CgroupV1MemorySubSystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuset\":\n+                    subsystem.setCpuSetController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuacct\":\n+                    subsystem.setCpuAcctController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpu\":\n+                    subsystem.setCpuController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"blkio\":\n+                    subsystem.setBlkIOController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                default:\n+                    \/\/ Ignore subsystems that we don't support\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n+     *\/\n+    private static void setSubSystemControllerPath(CgroupV1Subsystem subsystem, String[] entry) {\n+        String controller = entry[1];\n+        String base = entry[2];\n+        if (controller != null && base != null) {\n+            for (String cName: controller.split(\",\")) {\n+                switch (cName) {\n+                    case \"memory\":\n+                        setPath(subsystem, subsystem.memoryController(), base);\n+                        break;\n+                    case \"cpuset\":\n+                        setPath(subsystem, subsystem.cpuSetController(), base);\n+                        break;\n+                    case \"cpuacct\":\n+                        setPath(subsystem, subsystem.cpuController(), base);\n+                        break;\n+                    case \"cpu\":\n+                        setPath(subsystem, subsystem.cpuAcctController(), base);\n+                        break;\n+                    case \"blkio\":\n+                        setPath(subsystem, subsystem.blkIOController(), base);\n+                        break;\n+                    \/\/ Ignore subsystems that we don't support\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void setPath(CgroupV1Subsystem subsystem, CgroupV1SubsystemController controller, String base) {\n+        if (controller != null) {\n+            controller.setPath(base);\n+            if (controller instanceof CgroupV1MemorySubSystemController) {\n+                CgroupV1MemorySubSystemController memorySubSystem = (CgroupV1MemorySubSystemController)controller;\n+                boolean isHierarchial = getHierarchical(memorySubSystem);\n+                memorySubSystem.setHierarchical(isHierarchial);\n+                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n+                memorySubSystem.setSwapEnabled(isSwapEnabled);\n+            }\n+            subsystem.setActiveSubSystems();\n+        }\n+    }\n+\n+\n+    private static boolean getSwapEnabled(CgroupV1MemorySubSystemController controller) {\n+         long retval = getLongValue(controller, \"memory.memsw.limit_in_bytes\");\n+         return retval > 0;\n+     }\n+\n+\n+    private static boolean getHierarchical(CgroupV1MemorySubSystemController controller) {\n+        long hierarchical = getLongValue(controller, \"memory.use_hierarchy\");\n+        return hierarchical > 0;\n+    }\n+\n+    private void setActiveSubSystems() {\n+        activeSubSystems = true;\n+    }\n+\n+    private boolean activeSubSystems() {\n+        return activeSubSystems;\n+    }\n+\n+    private void setMemorySubSystem(CgroupV1MemorySubSystemController memory) {\n+        this.memory = memory;\n+    }\n+\n+    private void setCpuController(CgroupV1SubsystemController cpu) {\n+        this.cpu = cpu;\n+    }\n+\n+    private void setCpuAcctController(CgroupV1SubsystemController cpuacct) {\n+        this.cpuacct = cpuacct;\n+    }\n+\n+    private void setCpuSetController(CgroupV1SubsystemController cpuset) {\n+        this.cpuset = cpuset;\n+    }\n+\n+    private void setBlkIOController(CgroupV1SubsystemController blkio) {\n+        this.blkio = blkio;\n+    }\n+\n+    private CgroupV1SubsystemController memoryController() {\n+        return memory;\n+    }\n+\n+    private CgroupV1SubsystemController cpuController() {\n+        return cpu;\n+    }\n+\n+    private CgroupV1SubsystemController cpuAcctController() {\n+        return cpuacct;\n+    }\n+\n+    private CgroupV1SubsystemController cpuSetController() {\n+        return cpuset;\n+    }\n+\n+    private CgroupV1SubsystemController blkIOController() {\n+        return blkio;\n+    }\n+\n+    private static long getLongValue(CgroupSubsystemController controller,\n+                              String parm) {\n+        return CgroupSubsystemController.getLongValue(controller,\n+                                                      parm,\n+                                                      CgroupV1SubsystemController::convertStringToLong,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    \/*****************************************************************\n+     * CPU Accounting Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuUsage() {\n+        return getLongValue(cpuacct, \"cpuacct.usage\");\n+    }\n+\n+    public long[] getPerCpuUsage() {\n+        String usagelist = CgroupSubsystemController.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n+        if (usagelist == null) {\n+            return null;\n+        }\n+\n+        String list[] = usagelist.split(\" \");\n+        long percpu[] = new long[list.length];\n+        for (int i = 0; i < list.length; i++) {\n+            percpu[i] = Long.parseLong(list[i]);\n+        }\n+        return percpu;\n+    }\n+\n+    public long getCpuUserUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n+    }\n+\n+    public long getCpuSystemUsage() {\n+        return CgroupV1SubsystemController.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPU Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getCpuPeriod() {\n+        return getLongValue(cpuacct, \"cpu.cfs_period_us\");\n+    }\n+\n+    public long getCpuQuota() {\n+        return getLongValue(cpuacct, \"cpu.cfs_quota_us\");\n+    }\n+\n+    public long getCpuShares() {\n+        long retval = getLongValue(cpuacct, \"cpu.shares\");\n+        if (retval == 0 || retval == 1024)\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        else\n+            return retval;\n+    }\n+\n+    public long getCpuNumPeriods() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    public long getCpuNumThrottled() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    public long getCpuThrottledTime() {\n+        return CgroupV1SubsystemController.getLongEntry(cpu, \"cpu.stat\", \"throttled_time\");\n+    }\n+\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+\n+    \/*****************************************************************\n+     * CPUSet Subsystem\n+     ****************************************************************\/\n+\n+    public int[] getCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.cpus\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetCpus() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n+    }\n+\n+    public int[] getCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.mems\"));\n+    }\n+\n+    public int[] getEffectiveCpuSetMems() {\n+        return CgroupSubsystemController.stringRangeToIntArray(CgroupSubsystemController.getStringValue(cpuset, \"cpuset.effective_mems\"));\n+    }\n+\n+    public double getCpuSetMemoryPressure() {\n+        return CgroupV1SubsystemController.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n+    }\n+\n+    public Boolean isCpuSetMemoryPressureEnabled() {\n+        long val = getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n+        return (val == 1);\n+    }\n+\n+\n+    \/*****************************************************************\n+     * Memory Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getMemoryFailCount() {\n+        return getLongValue(memory, \"memory.failcnt\");\n+    }\n+\n+    public long getMemoryLimit() {\n+        long retval = getLongValue(memory, \"memory.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memory_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryUsage() {\n+        return getLongValue(memory, \"memory.usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.failcnt\");\n+    }\n+\n+    public long getKernelMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.limit_in_bytes\"));\n+    }\n+\n+    public long getKernelMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n+    }\n+\n+    public long getKernelMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryFailCount() {\n+        return getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n+    }\n+\n+    public long getTcpMemoryLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\"));\n+    }\n+\n+    public long getTcpMemoryMaxUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n+    }\n+\n+    public long getTcpMemoryUsage() {\n+        return getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapFailCount() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryFailCount();\n+        }\n+        return getLongValue(memory, \"memory.memsw.failcnt\");\n+    }\n+\n+    public long getMemoryAndSwapLimit() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryLimit();\n+        }\n+        long retval = getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n+        if (retval > CgroupV1SubsystemController.UNLIMITED_MIN) {\n+            if (memory.isHierarchical()) {\n+                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n+                \/\/ hierarchical memory limit\n+                String match = \"hierarchical_memsw_limit\";\n+                retval = CgroupV1SubsystemController.getLongValueMatchingLine(memory,\n+                                                            \"memory.stat\",\n+                                                            match);\n+            }\n+        }\n+        return CgroupV1SubsystemController.longValOrUnlimited(retval);\n+    }\n+\n+    public long getMemoryAndSwapMaxUsage() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryMaxUsage();\n+        }\n+        return getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n+    }\n+\n+    public long getMemoryAndSwapUsage() {\n+        if (memory != null && !memory.isSwapEnabled()) {\n+            return getMemoryUsage();\n+        }\n+        return getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n+    }\n+\n+    public Boolean isMemoryOOMKillEnabled() {\n+        long val = CgroupV1SubsystemController.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n+        return (val == 0);\n+    }\n+\n+    public long getMemorySoftLimit() {\n+        return CgroupV1SubsystemController.longValOrUnlimited(getLongValue(memory, \"memory.soft_limit_in_bytes\"));\n+    }\n+\n+\n+    \/*****************************************************************\n+     * BlKIO Subsystem\n+     ****************************************************************\/\n+\n+\n+    public long getBlkIOServiceCount() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n+    }\n+\n+    public long getBlkIOServiced() {\n+        return CgroupV1SubsystemController.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n+    }\n+\n+    private static native boolean isUseContainerSupport();\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":511,"deletions":0,"binary":false,"changes":511,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv1;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV1SubsystemController implements CgroupSubsystemController {\n+\n+    private static final double DOUBLE_RETVAL_UNLIMITED = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+    \/\/ Values returned larger than this number are unlimited.\n+    static long UNLIMITED_MIN = 0x7FFFFFFFFF000000L;\n+    String root;\n+    String mountPoint;\n+    String path;\n+\n+    public CgroupV1SubsystemController(String root, String mountPoint) {\n+        this.root = root;\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public void setPath(String cgroupPath) {\n+        if (root != null && cgroupPath != null) {\n+            if (root.equals(\"\/\")) {\n+                if (!cgroupPath.equals(\"\/\")) {\n+                    path = mountPoint + cgroupPath;\n+                }\n+                else {\n+                    path = mountPoint;\n+                }\n+            }\n+            else {\n+                if (root.equals(cgroupPath)) {\n+                    path = mountPoint;\n+                }\n+                else {\n+                    if (cgroupPath.startsWith(root)) {\n+                        if (cgroupPath.length() > root.length()) {\n+                            String cgroupSubstr = cgroupPath.substring(root.length());\n+                            path = mountPoint + cgroupSubstr;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static double getDoubleValue(CgroupSubsystemController controller, String parm) {\n+        return CgroupSubsystemController.getDoubleValue(controller,\n+                                                        parm,\n+                                                        DOUBLE_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             Long.MAX_VALUE \/* overflow value *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+\n+    public static long longValOrUnlimited(long value) {\n+        return value > UNLIMITED_MIN ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : value;\n+    }\n+\n+    public static long getLongValueMatchingLine(CgroupSubsystemController controller,\n+                                                String param,\n+                                                String match) {\n+        return CgroupSubsystemController.getLongValueMatchingLine(controller,\n+                                                                  param,\n+                                                                  match,\n+                                                                  CgroupV1SubsystemController::convertHierachicalLimitLine,\n+                                                                  CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    public static long convertHierachicalLimitLine(String line) {\n+        String[] tokens = line.split(\"\\\\s\");\n+        if (tokens.length == 2) {\n+            String strVal = tokens[1];\n+            return CgroupV1SubsystemController.convertStringToLong(strVal);\n+        }\n+        return CgroupV1SubsystemController.UNLIMITED_MIN + 1; \/\/ unlimited\n+    }\n+\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1SubsystemController.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -1,545 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.stream.Stream;\n-\n-import jdk.internal.platform.cgroupv1.SubSystem.MemorySubSystem;\n-\n-public class Metrics implements jdk.internal.platform.Metrics {\n-    private MemorySubSystem memory;\n-    private SubSystem cpu;\n-    private SubSystem cpuacct;\n-    private SubSystem cpuset;\n-    private SubSystem blkio;\n-    private boolean activeSubSystems;\n-\n-    \/\/ Values returned larger than this number are unlimited.\n-    static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-\n-    private static final Metrics INSTANCE = initContainerSubSystems();\n-\n-    private static final String PROVIDER_NAME = \"cgroupv1\";\n-\n-    private Metrics() {\n-        activeSubSystems = false;\n-    }\n-\n-    public static Metrics getInstance() {\n-        return INSTANCE;\n-    }\n-\n-    private static Metrics initContainerSubSystems() {\n-        if (!isUseContainerSupport()) {\n-            return null;\n-        }\n-        Metrics metrics = new Metrics();\n-\n-        \/**\n-         * Find the cgroup mount points for subsystems\n-         * by reading \/proc\/self\/mountinfo\n-         *\n-         * Example for docker MemorySubSystem subsystem:\n-         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n-         *\n-         * Example for host:\n-         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            lines.filter(line -> line.contains(\" - cgroup \"))\n-                 .map(line -> line.split(\" \"))\n-                 .forEach(entry -> createSubSystem(metrics, entry));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/**\n-         * Read \/proc\/self\/cgroup and map host mount point to\n-         * local one via \/proc\/self\/mountinfo content above\n-         *\n-         * Docker example:\n-         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-         *\n-         * Host example:\n-         * 5:memory:\/user.slice\n-         *\n-         * Construct a path to the process specific memory and cpuset\n-         * cgroup directory.\n-         *\n-         * For a container running under Docker from memory example above\n-         * the paths would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\n-         *\n-         * For a Host from memory example above the path would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\/user.slice\n-         *\n-         *\/\n-        try (Stream<String> lines =\n-             readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n-\n-            \/\/ The limit value of 3 is because \/proc\/self\/cgroup contains three\n-            \/\/ colon-separated tokens per line. The last token, cgroup path, might\n-            \/\/ contain a ':'.\n-            lines.map(line -> line.split(\":\", 3))\n-                 .filter(line -> (line.length >= 3))\n-                 .forEach(line -> setSubSystemPath(metrics, line));\n-\n-        } catch (IOException e) {\n-            return null;\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        }\n-\n-        \/\/ Return Metrics object if we found any subsystems.\n-        if (metrics.activeSubSystems()) {\n-            return metrics;\n-        }\n-\n-        return null;\n-    }\n-\n-    static Stream<String> readFilePrivileged(Path path) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<Stream<String>> pea = () -> Files.lines(path);\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    static void unwrapIOExceptionAndRethrow(PrivilegedActionException pae) throws IOException {\n-        Throwable x = pae.getCause();\n-        if (x instanceof IOException)\n-            throw (IOException) x;\n-        if (x instanceof RuntimeException)\n-            throw (RuntimeException) x;\n-        if (x instanceof Error)\n-            throw (Error) x;\n-    }\n-    \/**\n-     * createSubSystem objects and initialize mount points\n-     *\/\n-    private static void createSubSystem(Metrics metric, String[] mountentry) {\n-        if (mountentry.length < 5) return;\n-\n-        Path p = Paths.get(mountentry[4]);\n-        String[] subsystemNames = p.getFileName().toString().split(\",\");\n-\n-        for (String subsystemName: subsystemNames) {\n-            switch (subsystemName) {\n-                case \"memory\":\n-                    metric.setMemorySubSystem(new MemorySubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuset\":\n-                    metric.setCpuSetSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuacct\":\n-                    metric.setCpuAcctSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpu\":\n-                    metric.setCpuSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"blkio\":\n-                    metric.setBlkIOSubSystem(new SubSystem(mountentry[3], mountentry[4]));\n-                    break;\n-                default:\n-                    \/\/ Ignore subsystems that we don't support\n-                    break;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n-     *\/\n-    private static void setSubSystemPath(Metrics metric, String[] entry) {\n-        String controller = entry[1];\n-        String base = entry[2];\n-        if (controller != null && base != null) {\n-            for (String cName: controller.split(\",\")) {\n-                switch (cName) {\n-                    case \"memory\":\n-                        setPath(metric, metric.MemorySubSystem(), base);\n-                        break;\n-                    case \"cpuset\":\n-                        setPath(metric, metric.CpuSetSubSystem(), base);\n-                        break;\n-                    case \"cpuacct\":\n-                        setPath(metric, metric.CpuAcctSubSystem(), base);\n-                        break;\n-                    case \"cpu\":\n-                        setPath(metric, metric.CpuSubSystem(), base);\n-                        break;\n-                    case \"blkio\":\n-                        setPath(metric, metric.BlkIOSubSystem(), base);\n-                        break;\n-                    \/\/ Ignore subsystems that we don't support\n-                    default:\n-                        break;\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void setPath(Metrics metric, SubSystem subsystem, String base) {\n-        if (subsystem != null) {\n-            subsystem.setPath(base);\n-            if (subsystem instanceof MemorySubSystem) {\n-                MemorySubSystem memorySubSystem = (MemorySubSystem)subsystem;\n-                boolean isHierarchial = getHierarchical(memorySubSystem);\n-                memorySubSystem.setHierarchical(isHierarchial);\n-                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n-                memorySubSystem.setSwapEnabled(isSwapEnabled);\n-            }\n-            metric.setActiveSubSystems();\n-        }\n-    }\n-\n-\n-    private static boolean getHierarchical(MemorySubSystem subsystem) {\n-        long hierarchical = SubSystem.getLongValue(subsystem, \"memory.use_hierarchy\");\n-        return hierarchical > 0;\n-    }\n-\n-    private static boolean getSwapEnabled(MemorySubSystem subsystem) {\n-        long retval = SubSystem.getLongValue(subsystem, \"memory.memsw.limit_in_bytes\");\n-        return retval > 0;\n-    }\n-\n-    private void setActiveSubSystems() {\n-        activeSubSystems = true;\n-    }\n-\n-    private boolean activeSubSystems() {\n-        return activeSubSystems;\n-    }\n-\n-    private void setMemorySubSystem(MemorySubSystem memory) {\n-        this.memory = memory;\n-    }\n-\n-    private void setCpuSubSystem(SubSystem cpu) {\n-        this.cpu = cpu;\n-    }\n-\n-    private void setCpuAcctSubSystem(SubSystem cpuacct) {\n-        this.cpuacct = cpuacct;\n-    }\n-\n-    private void setCpuSetSubSystem(SubSystem cpuset) {\n-        this.cpuset = cpuset;\n-    }\n-\n-    private void setBlkIOSubSystem(SubSystem blkio) {\n-        this.blkio = blkio;\n-    }\n-\n-    private SubSystem MemorySubSystem() {\n-        return memory;\n-    }\n-\n-    private SubSystem CpuSubSystem() {\n-        return cpu;\n-    }\n-\n-    private SubSystem CpuAcctSubSystem() {\n-        return cpuacct;\n-    }\n-\n-    private SubSystem CpuSetSubSystem() {\n-        return cpuset;\n-    }\n-\n-    private SubSystem BlkIOSubSystem() {\n-        return blkio;\n-    }\n-\n-    public String getProvider() {\n-        return PROVIDER_NAME;\n-    }\n-\n-    \/*****************************************************************\n-     * CPU Accounting Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuUsage() {\n-        return SubSystem.getLongValue(cpuacct, \"cpuacct.usage\");\n-    }\n-\n-    public long[] getPerCpuUsage() {\n-        String usagelist = SubSystem.getStringValue(cpuacct, \"cpuacct.usage_percpu\");\n-        if (usagelist == null) {\n-            return new long[0];\n-        }\n-\n-        String list[] = usagelist.split(\" \");\n-        long percpu[] = new long[list.length];\n-        for (int i = 0; i < list.length; i++) {\n-            percpu[i] = Long.parseLong(list[i]);\n-        }\n-        return percpu;\n-    }\n-\n-    public long getCpuUserUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"user\");\n-    }\n-\n-    public long getCpuSystemUsage() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpuacct.stat\", \"system\");\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPU Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getCpuPeriod() {\n-        return SubSystem.getLongValue(cpuacct, \"cpu.cfs_period_us\");\n-    }\n-\n-    public long getCpuQuota() {\n-        return SubSystem.getLongValue(cpuacct, \"cpu.cfs_quota_us\");\n-    }\n-\n-    public long getCpuShares() {\n-        long retval = SubSystem.getLongValue(cpuacct, \"cpu.shares\");\n-        if (retval == 0 || retval == 1024)\n-            return -1;\n-        else\n-            return retval;\n-    }\n-\n-    public long getCpuNumPeriods() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpu.stat\", \"nr_periods\");\n-    }\n-\n-    public long getCpuNumThrottled() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpu.stat\", \"nr_throttled\");\n-    }\n-\n-    public long getCpuThrottledTime() {\n-        return SubSystem.getLongEntry(cpuacct, \"cpu.stat\", \"throttled_time\");\n-    }\n-\n-    public long getEffectiveCpuCount() {\n-        return Runtime.getRuntime().availableProcessors();\n-    }\n-\n-\n-    \/*****************************************************************\n-     * CPUSet Subsystem\n-     ****************************************************************\/\n-\n-    public int[] getCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.cpus\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetCpus() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_cpus\"));\n-    }\n-\n-    public int[] getCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.mems\"));\n-    }\n-\n-    public int[] getEffectiveCpuSetMems() {\n-        return SubSystem.StringRangeToIntArray(SubSystem.getStringValue(cpuset, \"cpuset.effective_mems\"));\n-    }\n-\n-    public double getCpuSetMemoryPressure() {\n-        return SubSystem.getDoubleValue(cpuset, \"cpuset.memory_pressure\");\n-    }\n-\n-    public boolean isCpuSetMemoryPressureEnabled() {\n-        long val = SubSystem.getLongValue(cpuset, \"cpuset.memory_pressure_enabled\");\n-        return (val == 1);\n-    }\n-\n-\n-    \/*****************************************************************\n-     * Memory Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.failcnt\");\n-    }\n-\n-    public long getMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memory_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public static long convertHierachicalLimitLine(String line) {\n-        String[] tokens = line.split(\"\\\\s\");\n-        if (tokens.length == 2) {\n-            String strVal = tokens[1];\n-            return SubSystem.convertStringToLong(strVal);\n-        }\n-        return unlimited_minimum + 1; \/\/ unlimited\n-    }\n-\n-    public long getMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.failcnt\");\n-    }\n-\n-    public long getKernelMemoryLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.kmem.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getKernelMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.max_usage_in_bytes\");\n-    }\n-\n-    public long getKernelMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryFailCount() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.failcnt\");\n-    }\n-\n-    public long getTcpMemoryLimit() {\n-        long retval =  SubSystem.getLongValue(memory, \"memory.kmem.tcp.limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getTcpMemoryMaxUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.max_usage_in_bytes\");\n-    }\n-\n-    public long getTcpMemoryUsage() {\n-        return SubSystem.getLongValue(memory, \"memory.kmem.tcp.usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapFailCount() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryFailCount();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.failcnt\");\n-    }\n-\n-    public long getMemoryAndSwapLimit() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryLimit();\n-        }\n-        long retval = SubSystem.getLongValue(memory, \"memory.memsw.limit_in_bytes\");\n-        if (retval > unlimited_minimum) {\n-            if (memory.isHierarchical()) {\n-                \/\/ memory.memsw.limit_in_bytes returned unlimited, attempt\n-                \/\/ hierarchical memory limit\n-                String match = \"hierarchical_memsw_limit\";\n-                retval = SubSystem.getLongValueMatchingLine(memory,\n-                                                            \"memory.stat\",\n-                                                            match,\n-                                                            Metrics::convertHierachicalLimitLine);\n-            }\n-        }\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-    public long getMemoryAndSwapMaxUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryMaxUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.max_usage_in_bytes\");\n-    }\n-\n-    public long getMemoryAndSwapUsage() {\n-        if (memory != null && !memory.isSwapEnabled()) {\n-            return getMemoryUsage();\n-        }\n-        return SubSystem.getLongValue(memory, \"memory.memsw.usage_in_bytes\");\n-    }\n-\n-    public boolean isMemoryOOMKillEnabled() {\n-        long val = SubSystem.getLongEntry(memory, \"memory.oom_control\", \"oom_kill_disable\");\n-        return (val == 0);\n-    }\n-\n-    public long getMemorySoftLimit() {\n-        long retval = SubSystem.getLongValue(memory, \"memory.soft_limit_in_bytes\");\n-        return retval > unlimited_minimum ? -1L : retval;\n-    }\n-\n-\n-    \/*****************************************************************\n-     * BlKIO Subsystem\n-     ****************************************************************\/\n-\n-\n-    public long getBlkIOServiceCount() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_service_bytes\", \"Total\");\n-    }\n-\n-    public long getBlkIOServiced() {\n-        return SubSystem.getLongEntry(blkio, \"blkio.throttle.io_serviced\", \"Total\");\n-    }\n-\n-    private static native boolean isUseContainerSupport();\n-\n-}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/Metrics.java","additions":0,"deletions":545,"binary":false,"changes":545,"status":"deleted"},{"patch":"@@ -1,301 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.platform.cgroupv1;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.math.BigInteger;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.function.Function;\n-import java.util.stream.Stream;\n-\n-public class SubSystem {\n-    String root;\n-    String mountPoint;\n-    String path;\n-\n-    public SubSystem(String root, String mountPoint) {\n-        this.root = root;\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public void setPath(String cgroupPath) {\n-        if (root != null && cgroupPath != null) {\n-            if (root.equals(\"\/\")) {\n-                if (!cgroupPath.equals(\"\/\")) {\n-                    path = mountPoint + cgroupPath;\n-                }\n-                else {\n-                    path = mountPoint;\n-                }\n-            }\n-            else {\n-                if (root.equals(cgroupPath)) {\n-                    path = mountPoint;\n-                }\n-                else {\n-                    if (cgroupPath.startsWith(root)) {\n-                        if (cgroupPath.length() > root.length()) {\n-                            String cgroupSubstr = cgroupPath.substring(root.length());\n-                            path = mountPoint + cgroupSubstr;\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    public String path() {\n-        return path;\n-    }\n-\n-    \/**\n-     * getSubSystemStringValue\n-     *\n-     * Return the first line of the file \"parm\" argument from the subsystem.\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @return Returns the contents of the file specified by param.\n-     *\/\n-    public static String getStringValue(SubSystem subsystem, String parm) {\n-        if (subsystem == null) return null;\n-\n-        try {\n-            return subsystem.readStringValue(parm);\n-        } catch (IOException e) {\n-            return null;\n-        }\n-    }\n-\n-    private String readStringValue(String param) throws IOException {\n-        PrivilegedExceptionAction<BufferedReader> pea = () ->\n-                Files.newBufferedReader(Paths.get(path(), param));\n-        try (BufferedReader bufferedReader =\n-                     AccessController.doPrivileged(pea)) {\n-            String line = bufferedReader.readLine();\n-            return line;\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValueMatchingLine(SubSystem subsystem,\n-                                                     String param,\n-                                                     String match,\n-                                                     Function<String, Long> conversion) {\n-        long retval = Metrics.unlimited_minimum + 1; \/\/ default unlimited\n-        try {\n-            List<String> lines = subsystem.readMatchingLines(param);\n-            for (String line: lines) {\n-                if (line.contains(match)) {\n-                    retval = conversion.apply(line);\n-                    break;\n-                }\n-            }\n-        } catch (IOException e) {\n-            \/\/ Ignore. Default is unlimited.\n-        }\n-        return retval;\n-    }\n-\n-    private List<String> readMatchingLines(String param) throws IOException {\n-        try {\n-            PrivilegedExceptionAction<List<String>> pea = () ->\n-                    Files.readAllLines(Paths.get(path(), param));\n-            return AccessController.doPrivileged(pea);\n-        } catch (PrivilegedActionException e) {\n-            Metrics.unwrapIOExceptionAndRethrow(e);\n-            throw new InternalError(e.getCause());\n-        } catch (UncheckedIOException e) {\n-            throw e.getCause();\n-        }\n-    }\n-\n-    public static long getLongValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-        return convertStringToLong(strval);\n-    }\n-\n-    public static long convertStringToLong(String strval) {\n-        if (strval == null) return 0L;\n-\n-        long retval = 0;\n-\n-        try {\n-            retval = Long.parseLong(strval);\n-        } catch (NumberFormatException e) {\n-            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n-            \/\/ In this case, return Long.max\n-            BigInteger b = new BigInteger(strval);\n-            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n-                return Long.MAX_VALUE;\n-            }\n-        }\n-\n-        return retval;\n-    }\n-\n-    public static double getDoubleValue(SubSystem subsystem, String parm) {\n-        String strval = getStringValue(subsystem, parm);\n-\n-        if (strval == null) return 0L;\n-\n-        double retval = Double.parseDouble(strval);\n-\n-        return retval;\n-    }\n-\n-    \/**\n-     * getSubSystemlongEntry\n-     *\n-     * Return the long value from the line containing the string \"entryname\"\n-     * within file \"parm\" in the \"subsystem\".\n-     *\n-     * TODO:  Consider using weak references for caching BufferedReader object.\n-     *\n-     * @param subsystem\n-     * @param parm\n-     * @param entryname\n-     * @return long value\n-     *\/\n-    public static long getLongEntry(SubSystem subsystem, String parm, String entryname) {\n-        String val = null;\n-\n-        if (subsystem == null) return 0L;\n-\n-        try (Stream<String> lines = Metrics.readFilePrivileged(Paths.get(subsystem.path(), parm))) {\n-\n-            Optional<String> result = lines.map(line -> line.split(\" \"))\n-                                           .filter(line -> (line.length == 2 &&\n-                                                   line[0].equals(entryname)))\n-                                           .map(line -> line[1])\n-                                           .findFirst();\n-\n-            return result.isPresent() ? Long.parseLong(result.get()) : 0L;\n-        } catch (IOException e) {\n-            return 0L;\n-        } catch (UncheckedIOException e) {\n-            return 0L;\n-        }\n-    }\n-\n-    public static int getIntValue(SubSystem subsystem, String parm) {\n-        String val = getStringValue(subsystem, parm);\n-\n-        if (val == null) return 0;\n-\n-        return Integer.parseInt(val);\n-    }\n-\n-    \/**\n-     * StringRangeToIntArray\n-     *\n-     * Convert a string in the form of  1,3-4,6 to an array of\n-     * integers containing all the numbers in the range.\n-     *\n-     * @param range\n-     * @return int[] containing a sorted list of processors or memory nodes\n-     *\/\n-    public static int[] StringRangeToIntArray(String range) {\n-        int[] ints = new int[0];\n-\n-        if (range == null) return ints;\n-\n-        ArrayList<Integer> results = new ArrayList<>();\n-        String strs[] = range.split(\",\");\n-        for (String str : strs) {\n-            if (str.contains(\"-\")) {\n-                String lohi[] = str.split(\"-\");\n-                \/\/ validate format\n-                if (lohi.length != 2) {\n-                    continue;\n-                }\n-                int lo = Integer.parseInt(lohi[0]);\n-                int hi = Integer.parseInt(lohi[1]);\n-                for (int i = lo; i <= hi; i++) {\n-                    results.add(i);\n-                }\n-            }\n-            else {\n-                results.add(Integer.parseInt(str));\n-            }\n-        }\n-\n-        \/\/ sort results\n-        results.sort(null);\n-\n-        \/\/ convert ArrayList to primitive int array\n-        ints = new int[results.size()];\n-        int i = 0;\n-        for (Integer n : results) {\n-            ints[i++] = n;\n-        }\n-\n-        return ints;\n-    }\n-\n-    public static class MemorySubSystem extends SubSystem {\n-\n-        private boolean hierarchical;\n-        private boolean swapenabled;\n-\n-        public MemorySubSystem(String root, String mountPoint) {\n-            super(root, mountPoint);\n-        }\n-\n-        boolean isHierarchical() {\n-            return hierarchical;\n-        }\n-\n-        void setHierarchical(boolean hierarchical) {\n-            this.hierarchical = hierarchical;\n-        }\n-\n-        boolean isSwapEnabled() {\n-            return swapenabled;\n-        }\n-\n-        void setSwapEnabled(boolean swapenabled) {\n-            this.swapenabled = swapenabled;\n-        }\n-\n-    }\n-}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/SubSystem.java","additions":0,"deletions":301,"binary":false,"changes":301,"status":"deleted"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.internal.platform.CgroupUtil;\n+\n+public class CgroupV2Subsystem implements CgroupSubsystem {\n+\n+    private static final CgroupV2Subsystem INSTANCE = initSubsystem();\n+    private static final long[] LONG_ARRAY_NOT_SUPPORTED = null;\n+    private static final int[] INT_ARRAY_UNAVAILABLE = null;\n+    private final CgroupSubsystemController unified;\n+    private static final String PROVIDER_NAME = \"cgroupv2\";\n+    private static final int PER_CPU_SHARES = 1024;\n+    private static final String MAX_VAL = \"max\";\n+    private static final Object EMPTY_STR = \"\";\n+\n+    private CgroupV2Subsystem(CgroupSubsystemController unified) {\n+        this.unified = unified;\n+    }\n+\n+    private long getLongVal(String file) {\n+        return CgroupSubsystemController.getLongValue(unified,\n+                                                      file,\n+                                                      CgroupV2SubsystemController::convertStringToLong,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED);\n+    }\n+\n+    private static CgroupV2Subsystem initSubsystem() {\n+        \/\/ read mountinfo so as to determine root mount path\n+        String mountPath = null;\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            String l = lines.filter(line -> line.contains(\" - cgroup2 \"))\n+                            .collect(Collectors.joining());\n+            String[] tokens = l.split(\" \");\n+            mountPath = tokens[4];\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+        String cgroupPath = null;\n+        try {\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/self\/cgroup\"));\n+            for (String line: lines) {\n+                String[] tokens = line.split(\":\");\n+                if (tokens.length != 3) {\n+                    return null; \/\/ something is not right.\n+                }\n+                if (!\"0\".equals(tokens[0])) {\n+                    \/\/ hierarchy must be zero for cgroups v2\n+                    return null;\n+                }\n+                cgroupPath = tokens[2];\n+                break;\n+            }\n+        } catch (UncheckedIOException e) {\n+            return null;\n+        } catch (IOException e) {\n+            return null;\n+        }\n+        CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                mountPath,\n+                cgroupPath);\n+        return new CgroupV2Subsystem(unified);\n+    }\n+\n+    public static CgroupSubsystem getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    @Override\n+    public String getProvider() {\n+        return PROVIDER_NAME;\n+    }\n+\n+    @Override\n+    public long getCpuUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"usage_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long[] getPerCpuUsage() {\n+        return LONG_ARRAY_NOT_SUPPORTED;\n+    }\n+\n+    @Override\n+    public long getCpuUserUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"user_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuSystemUsage() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"system_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getCpuPeriod() {\n+        return getFromCpuMax(1 \/* $PERIOD index *\/);\n+    }\n+\n+    @Override\n+    public long getCpuQuota() {\n+        return getFromCpuMax(0 \/* $MAX index *\/);\n+    }\n+\n+    private long getFromCpuMax(int tokenIdx) {\n+        String cpuMaxRaw = CgroupSubsystemController.getStringValue(unified, \"cpu.max\");\n+        if (cpuMaxRaw == null) {\n+            \/\/ likely file not found\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        \/\/ $MAX $PERIOD\n+        String[] tokens = cpuMaxRaw.split(\"\\\\s+\");\n+        if (tokens.length != 2) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        String quota = tokens[tokenIdx];\n+        return limitFromString(quota);\n+    }\n+\n+    private long limitFromString(String strVal) {\n+        if (strVal == null || MAX_VAL.equals(strVal)) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return Long.parseLong(strVal);\n+    }\n+\n+    @Override\n+    public long getCpuShares() {\n+        long sharesRaw = getLongVal(\"cpu.weight\");\n+        if (sharesRaw == 100 || sharesRaw <= 0) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        int shares = (int)sharesRaw;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    @Override\n+    public long getCpuNumPeriods() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_periods\");\n+    }\n+\n+    @Override\n+    public long getCpuNumThrottled() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"nr_throttled\");\n+    }\n+\n+    @Override\n+    public long getCpuThrottledTime() {\n+        long micros = CgroupV2SubsystemController.getLongEntry(unified, \"cpu.stat\", \"throttled_usec\");\n+        if (micros < 0) {\n+            return micros;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public long getEffectiveCpuCount() {\n+        return Runtime.getRuntime().availableProcessors();\n+    }\n+\n+    @Override\n+    public int[] getCpuSetCpus() {\n+        String cpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus\");\n+        return getCpuSet(cpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetCpus() {\n+        String effCpuSetVal = CgroupSubsystemController.getStringValue(unified, \"cpuset.cpus.effective\");\n+        return getCpuSet(effCpuSetVal);\n+    }\n+\n+    @Override\n+    public int[] getCpuSetMems() {\n+        String cpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems\");\n+        return getCpuSet(cpuSetMems);\n+    }\n+\n+    @Override\n+    public int[] getEffectiveCpuSetMems() {\n+        String effCpuSetMems = CgroupSubsystemController.getStringValue(unified, \"cpuset.mems.effective\");\n+        return getCpuSet(effCpuSetMems);\n+    }\n+\n+    private int[] getCpuSet(String cpuSetVal) {\n+        if (cpuSetVal == null || EMPTY_STR.equals(cpuSetVal)) {\n+            return INT_ARRAY_UNAVAILABLE;\n+        }\n+        return CgroupSubsystemController.stringRangeToIntArray(cpuSetVal);\n+    }\n+\n+    @Override\n+    public long getMemoryFailCount() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.events\", \"max\");\n+    }\n+\n+    @Override\n+    public long getMemoryLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.max\");\n+        return limitFromString(strVal);\n+    }\n+\n+    @Override\n+    public long getMemoryUsage() {\n+        return getLongVal(\"memory.current\");\n+    }\n+\n+    @Override\n+    public long getTcpMemoryUsage() {\n+        return CgroupV2SubsystemController.getLongEntry(unified, \"memory.stat\", \"sock\");\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapLimit() {\n+        String strVal = CgroupSubsystemController.getStringValue(unified, \"memory.swap.max\");\n+        return limitFromString(strVal);\n+    }\n+\n+    @Override\n+    public long getMemoryAndSwapUsage() {\n+        return getLongVal(\"memory.swap.current\");\n+    }\n+\n+    @Override\n+    public long getMemorySoftLimit() {\n+        String softLimitStr = CgroupSubsystemController.getStringValue(unified, \"memory.low\");\n+        return limitFromString(softLimitStr);\n+    }\n+\n+    @Override\n+    public long getBlkIOServiceCount() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRandWIOs);\n+    }\n+\n+\n+    @Override\n+    public long getBlkIOServiced() {\n+        return sumTokensIOStat(CgroupV2Subsystem::lineToRBytesAndWBytesIO);\n+    }\n+\n+    private long sumTokensIOStat(Function<String, Long> mapFunc) {\n+        try {\n+            return CgroupUtil.readFilePrivileged(Paths.get(unified.path(), \"io.stat\"))\n+                                .map(mapFunc)\n+                                .collect(Collectors.summingLong(e -> e));\n+        } catch (UncheckedIOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        } catch (IOException e) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+    }\n+\n+    private static String[] getRWIOMatchTokenNames() {\n+        return new String[] { \"rios\", \"wios\" };\n+    }\n+\n+    private static String[] getRWBytesIOMatchTokenNames() {\n+        return new String[] { \"rbytes\", \"wbytes\" };\n+    }\n+\n+    public static Long lineToRandWIOs(String line) {\n+        String[] matchNames = getRWIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    public static Long lineToRBytesAndWBytesIO(String line) {\n+        String[] matchNames = getRWBytesIOMatchTokenNames();\n+        return ioStatLineToLong(line, matchNames);\n+    }\n+\n+    private static Long ioStatLineToLong(String line, String[] matchNames) {\n+        if (line == null || EMPTY_STR.equals(line)) {\n+            return Long.valueOf(0);\n+        }\n+        String[] tokens = line.split(\"\\\\s+\");\n+        long retval = 0;\n+        for (String t: tokens) {\n+            String[] valKeys = t.split(\"=\");\n+            if (valKeys.length != 2) {\n+                \/\/ ignore device ids $MAJ:$MIN\n+                continue;\n+            }\n+            for (String match: matchNames) {\n+                if (match.equals(valKeys[0])) {\n+                    retval += longOrZero(valKeys[1]);\n+                }\n+            }\n+        }\n+        return Long.valueOf(retval);\n+    }\n+\n+    private static long longOrZero(String val) {\n+        long lVal = 0;\n+        try {\n+            lVal = Long.parseLong(val);\n+        } catch (NumberFormatException e) {\n+            \/\/ keep at 0\n+        }\n+        return lVal;\n+    }\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.platform.cgroupv2;\n+\n+import java.nio.file.Paths;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupSubsystemController;\n+\n+public class CgroupV2SubsystemController implements CgroupSubsystemController {\n+\n+    private final String path;\n+\n+    public CgroupV2SubsystemController(String mountPath, String cgroupPath) {\n+        this.path = Paths.get(mountPath, cgroupPath).toString();\n+    }\n+\n+    @Override\n+    public String path() {\n+        return path;\n+    }\n+\n+    public static long convertStringToLong(String strval) {\n+        return CgroupSubsystemController.convertStringToLong(strval,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* overflow retval *\/,\n+                                                             CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* default retval on error *\/);\n+    }\n+\n+    public static long getLongEntry(CgroupSubsystemController controller, String param, String entryname) {\n+        return CgroupSubsystemController.getLongEntry(controller,\n+                                                      param,\n+                                                      entryname,\n+                                                      CgroupSubsystem.LONG_RETVAL_UNLIMITED \/* retval on error *\/);\n+    }\n+}\n","filename":"jdk\/src\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2SubsystemController.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+\n+#include \"jdk_internal_platform_CgroupMetrics.h\"\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_platform_CgroupMetrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n+{\n+    return JVM_IsUseContainerSupport();\n+}\n","filename":"jdk\/src\/linux\/native\/jdk\/internal\/platform\/cgroupv1\/CgroupMetrics.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Red Hat, Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jvm.h\"\n-\n-#include \"jdk_internal_platform_cgroupv1_Metrics.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_internal_platform_cgroupv1_Metrics_isUseContainerSupport(JNIEnv *env, jclass ignored)\n-{\n-    return JVM_IsUseContainerSupport();\n-}\n","filename":"jdk\/src\/linux\/native\/jdk\/internal\/platform\/cgroupv1\/Metrics.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedExceptionAction;\n@@ -53,0 +55,15 @@\n+    private static int findFirstFreePort() {\n+        PrivilegedExceptionAction<DatagramSocket> action = () -> new DatagramSocket(0);\n+        int port;\n+        try {\n+            @SuppressWarnings({\"deprecated\", \"removal\"})\n+            DatagramSocket ds = AccessController.doPrivileged(action);\n+            try (DatagramSocket ds1 = ds) {\n+                port = ds1.getLocalPort();\n+            }\n+        } catch (Exception x) {\n+            port = 0;\n+        }\n+        return port;\n+    }\n+\n@@ -77,1 +94,4 @@\n-                ports[random.nextInt(capacity)] = port;\n+                \/\/ don't remove the last port\n+                int remove = random.nextInt(capacity);\n+                if ((remove +1) % capacity == index) remove = index;\n+                ports[index = remove] = port;\n@@ -93,1 +113,2 @@\n-    int lastport = 0;\n+    int lastport = findFirstFreePort();\n+    int lastSystemAllocated = lastport;\n@@ -150,0 +171,1 @@\n+            lastSystemAllocated = lastport;\n@@ -155,2 +177,4 @@\n-        boolean farEnough = Integer.bitCount(lastseen ^ lastport) > BIT_DEVIATION\n-                            && Math.abs(lastport - lastseen) > deviation;\n+        boolean farEnough = farEnough(lastseen);\n+        if (farEnough && lastSystemAllocated > 0) {\n+            farEnough = farEnough(lastSystemAllocated);\n+        }\n@@ -171,0 +195,1 @@\n+            lastSystemAllocated = lastport;\n@@ -221,0 +246,5 @@\n+    private boolean farEnough(int port) {\n+        return Integer.bitCount(port ^ lastport) > BIT_DEVIATION\n+                && Math.abs(port - lastport) > deviation;\n+    }\n+\n@@ -224,2 +254,16 @@\n-            int port = EphemeralPortRange.LOWER\n-                    + random.nextInt(EphemeralPortRange.RANGE);\n+            int port;\n+            boolean suitable;\n+            boolean recycled;\n+            int maxrandom = MAX_RANDOM_TRIES;\n+            do {\n+                port = EphemeralPortRange.LOWER\n+                        + random.nextInt(EphemeralPortRange.RANGE);\n+                recycled = history.contains(port);\n+                suitable = lastport == 0 || (farEnough(port) && !recycled);\n+            } while (maxrandom-- > 0 && !suitable);\n+\n+            \/\/ if no suitable port was found, try again\n+            \/\/ this means we might call random MAX_RANDOM_TRIES x MAX_RANDOM_TRIES\n+            \/\/ times - but that should be OK with MAX_RANDOM_TRIES = 5.\n+            if (!suitable) continue;\n+\n@@ -232,0 +276,2 @@\n+                        lastport = s.getLocalPort();\n+                        if (!recycled) history.add(port);\n@@ -238,1 +284,4 @@\n-                return new DatagramSocket(port);\n+                DatagramSocket s = new DatagramSocket(port);\n+                lastport = s.getLocalPort();\n+                if (!recycled) history.add(port);\n+                return s;\n","filename":"jdk\/src\/share\/classes\/com\/sun\/jndi\/dns\/DNSDatagramSocketFactory.java","additions":57,"deletions":8,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,2 @@\n-        if (type2 == null || (v != Version.NTLM && nonce == null)) {\n+        if (type2 == null || (v != Version.NTLM && nonce == null) ||\n+                (nonce != null && nonce.length != 8)) {\n@@ -122,1 +123,1 @@\n-                    \"type2 and nonce cannot be null\");\n+                    \"type2 cannot be null, and nonce must be 8-byte long\");\n","filename":"jdk\/src\/share\/classes\/com\/sun\/security\/ntlm\/Client.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-        void writeSecurityBuffer(int offset, byte[] data) {\n+        void writeSecurityBuffer(int offset, byte[] data) throws NTLMException {\n@@ -233,1 +233,1 @@\n-                writeShort(offset+4, current);\n+                writeInt(offset+4, current);\n@@ -236,0 +236,4 @@\n+                if (len > 65535) {\n+                    throw new NTLMException(NTLMException.INVALID_INPUT,\n+                            \"Invalid data length \" + len);\n+                }\n@@ -241,1 +245,1 @@\n-                writeShort(offset+4, current);\n+                writeInt(offset+4, current);\n@@ -247,1 +251,1 @@\n-        void writeSecurityBuffer(int offset, String str, boolean unicode) {\n+        void writeSecurityBuffer(int offset, String str, boolean unicode) throws NTLMException {\n","filename":"jdk\/src\/share\/classes\/com\/sun\/security\/ntlm\/NTLM.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -73,0 +73,5 @@\n+    \/**\n+     * If an invalid input is provided.\n+     *\/\n+    public static final int INVALID_INPUT = 7;\n+\n","filename":"jdk\/src\/share\/classes\/com\/sun\/security\/ntlm\/NTLMException.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2010, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-        if (nonce == null) {\n+        if (nonce == null || nonce.length != 8) {\n@@ -91,1 +91,1 @@\n-                    \"nonce cannot be null\");\n+                    \"nonce must be 8-byte long\");\n","filename":"jdk\/src\/share\/classes\/com\/sun\/security\/ntlm\/Server.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+import java.io.InvalidObjectException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectStreamException;\n+import java.io.StreamCorruptedException;\n@@ -978,0 +982,9 @@\n+    \/**\n+     * Accept no subclasses.\n+     *\/\n+    private static BigInteger toStrictBigInteger(BigInteger val) {\n+        return (val.getClass() == BigInteger.class) ?\n+            val :\n+            new BigInteger(val.toByteArray().clone());\n+    }\n+\n@@ -987,2 +1000,2 @@\n-        intVal = val;\n-        intCompact = compactValFor(val);\n+        intVal = toStrictBigInteger(val);\n+        intCompact = compactValFor(intVal);\n@@ -1004,1 +1017,1 @@\n-        this(val,0,mc);\n+        this(toStrictBigInteger(val), 0, mc);\n@@ -1018,2 +1031,2 @@\n-        this.intVal = unscaledVal;\n-        this.intCompact = compactValFor(unscaledVal);\n+        this.intVal = toStrictBigInteger(unscaledVal);\n+        this.intCompact = compactValFor(this.intVal);\n@@ -1039,0 +1052,1 @@\n+        unscaledVal = toStrictBigInteger(unscaledVal);\n@@ -3750,0 +3764,1 @@\n+        private static final long scaleOffset;\n@@ -3757,0 +3772,2 @@\n+                scaleOffset = unsafe.objectFieldOffset\n+                    (BigDecimal.class.getDeclaredField(\"scale\"));\n@@ -3761,2 +3778,5 @@\n-        static void setIntCompactVolatile(BigDecimal bd, long val) {\n-            unsafe.putLongVolatile(bd, intCompactOffset, val);\n+\n+        static void setIntValAndScaleVolatile(BigDecimal bd, BigInteger intVal, int scale) {\n+            unsafe.putObjectVolatile(bd, intValOffset, intVal);\n+            unsafe.putIntVolatile(bd, scaleOffset, scale);\n+            unsafe.putLongVolatile(bd, intCompactOffset, compactValFor(intVal));\n@@ -3778,7 +3798,7 @@\n-        \/\/ Read in all fields\n-        s.defaultReadObject();\n-        \/\/ validate possibly bad fields\n-        if (intVal == null) {\n-            String message = \"BigDecimal: null intVal in stream\";\n-            throw new java.io.StreamCorruptedException(message);\n-        \/\/ [all values of scale are now allowed]\n+        \/\/ prepare to read the fields\n+        ObjectInputStream.GetField fields = s.readFields();\n+        BigInteger serialIntVal = (BigInteger) fields.get(\"intVal\", null);\n+\n+        \/\/ Validate field data\n+        if (serialIntVal == null) {\n+            throw new StreamCorruptedException(\"Null or missing intVal in BigDecimal stream\");\n@@ -3786,1 +3806,15 @@\n-        UnsafeHolder.setIntCompactVolatile(this, compactValFor(intVal));\n+        \/\/ Validate provenance of serialIntVal object\n+        serialIntVal = toStrictBigInteger(serialIntVal);\n+\n+        \/\/ Any integer value is valid for scale\n+        int serialScale = fields.get(\"scale\", 0);\n+\n+        UnsafeHolder.setIntValAndScaleVolatile(this, serialIntVal, serialScale);\n+    }\n+\n+    \/**\n+     * Serialization without data not supported for this class.\n+     *\/\n+    private void readObjectNoData()\n+        throws ObjectStreamException {\n+        throw new InvalidObjectException(\"Deserialized BigDecimal objects need data\");\n","filename":"jdk\/src\/share\/classes\/java\/math\/BigDecimal.java","additions":49,"deletions":15,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.InvalidObjectException;\n@@ -36,0 +37,1 @@\n+import java.io.ObjectStreamException;\n@@ -4509,3 +4511,2 @@\n-        \/\/ Read the alternate persistent fields that we care about\n-        int sign = fields.get(\"signum\", -2);\n-        byte[] magnitude = (byte[])fields.get(\"magnitude\", null);\n+        \/\/ Read and validate the alternate persistent fields that we\n+        \/\/ care about, signum and magnitude\n@@ -4513,1 +4514,2 @@\n-        \/\/ Validate signum\n+        \/\/ Read and validate signum\n+        int sign = fields.get(\"signum\", -2);\n@@ -4520,0 +4522,4 @@\n+\n+        \/\/ Read and validate magnitude\n+        byte[] magnitude = (byte[])fields.get(\"magnitude\", null);\n+        magnitude = magnitude.clone(); \/\/ defensive copy\n@@ -4528,0 +4534,7 @@\n+        \/\/ Equivalent to checkRange() on mag local without assigning\n+        \/\/ this.mag field\n+        if (mag.length > MAX_MAG_LENGTH ||\n+            (mag.length == MAX_MAG_LENGTH && mag[0] < 0)) {\n+            throw new java.io.StreamCorruptedException(\"BigInteger: Out of the supported range\");\n+        }\n+\n@@ -4529,1 +4542,2 @@\n-        UnsafeHolder.putSign(this, sign);\n+        UnsafeHolder.putSignAndMag(this, sign, mag);\n+    }\n@@ -4531,9 +4545,6 @@\n-        \/\/ Calculate mag field from magnitude and discard magnitude\n-        UnsafeHolder.putMag(this, mag);\n-        if (mag.length >= MAX_MAG_LENGTH) {\n-            try {\n-                checkRange();\n-            } catch (ArithmeticException e) {\n-                throw new java.io.StreamCorruptedException(\"BigInteger: Out of the supported range\");\n-            }\n-        }\n+    \/**\n+     * Serialization without data not supported for this class.\n+     *\/\n+    private void readObjectNoData()\n+        throws ObjectStreamException {\n+        throw new InvalidObjectException(\"Deserialized BigInteger objects need data\");\n@@ -4559,1 +4570,1 @@\n-        static void putSign(BigInteger bi, int sign) {\n+        static void putSignAndMag(BigInteger bi, int sign, int[] magnitude) {\n@@ -4561,3 +4572,0 @@\n-        }\n-\n-        static void putMag(BigInteger bi, int[] magnitude) {\n","filename":"jdk\/src\/share\/classes\/java\/math\/BigInteger.java","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-     * the array will not affect this UnsolvedPermission.\n+     * the array will not affect this UnresolvedPermission.\n@@ -166,0 +166,6 @@\n+        \/\/ Perform a defensive copy and reassign certs if we have a non-null\n+        \/\/ reference\n+        if (certs != null) {\n+            certs = certs.clone();\n+        }\n+\n@@ -169,0 +175,1 @@\n+\n@@ -171,1 +178,1 @@\n-            for (int i=0; i<certs.length; i++) {\n+            for (int i = 0; i < certs.length; i++) {\n@@ -174,3 +181,3 @@\n-                    \/\/ entire cert array\n-                    this.certs = certs.clone();\n-                    break;\n+                    \/\/ entire cert array.  No further processing is necessary.\n+                    this.certs = certs;\n+                    return;\n@@ -180,12 +187,9 @@\n-            if (this.certs == null) {\n-                \/\/ Go through the list of certs and see if all the certs are\n-                \/\/ signer certs.\n-                int i = 0;\n-                int count = 0;\n-                while (i < certs.length) {\n-                    count++;\n-                    while (((i+1) < certs.length) &&\n-                           ((X509Certificate)certs[i]).getIssuerDN().equals(\n-                               ((X509Certificate)certs[i+1]).getSubjectDN())) {\n-                        i++;\n-                    }\n+            \/\/ Go through the list of certs and see if all the certs are\n+            \/\/ signer certs.\n+            int i = 0;\n+            int count = 0;\n+            while (i < certs.length) {\n+                count++;\n+                while (((i + 1) < certs.length) &&\n+                       ((X509Certificate)certs[i]).getIssuerDN().equals(\n+                           ((X509Certificate)certs[i + 1]).getSubjectDN())) {\n@@ -194,5 +198,8 @@\n-                if (count == certs.length) {\n-                    \/\/ All the certs are signer certs, so we store the entire\n-                    \/\/ array\n-                    this.certs = certs.clone();\n-                }\n+                i++;\n+            }\n+            if (count == certs.length) {\n+                \/\/ All the certs are signer certs, so we store the entire\n+                \/\/ array.  No further processing is needed.\n+                this.certs = certs;\n+                return;\n+            }\n@@ -200,17 +207,10 @@\n-                if (this.certs == null) {\n-                    \/\/ extract the signer certs\n-                    ArrayList<java.security.cert.Certificate> signerCerts =\n-                        new ArrayList<>();\n-                    i = 0;\n-                    while (i < certs.length) {\n-                        signerCerts.add(certs[i]);\n-                        while (((i+1) < certs.length) &&\n-                            ((X509Certificate)certs[i]).getIssuerDN().equals(\n-                              ((X509Certificate)certs[i+1]).getSubjectDN())) {\n-                            i++;\n-                        }\n-                        i++;\n-                    }\n-                    this.certs =\n-                        new java.security.cert.Certificate[signerCerts.size()];\n-                    signerCerts.toArray(this.certs);\n+            \/\/ extract the signer certs\n+            ArrayList<java.security.cert.Certificate> signerCerts =\n+                new ArrayList<>();\n+            i = 0;\n+            while (i < certs.length) {\n+                signerCerts.add(certs[i]);\n+                while (((i + 1) < certs.length) &&\n+                    ((X509Certificate)certs[i]).getIssuerDN().equals(\n+                      ((X509Certificate)certs[i + 1]).getSubjectDN())) {\n+                    i++;\n@@ -218,0 +218,1 @@\n+                i++;\n@@ -219,0 +220,3 @@\n+            this.certs =\n+                new java.security.cert.Certificate[signerCerts.size()];\n+            signerCerts.toArray(this.certs);\n@@ -311,0 +315,1 @@\n+    @Override\n@@ -331,0 +336,1 @@\n+    @Override\n@@ -404,1 +410,1 @@\n-\n+    @Override\n@@ -424,0 +430,1 @@\n+    @Override\n@@ -491,0 +498,1 @@\n+    @Override\n@@ -502,1 +510,1 @@\n-\n+    @Override\n","filename":"jdk\/src\/share\/classes\/java\/security\/UnresolvedPermission.java","additions":50,"deletions":42,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,3 +58,1 @@\n-            \/\/ We currently only support cgroupv1\n-            Class<?> c = Class.forName(\"jdk.internal.platform.cgroupv1.Metrics\");\n-            @SuppressWarnings(\"unchecked\")\n+            Class<?> c = Class.forName(\"jdk.internal.platform.CgroupMetrics\");\n@@ -76,1 +74,1 @@\n-     * The provider for Linux is cgroupsv1.\n+     * The provider for Linux is cgroups (version 1 or 2).\n@@ -92,1 +90,2 @@\n-     * @return Time in nanoseconds or 0L if metric is not available.\n+     * @return Time in nanoseconds, -1 if unknown or\n+     *         -2 if the metric is not supported.\n@@ -108,1 +107,1 @@\n-     *         this metric is not available, a zero length array will be\n+     *         this metric is not supported or not available, null will be\n@@ -118,1 +117,2 @@\n-     * @return User time in nanoseconds or 0L if metric is not available.\n+     * @return User time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -127,1 +127,2 @@\n-     * @return System time in nanoseconds or 0L if metric is not available.\n+     * @return System time in nanoseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -140,1 +141,2 @@\n-     * @return time in microseconds or 0L if metric is not available.\n+     * @return time in microseconds, -1 if the metric is not available or\n+     *         -2 if the metric is not supported.\n@@ -150,1 +152,2 @@\n-     * @return time in microseconds or -1 if the quota is unlimited.\n+     * @return time in microseconds, -1 if the quota is unlimited or\n+     *         -2 if not supported.\n@@ -169,1 +172,2 @@\n-     * @return shares value or -1 if no share set.\n+     * @return shares value, -1 if the metric is not available or\n+     *         -2 if cpu shares are not supported.\n@@ -176,2 +180,1 @@\n-     * a CPU quota has been setup for the Isolation Group; otherwise\n-     * returns 0.\n+     * a CPU quota has been setup for the Isolation Group\n@@ -179,1 +182,2 @@\n-     * @return count of elapsed periods or 0 if the quota is unlimited.\n+     * @return count of elapsed periods, -1 if the metric is not available\n+     *         or -2 if the metric is not supported.\n@@ -189,1 +193,2 @@\n-     * @return count of throttled periods or 0 if the quota is unlimited.\n+     * @return count of throttled periods, -1 if the metric is not available or\n+     *         -2 if it is not supported.\n@@ -199,1 +204,2 @@\n-     * @return Throttled time in nanoseconds or 0 if the quota is unlimited.\n+     * @return Throttled time in nanoseconds, -1 if the metric is not available\n+     *         or -2 if it is not supported.\n@@ -231,2 +237,2 @@\n-     * @return An array of available CPUs or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available CPUs. Returns null if the metric is not\n+     *         available or the metric is not supported.\n@@ -243,2 +249,2 @@\n-     * @return An array of available and online CPUs or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online CPUs. Returns null\n+     *         if the metric is not available or the metric is not supported.\n@@ -257,2 +263,2 @@\n-     * @return An array of available memory nodes or a zero length array\n-     *         if the metric is not available.\n+     * @return An array of available memory nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -269,2 +275,2 @@\n-     * @return An array of available and online nodes or a zero length\n-     *         array if the metric is not available.\n+     * @return An array of available and online nodes or null\n+     *         if the metric is not available or is not supported.\n@@ -275,21 +281,0 @@\n-    \/**\n-     * Returns the (attempts per second * 1000), if enabled, that the\n-     * operating system tries to satisfy a memory request for any\n-     * process in the current Isolation Group when no free memory is\n-     * readily available.  Use {@link #isCpuSetMemoryPressureEnabled()} to\n-     * to determine if this support is enabled.\n-     *\n-     * @return Memory pressure or 0 if not enabled or metric is not\n-     *         available.\n-     *\n-     *\/\n-    public double getCpuSetMemoryPressure();\n-\n-    \/**\n-     * Returns the state of the memory pressure detection support.\n-     *\n-     * @return true if the support is available and enabled, otherwise false.\n-     *\n-     *\/\n-    public boolean isCpuSetMemoryPressureEnabled();\n-\n@@ -304,2 +289,3 @@\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n+     * @return The number of exceeded requests or -1 if the metric\n+     *         is not available. Returns -2 if the metric is not\n+     *         supported.\n@@ -314,2 +300,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit or -2 if this metric is not supported.\n@@ -320,10 +306,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryMaxUsage();\n-\n@@ -334,2 +310,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available or -2 if the metric is not\n+     *         supported.\n@@ -340,70 +317,0 @@\n-    \/**\n-     * Returns the number of times that kernel memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of kernel physical memory, in bytes, that\n-     * can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of kernel physical memory, in bytes, that\n-     * have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryMaxUsage();\n-\n-    \/**\n-     * Returns the amount of kernel physical memory, in bytes, that\n-     * is currently allocated in the current Isolation Group.\n-     *\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getKernelMemoryUsage();\n-\n-    \/**\n-     * Returns the number of times that networking memory requests in the\n-     * Isolation Group have exceeded the kernel memory limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryFailCount();\n-\n-    \/**\n-     * Returns the maximum amount of networking physical memory, in bytes,\n-     * that can be allocated in the Isolation Group.\n-     *\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryLimit();\n-\n-    \/**\n-     * Returns the largest amount of networking physical memory, in bytes,\n-     * that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getTcpMemoryMaxUsage();\n-\n@@ -414,2 +321,2 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if the metric\n+     *         is not available. Returns -2 if this metric is not supported.\n@@ -420,10 +327,0 @@\n-    \/**\n-     * Returns the number of times that user memory requests in the\n-     * Isolation Group have exceeded the memory + swap limit.\n-     *\n-     * @return The number of exceeded requests or 0 if none or metric\n-     *         is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapFailCount();\n-\n@@ -434,2 +331,2 @@\n-     * @return The maximum amount of memory in bytes or -1 if either\n-     *         there is no limit set or this metric is not available.\n+     * @return The maximum amount of memory in bytes or -1 if\n+     *         there is no limit set or -2 if this metric is not supported.\n@@ -440,10 +337,0 @@\n-    \/**\n-     * Returns the largest amount of physical memory and swap space,\n-     * in bytes, that have been allocated in the Isolation Group.\n-     *\n-     * @return The largest amount of memory in bytes or or 0 if this\n-     *         metric is not available.\n-     *\n-     *\/\n-    public long getMemoryAndSwapMaxUsage();\n-\n@@ -454,2 +341,3 @@\n-     * @return The amount of memory in bytes allocated or 0 if this\n-     *         metric is not available.\n+     * @return The amount of memory in bytes allocated or -1 if\n+     *         the metric is not available. Returns -2 if this metric is not\n+     *         supported.\n@@ -460,12 +348,0 @@\n-    \/**\n-     * Returns the state of the Operating System Out of Memory termination\n-     * policy.\n-     *\n-     * @return Returns true if operating system will terminate processes\n-     *         in the Isolation Group that exceed the amount of available\n-     *         memory, otherwise false.  Flase will be returned if this\n-     *         capability is not available on the current operating system.\n-     *\n-     *\/\n-    public boolean isMemoryOOMKillEnabled();\n-\n@@ -480,2 +356,2 @@\n-     *         conditions.  If this metric is not available, 0 will be\n-     *         returned.\n+     *         conditions.  If this metric is not available, -1 will be\n+     *         returned. Returns -2 if the metric is not supported.\n@@ -494,1 +370,2 @@\n-     * @return The count of requests or 0 if this metric is not available.\n+     * @return The count of requests or -1 if the metric is not available.\n+     *         Returns -2 if this metric is not supported.\n@@ -503,1 +380,2 @@\n-     * @return The number of bytes transferred or 0 if this metric is not available.\n+     * @return The number of bytes transferred or -1 if the metric is not\n+     *         available. Returns -2 if this metric is not supported.\n","filename":"jdk\/src\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":52,"deletions":174,"binary":false,"changes":226,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,0 @@\n-import java.text.Normalizer;\n@@ -57,0 +56,1 @@\n+import java.text.Normalizer;\n@@ -89,0 +89,1 @@\n+\n@@ -299,0 +300,2 @@\n+        final long longRetvalNotSupported = -2;\n+\n@@ -301,5 +304,3 @@\n-        ostream.println(INDENT + \"CPU Period: \" + c.getCpuPeriod() +\n-               (c.getCpuPeriod() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Quota: \" + c.getCpuQuota() +\n-               (c.getCpuQuota() == -1 ? \"\" : \"us\"));\n-        ostream.println(INDENT + \"CPU Shares: \" + c.getCpuShares());\n+        ostream.println(formatCpuVal(c.getCpuPeriod(), INDENT + \"CPU Period: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuQuota(), INDENT + \"CPU Quota: \", longRetvalNotSupported));\n+        ostream.println(formatCpuVal(c.getCpuShares(), INDENT + \"CPU Shares: \", longRetvalNotSupported));\n@@ -308,2 +309,3 @@\n-        ostream.println(INDENT + \"List of Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -311,6 +313,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Processors: N\/A\");\n@@ -320,2 +325,3 @@\n-        ostream.println(INDENT + \"List of Effective Processors, \"\n-                + cpus.length + \" total: \");\n+        if (cpus != null) {\n+            ostream.println(INDENT + \"List of Effective Processors, \"\n+                    + cpus.length + \" total: \");\n@@ -323,6 +329,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < cpus.length; i++) {\n-            ostream.print(cpus[i] + \" \");\n-        }\n-        if (cpus.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < cpus.length; i++) {\n+                ostream.print(cpus[i] + \" \");\n+            }\n+            if (cpus.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Effective Processors: N\/A\");\n@@ -332,2 +341,3 @@\n-        ostream.println(INDENT + \"List of Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -335,6 +345,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Memory Nodes: N\/A\");\n@@ -344,2 +357,3 @@\n-        ostream.println(INDENT + \"List of Available Memory Nodes, \"\n-                + mems.length + \" total: \");\n+        if (mems != null) {\n+            ostream.println(INDENT + \"List of Available Memory Nodes, \"\n+                    + mems.length + \" total: \");\n@@ -347,6 +361,9 @@\n-        ostream.print(INDENT);\n-        for (int i = 0; i < mems.length; i++) {\n-            ostream.print(mems[i] + \" \");\n-        }\n-        if (mems.length > 0) {\n-            ostream.println(\"\");\n+            ostream.print(INDENT);\n+            for (int i = 0; i < mems.length; i++) {\n+                ostream.print(mems[i] + \" \");\n+            }\n+            if (mems.length > 0) {\n+                ostream.println(\"\");\n+            }\n+        } else {\n+            ostream.println(INDENT + \"List of Available Memory Nodes: N\/A\");\n@@ -355,3 +372,0 @@\n-        ostream.println(INDENT + \"CPUSet Memory Pressure Enabled: \"\n-                + c.isCpuSetMemoryPressureEnabled());\n-\n@@ -359,2 +373,1 @@\n-        ostream.println(INDENT + \"Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Limit: \", longRetvalNotSupported));\n@@ -363,2 +376,1 @@\n-        ostream.println(INDENT + \"Memory Soft Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory Soft Limit: \", longRetvalNotSupported));\n@@ -367,2 +379,1 @@\n-        ostream.println(INDENT + \"Memory & Swap Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(formatLimitString(limit, INDENT + \"Memory & Swap Limit: \", longRetvalNotSupported));\n@@ -370,7 +381,2 @@\n-        limit = c.getKernelMemoryLimit();\n-        ostream.println(INDENT + \"Kernel Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n-\n-        limit = c.getTcpMemoryLimit();\n-        ostream.println(INDENT + \"TCP Memory Limit: \" +\n-                ((limit >= 0) ? SizePrefix.scaleValue(limit) : \"Unlimited\"));\n+        ostream.println(\"\");\n+    }\n@@ -378,2 +384,9 @@\n-        ostream.println(INDENT + \"Out Of Memory Killer Enabled: \"\n-                + c.isMemoryOOMKillEnabled());\n+    private static String formatLimitString(long limit, String prefix, long unavailable) {\n+        if (limit >= 0) {\n+            return prefix + SizePrefix.scaleValue(limit);\n+        } else if (limit == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + \"Unlimited\";\n+        }\n+    }\n@@ -381,1 +394,8 @@\n-        ostream.println(\"\");\n+    private static String formatCpuVal(long cpuVal, String prefix, long unavailable) {\n+        if (cpuVal >= 0) {\n+            return prefix + cpuVal + \"us\";\n+        } else if (cpuVal == unavailable) {\n+            return prefix + \"N\/A\";\n+        } else {\n+            return prefix + cpuVal;\n+        }\n","filename":"jdk\/src\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":78,"deletions":58,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import com.sun.net.httpserver.*;\n-import com.sun.net.httpserver.spi.*;\n@@ -57,2 +55,2 @@\n-    long time;\n-    volatile long creationTime; \/\/ time this connection was created\n+    long idleStartTime; \/\/ absolute time in milli seconds, starting when the connection was marked idle\n+    volatile long reqStartedTime; \/\/ time when the request was initiated\n@@ -64,1 +62,1 @@\n-    public enum State {IDLE, REQUEST, RESPONSE};\n+    public enum State {IDLE, REQUEST, RESPONSE, NEWLY_ACCEPTED};\n","filename":"jdk\/src\/share\/classes\/sun\/net\/httpserver\/HttpConnection.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,0 @@\n-    TimeSource time;\n@@ -59,1 +58,0 @@\n-        this.time= (TimeSource)server;\n","filename":"jdk\/src\/share\/classes\/sun\/net\/httpserver\/SSLStreams.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    private static final int DEFAULT_CLOCK_TICK = 10000 ; \/\/ 10 sec.\n+    private static final int DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS = 10000 ; \/\/ 10 sec.\n@@ -40,2 +40,2 @@\n-    \/* These values must be a reasonable multiple of clockTick *\/\n-    private static final long DEFAULT_IDLE_INTERVAL = 30 ; \/\/ 5 min\n+    private static final long DEFAULT_IDLE_INTERVAL_IN_SECS = 30;\n+    private static final int DEFAULT_MAX_CONNECTIONS = -1 ; \/\/ no limit on maximum connections\n@@ -46,1 +46,3 @@\n-    private static final long DEFAULT_TIMER_MILLIS = 1000;\n+    \/\/ default timer schedule, in milli seconds, for the timer task that's responsible for\n+    \/\/ timing out request\/response if max request\/response time is configured\n+    private static final long DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS = 1000;\n@@ -50,2 +52,2 @@\n-    private static int clockTick;\n-    private static long idleInterval;\n+    private static long idleTimerScheduleMillis;\n+    private static long idleIntervalMillis;\n@@ -54,0 +56,4 @@\n+    \/\/ the maximum number of connections that the server will allow to be open\n+    \/\/ after which it will no longer \"accept()\" any new connections, till the\n+    \/\/ current connection count goes down due to completion of processing the requests\n+    private static int maxConnections;\n@@ -60,1 +66,1 @@\n-    private static long timerMillis;\n+    private static long reqRspTimerScheduleMillis;\n@@ -71,2 +77,12 @@\n-                    idleInterval = Long.getLong(\"sun.net.httpserver.idleInterval\",\n-                            DEFAULT_IDLE_INTERVAL) * 1000;\n+                    idleIntervalMillis = Long.getLong(\"sun.net.httpserver.idleInterval\",\n+                            DEFAULT_IDLE_INTERVAL_IN_SECS) * 1000;\n+                    if (idleIntervalMillis <= 0) {\n+                        idleIntervalMillis = DEFAULT_IDLE_INTERVAL_IN_SECS * 1000;\n+                    }\n+\n+                    idleTimerScheduleMillis = Long.getLong(\"sun.net.httpserver.clockTick\",\n+                            DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS);\n+                    if (idleTimerScheduleMillis <= 0) {\n+                        \/\/ ignore zero or negative value and use the default schedule\n+                        idleTimerScheduleMillis = DEFAULT_IDLE_TIMER_SCHEDULE_MILLIS;\n+                    }\n@@ -74,2 +90,3 @@\n-                    clockTick = Integer.getInteger(\"sun.net.httpserver.clockTick\",\n-                            DEFAULT_CLOCK_TICK);\n+                    maxConnections = Integer.getInteger(\n+                            \"jdk.httpserver.maxConnections\",\n+                            DEFAULT_MAX_CONNECTIONS);\n@@ -94,2 +111,7 @@\n-                    timerMillis = Long.getLong(\"sun.net.httpserver.timerMillis\",\n-                            DEFAULT_TIMER_MILLIS);\n+                    reqRspTimerScheduleMillis = Long.getLong(\"sun.net.httpserver.timerMillis\",\n+                            DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS);\n+                    if (reqRspTimerScheduleMillis <= 0) {\n+                        \/\/ ignore any negative or zero value for this configuration and reset\n+                        \/\/ to default schedule\n+                        reqRspTimerScheduleMillis = DEFAULT_REQ_RSP_TIMER_TASK_SCHEDULE_MILLIS;\n+                    }\n@@ -148,2 +170,13 @@\n-    static long getIdleInterval() {\n-        return idleInterval;\n+    \/**\n+     * {@return Returns the maximum duration, in milli seconds, a connection can be idle}\n+     *\/\n+    static long getIdleIntervalMillis() {\n+        return idleIntervalMillis;\n+    }\n+\n+    \/**\n+     * {@return Returns the schedule, in milli seconds, for the timer task that is responsible\n+     * for managing the idle connections}\n+     *\/\n+    static long getIdleTimerScheduleMillis() {\n+        return idleTimerScheduleMillis;\n@@ -152,2 +185,7 @@\n-    static int getClockTick() {\n-        return clockTick;\n+    \/**\n+     * @return Returns the maximum number of connections that can be open at any given time.\n+     * This method can return a value of 0 or negative to represent that the limit hasn't\n+     * been configured.\n+     *\/\n+    static int getMaxConnections() {\n+        return maxConnections;\n@@ -156,0 +194,4 @@\n+    \/**\n+     * @return Returns the maximum number of connections that can be idle. This method\n+     * can return a value of 0 or negative.\n+     *\/\n@@ -168,0 +210,5 @@\n+    \/**\n+     * @return Returns the maximum amount of time the server will wait for the request to be read\n+     * completely. This method can return a value of 0 or negative to imply no maximum limit has\n+     * been configured.\n+     *\/\n@@ -172,0 +219,5 @@\n+    \/**\n+     * @return Returns the maximum amount of time the server will wait for the response to be generated\n+     * for a request that is being processed. This method can return a value of 0 or negative to\n+     * imply no maximum limit has been configured.\n+     *\/\n@@ -176,2 +228,6 @@\n-    static long getTimerMillis() {\n-        return timerMillis;\n+    \/**\n+     * {@return Returns the timer schedule of the task that's responsible for timing out\n+     * request\/response that have been running longer than any configured timeout}\n+     *\/\n+    static long getReqRspTimerScheduleMillis() {\n+        return reqRspTimerScheduleMillis;\n","filename":"jdk\/src\/share\/classes\/sun\/net\/httpserver\/ServerConfig.java","additions":76,"deletions":20,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -28,5 +28,15 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.channels.*;\n-import java.util.*;\n-import java.util.concurrent.*;\n+import com.sun.net.httpserver.Filter;\n+import com.sun.net.httpserver.Headers;\n+import com.sun.net.httpserver.HttpContext;\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import sun.net.httpserver.HttpConnection.State;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLEngine;\n+import java.io.BufferedInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n@@ -35,2 +45,10 @@\n-import javax.net.ssl.*;\n-import com.sun.net.httpserver.*;\n+import java.net.BindException;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.channels.CancelledKeyException;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n@@ -39,1 +57,9 @@\n-import sun.net.httpserver.HttpConnection.State;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.Executor;\n@@ -44,1 +70,1 @@\n-class ServerImpl implements TimeSource {\n+class ServerImpl {\n@@ -56,2 +82,5 @@\n-    private Set<HttpConnection> idleConnections;\n-    private Set<HttpConnection> allConnections;\n+    private final Set<HttpConnection> idleConnections;\n+    \/\/ connections which have been accepted() by the server but which haven't\n+    \/\/ yet sent any byte on the connection yet\n+    private final Set<HttpConnection> newlyAcceptedConnections;\n+    private final Set<HttpConnection> allConnections;\n@@ -62,2 +91,2 @@\n-    private Set<HttpConnection> reqConnections;\n-    private Set<HttpConnection> rspConnections;\n+    private final Set<HttpConnection> reqConnections;\n+    private final Set<HttpConnection> rspConnections;\n@@ -65,1 +94,1 @@\n-    private Object lolock = new Object();\n+    private final Object lolock = new Object();\n@@ -70,3 +99,0 @@\n-    private volatile long time;  \/* current time *\/\n-    private volatile long subticks = 0;\n-    private volatile long ticks; \/* number of clock ticks since server started *\/\n@@ -75,2 +101,3 @@\n-    final static int CLOCK_TICK = ServerConfig.getClockTick();\n-    final static long IDLE_INTERVAL = ServerConfig.getIdleInterval();\n+    \/\/ schedule for the timer task that's responsible for idle connection management\n+    static final long IDLE_TIMER_TASK_SCHEDULE = ServerConfig.getIdleTimerScheduleMillis();\n+    static final int MAX_CONNECTIONS = ServerConfig.getMaxConnections();\n@@ -78,4 +105,18 @@\n-    final static long TIMER_MILLIS = ServerConfig.getTimerMillis ();\n-    final static long MAX_REQ_TIME=getTimeMillis(ServerConfig.getMaxReqTime());\n-    final static long MAX_RSP_TIME=getTimeMillis(ServerConfig.getMaxRspTime());\n-    final static boolean timer1Enabled = MAX_REQ_TIME != -1 || MAX_RSP_TIME != -1;\n+    \/\/ schedule for the timer task that's responsible for request\/response timeout management\n+    static final long REQ_RSP_TIMER_SCHEDULE = ServerConfig.getReqRspTimerScheduleMillis();\n+    static final long MAX_REQ_TIME = getTimeMillis(ServerConfig.getMaxReqTime());\n+    static final long MAX_RSP_TIME = getTimeMillis(ServerConfig.getMaxRspTime());\n+    static final boolean reqRspTimeoutEnabled = MAX_REQ_TIME != -1 || MAX_RSP_TIME != -1;\n+    \/\/ the maximum idle duration for a connection which is currently idle but has served\n+    \/\/ some request in the past\n+    static final long IDLE_INTERVAL = ServerConfig.getIdleIntervalMillis();\n+    \/\/ the maximum idle duration for a newly accepted connection which hasn't yet received\n+    \/\/ the first byte of data on that connection\n+    static final long NEWLY_ACCEPTED_CONN_IDLE_INTERVAL;\n+    static {\n+        \/\/ the idle duration of a newly accepted connection is considered to be the least of the\n+        \/\/ configured idle interval and the configured max request time (if any).\n+        NEWLY_ACCEPTED_CONN_IDLE_INTERVAL = MAX_REQ_TIME > 0\n+                ? Math.min(IDLE_INTERVAL, MAX_REQ_TIME)\n+                : IDLE_INTERVAL;\n+    }\n@@ -111,7 +152,7 @@\n-        time = System.currentTimeMillis();\n-        timer = new Timer (\"server-timer\", true);\n-        timer.schedule (new ServerTimerTask(), CLOCK_TICK, CLOCK_TICK);\n-        if (timer1Enabled) {\n-            timer1 = new Timer (\"server-timer1\", true);\n-            timer1.schedule (new ServerTimerTask1(),TIMER_MILLIS,TIMER_MILLIS);\n-            logger.config (\"HttpServer timer1 enabled period in ms:  \"+TIMER_MILLIS);\n+        newlyAcceptedConnections = Collections.synchronizedSet(new HashSet<>());\n+        timer = new Timer (\"idle-timeout-task\", true);\n+        timer.schedule (new IdleTimeoutTask(), IDLE_TIMER_TASK_SCHEDULE, IDLE_TIMER_TASK_SCHEDULE);\n+        if (reqRspTimeoutEnabled) {\n+            timer1 = new Timer (\"req-rsp-timeout-task\", true);\n+            timer1.schedule (new ReqRspTimeoutTask(), REQ_RSP_TIMER_SCHEDULE, REQ_RSP_TIMER_SCHEDULE);\n+            logger.config (\"HttpServer request\/response timeout task schedule ms: \"+REQ_RSP_TIMER_SCHEDULE);\n@@ -204,0 +245,1 @@\n+        newlyAcceptedConnections.clear();\n@@ -205,1 +247,1 @@\n-        if (timer1Enabled) {\n+        if (reqRspTimeoutEnabled) {\n@@ -259,4 +301,0 @@\n-    Selector getSelector () {\n-        return selector;\n-    }\n-\n@@ -272,0 +310,64 @@\n+    \/**\n+     * The Dispatcher is responsible for accepting any connections and then using those connections\n+     * to processing any incoming requests. A connection is represented as an instance of\n+     * sun.net.httpserver.HttpConnection.\n+     *\n+     * Connection states:\n+     *  An instance of HttpConnection goes through the following states:\n+     *\n+     *  - NEWLY_ACCEPTED: A connection is marked as newly accepted as soon as the Dispatcher\n+     *    accept()s a connection. A newly accepted connection is added to a newlyAcceptedConnections\n+     *    collection. A newly accepted connection also gets added to the allConnections collection.\n+     *    The newlyAcceptedConnections isn't checked for any size limits, however, if the server is\n+     *    configured with a maximum connection limit, then the elements in the\n+     *    newlyAcceptedConnections will never exceed that configured limit (no explicit size checks\n+     *    are done on the newlyAcceptedConnections collection, since the maximum connection limit\n+     *    applies to connections across different connection states). A connection in NEWLY_ACCEPTED\n+     *    state is considered idle and is eligible for idle connection management.\n+     *\n+     *  - REQUEST: A connection is marked to be in REQUEST state when the request processing starts\n+     *    on that connection. This typically happens when the first byte of data is received on a\n+     *    NEWLY_ACCEPTED connection or when new data arrives on a connection which was previously\n+     *    in IDLE state. When a connection is in REQUEST state, it implies that the connection is\n+     *    active and thus isn't eligible for idle connection management. If the server is configured\n+     *    with a maximum request timeout, then connections in REQUEST state are eligible\n+     *    for Request\/Response timeout management.\n+     *\n+     *  - RESPONSE: A connection is marked to be in RESPONSE state when the server has finished\n+     *    reading the request. A connection is RESPONSE state is considered active and isn't eligible\n+     *    for idle connection management. If the server is configured with a maximum response timeout,\n+     *    then connections in RESPONSE state are eligible for Request\/Response timeout management.\n+     *\n+     *  - IDLE: A connection is marked as IDLE when a request\/response cycle (successfully) completes\n+     *    on that particular connection. Idle connections are held in a idleConnections collection.\n+     *    The idleConnections collection is limited in size and the size is decided by a server\n+     *    configuration. Connections in IDLE state get added to the idleConnections collection only\n+     *    if that collection hasn't reached the configured limit. If a connection has reached IDLE\n+     *    state and there's no more room in the idleConnections collection, then such a connection\n+     *    gets closed. Connections in idleConnections collection are eligible for idle connection\n+     *    management.\n+     *\n+     * Idle connection management:\n+     *  A timer task is responsible for closing idle connections. Each connection that is in a state\n+     *  which is eligible for idle timeout management (see above section on connection states)\n+     *  will have a corresponding idle expiration time associated with it. The idle timeout management\n+     *  task will check the expiration time of each such connection against the current time and will\n+     *  close the connection if the current time is either equal to or past the expiration time.\n+     *\n+     * Request\/Response timeout management:\n+     *  The server can be optionally configured with a maximum request timeout and\/or maximum response\n+     *  timeout. If either of these timeouts have been configured, then an additional timer task is\n+     *  run by the server. This timer task is then responsible for closing connections which have\n+     *  been in REQUEST or RESPONSE state for a period of time that exceeds the respective configured\n+     *  timeouts.\n+     *\n+     * Maximum connection limit management:\n+     *  The server can be optionally configured with a maximum connection limit. A value of 0 or\n+     *  negative integer is ignored and considered to represent no connection limit. In case of a\n+     *  positive integer value, any newly accepted connections will be first checked against the\n+     *  current count of established connections (held by the allConnections collection) and if the\n+     *  configured limit has reached, then the newly accepted connection will be closed immediately\n+     *  (even before setting its state to NEWLY_ACCEPTED or adding it to the newlyAcceptedConnections\n+     *  collection).\n+     *\n+     *\/\n@@ -321,2 +423,1 @@\n-                c.time = getTime() + IDLE_INTERVAL;\n-                idleConnections.add (c);\n+                markIdle(c);\n@@ -365,0 +466,12 @@\n+                            \/\/ optimist there's a channel\n+                            if (chan != null) {\n+                                if (MAX_CONNECTIONS > 0 && allConnections.size() >= MAX_CONNECTIONS) {\n+                                    \/\/ we've hit max limit of current open connections, so we go\n+                                    \/\/ ahead and close this connection without processing it\n+                                    try {\n+                                        chan.close();\n+                                    } catch (IOException ignore) {\n+                                    }\n+                                    \/\/ move on to next selected key\n+                                    continue;\n+                                }\n@@ -366,7 +479,13 @@\n-                            \/\/ Set TCP_NODELAY, if appropriate\n-                            if (ServerConfig.noDelay()) {\n-                                chan.socket().setTcpNoDelay(true);\n-                            }\n-\n-                            if (chan == null) {\n-                                continue; \/* cancel something ? *\/\n+                                \/\/ Set TCP_NODELAY, if appropriate\n+                                if (ServerConfig.noDelay()) {\n+                                    chan.socket().setTcpNoDelay(true);\n+                                }\n+                                chan.configureBlocking (false);\n+                                SelectionKey newkey =\n+                                    chan.register (selector, SelectionKey.OP_READ);\n+                                HttpConnection c = new HttpConnection ();\n+                                c.selectionKey = newkey;\n+                                c.setChannel (chan);\n+                                newkey.attach (c);\n+                                markNewlyAccepted(c);\n+                                allConnections.add (c);\n@@ -374,8 +493,0 @@\n-                            chan.configureBlocking (false);\n-                            SelectionKey newkey = chan.register (selector, SelectionKey.OP_READ);\n-                            HttpConnection c = new HttpConnection ();\n-                            c.selectionKey = newkey;\n-                            c.setChannel (chan);\n-                            newkey.attach (c);\n-                            requestStarted (c);\n-                            allConnections.add (c);\n@@ -391,4 +502,6 @@\n-                                    if (idleConnections.remove(conn)) {\n-                                        \/\/ was an idle connection so add it\n-                                        \/\/ to reqConnections set.\n-                                        requestStarted (conn);\n+                                    if (newlyAcceptedConnections.remove(conn)\n+                                            || idleConnections.remove(conn)) {\n+                                        \/\/ was either a newly accepted connection or an idle\n+                                        \/\/ connection. In either case, we mark that the request\n+                                        \/\/ has now started on this connection.\n+                                        requestStarted(conn);\n@@ -474,0 +587,3 @@\n+        case NEWLY_ACCEPTED:\n+            newlyAcceptedConnections.remove(conn);\n+            break;\n@@ -478,0 +594,1 @@\n+        assert !newlyAcceptedConnections.remove(conn);\n@@ -633,1 +750,1 @@\n-                        int idle=(int)(ServerConfig.getIdleInterval()\/1000);\n+                        int idleSeconds = (int) (ServerConfig.getIdleIntervalMillis() \/ 1000);\n@@ -635,1 +752,1 @@\n-                        String val = \"timeout=\"+idle+\", max=\"+max;\n+                        String val = \"timeout=\"+idleSeconds+\", max=\"+max;\n@@ -771,8 +888,0 @@\n-    long getTicks() {\n-        return ticks;\n-    }\n-\n-    public long getTime() {\n-        return time;\n-    }\n-\n@@ -803,1 +912,1 @@\n-        c.creationTime = getTime();\n+        c.reqStartedTime = System.currentTimeMillis();\n@@ -808,0 +917,12 @@\n+    void markIdle(HttpConnection c) {\n+        c.idleStartTime = System.currentTimeMillis();\n+        c.setState(State.IDLE);\n+        idleConnections.add(c);\n+    }\n+\n+    void markNewlyAccepted(HttpConnection c) {\n+        c.idleStartTime = System.currentTimeMillis();\n+        c.setState(State.NEWLY_ACCEPTED);\n+        newlyAcceptedConnections.add(c);\n+    }\n+\n@@ -818,1 +939,1 @@\n-        c.rspStartedTime = getTime();\n+        c.rspStartedTime = System.currentTimeMillis();\n@@ -831,0 +952,1 @@\n+     * Responsible for closing connections that have been idle.\n@@ -833,1 +955,1 @@\n-    class ServerTimerTask extends TimerTask {\n+    class IdleTimeoutTask extends TimerTask {\n@@ -836,2 +958,1 @@\n-            time = System.currentTimeMillis();\n-            ticks ++;\n+            final long currentTime = System.currentTimeMillis();\n@@ -839,3 +960,6 @@\n-                for (HttpConnection c : idleConnections) {\n-                    if (c.time <= time) {\n-                        toClose.add (c);\n+                final Iterator<HttpConnection> it = idleConnections.iterator();\n+                while (it.hasNext()) {\n+                    final HttpConnection c = it.next();\n+                    if (currentTime - c.idleStartTime >= IDLE_INTERVAL) {\n+                        toClose.add(c);\n+                        it.remove();\n@@ -844,4 +968,18 @@\n-                for (HttpConnection c : toClose) {\n-                    idleConnections.remove (c);\n-                    allConnections.remove (c);\n-                    c.close();\n+            }\n+            \/\/ if any newly accepted connection has been idle (i.e. no byte has been sent on that\n+            \/\/ connection during the configured idle timeout period) then close it as well\n+            synchronized (newlyAcceptedConnections) {\n+                final Iterator<HttpConnection> it = newlyAcceptedConnections.iterator();\n+                while (it.hasNext()) {\n+                    final HttpConnection c = it.next();\n+                    if (currentTime - c.idleStartTime >= NEWLY_ACCEPTED_CONN_IDLE_INTERVAL) {\n+                        toClose.add(c);\n+                        it.remove();\n+                    }\n+                }\n+            }\n+            for (HttpConnection c : toClose) {\n+                allConnections.remove(c);\n+                c.close();\n+                if (logger.isLoggable(Level.FINER)) {\n+                    logger.log (Level.FINER, \"Closed idle connection \" + c);\n@@ -853,1 +991,4 @@\n-    class ServerTimerTask1 extends TimerTask {\n+    \/**\n+     * Responsible for closing connections which have timed out while in REQUEST or RESPONSE state\n+     *\/\n+    class ReqRspTimeoutTask extends TimerTask {\n@@ -858,1 +999,1 @@\n-            time = System.currentTimeMillis();\n+            final long currentTime = System.currentTimeMillis();\n@@ -862,1 +1003,1 @@\n-                        if (c.creationTime + TIMER_MILLIS + MAX_REQ_TIME <= time) {\n+                        if (currentTime - c.reqStartedTime >= MAX_REQ_TIME) {\n@@ -878,1 +1019,1 @@\n-                        if (c.rspStartedTime + TIMER_MILLIS +MAX_RSP_TIME <= time) {\n+                        if (currentTime - c.rspStartedTime >= MAX_RSP_TIME) {\n@@ -893,12 +1034,7 @@\n-    void logStackTrace (String s) {\n-        logger.finest (s);\n-        StringBuilder b = new StringBuilder ();\n-        StackTraceElement[] e = Thread.currentThread().getStackTrace();\n-        for (int i=0; i<e.length; i++) {\n-            b.append (e[i].toString()).append(\"\\n\");\n-        }\n-        logger.finest (b.toString());\n-    }\n-\n-    static long getTimeMillis(long secs) {\n-        if (secs == -1) {\n+    \/**\n+     * Converts and returns the passed {@code secs} as milli seconds. If the passed {@code secs}\n+     * is negative or zero or if the conversion from seconds to milli seconds results in a negative\n+     * number, then this method returns -1.\n+     *\/\n+    private static long getTimeMillis(long secs) {\n+        if (secs <= 0) {\n@@ -906,2 +1042,0 @@\n-        } else {\n-            return secs * 1000;\n@@ -909,0 +1043,3 @@\n+        final long milli = secs * 1000;\n+        \/\/ this handles potential numeric overflow that may have happened during conversion\n+        return milli > 0 ? milli : -1;\n","filename":"jdk\/src\/share\/classes\/sun\/net\/httpserver\/ServerImpl.java","additions":233,"deletions":96,"binary":false,"changes":329,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net.httpserver;\n-\n-interface TimeSource {\n-    public long getTime();\n-}\n","filename":"jdk\/src\/share\/classes\/sun\/net\/httpserver\/TimeSource.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -275,0 +275,3 @@\n+        if (length > buffer.available())\n+            throw new IOException(\"short read of an octet string\");\n+\n@@ -500,0 +503,4 @@\n+        if (length > buffer.available())\n+            throw new IOException(\"short read of \" +\n+                                  stringName + \" string\");\n+\n","filename":"jdk\/src\/share\/classes\/sun\/security\/util\/DerInputStream.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,3 @@\n+#define IS_MUL_OVERFLOW(m, n) \\\n+        ((m) != 0 && (n) != 0 && (((size_t)((m)*(n))) != (((size_t)(m)) * ((size_t)(n)))))\n+\n@@ -50,1 +53,3 @@\n-    (IS_SAFE_SIZE_T(m) && IS_SAFE_SIZE_T(n) && ((m) == 0 || (n) == 0 || (size_t)(n) <= (SIZE_MAX \/ (size_t)(m))))\n+    (IS_SAFE_SIZE_T(m) && IS_SAFE_SIZE_T(n) && \\\n+     ((m) == 0 || (n) == 0 || (size_t)(n) <= (SIZE_MAX \/ (size_t)(m))) && \\\n+     !IS_MUL_OVERFLOW(m, n))\n","filename":"jdk\/src\/share\/native\/common\/sizecalc.h","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -927,0 +927,6 @@\n+\n+    if (EC_ValidatePublicKey(ecParams, &key->publicValue, kmflag) != SECSuccess) {\n+        PORT_SetError(SEC_ERROR_BAD_KEY);\n+        goto cleanup;\n+    }\n+\n","filename":"jdk\/src\/share\/native\/sun\/security\/ec\/impl\/ec.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -284,1 +284,1 @@\n-        if (containerMetrics != null) {\n+        if (containerMetrics != null && containerMetrics.getCpuSetCpus() != null) {\n","filename":"jdk\/src\/solaris\/classes\/sun\/management\/OperatingSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -186,0 +186,1 @@\n+    NSString *nsVerStr = NULL;\n@@ -193,4 +194,12 @@\n-        NSString *nsVerStr;\n-        if (osVer.patchVersion == 0) { \/\/ Omit trailing \".0\"\n-            nsVerStr = [NSString stringWithFormat:@\"%ld.%ld\",\n-                    (long)osVer.majorVersion, (long)osVer.minorVersion];\n+\n+        \/\/ Copy out the char* if running on version other than 10.16 Mac OS (10.16 == 11.x)\n+        \/\/ or explicitly requesting version compatibility\n+        if (!((long)osVer.majorVersion == 10 && (long)osVer.minorVersion >= 16) ||\n+                (getenv(\"SYSTEM_VERSION_COMPAT\") != NULL)) {\n+            if (osVer.patchVersion == 0) { \/\/ Omit trailing \".0\"\n+                nsVerStr = [NSString stringWithFormat:@\"%ld.%ld\",\n+                        (long)osVer.majorVersion, (long)osVer.minorVersion];\n+            } else {\n+                nsVerStr = [NSString stringWithFormat:@\"%ld.%ld.%ld\",\n+                        (long)osVer.majorVersion, (long)osVer.minorVersion, (long)osVer.patchVersion];\n+            }\n@@ -198,2 +207,8 @@\n-            nsVerStr = [NSString stringWithFormat:@\"%ld.%ld.%ld\",\n-                    (long)osVer.majorVersion, (long)osVer.minorVersion, (long)osVer.patchVersion];\n+            \/\/ Version 10.16, without explicit env setting of SYSTEM_VERSION_COMPAT\n+            \/\/ AKA 11+ Read the *real* ProductVersion from the hidden link to avoid SYSTEM_VERSION_COMPAT\n+            \/\/ If not found, fallback below to the SystemVersion.plist\n+            NSDictionary *version = [NSDictionary dictionaryWithContentsOfFile :\n+                             @\"\/System\/Library\/CoreServices\/.SystemVersionPlatform.plist\"];\n+            if (version != NULL) {\n+                nsVerStr = [version objectForKey : @\"ProductVersion\"];\n+            }\n@@ -201,2 +216,0 @@\n-        \/\/ Copy out the char*\n-        osVersionCStr = strdup([nsVerStr UTF8String]);\n@@ -205,1 +218,1 @@\n-    if (osVersionCStr == NULL) {\n+    if (nsVerStr == NULL) {\n@@ -209,4 +222,1 @@\n-            NSString *nsVerStr = [version objectForKey : @\"ProductVersion\"];\n-            if (nsVerStr != NULL) {\n-                osVersionCStr = strdup([nsVerStr UTF8String]);\n-            }\n+            nsVerStr = [version objectForKey : @\"ProductVersion\"];\n@@ -215,0 +225,5 @@\n+\n+    if (nsVerStr != NULL) {\n+        \/\/ Copy out the char*\n+        osVersionCStr = strdup([nsVerStr UTF8String]);\n+    }\n","filename":"jdk\/src\/solaris\/native\/java\/lang\/java_props_macosx.c","additions":29,"deletions":14,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,4 @@\n+import jdk.testlibrary.OutputAnalyzer;\n+import jdk.testlibrary.ProcessTools;\n+import jdk.testlibrary.Utils;\n+\n@@ -26,4 +30,1 @@\n- * @summary Check that a double agent request fails\n- *\n- * @build VMConnection DoubleAgentTest Exit0\n- * @run main DoubleAgentTest\n+ * @summary Check that multiple -agentlib statements in command line fails\n@@ -31,0 +32,4 @@\n+ * @library \/lib\/testlibrary\n+ * @build jdk.testlibrary.*\n+ * @build DoubleAgentTest Exit0\n+ * @run driver DoubleAgentTest\n@@ -32,5 +37,0 @@\n-import java.io.InputStream;\n-import java.io.IOException;\n-import java.io.File;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n@@ -40,20 +40,2 @@\n-    static Object locker = new Object();\n-    static String outputText = \"\";\n-\n-    \/*\n-     * Helper class to redirect process output\/error\n-     *\/\n-    static class IOHandler implements Runnable {\n-        InputStream in;\n-\n-        IOHandler(InputStream in) {\n-            this.in = in;\n-        }\n-\n-        static Thread handle(InputStream in) {\n-            IOHandler handler = new IOHandler(in);\n-            Thread thr = new Thread(handler);\n-            thr.setDaemon(true);\n-            thr.start();\n-            return thr;\n-        }\n+    private static final String TEST_CLASSES = System.getProperty(\n+            \"test.classes\", \".\");\n@@ -61,24 +43,2 @@\n-        public void run() {\n-            try {\n-                byte b[] = new byte[100];\n-                for (;;) {\n-                    int n = in.read(b, 0, 100);\n-                    \/\/ The first thing that will get read is\n-                    \/\/    Listening for transport dt_socket at address: xxxxx\n-                    \/\/ which shows the debuggee is ready to accept connections.\n-                    synchronized(locker) {\n-                        locker.notify();\n-                    }\n-                    if (n < 0) {\n-                        break;\n-                    }\n-                    String s = new String(b, 0, n, \"UTF-8\");\n-                    System.out.print(s);\n-                    synchronized(outputText) {\n-                        outputText += s;\n-                    }\n-                }\n-            } catch (IOException ioe) {\n-                ioe.printStackTrace();\n-            }\n-        }\n+    public static void main(String[] args) throws Throwable {\n+        int port = Utils.getFreePort();\n@@ -86,8 +46,0 @@\n-    }\n-\n-    \/*\n-     * Launch a server debuggee with the given address\n-     *\/\n-    private static Process launch(String address, String class_name) throws IOException {\n-        String exe =   System.getProperty(\"java.home\")\n-                     + File.separator + \"bin\" + File.separator + \"java\";\n@@ -95,54 +47,1 @@\n-                         + \",server=y\" + \",suspend=y\" + \",address=\" + address;\n-        String cmd = exe + \" \" + VMConnection.getDebuggeeVMOptions()\n-                         + \" \" + jdwpOption\n-                         + \" \" + jdwpOption\n-                         + \" \" + class_name;\n-\n-        System.out.println(\"Starting: \" + cmd);\n-\n-        Process p = Runtime.getRuntime().exec(cmd);\n-\n-        return p;\n-    }\n-\n-    \/*\n-     * - pick a TCP port\n-     * - Launch a server debuggee that should fail\n-     * - verify we saw error\n-     *\/\n-    public static void main(String args[]) throws Exception {\n-        \/\/ find a free port\n-        ServerSocket ss = new ServerSocket(0);\n-        int port = ss.getLocalPort();\n-        ss.close();\n-\n-        String address = String.valueOf(port);\n-\n-        \/\/ launch the server debuggee\n-        Process process = launch(address, \"Exit0\");\n-        Thread t1 = IOHandler.handle(process.getInputStream());\n-        Thread t2 = IOHandler.handle(process.getErrorStream());\n-\n-        \/\/ wait for the debugge to be ready\n-        synchronized(locker) {\n-            locker.wait();\n-        }\n-\n-        int exitCode = process.waitFor();\n-        try {\n-            t1.join();\n-            t2.join();\n-        } catch ( InterruptedException e ) {\n-            e.printStackTrace();\n-            throw new Exception(\"Debuggee failed InterruptedException\");\n-        }\n-\n-        if ( outputText.contains(\"capabilities\") ) {\n-            throw new Exception(\n-                \"Debuggee failed with ERROR about capabilities: \" + outputText);\n-        }\n-\n-        if ( !outputText.contains(\"ERROR\") ) {\n-            throw new Exception(\n-                \"Debuggee does not have ERROR in the output: \" + outputText);\n-        }\n+                         + \",server=y\" + \",suspend=n\" + \",address=*:\" + String.valueOf(port);\n@@ -150,4 +49,5 @@\n-        if ( exitCode == 0 ) {\n-            throw new Exception(\n-                \"Debuggee should have failed with an non-zero exit code\");\n-        }\n+        OutputAnalyzer output = ProcessTools.executeTestJvm(\"-classpath\",\n+                TEST_CLASSES,\n+                jdwpOption, \/\/ Notice jdwpOption specified twice\n+                jdwpOption,\n+                \"Exit0\");\n@@ -155,0 +55,2 @@\n+        output.shouldContain(\"Cannot load this JVM TI agent twice\");\n+        output.shouldHaveExitValue(1);\n","filename":"jdk\/test\/com\/sun\/jdi\/DoubleAgentTest.java","additions":22,"deletions":120,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -204,3 +204,3 @@\n-            # Don't use ps on cygwin since it sometimes misses\n-            # some processes (!).\n-            tasklist \/NH | $grep \" $1 \" > $devnull 2>&1\n+            # No longer possible to use tasklist as Cygwin PIDs are no longer\n+            # same as Windows PIDs\n+            $psCmd | $grep '^ *'\"$1 \" > $devnull 2>&1\n@@ -284,1 +284,1 @@\n-         psCmd=ps\n+         psCmd=\"ps -W\"\n","filename":"jdk\/test\/com\/sun\/jdi\/ShellScaffold.sh","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @run main\/othervm -Dsun.net.httpserver.maxReqTime=2 Test\n+ * @run main\/othervm -Dsun.net.httpserver.maxReqTime=2 -Dsun.net.httpserver.clockTick=2000 Test\n","filename":"jdk\/test\/com\/sun\/net\/httpserver\/bugs\/6725892\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.File;\n+\n+\/**\n+ * @test\n+ * @bug 8290832\n+ * @summary It should be possible to change the \"user.dir\" property\n+ * @run main\/othervm ChangeDefaultUserDir\n+ *\/\n+public final class ChangeDefaultUserDir {\n+    public static void main(String[] args) throws Exception {\n+        String keyUserDir = \"user.dir\";\n+        String userDirNew = \"\/home\/user\/\";\n+        String fileName = \"file\";\n+\n+        String userDir = System.getProperty(keyUserDir);\n+        System.out.format(\"%24s %48s%n\", \"Default 'user.dir' = \", userDir);\n+        File file = new File(fileName);\n+        String canFilePath = file.getCanonicalPath();\n+\n+        System.setProperty(keyUserDir, userDirNew);\n+        String newCanFilePath = file.getCanonicalPath();\n+        System.out.format(\"%24s %48s%n\", \"Canonical Path = \", canFilePath);\n+        System.out.format(\"%24s %48s%n\", \"new Canonical Path = \", newCanFilePath);\n+        if (canFilePath.equals(newCanFilePath)) {\n+            throw new RuntimeException(\"Cannot change user.dir property\");\n+        }\n+    }\n+}\n","filename":"jdk\/test\/java\/io\/File\/ChangeDefaultUserDir.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282252\n+ * @summary Test constructors of BigDecimal to replace BigInteger subclasses\n+ *\/\n+\n+import java.math.*;\n+\n+public class ConstructorUnscaledValue {\n+    public static void main(String... args) {\n+        TestBigInteger tbi = new TestBigInteger(BigInteger.ONE);\n+        \/\/ Create BigDecimal's using each of the three constructors\n+        \/\/ with guards on the class of unscaledValue\n+        BigDecimal[] values = {\n+            new BigDecimal(tbi),\n+            new BigDecimal(tbi, 2),\n+            new BigDecimal(tbi, 3, MathContext.DECIMAL32),\n+        };\n+\n+        for (BigDecimal bd : values) {\n+            BigInteger unscaledValue = bd.unscaledValue();\n+            if (unscaledValue.getClass() != BigInteger.class) {\n+                throw new RuntimeException(\"Bad class for unscaledValue\");\n+            }\n+            if (!unscaledValue.equals(BigInteger.ONE)) {\n+                throw new RuntimeException(\"Bad value for unscaledValue\");\n+            }\n+        }\n+    }\n+\n+    private static class TestBigInteger extends BigInteger {\n+        public TestBigInteger(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return java.util.Arrays.toString(toByteArray());\n+        }\n+    }\n+}\n","filename":"jdk\/test\/java\/math\/BigDecimal\/ConstructorUnscaledValue.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6177836\n+ * @bug 6177836 8282252\n@@ -28,1 +28,0 @@\n- * @author Joseph D. Darcy\n@@ -33,0 +32,2 @@\n+import java.util.Arrays;\n+import java.util.List;\n@@ -36,1 +37,11 @@\n-    static void checkSerialForm(BigDecimal bd) throws Exception  {\n+    public static void main(String... args) throws Exception {\n+        checkBigDecimalSerialRoundTrip();\n+        checkBigDecimalSubSerialRoundTrip();\n+    }\n+\n+    private static void checkSerialForm(BigDecimal bd) throws Exception  {\n+        checkSerialForm0(bd);\n+        checkSerialForm0(bd.negate());\n+    }\n+\n+    private static void checkSerialForm0(BigDecimal bd) throws Exception  {\n@@ -38,4 +49,5 @@\n-        ObjectOutputStream oos = new ObjectOutputStream(bos);\n-        oos.writeObject(bd);\n-        oos.flush();\n-        oos.close();\n+        try(ObjectOutputStream oos = new ObjectOutputStream(bos)) {\n+            oos.writeObject(bd);\n+            oos.flush();\n+        }\n+\n@@ -47,1 +59,5 @@\n-            bd.hashCode() != tmp.hashCode()) {\n+            bd.hashCode() != tmp.hashCode() ||\n+            bd.getClass() != tmp.getClass() ||\n+            \/\/ Directly test equality of components\n+            bd.scale() != tmp.scale() ||\n+            !bd.unscaledValue().equals(tmp.unscaledValue())) {\n@@ -54,0 +70,9 @@\n+\n+        \/\/ If the class of the deserialized number is BigDecimal,\n+        \/\/ verify the implementation constraint on the unscaled value\n+        \/\/ having BigInteger class\n+        if (tmp.getClass() == BigDecimal.class) {\n+            if (tmp.unscaledValue().getClass() != BigInteger.class) {\n+                throw new RuntimeException(\"Not using genuine BigInteger as an unscaled value\");\n+            }\n+        }\n@@ -56,13 +81,27 @@\n-    public static void main(String[] args) throws Exception {\n-        BigDecimal values[] = {\n-            BigDecimal.ZERO,\n-            BigDecimal.ONE,\n-            BigDecimal.TEN,\n-            new BigDecimal(0),\n-            new BigDecimal(1),\n-            new BigDecimal(10),\n-            new BigDecimal(Integer.MAX_VALUE),\n-            new BigDecimal(Long.MAX_VALUE-1),\n-            new BigDecimal(BigInteger.valueOf(1), 1),\n-            new BigDecimal(BigInteger.valueOf(100), 50),\n-        };\n+    private static class BigIntegerSub extends BigInteger {\n+        public BigIntegerSub(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return java.util.Arrays.toString(toByteArray());\n+        }\n+    }\n+    private static void checkBigDecimalSerialRoundTrip() throws Exception {\n+        List<BigDecimal> values =\n+            Arrays.asList(BigDecimal.ZERO,\n+                    BigDecimal.ONE,\n+                    BigDecimal.TEN,\n+                    new BigDecimal(0),\n+                    new BigDecimal(1),\n+                    new BigDecimal(10),\n+                    new BigDecimal(Integer.MAX_VALUE),\n+                    new BigDecimal(Long.MAX_VALUE-1),\n+                    new BigDecimal(BigInteger.valueOf(1), 1),\n+                    new BigDecimal(BigInteger.valueOf(100), 50),\n+                    new BigDecimal(new BigInteger(\"9223372036854775808\"), \/\/ Long.MAX_VALUE + 1\n+                                   Integer.MAX_VALUE),\n+                    new BigDecimal(new BigInteger(\"9223372036854775808\"), \/\/ Long.MAX_VALUE + 1\n+                                   Integer.MIN_VALUE),\n+                    new BigDecimal(new BigIntegerSub(BigInteger.ONE), 2));\n@@ -72,1 +111,0 @@\n-            checkSerialForm(value.negate());\n@@ -74,0 +112,1 @@\n+    }\n@@ -75,0 +114,35 @@\n+    private static class BigDecimalSub extends BigDecimal {\n+        public BigDecimalSub(BigDecimal bd) {\n+            super(bd.unscaledValue(), bd.scale());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return unscaledValue() + \"x10^\" + (-scale());\n+        }\n+    }\n+\n+    \/\/ Subclass defining a serialVersionUID\n+    private static class BigDecimalSubSVUID extends BigDecimal {\n+        private static long serialVesionUID = 0x0123_4567_89ab_cdefL;\n+\n+        public BigDecimalSubSVUID(BigDecimal bd) {\n+            super(bd.unscaledValue(), bd.scale());\n+        }\n+    }\n+\n+    private static void checkBigDecimalSubSerialRoundTrip() throws Exception {\n+        List<BigDecimal> values =\n+            Arrays.asList(BigDecimal.ZERO,\n+                    BigDecimal.ONE,\n+                    BigDecimal.TEN,\n+                    new BigDecimal(BigInteger.TEN, 1234),\n+                    new BigDecimal(new BigInteger(\"9223372036854775808\"), \/\/ Long.MAX_VALUE + 1\n+                                   Integer.MAX_VALUE),\n+                    new BigDecimal(new BigInteger(\"9223372036854775808\"), \/\/ Long.MAX_VALUE + 1\n+                                   Integer.MIN_VALUE));\n+\n+        for(BigDecimal value : values) {\n+            checkSerialForm(new BigDecimalSub(value));\n+            checkSerialForm(new BigDecimalSubSVUID(value));\n+        }\n","filename":"jdk\/test\/java\/math\/BigDecimal\/SerializationTests.java","additions":97,"deletions":23,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282252\n+ * @summary Verify BigInteger objects are serialized properly.\n+ *\/\n+\n+import java.math.*;\n+import java.io.*;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class SerializationTests {\n+\n+    public static void main(String... args) throws Exception {\n+        checkBigIntegerSerialRoundTrip();\n+        checkBigIntegerSubSerialRoundTrip();\n+    }\n+\n+    private static void checkSerialForm(BigInteger bi) throws Exception {\n+        checkSerialForm0(bi);\n+        checkSerialForm0(bi.negate());\n+    }\n+\n+    private static void checkSerialForm0(BigInteger bi) throws Exception  {\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        try(ObjectOutputStream oos = new ObjectOutputStream(bos)) {\n+            oos.writeObject(bi);\n+            oos.flush();\n+        }\n+\n+        ObjectInputStream ois = new\n+            ObjectInputStream(new ByteArrayInputStream(bos.toByteArray()));\n+        BigInteger tmp = (BigInteger)ois.readObject();\n+\n+        if (!bi.equals(tmp) ||\n+            bi.hashCode() != tmp.hashCode() ||\n+            bi.getClass() != tmp.getClass() ||\n+            \/\/ For extra measure, directly test equality of components\n+            bi.signum() != tmp.signum() ||\n+            !Arrays.equals(bi.toByteArray(), (tmp.toByteArray())) ) {\n+            System.err.print(\"  original : \" + bi);\n+            System.err.println(\" (hash: 0x\" + Integer.toHexString(bi.hashCode()) + \")\");\n+            System.err.print(\"serialized : \" + tmp);\n+            System.err.println(\" (hash: 0x\" + Integer.toHexString(tmp.hashCode()) + \")\");\n+            throw new RuntimeException(\"Bad serial roundtrip\");\n+        }\n+    }\n+\n+    private static void checkBigIntegerSerialRoundTrip() throws Exception {\n+        List<BigInteger> values =\n+            Arrays.asList(BigInteger.ZERO,\n+                    BigInteger.ONE,\n+                    BigInteger.valueOf(2),\n+                    BigInteger.TEN,\n+                    BigInteger.valueOf(100),\n+                    BigInteger.valueOf(Integer.MAX_VALUE),\n+                    BigInteger.valueOf(Long.MAX_VALUE-1),\n+                    new BigInteger(\"9223372036854775808\")); \/\/ Long.MAX_VALUE + 1\n+\n+        for(BigInteger value : values) {\n+            checkSerialForm(value);\n+        }\n+    }\n+\n+    \/\/ Subclass with specialized toString output\n+    private static class BigIntegerSub extends BigInteger {\n+        public BigIntegerSub(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Arrays.toString(toByteArray());\n+        }\n+    }\n+\n+    \/\/ Subclass defining a serialVersionUID\n+    private static class BigIntegerSubSVUID extends BigInteger {\n+        private static long serialVesionUID = 0x0123_4567_89ab_cdefL;\n+\n+        public BigIntegerSubSVUID(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return Arrays.toString(toByteArray());\n+        }\n+    }\n+\n+    \/\/ Subclass defining writeReplace\n+    private static class BigIntegerSubWR extends BigInteger {\n+        public BigIntegerSubWR(BigInteger bi) {\n+            super(bi.toByteArray());\n+        }\n+\n+        \/\/ Just return this; could use a serial proxy instead\n+        private Object writeReplace() throws ObjectStreamException {\n+            return this;\n+        }\n+    }\n+\n+\n+    private static void checkBigIntegerSubSerialRoundTrip() throws Exception {\n+        List<BigInteger> values = Arrays.asList(\n+                             BigInteger.ZERO,\n+                             BigInteger.ONE,\n+                             BigInteger.TEN,\n+                             new BigInteger(\"9223372036854775808\")); \/\/ Long.MAX_VALUE + 1\n+\n+        for(BigInteger value : values) {\n+            checkSerialForm(new BigIntegerSub(value));\n+            checkSerialForm(new BigIntegerSubSVUID(value));\n+            checkSerialForm(new BigIntegerSubWR(value));\n+        }\n+    }\n+}\n","filename":"jdk\/test\/java\/math\/BigInteger\/SerializationTests.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8060126\n+ * @summary Make sure that the tzdata version matches between the run-time and tests.\n+ *\/\n+import java.time.zone.ZoneRules;\n+import java.time.zone.ZoneRulesProvider;\n+import java.util.NavigableMap;\n+\n+public class AssureTzdataVersion {\n+    public static void main(String... args) throws Exception {\n+        \/\/ get the tzdata version for the run-time\n+        NavigableMap<String, ZoneRules> map;\n+        map = ZoneRulesProvider.getVersions(\"America\/Los_Angeles\");\n+        if (map.isEmpty()) {\n+            throw new RuntimeException(\"Unknown runtime tzdata version\");\n+        }\n+        String runtime = map.lastEntry().getKey();\n+\n+        \/\/ get the tzdata version for regression tests\n+        String testdata = null;\n+        try (TextFileReader textreader = new TextFileReader(\"VERSION\")) {\n+            testdata = textreader.getLine().substring(\"tzdata\".length());\n+        }\n+        if (!testdata.equals(runtime)) {\n+            throw new RuntimeException(\"tzdata versions don't match: run-time=\" + runtime\n+                                       + \", tests=\" + testdata);\n+        }\n+    }\n+}\n","filename":"jdk\/test\/java\/util\/TimeZone\/AssureTzdataVersion.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6329116 6756569 6757131 6758988 6764308 6796489 6834474 6609737 6507067\n+ *      7039469 7090843 7103108 7103405 7158483 8008577 8059206 8064560 8072042\n+ *      8077685 8151876 8166875 8169191 8170316 8176044\n+ * @summary Make sure that timezone short display names are idenical to Olson's data.\n+ * @library \/java\/text\/testlib\n+ * @build Bug6329116 TextFileReader\n+ * @run main\/othervm -Djava.locale.providers=COMPAT,SPI Bug6329116\n+ *\/\n+\n+import java.io.*;\n+import java.text.*;\n+import java.util.*;\n+\n+public class Bug6329116 extends IntlTest {\n+\n+    static Locale[] locales = Locale.getAvailableLocales();\n+    static String[] timezones = TimeZone.getAvailableIDs();\n+\n+    public static void main(String[] args) throws IOException {\n+        if (bug6329116()) {\n+            throw new RuntimeException(\"At least one timezone display name is incorrect.\");\n+        }\n+    }\n+\n+    static boolean bug6329116() throws IOException {\n+        boolean err = false;\n+\n+        HashMap<String, String> aliasTable = new HashMap<>();\n+        HashSet<String> timezoneTable = new HashSet<>();\n+        for (String t : timezones) {\n+            timezoneTable.add(t);\n+        }\n+\n+        String line, key, value;\n+        StringTokenizer st;\n+\n+        try (TextFileReader in = new TextFileReader(\"aliases.txt\")) {\n+            while ((line = in.readLine()) != null) {\n+                st = new StringTokenizer(line);\n+                st.nextToken();\n+                key = st.nextToken();\n+                value = st.nextToken();\n+\n+                if (!value.equals(\"ROC\")) {\n+                    if (aliasTable.containsKey(key)) {\n+                        aliasTable.put(key, aliasTable.get(key) + \" \" + value);\n+                    } else {\n+                        aliasTable.put(key, value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        try (TextFileReader in = new TextFileReader(\"displaynames.txt\")) {\n+            String timezoneID, expected, expected_DST, got;\n+            String[] aliases, tzs;\n+            TimeZone tz;\n+            while ((line = in.readLine()) != null) {\n+                st = new StringTokenizer(line);\n+                timezoneID = st.nextToken();\n+                expected = st.nextToken();\n+                if (st.hasMoreTokens()) {\n+                    expected_DST = st.nextToken();\n+                } else {\n+                    expected_DST = null;\n+                }\n+\n+                if (aliasTable.containsKey(timezoneID)) {\n+                    aliases = aliasTable.get(timezoneID).split(\" \");\n+                    tzs = new String[1 + aliases.length];\n+                    System.arraycopy(aliases, 0, tzs, 1, aliases.length);\n+                    aliasTable.remove(timezoneID);\n+                } else {\n+                    tzs = new String[1];\n+                }\n+                tzs[0] = timezoneID;\n+\n+                for (int j = 0; j < tzs.length; j++) {\n+                    tz = TimeZone.getTimeZone(tzs[j]);\n+\n+                    if (!tzs[j].equals(tz.getID())) {\n+                        System.err.println(tzs[j] + \" may not be a valid Timezone ID and \\\"\" + tz.getID() + \"\\\" was returned. Please check it.\");\n+                        err = true;\n+                    }\n+\n+                    timezoneTable.remove(tzs[j]);\n+\n+                    for (int i = 0; i < locales.length; i++) {\n+                        got = tz.getDisplayName(false, TimeZone.SHORT, locales[i]);\n+                        if (!expected.equals(got) &&\n+                            !expected.startsWith(got + \"\/\") &&\n+                            !expected.endsWith(\"\/\" + got)) {\n+                            if (useLocalzedShortDisplayName(tz, locales[i], got, false)) {\n+\/*\n+                                System.out.println(tzs[j] +\n+                                                   ((j > 0) ? \"(Alias of \\\"\" + tzs[0] + \"\\\")\" : \"\") +\n+                                                   \" seems to use a localized short display name\" +\n+                                                   \": original: \" + expected +\n+                                                   \": got: \" + got + \" for non-DST in \" +\n+                                                   locales[i] + \" locale.\");\n+*\/\n+                            } else {\n+                                System.err.println(tzs[j] +\n+                                                   ((j > 0) ? \"(Alias of \\\"\" + tzs[0] + \"\\\")\" : \"\") +\n+                                                   \": expected: \" + expected +\n+                                                   \": got: \" + got + \" for non-DST in \" +\n+                                                   locales[i] + \" locale.\");\n+                                err = true;\n+                            }\n+                        }\n+\n+                        got = tz.getDisplayName(true, TimeZone.SHORT, locales[i]);\n+                        if (expected_DST != null) {\n+                            if (!expected_DST.equals(got) &&\n+                                !expected_DST.startsWith(got + \"\/\") &&\n+                                !expected_DST.endsWith(\"\/\" + got)) {\n+                                if (tzs[j].equals(\"Europe\/London\") &&\n+                                    locales[i].equals(new Locale(\"en\", \"IE\"))) {\n+                                    continue;\n+                                } else if (useLocalzedShortDisplayName(tz, locales[i], got, true)) {\n+\/*\n+                                System.out.println(tzs[j] +\n+                                    ((j > 0) ? \"(Alias of \\\"\" + tzs[0] + \"\\\")\" : \"\") +\n+                                    \" seems to use a localized short display name\" +\n+                                    \": original: \" + expected_DST +\n+                                    \": got: \" + got + \" for DST in \" +\n+                                    locales[i] + \" locale.\");\n+*\/\n+                                    continue;\n+                                }\n+                                System.err.println(tzs[j] +\n+                                                   ((j > 0) ? \"(Alias of \\\"\" + tzs[0] + \"\\\")\" : \"\") +\n+                                                   \": expected: \" + expected_DST +\n+                                                   \": got: \" + got + \" for DST in \" +\n+                                                   locales[i] + \" locale.\");\n+                                err = true;\n+                            }\n+                        } else {\n+                            \/\/ Some timezones don't have DST display names in Olson's data,\n+                            \/\/ and we created them ourselves based on non-DST display names\n+                            \/\/ to prepare potential use in the future.\n+                            \/\/ Because there's no expected name, we don't judge if these\n+                            \/\/ DST display names are correct but just compare them with\n+                            \/\/ non-DST diplay names for checking with our eyes .\n+                            if (!expected.equals(got) &&\n+                                !expected.startsWith(got + \"\/\") &&\n+                                !expected.endsWith(\"\/\" + got)) {\n+\/*\n+                                System.out.println(\"## \" + tzs[j] +\n+                                                   ((j > 0) ? \"(Alias of \\\"\" + tzs[0] + \"\\\")\" : \"\") +\n+                                                   \": expected: \" + expected +\n+                                                   \": got: \" + got + \" for DST in \" +\n+                                                   locales[i] + \" locale.\");\n+*\/\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (!timezoneTable.isEmpty()) {\n+            System.out.println(\"# Timezone(s) valid in JRE but untested in this test program:\");\n+            Iterator<String> it = timezoneTable.iterator();\n+            while (it.hasNext()) {\n+                System.out.println(it.next());\n+            }\n+            System.out.println();\n+        }\n+\n+        if (!aliasTable.isEmpty()) {\n+            System.out.println(\"# Timezone(s) exists in Olson's data as Link but unused in JRE:\");\n+            for (Map.Entry<String, String> entry : aliasTable.entrySet()) {\n+                System.out.println(entry);\n+            }\n+        }\n+\n+        return err;\n+    }\n+\n+    static boolean useLocalzedShortDisplayName(TimeZone tz,\n+                                               Locale locale,\n+                                               String got,\n+                                               boolean inDST) {\n+        if (locale.getLanguage().equals(\"de\")) {\n+            String name = tz.getDisplayName(inDST, TimeZone.LONG, locale);\n+            if (inDST) {\n+                if ((\"Mitteleurop\\u00e4ische Sommerzeit\".equals(name) && \"MESZ\".equals(got)) ||\n+                    (\"Osteurop\\u00e4ische Sommerzeit\".equals(name) && \"OESZ\".equals(got)) ||\n+                    (\"Westeurop\\u00e4ische Sommerzeit\".equals(name) && \"WESZ\".equals(got))) {\n+                    return true;\n+                }\n+            } else {\n+                if ((\"Mitteleurop\\u00e4ische Zeit\".equals(name) && \"MEZ\".equals(got)) ||\n+                    (\"Osteurop\\u00e4ische Zeit\".equals(name) && \"OEZ\".equals(got)) ||\n+                    (\"Westeurop\\u00e4ische Zeit\".equals(name) && \"WEZ\".equals(got))) {\n+                    return true;\n+                }\n+            }\n+        } else if (locale.getLanguage().equals(\"zh\") &&\n+            (locale.getCountry().equals(\"TW\") || locale.getCountry().equals(\"HK\"))) {\n+            String name = tz.getDisplayName(inDST, TimeZone.LONG, locale);\n+            if (inDST) {\n+                if ((\"\\u53f0\\u7063\\u590f\\u4ee4\\u6642\\u9593\".equals(name) && \"TDT\".equals(got))) {\n+                    return true;\n+                }\n+            } else {\n+                if ((\"\\u53f0\\u7063\\u6a19\\u6e96\\u6642\\u9593\".equals(name) && \"TST\".equals(got))) {\n+                    return true;\n+                }\n+            }\n+        }\n+        \/\/ If we get a TimeZone with GMT+hh:mm format, we can ignore the offset value\n+        if (tz.getDisplayName(Locale.ENGLISH).startsWith(\"GMT+\") || tz.getDisplayName(Locale.ENGLISH).startsWith(\"GMT-\")) {\n+            return tz.getDisplayName().substring(0, 3).equals(got.substring(0, 3));\n+        }\n+\n+        return false;\n+    }\n+\n+}\n","filename":"jdk\/test\/java\/util\/TimeZone\/Bug6329116.java","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+\n+\/\/ This class is public so that tools can invoke.\n+public class TextFileReader implements AutoCloseable {\n+    private BufferedReader reader;\n+    private int lineNo;\n+\n+    public TextFileReader(String filename) throws IOException {\n+        this(new File(new File(System.getProperty(\"test.src\", \".\"),\n+                               \"TimeZoneData\"),\n+                      filename));\n+    }\n+\n+    public TextFileReader(File file) throws IOException {\n+        InputStream is = new FileInputStream(file);\n+        reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n+    }\n+\n+    public String readLine() throws IOException {\n+        return getLine();\n+    }\n+\n+    public String getLine() throws IOException {\n+        checkReader();\n+\n+        String line;\n+        while ((line = reader.readLine()) != null) {\n+            lineNo++;\n+            line = line.trim();\n+            \/\/ Skip blank and comment lines.\n+            if (line.length() == 0) {\n+                continue;\n+            }\n+            int x = line.indexOf('#');\n+            if (x == 0) {\n+                    continue;\n+            }\n+            if (x > 0) {\n+                line = line.substring(0, x).trim();\n+            }\n+            break;\n+        }\n+        return line;\n+    }\n+\n+    public String getRawLine() throws IOException {\n+        checkReader();\n+\n+        String line = reader.readLine();\n+        if (line != null) {\n+            lineNo++;\n+        }\n+        return line;\n+    }\n+\n+    private void checkReader() throws IOException {\n+        if (reader == null) {\n+            throw new IOException(\"This TextFileReader has been closed.\");\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        reader.close();\n+        reader = null;\n+    }\n+\n+    int getLineNo() {\n+        return lineNo;\n+    }\n+}\n","filename":"jdk\/test\/java\/util\/TimeZone\/TextFileReader.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,1 @@\n+tzdata2022c\n","filename":"jdk\/test\/java\/util\/TimeZone\/TimeZoneData\/VERSION","additions":1,"deletions":0,"binary":false,"changes":1,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+Link Africa\/Abidjan Africa\/Accra\t# Ghana\n+Link Africa\/Abidjan Africa\/Bamako\t# Mali\n+Link Africa\/Abidjan Africa\/Banjul\t# The Gambia\n+Link Africa\/Abidjan Africa\/Conakry\t# Guinea\n+Link Africa\/Abidjan Africa\/Dakar\t# Senegal\n+Link Africa\/Abidjan Africa\/Freetown\t# Sierra Leone\n+Link Africa\/Abidjan Africa\/Lome\t\t# Togo\n+Link Africa\/Abidjan Africa\/Nouakchott\t# Mauritania\n+Link Africa\/Abidjan Africa\/Ouagadougou\t# Burkina Faso\n+Link Africa\/Abidjan Atlantic\/Reykjavik\t# Iceland\n+Link Africa\/Abidjan Atlantic\/St_Helena\t# St Helena\n+Link Africa\/Nairobi Africa\/Addis_Ababa\t # Ethiopia\n+Link Africa\/Nairobi Africa\/Asmara\t # Eritrea\n+Link Africa\/Nairobi Africa\/Dar_es_Salaam # Tanzania\n+Link Africa\/Nairobi Africa\/Djibouti\n+Link Africa\/Nairobi Africa\/Kampala\t # Uganda\n+Link Africa\/Nairobi Africa\/Mogadishu\t # Somalia\n+Link Africa\/Nairobi Indian\/Antananarivo\t # Madagascar\n+Link Africa\/Nairobi Indian\/Comoro\n+Link Africa\/Nairobi Indian\/Mayotte\n+Link Africa\/Maputo Africa\/Blantyre\t# Malawi\n+Link Africa\/Maputo Africa\/Bujumbura\t# Burundi\n+Link Africa\/Maputo Africa\/Gaborone\t# Botswana\n+Link Africa\/Maputo Africa\/Harare\t# Zimbabwe\n+Link Africa\/Maputo Africa\/Kigali\t# Rwanda\n+Link Africa\/Maputo Africa\/Lubumbashi\t# E Dem. Rep. of Congo\n+Link Africa\/Maputo Africa\/Lusaka\t# Zambia\n+Link Africa\/Lagos Africa\/Bangui\t\t# Central African Republic\n+Link Africa\/Lagos Africa\/Brazzaville\t# Rep. of the Congo\n+Link Africa\/Lagos Africa\/Douala\t\t# Cameroon\n+Link Africa\/Lagos Africa\/Kinshasa\t# Dem. Rep. of the Congo (west)\n+Link Africa\/Lagos Africa\/Libreville\t# Gabon\n+Link Africa\/Lagos Africa\/Luanda\t\t# Angola\n+Link Africa\/Lagos Africa\/Malabo\t\t# Equatorial Guinea\n+Link Africa\/Lagos Africa\/Niamey\t\t# Niger\n+Link Africa\/Lagos Africa\/Porto-Novo\t# Benin\n+Link Africa\/Johannesburg Africa\/Maseru\t# Lesotho\n+Link Africa\/Johannesburg Africa\/Mbabane\t# Eswatini\n+Link Asia\/Yangon Indian\/Cocos\n+Link Asia\/Urumqi Antarctica\/Vostok\n+Link\tAsia\/Nicosia\tEurope\/Nicosia\n+Link Asia\/Kuching Asia\/Brunei\n+Link Indian\/Maldives Indian\/Kerguelen\n+Link Asia\/Qatar Asia\/Bahrain\n+Link Asia\/Riyadh Antarctica\/Syowa\n+Link Asia\/Riyadh Asia\/Aden\t# Yemen\n+Link Asia\/Riyadh Asia\/Kuwait\n+Link Asia\/Singapore Asia\/Kuala_Lumpur\n+Link Asia\/Bangkok Asia\/Phnom_Penh\t# Cambodia\n+Link Asia\/Bangkok Asia\/Vientiane\t# Laos\n+Link Asia\/Bangkok Indian\/Christmas\n+Link Asia\/Dubai Asia\/Muscat\t# Oman\n+Link Asia\/Dubai Indian\/Mahe\n+Link Asia\/Dubai Indian\/Reunion\n+Link Pacific\/Guam Pacific\/Saipan # N Mariana Is\n+Link Pacific\/Tarawa Pacific\/Funafuti\n+Link Pacific\/Tarawa Pacific\/Majuro\n+Link Pacific\/Tarawa Pacific\/Wake\n+Link Pacific\/Tarawa Pacific\/Wallis\n+Link Pacific\/Auckland Antarctica\/McMurdo\n+Link Pacific\/Port_Moresby Antarctica\/DumontDUrville\n+Link Pacific\/Port_Moresby Pacific\/Chuuk\n+Link Pacific\/Pago_Pago Pacific\/Midway # in US minor outlying islands\n+Link Pacific\/Guadalcanal Pacific\/Pohnpei\n+Link\tEurope\/London\tEurope\/Jersey\n+Link\tEurope\/London\tEurope\/Guernsey\n+Link\tEurope\/London\tEurope\/Isle_of_Man\n+Link Europe\/Brussels Europe\/Amsterdam\n+Link Europe\/Brussels Europe\/Luxembourg\n+Link Europe\/Prague Europe\/Bratislava\n+Link\tEurope\/Helsinki\tEurope\/Mariehamn\n+Link Europe\/Paris Europe\/Monaco\n+Link Europe\/Berlin Arctic\/Longyearbyen\n+Link Europe\/Berlin Europe\/Copenhagen\n+Link Europe\/Berlin Europe\/Oslo\n+Link Europe\/Berlin Europe\/Stockholm\n+Link Europe\/Rome Europe\/Vatican\n+Link Europe\/Rome Europe\/San_Marino\n+Link Europe\/Belgrade Europe\/Ljubljana\t# Slovenia\n+Link Europe\/Belgrade Europe\/Podgorica\t# Montenegro\n+Link Europe\/Belgrade Europe\/Sarajevo\t# Bosnia and Herzegovina\n+Link Europe\/Belgrade Europe\/Skopje\t# North Macedonia\n+Link Europe\/Belgrade Europe\/Zagreb\t# Croatia\n+Link Europe\/Zurich Europe\/Busingen\n+Link Europe\/Zurich Europe\/Vaduz\n+Link\tEurope\/Istanbul\tAsia\/Istanbul\t# Istanbul is in both continents.\n+Link America\/Phoenix America\/Creston\n+Link America\/Toronto America\/Nassau\n+Link America\/Panama America\/Atikokan\n+Link America\/Panama America\/Cayman\n+Link America\/Puerto_Rico America\/Anguilla\n+Link America\/Puerto_Rico America\/Antigua\n+Link America\/Puerto_Rico America\/Aruba\n+Link America\/Puerto_Rico America\/Curacao\n+Link America\/Puerto_Rico America\/Blanc-Sablon\t# Quebec (Lower North Shore)\n+Link America\/Puerto_Rico America\/Dominica\n+Link America\/Puerto_Rico America\/Grenada\n+Link America\/Puerto_Rico America\/Guadeloupe\n+Link America\/Puerto_Rico America\/Kralendijk\t# Caribbean Netherlands\n+Link America\/Puerto_Rico America\/Lower_Princes\t# Sint Maarten\n+Link America\/Puerto_Rico America\/Marigot\t# St Martin (French part)\n+Link America\/Puerto_Rico America\/Montserrat\n+Link America\/Puerto_Rico America\/Port_of_Spain\t# Trinidad & Tobago\n+Link America\/Puerto_Rico America\/St_Barthelemy\t# St Barthélemy\n+Link America\/Puerto_Rico America\/St_Kitts\t# St Kitts & Nevis\n+Link America\/Puerto_Rico America\/St_Lucia\n+Link America\/Puerto_Rico America\/St_Thomas\t# Virgin Islands (US)\n+Link America\/Puerto_Rico America\/St_Vincent\n+Link America\/Puerto_Rico America\/Tortola\t# Virgin Islands (UK)\n+Link\tAsia\/Riyadh87\tMideast\/Riyadh87\n+Link\tAsia\/Riyadh88\tMideast\/Riyadh88\n+Link\tAsia\/Riyadh89\tMideast\/Riyadh89\n+Link\tAfrica\/Nairobi\t\tAfrica\/Asmera\n+Link\tAfrica\/Abidjan\t\tAfrica\/Timbuktu\n+Link\tAmerica\/Argentina\/Catamarca\tAmerica\/Argentina\/ComodRivadavia\n+Link\tAmerica\/Adak\t\tAmerica\/Atka\n+Link\tAmerica\/Argentina\/Buenos_Aires\tAmerica\/Buenos_Aires\n+Link\tAmerica\/Argentina\/Catamarca\tAmerica\/Catamarca\n+Link\tAmerica\/Panama\t\tAmerica\/Coral_Harbour\n+Link\tAmerica\/Argentina\/Cordoba\tAmerica\/Cordoba\n+Link\tAmerica\/Tijuana\t\tAmerica\/Ensenada\n+Link\tAmerica\/Indiana\/Indianapolis\tAmerica\/Fort_Wayne\n+Link\tAmerica\/Nuuk\t\tAmerica\/Godthab\n+Link\tAmerica\/Indiana\/Indianapolis\tAmerica\/Indianapolis\n+Link\tAmerica\/Argentina\/Jujuy\tAmerica\/Jujuy\n+Link\tAmerica\/Indiana\/Knox\tAmerica\/Knox_IN\n+Link\tAmerica\/Kentucky\/Louisville\tAmerica\/Louisville\n+Link\tAmerica\/Argentina\/Mendoza\tAmerica\/Mendoza\n+Link\tAmerica\/Toronto\t\tAmerica\/Montreal\n+Link\tAmerica\/Rio_Branco\tAmerica\/Porto_Acre\n+Link\tAmerica\/Argentina\/Cordoba\tAmerica\/Rosario\n+Link\tAmerica\/Tijuana\t\tAmerica\/Santa_Isabel\n+Link\tAmerica\/Denver\t\tAmerica\/Shiprock\n+Link\tAmerica\/Puerto_Rico\tAmerica\/Virgin\n+Link\tPacific\/Auckland\tAntarctica\/South_Pole\n+Link\tAsia\/Ashgabat\t\tAsia\/Ashkhabad\n+Link\tAsia\/Kolkata\t\tAsia\/Calcutta\n+Link\tAsia\/Shanghai\t\tAsia\/Chongqing\n+Link\tAsia\/Shanghai\t\tAsia\/Chungking\n+Link\tAsia\/Dhaka\t\tAsia\/Dacca\n+Link\tAsia\/Shanghai\t\tAsia\/Harbin\n+Link\tAsia\/Urumqi\t\tAsia\/Kashgar\n+Link\tAsia\/Kathmandu\t\tAsia\/Katmandu\n+Link\tAsia\/Macau\t\tAsia\/Macao\n+Link\tAsia\/Yangon\t\tAsia\/Rangoon\n+Link\tAsia\/Ho_Chi_Minh\tAsia\/Saigon\n+Link\tAsia\/Jerusalem\t\tAsia\/Tel_Aviv\n+Link\tAsia\/Thimphu\t\tAsia\/Thimbu\n+Link\tAsia\/Makassar\t\tAsia\/Ujung_Pandang\n+Link\tAsia\/Ulaanbaatar\tAsia\/Ulan_Bator\n+Link\tAtlantic\/Faroe\t\tAtlantic\/Faeroe\n+Link\tEurope\/Berlin\t\tAtlantic\/Jan_Mayen\n+Link\tAustralia\/Sydney\tAustralia\/ACT\n+Link\tAustralia\/Sydney\tAustralia\/Canberra\n+Link\tAustralia\/Hobart\tAustralia\/Currie\n+Link\tAustralia\/Lord_Howe\tAustralia\/LHI\n+Link\tAustralia\/Sydney\tAustralia\/NSW\n+Link\tAustralia\/Darwin\tAustralia\/North\n+Link\tAustralia\/Brisbane\tAustralia\/Queensland\n+Link\tAustralia\/Adelaide\tAustralia\/South\n+Link\tAustralia\/Hobart\tAustralia\/Tasmania\n+Link\tAustralia\/Melbourne\tAustralia\/Victoria\n+Link\tAustralia\/Perth\t\tAustralia\/West\n+Link\tAustralia\/Broken_Hill\tAustralia\/Yancowinna\n+Link\tAmerica\/Rio_Branco\tBrazil\/Acre\n+Link\tAmerica\/Noronha\t\tBrazil\/DeNoronha\n+Link\tAmerica\/Sao_Paulo\tBrazil\/East\n+Link\tAmerica\/Manaus\t\tBrazil\/West\n+Link\tAmerica\/Halifax\t\tCanada\/Atlantic\n+Link\tAmerica\/Winnipeg\tCanada\/Central\n+Link\tAmerica\/Toronto\t\tCanada\/Eastern\n+Link\tAmerica\/Edmonton\tCanada\/Mountain\n+Link\tAmerica\/St_Johns\tCanada\/Newfoundland\n+Link\tAmerica\/Vancouver\tCanada\/Pacific\n+Link\tAmerica\/Regina\t\tCanada\/Saskatchewan\n+Link\tAmerica\/Whitehorse\tCanada\/Yukon\n+Link\tAmerica\/Santiago\tChile\/Continental\n+Link\tPacific\/Easter\t\tChile\/EasterIsland\n+Link\tAmerica\/Havana\t\tCuba\n+Link\tAfrica\/Cairo\t\tEgypt\n+Link\tEurope\/Dublin\t\tEire\n+Link\tEtc\/UTC\t\t\tEtc\/UCT\n+Link\tEurope\/London\t\tEurope\/Belfast\n+Link\tEurope\/Kyiv\t\tEurope\/Kiev\n+Link\tEurope\/Chisinau\t\tEurope\/Tiraspol\n+Link\tEurope\/London\t\tGB\n+Link\tEurope\/London\t\tGB-Eire\n+Link\tEtc\/GMT\t\t\tGMT+0\n+Link\tEtc\/GMT\t\t\tGMT-0\n+Link\tEtc\/GMT\t\t\tGMT0\n+Link\tEtc\/GMT\t\t\tGreenwich\n+Link\tAsia\/Hong_Kong\t\tHongkong\n+Link\tAfrica\/Abidjan\t\tIceland\n+Link\tAsia\/Tehran\t\tIran\n+Link\tAsia\/Jerusalem\t\tIsrael\n+Link\tAmerica\/Jamaica\t\tJamaica\n+Link\tAsia\/Tokyo\t\tJapan\n+Link\tPacific\/Kwajalein\tKwajalein\n+Link\tAfrica\/Tripoli\t\tLibya\n+Link\tAmerica\/Tijuana\t\tMexico\/BajaNorte\n+Link\tAmerica\/Mazatlan\tMexico\/BajaSur\n+Link\tAmerica\/Mexico_City\tMexico\/General\n+Link\tPacific\/Auckland\tNZ\n+Link\tPacific\/Chatham\t\tNZ-CHAT\n+Link\tAmerica\/Denver\t\tNavajo\n+Link\tAsia\/Shanghai\t\tPRC\n+Link\tPacific\/Kanton\t\tPacific\/Enderbury\n+Link\tPacific\/Honolulu\tPacific\/Johnston\n+Link\tPacific\/Guadalcanal\tPacific\/Ponape\n+Link\tPacific\/Pago_Pago\tPacific\/Samoa\n+Link\tPacific\/Port_Moresby\tPacific\/Truk\n+Link\tPacific\/Port_Moresby\tPacific\/Yap\n+Link\tEurope\/Warsaw\t\tPoland\n+Link\tEurope\/Lisbon\t\tPortugal\n+Link\tAsia\/Taipei\t\tROC\n+Link\tAsia\/Seoul\t\tROK\n+Link\tAsia\/Singapore\t\tSingapore\n+Link\tEurope\/Istanbul\t\tTurkey\n+Link\tEtc\/UTC\t\t\tUCT\n+Link\tAmerica\/Anchorage\tUS\/Alaska\n+Link\tAmerica\/Adak\t\tUS\/Aleutian\n+Link\tAmerica\/Phoenix\t\tUS\/Arizona\n+Link\tAmerica\/Chicago\t\tUS\/Central\n+Link\tAmerica\/Indiana\/Indianapolis\tUS\/East-Indiana\n+Link\tAmerica\/New_York\tUS\/Eastern\n+Link\tPacific\/Honolulu\tUS\/Hawaii\n+Link\tAmerica\/Indiana\/Knox\tUS\/Indiana-Starke\n+Link\tAmerica\/Detroit\t\tUS\/Michigan\n+Link\tAmerica\/Denver\t\tUS\/Mountain\n+Link\tAmerica\/Los_Angeles\tUS\/Pacific\n+Link\tPacific\/Pago_Pago\tUS\/Samoa\n+Link\tEtc\/UTC\t\t\tUTC\n+Link\tEtc\/UTC\t\t\tUniversal\n+Link\tEurope\/Moscow\t\tW-SU\n+Link\tEtc\/UTC\t\t\tZulu\n","filename":"jdk\/test\/java\/util\/TimeZone\/TimeZoneData\/aliases.txt","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+Africa\/Abidjan GMT\n+Africa\/Algiers CET\n+Africa\/Bissau GMT\n+Africa\/Cairo EET EEST\n+Africa\/Ceuta CET CEST\n+Africa\/Johannesburg SAST\n+Africa\/Juba CAT\n+Africa\/Khartoum CAT\n+Africa\/Lagos WAT\n+Africa\/Maputo CAT\n+Africa\/Monrovia GMT\n+Africa\/Nairobi EAT\n+Africa\/Ndjamena WAT\n+Africa\/Sao_Tome GMT\n+Africa\/Tripoli EET\n+Africa\/Tunis CET CEST\n+Africa\/Windhoek CAT WAT\n+America\/Adak HST HDT\n+America\/Anchorage AKST AKDT\n+America\/Bahia_Banderas CST CDT\n+America\/Barbados AST ADT\n+America\/Belize CST CDT\n+America\/Boise MST MDT\n+America\/Cambridge_Bay MST MDT\n+America\/Cancun EST\n+America\/Chicago CST CDT\n+America\/Chihuahua MST MDT\n+America\/Costa_Rica CST CDT\n+America\/Danmarkshavn GMT\n+America\/Dawson MST\n+America\/Dawson_Creek MST\n+America\/Denver MST MDT\n+America\/Detroit EST EDT\n+America\/Edmonton MST MDT\n+America\/El_Salvador CST CDT\n+America\/Fort_Nelson MST\n+America\/Glace_Bay AST ADT\n+America\/Goose_Bay AST ADT\n+America\/Grand_Turk EST EDT\n+America\/Guatemala CST CDT\n+America\/Halifax AST ADT\n+America\/Havana CST CDT\n+America\/Hermosillo MST\n+America\/Indiana\/Indianapolis EST EDT\n+America\/Indiana\/Knox CST CDT\n+America\/Indiana\/Marengo EST EDT\n+America\/Indiana\/Petersburg EST EDT\n+America\/Indiana\/Tell_City CST CDT\n+America\/Indiana\/Vevay EST EDT\n+America\/Indiana\/Vincennes EST EDT\n+America\/Indiana\/Winamac EST EDT\n+America\/Inuvik MST MDT\n+America\/Iqaluit EST EDT\n+America\/Jamaica EST\n+America\/Juneau AKST AKDT\n+America\/Kentucky\/Louisville EST EDT\n+America\/Kentucky\/Monticello EST EDT\n+America\/Los_Angeles PST PDT\n+America\/Managua CST CDT\n+America\/Martinique AST\n+America\/Matamoros CST CDT\n+America\/Mazatlan MST MDT\n+America\/Menominee CST CDT\n+America\/Merida CST CDT\n+America\/Metlakatla AKST AKDT\n+America\/Mexico_City CST CDT\n+America\/Moncton AST ADT\n+America\/Monterrey CST CDT\n+America\/New_York EST EDT\n+America\/Nipigon EST EDT\n+America\/Nome AKST AKDT\n+America\/North_Dakota\/Beulah CST CDT\n+America\/North_Dakota\/Center CST CDT\n+America\/North_Dakota\/New_Salem CST CDT\n+America\/Ojinaga MST MDT\n+America\/Panama EST\n+America\/Pangnirtung EST EDT\n+America\/Phoenix MST\n+America\/Port-au-Prince EST EDT\n+America\/Puerto_Rico AST\n+America\/Rainy_River CST CDT\n+America\/Rankin_Inlet CST CDT\n+America\/Regina CST\n+America\/Resolute CST CDT\n+America\/Santo_Domingo AST\n+America\/Sitka AKST AKDT\n+America\/St_Johns NST NDT\n+America\/Swift_Current CST\n+America\/Tegucigalpa CST CDT\n+America\/Thule AST ADT\n+America\/Thunder_Bay EST EDT\n+America\/Tijuana PST PDT\n+America\/Toronto EST EDT\n+America\/Vancouver PST PDT\n+America\/Whitehorse MST\n+America\/Winnipeg CST CDT\n+America\/Yakutat AKST AKDT\n+America\/Yellowknife MST MDT\n+Antarctica\/Macquarie AEST AEDT\n+Asia\/Amman EET EEST\n+Asia\/Beirut EET EEST\n+Asia\/Damascus EET EEST\n+Asia\/Famagusta EET EEST\n+Asia\/Gaza EET EEST\n+Asia\/Hebron EET EEST\n+Asia\/Hong_Kong HKT HKST\n+Asia\/Jakarta WIB\n+Asia\/Jayapura WIT\n+Asia\/Jerusalem IST IDT\n+Asia\/Karachi PKT PKST\n+Asia\/Kolkata IST\n+Asia\/Macau CST CDT\n+Asia\/Makassar WITA\n+Asia\/Manila PST PDT\n+Asia\/Nicosia EET EEST\n+Asia\/Pontianak WIB\n+Asia\/Pyongyang KST\n+Asia\/Seoul KST KDT\n+Asia\/Shanghai CST CDT\n+Asia\/Taipei CST CDT\n+Asia\/Tokyo JST JDT\n+Atlantic\/Bermuda AST ADT\n+Atlantic\/Canary WET WEST\n+Atlantic\/Faroe WET WEST\n+Atlantic\/Madeira WET WEST\n+Australia\/Adelaide ACST ACDT\n+Australia\/Brisbane AEST AEDT\n+Australia\/Broken_Hill ACST ACDT\n+Australia\/Darwin ACST ACDT\n+Australia\/Hobart AEST AEDT\n+Australia\/Lindeman AEST AEDT\n+Australia\/Melbourne AEST AEDT\n+Australia\/Perth AWST AWDT\n+Australia\/Sydney AEST AEDT\n+CET CET CEST\n+CST6CDT CST CDT\n+EET EET EEST\n+EST EST\n+EST5EDT EST EDT\n+Europe\/Andorra CET CEST\n+Europe\/Athens EET EEST\n+Europe\/Belgrade CET CEST\n+Europe\/Berlin CET CEST\n+Europe\/Brussels CET CEST\n+Europe\/Bucharest EET EEST\n+Europe\/Budapest CET CEST\n+Europe\/Chisinau EET EEST\n+Europe\/Dublin IST\/GMT IST\/GMT\n+Europe\/Gibraltar CET CEST\n+Europe\/Helsinki EET EEST\n+Europe\/Kaliningrad EET\n+Europe\/Kyiv EET EEST\n+Europe\/Lisbon WET WEST\n+Europe\/London GMT\/BST GMT\/BST\n+Europe\/Madrid CET CEST\n+Europe\/Malta CET CEST\n+Europe\/Moscow MSK\n+Europe\/Paris CET CEST\n+Europe\/Prague CET CEST\n+Europe\/Riga EET EEST\n+Europe\/Rome CET CEST\n+Europe\/Simferopol MSK\n+Europe\/Sofia EET EEST\n+Europe\/Tallinn EET EEST\n+Europe\/Tirane CET CEST\n+Europe\/Uzhgorod EET EEST\n+Europe\/Vienna CET CEST\n+Europe\/Vilnius EET EEST\n+Europe\/Warsaw CET CEST\n+Europe\/Zaporozhye EET EEST\n+Europe\/Zurich CET CEST\n+HST HST\n+MET MET MEST\n+MST MST\n+MST7MDT MST MDT\n+PST8PDT PST PDT\n+Pacific\/Auckland NZST NZDT\n+Pacific\/Guam ChST\n+Pacific\/Honolulu HST\n+Pacific\/Pago_Pago SST\n+WET WET WEST\n","filename":"jdk\/test\/java\/util\/TimeZone\/TimeZoneData\/displaynames.txt","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+#\n+# Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#\n+# Compares two year* test data files\n+# Typical usage:\n+#     perl CompareYearData.pl ..\/..\/TimeZoneData\/year2008 year2008\n+#\n+\n+%oldData = &readData($ARGV[0]);\n+%newData = &readData($ARGV[1]);\n+\n+foreach $key (sort(keys(%oldData))) {\n+  if (defined($newData{$key})) {\n+    if ($oldData{$key} ne $newData{$key}) {\n+      print \"Changed:\\n\";\n+      print \"$oldData{$key}\";\n+      print \"---\\n\";\n+      print \"$newData{$key}\";\n+    }\n+    delete $newData{$key};\n+  } else {\n+    print \"Deleted:\\n\";\n+    print \"$oldData{$key}\";\n+  }\n+}\n+foreach $key (sort(keys(%newData))) {\n+  print \"Added:\\n\";\n+  print \"$newData{$key}\";\n+}\n+\n+sub readData {\n+  local($file) = @_;\n+\n+  open(F, $file) || die \"Can't open $file\\n\";\n+  my %data = ();\n+  my $line = 0;\n+  my $id = \"\";\n+\n+  while (<F>) {\n+    $line++;\n+    s\/^\\s*\\d+ \/\/;\n+    if (\/tzdata\\d+\/) {\n+      $data{\" version\"} = $_;\n+      next;\n+    }\n+    if (\/(\\s*#.*$)\/) {\n+      $data{\" comments\"} .= $_;\n+      next;\n+    }\n+    if (\/^(Zone|Rule)\/) {\n+      die \"No id at line: $line\\n\" if ($id eq \"\");\n+      $data{$id} .= $_;\n+    } elsif (\/^(\\S+)\\s+\\S+\/) {\n+      $id = $1;\n+      $data{$id} = $_;\n+      $flag = 1;\n+    } else {\n+      die \"Unknown format at line: $line: $file\\n\";\n+    }\n+  }\n+  close(F);\n+  return %data;\n+}\n","filename":"jdk\/test\/java\/util\/TimeZone\/tools\/share\/CompareYearData.pl","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+#\n+# Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#\n+#\n+# This makefile is used to update the time zone tests data: aliases.txt displaynames.txt\n+# and VERSION. After switching to new build system in JDK8 the following make\n+# command should be used for test data updates:\n+#     make JDK_HOME=<path to built JDK with latest tzdata>\n+#     make install\n+#\n+\n+TZDATA = ..\/..\/..\/..\/..\/..\/..\/src\/java.base\/share\/data\/tzdata\n+TZDATA_VER = `grep '^tzdata' $(TZDATA)\/VERSION`\n+TZNAME = africa antarctica asia australasia europe northamerica \\\n+\tsolar87 solar88 solar89 southamerica \\\n+\tbackward\n+TZFILES = $(addprefix $(TZDATA)\/, $(TZNAME))\n+ALIASLIST = aliases.txt\n+DISPLAYNAMES = displaynames.txt\n+\n+all:\t$(DISPLAYNAMES) VERSION $(ALIASLIST)\n+\n+$(DISPLAYNAMES): $(TZFILES) makeZoneData.pl\n+\t(cat $(TZFILES) | perl makeZoneData.pl -v -V \"$(TZDATA_VER)\") 2>errors\n+\n+VERSION: $(TZDATA)\/VERSION\n+\techo \"$(TZDATA_VER)\" > VERSION\n+\n+$(ALIASLIST): $(TZFILES)\n+\trm -f $(ALIASLIST)\n+\tgrep -h \"^Link\" $(TZFILES) >> $(ALIASLIST)\n+\n+clean:\n+\trm -f $(DISPLAYNAMES) errors year???? VERSION $(ALIASLIST)\n+\n+install:\n+\tcp $(ALIASLIST) $(DISPLAYNAMES) VERSION ..\/..\/TimeZoneData\/\n","filename":"jdk\/test\/java\/util\/TimeZone\/tools\/share\/Makefile","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+#\n+# Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+#\n+#\n+#\n+# Perl script to generate ZoneData from Olson public time zone data.\n+#\n+# For J2SE before JDK1.3, see ..\/..\/README how to update TimeZone.java \n+# static TimeZoneData.\n+# For J2SE since JDK1.4, this script is used to generate testdata(reference)\n+# for ZoneData.sh which is one of TimeZone Regression test.\n+\n+$continue = 0;\n+\n+# verbose flag\n+$verbose = 0;\n+\n+# version of Olson's public zone information (e.g. \"tzdata2000g\")\n+$versionName = \"unknown\";\n+\n+# Number of testdata files.\n+$count = 5;\n+\n+# Display name datafile\n+$displayNameFile = \"displaynames.txt\";\n+\n+# time zone IDs to be generated. If it's empty, then generate all time\n+# zone in the tzdata files.\n+@javatzids = ();\n+\n+#\n+# Parses command-line options\n+#\n+while ($#ARGV >= 0) {\n+    if ($ARGV[0] =~ \/^-v\/) {\n+\t$verbose = 1;\n+    } elsif ($ARGV[0] =~ \/^-V\/) {\n+\t$versionName = $ARGV[1];\n+\tshift(@ARGV);\n+    } else {\n+\t@javatzids = &readIDs($ARGV[0]);\n+\tlast;\n+    }\n+    shift(@ARGV);\n+}\n+\n+# Beginning year of testdata\n+($sec, $min, $hour, $mday, $mon, $year, $wday, $ydat, $isdst) = gmtime();\n+$baseYear = $year+1900;\n+\n+if ($verbose == 1) {\n+    print STDERR \"baseYear : $baseYear\\n\";\n+    print STDERR \"versionName : $versionName\\n\";\n+}\n+\n+# Open display name datafile\n+open (DNFD, \">$displayNameFile\") || die (\"$displayNameFile : open error.\\n\");\n+\n+while(<STDIN>) {\n+    chop;\n+    if (\/^\\#\/) { # skip comment line\n+\tnext;\n+    }\n+    @item = (\"foo\");\n+\n+    # Zone\tNAME\t\tGMTOFF\tRULES\tFORMAT\t[UNTIL]\n+    if ($continue == 1) {\n+\ts\/\\#.*\/\/; # chop trailing comments\n+\ts\/\\s+$\/\/;\n+\ts\/^\\s+\/\/;\n+\t@item = split(\/\\s+\/, $_);\n+\t@item = ($zname, @item); # push zone name\n+    } elsif (\/^Zone\/) {\n+\ts\/\\#.*\/\/; # chop trailing comments\n+\ts\/\\s+$\/\/;\n+\t@item = split(\/\\s+\/, $_);\n+\t$zname = $item[1];\n+\tif (defined ($zones{$name})) {\n+\t    printf STDERR \"WARNING: duplicate definition of zone $name\\n\";\n+\t}\n+\tshift(@item);\n+    }\n+    if (@item[0] ne \"foo\") {\n+\tif($#item == 3) { # find out no UNTIL line\n+\t    $item[3] =~ s\/%\/%%\/;\n+\t    $zones{$item[0]} = \"Zone $item[0]\\t$item[1]\\t$item[2]\\t$item[3]\";\n+\t} else {\n+\t    $continue = 1;\n+\t    next;\n+\t}\n+    }\n+\n+    # Rule\tNAME\tFROM\tTO\tTYPE\tIN\tON\tAT\tSAVE\tLETTER\/S\n+    if (\/^Rule\/) {\n+\t($rule, $name, $from, $to, $type, $in, $on, $at, $save, $letter)\n+\t  = split(\/\\s+\/, $_);\n+\n+\t# matches specified year?\n+\tfor ($i = 0; $i < $count; $i++) {\n+\t    if ($from <= $baseYear+$i && ($to >= $baseYear+$i || $to eq \"max\")\n+\t\t|| ($from == $baseYear+$i && $to eq \"only\")) {\n+\t\tif ($save ne \"0\") {\n+\t\t    $rules[$i]{$name . \"0\"} = $_;\n+\t\t} else {\n+\t\t    $rules[$i]{$name . \"1\"} = $_;\n+\t\t}\n+\t    } else {\n+                if ($from <= $baseYear) {\n+                    if ($save ne \"0\") {\n+\t\t        $oldRules[0]{$name} = $_;\n+\t\t    } else {\n+\t\t        $oldRules[1]{$name} = $_;\n+\t\t    }\n+                }\n+\t    }\n+\t}\n+    }\n+    $continue = 0;\n+}\n+\n+#\n+# Prepare output files\n+#\n+for ($i = 0, $fd = 0; $i < $count; $i++, $fd++) {\n+    $filename = \"year\".($baseYear+$i);\n+    open ($fd, \">$filename\") || die (\"$filename : open error.\\n\");\n+    print $fd \"# Based on $versionName\\n\";\n+}\n+\n+#\n+# If no IDs are specified, produce test data for all zones.\n+#\n+if ($#javatzids < 0) {\n+    @javatzids = keys(%zones);\n+}\n+\n+foreach $z (@javatzids) {\n+    #\n+    # skip any Riyadh zones; ZoneData.java can't handle Riyada zones\n+    #\n+    next if ($z =~ \/Riyadh\/);\n+\n+    for ($i = 0, $fd = 0; $i < $count; $i++, $fd++) {\n+\tif (!defined($zones{$z})) {\n+\t    printf $fd \"$z ?\\n\";\n+\t    printf STDERR \"WARNING: java zone $z not found\\n\";\n+\t    next;\n+\t}\n+\t@item = split(\/\\s+\/, $zones{$z});\n+\tif ($item[3] ne \"-\") {\n+\t    printf $fd \"$item[1] $item[2] \";\n+\t    if (defined($rules[$i]{$item[3] . \"0\"})\n+\t\t&& defined($rules[$i]{$item[3] . \"1\"})) {\n+\t\t$rule0 = $rules[$i]{$item[3] . \"0\"};\n+\t\t$rule1 = $rules[$i]{$item[3] . \"1\"};\n+\t\t@r0 = split(\/\\s+\/, $rule0);\n+\t\t@r1 = split(\/\\s+\/, $rule1);\n+\t\tprintf $fd \"$r0[5] $r0[6] $r0[7] $r1[5] $r1[6] $r1[7] $r0[8]\\n\";\n+\t\tprintf $fd \"$zones{$z}\\n\";\n+\t\tprintf $fd \"$rule0\\n\";\n+\t\tprintf $fd \"$rule1\\n\";\n+                if ($i == 0) {\n+                    $std = $dst = $item[4];\n+                    $std =~ s\/%%s\/$r1[9]\/;\n+                    if ($r1[9] eq \"-\") {\n+                        $std =~ s\/-\/\/;\n+                    }\n+                    $dst =~ s\/%%s\/$r0[9]\/;\n+                    if ($r0[9] eq \"-\") {\n+                        $dst =~ s\/-\/\/;\n+                    }\n+                    if (\"$std$dst\" =~ \/[A-Z]\/) {\n+                        print DNFD \"$item[1] $std $dst\\n\";\n+                    }\n+                }\n+\t    } else {\n+\t\tprintf $fd \"-\\n\"; # In case we cannot find Rule, assume no DST.\n+\t\tprintf $fd \"$zones{$z}\\n\";\n+\t\tprintf STDERR \"WARNING: $z no rules defined for $item[3]\\n\";\n+                if ($i == 0) {\n+                    # About 30 time zones (e.g. Asia\/Tokyo needs the following\n+                    # recovery.\n+                    if ($item[4] =~ m\/%\/) {\n+                        @r0 = split(\/\\s+\/, $oldRules[0]{$item[3]});\n+                        @r1 = split(\/\\s+\/, $oldRules[1]{$item[3]});\n+                        if ($i == 0) {\n+                            $std = $dst = $item[4];\n+                            $std =~ s\/%%s\/$r1[9]\/;\n+                            if ($r1[9] eq \"-\") {\n+                                $std =~ s\/-\/\/;\n+                            }\n+                            $dst =~ s\/%%s\/$r0[9]\/;\n+                            if ($r0[9] eq \"-\") {\n+                                $dst =~ s\/-\/\/;\n+                            }\n+                            if (\"$std$dst\" =~ \/[A-Z]\/) {\n+                                print DNFD \"$item[1] $std $dst\\n\";\n+                            }\n+                        }\n+                    } else {\n+                        if (\"$item[4]\" =~ \/[A-Z]\/) {\n+                            print DNFD \"$item[1] $item[4]\\n\";\n+                        }\n+                    }\n+                }\n+\t    }\n+\t} else {\n+\t    printf $fd \"$item[1] $item[2] $item[3]\\n\";\n+\t    printf $fd \"$zones{$z}\\n\";\n+            if ($i == 0 && \"$item[4]\" =~ \/[A-Z]\/) {\n+                print DNFD \"$item[1] $item[4]\\n\";\n+            }\n+\t}\n+    }\n+}\n+\n+#\n+# Close all the output files\n+#\n+close (DNFD);\n+for ($i = 0, $fd = 0; $i < $count; $i++, $fd++) {\n+    close ($fd);\n+}\n+\n+#\n+# Sort the displaynames.txt file\n+#\n+open my $fh, '<', $displayNameFile || die (\"Can't open $displayNameFile for sorting\\n\");;\n+chomp(my @names = <$fh>);\n+close $fh;\n+open my $fh, '>', $displayNameFile;\n+foreach $line (sort @names) { print $fh $line,\"\\n\"; }\n+close $fh;\n+\n+exit(0);\n+\n+sub readIDs {\n+    local ($file) = @_;\n+    local (@ids, $i);\n+\n+    open(F, $file) || die \"Fatal: can't open $file.\\n\";\n+\n+    $i = 0;\n+    while (<F>) {\n+\tchop;\n+\tif (\/^\\#\/) { # skip comment line\n+\t    next;\n+\t}\n+\n+\t# trim any leading and trailing space\n+\ts\/^\\s+\/\/;\n+\ts\/\\s+$\/\/;\n+\n+        if (\/^\\s*$\/) { # skip blank line\n+\t    next;\n+\t}\n+\n+\t$ids[$i++] = $_;\n+    }\n+    close(F);\n+    return @ids;\n+}\n","filename":"jdk\/test\/java\/util\/TimeZone\/tools\/share\/makeZoneData.pl","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -44,8 +44,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(metrics);\n","filename":"jdk\/test\/jdk\/internal\/platform\/cgroup\/TestCgroupMetrics.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,219 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemController;\n+import jdk.test.lib.Utils;\n+import jdk.testlibrary.FileUtils;\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/lib\n+ * @library \/lib\/testlibrary\n+ * @run junit\/othervm TestCgroupSubsystemController\n+ *\/\n+\n+\/**\n+ *\n+ * Basic unit test for CgroupSubsystemController\n+ *\n+ *\/\n+public class TestCgroupSubsystemController {\n+\n+    private static final double DELTA = 0.01;\n+    private Path existingDirectory;\n+    private Path existingFile;\n+    private String existingFileName = \"test-controller-file\";\n+    private String existingFileContents = \"foobar\";\n+    private String doubleValueContents = \"1.5\";\n+    private String longValueContents = \"3000000000\";\n+    private String longValueMatchingLineContents = \"testme\\n\" +\n+                                                   \"itemfoo 25\";\n+    private String longEntryContents = \"s 1\\n\" +\n+                                       \"t 2\";\n+    private String longEntryName = \"longEntry\";\n+    private String longEntryMatchingLineName = \"longMatchingLine\";\n+    private String doubleValueName = \"doubleValue\";\n+    private String longValueName = \"longValue\";\n+    private CgroupSubsystemController mockController;\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemController.class.getSimpleName());\n+            existingFile = Paths.get(existingDirectory.toString(), existingFileName);\n+            Files.write(existingFile, existingFileContents.getBytes(StandardCharsets.UTF_8));\n+            Path longFile = Paths.get(existingDirectory.toString(), longValueName);\n+            Files.write(longFile, longValueContents.getBytes());\n+            Path doubleFile = Paths.get(existingDirectory.toString(), doubleValueName);\n+            Files.write(doubleFile, doubleValueContents.getBytes());\n+            Path longEntryFile = Paths.get(existingDirectory.toString(), longEntryName);\n+            Files.write(longEntryFile, longEntryContents.getBytes());\n+            Path longMatchingLine = Paths.get(existingDirectory.toString(), longEntryMatchingLineName);\n+            Files.write(longMatchingLine, longValueMatchingLineContents.getBytes());\n+            mockController = new MockCgroupSubsystemController(existingDirectory.toString());\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void getStringValueNullController() {\n+        String val = CgroupSubsystemController.getStringValue(null, \"ignore\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueIOException() throws IOException {\n+        String val = CgroupSubsystemController.getStringValue(mockController, \"don-t-exist.txt\");\n+        assertNull(val);\n+    }\n+\n+    @Test\n+    public void getStringValueSuccess() {\n+        String actual = CgroupSubsystemController.getStringValue(mockController, existingFileName);\n+        assertEquals(existingFileContents, actual);\n+    }\n+\n+    @Test\n+    public void convertStringToLong() {\n+        String strVal = \"1230\";\n+        long longVal = Long.parseLong(strVal);\n+        long actual = CgroupSubsystemController.convertStringToLong(strVal, -1L, 0);\n+        assertEquals(longVal, actual);\n+\n+        String overflowVal = \"9223372036854775808\"; \/\/ Long.MAX_VALUE + 1\n+        long overflowDefault = -1;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+        overflowDefault = Long.MAX_VALUE;\n+        actual = CgroupSubsystemController.convertStringToLong(overflowVal, overflowDefault, 0);\n+        assertEquals(overflowDefault, actual);\n+    }\n+\n+    @Test\n+    public void convertStringRangeToIntArray() {\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(null));\n+        assertNull(CgroupSubsystemController.stringRangeToIntArray(\"\"));\n+        String strRange = \"2,4,6\";\n+        int[] actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        int[] expected = new int[] { 2, 4, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+        strRange = \"6,1-3\";\n+        actual = CgroupSubsystemController.stringRangeToIntArray(strRange);\n+        expected = new int[] { 1, 2, 3, 6 };\n+        assertTrue(Arrays.equals(expected, actual));\n+    }\n+\n+    @Test\n+    public void getDoubleValue() {\n+        double defaultValue = -3;\n+        double actual = CgroupSubsystemController.getDoubleValue(null, null, defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+        double expected = Double.parseDouble(doubleValueContents);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, doubleValueName, defaultValue);\n+        assertEquals(expected, actual, DELTA);\n+        actual = CgroupSubsystemController.getDoubleValue(mockController, \"don't-exist\", defaultValue);\n+        assertEquals(defaultValue, actual, DELTA);\n+    }\n+\n+    @Test\n+    public void getLongValue() {\n+        long defaultValue = -4;\n+        long actual = CgroupSubsystemController.getLongValue(null, null, Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValue(mockController, \"dont-exist\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        long expected = Long.parseLong(longValueContents);\n+        actual = CgroupSubsystemController.getLongValue(mockController, longValueName, Long::parseLong, defaultValue);\n+        assertEquals(expected, actual);\n+    }\n+\n+    @Test\n+    public void getLongEntry() {\n+        long defaultValue = -5;\n+        long actual = CgroupSubsystemController.getLongEntry(null, null, \"no-matter\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, \"dont-exist\", \"foo-bar\", defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongEntry(mockController, longEntryName, \"t\", defaultValue);\n+        assertEquals(2, actual);\n+    }\n+\n+    @Test\n+    public void getLongMatchingLine() {\n+        long defaultValue = -6;\n+        long actual = CgroupSubsystemController.getLongValueMatchingLine(null, null, \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, \"dont-exist\", \"no-matter\", Long::parseLong, defaultValue);\n+        assertEquals(defaultValue, actual);\n+        actual = CgroupSubsystemController.getLongValueMatchingLine(mockController, longEntryMatchingLineName, \"item\", TestCgroupSubsystemController::convertLong, defaultValue);\n+        assertEquals(25, actual);\n+    }\n+\n+    public static long convertLong(String line) {\n+        return Long.parseLong(line.split(\"\\\\s+\")[1]);\n+    }\n+\n+    static class MockCgroupSubsystemController implements CgroupSubsystemController {\n+\n+        private final String path;\n+\n+        public MockCgroupSubsystemController(String path) {\n+            this.path = path;\n+        }\n+\n+        @Override\n+        public String path() {\n+            return path;\n+        }\n+\n+    }\n+\n+}\n","filename":"jdk\/test\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemController.java","additions":219,"deletions":0,"binary":false,"changes":219,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import jdk.internal.platform.CgroupSubsystemFactory;\n+import jdk.internal.platform.CgroupSubsystemFactory.CgroupTypeResult;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.util.FileUtils;\n+\n+\n+\/*\n+ * @test\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.platform\n+ * @library \/test\/lib\n+ * @run junit\/othervm TestCgroupSubsystemFactory\n+ *\/\n+public class TestCgroupSubsystemFactory {\n+\n+    private Path existingDirectory;\n+    private Path cgroupv1CgInfoZeroHierarchy;\n+    private Path cgroupv1MntInfoZeroHierarchy;\n+    private Path cgroupv2CgInfoZeroHierarchy;\n+    private Path cgroupv2MntInfoZeroHierarchy;\n+    private Path cgroupv1CgInfoNonZeroHierarchy;\n+    private Path cgroupv1MntInfoNonZeroHierarchy;\n+    private String mntInfoEmpty = \"\";\n+    private String cgroupsZeroHierarchy =\n+            \"#subsys_name hierarchy num_cgroups enabled\\n\" +\n+            \"cpuset 0 1 1\\n\" +\n+            \"cpu 0 1 1\\n\" +\n+            \"cpuacct 0 1 1\\n\" +\n+            \"memory 0 1 1\\n\" +\n+            \"devices 0 1 1\\n\" +\n+            \"freezer 0 1 1\\n\" +\n+            \"net_cls 0 1 1\\n\" +\n+            \"blkio 0 1 1\\n\" +\n+            \"perf_event 0 1 1 \";\n+    private String mntInfoHybrid =\n+            \"30 23 0:26 \/ \/sys\/fs\/cgroup ro,nosuid,nodev,noexec shared:4 - tmpfs tmpfs ro,seclabel,mode=755\\n\" +\n+            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n+            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n+    private String cgroupsNonZeroHierarchy =\n+            \"#subsys_name hierarchy   num_cgroups enabled\\n\" +\n+            \"cpuset  9   1   1\\n\" +\n+            \"cpu 7   1   1\\n\" +\n+            \"cpuacct 7   1   1\\n\" +\n+            \"blkio   10  1   1\\n\" +\n+            \"memory  2   90  1\\n\" +\n+            \"devices 8   74  1\\n\" +\n+            \"freezer 11  1   1\\n\" +\n+            \"net_cls 5   1   1\\n\" +\n+            \"perf_event  4   1   1\\n\" +\n+            \"net_prio    5   1   1\\n\" +\n+            \"hugetlb 6   1   1\\n\" +\n+            \"pids    3   80  1\";\n+    private String mntInfoCgroupsV2Only =\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n+\n+    @Before\n+    public void setup() {\n+        try {\n+            existingDirectory = Utils.createTempDirectory(TestCgroupSubsystemFactory.class.getSimpleName());\n+            Path cgroupsZero = Paths.get(existingDirectory.toString(), \"cgroups_zero\");\n+            Files.writeString(cgroupsZero, cgroupsZeroHierarchy, StandardCharsets.UTF_8);\n+            cgroupv1CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv2CgInfoZeroHierarchy = cgroupsZero;\n+            cgroupv1MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_empty\");\n+            Files.writeString(cgroupv1MntInfoZeroHierarchy, mntInfoEmpty);\n+\n+            cgroupv2MntInfoZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv2\");\n+            Files.writeString(cgroupv2MntInfoZeroHierarchy, mntInfoCgroupsV2Only);\n+\n+            cgroupv1CgInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"cgroups_non_zero\");\n+            Files.writeString(cgroupv1CgInfoNonZeroHierarchy, cgroupsNonZeroHierarchy);\n+\n+            cgroupv1MntInfoNonZeroHierarchy = Paths.get(existingDirectory.toString(), \"mountinfo_non_zero\");\n+            Files.writeString(cgroupv1MntInfoNonZeroHierarchy, mntInfoHybrid);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @After\n+    public void teardown() {\n+        try {\n+            FileUtils.deleteFileTreeWithRetry(existingDirectory);\n+        } catch (IOException e) {\n+            System.err.println(\"Teardown failed. \" + e.getMessage());\n+        }\n+    }\n+\n+    @Test\n+    public void testHybridCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoNonZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"hybrid hierarchy expected as cgroups v1\", res.isCgroupV2());\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV1() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"zero hierarchy ids with no mounted controllers => empty result\", result.isEmpty());\n+    }\n+\n+    @Test\n+    public void testZeroHierarchyCgroupsV2() throws IOException {\n+        String cgroups = cgroupv2CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+\n+        assertTrue(\"zero hierarchy ids with mounted controllers expected cgroups v2\", res.isCgroupV2());\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void mountInfoFileNotFound() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String mountInfo = Paths.get(existingDirectory.toString(), \"not-existing-mountinfo\").toString();\n+\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void cgroupsFileNotFound() throws IOException {\n+        String cgroups = Paths.get(existingDirectory.toString(), \"not-existing-cgroups\").toString();\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString(); \/\/ any existing file\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+    }\n+}\n","filename":"jdk\/test\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+\n@@ -98,4 +99,7 @@\n-        if (!Arrays.equals(ipCpuSet, effectiveCpus)) {\n-            throw new RuntimeException(\"Effective Cpusets not equal, expected : \"\n-                    + Arrays.toString(ipCpuSet) + \", got : \"\n-                    + Arrays.toString(effectiveCpus));\n+        \/\/ Check to see if this metric is supported on this platform\n+        if (effectiveCpus != null) {\n+            if (!Arrays.equals(ipCpuSet, effectiveCpus)) {\n+                throw new RuntimeException(\"Effective Cpusets not equal, expected : \"\n+                        + Arrays.toString(ipCpuSet) + \", got : \"\n+                        + Arrays.toString(effectiveCpus));\n+            }\n@@ -130,4 +134,7 @@\n-        if (!Arrays.equals(ipCpuSet, effectiveMems)) {\n-            throw new RuntimeException(\"Effective mem nodes not equal, expected : \"\n-                    + Arrays.toString(ipCpuSet) + \", got : \"\n-                    + Arrays.toString(effectiveMems));\n+        \/\/ Check to see if this metric is supported on this platform\n+        if (effectiveMems != null) {\n+            if (!Arrays.equals(ipCpuSet, effectiveMems)) {\n+                throw new RuntimeException(\"Effective mem nodes not equal, expected : \"\n+                        + Arrays.toString(ipCpuSet) + \", got : \"\n+                        + Arrays.toString(effectiveMems));\n+            }\n@@ -140,0 +147,5 @@\n+        if (\"cgroupv2\".equals(metrics.getProvider()) && shares < 1024) {\n+            \/\/ Adjust input shares for < 1024 cpu shares as the\n+            \/\/ impl. rounds up to the next multiple of 1024\n+            shares = 1024;\n+        }\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/MetricsCpuTester.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+\n@@ -26,0 +27,1 @@\n+import jdk.internal.platform.CgroupV1Metrics;\n@@ -28,0 +30,3 @@\n+\n+    private static final long UNLIMITED = -1;\n+\n@@ -75,0 +80,1 @@\n+            boolean atLeastOneAllocationWorked = false;\n@@ -78,0 +84,1 @@\n+                    atLeastOneAllocationWorked = true;\n@@ -87,0 +94,6 @@\n+            if (!atLeastOneAllocationWorked) {\n+                System.out.println(\"Allocation failed immediately. Ignoring test!\");\n+                return;\n+            }\n+            \/\/ Be sure bytes allocations don't get optimized out\n+            System.out.println(\"DEBUG: Bytes allocation length 1: \" + bytes[0].length);\n@@ -110,5 +123,16 @@\n-        long limit = getMemoryValue(value);\n-        if (limit != Metrics.systemMetrics().getKernelMemoryLimit()) {\n-            throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n-                    + limit + \"]\" + \", got : [\"\n-                    + Metrics.systemMetrics().getKernelMemoryLimit() + \"]\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            System.out.println(\"TEST PASSED!!!\");\n+            long limit = getMemoryValue(value);\n+            long kmemlimit = mCgroupV1.getKernelMemoryLimit();\n+            \/\/ Note that the kernel memory limit might get ignored by OCI runtimes\n+            \/\/ This feature is deprecated. Only perform the check if we get an actual\n+            \/\/ limit back.\n+            if (kmemlimit != UNLIMITED && limit != kmemlimit) {\n+                throw new RuntimeException(\"Kernel Memory limit not equal, expected : [\"\n+                            + limit + \"]\" + \", got : [\"\n+                            + kmemlimit + \"]\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"kernel memory limit test not supported for cgroups v2\");\n@@ -116,1 +140,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n@@ -150,2 +173,11 @@\n-        if (!(oomKillFlag ^ Metrics.systemMetrics().isMemoryOOMKillEnabled())) {\n-            throw new RuntimeException(\"oomKillFlag error\");\n+        Metrics m = Metrics.systemMetrics();\n+        if (m instanceof CgroupV1Metrics) {\n+            CgroupV1Metrics mCgroupV1 = (CgroupV1Metrics)m;\n+            Boolean expected = Boolean.valueOf(oomKillFlag);\n+            Boolean actual = mCgroupV1.isMemoryOOMKillEnabled();\n+            if (!(expected.equals(actual))) {\n+                throw new RuntimeException(\"oomKillFlag error\");\n+            }\n+            System.out.println(\"TEST PASSED!!!\");\n+        } else {\n+            throw new RuntimeException(\"oomKillFlag test not supported for cgroups v2\");\n@@ -153,1 +185,0 @@\n-        System.out.println(\"TEST PASSED!!!\");\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/MetricsMemoryTester.java","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-            if (cpuSetMems.length > 1) {\n+            if (cpuSetMems != null && cpuSetMems.length > 1) {\n@@ -82,1 +82,1 @@\n-            } else if (cpuSetMems.length == 1) {\n+            } else if (cpuSetMems != null && cpuSetMems.length == 1) {\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/TestDockerCpuMetrics.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.internal.platform.Metrics;\n@@ -28,0 +29,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -58,4 +60,15 @@\n-            testKernelMemoryLimit(\"100m\");\n-            testKernelMemoryLimit(\"1g\");\n-\n-            testOomKillFlag(\"100m\", false);\n+            Metrics m = Metrics.systemMetrics();\n+            \/\/ kernel memory, '--kernel-memory' switch, and OOM killer,\n+            \/\/ '--oom-kill-disable' switch, tests not supported by cgroupv2\n+            \/\/ runtimes\n+            if (m != null) {\n+                if (\"cgroupv1\".equals(m.getProvider())) {\n+                    testKernelMemoryLimit(\"100m\");\n+                    testKernelMemoryLimit(\"1g\");\n+\n+                    testOomKillFlag(\"100m\", false);\n+                } else {\n+                    System.out.println(\"kernel memory tests and OOM Kill flag tests not \" +\n+                                       \"possible with cgroupv2.\");\n+                }\n+            }\n@@ -69,1 +82,3 @@\n-            DockerTestUtils.removeDockerImage(imageName);\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n@@ -130,1 +145,2 @@\n-        DockerTestUtils.dockerRunJava(opts).shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n+        OutputAnalyzer oa = DockerTestUtils.dockerRunJava(opts);\n+        oa.shouldHaveExitValue(0).shouldContain(\"TEST PASSED!!!\");\n","filename":"jdk\/test\/jdk\/internal\/platform\/docker\/TestDockerMemoryMetrics.java","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n- * @run main\/othervm -XX:TLABSize=2k jdk.jfr.event.oldobject.TestClassLoaderLeak\n+ * @run main\/othervm -XX:TLABSize=2k -Xmx64m jdk.jfr.event.oldobject.TestClassLoaderLeak\n","filename":"jdk\/test\/jdk\/jfr\/event\/oldobject\/TestClassLoaderLeak.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+\n@@ -57,2 +58,1 @@\n-        try {\n-            Stream<String> stream = Files.lines(Paths.get(path));\n+        try (Stream<String> stream = Files.lines(Paths.get(path))) {\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CPUSetsReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+interface CgroupMetricsTester {\n+\n+    public static final double ERROR_MARGIN = 0.1;\n+    public static final String EMPTY_STR = \"\";\n+\n+    public void testMemorySubsystem();\n+    public void testCpuAccounting();\n+    public void testCpuSchedulingMetrics();\n+    public void testCpuSets();\n+    public void testCpuConsumption() throws IOException, InterruptedException;\n+    public void testMemoryUsage() throws Exception;\n+    public void testMisc();\n+\n+    public static long convertStringToLong(String strval, long initialVal, long overflowRetval) {\n+        long retval = initialVal;\n+        if (strval == null) return retval;\n+\n+        try {\n+            retval = Long.parseLong(strval);\n+        } catch (NumberFormatException e) {\n+            \/\/ For some properties (e.g. memory.limit_in_bytes) we may overflow the range of signed long.\n+            \/\/ In this case, return Long.MAX_VALUE\n+            BigInteger b = new BigInteger(strval);\n+            if (b.compareTo(BigInteger.valueOf(Long.MAX_VALUE)) > 0) {\n+                return overflowRetval;\n+            }\n+        }\n+        return retval;\n+    }\n+\n+    public static boolean compareWithErrorMargin(long oldVal, long newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static boolean compareWithErrorMargin(double oldVal, double newVal) {\n+        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n+    }\n+\n+    public static void fail(String controller, String metric, long oldVal, long testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, String oldVal, String testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, double oldVal, double testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void fail(String controller, String metric, boolean oldVal, boolean testVal) {\n+        throw new RuntimeException(\"Test failed for - \" + controller + \":\"\n+                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static void warn(String controller, String metric, long oldVal, long testVal) {\n+        System.err.println(\"Warning - \" + controller + \":\" + metric\n+                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n+    }\n+\n+    public static Integer[] convertCpuSetsToArray(String cpusstr) {\n+        if (cpusstr == null || EMPTY_STR.equals(cpusstr)) {\n+            return null;\n+        }\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] cpuSets = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n+            if (a.contains(\"-\")) {\n+                String[] range = a.split(\"-\");\n+                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n+                        Integer.parseInt(range[1])).boxed();\n+            } else {\n+                return Stream.of(Integer.parseInt(a));\n+            }\n+        }).toArray(Integer[]::new);\n+        return cpuSets;\n+    }\n+\n+    public static Integer[] boxedArrayOrNull(int[] primitiveArray) {\n+        if (primitiveArray == null) {\n+            return null;\n+        }\n+        return Arrays.stream(primitiveArray).boxed().toArray(Integer[]::new);\n+    }\n+\n+    public static Integer[] sortAllowNull(Integer[] array) {\n+        if (array == null) {\n+            return null;\n+        }\n+        Arrays.sort(array);\n+        return array;\n+    }\n+\n+}\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/CgroupMetricsTester.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc.\n@@ -24,0 +24,1 @@\n+\n@@ -26,16 +27,2 @@\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Scanner;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.IntStream;\n-import java.util.stream.LongStream;\n-import java.util.stream.Stream;\n+import java.util.Objects;\n+\n@@ -44,0 +31,4 @@\n+\/**\n+ * Cgroup version agnostic metrics tester\n+ *\n+ *\/\n@@ -46,312 +37,2 @@\n-    private static final double ERROR_MARGIN = 0.1;\n-    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n-    long startSysVal;\n-    long startUserVal;\n-    long startUsage;\n-    long startPerCpu[];\n-\n-    enum SubSystem {\n-        MEMORY(\"memory\"),\n-        CPUSET(\"cpuset\"),\n-        CPU(\"cpu\"),\n-        CPUACCT(\"cpuacct\"),\n-        BLKIO(\"blkio\");\n-\n-        private String value;\n-\n-        SubSystem(String value) {\n-            this.value = value;\n-        }\n-\n-        public String value() {\n-            return value;\n-        }\n-    }\n-\n-    private static final Set<String> allowedSubSystems =\n-            Stream.of(SubSystem.values()).map(SubSystem::value).collect(Collectors.toSet());\n-\n-    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n-\n-    private static void setPath(String[] line) {\n-        String cgroupPath = line[2];\n-        String[] subSystems = line[1].split(\",\");\n-\n-        for (String subSystem : subSystems) {\n-            if (allowedSubSystems.contains(subSystem)) {\n-                String[] paths = subSystemPaths.get(subSystem);\n-                String finalPath = \"\";\n-                String root = paths[0];\n-                String mountPoint = paths[1];\n-                if (root != null && cgroupPath != null) {\n-                    if (root.equals(\"\/\")) {\n-                        if (!cgroupPath.equals(\"\/\")) {\n-                            finalPath = mountPoint + cgroupPath;\n-                        } else {\n-                            finalPath = mountPoint;\n-                        }\n-                    } else {\n-                        if (root.equals(cgroupPath)) {\n-                            finalPath = mountPoint;\n-                        } else {\n-                            if (cgroupPath.startsWith(root)) {\n-                                if (cgroupPath.length() > root.length()) {\n-                                    String cgroupSubstr = cgroupPath.substring(root.length());\n-                                    finalPath = mountPoint + cgroupSubstr;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n-            }\n-        }\n-    }\n-\n-    private static void createSubsystems(String[] line) {\n-        if (line.length < 5) return;\n-        Path p = Paths.get(line[4]);\n-        String subsystemName = p.getFileName().toString();\n-        if (subsystemName != null) {\n-            for (String subSystem : subsystemName.split(\",\")) {\n-                if (allowedSubSystems.contains(subSystem)) {\n-                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n-                }\n-            }\n-        }\n-    }\n-\n-    public void setup() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ Initialize CPU usage metrics before we do any testing.\n-        startSysVal = metrics.getCpuSystemUsage();\n-        startUserVal = metrics.getCpuUserUsage();\n-        startUsage = metrics.getCpuUsage();\n-        startPerCpu = metrics.getPerCpuUsage();\n-\n-        try {\n-            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n-            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n-                    .map(line -> line.split(\" \"))\n-                    .forEach(MetricsTester::createSubsystems);\n-            lines.close();\n-\n-            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n-            lines.map(line -> line.split(\":\"))\n-                    .filter(line -> (line.length >= 3))\n-                    .forEach(MetricsTester::setPath);\n-            lines.close();\n-        } catch (IOException e) {\n-        }\n-    }\n-\n-    private static String getFileContents(SubSystem subSystem, String fileName) {\n-        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n-        try {\n-            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n-        } catch (FileNotFoundException e) {\n-            System.err.println(\"Unable to open : \" + fname);\n-            return \"\";\n-        }\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0L : Long.parseLong(data);\n-    }\n-\n-    private static long getLongValueFromFile(SubSystem subSystem, String metric, String subMetric) {\n-        String stats = getFileContents(subSystem, metric);\n-        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n-        for (int i = 0; i < tokens.length; i++) {\n-            if (tokens[i].startsWith(subMetric)) {\n-                return Long.parseLong(tokens[i].split(\"\\\\s+\")[1]);\n-            }\n-        }\n-        return 0L;\n-    }\n-\n-    private static double getDoubleValueFromFile(SubSystem subSystem, String fileName) {\n-        String data = getFileContents(subSystem, fileName);\n-        return data.isEmpty() ? 0.0 : Double.parseDouble(data);\n-    }\n-\n-    private boolean compareWithErrorMargin(long oldVal, long newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private boolean compareWithErrorMargin(double oldVal, double newVal) {\n-        return Math.abs(oldVal - newVal) <= Math.abs(oldVal * ERROR_MARGIN);\n-    }\n-\n-    private static void fail(SubSystem system, String metric, long oldVal, long testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, String oldVal, String testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, double oldVal, double testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void fail(SubSystem system, String metric, boolean oldVal, boolean testVal) {\n-        throw new RuntimeException(\"Test failed for - \" + system.value + \":\"\n-                + metric + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    private static void warn(SubSystem system, String metric, long oldVal, long testVal) {\n-        System.err.println(\"Warning - \" + system.value + \":\" + metric\n-                + \", expected [\" + oldVal + \"], got [\" + testVal + \"]\");\n-    }\n-\n-    public void testMemorySubsystem() {\n-        Metrics metrics = Metrics.systemMetrics();\n-\n-        \/\/ User Memory\n-        long oldVal = metrics.getMemoryFailCount();\n-        long newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/ Kernel memory\n-        oldVal = metrics.getKernelMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getKernelMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/TCP Memory\n-        oldVal = metrics.getTcpMemoryFailCount();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryMaxUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getTcpMemoryUsage();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n-        }\n-\n-        \/\/  Memory and Swap\n-        \/\/ Skip swap tests if no swap is configured.\n-        if (metrics.getMemoryAndSwapLimit() > metrics.getMemoryLimit()) {\n-            oldVal = metrics.getMemoryAndSwapFailCount();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.failcnt\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapLimit();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\");\n-            newVal = newVal > unlimited_minimum ? -1L : newVal;\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapMaxUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n-            }\n-\n-            oldVal = metrics.getMemoryAndSwapUsage();\n-            newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\");\n-            if (!compareWithErrorMargin(oldVal, newVal)) {\n-                fail(SubSystem.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n-            }\n-        }\n-\n-        oldVal = metrics.getMemorySoftLimit();\n-        newVal = getLongValueFromFile(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\");\n-        newVal = newVal > unlimited_minimum ? -1L : newVal;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n-        }\n-\n-        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n-        boolean newOomKillEnabled = getLongValueFromFile(SubSystem.MEMORY,\n-                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n-        if (oomKillEnabled != newOomKillEnabled) {\n-            throw new RuntimeException(\"Test failed for - \" + SubSystem.MEMORY.value + \":\"\n-                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n-                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n-        }\n-    }\n-\n-    public void testCpuAccounting() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuUsage();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.usage\");\n-\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n-        }\n-\n-        Long[] newVals = Stream.of(getFileContents(SubSystem.CPUACCT, \"cpuacct.usage_percpu\")\n-                .split(\"\\\\s+\"))\n-                .map(Long::parseLong)\n-                .toArray(Long[]::new);\n-        Long[] oldVals = LongStream.of(metrics.getPerCpuUsage()).boxed().toArray(Long[]::new);\n-        for (int i = 0; i < oldVals.length; i++) {\n-            if (!compareWithErrorMargin(oldVals[i], newVals[i])) {\n-                warn(SubSystem.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n-            }\n-        }\n+    private static final String CGROUP_V1 = \"cgroupv1\";\n+    private static final String CGROUP_V2 = \"cgroupv2\";\n@@ -359,50 +40,12 @@\n-        oldVal = metrics.getCpuUserUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"user\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuSystemUsage();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpuacct.stat\", \"system\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            warn(SubSystem.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuSchedulingMetrics() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long oldVal = metrics.getCpuPeriod();\n-        long newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_period_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuQuota();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.cfs_quota_us\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuShares();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.shares\");\n-        if (newVal == 0 || newVal == 1024) newVal = -1;\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.shares\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumPeriods();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_periods\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuNumThrottled();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getCpuThrottledTime();\n-        newVal = getLongValueFromFile(SubSystem.CPUACCT, \"cpu.stat\", \"throttled_time\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n+    private static CgroupMetricsTester createInstance(Metrics m) {\n+        Objects.requireNonNull(m);\n+        if (CGROUP_V1.equals(m.getProvider())) {\n+            MetricsTesterCgroupV1 t = new MetricsTesterCgroupV1();\n+            t.setup();\n+            return t;\n+        } else if (CGROUP_V2.equals(m.getProvider())) {\n+            return new MetricsTesterCgroupV2();\n+        } else {\n+            System.err.println(\"WARNING: Metrics provider, '\" + m.getProvider()\n+                                                              + \"' is unknown!\");\n+            return null;\n@@ -412,180 +55,9 @@\n-    public void testCpuSets() {\n-        Metrics metrics = Metrics.systemMetrics();\n-        Integer[] oldVal = Arrays.stream(metrics.getCpuSetCpus()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-\n-        String cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.cpus\");\n-        \/\/ Parse range string in the format 1,2-6,7\n-        Integer[] newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (!Arrays.equals(oldVal, newVal)) {\n-            fail(SubSystem.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n-                Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSets.length != 0) {\n-            oldVal = Arrays.stream(cpuSets).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_cpus\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (!Arrays.equals(oldVal, newVal)) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        oldVal = Arrays.stream(metrics.getCpuSetMems()).boxed().toArray(Integer[]::new);\n-        Arrays.sort(oldVal);\n-        cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.mems\");\n-        newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-            if (a.contains(\"-\")) {\n-                String[] range = a.split(\"-\");\n-                return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                        Integer.parseInt(range[1])).boxed();\n-            } else {\n-                return Stream.of(Integer.parseInt(a));\n-            }\n-        }).toArray(Integer[]::new);\n-        Arrays.sort(newVal);\n-        if (!Arrays.equals(oldVal, newVal)) {\n-            fail(SubSystem.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n-                    Arrays.toString(newVal));\n-        }\n-\n-        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n-\n-        \/\/ Skip this test if this metric is supported on this platform\n-        if (cpuSetMems.length != 0) {\n-            oldVal = Arrays.stream(cpuSetMems).boxed().toArray(Integer[]::new);\n-            Arrays.sort(oldVal);\n-            cpusstr = getFileContents(SubSystem.CPUSET, \"cpuset.effective_mems\");\n-            newVal = Stream.of(cpusstr.split(\",\")).flatMap(a -> {\n-                if (a.contains(\"-\")) {\n-                    String[] range = a.split(\"-\");\n-                    return IntStream.rangeClosed(Integer.parseInt(range[0]),\n-                            Integer.parseInt(range[1])).boxed();\n-                } else {\n-                    return Stream.of(Integer.parseInt(a));\n-                }\n-            }).toArray(Integer[]::new);\n-            Arrays.sort(newVal);\n-            if (!Arrays.equals(oldVal, newVal)) {\n-                fail(SubSystem.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n-                        Arrays.toString(newVal));\n-            }\n-        }\n-\n-        double oldValue = metrics.getCpuSetMemoryPressure();\n-        double newValue = getDoubleValueFromFile(SubSystem.CPUSET, \"cpuset.memory_pressure\");\n-        if (!compareWithErrorMargin(oldValue, newValue)) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n-        }\n-\n-        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n-        boolean newV = getLongValueFromFile(SubSystem.CPUSET,\n-                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n-        if (oldV != newV) {\n-            fail(SubSystem.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n-        }\n-    }\n-\n-    public void testBlkIO() {\n-        Metrics metrics = Metrics.systemMetrics();\n-            long oldVal = metrics.getBlkIOServiceCount();\n-        long newVal = getLongValueFromFile(SubSystem.BLKIO,\n-                \"blkio.throttle.io_service_bytes\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n-                    oldVal, newVal);\n-        }\n-\n-        oldVal = metrics.getBlkIOServiced();\n-        newVal = getLongValueFromFile(SubSystem.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n-        if (!compareWithErrorMargin(oldVal, newVal)) {\n-            fail(SubSystem.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n-        }\n-    }\n-\n-    public void testCpuConsumption() throws IOException, InterruptedException {\n-        Metrics metrics = Metrics.systemMetrics();\n-        \/\/ make system call\n-        long newSysVal = metrics.getCpuSystemUsage();\n-        long newUserVal = metrics.getCpuUserUsage();\n-        long newUsage = metrics.getCpuUsage();\n-        long[] newPerCpu = metrics.getPerCpuUsage();\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newSysVal < startSysVal) {\n-            fail(SubSystem.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n-        }\n-\n-        \/\/ system\/user CPU usage counters may be slowly increasing.\n-        \/\/ allow for equal values for a pass\n-        if (newUserVal < startUserVal) {\n-            fail(SubSystem.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n-        }\n-\n-        if (newUsage <= startUsage) {\n-            fail(SubSystem.CPU, \"getCpuUsage\", newUsage, startUsage);\n-        }\n-\n-        boolean success = false;\n-        for (int i = 0; i < startPerCpu.length; i++) {\n-            if (newPerCpu[i] > startPerCpu[i]) {\n-                success = true;\n-                break;\n-            }\n-        }\n-\n-        if(!success) fail(SubSystem.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n-                Arrays.toString(startPerCpu));\n-    }\n-\n-    public void testMemoryUsage() throws Exception {\n-        Metrics metrics = Metrics.systemMetrics();\n-        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n-        long memoryUsage = metrics.getMemoryUsage();\n-        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n-\n-        \/\/ allocate memory in a loop and check more than once for new values\n-        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n-        \/\/ e.g. because the system could free up memory\n-        byte[][] bytes = new byte[32][];\n-        for (int i = 0; i < 32; i++) {\n-            bytes[i] = new byte[8*1024*1024];\n-            newMemoryUsage = metrics.getMemoryUsage();\n-            if (newMemoryUsage > memoryUsage) {\n-                break;\n-            }\n-        }\n-        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n-\n-        if (newMemoryMaxUsage < memoryMaxUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n-                    newMemoryMaxUsage);\n-        }\n-\n-        if (newMemoryUsage < memoryUsage) {\n-            fail(SubSystem.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n-        }\n+    public void testAll(Metrics m) throws Exception {\n+        CgroupMetricsTester tester =  createInstance(m);\n+        tester.testCpuAccounting();\n+        tester.testCpuConsumption();\n+        tester.testCpuSchedulingMetrics();\n+        tester.testCpuSets();\n+        tester.testMemorySubsystem();\n+        tester.testMemoryUsage();\n+        tester.testMisc();\n@@ -595,0 +67,1 @@\n+        Metrics m = Metrics.systemMetrics();\n@@ -596,2 +69,1 @@\n-        Metrics metrics = Metrics.systemMetrics();\n-        if (metrics == null) {\n+        if (m == null) {\n@@ -603,8 +75,1 @@\n-        metricsTester.setup();\n-        metricsTester.testCpuAccounting();\n-        metricsTester.testCpuSchedulingMetrics();\n-        metricsTester.testCpuSets();\n-        metricsTester.testMemorySubsystem();\n-        metricsTester.testBlkIO();\n-        metricsTester.testCpuConsumption();\n-        metricsTester.testMemoryUsage();\n+        metricsTester.testAll(m);\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTester.java","additions":34,"deletions":569,"binary":false,"changes":603,"status":"modified"},{"patch":"@@ -0,0 +1,579 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Scanner;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.platform.CgroupSubsystem;\n+import jdk.internal.platform.CgroupV1Metrics;\n+import jdk.internal.platform.Metrics;\n+import jdk.test.lib.Asserts;\n+\n+public class MetricsTesterCgroupV1 implements CgroupMetricsTester {\n+\n+    \/\/ Aliased for readability\n+    private static final long RETVAL_UNAVAILABLE = CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+    private static long unlimited_minimum = 0x7FFFFFFFFF000000L;\n+    long startSysVal;\n+    long startUserVal;\n+    long startUsage;\n+    long startPerCpu[];\n+\n+    enum Controller {\n+        MEMORY(\"memory\"),\n+        CPUSET(\"cpuset\"),\n+        CPU(\"cpu\"),\n+        CPUACCT(\"cpuacct\"),\n+        BLKIO(\"blkio\");\n+\n+        private String value;\n+\n+        Controller(String value) {\n+            this.value = value;\n+        }\n+\n+        public String value() {\n+            return value;\n+        }\n+    }\n+\n+    private static final Set<String> allowedSubSystems =\n+            Stream.of(Controller.values()).map(Controller::value).collect(Collectors.toSet());\n+\n+    private static final Map<String, String[]> subSystemPaths = new HashMap<>();\n+\n+    private static void setPath(String[] line) {\n+        String cgroupPath = line[2];\n+        String[] subSystems = line[1].split(\",\");\n+\n+        for (String subSystem : subSystems) {\n+            if (allowedSubSystems.contains(subSystem)) {\n+                String[] paths = subSystemPaths.get(subSystem);\n+                String finalPath = \"\";\n+                String root = paths[0];\n+                String mountPoint = paths[1];\n+                if (root != null && cgroupPath != null) {\n+                    if (root.equals(\"\/\")) {\n+                        if (!cgroupPath.equals(\"\/\")) {\n+                            finalPath = mountPoint + cgroupPath;\n+                        } else {\n+                            finalPath = mountPoint;\n+                        }\n+                    } else {\n+                        if (root.equals(cgroupPath)) {\n+                            finalPath = mountPoint;\n+                        } else {\n+                            if (cgroupPath.startsWith(root)) {\n+                                if (cgroupPath.length() > root.length()) {\n+                                    String cgroupSubstr = cgroupPath.substring(root.length());\n+                                    finalPath = mountPoint + cgroupSubstr;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                subSystemPaths.put(subSystem, new String[]{finalPath, mountPoint});\n+            }\n+        }\n+    }\n+\n+    private static void createSubsystems(String[] line) {\n+        if (line.length < 5) return;\n+        Path p = Paths.get(line[4]);\n+        String subsystemName = p.getFileName().toString();\n+        if (subsystemName != null) {\n+            for (String subSystem : subsystemName.split(\",\")) {\n+                if (allowedSubSystems.contains(subSystem)) {\n+                    subSystemPaths.put(subSystem, new String[]{line[3], line[4]});\n+                }\n+            }\n+        }\n+    }\n+\n+    public void setup() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+        startPerCpu = metrics.getPerCpuUsage();\n+\n+        try {\n+            Stream<String> lines = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"));\n+            lines.filter(line -> line.contains(\" - cgroup cgroup \"))\n+                    .map(line -> line.split(\" \"))\n+                    .forEach(MetricsTesterCgroupV1::createSubsystems);\n+            lines.close();\n+\n+            lines = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"));\n+            lines.map(line -> line.split(\":\"))\n+                    .filter(line -> (line.length >= 3))\n+                    .forEach(MetricsTesterCgroupV1::setPath);\n+            lines.close();\n+        } catch (IOException e) {\n+        }\n+    }\n+\n+    private static String getFileContents(Controller subSystem, String fileName) {\n+        String fname = subSystemPaths.get(subSystem.value())[0] + File.separator + fileName;\n+        try {\n+            return new Scanner(new File(fname)).useDelimiter(\"\\\\Z\").next();\n+        } catch (FileNotFoundException e) {\n+            System.err.println(\"Unable to open : \" + fname);\n+            return null;\n+        }\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return (data == null || data.isEmpty()) ? RETVAL_UNAVAILABLE : convertStringToLong(data);\n+    }\n+\n+    private static long convertStringToLong(String strval) {\n+        return CgroupMetricsTester.convertStringToLong(strval, RETVAL_UNAVAILABLE, Long.MAX_VALUE);\n+    }\n+\n+    private static long getLongValueFromFile(Controller subSystem, String metric, String subMetric) {\n+        String stats = getFileContents(subSystem, metric);\n+        String[] tokens = stats.split(\"[\\\\r\\\\n]+\");\n+        for (int i = 0; i < tokens.length; i++) {\n+            if (tokens[i].startsWith(subMetric)) {\n+                String strval = tokens[i].split(\"\\\\s+\")[1];\n+                return convertStringToLong(strval);\n+            }\n+        }\n+        return RETVAL_UNAVAILABLE;\n+    }\n+\n+    private static double getDoubleValueFromFile(Controller subSystem, String fileName) {\n+        String data = getFileContents(subSystem, fileName);\n+        return data == null || data.isEmpty() ? RETVAL_UNAVAILABLE : Double.parseDouble(data);\n+    }\n+\n+    private static void fail(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, String oldVal, String testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, double oldVal, double testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void fail(Controller system, String metric, boolean oldVal, boolean testVal) {\n+        CgroupMetricsTester.fail(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private static void warn(Controller system, String metric, long oldVal, long testVal) {\n+        CgroupMetricsTester.warn(system.value, metric, oldVal, testVal);\n+    }\n+\n+    private Long[] boxedArrayOrNull(long[] primitiveArray) {\n+        if (primitiveArray == null) {\n+            return null;\n+        }\n+        return LongStream.of(primitiveArray).boxed().toArray(Long[]::new);\n+    }\n+\n+    public void testMemorySubsystem() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueFromFile(Controller.MEMORY, \"memory.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/ Kernel memory\n+        oldVal = metrics.getKernelMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getKernelMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/TCP Memory\n+        oldVal = metrics.getTcpMemoryFailCount();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.failcnt\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.failcnt\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED: newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryMaxUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.max_usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.kmem.tcp.usage_in_bytes\", oldVal, newVal);\n+        }\n+\n+        \/\/  Memory and Swap\n+        \/\/ Skip swap tests if no swap is configured.\n+        if (metrics.getMemoryAndSwapLimit() > metrics.getMemoryLimit()) {\n+            oldVal = metrics.getMemoryAndSwapFailCount();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.failcnt\");\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.failcnt\", oldVal, newVal);\n+            }\n+\n+            oldVal = metrics.getMemoryAndSwapLimit();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.limit_in_bytes\");\n+            newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.limit_in_bytes\", oldVal, newVal);\n+            }\n+\n+            oldVal = metrics.getMemoryAndSwapMaxUsage();\n+            newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\");\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.max_usage_in_bytes\", oldVal, newVal);\n+            }\n+\n+            if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                fail(Controller.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n+                oldVal = metrics.getMemoryAndSwapUsage();\n+                newVal = getLongValueFromFile(Controller.MEMORY, \"memory.memsw.usage_in_bytes\");\n+                if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+                    fail(Controller.MEMORY, \"memory.memsw.usage_in_bytes\", oldVal, newVal);\n+                }\n+            }\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongValueFromFile(Controller.MEMORY, \"memory.soft_limit_in_bytes\");\n+        newVal = newVal > unlimited_minimum ? CgroupSubsystem.LONG_RETVAL_UNLIMITED : newVal;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.MEMORY, \"memory.soft_limit_in_bytes\", oldVal, newVal);\n+        }\n+\n+        boolean oomKillEnabled = metrics.isMemoryOOMKillEnabled();\n+        boolean newOomKillEnabled = getLongValueFromFile(Controller.MEMORY,\n+                \"memory.oom_control\", \"oom_kill_disable\") == 0L ? true : false;\n+        if (oomKillEnabled != newOomKillEnabled) {\n+            throw new RuntimeException(\"Test failed for - \" + Controller.MEMORY.value + \":\"\n+                    + \"memory.oom_control:oom_kill_disable\" + \", expected [\"\n+                    + oomKillEnabled + \"], got [\" + newOomKillEnabled + \"]\");\n+        }\n+    }\n+\n+    public void testCpuAccounting() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.usage\");\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage\", oldVal, newVal);\n+        }\n+\n+        String newValsStr = getFileContents(Controller.CPUACCT, \"cpuacct.usage_percpu\");\n+        Long[] newVals = null;\n+        if (newValsStr != null) {\n+            newVals = Stream.of(newValsStr\n+                .split(\"\\\\s+\"))\n+                .map(Long::parseLong)\n+                .toArray(Long[]::new);\n+        }\n+        Long[] oldVals = boxedArrayOrNull(metrics.getPerCpuUsage());\n+        if (oldVals != null) {\n+            for (int i = 0; i < oldVals.length; i++) {\n+                if (!CgroupMetricsTester.compareWithErrorMargin(oldVals[i], newVals[i])) {\n+                    warn(Controller.CPUACCT, \"cpuacct.usage_percpu\", oldVals[i], newVals[i]);\n+                }\n+            }\n+        } else {\n+            Asserts.assertNull(newVals, Controller.CPUACCT.value() + \"cpuacct.usage_percpu not both null\");\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"user\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - user\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpuacct.stat\", \"system\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(Controller.CPUACCT, \"cpuacct.usage - system\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSchedulingMetrics() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_period_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_period_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.cfs_quota_us\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.cfs_quota_us\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.shares\");\n+        if (newVal == 0 || newVal == 1024) newVal = -1;\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.shares\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_periods\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - nr_throttled\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = getLongValueFromFile(Controller.CPUACCT, \"cpu.stat\", \"throttled_time\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.CPUACCT, \"cpu.stat - throttled_time\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuSets() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        Integer[] oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+\n+        String cpusstr = getFileContents(Controller.CPUSET, \"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.cpus\", Arrays.toString(oldVal),\n+                Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSets = metrics.getEffectiveCpuSetCpus();\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(cpuSets);\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_cpus\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.effective_cpus\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n+        }\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.mems\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n+        }\n+\n+        int [] cpuSetMems = metrics.getEffectiveCpuSetMems();\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(cpuSetMems);\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getFileContents(Controller.CPUSET, \"cpuset.effective_mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(Controller.CPUSET, \"cpuset.effective_mems\", Arrays.toString(oldVal),\n+                    Arrays.toString(newVal));\n+        }\n+\n+        double oldValue = metrics.getCpuSetMemoryPressure();\n+        double newValue = getDoubleValueFromFile(Controller.CPUSET, \"cpuset.memory_pressure\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldValue, newValue)) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure\", oldValue, newValue);\n+        }\n+\n+        boolean oldV = metrics.isCpuSetMemoryPressureEnabled();\n+        boolean newV = getLongValueFromFile(Controller.CPUSET,\n+                \"cpuset.memory_pressure_enabled\") == 1 ? true : false;\n+        if (oldV != newV) {\n+            fail(Controller.CPUSET, \"cpuset.memory_pressure_enabled\", oldV, newV);\n+        }\n+    }\n+\n+    private void testBlkIO() {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+            long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getLongValueFromFile(Controller.BLKIO,\n+                \"blkio.throttle.io_service_bytes\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_service_bytes - Total\",\n+                    oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getLongValueFromFile(Controller.BLKIO, \"blkio.throttle.io_serviced\", \"Total\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(Controller.BLKIO, \"blkio.throttle.io_serviced - Total\", oldVal, newVal);\n+        }\n+    }\n+\n+    public void testCpuConsumption() throws IOException, InterruptedException {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+        long[] newPerCpu = metrics.getPerCpuUsage();\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(Controller.CPU, \"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(Controller.CPU, \"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(Controller.CPU, \"getCpuUsage\", newUsage, startUsage);\n+        }\n+\n+        if (startPerCpu != null) {\n+            boolean success = false;\n+            for (int i = 0; i < startPerCpu.length; i++) {\n+                if (newPerCpu[i] > startPerCpu[i]) {\n+                    success = true;\n+                    break;\n+                }\n+            }\n+            if (!success) {\n+                fail(Controller.CPU, \"getPerCpuUsage\", Arrays.toString(newPerCpu),\n+                                                       Arrays.toString(startPerCpu));\n+            }\n+        } else {\n+            Asserts.assertNull(newPerCpu, Controller.CPU.value() + \" getPerCpuUsage not both null\");\n+        }\n+\n+    }\n+\n+    public void testMemoryUsage() throws Exception {\n+        CgroupV1Metrics metrics = (CgroupV1Metrics)Metrics.systemMetrics();\n+        long memoryMaxUsage = metrics.getMemoryMaxUsage();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryMaxUsage = 0, newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might see seldom the effect of decreasing new memory values\n+        \/\/ e.g. because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+        newMemoryMaxUsage = metrics.getMemoryMaxUsage();\n+\n+        if (newMemoryMaxUsage < memoryMaxUsage) {\n+            fail(Controller.MEMORY, \"getMemoryMaxUsage\", memoryMaxUsage,\n+                    newMemoryMaxUsage);\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(Controller.MEMORY, \"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testBlkIO();\n+    }\n+}\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV1.java","additions":579,"deletions":0,"binary":false,"changes":579,"status":"added"},{"patch":"@@ -0,0 +1,462 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.containers.cgroup;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import jdk.internal.platform.Metrics;\n+\n+public class MetricsTesterCgroupV2 implements CgroupMetricsTester {\n+\n+    private static final long UNLIMITED = -1;\n+    private static final long NOT_AVAILABLE = -1;\n+    private static final UnifiedController UNIFIED = new UnifiedController();\n+    private static final String MAX = \"max\";\n+    private static final int PER_CPU_SHARES = 1024;\n+\n+    private final long startSysVal;\n+    private final long startUserVal;\n+    private final long startUsage;\n+\n+    static class UnifiedController {\n+\n+        private static final String NAME = \"unified\";\n+        private final String path;\n+\n+        UnifiedController() {\n+            path = constructPath();\n+        }\n+\n+        String getPath() {\n+            return path;\n+        }\n+\n+        private static String constructPath() {\n+            String mountPath;\n+            String cgroupPath;\n+            try {\n+                List<String> fifthTokens = Files.lines(Paths.get(\"\/proc\/self\/mountinfo\"))\n+                        .filter( l -> l.contains(\"- cgroup2\"))\n+                        .map(UnifiedController::splitAndMountPath)\n+                        .collect(Collectors.toList());\n+                if (fifthTokens.size() != 1) {\n+                    throw new AssertionError(\"Expected only one cgroup2 line\");\n+                }\n+                mountPath = fifthTokens.get(0);\n+\n+                List<String> cgroupPaths = Files.lines(Paths.get(\"\/proc\/self\/cgroup\"))\n+                        .filter( l -> l.startsWith(\"0:\"))\n+                        .map(UnifiedController::splitAndCgroupPath)\n+                        .collect(Collectors.toList());\n+                if (cgroupPaths.size() != 1) {\n+                    throw new AssertionError(\"Expected only one unified controller line\");\n+                }\n+                cgroupPath = cgroupPaths.get(0);\n+                return Paths.get(mountPath, cgroupPath).toString();\n+            } catch (IOException e) {\n+                return null;\n+            }\n+        }\n+\n+        public static String splitAndMountPath(String input) {\n+            String[] tokens = input.split(\"\\\\s+\");\n+            return tokens[4]; \/\/ fifth entry is the mount path\n+        }\n+\n+        public static String splitAndCgroupPath(String input) {\n+            String[] tokens = input.split(\":\");\n+            return tokens[2];\n+        }\n+    }\n+\n+    private long getLongLimitValueFromFile(String file) {\n+        String strVal = getStringVal(file);\n+        if (MAX.equals(strVal)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(strVal);\n+    }\n+\n+    public MetricsTesterCgroupV2() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ Initialize CPU usage metrics before we do any testing.\n+        startSysVal = metrics.getCpuSystemUsage();\n+        startUserVal = metrics.getCpuUserUsage();\n+        startUsage = metrics.getCpuUsage();\n+    }\n+\n+    private long getLongValueFromFile(String file) {\n+        return convertStringToLong(getStringVal(file));\n+    }\n+\n+    private long getLongValueEntryFromFile(String file, String metric) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            String strVal = Files.lines(filePath).filter(l -> l.startsWith(metric)).collect(Collectors.joining());\n+            String[] keyValues = strVal.split(\"\\\\s+\");\n+            String value = keyValues[1];\n+            return convertStringToLong(value);\n+        } catch (IOException e) {\n+            return NOT_AVAILABLE;\n+        }\n+    }\n+\n+    private String getStringVal(String file) {\n+        Path filePath = Paths.get(UNIFIED.getPath(), file);\n+        try {\n+            return Files.lines(filePath).collect(Collectors.joining());\n+        } catch (IOException e) {\n+            return null;\n+        }\n+    }\n+\n+    private void fail(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void fail(String metric, String oldVal, String newVal) {\n+        CgroupMetricsTester.fail(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private void warn(String metric, long oldVal, long newVal) {\n+        CgroupMetricsTester.warn(UnifiedController.NAME, metric, oldVal, newVal);\n+    }\n+\n+    private long getCpuShares(String file) {\n+        long rawVal = getLongValueFromFile(file);\n+        if (rawVal == NOT_AVAILABLE || rawVal == 100) {\n+            return UNLIMITED;\n+        }\n+        int shares = (int)rawVal;\n+        \/\/ CPU shares (OCI) value needs to get translated into\n+        \/\/ a proper Cgroups v2 value. See:\n+        \/\/ https:\/\/github.com\/containers\/crun\/blob\/master\/crun.1.md#cpu-controller\n+        \/\/\n+        \/\/ Use the inverse of (x == OCI value, y == cgroupsv2 value):\n+        \/\/ ((262142 * y - 1)\/9999) + 2 = x\n+        \/\/\n+        int x = 262142 * shares - 1;\n+        double frac = x\/9999.0;\n+        x = ((int)frac) + 2;\n+        if ( x <= PER_CPU_SHARES ) {\n+            return PER_CPU_SHARES; \/\/ mimic cgroups v1\n+        }\n+        int f = x\/PER_CPU_SHARES;\n+        int lower_multiple = f * PER_CPU_SHARES;\n+        int upper_multiple = (f + 1) * PER_CPU_SHARES;\n+        int distance_lower = Math.max(lower_multiple, x) - Math.min(lower_multiple, x);\n+        int distance_upper = Math.max(upper_multiple, x) - Math.min(upper_multiple, x);\n+        x = distance_lower <= distance_upper ? lower_multiple : upper_multiple;\n+        return x;\n+    }\n+\n+    private long getCpuMaxValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 0 \/* $MAX index *\/);\n+    }\n+\n+    private long getCpuPeriodValueFromFile(String file) {\n+        return getCpuValueFromFile(file, 1 \/* $PERIOD index *\/);\n+    }\n+\n+    private long getCpuValueFromFile(String file, int index) {\n+        String maxPeriod = getStringVal(file);\n+        if (maxPeriod == null) {\n+            return UNLIMITED;\n+        }\n+        String[] tokens = maxPeriod.split(\"\\\\s+\");\n+        String val = tokens[index];\n+        if (MAX.equals(val)) {\n+            return UNLIMITED;\n+        }\n+        return convertStringToLong(val);\n+    }\n+\n+    private long convertStringToLong(String val) {\n+        return CgroupMetricsTester.convertStringToLong(val, NOT_AVAILABLE, UNLIMITED);\n+    }\n+\n+    private long nanosOrUnlimited(long micros) {\n+        if (micros < 0) {\n+            return UNLIMITED;\n+        }\n+        return TimeUnit.MICROSECONDS.toNanos(micros);\n+    }\n+\n+    @Override\n+    public void testMemorySubsystem() {\n+        Metrics metrics = Metrics.systemMetrics();\n+\n+        \/\/ User Memory\n+        long oldVal = metrics.getMemoryFailCount();\n+        long newVal = getLongValueEntryFromFile(\"memory.events\", \"max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.events[max]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.max\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryUsage();\n+        newVal = getLongValueFromFile(\"memory.current\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.current\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getTcpMemoryUsage();\n+        newVal = getLongValueEntryFromFile(\"memory.stat\", \"sock\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.stat[sock]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.swap.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.swap.max\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemoryAndSwapUsage();\n+        newVal = getLongValueFromFile(\"memory.swap.current\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.swap.current\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getMemorySoftLimit();\n+        newVal = getLongLimitValueFromFile(\"memory.low\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"memory.low\", oldVal, newVal);\n+        }\n+\n+    }\n+\n+    @Override\n+    public void testCpuAccounting() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuUsage();\n+        long newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"usage_usec\"));\n+\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[usage_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuUserUsage();\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"user_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[user_usec]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuSystemUsage();\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"system_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            warn(\"cpu.stat[system_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSchedulingMetrics() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getCpuPeriod();\n+        long newVal = getCpuPeriodValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$PERIOD]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuQuota();\n+        newVal = getCpuMaxValueFromFile(\"cpu.max\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.max[$MAX]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuShares();\n+        newVal = getCpuShares(\"cpu.weight\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.weight\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumPeriods();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_periods\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_periods]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuNumThrottled();\n+        newVal = getLongValueEntryFromFile(\"cpu.stat\", \"nr_throttled\");\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[nr_throttled]\", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getCpuThrottledTime();\n+        newVal = nanosOrUnlimited(getLongValueEntryFromFile(\"cpu.stat\", \"throttled_usec\"));\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"cpu.stat[throttled_usec]\", oldVal, newVal);\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuSets() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        Integer[] oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+\n+        String cpusstr = getStringVal(\"cpuset.cpus\");\n+        \/\/ Parse range string in the format 1,2-6,7\n+        Integer[] newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(\"cpuset.cpus\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getEffectiveCpuSetCpus());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getStringVal(\"cpuset.cpus.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(\"cpuset.cpus.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(\"cpuset.mems\", Arrays.toString(oldVal),\n+                                Arrays.toString(newVal));\n+        }\n+\n+        oldVal = CgroupMetricsTester.boxedArrayOrNull(metrics.getEffectiveCpuSetMems());\n+        oldVal = CgroupMetricsTester.sortAllowNull(oldVal);\n+        cpusstr = getStringVal(\"cpuset.mems.effective\");\n+        newVal = CgroupMetricsTester.convertCpuSetsToArray(cpusstr);\n+        newVal = CgroupMetricsTester.sortAllowNull(newVal);\n+        if (!Arrays.equals(oldVal, newVal)) {\n+            fail(\"cpuset.mems.effective\", Arrays.toString(oldVal),\n+                                          Arrays.toString(newVal));\n+        }\n+    }\n+\n+    @Override\n+    public void testCpuConsumption() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        \/\/ make system call\n+        long newSysVal = metrics.getCpuSystemUsage();\n+        long newUserVal = metrics.getCpuUserUsage();\n+        long newUsage = metrics.getCpuUsage();\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newSysVal < startSysVal) {\n+            fail(\"getCpuSystemUsage\", newSysVal, startSysVal);\n+        }\n+\n+        \/\/ system\/user CPU usage counters may be slowly increasing.\n+        \/\/ allow for equal values for a pass\n+        if (newUserVal < startUserVal) {\n+            fail(\"getCpuUserUsage\", newUserVal, startUserVal);\n+        }\n+\n+        if (newUsage <= startUsage) {\n+            fail(\"getCpuUsage\", newUsage, startUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMemoryUsage() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long memoryUsage = metrics.getMemoryUsage();\n+        long newMemoryUsage = 0;\n+\n+        \/\/ allocate memory in a loop and check more than once for new values\n+        \/\/ otherwise we might occasionally see the effect of decreasing new memory\n+        \/\/ values. For example because the system could free up memory\n+        byte[][] bytes = new byte[32][];\n+        for (int i = 0; i < 32; i++) {\n+            bytes[i] = new byte[8*1024*1024];\n+            newMemoryUsage = metrics.getMemoryUsage();\n+            if (newMemoryUsage > memoryUsage) {\n+                break;\n+            }\n+        }\n+\n+        if (newMemoryUsage < memoryUsage) {\n+            fail(\"getMemoryUsage\", memoryUsage, newMemoryUsage);\n+        }\n+    }\n+\n+    @Override\n+    public void testMisc() {\n+        testIOStat();\n+    }\n+\n+    private void testIOStat() {\n+        Metrics metrics = Metrics.systemMetrics();\n+        long oldVal = metrics.getBlkIOServiceCount();\n+        long newVal = getIoStatAccumulate(new String[] { \"rios\", \"wios\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rios\/wios: \", oldVal, newVal);\n+        }\n+\n+        oldVal = metrics.getBlkIOServiced();\n+        newVal = getIoStatAccumulate(new String[] { \"rbytes\", \"wbytes\" });\n+        if (!CgroupMetricsTester.compareWithErrorMargin(oldVal, newVal)) {\n+            fail(\"io.stat->rbytes\/wbytes: \", oldVal, newVal);\n+        }\n+    }\n+\n+    private long getIoStatAccumulate(String[] matchNames) {\n+        try {\n+            return Files.lines(Paths.get(UNIFIED.getPath(), \"io.stat\"))\n+                    .map(line -> {\n+                        long accumulator = 0;\n+                        String[] tokens = line.split(\"\\\\s+\");\n+                        for (String t: tokens) {\n+                            String[] keyVal = t.split(\"=\");\n+                            if (keyVal.length != 2) {\n+                                continue;\n+                            }\n+                            for (String match: matchNames) {\n+                                if (match.equals(keyVal[0])) {\n+                                    accumulator += Long.parseLong(keyVal[1]);\n+                                }\n+                            }\n+                        }\n+                        return accumulator;\n+                    }).collect(Collectors.summingLong(e -> e));\n+        } catch (IOException e) {\n+            return NOT_AVAILABLE;\n+        }\n+    }\n+}\n","filename":"jdk\/test\/lib\/jdk\/test\/lib\/containers\/cgroup\/MetricsTesterCgroupV2.java","additions":462,"deletions":0,"binary":false,"changes":462,"status":"added"},{"patch":"@@ -446,0 +446,3 @@\n+  public native int validateCgroup(String procCgroups,\n+                                   String procSelfCgroup,\n+                                   String procSelfMountinfo);\n","filename":"jdk\/test\/lib\/sun\/hotspot\/WhiteBox.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8151788\n+ * @bug 8151788 8286526\n@@ -44,1 +44,1 @@\n-        byte[] nonce = new byte[10];\n+        byte[] nonce = new byte[8];\n","filename":"jdk\/test\/sun\/net\/www\/protocol\/http\/NULLTargetInfoTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2022a\n+tzdata2022c\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,0 +185,1 @@\n+Link Africa\/Abidjan Atlantic\/Reykjavik\t# Iceland\n@@ -195,1 +196,1 @@\n-# observatory; round to nearest.  Milne also says that the official time for\n+# observatory.  Milne also says that the official time for\n@@ -380,0 +381,1 @@\n+\t\t#STDOFF\t2:05:08.9\n@@ -433,1 +435,1 @@\n-# [Ordinance No. 11 of 1928, The Offical Gazette, 1928-06-26, p 813]\n+# [Ordinance No. 11 of 1928, The Official Gazette, 1928-06-26, p 813]\n@@ -1143,2 +1145,1 @@\n-\t\t\t 0:00\tMorocco\t+00\/+01\t2087 May 11  2:00\n-\t\t\t 1:00\t-\t+01\n+\t\t\t 0:00\tMorocco\t+00\/+01\n@@ -1160,2 +1161,1 @@\n-\t\t\t 0:00\tMorocco\t+00\/+01\t2087 May 11  2:00\n-\t\t\t 1:00\t-\t+01\n+\t\t\t 0:00\tMorocco\t+00\/+01\n@@ -1338,9 +1338,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tIndian\/Reunion\t3:41:52 -\tLMT\t1911 Jun # Saint-Denis\n-\t\t\t4:00\t-\t+04\n-#\n-# Scattered Islands (Îles Éparses) administered from Réunion are as follows.\n-# The following information about them is taken from\n-# Îles Éparses (<http:\/\/www.outre-mer.gouv.fr\/domtom\/ile.htm>, 1997-07-22,\n-# in French; no longer available as of 1999-08-17).\n-# We have no info about their time zone histories.\n+# See Asia\/Dubai.\n@@ -1348,5 +1340,1 @@\n-# Bassas da India - uninhabited\n-# Europa Island - inhabited from 1905 to 1910 by two families\n-# Glorioso Is - inhabited until at least 1958\n-# Juan de Nova - uninhabited\n-# Tromelin - inhabited until at least 1958\n+# The Crozet Islands also observe Réunion time; see the 'antarctica' file.\n@@ -1384,1 +1372,1 @@\n-# coordinated time, will be restituted at 2 o'clock on day 1 of January, 2019.]\n+# coordinated time, will be reinstituted at 2 o'clock on day 1 of January, 2019.]\n@@ -1387,0 +1375,1 @@\n+\t\t#STDOFF\t-0:36:44.68\n@@ -1396,22 +1385,1 @@\n-\n-# From P Chan (2020-11-27):\n-# Standard Time was adopted on 1907-01-01.\n-#\n-# Standard Time Ordinance (Chapter 237)\n-# The Laws of Seychelles in Force on the 31st December, 1971, Vol. 6, p 571\n-# https:\/\/books.google.com\/books?id=efE-AQAAIAAJ&pg=PA571\n-#\n-# From Tim Parenti (2020-12-05):\n-# A footnote on https:\/\/books.google.com\/books?id=DYdDAQAAMAAJ&pg=PA1689\n-# confirms that Ordinance No. 9 of 1906 \"was brought into force on the 1st\n-# January, 1907.\"\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tIndian\/Mahe\t3:41:48 -\tLMT\t1907 Jan  1 # Victoria\n-\t\t\t4:00\t-\t+04\n-# From Paul Eggert (2001-05-30):\n-# Aldabra, Farquhar, and Desroches, originally dependencies of the\n-# Seychelles, were transferred to the British Indian Ocean Territory\n-# in 1965 and returned to Seychelles control in 1976.  We don't know\n-# whether this affected their time zone, so omit this for now.\n-# Possibly the islands were uninhabited.\n+# See Asia\/Dubai.\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/africa","additions":11,"deletions":43,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -183,3 +183,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Indian\/Kerguelen\t0\t-\t-00\t1950 # Port-aux-Français\n-\t\t\t5:00\t-\t+05\n+# Kerguelen - see Indian\/Maldives.\n@@ -268,25 +266,1 @@\n-# From Craig Mundell (1994-12-15):\n-# http:\/\/quest.arc.nasa.gov\/antarctica\/QA\/computers\/Directions,Time,ZIP\n-# Vostok, which is one of the Russian stations, is set on the same\n-# time as Moscow, Russia.\n-#\n-# From Lee Hotz (2001-03-08):\n-# I queried the folks at Columbia who spent the summer at Vostok and this is\n-# what they had to say about time there:\n-# \"in the US Camp (East Camp) we have been on New Zealand (McMurdo)\n-# time, which is 12 hours ahead of GMT. The Russian Station Vostok was\n-# 6 hours behind that (although only 2 miles away, i.e. 6 hours ahead\n-# of GMT). This is a time zone I think two hours east of Moscow. The\n-# natural time zone is in between the two: 8 hours ahead of GMT.\"\n-#\n-# From Paul Eggert (2001-05-04):\n-# This seems to be hopelessly confusing, so I asked Lee Hotz about it\n-# in person.  He said that some Antarctic locations set their local\n-# time so that noon is the warmest part of the day, and that this\n-# changes during the year and does not necessarily correspond to mean\n-# solar noon.  So the Vostok time might have been whatever the clocks\n-# happened to be during their visit.  So we still don't really know what time\n-# it is at Vostok.  But we'll guess +06.\n-#\n-Zone Antarctica\/Vostok\t0\t-\t-00\t1957 Dec 16\n-\t\t\t6:00\t-\t+06\n+# See Asia\/Urumqi.\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/antarctica","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -281,4 +281,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tAsia\/Brunei\t7:39:40 -\tLMT\t1926 Mar # Bandar Seri Begawan\n-\t\t\t7:30\t-\t+0730\t1933\n-\t\t\t8:00\t-\t+08\n+# See Asia\/Kuching.\n@@ -302,0 +299,1 @@\n+Link Asia\/Yangon Indian\/Cocos\n@@ -370,6 +368,3 @@\n-# a. For the 1940 May 31 spring forward, the essay claim that it was\n-# coordinared between the international settlement authority and the French\n-# concession authority and have gathered support from Hong Kong and Xiamen,\n-# that it would spring forward an hour from May 31 \"midnight\", and the essay\n-# claim \"Hong Kong government implemented the spring forward in the same time\n-# on the same date as Shanghai\".\n+# a. For the 1940 May 31 spring forward, the essay [says] ... \"Hong\n+# Kong government implemented the spring forward in the same time on\n+# the same date as Shanghai\".\n@@ -571,1 +566,1 @@\n-# Milne gives 8:05:43.2 for Xujiahui Observatory time; round to nearest.\n+# Milne gives 8:05:43.2 for Xujiahui Observatory time....\n@@ -690,0 +685,1 @@\n+\t\t#STDOFF\t8:05:43.2\n@@ -697,0 +693,1 @@\n+Link Asia\/Urumqi Antarctica\/Vostok\n@@ -701,1 +698,1 @@\n-# Milne gives 7:36:41.7; round this.\n+# Milne gives 7:36:41.7.\n@@ -885,1 +882,2 @@\n-Zone\tAsia\/Hong_Kong\t7:36:42 -\tLMT\t1904 Oct 30  0:36:42\n+\t\t#STDOFF\t7:36:41.7\n+Zone\tAsia\/Hong_Kong\t7:36:42 -\tLMT\t1904 Oct 29 17:00u\n@@ -1360,1 +1358,1 @@\n-# civil time was 7:07:12.5; round to even for Jakarta.\n+# civil time was 7:07:12.5.\n@@ -1396,0 +1394,1 @@\n+\t\t#STDOFF\t7:07:12.5\n@@ -1399,1 +1398,1 @@\n-\t\t\t7:07:12\t-\tBMT\t1923 Dec 31 23:47:12 # Batavia\n+\t\t\t7:07:12\t-\tBMT\t1923 Dec 31 16:40u # Batavia\n@@ -1431,0 +1430,105 @@\n+# From Roozbeh Pournader (2022-05-30):\n+# Here's an order from the Cabinet to the rest of the government to switch to\n+# Tehran time, which is mentioned to be already at +03:30:\n+# https:\/\/qavanin.ir\/Law\/TreeText\/180138\n+# Just in case that goes away, I also saved a copy at archive.org:\n+# https:\/\/web.archive.org\/web\/20220530111940\/https:\/\/qavanin.ir\/Law\/TreeText\/180138\n+# Here's my translation:\n+#\n+# \"Circular on Matching the Hours of Governmental and Official Circles\n+# in Provinces\n+# Approved 1314\/03\/22 [=1935-06-13]\n+# According to the ruling of the Honorable Cabinet, it is ordered that from\n+# now on in all internal provinces of the country, governmental and official\n+# circles set their time to match Tehran time (three hours and half before\n+# Greenwich)....\n+#\n+# I still haven't found out when Tehran itself switched to +03:30....\n+#\n+# From Paul Eggert (2022-06-05):\n+# Although the above says Tehran was at +03:30 before 1935-06-13, we don't\n+# know when it switched to +03:30.  For now, use 1935-06-13 as the switch date.\n+# Although most likely wrong, we have no better info.\n+\n+# From Roozbeh Pournader (2022-06-01):\n+# This is from Kayhan newspaper, one of the major Iranian newspapers, from\n+# March 20, 1978, page 2:\n+#\n+# \"Pull the clocks 60 minutes forward\n+# As we informed before, from the fourth day of the month Farvardin of the\n+# new year [=1978-03-24], clocks will be pulled forward, and people's daily\n+# work and life program will start one hour earlier than the current program.\n+# On the 1st day of the month Farvardin of this year [=1977-03-21], they had\n+# pulled the clocks forward by one hour, but in the month of Mehr\n+# [=1977-09-23], the clocks were pulled back by 30 minutes.\n+# In this way, from the 4th day of the month Farvardin, clocks will be ahead\n+# of the previous years by one hour and a half.\n+# According to the new program, during the night of 4th of Farvardin, when\n+# the midnight, meaning 24 o'clock is announced, the hands of the clock must\n+# be pulled forward by one hour and thus consider midnight 1 o'clock in the\n+# forenoon.\"\n+#\n+# This implies that in September 1977, when the daylight savings time was\n+# done with, Iran didn't go back to +03:30, but immediately to +04:00.\n+#\n+#\n+# This is from the major Iranian newspaper Ettela'at, dated [1978-08-03]...,\n+# page 32. It looks like they decided to get the clocks back to +4:00\n+# just in time for Ramadan that year:\n+#\n+# \"Tomorrow Night, Pull the Clocks Back by One Hour\n+# At 1 o'clock in the forenoon of Saturday 14 Mordad [=1978-08-05], the\n+# clocks will be pulled one hour back and instead of 1 o'clock in the\n+# forenoon, Radio Iran will announce 24 o'clock.\n+# This decision was made in the Cabinet of Ministers meeting of 25 Tir\n+# [=1978-07-16], [...]\n+# At the beginning of the year 2537 [=March 1978: Iran was using a different\n+# year number for a few years then, based on the Coronation of Cyrus the\n+# Great], the country's official time was pulled forward by one hour and now\n+# the official time is one hour and a half ahead compared to last year,\n+# because in Farvardin of last year [=March 1977], the official time was\n+# pulled forward one hour and this continued until the second half of last\n+# year [=September 1977] until in the second half of last year the official\n+# time was pulled back half an hour and that half hour still remains.\"\n+#\n+# This matches the time of the true noon published in the newspapers, as they\n+# clearly go from +05:00 to +04:00 after that date (which happened during a\n+# long weekend in Iran).\n+\n+# From Roozbeh Pournader (2022-05-31):\n+# [Movahedi S. Cultural preconceptions of time: Can we use operational time\n+# to meddle in God's Time? Comp Stud Soc Hist. 1985;27(3):385-400]\n+# https:\/\/www.jstor.org\/stable\/178704\n+# Here's the quotes from the paper:\n+# 1. '\"Iran's official time keeper moved the clock one hour forward as from\n+# March 22, 1977 (Farvardin 2, 2536) to make maximum use of daylight and save\n+# in energy consumption. Thus Iran joined such other countries as Britain in\n+# observing what is known as 'daylight saving.' The proposal was originally\n+# put forward by the Ministry of Energy, in no way having any influence on\n+# observing religious ceremonies. Moving time one hour forward in summer\n+# means that at 11:00 o'clock on March 21, the official time was set as\n+# midnight March 22. Then September 24 will actually begin one hour later\n+# than the end of September 23 [...].\" Iran's time base thus continued to be\n+# Greenwich Mean Time plus three and one-half hours (plus four and one-half\n+# hours in summer).'\n+#\n+# The article sources this from Iran Almanac and Book of Facts, 1977, Tehran:\n+# Echo of Iran, which is on Google Books at\n+# https:\/\/www.google.com\/books\/edition\/Iran_Almanac_and_Book_of_Facts\/9ybVAAAAMAAJ.\n+# (I confirmed it by searching for snippets.)\n+#\n+# 2. \"After the fall of the shah, the revolutionary government returned to\n+# daylight-saving time (DST) on 26 May 1979.\"\n+#\n+# This seems to have been announced just one day in advance, on 25 May 1979.\n+#\n+# The change in 1977 clearly seems to be the first daylight savings effort in\n+# Iran. But the article doesn't mention what happened in 1978 (which was\n+# still during the shah's government), or how things continued in 1979\n+# onwards (which was during the Islamic Republic).\n+\n+# From Francis Santoni (2022-06-01):\n+# for Iran and 1977 the effective change is only 20 October\n+# (UIT No. 143 17.XI.1977) and not 23 September (UIT No. 141 13.IX.1977).\n+# UIT is the Operational Bulletin of International Telecommunication Union.\n+\n@@ -1465,59 +1569,6 @@\n-# From Paul Eggert (2018-11-30):\n-# Go with Shanks & Pottenger before Sept. 1991, and with Pournader thereafter.\n-# I used the following code in GNU Emacs 26.1 to generate the \"Rule Iran\"\n-# lines from 2008 through 2087.  Emacs 26.1 uses Ed Reingold's\n-# cal-persia implementation of Birashk's approximation, which in the\n-# 2008-2087 range disagrees with the astronomical Persian calendar\n-# for Persian years 1404 (Gregorian 2025) and 1437 (Gregorian 2058), so\n-# the following code special-cases those years.  See Table 15.1, page 264, of:\n-# Edward M. Reingold and Nachum Dershowitz, Calendrical Calculations:\n-# The Ultimate Edition, Cambridge University Press (2018).\n-# https:\/\/www.cambridge.org\/fr\/academic\/subjects\/computer-science\/computing-general-interest\/calendrical-calculations-ultimate-edition-4th-edition\n-# Page 258, footnote 2, of this book says there is some dispute over what will\n-# happen in 2091 (and some other years after that), so this code\n-# stops in 2087, as 2088 and 2089 agree with the \"max\" rule below.\n-# (cl-loop\n-#  initially (require 'cal-persia)\n-#  with first-persian-year = 1387\n-#  with last-persian-year = 1466\n-#  ;; Exceptional years in the above range,\n-#  ;; from Reingold & Dershowitz Table 15.1, page 264:\n-#  with exceptional-persian-years = '(1404 1437)\n-#  with range-start = nil\n-#  for persian-year from first-persian-year to last-persian-year\n-#  do\n-#  (let*\n-#      ((exceptional-year-offset\n-#        (if (member persian-year exceptional-persian-years) 1 0))\n-#       (beg-dst-absolute\n-#        (+ (calendar-persian-to-absolute (list 1 1 persian-year))\n-#           exceptional-year-offset))\n-#       (end-dst-absolute\n-#        (+ (calendar-persian-to-absolute (list 6 30 persian-year))\n-#           exceptional-year-offset))\n-#       (next-year-beg-dst-absolute\n-#        (+ (calendar-persian-to-absolute (list 1 1 (1+ persian-year)))\n-#           (if (member (1+ persian-year) exceptional-persian-years) 1 0)))\n-#       (beg-dst (calendar-gregorian-from-absolute beg-dst-absolute))\n-#       (end-dst (calendar-gregorian-from-absolute end-dst-absolute))\n-#       (next-year-beg-dst (calendar-gregorian-from-absolute\n-#                           next-year-beg-dst-absolute))\n-#       (year (calendar-extract-year beg-dst))\n-#       (range-end (if range-start year \"only\")))\n-#    (setq range-start (or range-start year))\n-#    (when (or (\/= (calendar-extract-day beg-dst)\n-#                  (calendar-extract-day next-year-beg-dst))\n-#              (= persian-year last-persian-year))\n-#      (insert\n-#       (format\n-#        \"Rule\\tIran\\t%d\\t%s\\t-\\t%s\\t%2d\\t24:00\\t1:00\\t-\\n\"\n-#        range-start range-end\n-#        (calendar-month-name (calendar-extract-month beg-dst) t)\n-#        (calendar-extract-day beg-dst)))\n-#      (insert\n-#       (format\n-#        \"Rule\\tIran\\t%d\\t%s\\t-\\t%s\\t%2d\\t24:00\\t0\\t-\\n\"\n-#        range-start range-end\n-#        (calendar-month-name (calendar-extract-month end-dst) t)\n-#        (calendar-extract-day end-dst)))\n-#      (setq range-start nil))))\n+# From Paul Eggert (2022-06-30):\n+# Go with Pournader for 1935 through spring 1979, and for timestamps\n+# after August 1991; go with with Shanks & Pottenger for other timestamps.\n+# Go with Santoni's citation of the UIT for fall 1977, as 20 October 1977\n+# is 28 Mehr 1356, consistent with the \"Mehr\" in Pournader's source.\n+# Assume that the UIT's \"1930\" is UTC, i.e., 24:00 local time.\n@@ -1557,0 +1608,6 @@\n+# From Ali Mirjamali (2022-05-10):\n+# Official IR News Agency announcement: irna.ir\/xjJ3TT\n+# ...\n+# Highlights: DST will be cancelled for the next Iranian year 1402\n+# (i.e 2023-March-21) and forthcoming years.\n+#\n@@ -1558,2 +1615,8 @@\n-Rule\tIran\t1978\t1980\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t1978\tonly\t-\tOct\t20\t24:00\t0\t-\n+# Work around a bug in zic 2022a and earlier.\n+Rule\tIran\t1910\tonly\t-\tJan\t 1\t00:00\t0\t-\n+#\n+Rule\tIran\t1977\tonly\t-\tMar\t21\t23:00\t1:00\t-\n+Rule\tIran\t1977\tonly\t-\tOct\t20\t24:00\t0\t-\n+Rule\tIran\t1978\tonly\t-\tMar\t24\t24:00\t1:00\t-\n+Rule\tIran\t1978\tonly\t-\tAug\t 5\t01:00\t0\t-\n+Rule\tIran\t1979\tonly\t-\tMay\t26\t24:00\t1:00\t-\n@@ -1561,0 +1624,1 @@\n+Rule\tIran\t1980\tonly\t-\tMar\t20\t24:00\t1:00\t-\n@@ -1591,74 +1655,2 @@\n-Rule\tIran\t2021\t2023\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2021\t2023\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2024\tonly\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2024\tonly\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2025\t2027\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2025\t2027\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2028\t2029\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2028\t2029\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2030\t2031\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2030\t2031\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2032\t2033\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2032\t2033\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2034\t2035\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2034\t2035\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2036\t2037\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2036\t2037\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2038\t2039\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2038\t2039\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2040\t2041\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2040\t2041\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2042\t2043\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2042\t2043\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2044\t2045\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2044\t2045\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2046\t2047\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2046\t2047\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2048\t2049\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2048\t2049\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2050\t2051\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2050\t2051\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2052\t2053\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2052\t2053\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2054\t2055\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2054\t2055\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2056\t2057\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2056\t2057\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2058\t2059\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2058\t2059\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2060\t2062\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2060\t2062\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2063\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2063\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2064\t2066\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2064\t2066\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2067\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2067\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2068\t2070\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2068\t2070\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2071\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2071\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2072\t2074\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2072\t2074\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2075\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2075\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2076\t2078\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2076\t2078\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2079\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2079\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2080\t2082\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2080\t2082\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2083\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2083\tonly\t-\tSep\t21\t24:00\t0\t-\n-Rule\tIran\t2084\t2086\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2084\t2086\t-\tSep\t20\t24:00\t0\t-\n-Rule\tIran\t2087\tonly\t-\tMar\t21\t24:00\t1:00\t-\n-Rule\tIran\t2087\tonly\t-\tSep\t21\t24:00\t0\t-\n-#\n-# The following rules are approximations starting in the year 2088.\n-# These are the best post-2088 approximations available, given the\n-# restrictions of a single rule using ordinary Gregorian dates.\n-# At some point this table will need to be extended, though quite\n-# possibly Iran will change the rules first.\n-Rule\tIran\t2088\tmax\t-\tMar\t20\t24:00\t1:00\t-\n-Rule\tIran\t2088\tmax\t-\tSep\t20\t24:00\t0\t-\n+Rule\tIran\t2021\t2022\t-\tMar\t21\t24:00\t1:00\t-\n+Rule\tIran\t2021\t2022\t-\tSep\t21\t24:00\t0\t-\n@@ -1668,2 +1660,2 @@\n-\t\t\t3:25:44\t-\tTMT\t1946     # Tehran Mean Time\n-\t\t\t3:30\t-\t+0330\t1977 Nov\n+\t\t\t3:25:44\t-\tTMT\t1935 Jun 13 # Tehran Mean Time\n+\t\t\t3:30\tIran\t+0330\/+0430 1977 Oct 20 24:00\n@@ -2491,3 +2483,3 @@\n-# Qyzyolrda Region (Asia\/Qyzylorda) is changing its time zone from\n-# UTC+6 to UTC+5 effective December 21st, 2018. The legal document is\n-# located here: http:\/\/adilet.zan.kz\/rus\/docs\/P1800000817 (russian language).\n+# (Asia\/Qyzylorda) is changing its time zone from UTC+6 to UTC+5\n+# effective December 21st, 2018....\n+# http:\/\/adilet.zan.kz\/rus\/docs\/P1800000817 (russian language).\n@@ -2770,14 +2762,2 @@\n-# peninsular Malaysia\n-# taken from Mok Ly Yng (2003-10-30)\n-# https:\/\/web.archive.org\/web\/20190822231045\/http:\/\/www.math.nus.edu.sg\/~mathelmr\/teaching\/timezone.html\n-# This agrees with Singapore since 1905-06-01.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Asia\/Kuala_Lumpur\t6:46:46 -\tLMT\t1901 Jan  1\n-\t\t\t6:55:25\t-\tSMT\t1905 Jun  1 # Singapore M.T.\n-\t\t\t7:00\t-\t+07\t1933 Jan  1\n-\t\t\t7:00\t0:20\t+0720\t1936 Jan  1\n-\t\t\t7:20\t-\t+0720\t1941 Sep  1\n-\t\t\t7:30\t-\t+0730\t1942 Feb 16\n-\t\t\t9:00\t-\t+09\t1945 Sep 12\n-\t\t\t7:30\t-\t+0730\t1982 Jan  1\n-\t\t\t8:00\t-\t+08\n+# For peninsular Malaysia see Asia\/Singapore.\n+#\n@@ -2794,0 +2774,1 @@\n+Link Asia\/Kuching Asia\/Brunei\n@@ -2800,0 +2781,1 @@\n+Link Indian\/Maldives Indian\/Kerguelen\n@@ -3634,0 +3616,1 @@\n+Link Asia\/Singapore Asia\/Kuala_Lumpur\n@@ -3868,1 +3851,1 @@\n-\t\t\t5:00\t1:00\t+05\/+06\t1991 Sep  9  2:00s\n+\t\t\t5:00\t1:00\t+06\t1991 Sep  9  2:00s\n@@ -3878,0 +3861,1 @@\n+Link Asia\/Bangkok Indian\/Christmas\n@@ -3893,0 +3877,2 @@\n+Link Asia\/Dubai Indian\/Mahe\n+Link Asia\/Dubai Indian\/Reunion\n@@ -3904,1 +3890,2 @@\n-# Milne says Tashkent was 4:37:10.8; round to nearest.\n+# Milne says Tashkent was 4:37:10.8.\n+\t\t#STDOFF\t4:37:10.8\n@@ -3923,1 +3910,1 @@\n-# From Paul Eggert (2014-10-21) after a heads-up from Trần Ngọc Quân:\n+# From Paul Eggert (2022-07-27) after a 2014 heads-up from Trần Ngọc Quân:\n@@ -3935,2 +3922,2 @@\n-# the Paris Meridian (2° 20' 14.03\" E); the former yields 07:06:30.1333...\n-# and the latter 07:06:29.333... so either way it rounds to 07:06:30,\n+# the Paris Meridian; for now guess the former and round the exact\n+# 07:06:30.1333... to 07:06:30.13 as the legal spec used 66 2\/3 ms precision.\n@@ -3963,1 +3950,2 @@\n-Zone Asia\/Ho_Chi_Minh\t7:06:40 -\tLMT\t1906 Jul  1\n+\t\t#STDOFF\t7:06:30.13\n+Zone Asia\/Ho_Chi_Minh\t7:06:30 -\tLMT\t1906 Jul  1\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/asia","additions":163,"deletions":175,"binary":false,"changes":338,"status":"modified"},{"patch":"@@ -278,3 +278,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Indian\/Christmas\t7:02:52 -\tLMT\t1895 Feb\n-\t\t\t7:00\t-\t+07\n+# See Asia\/Bangkok.\n@@ -283,5 +281,1 @@\n-# These islands were ruled by the Ross family from about 1830 to 1978.\n-# We don't know when standard time was introduced; for now, we guess 1900.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tIndian\/Cocos\t6:27:40\t-\tLMT\t1900\n-\t\t\t6:30\t-\t+0630\n+# See Asia\/Yangon.\n@@ -504,0 +498,5 @@\n+Link Pacific\/Tarawa Pacific\/Funafuti\n+Link Pacific\/Tarawa Pacific\/Majuro\n+Link Pacific\/Tarawa Pacific\/Wake\n+Link Pacific\/Tarawa Pacific\/Wallis\n+\n@@ -517,0 +516,1 @@\n+# See Pacific\/Tarawa for most locations.\n@@ -518,8 +518,0 @@\n-Zone Pacific\/Majuro\t 11:24:48 -\tLMT\t1901\n-\t\t\t 11:00\t-\t+11\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 11:00\t-\t+11\t1937\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1944 Jan 30\n-\t\t\t 11:00\t-\t+11\t1969 Oct\n-\t\t\t 12:00\t-\t+12\n@@ -535,0 +527,2 @@\n+# For Chuuk and Yap see Pacific\/Port_Moresby.\n+# For Pohnpei see Pacific\/Guadalcanal.\n@@ -536,15 +530,0 @@\n-Zone Pacific\/Chuuk\t-13:52:52 -\tLMT\t1844 Dec 31\n-\t\t\t 10:07:08 -\tLMT\t1901\n-\t\t\t 10:00\t-\t+10\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1945 Aug\n-\t\t\t 10:00\t-\t+10\n-Zone Pacific\/Pohnpei\t-13:27:08 -\tLMT\t1844 Dec 31\t# Kolonia\n-\t\t\t 10:32:52 -\tLMT\t1901\n-\t\t\t 11:00\t-\t+11\t1914 Oct\n-\t\t\t  9:00\t-\t+09\t1919 Feb  1\n-\t\t\t 11:00\t-\t+11\t1937\n-\t\t\t 10:00\t-\t+10\t1941 Apr  1\n-\t\t\t  9:00\t-\t+09\t1945 Aug\n-\t\t\t 11:00\t-\t+11\n@@ -620,0 +599,2 @@\n+Link Pacific\/Auckland Antarctica\/McMurdo\n+\n@@ -624,2 +605,0 @@\n-Link Pacific\/Auckland Antarctica\/McMurdo\n-\n@@ -684,1 +663,1 @@\n-# See Pacific\/Raratonga comments for 1952 transition.\n+# See Pacific\/Rarotonga comments for 1952 transition.\n@@ -720,0 +699,1 @@\n+Link Pacific\/Port_Moresby Pacific\/Chuuk\n@@ -847,0 +827,1 @@\n+Link Pacific\/Guadalcanal Pacific\/Pohnpei\n@@ -887,3 +868,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Pacific\/Funafuti\t11:56:52 -\tLMT\t1901\n-\t\t\t12:00\t-\t+12\n+# See Pacific\/Tarawa.\n@@ -948,3 +927,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tPacific\/Wake\t11:06:28 -\tLMT\t1901\n-\t\t\t12:00\t-\t+12\n+# See Pacific\/Tarawa.\n@@ -989,3 +966,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tPacific\/Wallis\t12:15:20 -\tLMT\t1901\n-\t\t\t12:00\t-\t+12\n+# See Pacific\/Tarawa.\n@@ -1309,0 +1284,1 @@\n+# [The article ends with \"Today's date is April 1.\"]\n@@ -1852,10 +1828,6 @@\n-# From Phake Nick (2018-10-27):\n-# <https:\/\/wiki.suikawiki.org\/n\/南洋群島の標準時> ... pointed out that\n-# currently tzdata say Pacific\/Kwajalein switched from GMT+11 to GMT-12 in\n-# 1969 October without explanation, however an 1993 article from NYT say it\n-# synchorized its day with US mainland about 40 years ago and thus the switch\n-# should occur at around 1950s instead.\n-#\n-# From Paul Eggert (2018-11-18):\n-# The NYT (actually, AP) article is vague and possibly wrong about this.\n-# The article says the earlier switch was \"40 years ago when the United States\n+# From Paul Eggert (2022-03-31):\n+# Phake Nick (2018-10-27) noted <https:\/\/wiki.suikawiki.org\/n\/南洋群島の標準時>'s\n+# citation of a 1993 AP article published in the New York Times saying\n+# Kwajalein synchronized its day with the US mainland about 40 years earlier.\n+# However the AP article is vague and possibly wrong about this.  The article\n+# says the earlier switch was \"about 40 years ago when the United States\n@@ -1908,7 +1880,0 @@\n-# Alan Eugene Davis writes (1996-03-16),\n-# \"I am certain, having lived there for the past decade, that 'Truk'\n-# (now properly known as Chuuk) ... is in the time zone GMT+10.\"\n-#\n-# Shanks & Pottenger write that Truk switched from UT +10 to +11\n-# on 1978-10-01; ignore this for now.\n-\n@@ -2245,1 +2210,1 @@\n-# In August government was disolved by the King.  The current prime minister\n+# In August government was dissolved by the King.  The current prime minister\n@@ -2253,20 +2218,0 @@\n-# Wake\n-\n-# From Vernice Anderson, Personal Secretary to Philip Jessup,\n-# US Ambassador At Large (oral history interview, 1971-02-02):\n-#\n-# Saturday, the 14th [of October, 1950] - ...  The time was all the\n-# more confusing at that point, because we had crossed the\n-# International Date Line, thus getting two Sundays.  Furthermore, we\n-# discovered that Wake Island had two hours of daylight saving time\n-# making calculation of time in Washington difficult if not almost\n-# impossible.\n-#\n-# https:\/\/www.trumanlibrary.org\/oralhist\/andrsonv.htm\n-\n-# From Paul Eggert (2003-03-23):\n-# We have no other report of DST in Wake Island, so omit this info for now.\n-\n-# See also the commentary for Micronesia.\n-\n-\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/australasia","additions":26,"deletions":81,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-# Many names changed in late 1993.  Several of these names are\n+# Many names changed in late 1993, and many merged names moved here\n+# in the period from 2013 through 2022.  Several of these names are\n@@ -34,0 +35,4 @@\n+# Although this file is optional and tzdb will work if you omit it by\n+# building with 'make BACKWARD=', in practice downstream users\n+# typically use this file for backward compatibility.\n+\n@@ -74,1 +79,1 @@\n-Link\tEurope\/Oslo\t\tAtlantic\/Jan_Mayen\n+Link\tEurope\/Berlin\t\tAtlantic\/Jan_Mayen\n@@ -109,0 +114,1 @@\n+Link\tEurope\/Kyiv\t\tEurope\/Kiev\n@@ -117,1 +123,1 @@\n-Link\tAtlantic\/Reykjavik\tIceland\n+Link\tAfrica\/Abidjan\t\tIceland\n@@ -133,1 +139,1 @@\n-Link\tPacific\/Pohnpei\t\tPacific\/Ponape\n+Link\tPacific\/Guadalcanal\tPacific\/Ponape\n@@ -135,2 +141,2 @@\n-Link\tPacific\/Chuuk\t\tPacific\/Truk\n-Link\tPacific\/Chuuk\t\tPacific\/Yap\n+Link\tPacific\/Port_Moresby\tPacific\/Truk\n+Link\tPacific\/Port_Moresby\tPacific\/Yap\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/backward","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+\n+# The following zone is used by tzcode functions like gmtime,\n+# which load the \"UTC\" file to handle seconds properly.\n@@ -47,2 +50,3 @@\n-# as functions like gmtime load the \"GMT\" file to handle leap seconds properly.\n-# We want this to work even on installations that omit the other older names.\n+# as it is needed for tzcode releases through 2022a,\n+# where functions like gmtime load \"GMT\" instead of the \"Etc\/UTC\".\n+# We want this to work even on installations that omit 'backward'.\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/etcetera","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -329,2 +329,1 @@\n-# transition for now and just use the latter value, omitting its\n-# fraction since our format cannot represent fractions.\n+# transition for now and just use the latter value.\n@@ -526,1 +525,1 @@\n-Zone\tEurope\/London\t-0:01:15 -\tLMT\t1847 Dec  1  0:00s\n+Zone\tEurope\/London\t-0:01:15 -\tLMT\t1847 Dec  1\n@@ -564,1 +563,2 @@\n-Zone\tEurope\/Dublin\t-0:25:00 -\tLMT\t1880 Aug  2\n+\t\t#STDOFF\t-0:25:21.1\n+Zone\tEurope\/Dublin\t-0:25:21 -\tLMT\t1880 Aug  2\n@@ -987,0 +987,2 @@\n+Link Europe\/Brussels Europe\/Amsterdam\n+Link Europe\/Brussels Europe\/Luxembourg\n@@ -1049,1 +1051,1 @@\n-# Use Europe\/Prague also for Slovakia.\n+Link Europe\/Prague Europe\/Bratislava\n@@ -1051,1 +1053,0 @@\n-# Denmark, Faroe Islands, and Greenland\n@@ -1053,31 +1054,2 @@\n-# From Jesper Nørgaard Welen (2005-04-26):\n-# the law [introducing standard time] was in effect from 1894-01-01....\n-# The page https:\/\/www.retsinformation.dk\/eli\/lta\/1893\/83\n-# confirms this, and states that the law was put forth 1893-03-29.\n-#\n-# The EU [actually, EEC and Euratom] treaty with effect from 1973:\n-# https:\/\/www.retsinformation.dk\/eli\/lta\/1972\/21100\n-#\n-# This provoked a new law from 1974 to make possible summer time changes\n-# in subsequent decrees with the law\n-# https:\/\/www.retsinformation.dk\/eli\/lta\/1974\/223\n-#\n-# It seems however that no decree was set forward until 1980.  I have\n-# not found any decree, but in another related law, the effecting DST\n-# changes are stated explicitly to be from 1980-04-06 at 02:00 to\n-# 1980-09-28 at 02:00.  If this is true, this differs slightly from\n-# the EU rule in that DST runs to 02:00, not 03:00.  We don't know\n-# when Denmark began using the EU rule correctly, but we have only\n-# confirmation of the 1980-time, so I presume it was correct in 1981:\n-# The law is about the management of the extra hour, concerning\n-# working hours reported and effect on obligatory-rest rules (which\n-# was suspended on that night):\n-# https:\/\/web.archive.org\/web\/20140104053304\/https:\/\/www.retsinformation.dk\/Forms\/R0710.aspx?id=60267\n-\n-# From Jesper Nørgaard Welen (2005-06-11):\n-# The Herning Folkeblad (1980-09-26) reported that the night between\n-# Saturday and Sunday the clock is set back from three to two.\n-\n-# From Paul Eggert (2005-06-11):\n-# Hence the \"02:00\" of the 1980 law refers to standard time, not\n-# wall-clock time, and so the EU rules were in effect in 1980.\n+# Denmark, Faroe Islands, and Greenland\n+# For Denmark see Europe\/Berlin.\n@@ -1085,20 +1057,0 @@\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tDenmark\t1916\tonly\t-\tMay\t14\t23:00\t1:00\tS\n-Rule\tDenmark\t1916\tonly\t-\tSep\t30\t23:00\t0\t-\n-Rule\tDenmark\t1940\tonly\t-\tMay\t15\t 0:00\t1:00\tS\n-Rule\tDenmark\t1945\tonly\t-\tApr\t 2\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1945\tonly\t-\tAug\t15\t 2:00s\t0\t-\n-Rule\tDenmark\t1946\tonly\t-\tMay\t 1\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1946\tonly\t-\tSep\t 1\t 2:00s\t0\t-\n-Rule\tDenmark\t1947\tonly\t-\tMay\t 4\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1947\tonly\t-\tAug\t10\t 2:00s\t0\t-\n-Rule\tDenmark\t1948\tonly\t-\tMay\t 9\t 2:00s\t1:00\tS\n-Rule\tDenmark\t1948\tonly\t-\tAug\t 8\t 2:00s\t0\t-\n-#\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Copenhagen\t 0:50:20 -\tLMT\t1890\n-\t\t\t 0:50:20 -\tCMT\t1894 Jan  1 # Copenhagen MT\n-\t\t\t 1:00\tDenmark\tCE%sT\t1942 Nov  2  2:00s\n-\t\t\t 1:00\tC-Eur\tCE%sT\t1945 Apr  2  2:00\n-\t\t\t 1:00\tDenmark\tCE%sT\t1980\n-\t\t\t 1:00\tEU\tCE%sT\n@@ -1324,2 +1276,1 @@\n-# Milne says Helsinki (Helsingfors) time was 1:39:49.2 (official document);\n-# round to nearest.\n+# Milne says Helsinki (Helsingfors) time was 1:39:49.2 (official document).\n@@ -1328,0 +1279,1 @@\n+\t\t#STDOFF\t1:39:49.2\n@@ -1474,0 +1426,1 @@\n+Link Europe\/Paris Europe\/Monaco\n@@ -1517,0 +1470,4 @@\n+Link Europe\/Berlin Arctic\/Longyearbyen\n+Link Europe\/Berlin Europe\/Copenhagen\n+Link Europe\/Berlin Europe\/Oslo\n+Link Europe\/Berlin Europe\/Stockholm\n@@ -1518,14 +1475,0 @@\n-# From Tobias Conradi (2011-09-12):\n-# Büsingen <http:\/\/www.buesingen.de>, surrounded by the Swiss canton\n-# Schaffhausen, did not start observing DST in 1980 as the rest of DE\n-# (West Germany at that time) and DD (East Germany at that time) did.\n-# DD merged into DE, the area is currently covered by code DE in ISO 3166-1,\n-# which in turn is covered by the zone Europe\/Berlin.\n-#\n-# Source for the time in Büsingen 1980:\n-# http:\/\/www.srf.ch\/player\/video?id=c012c029-03b7-4c2b-9164-aa5902cd58d3\n-\n-# From Arthur David Olson (2012-03-03):\n-# Büsingen and Zurich have shared clocks since 1970.\n-\n-Link\tEurope\/Zurich\tEurope\/Busingen\n@@ -1540,1 +1483,1 @@\n-Zone Europe\/Gibraltar\t-0:21:24 -\tLMT\t1880 Aug  2  0:00s\n+Zone Europe\/Gibraltar\t-0:21:24 -\tLMT\t1880 Aug  2\n@@ -1651,56 +1594,1 @@\n-#\n-# From Adam David (1993-11-06):\n-# The name of the timezone in Iceland for system \/ mail \/ news purposes is GMT.\n-#\n-# (1993-12-05):\n-# This material is paraphrased from the 1988 edition of the University of\n-# Iceland Almanak.\n-#\n-# From January 1st, 1908 the whole of Iceland was standardised at 1 hour\n-# behind GMT. Previously, local mean solar time was used in different parts\n-# of Iceland, the almanak had been based on Reykjavík mean solar time which\n-# was 1 hour and 28 minutes behind GMT.\n-#\n-# \"first day of winter\" referred to [below] means the first day of the 26 weeks\n-# of winter, according to the old icelandic calendar that dates back to the\n-# time the norsemen first settled Iceland.  The first day of winter is always\n-# Saturday, but is not dependent on the Julian or Gregorian calendars.\n-#\n-# (1993-12-10):\n-# I have a reference from the Oxford Icelandic-English dictionary for the\n-# beginning of winter, which ties it to the ecclesiastical calendar (and thus\n-# to the julian\/gregorian calendar) over the period in question.\n-#\tthe winter begins on the Saturday next before St. Luke's day\n-#\t(old style), or on St. Luke's day, if a Saturday.\n-# St. Luke's day ought to be traceable from ecclesiastical sources. \"old style\"\n-# might be a reference to the Julian calendar as opposed to Gregorian, or it\n-# might mean something else (???).\n-#\n-# From Paul Eggert (2014-11-22):\n-# The information below is taken from the 1988 Almanak; see\n-# http:\/\/www.almanak.hi.is\/klukkan.html\n-#\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tIceland\t1917\t1919\t-\tFeb\t19\t23:00\t1:00\t-\n-Rule\tIceland\t1917\tonly\t-\tOct\t21\t 1:00\t0\t-\n-Rule\tIceland\t1918\t1919\t-\tNov\t16\t 1:00\t0\t-\n-Rule\tIceland\t1921\tonly\t-\tMar\t19\t23:00\t1:00\t-\n-Rule\tIceland\t1921\tonly\t-\tJun\t23\t 1:00\t0\t-\n-Rule\tIceland\t1939\tonly\t-\tApr\t29\t23:00\t1:00\t-\n-Rule\tIceland\t1939\tonly\t-\tOct\t29\t 2:00\t0\t-\n-Rule\tIceland\t1940\tonly\t-\tFeb\t25\t 2:00\t1:00\t-\n-Rule\tIceland\t1940\t1941\t-\tNov\tSun>=2\t 1:00s\t0\t-\n-Rule\tIceland\t1941\t1942\t-\tMar\tSun>=2\t 1:00s\t1:00\t-\n-# 1943-1946 - first Sunday in March until first Sunday in winter\n-Rule\tIceland\t1943\t1946\t-\tMar\tSun>=1\t 1:00s\t1:00\t-\n-Rule\tIceland\t1942\t1948\t-\tOct\tSun>=22\t 1:00s\t0\t-\n-# 1947-1967 - first Sunday in April until first Sunday in winter\n-Rule\tIceland\t1947\t1967\t-\tApr\tSun>=1\t 1:00s\t1:00\t-\n-# 1949 and 1967 Oct transitions delayed by 1 week\n-Rule\tIceland\t1949\tonly\t-\tOct\t30\t 1:00s\t0\t-\n-Rule\tIceland\t1950\t1966\t-\tOct\tSun>=22\t 1:00s\t0\t-\n-Rule\tIceland\t1967\tonly\t-\tOct\t29\t 1:00s\t0\t-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Atlantic\/Reykjavik\t-1:28\t-\tLMT\t1908\n-\t\t\t-1:00\tIceland\t-01\/+00\t1968 Apr  7  1:00s\n-\t\t\t 0:00\t-\tGMT\n+# See Africa\/Abidjan.\n@@ -1822,1 +1710,1 @@\n-\t\t\t0:49:56\t-\tRMT\t1893 Oct 31 23:49:56 # Rome Mean\n+\t\t\t0:49:56\t-\tRMT\t1893 Oct 31 23:00u # Rome Mean\n@@ -1827,0 +1715,3 @@\n+Link Europe\/Rome Europe\/Vatican\n+Link Europe\/Rome Europe\/San_Marino\n+\n@@ -1832,3 +1723,0 @@\n-Link\tEurope\/Rome\tEurope\/Vatican\n-Link\tEurope\/Rome\tEurope\/San_Marino\n-\n@@ -1918,10 +1806,1 @@\n-\n-# From Paul Eggert (2013-09-09):\n-# Shanks & Pottenger say Vaduz is like Zurich.\n-\n-# From Alois Treindl (2019-07-04):\n-# I was able to access the online archive of the Vaduz paper Vaterland ...\n-# I could confirm from the paper that Liechtenstein did in fact follow\n-# the same DST in 1941 and 1942 as Switzerland did.\n-\n-Link Europe\/Zurich Europe\/Vaduz\n+# See Europe\/Zurich.\n@@ -1983,34 +1862,1 @@\n-# Whitman disagrees with most of these dates in minor ways;\n-# go with Shanks & Pottenger.\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tLux\t1916\tonly\t-\tMay\t14\t23:00\t1:00\tS\n-Rule\tLux\t1916\tonly\t-\tOct\t 1\t 1:00\t0\t-\n-Rule\tLux\t1917\tonly\t-\tApr\t28\t23:00\t1:00\tS\n-Rule\tLux\t1917\tonly\t-\tSep\t17\t 1:00\t0\t-\n-Rule\tLux\t1918\tonly\t-\tApr\tMon>=15\t 2:00s\t1:00\tS\n-Rule\tLux\t1918\tonly\t-\tSep\tMon>=15\t 2:00s\t0\t-\n-Rule\tLux\t1919\tonly\t-\tMar\t 1\t23:00\t1:00\tS\n-Rule\tLux\t1919\tonly\t-\tOct\t 5\t 3:00\t0\t-\n-Rule\tLux\t1920\tonly\t-\tFeb\t14\t23:00\t1:00\tS\n-Rule\tLux\t1920\tonly\t-\tOct\t24\t 2:00\t0\t-\n-Rule\tLux\t1921\tonly\t-\tMar\t14\t23:00\t1:00\tS\n-Rule\tLux\t1921\tonly\t-\tOct\t26\t 2:00\t0\t-\n-Rule\tLux\t1922\tonly\t-\tMar\t25\t23:00\t1:00\tS\n-Rule\tLux\t1922\tonly\t-\tOct\tSun>=2\t 1:00\t0\t-\n-Rule\tLux\t1923\tonly\t-\tApr\t21\t23:00\t1:00\tS\n-Rule\tLux\t1923\tonly\t-\tOct\tSun>=2\t 2:00\t0\t-\n-Rule\tLux\t1924\tonly\t-\tMar\t29\t23:00\t1:00\tS\n-Rule\tLux\t1924\t1928\t-\tOct\tSun>=2\t 1:00\t0\t-\n-Rule\tLux\t1925\tonly\t-\tApr\t 5\t23:00\t1:00\tS\n-Rule\tLux\t1926\tonly\t-\tApr\t17\t23:00\t1:00\tS\n-Rule\tLux\t1927\tonly\t-\tApr\t 9\t23:00\t1:00\tS\n-Rule\tLux\t1928\tonly\t-\tApr\t14\t23:00\t1:00\tS\n-Rule\tLux\t1929\tonly\t-\tApr\t20\t23:00\t1:00\tS\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Luxembourg\t0:24:36 -\tLMT\t1904 Jun\n-\t\t\t1:00\tLux\tCE%sT\t1918 Nov 25\n-\t\t\t0:00\tLux\tWE%sT\t1929 Oct  6  2:00s\n-\t\t\t0:00\tBelgium\tWE%sT\t1940 May 14  3:00\n-\t\t\t1:00\tC-Eur\tWE%sT\t1944 Sep 18  3:00\n-\t\t\t1:00\tBelgium\tCE%sT\t1977\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Brussels.\n@@ -2035,1 +1881,1 @@\n-Zone\tEurope\/Malta\t0:58:04 -\tLMT\t1893 Nov  2  0:00s # Valletta\n+Zone\tEurope\/Malta\t0:58:04 -\tLMT\t1893 Nov  2 # Valletta\n@@ -2117,21 +1963,1 @@\n-#\n-# From Michael Deckers (2020-06-12):\n-# In the \"Journal de Monaco\" of 1892-05-24, online at\n-# https:\/\/journaldemonaco.gouv.mc\/var\/jdm\/storage\/original\/application\/b1c67c12c5af11b41ea888fb048e4fe8.pdf\n-# we read: ...\n-#  [In virtue of a Sovereign Ordinance of the May 13 of the current [year],\n-#   legal time in the Principality will be set to, from the date of June 1,\n-#   1892 onwards, to the meridian of Paris, as in France.]\n-# In the \"Journal de Monaco\" of 1911-03-28, online at\n-# https:\/\/journaldemonaco.gouv.mc\/var\/jdm\/storage\/original\/application\/de74ffb7db53d4f599059fe8f0ed482a.pdf\n-# we read an ordinance of 1911-03-16: ...\n-#  [Legal time in the Principality will be set, from the date of promulgation\n-#   of the present ordinance, to legal time in France....  Consequently, legal\n-#   time will be retarded by 9 minutes and 21 seconds.]\n-#\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tEurope\/Monaco\t0:29:32 -\tLMT\t1892 Jun  1\n-\t\t\t0:09:21\t-\tPMT\t1911 Mar 29 # Paris Mean Time\n-\t\t\t0:00\tFrance\tWE%sT\t1945 Sep 16  3:00\n-\t\t\t1:00\tFrance\tCE%sT\t1977\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Paris.\n@@ -2143,76 +1969,1 @@\n-\n-# Howse writes that the Netherlands' railways used GMT between 1892 and 1940,\n-# but for other purposes the Netherlands used Amsterdam mean time.\n-\n-# However, Robert H. van Gent writes (2001-04-01):\n-# Howse's statement is only correct up to 1909. From 1909-05-01 (00:00:00\n-# Amsterdam mean time) onwards, the whole of the Netherlands (including\n-# the Dutch railways) was required by law to observe Amsterdam mean time\n-# (19 minutes 32.13 seconds ahead of GMT). This had already been the\n-# common practice (except for the railways) for many decades but it was\n-# not until 1909 when the Dutch government finally defined this by law.\n-# On 1937-07-01 this was changed to 20 minutes (exactly) ahead of GMT and\n-# was generally known as Dutch Time (\"Nederlandse Tijd\").\n-#\n-# (2001-04-08):\n-# 1892-05-01 was the date when the Dutch railways were by law required to\n-# observe GMT while the remainder of the Netherlands adhered to the common\n-# practice of following Amsterdam mean time.\n-#\n-# (2001-04-09):\n-# In 1835 the authorities of the province of North Holland requested the\n-# municipal authorities of the towns and cities in the province to observe\n-# Amsterdam mean time but I do not know in how many cases this request was\n-# actually followed.\n-#\n-# From 1852 onwards the Dutch telegraph offices were by law required to\n-# observe Amsterdam mean time. As the time signals from the observatory of\n-# Leiden were also distributed by the telegraph system, I assume that most\n-# places linked up with the telegraph (and railway) system automatically\n-# adopted Amsterdam mean time.\n-#\n-# Although the early Dutch railway companies initially observed a variety\n-# of times, most of them had adopted Amsterdam mean time by 1858 but it\n-# was not until 1866 when they were all required by law to observe\n-# Amsterdam mean time.\n-\n-# The data entries before 1945 are taken from\n-# https:\/\/www.staff.science.uu.nl\/~gent0113\/wettijd\/wettijd.htm\n-\n-# From Paul Eggert (2021-05-09):\n-# I invented the abbreviations AMT for Amsterdam Mean Time and NST for\n-# Netherlands Summer Time, used in the Netherlands from 1835 to 1937.\n-\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tNeth\t1916\tonly\t-\tMay\t 1\t0:00\t1:00\tNST\t# Netherlands Summer Time\n-Rule\tNeth\t1916\tonly\t-\tOct\t 1\t0:00\t0\tAMT\t# Amsterdam Mean Time\n-Rule\tNeth\t1917\tonly\t-\tApr\t16\t2:00s\t1:00\tNST\n-Rule\tNeth\t1917\tonly\t-\tSep\t17\t2:00s\t0\tAMT\n-Rule\tNeth\t1918\t1921\t-\tApr\tMon>=1\t2:00s\t1:00\tNST\n-Rule\tNeth\t1918\t1921\t-\tSep\tlastMon\t2:00s\t0\tAMT\n-Rule\tNeth\t1922\tonly\t-\tMar\tlastSun\t2:00s\t1:00\tNST\n-Rule\tNeth\t1922\t1936\t-\tOct\tSun>=2\t2:00s\t0\tAMT\n-Rule\tNeth\t1923\tonly\t-\tJun\tFri>=1\t2:00s\t1:00\tNST\n-Rule\tNeth\t1924\tonly\t-\tMar\tlastSun\t2:00s\t1:00\tNST\n-Rule\tNeth\t1925\tonly\t-\tJun\tFri>=1\t2:00s\t1:00\tNST\n-# From 1926 through 1939 DST began 05-15, except that it was delayed by a week\n-# in years when 05-15 fell in the Pentecost weekend.\n-Rule\tNeth\t1926\t1931\t-\tMay\t15\t2:00s\t1:00\tNST\n-Rule\tNeth\t1932\tonly\t-\tMay\t22\t2:00s\t1:00\tNST\n-Rule\tNeth\t1933\t1936\t-\tMay\t15\t2:00s\t1:00\tNST\n-Rule\tNeth\t1937\tonly\t-\tMay\t22\t2:00s\t1:00\tNST\n-Rule\tNeth\t1937\tonly\t-\tJul\t 1\t0:00\t1:00\tS\n-Rule\tNeth\t1937\t1939\t-\tOct\tSun>=2\t2:00s\t0\t-\n-Rule\tNeth\t1938\t1939\t-\tMay\t15\t2:00s\t1:00\tS\n-Rule\tNeth\t1945\tonly\t-\tApr\t 2\t2:00s\t1:00\tS\n-Rule\tNeth\t1945\tonly\t-\tSep\t16\t2:00s\t0\t-\n-#\n-# Amsterdam Mean Time was +00:19:32.13, but the .13 is omitted\n-# below because the current format requires STDOFF to be an integer.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Amsterdam\t0:19:32 -\tLMT\t1835\n-\t\t\t0:19:32\tNeth\t%s\t1937 Jul  1\n-\t\t\t0:20\tNeth +0020\/+0120 1940 May 16  0:00\n-\t\t\t1:00\tC-Eur\tCE%sT\t1945 Apr  2  2:00\n-\t\t\t1:00\tNeth\tCE%sT\t1977\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Brussels.\n@@ -2221,16 +1972,1 @@\n-# http:\/\/met.no\/met\/met_lex\/q_u\/sommertid.html (2004-01) agrees with Shanks &\n-# Pottenger.\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tNorway\t1916\tonly\t-\tMay\t22\t1:00\t1:00\tS\n-Rule\tNorway\t1916\tonly\t-\tSep\t30\t0:00\t0\t-\n-Rule\tNorway\t1945\tonly\t-\tApr\t 2\t2:00s\t1:00\tS\n-Rule\tNorway\t1945\tonly\t-\tOct\t 1\t2:00s\t0\t-\n-Rule\tNorway\t1959\t1964\t-\tMar\tSun>=15\t2:00s\t1:00\tS\n-Rule\tNorway\t1959\t1965\t-\tSep\tSun>=15\t2:00s\t0\t-\n-Rule\tNorway\t1965\tonly\t-\tApr\t25\t2:00s\t1:00\tS\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tEurope\/Oslo\t0:43:00 -\tLMT\t1895 Jan  1\n-\t\t\t1:00\tNorway\tCE%sT\t1940 Aug 10 23:00\n-\t\t\t1:00\tC-Eur\tCE%sT\t1945 Apr  2  2:00\n-\t\t\t1:00\tNorway\tCE%sT\t1980\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Berlin.\n@@ -2283,1 +2019,1 @@\n-# All these events predate our cutoff date of 1970, so use Europe\/Oslo\n+# All these events predate our cutoff date of 1970, so use Europe\/Berlin\n@@ -2285,1 +2021,1 @@\n-Link\tEurope\/Oslo\tArctic\/Longyearbyen\n+\n@@ -2339,1 +2075,0 @@\n-# Round the old offset to -0:36:45.  This agrees with Willett....\n@@ -2426,0 +2161,1 @@\n+\t\t#STDOFF\t-0:36:44.68\n@@ -2434,1 +2170,0 @@\n-# This Zone can be simplified once we assume zic %z.\n@@ -2437,0 +2172,5 @@\n+# Vanguard section, for zic and other parsers that support %z.\n+#\t\t\t-2:00\tPort\t%z\t1966 Apr  3  2:00\n+#\t\t\t-1:00\tPort\t%z\t1983 Sep 25  1:00s\n+#\t\t\t-1:00\tW-Eur\t%z\t1992 Sep 27  1:00s\n+# Rearguard section, for parsers lacking %z; see ziguard.awk.\n@@ -2448,0 +2188,1 @@\n+# End of rearguard section.\n@@ -2450,1 +2191,0 @@\n-# This Zone can be simplified once we assume zic %z.\n@@ -2453,0 +2193,3 @@\n+# Vanguard section, for zic and other parsers that support %z.\n+#\t\t\t-1:00\tPort\t%z\t1966 Apr  3  2:00\n+# Rearguard section, for parsers lacking %z; see ziguard.awk.\n@@ -2462,0 +2205,1 @@\n+# End of rearguard section.\n@@ -2880,3 +2624,3 @@\n-# From Paul Eggert (2006-03-22):\n-# The _Economist_ (1994-05-28, p 45) reports that central Crimea switched\n-# from Kiev to Moscow time sometime after the January 1994 elections.\n+# From Paul Eggert (2022-07-21):\n+# The _Economist_ (1994-05-28, p 45) reported that central Crimea switched\n+# from Kyiv to Moscow time sometime after the January 1994 elections.\n@@ -2886,1 +2630,1 @@\n-# changed in May.\n+# changed in May.  This change evidently didn't last long; see below.\n@@ -2888,2 +2632,2 @@\n-# From IATA SSIM (1994\/1997), which also says that Kerch is still like Kiev.\n-\t\t\t 3:00\tE-Eur\tMSK\/MSD\t1996 Mar 31  0:00s\n+# From IATA SSIM (1994\/1997), which also said that Kerch is still like Kyiv.\n+\t\t\t 3:00\tC-Eur\tMSK\/MSD\t1996 Mar 31  0:00s\n@@ -2891,1 +2635,1 @@\n-# IATA SSIM (1997-09) says Crimea switched to EET\/EEST.\n+# IATA SSIM (1997-09) said Crimea switched to EET\/EEST.\n@@ -2893,1 +2637,0 @@\n-\t\t\t 3:00\tRussia\tMSK\/MSD\t1997\n@@ -3062,1 +2805,1 @@\n-# Milne says Yekaterinburg was 4:02:32.9; round to nearest.\n+# Milne says Yekaterinburg was 4:02:32.9.\n@@ -3067,0 +2810,1 @@\n+\t\t#STDOFF\t 4:02:32.9\n@@ -3378,2 +3122,2 @@\n-# From Arthur David Olson (2012-05-09):\n-# Tomponskij and Ust'-Majskij switched from Vladivostok time to Yakutsk time\n+# From Arthur David Olson (2022-03-21):\n+# Tomponsky and Ust-Maysky switched from Vladivostok time to Yakutsk time\n@@ -3504,2 +3248,2 @@\n-# From Arthur David Olson (2012-05-09):\n-# Ojmyakonskij [and the Kuril Islands] switched from\n+# From Arthur David Olson (2022-03-21):\n+# Oymyakonsky and the Kuril Islands switched from\n@@ -3579,1 +3323,1 @@\n-Link Europe\/Prague Europe\/Bratislava\n+# See Europe\/Prague.\n@@ -3668,1 +3412,1 @@\n-Zone\tEurope\/Madrid\t-0:14:44 -\tLMT\t1900 Dec 31 23:45:16\n+Zone\tEurope\/Madrid\t-0:14:44 -\tLMT\t1901 Jan  1  0:00u\n@@ -3690,55 +3434,1 @@\n-\n-# From Ivan Nilsson (2001-04-13), superseding Shanks & Pottenger:\n-#\n-# The law \"Svensk författningssamling 1878, no 14\" about standard time in 1879:\n-# From the beginning of 1879 (that is 01-01 00:00) the time for all\n-# places in the country is \"the mean solar time for the meridian at\n-# three degrees, or twelve minutes of time, to the west of the\n-# meridian of the Observatory of Stockholm\".  The law is dated 1878-05-31.\n-#\n-# The observatory at that time had the meridian 18° 03' 30\"\n-# eastern longitude = 01:12:14 in time.  Less 12 minutes gives the\n-# national standard time as 01:00:14 ahead of GMT....\n-#\n-# About the beginning of CET in Sweden. The lawtext (\"Svensk\n-# författningssamling 1899, no 44\") states, that \"from the beginning\n-# of 1900... ... the same as the mean solar time for the meridian at\n-# the distance of one hour of time from the meridian of the English\n-# observatory at Greenwich, or at 12 minutes 14 seconds to the west\n-# from the meridian of the Observatory of Stockholm\". The law is dated\n-# 1899-06-16.  In short: At 1900-01-01 00:00:00 the new standard time\n-# in Sweden is 01:00:00 ahead of GMT.\n-#\n-# 1916: The lawtext (\"Svensk författningssamling 1916, no 124\") states\n-# that \"1916-05-15 is considered to begin one hour earlier\". It is\n-# pretty obvious that at 05-14 23:00 the clocks are set to 05-15 00:00....\n-# Further the law says, that \"1916-09-30 is considered to end one hour later\".\n-#\n-# The laws regulating [DST] are available on the site of the Swedish\n-# Parliament beginning with 1985 - the laws regulating 1980\/1984 are\n-# not available on the site (to my knowledge they are only available\n-# in Swedish): <http:\/\/www.riksdagen.se\/english\/work\/sfst.asp> (type\n-# \"sommartid\" without the quotes in the field \"Fritext\" and then click\n-# the Sök-button).\n-#\n-# (2001-05-13):\n-#\n-# I have now found a newspaper stating that at 1916-10-01 01:00\n-# summertime the church-clocks etc were set back one hour to show\n-# 1916-10-01 00:00 standard time.  The article also reports that some\n-# people thought the switch to standard time would take place already\n-# at 1916-10-01 00:00 summer time, but they had to wait for another\n-# hour before the event took place.\n-#\n-# Source: The newspaper \"Dagens Nyheter\", 1916-10-01, page 7 upper left.\n-\n-# An extra-special abbreviation style is SET for Swedish Time (svensk\n-# normaltid) 1879-1899, 3° west of the Stockholm Observatory.\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Europe\/Stockholm\t1:12:12 -\tLMT\t1879 Jan  1\n-\t\t\t1:00:14\t-\tSET\t1900 Jan  1 # Swedish Time\n-\t\t\t1:00\t-\tCET\t1916 May 14 23:00\n-\t\t\t1:00\t1:00\tCEST\t1916 Oct  1  1:00\n-\t\t\t1:00\t-\tCET\t1980\n-\t\t\t1:00\tEU\tCE%sT\n+# See Europe\/Berlin.\n@@ -3838,0 +3528,13 @@\n+# From Tobias Conradi (2011-09-12):\n+# Büsingen <http:\/\/www.buesingen.de>, surrounded by the Swiss canton\n+# Schaffhausen, did not start observing DST in 1980 as the rest of DE\n+# (West Germany at that time) and DD (East Germany at that time) did.\n+# DD merged into DE, the area is currently covered by code DE in ISO 3166-1,\n+# which in turn is covered by the zone Europe\/Berlin.\n+#\n+# Source for the time in Büsingen 1980:\n+# http:\/\/www.srf.ch\/player\/video?id=c012c029-03b7-4c2b-9164-aa5902cd58d3\n+#\n+# From Arthur David Olson (2012-03-03):\n+# Büsingen and Zurich have shared clocks since 1970.\n+\n@@ -3846,0 +3549,3 @@\n+Link Europe\/Zurich Europe\/Busingen\n+Link Europe\/Zurich Europe\/Vaduz\n+\n@@ -4054,1 +3760,1 @@\n-# From Alois Triendl (2014-03-01):\n+# From Alois Treindl (2014-03-01):\n@@ -4114,1 +3820,1 @@\n-# From Vladimir in Moscow via Alois Treindl re Kiev time 1991\/2 (2014-02-28):\n+# From Vladimir in Moscow via Alois Treindl re Kyiv time 1991\/2 (2014-02-28):\n@@ -4142,1 +3848,1 @@\n-# From Paul Eggert (2018-10-03):\n+# From Paul Eggert (2022-04-12):\n@@ -4144,10 +3850,10 @@\n-# For example, tzdb uses Europe\/Kiev, as \"Kiev\" is the most common spelling in\n-# English for Ukraine's capital, even though it is certainly wrong as a\n-# transliteration of the Ukrainian \"Київ\".  This is similar to tzdb's use of\n-# Europe\/Prague, which is certainly wrong as a transliteration of the Czech\n-# \"Praha\".  (\"Kiev\" came from old Slavic via Russian to English, and \"Prague\"\n-# came from old Slavic via French to English, so the two cases have something\n-# in common.)  Admittedly English-language spelling of Ukrainian names is\n-# controversial, and some day \"Kyiv\" may become substantially more popular in\n-# English; in the meantime, stick with the traditional English \"Kiev\" as that\n-# means less disruption for our users.\n+# In particular, tzdb's name Europe\/Kyiv uses the most common spelling in\n+# English for Ukraine's capital.  Although tzdb's former name was Europe\/Kiev,\n+# \"Kyiv\" is now more common due to widespread reporting of the current conflict.\n+# Conversely, tzdb continues to use the names Europe\/Uzhgorod and\n+# Europe\/Zaporozhye; this is similar to tzdb's use of Europe\/Prague, which is\n+# certainly wrong as a transliteration of the Czech \"Praha\".\n+# English-language spelling of Ukrainian names is in flux, and\n+# some day \"Uzhhorod\" or \"Zaporizhzhia\" may become substantially more\n+# common in English; in the meantime, do not change these\n+# English spellings as that means less disruption for our users.\n@@ -4156,3 +3862,3 @@\n-# This represents most of Ukraine.  See above for the spelling of \"Kiev\".\n-Zone Europe\/Kiev\t2:02:04 -\tLMT\t1880\n-\t\t\t2:02:04\t-\tKMT\t1924 May  2 # Kiev Mean Time\n+# This represents most of Ukraine.  See above for the spelling of \"Kyiv\".\n+Zone Europe\/Kyiv\t2:02:04 -\tLMT\t1880\n+\t\t\t2:02:04\t-\tKMT\t1924 May  2 # Kyiv Mean Time\n@@ -4181,1 +3887,1 @@\n-# \"Zaporizhia\" is the transliteration of the Ukrainian name, but\n+# \"Zaporizhzhia\" is the transliteration of the Ukrainian name, but\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/europe","additions":90,"deletions":384,"binary":false,"changes":474,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-#Expires 2022\tDec\t28\t00:00:00\n+#Expires 2023\tJun\t28\t00:00:00\n@@ -102,1 +102,1 @@\n-#expires 1672185600 (2022-12-28 00:00:00 UTC)\n+#expires 1687910400 (2023-06-28 00:00:00 UTC)\n@@ -104,2 +104,2 @@\n-#\tUpdated through IERS Bulletin C63\n-#\tFile expires on:  28 December 2022\n+#\tUpdated through IERS Bulletin C64\n+#\tFile expires on:  28 June 2023\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/leapseconds","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -370,2 +370,1 @@\n-# Eastern time (i.e., -4:56:01.6) just before the 1883 switch.  Round to the\n-# nearest second.\n+# Eastern time (i.e., -4:56:01.6) just before the 1883 switch.\n@@ -380,1 +379,2 @@\n-Zone America\/New_York\t-4:56:02 -\tLMT\t1883 Nov 18 12:03:58\n+\t\t#STDOFF\t-4:56:01.6\n+Zone America\/New_York\t-4:56:02 -\tLMT\t1883 Nov 18 17:00u\n@@ -2844,1 +2844,1 @@\n-# For 1899 Milne gives -3:58:29.2; round that.\n+# For 1899 Milne gives -3:58:29.2.\n@@ -2888,0 +2888,1 @@\n+\t\t#STDOFF\t-3:58:29.2\n@@ -2948,1 +2949,1 @@\n-# From Paul Eggert (2020-11-24):\n+# From Paul Eggert (2022-07-27):\n@@ -2951,1 +2952,1 @@\n-# Daylight Saving Act, 1917 cited below.  Round that to the nearest second.\n+# Daylight Saving Act, 1917 cited below.\n@@ -3046,0 +3047,1 @@\n+\t\t#STDOFF\t-4:19:18.3\n@@ -3060,1 +3062,1 @@\n-# Milne gives -5:36:13.3 as San José mean time; round to nearest.\n+# Milne gives -5:36:13.3 as San José mean time.\n@@ -3072,0 +3074,1 @@\n+\t\t#STDOFF\t-5:36:13.3\n@@ -3494,1 +3497,1 @@\n-# island\".  Go with Milne.  Round to the nearest second as required by zic.\n+# island\".  Go with Milne.\n@@ -3507,0 +3510,1 @@\n+\t\t#STDOFF\t-5:07:10.41\n@@ -3704,0 +3708,1 @@\n+\t\t#STDOFF\t-5:07:10.41\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/northamerica","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -443,0 +444,1 @@\n+\t\t#STDOFF\t       -4:16:48.25\n@@ -455,0 +457,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -467,0 +470,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -480,0 +484,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -494,0 +499,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -508,0 +514,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -523,0 +530,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -537,0 +545,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -559,0 +568,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -577,0 +587,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -589,0 +600,1 @@\n+\t\t#STDOFF\t-4:16:48.25\n@@ -671,1 +683,1 @@\n-# modern Brazilian eletronic voting machines which, apparently, can't deal\n+# modern Brazilian ... voting machines which, apparently, can't deal\n@@ -1167,1 +1179,1 @@\n-# From Tim Parenti (2022-03-15):\n+# From Tim Parenti (2022-07-06):\n@@ -1185,1 +1197,8 @@\n-# seconds\".\n+# seconds\".  Although this law specified the new Summer Time to start on 1\n+# September each year, a special \"transitional article\" started it a few days\n+# early, as soon as the law took effect.  As the law was to take force \"from\n+# the date of its publication in the 'Diario Oficial', which happened the\n+# following day, presume the change took place in Santiago and its environs\n+# from 24:00 -03 to 23:00 -04 on Wednesday 1946-08-28.  Although this was a\n+# no-op for wall clocks in the north and south of the country, put their formal\n+# start to DST an hour later when they reached 24:00 -04.\n@@ -1305,5 +1324,13 @@\n-# From Paul Eggert (2019-09-01):\n-# The above says the Magallanes exception expires 2022-04-02 at 24:00,\n-# so in theory, they will revert to -04\/-03 after that.\n-# For now, assume that they will not revert,\n-# since they have extended the expiration date once already.\n+\n+# From Juan Correa (2022-04-02):\n+# I found there was a decree published last Thursday that will keep\n+# Magallanes region to UTC -3 \"indefinitely\". The decree is available at\n+# https:\/\/www.diariooficial.interior.gob.cl\/publicaciones\/2022\/03\/31\/43217-B\/01\/2108910.pdf\n+\n+# From Juan Correa (2022-08-09):\n+# the Internal Affairs Ministry (Ministerio del Interior) informed DST\n+# for America\/Santiago will start on midnight of September 11th;\n+# and will end on April 1st, 2023. Magallanes region (America\/Punta_Arenas)\n+# will keep UTC -3 \"indefinitely\"...  This is because on September 4th\n+# we will have a voting whether to approve a new Constitution....\n+# https:\/\/www.interior.gob.cl\/noticias\/2022\/08\/09\/comunicado-el-proximo-sabado-10-de-septiembre-los-relojes-se-deben-adelantar-una-hora\/\n@@ -1347,1 +1374,3 @@\n-Rule\tChile\t2019\tmax\t-\tSep\tSun>=2\t4:00u\t1:00\t-\n+Rule\tChile\t2019\t2021\t-\tSep\tSun>=2\t4:00u\t1:00\t-\n+Rule\tChile\t2022\tonly\t-\tSep\tSun>=9\t4:00u\t1:00\t-\n+Rule\tChile\t2023\tmax\t-\tSep\tSun>=2\t4:00u\t1:00\t-\n@@ -1360,3 +1389,3 @@\n-\t\t\t-4:00\t-\t-04\t1946 Jul 15\n-\t\t\t-4:00\t1:00\t-03\t1946 Sep  1 # central Chile\n-\t\t\t-4:00\t-\t-04\t1947 Apr  1\n+\t\t\t-4:00\t-\t-04\t1946 Jul 14 24:00\n+\t\t\t-4:00\t1:00\t-03\t1946 Aug 28 24:00 # central CL\n+\t\t\t-5:00\t1:00\t-04\t1947 Mar 31 24:00\n@@ -1374,1 +1403,2 @@\n-\t\t\t-4:00\t-\t-04\t1947 Apr  1\n+\t\t\t-4:00\t-\t-04\t1946 Aug 28 24:00\n+\t\t\t-5:00\t1:00\t-04\t1947 Mar 31 24:00\n@@ -1408,1 +1438,1 @@\n-# Milne gives 4:56:16.4 for Bogotá time in 1899; round to nearest.  He writes,\n+# Milne gives 4:56:16.4 for Bogotá time in 1899.  He writes,\n@@ -1415,0 +1445,1 @@\n+\t\t#STDOFF\t-4:56:16.4\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/southamerica","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -156,1 +156,1 @@\n-CA\t+5946-12014\tAmerica\/Dawson_Creek\tMST - BC (Dawson Cr, Ft St John)\n+CA\t+5546-12014\tAmerica\/Dawson_Creek\tMST - BC (Dawson Cr, Ft St John)\n@@ -426,1 +426,1 @@\n-UA\t+5026+03031\tEurope\/Kiev\tUkraine (most areas)\n+UA\t+5026+03031\tEurope\/Kyiv\tUkraine (most areas)\n","filename":"jdk\/test\/sun\/util\/calendar\/zi\/tzdata\/zone.tab","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+compiler.misc.where.description.intersection.1\n","filename":"langtools\/test\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,4 +24,3 @@\n-\/\/ key: compiler.misc.inferred.do.not.conform.to.upper.bounds\n-\/\/ key: compiler.misc.intersection.type\n-\/\/ key: compiler.misc.where.description.intersection.1\n-\/\/ key: compiler.misc.where.intersection\n+\/\/ key: compiler.misc.incompatible.upper.lower.bounds\n+\/\/ key: compiler.misc.where.description.typevar\n+\/\/ key: compiler.misc.where.typevar\n","filename":"langtools\/test\/tools\/javac\/diags\/examples\/WhereIntersection.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}