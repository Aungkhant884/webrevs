{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,1 @@\n-                    DESKeySpec.class.isAssignableFrom(keySpec)) {\n+                    keySpec.isAssignableFrom(DESKeySpec.class)) {\n","filename":"jdk\/src\/share\/classes\/com\/sun\/crypto\/provider\/DESKeyFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-                if (DESedeKeySpec.class.isAssignableFrom(keySpec)) {\n+                if (keySpec.isAssignableFrom(DESedeKeySpec.class)) {\n","filename":"jdk\/src\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKeyFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -148,1 +148,1 @@\n-            if (DHPublicKeySpec.class.isAssignableFrom(keySpec)) {\n+            if (keySpec.isAssignableFrom(DHPublicKeySpec.class)) {\n@@ -156,1 +156,1 @@\n-            } else if (X509EncodedKeySpec.class.isAssignableFrom(keySpec)) {\n+            } else if (keySpec.isAssignableFrom(X509EncodedKeySpec.class)) {\n@@ -166,1 +166,1 @@\n-            if (DHPrivateKeySpec.class.isAssignableFrom(keySpec)) {\n+            if (keySpec.isAssignableFrom(DHPrivateKeySpec.class)) {\n@@ -174,1 +174,1 @@\n-            } else if (PKCS8EncodedKeySpec.class.isAssignableFrom(keySpec)) {\n+            } else if (keySpec.isAssignableFrom(PKCS8EncodedKeySpec.class)) {\n","filename":"jdk\/src\/share\/classes\/com\/sun\/crypto\/provider\/DHKeyFactory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,1 +259,1 @@\n-            if (ECPublicKeySpec.class.isAssignableFrom(keySpec)) {\n+            if (keySpec.isAssignableFrom(ECPublicKeySpec.class)) {\n@@ -264,1 +264,1 @@\n-            } else if (X509EncodedKeySpec.class.isAssignableFrom(keySpec)) {\n+            } else if (keySpec.isAssignableFrom(X509EncodedKeySpec.class)) {\n@@ -272,1 +272,1 @@\n-            if (PKCS8EncodedKeySpec.class.isAssignableFrom(keySpec)) {\n+            if (keySpec.isAssignableFrom(PKCS8EncodedKeySpec.class)) {\n@@ -274,1 +274,1 @@\n-            } else if (ECPrivateKeySpec.class.isAssignableFrom(keySpec)) {\n+            } else if (keySpec.isAssignableFrom(ECPrivateKeySpec.class)) {\n","filename":"jdk\/src\/share\/classes\/sun\/security\/ec\/ECKeyFactory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -217,1 +217,1 @@\n-        if (DHPublicKeySpec.class.isAssignableFrom(keySpec)) {\n+        if (keySpec.isAssignableFrom(DHPublicKeySpec.class)) {\n@@ -244,1 +244,1 @@\n-        if (DHPrivateKeySpec.class.isAssignableFrom(keySpec)) {\n+        if (keySpec.isAssignableFrom(DHPrivateKeySpec.class)) {\n","filename":"jdk\/src\/share\/classes\/sun\/security\/pkcs11\/P11DHKeyFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-        if (DSAPublicKeySpec.class.isAssignableFrom(keySpec)) {\n+        if (keySpec.isAssignableFrom(DSAPublicKeySpec.class)) {\n@@ -242,1 +242,1 @@\n-        if (DSAPrivateKeySpec.class.isAssignableFrom(keySpec)) {\n+        if (keySpec.isAssignableFrom(DSAPrivateKeySpec.class)) {\n","filename":"jdk\/src\/share\/classes\/sun\/security\/pkcs11\/P11DSAKeyFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -287,1 +287,1 @@\n-        if (ECPublicKeySpec.class.isAssignableFrom(keySpec)) {\n+        if (keySpec.isAssignableFrom(ECPublicKeySpec.class)) {\n@@ -312,1 +312,1 @@\n-        if (ECPrivateKeySpec.class.isAssignableFrom(keySpec)) {\n+        if (keySpec.isAssignableFrom(ECPrivateKeySpec.class)) {\n","filename":"jdk\/src\/share\/classes\/sun\/security\/pkcs11\/P11ECKeyFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,2 +76,2 @@\n-        if (PKCS8EncodedKeySpec.class.isAssignableFrom(keySpec)\n-                || X509EncodedKeySpec.class.isAssignableFrom(keySpec)) {\n+        if (keySpec.isAssignableFrom(PKCS8EncodedKeySpec.class)\n+                || keySpec.isAssignableFrom(X509EncodedKeySpec.class)) {\n","filename":"jdk\/src\/share\/classes\/sun\/security\/pkcs11\/P11KeyFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-        if (RSAPublicKeySpec.class.isAssignableFrom(keySpec)) {\n+        if (keySpec.isAssignableFrom(RSAPublicKeySpec.class)) {\n@@ -285,18 +285,29 @@\n-        if (RSAPrivateCrtKeySpec.class.isAssignableFrom(keySpec)) {\n-            session[0] = token.getObjSession();\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PUBLIC_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-                new CK_ATTRIBUTE(CKA_PRIME_1),\n-                new CK_ATTRIBUTE(CKA_PRIME_2),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_1),\n-                new CK_ATTRIBUTE(CKA_EXPONENT_2),\n-                new CK_ATTRIBUTE(CKA_COEFFICIENT),\n-            };\n-            long keyID = key.getKeyID();\n-            try {\n-                token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n-            } finally {\n-                key.releaseKeyID();\n-            }\n+        if (key.sensitive || !key.extractable) {\n+            throw new InvalidKeySpecException(\"Key is sensitive or not extractable\");\n+        }\n+        \/\/ If the key is both extractable and not sensitive, then when it was converted into a P11Key\n+        \/\/ it was also converted into subclass of RSAPrivateKey which encapsulates all of the logic\n+        \/\/ necessary to retrieve the attributes we need. This sub-class will also cache these attributes\n+        \/\/ so that we do not need to query them more than once.\n+        \/\/ Rather than rewrite this logic and make possibly slow calls to the token, we'll just use\n+        \/\/ that existing logic.\n+        if (keySpec.isAssignableFrom(RSAPrivateCrtKeySpec.class)) {\n+            \/\/ All supported keyspecs (other than PKCS8EncodedKeySpec) descend from RSAPrivateCrtKeySpec\n+            if (key instanceof RSAPrivateCrtKey) {\n+                RSAPrivateCrtKey crtKey = (RSAPrivateCrtKey)key;\n+                return keySpec.cast(new RSAPrivateCrtKeySpec(\n+                    crtKey.getModulus(),\n+                    crtKey.getPublicExponent(),\n+                    crtKey.getPrivateExponent(),\n+                    crtKey.getPrimeP(),\n+                    crtKey.getPrimeQ(),\n+                    crtKey.getPrimeExponentP(),\n+                    crtKey.getPrimeExponentQ(),\n+                    crtKey.getCrtCoefficient(),\n+                    crtKey.getParams()\n+                ));\n+            } else { \/\/ RSAPrivateKey (non-CRT)\n+                if (!keySpec.isAssignableFrom(RSAPrivateKeySpec.class)) {\n+                    throw new InvalidKeySpecException\n+                        (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n+                }\n@@ -304,23 +315,6 @@\n-            KeySpec spec = new RSAPrivateCrtKeySpec(\n-                attributes[0].getBigInteger(),\n-                attributes[1].getBigInteger(),\n-                attributes[2].getBigInteger(),\n-                attributes[3].getBigInteger(),\n-                attributes[4].getBigInteger(),\n-                attributes[5].getBigInteger(),\n-                attributes[6].getBigInteger(),\n-                attributes[7].getBigInteger()\n-            );\n-            return keySpec.cast(spec);\n-        } else if (RSAPrivateKeySpec.class.isAssignableFrom(keySpec)) {\n-            session[0] = token.getObjSession();\n-            CK_ATTRIBUTE[] attributes = new CK_ATTRIBUTE[] {\n-                new CK_ATTRIBUTE(CKA_MODULUS),\n-                new CK_ATTRIBUTE(CKA_PRIVATE_EXPONENT),\n-            };\n-            long keyID = key.getKeyID();\n-            try {\n-                token.p11.C_GetAttributeValue(session[0].id(), keyID, attributes);\n-            } finally {\n-                key.releaseKeyID();\n-            }\n+                if (!(key instanceof RSAPrivateKey)) {\n+                    \/\/ We should never reach here as P11Key.privateKey() should always produce an instance\n+                    \/\/ of RSAPrivateKey when the RSA key is both extractable and non-sensitive.\n+                    throw new InvalidKeySpecException\n+                    (\"Key must be an instance of RSAPrivateKeySpec. Was \" + key.getClass());\n+                }\n@@ -328,5 +322,8 @@\n-            KeySpec spec = new RSAPrivateKeySpec(\n-                attributes[0].getBigInteger(),\n-                attributes[1].getBigInteger()\n-            );\n-            return keySpec.cast(spec);\n+                \/\/ fall through to RSAPrivateKey (non-CRT)\n+                RSAPrivateKey rsaKey = (RSAPrivateKey) key;\n+                return keySpec.cast(new RSAPrivateKeySpec(\n+                    rsaKey.getModulus(),\n+                    rsaKey.getPrivateExponent(),\n+                    rsaKey.getParams()\n+                ));\n+            }\n","filename":"jdk\/src\/share\/classes\/sun\/security\/pkcs11\/P11RSAKeyFactory.java","additions":44,"deletions":47,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -333,1 +333,1 @@\n-        if (SecretKeySpec.class.isAssignableFrom(keySpec)) {\n+        if (keySpec.isAssignableFrom(SecretKeySpec.class)) {\n@@ -337,1 +337,1 @@\n-                if (DESKeySpec.class.isAssignableFrom(keySpec)) {\n+                if (keySpec.isAssignableFrom(DESKeySpec.class)) {\n@@ -345,1 +345,1 @@\n-                if (DESedeKeySpec.class.isAssignableFrom(keySpec)) {\n+                if (keySpec.isAssignableFrom(DESedeKeySpec.class)) {\n","filename":"jdk\/src\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,1 +190,1 @@\n-                if (dsaPubKeySpec.isAssignableFrom(keySpec)) {\n+                if (keySpec.isAssignableFrom(dsaPubKeySpec)) {\n@@ -199,1 +199,1 @@\n-                } else if (x509KeySpec.isAssignableFrom(keySpec)) {\n+                } else if (keySpec.isAssignableFrom(x509KeySpec)) {\n@@ -215,1 +215,1 @@\n-                if (dsaPrivKeySpec.isAssignableFrom(keySpec)) {\n+                if (keySpec.isAssignableFrom(dsaPrivKeySpec)) {\n@@ -224,1 +224,1 @@\n-                } else if (pkcs8KeySpec.isAssignableFrom(keySpec)) {\n+                } else if (keySpec.isAssignableFrom(pkcs8KeySpec)) {\n","filename":"jdk\/src\/share\/classes\/sun\/security\/provider\/DSAKeyFactory.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -407,1 +407,1 @@\n-            if (RSA_PUB_KEYSPEC_CLS.isAssignableFrom(keySpec)) {\n+            if (keySpec.isAssignableFrom(RSA_PUB_KEYSPEC_CLS)) {\n@@ -413,1 +413,1 @@\n-            } else if (X509_KEYSPEC_CLS.isAssignableFrom(keySpec)) {\n+            } else if (keySpec.isAssignableFrom(X509_KEYSPEC_CLS)) {\n@@ -421,1 +421,1 @@\n-            if (PKCS8_KEYSPEC_CLS.isAssignableFrom(keySpec)) {\n+            if (keySpec.isAssignableFrom(PKCS8_KEYSPEC_CLS)) {\n@@ -423,1 +423,2 @@\n-            } else if (RSA_PRIVCRT_KEYSPEC_CLS.isAssignableFrom(keySpec)) {\n+            } else if (keySpec.isAssignableFrom(RSA_PRIVCRT_KEYSPEC_CLS)) {\n+                \/\/ All supported keyspecs (other than PKCS8_KEYSPEC_CLS) descend from RSA_PRIVCRT_KEYSPEC_CLS\n@@ -437,3 +438,13 @@\n-                } else {\n-                    throw new InvalidKeySpecException\n-                    (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n+                } else { \/\/ RSAPrivateKey (non-CRT)\n+                    if (!keySpec.isAssignableFrom(RSA_PRIV_KEYSPEC_CLS)) {\n+                        throw new InvalidKeySpecException\n+                            (\"RSAPrivateCrtKeySpec can only be used with CRT keys\");\n+                    }\n+\n+                    \/\/ fall through to RSAPrivateKey (non-CRT)\n+                    RSAPrivateKey rsaKey = (RSAPrivateKey) key;\n+                    return keySpec.cast(new RSAPrivateKeySpec(\n+                        rsaKey.getModulus(),\n+                        rsaKey.getPrivateExponent(),\n+                        rsaKey.getParams()\n+                    ));\n@@ -441,7 +452,0 @@\n-            } else if (RSA_PRIV_KEYSPEC_CLS.isAssignableFrom(keySpec)) {\n-                RSAPrivateKey rsaKey = (RSAPrivateKey)key;\n-                return keySpec.cast(new RSAPrivateKeySpec(\n-                    rsaKey.getModulus(),\n-                    rsaKey.getPrivateExponent(),\n-                    rsaKey.getParams()\n-                ));\n","filename":"jdk\/src\/share\/classes\/sun\/security\/rsa\/RSAKeyFactory.java","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com, Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8254717 8263404\n+ * @summary isAssignableFrom checks in KeyFactorySpi.engineGetKeySpec appear to be backwards.\n+ * @author Greg Rubin, Ziyi Luo\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.spec.*;\n+\n+public class KeyFactoryGetKeySpecForInvalidSpec {\n+\n+    \/\/ Test for 8263404: This method generates RSAPrivateKey (without Crt info) from a RSAPrivateCrtKey\n+    public static RSAPrivateKey privateCrtToPrivate(RSAPrivateCrtKey crtKey) {\n+        return new RSAPrivateKey() {\n+            @Override\n+            public BigInteger getPrivateExponent() {\n+                return crtKey.getPrivateExponent();\n+            }\n+\n+            @Override\n+            public String getAlgorithm() {\n+                return crtKey.getAlgorithm();\n+            }\n+\n+            @Override\n+            public String getFormat() {\n+                return crtKey.getFormat();\n+            }\n+\n+            @Override\n+            public byte[] getEncoded() {\n+                return crtKey.getEncoded();\n+            }\n+\n+            @Override\n+            public BigInteger getModulus() {\n+                return crtKey.getModulus();\n+            }\n+        };\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\", \"SunRsaSign\");\n+        kg.initialize(2048);\n+        KeyPair pair = kg.generateKeyPair();\n+\n+        KeyFactory factory = KeyFactory.getInstance(\"RSA\");\n+\n+        \/\/ === Case 1: private key is RSAPrivateCrtKey, keySpec is RSAPrivateKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        \/\/ Since RSAPrivateCrtKeySpec inherits from RSAPrivateKeySpec, we'd expect this next line to return an instance of RSAPrivateKeySpec\n+        \/\/ (because the private key has CRT parts).\n+        KeySpec spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateKeySpec.class);\n+        if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+        }\n+\n+        \/\/ === Case 2: private key is RSAPrivateCrtKey, keySpec is RSAPrivateCrtKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        spec = factory.getKeySpec(pair.getPrivate(), RSAPrivateCrtKeySpec.class);\n+        if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+        }\n+\n+        \/\/ === Case 3: private key is RSAPrivateKey, keySpec is RSAPrivateKeySpec\n+        \/\/ === Expected: return RSAPrivateKeySpec not RSAPrivateCrtKeySpec\n+        RSAPrivateKey notCrtKey = privateCrtToPrivate((RSAPrivateCrtKey)pair.getPrivate());\n+        \/\/ InvalidKeySpecException should not be thrown\n+        KeySpec notCrtSpec = factory.getKeySpec(notCrtKey, RSAPrivateKeySpec.class);\n+        if (notCrtSpec instanceof RSAPrivateCrtKeySpec) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateKeySpec not RSAPrivateCrtKeySpec\");\n+        }\n+        if (!(notCrtSpec instanceof RSAPrivateKeySpec)) {\n+            throw new Exception(\"Spec should be an instance of RSAPrivateKeySpec\");\n+        }\n+\n+        \/\/ === Case 4: private key is RSAPrivateKey, keySpec is RSAPrivateCrtKeySpec\n+        \/\/ === Expected: throw InvalidKeySpecException\n+        try {\n+            factory.getKeySpec(notCrtKey, RSAPrivateCrtKeySpec.class);\n+            throw new Exception(\"InvalidKeySpecException is expected but not thrown\");\n+        } catch (InvalidKeySpecException e) {\n+            \/\/ continue;\n+        }\n+\n+        \/\/ This next line should give an InvalidKeySpec exception\n+        try {\n+            spec = factory.getKeySpec(pair.getPublic(), FakeX509Spec.class);\n+            throw new Exception(\"InvalidKeySpecException is expected but not thrown\");\n+        } catch (final ClassCastException ex) {\n+            throw new Exception(\"InvalidKeySpecException is expected ClassCastException is thrown\", ex);\n+        } catch (final InvalidKeySpecException ex) {\n+            \/\/ Pass\n+        }\n+    }\n+\n+    public static class FakeX509Spec extends X509EncodedKeySpec {\n+        public FakeX509Spec(byte[] encodedKey) {\n+            super(encodedKey);\n+        }\n+    }\n+}\n","filename":"jdk\/test\/java\/security\/KeyFactory\/KeyFactoryGetKeySpecForInvalidSpec.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\n+# Configuration to run unit tests with NSS\n+# Marks private and secret keys as sensitive\n+\n+name = NSS\n+\n+slot = 1\n+\n+#showInfo = true\n+\n+library = ${pkcs11test.nss.lib}\n+\n+nssArgs = \"configdir='${pkcs11test.nss.db}' certPrefix='' keyPrefix='' secmod='secmod.db' flags=readOnly\"\n+\n+disabledMechanisms = {\n+  CKM_DSA_SHA224\n+  CKM_DSA_SHA256\n+  CKM_DSA_SHA384\n+  CKM_DSA_SHA512\n+  CKM_DSA_SHA3_224\n+  CKM_DSA_SHA3_256\n+  CKM_DSA_SHA3_384\n+  CKM_DSA_SHA3_512\n+  CKM_ECDSA_SHA224\n+  CKM_ECDSA_SHA256\n+  CKM_ECDSA_SHA384\n+  CKM_ECDSA_SHA512\n+  CKM_ECDSA_SHA3_224\n+  CKM_ECDSA_SHA3_256\n+  CKM_ECDSA_SHA3_384\n+  CKM_ECDSA_SHA3_512\n+}\n+\n+attributes = compatibility\n+\n+# NSS needs CKA_NETSCAPE_DB for DSA and DH private keys\n+# just put an arbitrary value in there to make it happy\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DSA) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n+\n+attributes(*,CKO_PRIVATE_KEY,CKK_DH) = {\n+  CKA_NETSCAPE_DB = 0h00\n+}\n+\n+# Everything above this line (with the exception of the comment at the top) is copy\/pasted from p11-nss.txt\n+\n+# Make all private keys sensitive\n+attributes(*,CKO_PRIVATE_KEY,*) = {\n+  CKA_SENSITIVE = true\n+}\n+\n+\n+# Make all secret keys sensitive\n+attributes(*,CKO_SECRET_KEY,*) = {\n+  CKA_SENSITIVE = true\n+}\n","filename":"jdk\/test\/sun\/security\/pkcs11\/nss\/p11-nss-sensitive.txt","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Amazon.com, Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.math.BigInteger;\n+import java.security.KeyFactory;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.Provider;\n+import java.security.PrivateKey;\n+import java.security.interfaces.RSAPrivateKey;\n+import java.security.interfaces.RSAPrivateCrtKey;\n+import java.security.spec.*;\n+\n+\/**\n+ * @test\n+ * @bug 8263404\n+ * @summary RSAPrivateCrtKeySpec is prefered for CRT keys even when a RsaPrivateKeySpec is requested.\n+ * @summary Also checks to ensure that sensitive RSA keys are correctly not exposed\n+ * @library ..\n+ * @run main\/othervm TestP11KeyFactoryGetRSAKeySpec\n+ * @run main\/othervm TestP11KeyFactoryGetRSAKeySpec sm rsakeys.ks.policy\n+ * @run main\/othervm -DCUSTOM_P11_CONFIG_NAME=p11-nss-sensitive.txt -DNO_DEIMOS=true -DNO_DEFAULT=true TestP11KeyFactoryGetRSAKeySpec\n+ *\/\n+\n+public class TestP11KeyFactoryGetRSAKeySpec extends PKCS11Test {\n+    private static boolean testingSensitiveKeys = false;\n+    public static void main(String[] args) throws Exception {\n+        testingSensitiveKeys = \"p11-nss-sensitive.txt\".equals(System.getProperty(\"CUSTOM_P11_CONFIG_NAME\"));\n+        main(new TestP11KeyFactoryGetRSAKeySpec(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        KeyPairGenerator kg = KeyPairGenerator.getInstance(\"RSA\", p);\n+        kg.initialize(2048);\n+        KeyPair pair = kg.generateKeyPair();\n+        PrivateKey privKey = pair.getPrivate();\n+\n+        KeyFactory factory = KeyFactory.getInstance(\"RSA\", p);\n+\n+        \/\/ If this is a sensitive key, then it shouldn't implement the RSAPrivateKey interface as that exposes sensitive fields\n+        boolean keyExposesSensitiveFields = privKey instanceof RSAPrivateKey;\n+        if (keyExposesSensitiveFields == testingSensitiveKeys) {\n+            throw new Exception(\"Key of type \" + privKey.getClass() + \" returned when testing sensitive keys is \" + testingSensitiveKeys);\n+        }\n+\n+        if (!testingSensitiveKeys) {\n+            \/\/ The remaining tests require that the PKCS #11 token actually generated a CRT key.\n+            \/\/ This is the normal and expected case, but we add an assertion here to detect a broken test due to bad assumptions.\n+            if (!(privKey instanceof RSAPrivateCrtKey)) {\n+                throw new Exception(\"Test assumption violated: PKCS #11 token did not generate a CRT key.\");\n+            }\n+        }\n+\n+        \/\/ === Case 1: private key is RSAPrivateCrtKey, keySpec is RSAPrivateKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        \/\/ Since RSAPrivateCrtKeySpec inherits from RSAPrivateKeySpec, we'd expect this next line to return an instance of RSAPrivateKeySpec\n+        \/\/ (because the private key has CRT parts).\n+        testKeySpec(factory, privKey, RSAPrivateKeySpec.class);\n+\n+        \/\/ === Case 2: private key is RSAPrivateCrtKey, keySpec is RSAPrivateCrtKeySpec\n+        \/\/ === Expected: return RSAPrivateCrtKeySpec\n+        testKeySpec(factory, privKey, RSAPrivateCrtKeySpec.class);\n+    }\n+\n+    private static void testKeySpec(KeyFactory factory, PrivateKey key, Class<? extends KeySpec> specClass) throws Exception {\n+        try {\n+            KeySpec spec = factory.getKeySpec(key, RSAPrivateKeySpec.class);\n+            if (testingSensitiveKeys) {\n+                throw new Exception(\"Able to retrieve spec from sensitive key\");\n+            }\n+            if (!(spec instanceof RSAPrivateCrtKeySpec)) {\n+                throw new Exception(\"Spec should be an instance of RSAPrivateCrtKeySpec\");\n+            }\n+        } catch (final InvalidKeySpecException ex) {\n+            if (testingSensitiveKeys) {\n+                \/\/ Expected exception so swallow it\n+                System.err.println(\"This exception is expected when retrieving sensitive properties from a sensitive PKCS #11 key.\");\n+                ex.printStackTrace();\n+            } else {\n+                throw ex;\n+            }\n+        }\n+    }\n+}\n","filename":"jdk\/test\/sun\/security\/pkcs11\/rsa\/TestP11KeyFactoryGetRSAKeySpec.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4853305\n+ * @bug 4853305 8254717\n@@ -110,3 +110,0 @@\n-        RSAPrivateKey rsaKey = (RSAPrivateKey)key;\n-        KeySpec rsaSpec3 = new RSAPrivateKeySpec(rsaKey.getModulus(), rsaKey.getPrivateExponent());\n-        PrivateKey key7 = kf.generatePrivate(rsaSpec3);\n@@ -114,1 +111,8 @@\n-        testKey(key6, key7);\n+        if (key instanceof RSAPrivateCrtKey) {\n+            RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey)key;\n+            KeySpec rsaSpec3 = new RSAPrivateCrtKeySpec(rsaKey.getModulus(),\n+                    rsaKey.getPublicExponent(), rsaKey.getPrivateExponent(), rsaKey.getPrimeP(), rsaKey.getPrimeQ(),\n+                    rsaKey.getPrimeExponentP(), rsaKey.getPrimeExponentQ(), rsaKey.getCrtCoefficient(), rsaKey.getParams());\n+            PrivateKey key7 = kf.generatePrivate(rsaSpec3);\n+            testKey(key6, key7);\n+        }\n","filename":"jdk\/test\/sun\/security\/rsa\/TestKeyFactory.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8146293 8242556\n+ * @bug 8146293 8242556 8254717\n@@ -101,3 +101,4 @@\n-        RSAPrivateKey rsaKey = (RSAPrivateKey)key;\n-        KeySpec rsaSpec3 = new RSAPrivateKeySpec(rsaKey.getModulus(),\n-            rsaKey.getPrivateExponent(), rsaKey.getParams());\n+        RSAPrivateCrtKey rsaKey = (RSAPrivateCrtKey)key;\n+        KeySpec rsaSpec3 = new RSAPrivateCrtKeySpec(rsaKey.getModulus(),\n+                rsaKey.getPublicExponent(), rsaKey.getPrivateExponent(), rsaKey.getPrimeP(), rsaKey.getPrimeQ(),\n+                rsaKey.getPrimeExponentP(), rsaKey.getPrimeExponentQ(), rsaKey.getCrtCoefficient(), rsaKey.getParams());\n","filename":"jdk\/test\/sun\/security\/rsa\/pss\/TestPSSKeySupport.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"}]}